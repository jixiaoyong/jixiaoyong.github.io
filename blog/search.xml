<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android开发常用设置</title>
    <url>/blog/posts/1c56d6b9/</url>
    <content><![CDATA[<h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><ul>
<li><p>国内较快的仓库：</p>
<p>  maven {url’<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;}">http://maven.aliyun.com/nexus/content/groups/public/&#39;}</a></p>
</li>
<li><p>RecyclerView添加依赖<br>注意RecyclerView的版本号要和当前工程中其他android.support包版本保持一致，否则虽然导入了对应的包，但是仍然无法正常使用。</p>
<p>  compile ‘com.android.support:recyclerview-v7:26+’</p>
</li>
<li><p>设置：<br>自动添加依赖：insert imports on paste: None<br>自动删除无用依赖：Optimize imports on the fly</p>
</li>
</ul>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul>
<li><p>设置ndk环境变量 &#x2F;etc&#x2F;profile</p>
<p>  #set ndk env<br>  NDKROOT&#x3D;&#x2F;home&#x2F;jixiaoyong&#x2F;AndroidDev&#x2F;Sdk&#x2F;ndk-bundle<br>  export PATH&#x3D;$NDKROOT:$PATH</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Android11文件分区存储在图片读写的适配</title>
    <url>/blog/posts/12cb887a/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>当APP目标版本是Android 10（API 29）及以后时，由于Android引入了分区存储，APP不能直接通过路径访问文件，访问外部存储空间中的媒体文件除了需要<code>READ_EXTERNAL_STORAGE</code> 或 <code>WRITE_EXTERNAL_STORAGE</code> 权限之外，需要通过其他APP分享的<code>Uri</code>读写文件，同理要给其余APP分享文件也许要通过<code>FileProvider</code>生成<code>Uri</code>并赋予对应的权限。</p>
<p>本文以从相册中获取图片、请求系统裁剪并返回图片为例展示对应的适配方法。</p>
<h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><p>1.<strong>从相册中获取图片</strong></p>
<p>从相册中获取到的图片<code>Uri</code>一般如：<code>content://raw//storage/emulated/0/DCIM/Camera/IMG_20210531_183008.HEIC</code></p>
<p>app内部要读取其内容的话，可以通过<code>context.getContentResolver().openInputStream(imageUri)</code></p>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> context.getContentResolver().query(uri, filePathColumn, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);<span class="comment">//从系统表中查询指定Uri对应的照片</span></span><br><span class="line">            cursor.moveToFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">columnIndex</span> <span class="operator">=</span> cursor.getColumnIndex(filePathColumn[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (columnIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                picturePath = cursor.getString(columnIndex); </span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>等方式读取，操作该图片。</p>
<p>2.<strong>将外部文件保存到本地并获取Uri</strong></p>
<p>由于上述方式获取到的<code>Uri</code>只对本APP赋予了权限，要是希望将此图片分享给第三方APP进一步加工处理，则可能出现第三方APP没有读写权限而导致操作失败的情况，为了避免这种情况，可以将获取到的图片缓存到APP私有目录，并且重新生成<code>Uri</code>并赋予将要处理该图的第三方APP对应权限。</p>
<p>将外部文件缓存本地的步骤参考第一步操作即可自行完成，主要讲解一下如何将对外分享的<code>Uri</code>赋予读写权限。</p>
<p>下面这个方法在不同系统分别采用不同方式获取文件对应的<code>Uri</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Uri <span class="title function_">getUriForFile</span><span class="params">(Context context, File file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        <span class="keyword">return</span> FileProvider.getUriForFile(context, <span class="string">&quot;com.your.app.packagename.fileprovider&quot;</span>, file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>com.your.app.packagename.fileprovider</code>是<a href="https://developer.android.google.cn/reference/androidx/core/content/FileProvider"><code>FileProvider</code></a>的<code>authorities</code>。</p>
<p>要使用<code>FileProvider</code>可以参考<a href="https://developer.android.google.cn/reference/androidx/core/content/FileProvider#ProviderDefinition">定义FileProvider</a>操作，一般只需要修改<code>authorities</code>即可，同时如果是开发Android库，为了避免与主工程已有的<code>FileProvider</code>冲突，可以继承<code>FileProvider</code>类并修改下文中<code>name</code>字段。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">&quot;com.mydomain.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">&quot;@xml/file_paths&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时，为了定义此<code>FileProvider</code>可以使用的文件目录范围，可以在<code>res/xml</code>文件夹中新建<code>file_paths.xml</code>并做如下配置，也可参考官方文档或者<a href="https://www.jianshu.com/p/6192f04eca11">Android N 7.0 FileProvider 兼容适配 原理解析</a>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;camera_photos&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span> // 对应<span class="attr">Context</span>#<span class="attr">getExternalFilesDir</span>(<span class="attr">String</span>)获取的路径，一般为存储卡中<span class="attr">Android</span>/<span class="attr">data</span>/<span class="attr">com.your.app.packagename</span>/<span class="attr">file</span>下面的目录</span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;external_files&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">path</span>=<span class="string">&quot;.&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.<strong>对外分享有权限的Uri</strong></p>
<p>对于上述步骤获取到的图片Uri赋予权限有两种方式：</p>
<p>第一种，通过<code>Intent</code>传递出去的<code>imgUri</code>，可以使用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line">intent.setDataAndType(imgUri, <span class="string">&quot;image/*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是这种只适用于主动分享出去的文件，在调用第三方APP裁剪的场景中，一般还需要一个<code>outPutUri</code>用于保存裁剪之后的图片，对于这种场景，可以查询可能会调用的APP并赋予其访问权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">    List&lt;ResolveInfo&gt; resInfoList = context.getPackageManager()</span><br><span class="line">            .queryIntentActivities(intent, PackageManager.MATCH_ALL);</span><br><span class="line">    <span class="keyword">for</span> (ResolveInfo resolveInfo : resInfoList) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> resolveInfo.activityInfo.packageName;</span><br><span class="line">        contextWrap.getActivity().grantUriPermission(packageName, outPutUri,</span><br><span class="line">                Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样不管是分享出去的原图，还是裁剪之后保存的图片都给第三方APP赋予了权限，保证其可以正常访问。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://developer.android.google.cn/reference/androidx/core/content/FileProvider">https://developer.android.google.cn/reference/androidx/core/content/FileProvider</a></p>
<p><a href="https://www.jianshu.com/p/6192f04eca11">Android N 7.0 FileProvider 兼容适配 原理解析</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android AlarmManager设置重复任务</title>
    <url>/blog/posts/5754fcd2/</url>
    <content><![CDATA[<p>近期有一个实现定时启动APP提醒用户的需求，一番比较之后觉得用闹钟<code>AlarmManager</code>实现比较合适，本文是对此过程的梳理，属于比较基础性的内容。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>需求需要实现</p>
<blockquote>
<p>“每天在指定时间范围内,循环提示用户直到满足指定的条件”</p>
</blockquote>
<p>拆分需求：</p>
<ol>
<li>每天都要提醒</li>
<li>在时间范围内一直循环</li>
<li>满足条件后结束当天循环</li>
</ol>
<h1 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h1><p>Android中可以用到的循环任务实现有<code>Handler</code>、<code>Timer</code>、<code>ScheduledExecutorService</code>（这三个可以看<a href="https://blog.csdn.net/qq_27489007/article/details/79220609">这里</a>），还有最近的<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager"><code>WorkManager</code></a>和我们要用到的<a href="https://developer.android.google.cn/training/scheduling/alarms"><code>AlarmManager</code></a>。</p>
<blockquote>
<p> WorkManager offers a backwards compatible (API level 14+) API leveraging <a href="https://developer.android.google.cn/reference/android/app/job/JobScheduler"><code>JobScheduler</code></a> API (API level 23+) and above to help optimize battery life and batch jobs and a combination of <a href="https://developer.android.google.cn/reference/android/app/AlarmManager"><code>AlarmManager</code></a> &amp; <a href="https://developer.android.google.cn/reference/android/app/BroadcastReceiver"><code>BroadcastReceiver</code></a> on lower devices. </p>
</blockquote>
<p>这几个方案中，前三者都需要APP在前台运行，<code>WorkManager</code>和<code>AlarmManager</code>则在APP退出之后也可以使用，甚至在低版本上<code>WorkManager</code>底层也是通过<code>AlarmManager</code>实现的。</p>
<p><code>WorkManager</code>主要倾向于保证任务在APP退出，甚至设备关机重启等情况下也会被执行，虽然也提供循环任务的，但是无法确保在精确的时间得到执行，且最小间隔15min。</p>
<p>相比之下，<code>AlarmManager</code>可以确保任务在指定时间（精确的时间）得到执行，并且对于循环的间隔也更加灵活。</p>
<p><img src="https://developer.android.google.cn/images/guide/background/bg-job-choose.svg" alt="Android推荐选择方案"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>据Android官网介绍，闹钟主要用于在应用程序生命周期之外进行定时操作。</p>
<p>闹钟具有以下特征：</p>
<blockquote>
<ul>
<li>它们可让您按设定的时间和&#x2F;或间隔触发 intent。</li>
<li>您可以将它们与广播接收器结合使用，以启动服务以及执行其他操作。</li>
<li>它们在应用外部运行，因此即使应用未运行，或设备本身处于休眠状态，您也可以使用它们来触发事件或操作。</li>
<li>它们可以帮助您最大限度地降低应用的资源要求。您可以安排定期执行操作，而无需依赖定时器或持续运行后台服务。</li>
</ul>
</blockquote>
<p>需要注意的是，Android为了避免重复闹钟可能带来的性能消耗，推荐使用不是很精确的<code>setInexactRepeating()</code>， 而不是精确的<code>setRepeating()</code>，并且在<code>API19+</code>之后的所有的重复闹钟都不是精确的，如果需要精确闹钟需要使用 <code>setWindow(int, long, long, android.app.PendingIntent)</code> 或<code>setExact(int, long, android.app.PendingIntent)</code>。 重复闹钟具有以下特征：</p>
<blockquote>
<ul>
<li>闹钟类型。要了解详情，请参阅<a href="https://developer.android.google.cn/training/scheduling/alarms#type">选择闹钟类型</a>。</li>
<li>触发时间。如果您指定的触发时间为过去的时间，则闹钟会立即触发。</li>
<li>闹钟的间隔。例如，每天一次、每小时一次、每 5 分钟一次，等等。</li>
<li>闹钟触发的待定 intent。当您设置了使用同一待定 intent 的第二个闹钟时，它会替换原始闹钟。</li>
</ul>
</blockquote>
<h2 id="闹钟类型"><a href="#闹钟类型" class="headerlink" title="闹钟类型"></a>闹钟类型</h2><p>闹钟有两个类型：</p>
<ol>
<li><p>距离系统启动后的时间，主要用于“间隔多久重复一次”这样的需求</p>
<p><code>ELAPSED_REALTIME</code> 距离开机时间多久后启用闹钟，如果系统在休眠中则不会唤醒</p>
<p><code>ELAPSED_REALTIME_WAKEUP</code> 在系统休眠时也会唤醒系统</p>
</li>
<li><p>精确的时间UTC，主要用于“在当天下午8点整开始”等这样的需求</p>
<p><code>RTC</code> 在指定的时间触发闹钟，不会唤醒机器</p>
<p><code>RTC_WAKEUP</code> 在指定时间触发闹钟，并且唤醒设备</p>
</li>
</ol>
<h2 id="触发时间"><a href="#触发时间" class="headerlink" title="触发时间"></a>触发时间</h2><p>闹钟触发的时间，分为从设备上次启动时间和精准时间两种。</p>
<p>如果触发的时间早于当前系统时间的话，系统会根据过去的时间和重复间隔选择一个合适的时间来触发（有几分钟内的误差）。</p>
<p>从实际运行来看，使用<code>ELAPSED_*</code>的基本上会立即（几秒钟）触发该闹钟，并且每次循环间隔有几毫秒的误差。</p>
<p>使用<code>RTC_*</code>则会在刚开始的两三次出现间隔时间小于指定时间的情况，后期稳定：</p>
<p>设置的闹钟间隔为10分钟，闹钟开始时间早于当前时间，唤醒结果如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">alarmMgr.setRepeating(AlarmManager.RTC_WAKEUP,</span><br><span class="line">            calendar.timeInMillis,</span><br><span class="line">            <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>,</span><br><span class="line">            alarmIntent</span><br><span class="line">        )</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">46.696</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">16</span>:<span class="number">26.634</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">24</span>:<span class="number">26.765</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">26.579</span> </span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">46.785</span> </span><br></pre></td></tr></table></figure>

<h2 id="间隔时间"><a href="#间隔时间" class="headerlink" title="间隔时间"></a>间隔时间</h2><p>间隔时间有两种：</p>
<ol>
<li><code>AlarmManager interval</code> 如果设置的是<code>setInexactRepeating()</code>，则需要设置<code>AlarmManager </code>指定的几种间隔时间。</li>
<li>任意时间 <code>setRepeating()</code>方法可以使用任意时间</li>
</ol>
<h2 id="待定的intent"><a href="#待定的intent" class="headerlink" title="待定的intent"></a>待定的intent</h2><blockquote>
<p>当您设置了使用同一待定 intent 的第二个闹钟时，它会替换原始闹钟 </p>
</blockquote>
<p>待定的<code>Intent</code>是一个<code>PendingIntent</code>，可以用来打开<code>Service</code>，<code>Activity</code>，<code>Broadcast</code>等等。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPendingIntent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        context: <span class="type">Context</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        action: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: PendingIntent &#123;</span><br><span class="line">        <span class="keyword">return</span> PendingIntent.getBroadcast(context, requestCode, Intent(action), <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>requestCode</code>，当不需要该闹钟时可以根据这个来取消。</p>
<h2 id="取消闹钟"><a href="#取消闹钟" class="headerlink" title="取消闹钟"></a>取消闹钟</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">alarmManager.cancel(getPendingIntent(context,ACTION,RequestCode))</span><br></pre></td></tr></table></figure>

<h2 id="在重启时恢复闹钟"><a href="#在重启时恢复闹钟" class="headerlink" title="在重启时恢复闹钟"></a>在重启时恢复闹钟</h2><p>由于闹钟会在设备关机的时候被取消，所以需要监听设备开机广播（<code>android.intent.action.BOOT_COMPLETED</code>），并且恢复闹钟。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="设置一个每天指定时间循环的闹钟"><a href="#设置一个每天指定时间循环的闹钟" class="headerlink" title="设置一个每天指定时间循环的闹钟"></a>设置一个每天指定时间循环的闹钟</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupDailyAlarmClock</span><span class="params">( context: <span class="type">Context</span>,startTime: <span class="type">Pair</span>&lt;<span class="type">Int</span>, <span class="built_in">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> alarmMgr = context.getSystemService(Context.ALARM_SERVICE) <span class="keyword">as</span> AlarmManager</span><br><span class="line">        <span class="keyword">val</span> alarmIntent = getPendingIntent(</span><br><span class="line">            context,</span><br><span class="line">            BROADCAST_ACTION_REPEAT,</span><br><span class="line">            RequestCode.START_REPEAT_INVENTORY</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// Set the alarm to start at xx:xx</span></span><br><span class="line">        <span class="keyword">val</span> calendar: Calendar = Calendar.getInstance().apply &#123;</span><br><span class="line">            timeInMillis = System.currentTimeMillis()</span><br><span class="line">            <span class="keyword">set</span>(Calendar.HOUR_OF_DAY, startTime.first)</span><br><span class="line">            <span class="keyword">set</span>(Calendar.MINUTE, startTime.second)</span><br><span class="line">            <span class="keyword">set</span>(Calendar.SECOND, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 day</span></span><br><span class="line">        alarmMgr.setRepeating(</span><br><span class="line">            AlarmManager.RTC_WAKEUP,</span><br><span class="line">            calendar.timeInMillis,</span><br><span class="line">            AlarmManager.INTERVAL_DAY,</span><br><span class="line">            alarmIntent</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在每天指定时间到了之后，开始设置一个间隔10分钟唤醒一次的闹钟，直到超时或者满足指定的条件后取消该闹钟。</p>
<h2 id="监听每日循环的闹钟"><a href="#监听每日循环的闹钟" class="headerlink" title="监听每日循环的闹钟"></a>监听每日循环的闹钟</h2><p>监听其发送的广播<code>BROADCAST_ACTION_REPEAT</code>。</p>
<p>启用当日循环闹钟：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setupRepeatAlarmClock</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = SharePreferencesUtils.sharedPreferences</span><br><span class="line">        .getString(KEY_STARTT_TIME,DEF_INVENTORY_TIME)?.toFormatTime() ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> alarmMgr = context.getSystemService(Context.ALARM_SERVICE) <span class="keyword">as</span> AlarmManager</span><br><span class="line">    <span class="keyword">val</span> alarmIntent = getPendingIntent(</span><br><span class="line">        context,</span><br><span class="line">        BROADCAST_ACTION_START,</span><br><span class="line">        RequestCode.START_INVENTORY</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> tenMinutes = DEF_INVENTORY_DURATION * <span class="number">60</span> * <span class="number">1000</span></span><br><span class="line">    alarmMgr.setRepeating(</span><br><span class="line">        AlarmManager.ELAPSED_REALTIME_WAKEUP,<span class="comment">//从开机后多久</span></span><br><span class="line">        SystemClock.elapsedRealtime(),<span class="comment">//当前自开机完后的时间</span></span><br><span class="line">        tenMinutes,<span class="comment">//每十分钟循环一次</span></span><br><span class="line">        alarmIntent</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在广播接收器中收听到<code>BROADCAST_ACTION_START</code>后去开启任务</p>
<h2 id="条件满足后关闭当日循环闹钟"><a href="#条件满足后关闭当日循环闹钟" class="headerlink" title="条件满足后关闭当日循环闹钟"></a>条件满足后关闭当日循环闹钟</h2><p>在收到<code>BROADCAST_ACTION_START</code>后检测到已经超时或其他满足取消条件的情况，则取消任务。</p>
<p>或者可以再订一个结束时间的闹钟，到时间后取消当日循环闹钟。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> alarmManager = getSystemService(Context.ALARM_SERVICE) <span class="keyword">as</span> AlarmManager</span><br><span class="line">alarmManager.cancel(pIntent)</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>pIntent</code>需要与设置闹钟时的<code>PendingIntent</code>一致(满足<code>Intent.filterEquals()</code>的条件)。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_27489007/article/details/79220609">Android定时任务及循环任务基础大集合</a></p>
<p><a href="https://developer.android.google.cn/training/scheduling/alarms">安排重复闹钟 Android官网</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android事件分发</title>
    <url>/blog/posts/c0fefed0/</url>
    <content><![CDATA[<p>Android事件分发，指手指点击屏幕后，从Activity、ViewGroup到View的一系列过程。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android系统的窗口机制如下图：</p>
<p>Activity内有一个Window对象，其实现类是PhoneWindow；</p>
<p>DecorView为顶层View，DecorView是一个FrameLayout，其中有TitleView和ContentView；</p>
<p><img src="https://github.com/jixiaoyong/jixiaoyong.github.io/blob/master/images/blog/2018-04/AndroidDispatchTouchEvent.png?raw=true" alt="Android系统窗口管理机制"></p>
<p>TitleView为标题栏，ContentView就是平时在Activity的onCreate()方法中设置的视图，TitleView可以用<code>this.requestWindowFeature(Window.FEATURE_NO_TITLE);</code>隐藏掉，但是必须注意要在setContentView()之前，原因如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">    getWindow().setContentView(view);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="点击事件-Activity-–-gt-ViewGroup"><a href="#点击事件-Activity-–-gt-ViewGroup" class="headerlink" title="点击事件 Activity –&gt; ViewGroup"></a>点击事件 Activity –&gt; ViewGroup</h1><p>点击事件发生后，首先被调用的是<code>Activity.dispatchTouchEvent()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其内部先调用了<code>getWindow().superDispatchTouchEvent(ev)</code>这个方法，getWindow()返回的mWindow是PhoneWindow的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window, activityConfigCallback);</span><br></pre></td></tr></table></figure>

<p>再看看PhoneWindow.superDispatchTouchEvent()方法，显然又调用了DecorView的superDispatchTouchEvent()方法,在该方法中，调用了FrameLayout.dispatchKeyEvent(event)，此时<strong>点击事件从Activity转到了ViewGroup中</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DecorView extends FrameLayout</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// Give priority to closing action modes if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">        <span class="comment">// Back cancels action modes first.</span></span><br><span class="line">        <span class="keyword">if</span> (mPrimaryActionMode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                mPrimaryActionMode.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="点击事件-ViewGroup-–-gt-View"><a href="#点击事件-ViewGroup-–-gt-View" class="headerlink" title="点击事件 ViewGroup –&gt; View"></a>点击事件 ViewGroup –&gt; View</h1><p>ViewGroup与事件分发的方法有三个：</p>
<ul>
<li><code>dispatchTouchEvent()</code>  分发事件，每次都会被调用</li>
<li><code>onInterceptTouchEvent()</code>  拦截事件，如果当前ViewGroup已经决定拦截事件，那么不会再调用</li>
<li><code>onTouchEvent()</code>  处理点击事件,如果设置了<code>mOnTouchListener</code>的话，则不会回调本方法</li>
</ul>
<p>这三个主要方法关系如下（伪代码，来自《Android开发艺术探索》）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次点击事件回调该方法</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;<span class="comment">//viewGroup会回调该方法，确认是否拦截点击事件</span></span><br><span class="line">        result = onTouchEvent(event)<span class="comment">//对点击事件进行处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = child.dispatchTouchEvent(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ViewGroup.dispatchTouchEvent()被调用后，会通过一系列条件判断是由ViewGroup拦截该事件，还是由子View消耗该事件。</p>
<p>主要流程分为两部分</p>
<p><strong>1.检查是否需要拦截</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/view/ViewGroup.java line2567-2582</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">            <span class="comment">// Check for interception.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);<span class="comment">//在这里调用了onInterceptTouchEvent()方法，如果已经拦截了</span></span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">                <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次ACTION_DOWN事件都需要调用<code>onInterceptTouchEvent()</code>方法判断是否需要拦截</li>
<li>其他MotionEvent事件，如果有能处理点击事件的子View（<code>mFirstTouchTarget != null</code>）且<code>disallowIntercept</code>为false也需要调用<code>onInterceptTouchEvent()</code>方法判断是否需要拦截，否则不需要拦截</li>
<li>其余情况都需要拦截（没有可以处理点击事件的子View，并且不是ACTION_DOWN事件）</li>
</ul>
<p>如果ViewGroup判断要拦截该事件，则会调用<code>dispatchTransformedTouchEvent()</code>（后面会再讲到）通过他调用继承自View的<code>dispatchTouchEvent(MotionEvent event)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                       TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>否则就需要遍历其子View</p>
<p><strong>2.遍历ViewGroup的所有子View，寻找一个可以处理点击事件的子View</strong></p>
<ul>
<li><code>dispatchTransformedTouchEvent()</code>   调用了子View的<code>dispatchTouchEvent()</code></li>
<li><code>addTouchTarget()</code>   对<code>mFirstTouchTarget </code>进行更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. Check for interception.判断是否需要拦截</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="literal">null</span>) &#123;<span class="comment">//mFirstTouchTarget表示能处理点击事件的子View</span></span><br><span class="line">            <span class="comment">//FLAG_DISALLOW_INTERCEPT每次ACTION_DOWN都会被重置</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);<span class="comment">//调用拦截方法</span></span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//2.遍历子View，寻找可以处理点击事件的子View</span></span><br><span class="line">    	<span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">       		 <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                     <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                     ...</span><br><span class="line">                     newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                     alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">        	 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatchTransformedTouchEvent()方法如下，由于<code>child != null</code>其内部调用<code>child.dispatchTouchEvent(event)</code>方法，如此循环直到子View是一个View（单就ViewGroup和View而论）即<strong>将点击事件从ViewGroup分发到了View</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel,</span></span><br><span class="line"><span class="params">            View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">        handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有子View可以处理点击事件，在<code>addTouchTarget()</code>方法内部对<code>mFirstTouchTarget</code>进行更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="点击事件-View内部"><a href="#点击事件-View内部" class="headerlink" title="点击事件 View内部"></a>点击事件 View内部</h1><p>View的点击事件分发主要涉及到两个方法：</p>
<ul>
<li><code>dispatchTouchEvent()</code></li>
<li><code>onTouchEvent()</code></li>
</ul>
<p>其点击事件分发用伪代码表示如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(mListenerInfo.mOnTouchListener.onTouch(<span class="built_in">this</span>, event))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见View的dispatchTouchEvent()方法中，如果View注册了OnTouchListener则会先执行<code>mOnTouchListener.onTouch()</code>方法,如果该方法返回false才会执行<code>onTouchEvent()</code>。</p>
<p>在看onTouchEvent()方法：</p>
<ul>
<li>如果View处于<strong>不可用状态</strong>下，也会消耗点击事件，只不过没有反应</li>
<li>如果注册了OnClickListener会在ACTION_UP的时候调用<code>mOnClickListener.onClick(this)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(CLICKABLE&amp;&amp;LONG_CLICKABLE)&#123;<span class="comment">//LONG_CLICKABLE默认为false，CLICKABLE、LONG_CLICKABLE会在设置点击事件时被设置为true</span></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:&#123;</span><br><span class="line">                ...</span><br><span class="line">                performClick();<span class="comment">//如果注册了OnClickListener则会调用其onClick()方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">performClick</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mListenerInfo.mOnClickListener.onClick(<span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个Android的时间分发始于Activity,经过PhoneWindow、DecorView到达ViewGroup，再逐层分发到View中。</p>
<p>如果底层没有处理点击事件，则又一层层向上返回，直到最顶层消耗掉点击事件。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Android开发艺术探索》</p>
<p><a href="http://androidxref.com/">Android源代码</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 5.x以下加载MultiDex白屏的处理优化</title>
    <url>/blog/posts/caa169b7/</url>
    <content><![CDATA[<p>当APP的minSdkVersion低于Android 5时，在方法数大于65536时，需要将APP打包为多个DEX文件，此时需要添加MultiDex依赖。</p>
<p>官方方法如下：</p>
<p>1.<code>build.gradle</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion <span class="number">15</span> </span><br><span class="line">        targetSdkVersion <span class="number">28</span></span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile <span class="string">&#x27;com.android.support:multidex:1.0.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<code>MyApplication</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方式❶：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">MultiDexApplication</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">方式❷：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">SomeOtherApplication</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">attachBaseContext</span><span class="params">(Context base)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.attachBaseContext(base);</span><br><span class="line">     MultiDex.install(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，为了避免一些启动期间需要的任何类未在主 DEX 文件中提供而导致<code>java.lang.NoClassDefFoundError</code>，还需要告诉AS将这些类添加到主DEX文件中：</p>
<p>3.<code>build.gradle</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            ❶ multiDexKeepFile file(<span class="string">&#x27;multidex-config.txt&#x27;</span>)</span><br><span class="line">            ❷ multiDexKeepProguard(<span class="string">&#x27;multidex-config.pro&#x27;</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//multidex-config.txt</span></span><br><span class="line">com<span class="regexp">/example/</span>MyClass.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">com</span><span class="regexp">/example/</span>MyOtherClass.<span class="keyword">class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//multidex-config.pro</span></span><br><span class="line">-keep <span class="keyword">class</span> <span class="title class_">com</span>.example.MyClass</span><br><span class="line">-keep <span class="keyword">class</span> <span class="title class_">com</span>.example.MyClassToo</span><br><span class="line">-keep <span class="keyword">class</span> <span class="title class_">com</span>.example.** &#123; *; &#125; <span class="comment">// All classes in the com.example package</span></span><br></pre></td></tr></table></figure>

<p>但是在实际运行中，Android 4.x的系统会在APP安装后第一次启动时，在<code>MultiDex.install(this)</code>方法中进行DEX文件合并优化等耗时操作（主线程），往往会持续数十秒以上，从而导致APP第一次启动时长时间白屏，十分影响体验。</p>
<p>查阅相应的资料后大体有以下几种方案</p>
<ol>
<li><p>设置主Activity的背景为透明色</p>
<p>这样当用户点击APP图标启动APP时，在主Activity启动之前看到的一直是桌面的样子而非白屏，但这只是一种障眼法，用户可能会以为系统卡顿，体验并不好。</p>
</li>
<li><p>在Application中检测到是第一次启动的话，新开一个进程并在其中进行<code>MultiDex.install(this)</code></p>
<p>这种方法在主进程启动时，检测到尚未进行MultidexOpt，则阻塞当前进程，新开一个进程，在其中加载一个Activity，并在后台进程运行<code>MultiDex.install(this)</code>，当MultidexOpt完成后再关闭当前进程，返回主进程继续正常开启APP。</p>
<p>由于主进程被阻塞的同时成为了后台进程，所以也不会触发ANR，此外子进程中的过渡Activity也只用到了基本的类，所以基本不用担心会触发<code>java.lang.NoClassDefFoundError</code>，而且过渡Activity可以展示进度、提示等用户友好的页面，相对来说体验也好了很多。</p>
<p>但是这种方法从子进程返回主进程涉及到进程间通信，以及主进程的主Activity启动时生命周期会出现异常(<code>onCreate()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code> -&gt; <code>onPause()</code>-&gt;<code>onResume()</code>)，仍然不是很好的解决方法。</p>
</li>
</ol>
<p>结合上述的分析后，可以看到这种问题的优化思路主要在于如何在避免<code>java.lang.NoClassDefFoundError</code>的同时，在后台可靠的通过<code>MultiDex.install(this)</code>执行MultidexOpt操作。</p>
<p>通过以上方案1和2的结合，可以有一个比较完美的解决方案：</p>
<ol>
<li>方案2中在过渡Activity的后台线程进行MultidexOpt操作思路是正确的，但是不需要再单独开一个进程，我们完全可以将其当做主进程的第一个Activity，等待MultidexOpt操作完成后再跳转到主Activity并finish掉本Activity，这样主Activity的生命周期也不会受影响。</li>
<li>这种情况下在部分低端机上，过渡Activity到主Activity跳转时会出现短暂黑屏，我们可以在过渡页面将Activity切换动画设置为渐变效果，并将主Activity背景设置为透明，待主Activity完全加载好后再将背景切换为普通模式。</li>
</ol>
<p>综上处理，我们的Application无需改动，甚至主Activity也可以不做改动，只需要添加一个过渡页面为启动Activity，在其中后台进行MultidexOpt，等DEX文件处理完毕后再加载主Activity。对项目改动少并且逻辑较为简单。</p>
<p>注：</p>
<ol>
<li>MultiDexOpt即执行<code>MultiDex.install(getApplication());</code>方法；</li>
<li>需要注意过渡Activity尽量少的使用类，并且要确保过渡Activity可能会调用到的类加载到了主dex文件中。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://developer.android.google.cn/studio/build/multidex.html?hl=zh-CN">配置方法数超过 64K 的应用</a></p>
<p><a href="https://www.jianshu.com/p/c2d7b76ff063">Android MultiDex初次启动APP优化方案优雅的实现</a></p>
<p><a href="https://www.zybuluo.com/946898963/note/1219741">MultiDex深入学习</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android paint绘制text</title>
    <url>/blog/posts/e5860bb5/</url>
    <content><![CDATA[<p>Android中绘制文字的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted</span></span><br><span class="line"><span class="comment"> * based on the Align setting in the paint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text The text to be drawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x The x-coordinate of the origin of the text being drawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y The y-coordinate of the baseline of the text being drawn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paint The paint used for the text (e.g. color, size, style)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawText</span><span class="params">(<span class="meta">@NonNull</span> String text, <span class="type">float</span> x, <span class="type">float</span> y, <span class="meta">@NonNull</span> Paint paint)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.drawText(text, x, y, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>y</code>是<strong>文字baseline的y坐标</strong>。</p>
<p>下图表示<code>Paint.FontMetrics</code>中存储的文字的各种信息（来源：<a href="https://www.jianshu.com/p/c1575636741e">简书</a>）：<br><img src="https://jixiaoyong.github.io/images/20200407220410.png"></p>
<p>我们没法直接获取到<code>baseline的坐标</code>，所以只能从另外一个角度考虑：<br>因为在绘制文字时，文字的上下中心（即上图中的<code>center</code>）是确定的，我们只要计算出<code>center</code>到<code>baseline</code>之间的偏移量，就可以计算出<code>baseline的y坐标</code>。</p>
<p>又根据这个<a href="http://www.imooc.com/article/277490?block_id=tuijian_wz">文章</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基线到中线的距离 = (descent + ascent) / 2 - descent = (ascent - descent) / 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>(descent + ascent) / 2</code>是中线center的值，而根据上图可知<code>(descent + ascent) / 2 - descent</code>的值就是baseline到center的距离。</p>
</blockquote>
<p>所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baseline的y坐标 = 文字的上下高度中心 + baseline的竖坐标和文字上下实际中心的偏移量</span><br><span class="line">                = center.y + 基线到中线的距离</span><br><span class="line">                = center.y + (ascent - descent) / 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个<code>center.y</code>根据场景不同可以是一行的行中心（文字在一行居中显示），或者控件的上下中心（文字在控件上下居中）</p>
</blockquote>
<p>得出结论：</p>
<p>由于android绘制文字时，<strong>并不是从文字高度的中间开始绘制，而是从baseline开始绘制</strong>。所以在绘制文字时，为了使文字高度居中（在所指定的空间内居中，比如某一行，就在该行限定的高度内居中显示；某一控件，则整个控件的上下中间显示），需要在计算出来的<strong>文字上下中心的y坐标基础上加上baseline到文字中线的偏移量</strong>。</p>
<p>除此之外，也可以类比得到：<code>baseline.y = center.y + (bottom.y - top.y) / 2 - bottom.y</code></p>
<blockquote>
<p>基线（baeseline），坡顶（ascenter）,坡底（descenter）</p>
<p>上坡度（ascent），下坡度（descent）</p>
<p>行间距（leading）：坡底到下一行坡顶的距离</p>
<p>字体的高度＝上坡度＋下坡度＋行间距</p>
<p><a href="https://blog.csdn.net/hanyongbai/article/details/84418369">https://blog.csdn.net/hanyongbai/article/details/84418369</a></p>
</blockquote>
<p>参考文章：<br><a href="https://www.jianshu.com/p/c1575636741e">https://www.jianshu.com/p/c1575636741e</a><br><a href="https://blog.csdn.net/hanyongbai/article/details/84418369">https://blog.csdn.net/hanyongbai/article/details/84418369</a><br><a href="http://www.imooc.com/article/277490?block_id=tuijian_wz">http://www.imooc.com/article/277490?block_id=tuijian_wz</a><br><a href="https://blog.csdn.net/xuxingxing002/article/details/50971606">https://blog.csdn.net/xuxingxing002/article/details/50971606</a></p>
]]></content>
  </entry>
  <entry>
    <title>AndroidService相关知识</title>
    <url>/blog/posts/ad4c562c/</url>
    <content><![CDATA[<h2 id="启动一个Service"><a href="#启动一个Service" class="headerlink" title="启动一个Service"></a>启动一个Service</h2><ul>
<li><p>MyServices.java</p>
<p>必须继承自Service，或者如IntentService本身就是等其子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServices</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;onBind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        Log.d(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onDestroy: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>AndroidManifest.xml</p>
<p>注册MyServices</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyServices&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;cf.android666.myservices&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>MainActivity.java</p>
<p>在java中调用Service，需要<code>ServiceConnection</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServiceConnection</span> <span class="variable">mConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onServiceConnected: 服务绑定&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onServiceDisconnected: 服务解绑&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(context, MyServices.class);</span><br><span class="line">bindService(intent, mConnection, Service.BIND_AUTO_CREATE);<span class="comment">//绑定Service</span></span><br><span class="line"><span class="comment">//startService(intent); 启动service</span></span><br><span class="line">unbindService(mConnection);<span class="comment">//解绑Service</span></span><br></pre></td></tr></table></figure>

<p><code>bindService()</code>和<code>startService()</code>的区别在于：</p>
<p>** <code>bindService()</code>将service和当前的activity绑定在一起，activity销毁时，service也会被销毁；</p>
<p>** <code>startService()</code>则只是“启动”service，在此后service的活动和activity无关，并一直存活。</p>
</li>
</ul>
<h1 id="Service具体分析"><a href="#Service具体分析" class="headerlink" title="Service具体分析"></a>Service具体分析</h1><p>Service在AndroidManifest.xml中的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:name=<span class="string">&quot;.MyService&quot;</span><span class="comment">//必须被指定</span></span><br><span class="line">android:exported=<span class="literal">true</span>/<span class="literal">false</span> <span class="comment">//是否能被其他应用隐式调用</span></span><br><span class="line"><span class="comment">//有intent-filter则默认为true，否则默认false；若手动指定为false则即使有intent-filter也无法隐式调用</span></span><br><span class="line">android:process=<span class="string">&quot;remote&quot;</span>/<span class="string">&quot;:remote&quot;</span><span class="comment">//前者在共有的进程中进行，后者在名字为&#123;packageName&#125;:remote 的私有进程中进行，其他进行不可访问；如果不设置该属性，则service在应用自己的进程里面运行</span></span><br></pre></td></tr></table></figure>

<p>Service默认运行在创建他的线程中，要是进行耗时操作，最好在service中单独创建一个线程，这样子可以在子线程工作，在主线程中更新工作进度。</p>
<p>Service中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在初次创建服务时调用，并且直至服务死亡，只会被调用一次</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在绑定服务是才会被调用，必须实现该方法</span></span><br><span class="line">IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//每一次通过startService()方法启动Service的时候都会被调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span></span><br><span class="line">  <span class="comment">//1.intent 启动时，启动组件传递过来的Intent</span></span><br><span class="line">  <span class="comment">//2.flags 表示启动请求时是否有额外数据，可以是：</span></span><br><span class="line">  <span class="comment">//  0：无</span></span><br><span class="line">  <span class="comment">//  START_FLAG_REDELIVERY：表示该方法返回值为START_REDELIVER_INTENT，在上个服务被杀死之前调用stopSelf()停止服务</span></span><br><span class="line">  <span class="comment">//  START_FLAG_RETRY：在onStartCommand()被调用后一直无返回值时，会尝试重新调用onStartCommand()</span></span><br><span class="line">  <span class="comment">//3.当前服务id</span></span><br></pre></td></tr></table></figure>

<p>其中<code>onStartCommand()</code>方法的返回值意义如下：</p>
<p><code>START_STICKY </code>:service在内存不足被杀死后，内存空闲时系统会重新创建service，一旦成功创建会回调<code>onStartCommand()</code>方法，此时intent是null，除非是挂起的intent如pendingintent，无限期运行</p>
<p><code>START_NOT_STICKY</code>：service因内存不足被杀死，内存再次空闲系统也不会再重新创建服务，最安全</p>
<p><code>START_REDELIVER_INTENT</code>：service因内存不足被杀死，会重建服务并传递给最后一个intent（最后一次调用<code>startService()</code> 时的intent），用于连续作业，如下载等</p>
<h2 id="Service绑定服务的三种方式"><a href="#Service绑定服务的三种方式" class="headerlink" title="Service绑定服务的三种方式"></a>Service绑定服务的三种方式</h2><h3 id="1-拓展Binder类"><a href="#1-拓展Binder类" class="headerlink" title="1.拓展Binder类"></a>1.拓展Binder类</h3><p><strong>要求客户端和服务在同一应用的同一进程内</strong>。客户端通过其访问service中的公共方法。</p>
<p>步骤如下：</p>
<ol>
<li>创建BindService服务端，在类中创建一个实现了IBinder接口的实力对象并提供公共方法给客户端使用</li>
<li>在onBind()回调方法返回此Binder实例</li>
<li>在客户端的onServiceConnected()方法接收Binder，使用提供的方法绑定服务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//service服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalService</span> <span class="keyword">extends</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">  LocalService mService;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">LocalBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalBinder</span>();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binder;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//服务中公共方法，可以被客户端通过IBInder获取实例调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span>&#123;</span><br><span class="line">    LocalService <span class="title function_">getService</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> LocalService.<span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BindActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(...)</span>&#123;</span><br><span class="line">    <span class="type">ServiceConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>()&#123;</span><br><span class="line">      <span class="comment">//绑定服务时被调用，实现客户端和服务端交互（IBinder）</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span>&#123;</span><br><span class="line">        LocalService.<span class="type">LocalBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (LocalService.LocalBinder)service;<span class="comment">//获取服务端IBinder</span></span><br><span class="line">        mService = binder.getService();<span class="comment">//获取服务实例，以调用服务的公共方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//取消绑定时回调，多数时候是service被意外销毁，如内存不足</span></span><br><span class="line">      <span class="comment">//当客户端取消绑定时，系统“绝对不会”调用该方法。</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span>&#123;</span><br><span class="line">        mService = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//创建绑定对象</span></span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,LocalService.class);</span><br><span class="line">    <span class="comment">//绑定服务</span></span><br><span class="line">    <span class="comment">//参数3 flags则是指定绑定时是否自动创建Service。0代表不自动创建、BIND_AUTO_CREATE则代表自动创建</span></span><br><span class="line">    bindService(intent,conn,Service.BIND_AUTO_CREATE);</span><br><span class="line">    <span class="comment">//调用服务中的方法，最好先判断是否为null</span></span><br><span class="line">    mService.doSomeThing();</span><br><span class="line">    <span class="comment">//解除绑定</span></span><br><span class="line">    unbindService(conn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-Messenger"><a href="#2-Messenger" class="headerlink" title="2.Messenger"></a>2.Messenger</h3><p><strong>service与不同进程通信（IPC）</strong> 。</p>
<p>步骤如下：</p>
<ol>
<li>Service实现一个Handler，接收客户端每个调用的回调</li>
<li>用Handler创建Messenger对象</li>
<li>用Messenger创建IBinder对象，并通过onBind()返回客户端</li>
<li>客户端使用IBinder实例化Messenger，用其将Message对象发送给Service</li>
<li>Service在Handler接收并处理Message</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageService</span> <span class="keyword">extends</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MSG_WHAT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//创建Handler接收、处理客户端msg</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">IncomingHanler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">      <span class="comment">//do sth with msg...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Messenger</span> <span class="variable">messenger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Messenger</span>(<span class="keyword">new</span> <span class="title class_">IncomingHanlder</span>());</span><br><span class="line">  <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> messenger.getBinder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="comment">//onCreate()方法中：</span></span><br><span class="line">mConnection = <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span>&#123;</span><br><span class="line">    <span class="type">Messenger</span> <span class="variable">mService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Messenger</span>(service);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//给服务发消息</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(<span class="literal">null</span>,MessengerService.MSG_WHAT,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">mService.send(msg);</span><br></pre></td></tr></table></figure>

<p>注意service要在不同的进程中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">AndroidMinafast.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.messenger.MessengerService&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">&quot;:remote&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>服务与客户端双向通信</strong></p>
<p>服务端，修改IncomingHandler，回复客户端消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncomingHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">    <span class="comment">//回复消息</span></span><br><span class="line">    <span class="type">Messenger</span> <span class="variable">client</span> <span class="operator">=</span> msg.replyTo;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">replyMsg</span> <span class="operator">=</span> Message.obtain(<span class="literal">null</span>,MessengerService.MSG_WHAT);</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">    bundle.putString(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    replyMsg.setData(bundle);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      client.send(replyMsg);</span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端，增加Messenger和Handler处理服务端回复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RecyclerReplyMsgHandler</span> <span class="keyword">extends</span> <span class="title class_">Hanlder</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">    <span class="comment">//接收服务端返回的msg</span></span><br><span class="line">  <span class="comment">//do sth ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Messenger</span> <span class="variable">mRecevierReplyMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Messenger</span>(<span class="keyword">new</span> <span class="title class_">RecyclerReplyMsgHandler</span>());</span><br></pre></td></tr></table></figure>

<p>此外，在发送消息是需要将接收服务端回复的Messenger通过Message的replyTo传递给服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//create msg...</span></span><br><span class="line">msg.replyTo = mRecevierReplyMsg;</span><br><span class="line"><span class="comment">//send msg...</span></span><br></pre></td></tr></table></figure>

<h3 id="3-AIDL"><a href="#3-AIDL" class="headerlink" title="3.AIDL"></a>3.AIDL</h3><p>一般不会使用，具体使用可以参考<a href="https://jixiaoyong.github.io/blog/posts/f931e8ae/">这篇文章</a></p>
<h1 id="绑定服务时的注意事项"><a href="#绑定服务时的注意事项" class="headerlink" title="绑定服务时的注意事项"></a>绑定服务时的注意事项</h1><ul>
<li>多个客户端可连接一个服务端，只有第一个客户端绑定时才会调用服务<code>onBind()</code>方法来检索IBinder，此后无需调用就可将同一个IBinder传递给其他客户端</li>
<li><code>bindService()</code> 绑定服务是异步进行的</li>
<li>一般在activity可见生命周期内绑定-取消服务，不要在<code>onResume()</code>、<code>onPause()</code>期间执行绑定&#x2F;解绑</li>
</ul>
<h1 id="Service绑定和启动转换"><a href="#Service绑定和启动转换" class="headerlink" title="Service绑定和启动转换"></a>Service绑定和启动转换</h1><table>
<thead>
<tr>
<th>顺序</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>先绑定后启动service</td>
<td>启动service</td>
</tr>
<tr>
<td>先启动后绑定service</td>
<td>会绑定宿主，但是宿主死后仍按照启动service方式存活</td>
</tr>
</tbody></table>
<h1 id="前台服务和通知"><a href="#前台服务和通知" class="headerlink" title="前台服务和通知"></a>前台服务和通知</h1><blockquote>
<ul>
<li><strong>startForeground(int id, Notification notification)</strong><br>该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。</li>
<li><strong>stopForeground(boolean removeNotification)</strong><br>该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务。 但是，如果在服务正在前台运行时将其停止，则通知也会被删除。</li>
</ul>
</blockquote>
<p>文章参考：</p>
<p><a href="http://blog.csdn.net/javazejian/article/details/52709857#t3">关于Android Service真正的完全详解，你需要知道的一切 - CSDN博客</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 异步消息机制 Handler、Message、Looper</title>
    <url>/blog/posts/5962504e/</url>
    <content><![CDATA[<blockquote>
<p>此文为鸿洋博客阅读笔记，配合原文食用口味更佳。</p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/38377229">Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系 - CSDN博客</a></p>
</blockquote>
<h1 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h1><p><img src="https://jixiaoyong.github.io/images/20200429160005.png" alt="20200429160005"></p>
<h1 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h1><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><h3 id="Looper-perpare"><a href="#Looper-perpare" class="headerlink" title="Looper.perpare()"></a><strong>Looper.perpare()</strong></h3><p><code>Looper.perpare()</code>方法创建<code>Looper对象</code>（同时创建<code>MessageQueue对象</code>），并与当前线程关联保存在<code>sThreadLocal</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(<span class="literal">true</span>));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;  </span><br><span class="line">        mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);  </span><br><span class="line">        mRun = <span class="literal">true</span>;  </span><br><span class="line">        mThread = Thread.currentThread();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a><strong>Looper.loop()</strong></h3><p><code>Looper.loop()</code>方法获取保存的<code>Looper对象</code>并由此获取到<code>MessageQueue对象</code>。</p>
<p>通过<code>for循环</code>，不停的通过<code>mQueue</code>获取到<code>msg</code>，并调用<code>msg.target.dispatchMessage(msg)</code>执行msg对应的处理方法。</p>
<p>最后通过<code>msg.recycle()</code>回收使用完的msg。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block  </span></span><br><span class="line">        ...</span><br><span class="line">        msg.target.dispatchMessage(msg); </span><br><span class="line">        ...</span><br><span class="line">        msg.recycle();  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Looper-myLooper"><a href="#Looper-myLooper" class="headerlink" title="Looper.myLooper()"></a><strong>Looper.myLooper()</strong></h3><p><code>myLooper()</code>内部调用<code>sThreadLocal</code>获取已有的<code>Looper对象</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Android的Activity默认在UI线程调用了Looper的<code>prepare()</code>和<code>loop()</code>方法</strong></p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><h3 id="handler-sendMessage"><a href="#handler-sendMessage" class="headerlink" title="handler.sendMessage()"></a>handler.sendMessage()</h3><p>Handler构造方法会获取到<code>mLooper</code>和<code>mQueue</code>以及<code>mCallback</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mLooper = Looper.myLooper();  </span><br><span class="line">mQueue = mLooper.mQueue;  </span><br><span class="line">mCallback = callback;  <span class="comment">// Handler()中此值为null</span></span><br></pre></td></tr></table></figure>

<p><code>sendMessage()</code>方法最终会调用<code>sendMessageAtTime()</code>方法,在其内部调用<code>enqueueMessage()</code>方法，将handler赋予msg.target，并将msg压入mQueue中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enqueueMessage方法</span></span><br><span class="line">msg.target = <span class="built_in">this</span>;</span><br><span class="line">queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//将handler发送的msg压入到当前线程的Looper持有的MessageQueue中</span></span><br></pre></td></tr></table></figure>

<h3 id="handler-dispatchMessage"><a href="#handler-dispatchMessage" class="headerlink" title="handler.dispatchMessage()"></a>handler.dispatchMessage()</h3><p>Handler的<code>dispatchMessage()</code>方法会在<code>Looper.loop()</code>中被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;  <span class="comment">//msg自带的回调方法</span></span><br><span class="line">            handleCallback(msg);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;  <span class="comment">//handler指定的回调方法</span></span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            handleMessage(msg);  <span class="comment">//handler的handleMessage()方法</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p>其中执行顺序是：<code>msg.callback</code> &gt; <code>mCallback</code> &gt; <code>handleMessage()</code></p>
<h3 id="handler-post"><a href="#handler-post" class="headerlink" title="handler.post()"></a>handler.post()</h3><p><code>handler.post(new Runnable())</code>调用了<code>getPostMessage(r)</code>方法将r赋予msg.callback</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable r)</span>  &#123;  </span><br><span class="line">      <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;  </span><br><span class="line">      <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();  </span><br><span class="line">      m.callback = r;  </span><br><span class="line">      <span class="keyword">return</span> m;  </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>

<p>最后也是在<code>sendMessageDelayed方法</code>中调用<code>sendMessageAtTime()方法</code>将msg压入MessageQueue中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(Message msg, <span class="type">long</span> delayMillis)</span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="msg的获取"><a href="#msg的获取" class="headerlink" title="msg的获取"></a>msg的获取</h2><ul>
<li><code>Message.obtain();</code> 复用MessageMessage池中已有的对象，避免出现分配内存 <strong>推荐</strong> </li>
<li><code>new Message();</code></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>Looper</strong>在**<code>perfare()</code>**方法中创建<code>Looper及MessageQueue对象</code>并保存在<code>sThreadLocal</code>中，</p>
<p>在**<code>loop()</code>**方法中通过<code>myLooper()</code>从<code>sThreadLocal</code>中取出<code>mLooper</code>，并由此获得<code>mQueue</code>，在for循环中通过<code>mQueue.next()</code>获取<code>msg</code>，用<code>msg.target.dispatchMessage()</code>方法回调<code>handler中的msg处理方法</code>。</p>
<p><strong>Handler</strong>在**<code>构造函数</code>**中通过<code>Looper.myLooper()</code>获取到<code>当前线程的Looper和MessageQueue</code>；</p>
<p>**<code>sendMessage()</code>**方法最终通过<code>sendMessageAtTime()</code>调用<code>enqueueMessage()</code>方法<code>将msg压入到MessageQueue</code>中。</p>
<p>至此将<em>Looper和Handler通过MessageQueue联系在一起</em>，并共同参与处理Message。</p>
<p>此外**<code>handler.post(runnable)</code><strong>也是通过在</strong><code>post()</code>**内部调用<code>getPostMessage()</code>方法将<code>runnable赋予msg.callback</code>，并在<code>post()</code>中通过<code>sendMessageDelayed()</code>方法调用<code>sendMessageAtTime()方法</code>将<code>msg压入MessageQueue</code>中</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中AIDL的使用</title>
    <url>/blog/posts/f931e8ae/</url>
    <content><![CDATA[<p>AIDL（Android Interface Definition Language ，Android接口定义语言）用于Android IPC，适用于<strong>大量并发</strong>请求。</p>
<p>主要分为两部分：</p>
<ol>
<li>服务端 创建Service监听Client的请求，通过创建AIDL将接口暴露给客户端</li>
<li>客户端 绑定到服务端获取BInder对象，将其转化为对应AIDL，并调用接口对应方法。</li>
</ol>
<p>两者的连线就是AIDL，因此两个APP的AIDL必须一致，可以将AIDL文件放到一个Android Library中，或者打成aar文件供二者依赖。</p>
<p>也可以将AIDL涉及到的AIDL文件、java都放到AIDL文件夹下，然后在build.gradle的<code>android&#123;...&#125;</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">     main&#123;</span><br><span class="line">         java.srcDirs = [&#x27;src/main/java&#x27;,&#x27;src/main/adil&#x27;]</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 即添加一个java路径</p>
<h1 id="AIDL-文件特点"><a href="#AIDL-文件特点" class="headerlink" title="AIDL 文件特点"></a>AIDL 文件特点</h1><h2 id="支持的数据格式"><a href="#支持的数据格式" class="headerlink" title="支持的数据格式"></a>支持的数据格式</h2><p>基本数据类型、List（ArrayList）、Map（HashMap）以及实现了Parcelable接口的对象、AIDL接口。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>自定义的Parcelable对象、AIDL对象必须显示import。</li>
<li>AIDL中用到的Parcelable对象必须新建一个同名AIDL接口，声明其为Parcelable类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// People.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line">parcelable People;</span><br></pre></td></tr></table></figure>

<ul>
<li>AIDL中除了基本数据类型，其他的参数必须标记方向（in,out,inout）。</li>
<li>AIDL不支持方法重载，也就是说不能有两个同名的方法（即使参数类型、个数不同也不行）。</li>
<li>AIDL中只支持方法，不支持静态变量。</li>
</ul>
<h1 id="AIDL用法"><a href="#AIDL用法" class="headerlink" title="AIDL用法"></a>AIDL用法</h1><h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ManagerAidl.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.TaskCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ManagerAidl</span> &#123;</span><br><span class="line">    <span class="comment">//客户端提供的方法</span></span><br><span class="line">    List&lt;People&gt; <span class="title function_">getPeopleList</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addPeople</span><span class="params">(in People people)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调接口，用于服务端往客户端通信</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerCallBack</span><span class="params">(in TaskCallBack callback)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unregisterCallBack</span><span class="params">(in TaskCallBack callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TaskCallBack.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://blog.csdn.net/woshiwoshiyu/article/details/54266101</span></span><br><span class="line"><span class="comment">//回调的具体方法，供服务端回调</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TaskCallBack</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">callBack</span><span class="params">(in <span class="type">int</span> size)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onPeopleChange</span><span class="params">(in List&lt;People&gt; peoples)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//People.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PeopleManager.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个管理类，封装了客户端绑定服务端的一些方法</span></span><br><span class="line"><span class="comment"> * 属于客户端部分，不过放在AIDL中便于多个客户端开发</span></span><br><span class="line"><span class="comment"> * Created by jixiaoyong on 2018/8/6.</span></span><br><span class="line"><span class="comment"> * email:jixiaoyong1995@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeopleManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PeopleManager mPeopleManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Context mContext;</span><br><span class="line">    <span class="keyword">private</span>  Listener mListener;</span><br><span class="line">    <span class="keyword">private</span> ManagerAidl managerAidl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;People&gt; peopleList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现该回调方法，用于调用客户端的具体方法</span></span><br><span class="line">    <span class="comment">//注意这里是new TaskCallBack.Stub()，而非new TaskCallBack(),否则服务器无法接收到callback</span></span><br><span class="line">    <span class="comment">//TaskCallBack.Stub()是TaskCallBack的子类，当跨进程通信时传递的是proxy类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TaskCallBack</span> <span class="variable">callBack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskCallBack</span>.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callBack</span><span class="params">(<span class="type">int</span> size)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            mListener.onCallback(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeopleChange</span><span class="params">(List&lt;People&gt; peoples)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            peopleList = peoples;</span><br><span class="line">            mListener.onPeopleListChange(peoples);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">serviceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            <span class="comment">//在连接上服务端后，客户端从IBinder对象中获取到AIDL接口对象，并执行其方法</span></span><br><span class="line">            managerAidl =  ManagerAidl.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                peopleList = managerAidl.getPeopleList();</span><br><span class="line">                managerAidl.registerCallBack(callBack);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mListener.onCreate(mPeopleManager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                managerAidl.unregisterCallBack(callBack);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PeopleManager</span><span class="params">(Context context,Listener listener)</span> &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mListener = listener;</span><br><span class="line">        peopleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;cf.android666.demo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;cf.android666.demo.MService&quot;</span>));<span class="comment">//Android5.0后必须显示的启动服务</span></span><br><span class="line">        context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context,Listener listener)</span> &#123;</span><br><span class="line">        mPeopleManager = <span class="keyword">new</span> <span class="title class_">PeopleManager</span>( context, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPeople</span><span class="params">(People people)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            managerAidl.addPeople(people);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;People&gt; <span class="title function_">getPeopleList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> peopleList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类可以实现该Listener的方法，在服务端调用这些方法时执行对应操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(PeopleManager peopleManager)</span>;<span class="comment">//服务连接成功</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onCallback</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onPeopleListChange</span><span class="params">(List&lt;People&gt; peoples)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>注意MService在AndroidManife.xml中配置:</p>
<p><code>android:exported=&quot;true&quot;android:enabled=&quot;true&quot;android:process=&quot;:people&quot;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MService.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteCallbackList;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.text.InputFilter;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.ManagerAidl;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.TaskCallBack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by jixiaoyong on 2018/8/6.</span></span><br><span class="line"><span class="comment"> * email:jixiaoyong1995@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> <span class="keyword">implements</span> <span class="title class_">ManagerAidl</span>.Stub.DeathRecipient &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;People&gt; mPeopleList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RemoteCallbackList&lt;TaskCallBack&gt; callbackList = <span class="keyword">new</span> <span class="title class_">RemoteCallbackList</span>&lt;&gt;();;</span><br><span class="line">    <span class="keyword">private</span> TaskCallBack mCallBack;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用AIDL接口生成mIBinder，在服务端实现接口各个方法，供客户端调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IBinder</span> <span class="variable">mIBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManagerAidl</span>.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;People&gt; <span class="title function_">getPeopleList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">return</span> mPeopleList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPeople</span><span class="params">(People people)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            mPeopleList.add(people);</span><br><span class="line">            onPeopleChange(mPeopleList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerCallBack</span><span class="params">(TaskCallBack callback)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            mCallBack = callback;</span><br><span class="line">            Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;registerCallBack注册回调方法 callback == null&quot;</span> + callback);</span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;<span class="comment">//注意这里一定要判断非空</span></span><br><span class="line">                callbackList.register(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterCallBack</span><span class="params">(TaskCallBack callback)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">                callbackList.unregister(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;onBind  MService开始了&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPeopleList == <span class="literal">null</span>) &#123;</span><br><span class="line">            mPeopleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            mPeopleList.add(<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;people&quot;</span> + i, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mIBinder;<span class="comment">//返回开始用AIDL创建的IBinder</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实现DeathRecipient接口的方法，在客户端终止后自动调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binderDied</span><span class="params">()</span> &#123;</span><br><span class="line">        callbackList.unregister(mCallBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里时在服务端调用回调方法的写法，是从callbackList依次取出来执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onPeopleChange</span><span class="params">(List&lt;People&gt; peoples)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackList == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> callbackList.beginBroadcast();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                callbackList.getBroadcastItem(i).onPeopleChange(peoples);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            callbackList.finishBroadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>这里用来注册监听的类是RemoteCallbackList</p>
<p>我们知道跨进程的两个listener是两个不同的对象，那他是怎么保证跨进程注册、注销的是指定的listener呢？</p>
<p>这是因为虽然两个listener对象不同，但是他们底层的Binder对象是同一个，在RemoteCallbackList中有一个以Binder对象为KEY的map来存放这些listener对象，当要注销时，只需要按当前待注销的listener的Binder对象找到已经注册了的listener并删除掉即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayMap&lt;IBinder, Callback&gt; mCallbacks</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;IBinder, Callback&gt;()</span><br></pre></td></tr></table></figure>

<p>此外，RemoteCallbackList可以在客户端死亡的时候自动注销掉对应的listener，这是因为他在注册的同时也对Binder的死亡就行了监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(E callback, Object cookie)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mKilled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Flag unusual case that could be caused by a leak. b/36778087</span></span><br><span class="line">        logExcessiveCallbacks();</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> callback.asBinder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callback</span>(callback, cookie);</span><br><span class="line">            binder.linkToDeath(cb, <span class="number">0</span>);<span class="comment">//监听binder的死亡事件</span></span><br><span class="line">            mCallbacks.put(binder, cb);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//当binder死亡时，会主动移除其注册的listener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binderDied</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">                mCallbacks.remove(mCallback.asBinder());</span><br><span class="line">            &#125;</span><br><span class="line">            onCallbackDied(mCallback, mCookie);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法运行的线程</p>
<p><strong>如果客户端和服务端运行在同一进程</strong>：客户端调用服务端和服务端回调客户端方法（RemoteCallbackList，下同）都会运行在同一线程，即客户端调用服务端时所在的线程，默认为主线程</p>
<p><strong>如果客户端和服务端运行在不同进程</strong>：客户端调用服务端方法，客户端会被挂起，直到服务端方法在Binder线程池中运行完毕,这种情况下服务端可以执行耗时操作而无需另建线程；服务端回调客户端方法运行在客户端主线程(与客户端调用服务端方法在同一线程)</p>
<p>通过上述分析，可以注意到一个细节：<strong>虽然在服务端中回调客户端的方法是在服务端的Binder线程，但是在客户端中被回调的方法却是和客户端中主动调用服务端方法的线程一致</strong>。</p>
</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PeopleManager.init(<span class="built_in">this</span>, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务连接成功后，可以开始调用服务的一系列方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(PeopleManager peopleManager)</span> &#123;</span><br><span class="line">    mPeopleManager = peopleManager;</span><br><span class="line">    peopleList = peopleManager.getPeopleList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; peopleList.size(); i++) &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;people list is &quot;</span> + peopleList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他回调方法，等服务端回调时会执行对应方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeopleListChange</span><span class="params">(List&lt;People&gt; peoples)</span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;demo2 people变化了&quot;</span> + peoples.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听并处理Binder死亡事件"><a href="#监听并处理Binder死亡事件" class="headerlink" title="监听并处理Binder死亡事件"></a>监听并处理Binder死亡事件</h2><p>当服务端进程意外死亡时，我们可以选择重新连接服务，一般有两种方式：</p>
<ol>
<li>binderDied 在客户端的Binder线程池中</li>
<li>onServiceDisconnected 在客户端UI线程</li>
</ol>
<h2 id="AIDL的权限验证"><a href="#AIDL的权限验证" class="headerlink" title="AIDL的权限验证"></a>AIDL的权限验证</h2><p>可以在服务的onBind(Intent intent)或者onTransact()方法中做验证</p>
<p>做验证的手段有：1.permission验证；2.Uid，Pid等做验证</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Android开发艺术探索》</p>
]]></content>
      <tags>
        <tag>aidl</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中AIDL相关知识</title>
    <url>/blog/posts/2270057c/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>AIDL</code>是Android中用于IPC的语言，具体使用可以参见<a href="https://jixiaoyong.github.io/blog/posts/f931e8ae/">这篇文章</a>，这篇文章主要想总结一下<code>AIDL</code>具体为我们做了什么工作，主要参考书目《Android开发艺术探索》。</p>
<p>在Android中，除了<code>Socket</code>、<code>Intent</code>中使用<code>Bundle</code>、本地文件共享，<code>ContentProvider</code>等等之外，还有一个独有的IPC方式即<code>Binder</code>。在日常编程中使用<code>Binder</code>的主要有<code>AIDL</code>和<code>Messenger</code>两种方式，而<code>Messenger</code>也是用<code>AIDL</code>来实现的。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol>
<li>新建一个AIDL文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IBookManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getSth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用AndroidStudio自动生成一个Binder类</li>
</ol>
<p>使用<code>Build</code>-&gt;<code>Make Project</code>，会在<code>app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out</code>目录下生成<code>IBookManager.java</code>。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>AIDL从客户端(Client)发起请求至服务端(Server)相应的工作流程概览，图片来源(<a href="https://blog.csdn.net/qian520ao/article/details/78074983">https://blog.csdn.net/qian520ao/article/details/78074983</a>)</p>
<p><img src="https://jixiaoyong.github.io/images/20190320205619.png" alt="AIDL从客户端(Client)发起请求至服务端(Server)的流程"></p>
<p>下面我们对<code>IBookManager.java</code>这个文件简单分析一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> * Original file: app/src/main/aidl/cf/android666/myapplication/IBookManager.aidl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBookManager</span> <span class="keyword">extends</span></span><br><span class="line">  <span class="title class_">android</span>.os.IInterface<span class="comment">//IInterface接口，所有可以在Binder中传输的接口都要继承自该接口</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     * 持有Binder对象</span></span><br><span class="line"><span class="comment">     * 获取客户端传过来的数据，根据方法 ID 执行相应操作。</span></span><br><span class="line"><span class="comment">     * 将传过来的数据取出来，调用本地写好的对应方法。</span></span><br><span class="line"><span class="comment">     * 将需要回传的数据写入 reply 流，传回客户端。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">cf</span>.android666.myapplication.IBookManager &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;cf.android666.myapplication.IBookManager&quot;</span>;<span class="comment">//是Binder的唯一标识，一般为当前Binder的类目</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);<span class="comment">//将Binder和指定的接口绑定，这样当queryLocalInterface时会返回与DESCRIPTOR一致的IInterface</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an cf.android666.myapplication.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         * 将服务端的Binder转化为客户端需要的IInterface</span></span><br><span class="line"><span class="comment">         * 如果是相同的进程，则直接返回服务端的Stub对象本身（没有跨进程）；</span></span><br><span class="line"><span class="comment">         * 如果是不同的进程，则返回的是Stub.Proxy代理类对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> cf.android666.myapplication.IBookManager <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="literal">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> cf.android666.myapplication.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((cf.android666.myapplication.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">cf</span>.android666.myapplication.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 客户端远程请求经过系统封装后调用该方法，</span></span><br><span class="line"><span class="comment">        * 生成 _data 和 _reply 数据流，并向 _data 中存入客户端的数据。</span></span><br><span class="line"><span class="comment">        * 通过 transact() 方法将它们传递给服务端，并请求服务端调用指定方法。</span></span><br><span class="line"><span class="comment">        * 接收 _reply 数据流，并从中取出服务端传回来的数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">            java.lang.<span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> DESCRIPTOR;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getSth: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);<span class="comment">//从data中可以读取参数</span></span><br><span class="line">                    <span class="built_in">this</span>.getSth();<span class="comment">//注意，这里调用的是IBookManager的getSth()，也就是需要我们在使用该Binder时实现的方法</span></span><br><span class="line">                    reply.writeNoException();<span class="comment">//可以往reply中写入结果</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Proxy类持有IBinder的引用</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">cf</span>.android666.myapplication.IBookManager &#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSth</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getSth, _data, _reply, <span class="number">0</span>);<span class="comment">//这里实际上是调用了远程的IBinder的transact()方法</span></span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_getSth</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);<span class="comment">//这个是我们在AIDL中定义的getSth()方法的标志，用于在onTransact中区分调用的是哪个方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSth</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException;<span class="comment">//这个是我们在AIDL中定义的方法,需要在服务端实现，并且会在客户端被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qian520ao/article/details/78074983">Android 深入浅出AIDL（二）</a></p>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78089877">Android Binder之应用层总结与分析</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android中View相关知识</title>
    <url>/blog/posts/1b0362b/</url>
    <content><![CDATA[<p>本文为笔记性质，尚未成文。</p>
<h1 id="View的坐标"><a href="#View的坐标" class="headerlink" title="View的坐标"></a>View的坐标</h1><p>Android中的坐标，以屏幕左上角顶点为原点(0,0)，以横轴为x轴，竖轴为y轴，数值依次递增。</p>
<p>View的坐标信息有以下几种，其坐标都是以父View的左上角顶点为原点：</p>
<ul>
<li><p>x，y 是View的左上角坐标。</p>
</li>
<li><p>translationX，translationY是View左上角顶点与父容器左上角顶点的偏移量，默认为0。</p>
</li>
<li><p>left，top 是分别是View左上角顶点的x轴，y轴坐标。</p>
<p>right，bottom分别是View右下角顶点的x轴，y轴坐标。</p>
</li>
</ul>
<blockquote>
<p>注意</p>
</blockquote>
<p>x &#x3D; translationX + left；</p>
<p>y &#x3D; translationY + top；</p>
<p>改变translationX&#x2F;Y的值便可以更改<strong>View的位置</strong>。当View平移的时候，代表原始位置信息的left，right，top，bottom的值并不会变化。</p>
<p>在OnTouch事件中，我们可以从event得到两种值：</p>
<p>event.rawX,event.rawY 代表 相对于手机屏幕原点的坐标</p>
<p>event.X,event.Y 代表 相对于当前View左上角的坐标</p>
<p>TouchSlop则代表认为滑动开始的最小距离</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ViewConfiguration.<span class="keyword">get</span>(<span class="keyword">this</span>).scaledTouchSlop</span><br></pre></td></tr></table></figure>

<h1 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h1><p>mScroller.startScroll()方法可以实现平滑的滑动</p>
<p>scrollX,scrollY表示的是<em>view的X，Y坐标减去view内容的X，Y坐标</em>。</p>
<p>所以scrollX&gt;0，则表示view内容向左移动，scrollX&lt;0表示view内容向右移动。类似于窗户(view)位置不变，景色(view内容)的scrollX&gt;0即景色向右移动，则在窗户中看到的效果是景色向窗户左边移动。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mScroller = Scroller(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">smoothScrollBy</span><span class="params">(destX: <span class="type">Int</span>, destY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    mScroller.startScroll(scrollX, scrollY, destX, destY, <span class="number">1000</span>)<span class="comment">//destX, destY的值如果是正的话，会向左，上方移动</span></span><br><span class="line">    invalidate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeScroll</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        scrollTo(mScroller.currX, mScroller.currY)</span><br><span class="line">        postInvalidate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scroller不能使View滑动，而只能配合View的computeScroll()方法实现是<strong>View的内容滑动</strong>的效果。</p>
<ul>
<li>mScroller.startScroll()记录下要滑动的数据，而invalidate()通知View重绘；</li>
<li>每次重绘都会调用computeScroll()方法，利用mScroller计算出接下来要scrollTo()的具体值并执行，再次postInvalidate()通知View重绘；</li>
<li>如此反复直到绘制滑动完毕。</li>
</ul>
<p>上述无论是translationX还是scrollX等引起的view变化，都不能改变View的定位（left，right，top，bottom值），而如果<strong>更改margin的值，则可以更改View的定位</strong>。</p>
<h1 id="Window和WindowManager"><a href="#Window和WindowManager" class="headerlink" title="Window和WindowManager"></a>Window和WindowManager</h1><p>WindowManager.LayoutParams.flags有三个常用选项：</p>
<ul>
<li>WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL &#x2F;&#x2F; 只处理Window区域内的点击事件，之外的交给其他Window处理</li>
<li>WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE &#x2F;&#x2F; 不接受输入事件，不获取焦点，同时会开启FLAG_NOT_TOUCH_MODAL，最终事件会传递给下层具有焦点的Window</li>
<li>WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED  &#x2F;&#x2F; 让Window显示在锁屏界面上</li>
</ul>
<p>WindowManager.LayoutParams.type代表Window的类型(三个)：</p>
<ul>
<li>应用Window 对应一个Activity。<code>z-ordered</code>:1~99</li>
<li>子Window 不能单独存在，附属在特定的父Window中，如Dialog。<code>z-ordered</code>:1000~1999</li>
<li>系统Window 需要系统权限，如Toast，状态栏等。<code>z-ordered</code>:2000~2999</li>
</ul>
<p><code>z-ordered</code>值大的Window会覆盖掉低值的Window。</p>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>recycleview滑动<br>ItemTouchHelper源码分析 <a href="https://www.jianshu.com/p/130fdd755471">https://www.jianshu.com/p/130fdd755471</a><br>嵌套滑动 <a href="https://blog.csdn.net/qq_15807167/article/details/51637678">https://blog.csdn.net/qq_15807167/article/details/51637678</a><br><a href="https://www.cnblogs.com/dasusu/p/9159904.html">https://www.cnblogs.com/dasusu/p/9159904.html</a><br><del>滑动展示删除按钮</del> <a href="https://www.jianshu.com/p/9bfed6e127cc">https://www.jianshu.com/p/9bfed6e127cc</a> &gt;&gt; 对应的demo：<a href="https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt">https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/Holmofy/article/details/53959511">View滑动效果常用属性详解：scroll、translation、LayoutParams</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android中WebView使用的一些问题</title>
    <url>/blog/posts/b35fe0f7/</url>
    <content><![CDATA[<h1 id="问题描述：WebView在fragment中不显示"><a href="#问题描述：WebView在fragment中不显示" class="headerlink" title="问题描述：WebView在fragment中不显示"></a>问题描述：WebView在fragment中不显示</h1><p>解决代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin 代码</span></span><br><span class="line">webView.webViewClient = <span class="keyword">object</span> : WebViewClient() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(view: <span class="type">WebView</span>?, url: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">                view!!.loadUrl(url)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>此代码同样强制在webview中打开对应的网页</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的Messenger源码详解</title>
    <url>/blog/posts/b0dc2559/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Messenger是Android中用于IPC的方式之一，使用Handler发送有序消息队列，底层是通过AIDL调用Binder实现。</p>
<p>Messenger只用于服务端和客户端串行的传递消息，如果大量并发或者跨进程调用服务端的方法，就需要考虑AIDL而非Messenger。</p>
<p>Messenger的使用可以参考<a href="https://jixiaoyong.github.io/blog/posts/ad4c562c/">这篇文章</a>,本文主要探索一下Messenger源码实现。</p>
<p>主要使用到的文件：</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/IMessenger.aidl">IMessenger.aidl</a></p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Messenger.java">Messenger.java</a></p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Handler.java">Handler.java</a></p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>一个典型的Messenger服务如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messenger = Messenger(MessengerHandler())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> messenger.binder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以从客户端的得到的Messenger中取出该Handler，并实现客户端-&gt;服务端通信</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> : <span class="type">Handler</span></span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            <span class="comment">//客户端的Messenger，用于服务端-&gt;客户端通信,可选</span></span><br><span class="line">            <span class="keyword">val</span> client = msg?.replyTo</span><br><span class="line">            client?.send(Message.obtain(<span class="literal">null</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到使用Handler创建一个Messenger，进入到源码看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IMessenger mTarget;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Messenger</span><span class="params">(Handler target)</span> &#123;</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，在这里创建了一个新的与给定的Handler绑定在一起的Messenger，再看看<code>getIMessenger()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> IMessenger <span class="title function_">getIMessenger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMessenger != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> <span class="title class_">MessengerImpl</span>();</span><br><span class="line">        <span class="keyword">return</span> mMessenger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MessengerImpl</span> <span class="keyword">extends</span> <span class="title class_">IMessenger</span>.Stub &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">        Handler.<span class="built_in">this</span>.sendMessage(msg);<span class="comment">//使用Handler发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到<code>getIMessenger()</code>方法会创建一个MessengerImpl对象，而这个对象</p>
<p>实现了<code>send()</code>方法，也证实了我们之前的一个观点——Messenger底层是使用Handler发送消息。</p>
<p>同时，看到MessengerImpl继承的IMessenger.Stub类我们可以联想到这里应该有一个AIDL实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/os/IMessenger.aidl</span></span><br><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">oneway <span class="keyword">interface</span> <span class="title class_">IMessenger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(in Message msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>oneway</code> 关键字用于修改远程调用的行为。使用该关键字时，远程调用不会阻塞；它只是发送事务数据并立即返回。接口的实现最终接收此调用时，是以正常远程调用形式将其作为来自 <code>Binder</code> 线程池的常规调用进行接收。 如果 <code>oneway</code> 用于本地调用，则不会有任何影响，调用仍是同步调用</p>
<p><a href="https://developer.android.google.cn/guide/components/aidl?hl=zh-cn">https://developer.android.google.cn/guide/components/aidl?hl=zh-cn</a></p>
</blockquote>
<p>这也就解释了在服务的<code>onBind(intent: Intent?)</code>方法中，我们可以直接使用<code>messenger.binder</code>获取到Binder对象的原因。</p>
<p>再看看Messenger客户端的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> messenger: Messenger<span class="comment">//服务端的Messenger</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> replyMessenger: Messenger = Messenger(ReplyHandler())<span class="comment">//客户端的Messenger，用于服务端-&gt;客户端通信，可选</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">        messenger = Messenger(service)<span class="comment">//注意这里的构造方法传入的是IBinder对象</span></span><br><span class="line">        <span class="keyword">val</span> message = Message.obtain(<span class="literal">null</span>, <span class="number">1</span>)</span><br><span class="line">        message.replyTo = replyMessenger</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = Bundle()</span><br><span class="line">        <span class="keyword">data</span>.putString(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messenger.send(message)<span class="comment">//使用服务端的Messenger向服务端发送消息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到在客户端通过<code>Messenger(IBinder target)</code>取得服务端的Messenger，而这里的IBinder对象则是通过服务端的Messenger的<code>getBinder()</code>获取的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Messenger</span><span class="params">(IBinder target)</span> &#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Stub.asInterface()</code>方法我们在<a href="http://jixiaoyong.github.io/blog/posts/88d0bcd1/">之前的文章</a>中介绍过，他会根据客户端和服务端是否在同一进程而决定返回Stub实例还是Proxy类实例以实现跨进程通信。</p>
<p>而通过比较 <code>Messenger(IBinder target)</code>和<code>Messenger(Handler target)</code>两个构造方法我们也可以知道，两个方法都只是用来初始化了<code>IMessenger mTarget</code>对象，这也就解释了在服务端和客户端可以通过两个不同的构造方法获取到有同样功能的Messenger。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Android开发艺术探索》</p>
<p><a href="https://developer.android.google.cn/guide/components/aidl?hl=zh-cn">Android 接口定义语言 (AIDL)</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android中的SpareArray和ArrayMap实现分析</title>
    <url>/blog/posts/c2f123c/</url>
    <content><![CDATA[<p>日常开发中，常用的存储键值对的数据结构是<code>HashMap</code>，根据<a href="https://xiaoyong.ml/blog/posts/ff927bd4/">Java笔记之HashMap保存数据</a>和<a href="https://xiaoyong.ml/blog/posts/b0793c74/">Java笔记之计算Java对象的大小及其应用</a>可以知道，<code>HashMap</code>存储<strong>键值对</strong>会占用比较多的内存控件，而对于内存限制较大的Android平台来说，为了避免这种浪费，官方推荐我们使用<code>SpareArray</code>和<code>ArrayMap</code>，本文对这两个类的实现进行分析比较。</p>
<p><strong><code>SpareArray</code>以及他的衍生类</strong>都是以<strong>基本类型</strong>为<code>key</code>，因为避免了<em>自动装箱</em>，并且<strong>用数组直接保存key、value</strong>（而非像<code>HashMap</code>那样将其封装为<code>Node</code>对象后再保存），因而节省了内存。</p>
<p><strong><code>ArrayMap</code><strong>则支持</strong>所有类型的key</strong>，他是<strong>将<code>key</code>和<code>value</code>全部保存在一个数组中</strong>（<code>n</code>位为<code>key</code>，<code>n+1</code>位为<code>value</code>），避免了将其封装为<code>Node</code>对象带来的内存消耗。</p>
<p><strong>当要保存的数据量比较小（小于几千个）的时候，如果KEY是基本类型，推荐使用<code>SparseArray</code>及其衍生类以节省内存，如果KEY是其他类型则使用<code>ArrayMap</code>;否则使用<code>HashMap</code>更加高效</strong>。</p>
<h1 id="SpareArray"><a href="#SpareArray" class="headerlink" title="SpareArray"></a>SpareArray</h1><p><code>SpareArray</code>以及他的衍生类主要用于<strong>以<code>基本类型</code>为<code>key</code>保存非大量数据的场景</strong>。</p>
<p>相比<code>HashMap</code>而言，他的优点主要在于<strong>没有对保存的数据二次封装</strong>，没有对基本类型的数据<strong>自动装箱</strong>，存储单个数据的成本小，也没有<code>hash</code>计算。</p>
<p>但他在添加数据时需要扩展数组(涉及到新建、复制数组，<code>gc()</code>等)，<del>在删除数据时需要缩减数组</del> (查看<code>gc()</code>等源码发现他的数组只会增加，不会缩减)，以及通过二分法查找索引都会消耗性能。</p>
<blockquote>
<p>为了避免每次删除时都需要缩减数组，<code>SpareArray</code>在删除数组时只会将其赋值为<code>DELETED</code>，在下次调用其<code>private void gc()</code>方法时丢弃掉这些数据</p>
</blockquote>
<p>先看一下<code>SpareArray</code>的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mGarbage</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//是否调用gc()方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] mKeys;<span class="comment">//所有的key</span></span><br><span class="line">    <span class="keyword">private</span> Object[] mValues;<span class="comment">//所有的value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mSize;<span class="comment">//所保存的数据个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="void-put-int-key-E-value"><a href="#void-put-int-key-E-value" class="headerlink" title="void put(int key, E value)"></a>void put(int key, E value)</h2><p>添加方法先用<strong>二分法</strong>查找<code>key</code>对应的位置：</p>
<ul>
<li>如果有，则直接覆盖</li>
<li>如果没有，则<strong>取反</strong>得到应该<code>插入的位置</code>，并分别插入<code>key</code>和<code>value</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, E value)</span> &#123;</span><br><span class="line">  <span class="comment">// 先用二分法查找key对应的索引,找到的话返回对应索引，</span></span><br><span class="line">  <span class="comment">// 否则返回key应该插入的位置的取反值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果已存在值则直接覆盖</span></span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对二分法查找到的值再取反，得到key应该插入的位置</span></span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// public static &lt;T&gt; T[] insert(T[] array, int currentSize, int index, T element)</span></span><br><span class="line">      <span class="comment">// Inserts an element into the array at the specified index,</span></span><br><span class="line">      <span class="comment">// growing the array if there is no more room.</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-get-int-key"><a href="#E-get-int-key" class="headerlink" title="E get(int key)"></a>E get(int key)</h2><p>获取数据，先用<strong>二分法</strong>查找，如果找到就返回<code>对应的值</code>，否则返回<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(key, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> key, E valueIfKeyNotFound)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || mValues[i] == DELETED) &#123;</span><br><span class="line">        <span class="keyword">return</span> valueIfKeyNotFound;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="void-remove-int-key"><a href="#void-remove-int-key" class="headerlink" title="void remove(int key)"></a>void remove(int key)</h2><p>删除<code>key</code>以及<code>对应的数据</code>。</p>
<p>同样先用<strong>二分法</strong>查找<code>对应位置</code>，有的话则标记为<code>DELETED</code>，<strong>等待下次<code>gc()</code>时丢弃</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        delete(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gc"><a href="#gc" class="headerlink" title="gc()"></a>gc()</h2><p>在上文中我们看到，删除数据时，<code>mGarbage</code>被标记为<code>true</code>，这样当下一次进行<code>put/valueAt/append/size</code>等涉及到数组大小查询、改动等时，就出触发<code>gc()</code>以便整理数组结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">gc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mSize;</span><br><span class="line">    <span class="type">int</span> <span class="variable">o</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> values[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里的操作只是将没有被删除的数据移动到了数组的前面</span></span><br><span class="line">      <span class="comment">// 而保证了数组后面都是DELETED或null，方便后续操作</span></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="literal">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap与SpareArray及其衍生类对应关系"><a href="#HashMap与SpareArray及其衍生类对应关系" class="headerlink" title="HashMap与SpareArray及其衍生类对应关系"></a>HashMap与SpareArray及其衍生类对应关系</h2><p>参考<a href="https://android.jlelse.eu/app-optimization-with-arraymap-sparsearray-in-android-c0b7de22541a">下图</a></p>
<p><img src="https://jixiaoyong.github.io/images/20191222131219.png"></p>
<h1 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h1><p><code>ArrayMap</code>实现了<code>Map&lt;K, V&gt;</code>接口，他的API和<code>HashMap</code>相差无几，但是由于<strong>没有对数据再包装</strong>，<strong>动态调整数组的大小</strong>，一定范围内他比<code>HashMap</code>内存效率高。</p>
<p>但是如果保存大量数据（超过千位）时，由于他需要<strong>二分法查找</strong>的影响会比<code>HashMap</code>慢很多。</p>
<blockquote>
<p><strong><code>ArrayMap</code>特殊之处在于将<code>key</code>，<code>value</code>保存到了同一个数组mArray中（n位保存key，n+1位保存value</strong>）。</p>
</blockquote>
<p>先看一下<code>ArrayMap</code>的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Object[] mBaseCache;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> mBaseCacheSize;</span><br><span class="line"><span class="keyword">static</span> Object[] mTwiceBaseCache;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> mTwiceBaseCacheSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> mIdentityHashCode;<span class="comment">//是否强制使用System.identityHashCode(key)获取key的HashCode</span></span><br><span class="line"><span class="comment">//System.identityHashCode(key)方法无论类是否重写了hashCode()方法，</span></span><br><span class="line"><span class="comment">//都会调用Object.identityHashCode(key)来获取对象的hashCode</span></span><br><span class="line"><span class="type">int</span>[] mHashes;<span class="comment">//存储所有key的hash值</span></span><br><span class="line">Object[] mArray;<span class="comment">//存储key和value，大小是mHashes的两倍</span></span><br><span class="line"><span class="comment">//n位保存key，n+1位保存value</span></span><br><span class="line"><span class="type">int</span> mSize;</span><br><span class="line">MapCollections&lt;K, V&gt; mCollections;</span><br></pre></td></tr></table></figure>

<p>在使用时：</p>
<ol>
<li><p>计算<code>key</code>的<code>hash值</code>，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后使用<code>indexOf()</code>在<code>mHashes</code>中进行二分法查找对应的<code>index</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = indexOf(key, hash);</span><br></pre></td></tr></table></figure>

<p><code>indexOf()</code>方法会先用<strong>二分法</strong>查找<code>hash</code>对应的<code>index</code>,如果<code>index&lt;0</code>则返回<code>index</code>；否则在对比<code>mArray</code>中对应位置<code>mArray[index&lt;&lt;1]</code>的<code>key</code>与要<code>查询的key</code>：</p>
<ul>
<li>两者一致：返回<code>index</code></li>
<li>两者不一致：从<code>index</code>开始，<strong>先向后，再向前</strong>查询是否有相同的<code>key</code>,如果有返回<code>对应index</code></li>
<li>以上都没有找到：<strong>对<code>mHashes</code>中<code>最后一个与key的hash一致的后一位index</code>取反</strong>，并返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object key, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> mSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Important fast case: if nothing is in here, nothing to look for.</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearchHashes(mHashes, N, hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the hash code wasn&#x27;t found, then we have no entry for this key.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the key at the returned index matches, that&#x27;s what we want.</span></span><br><span class="line">    <span class="keyword">if</span> (key.equals(mArray[index&lt;&lt;<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for a matching key after the index.</span></span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">for</span> (end = index + <span class="number">1</span>; end &lt; N &amp;&amp; mHashes[end] == hash; end++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[end &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for a matching key before the index.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; mHashes[i] == hash; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[i &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key not found -- return negative value indicating where a</span></span><br><span class="line">    <span class="comment">// new entry for this key should go.  We use the end of the</span></span><br><span class="line">    <span class="comment">// hash chain to reduce the number of array entries that will</span></span><br><span class="line">    <span class="comment">// need to be copied when inserting.</span></span><br><span class="line">    <span class="keyword">return</span> ~end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="V-put-K-key-V-value"><a href="#V-put-K-key-V-value" class="headerlink" title="V put(K key, V value)"></a>V put(K key, V value)</h2><p>当添加<code>item</code>时，按照前述规则，先在<code>mArray</code>中查找<code>key</code>对应的<code>索引index</code>：</p>
<ul>
<li><p><code>index &gt;= 0</code> ：已经有键为<code>key</code>的数据，直接覆盖旧值并返回</p>
</li>
<li><p><code>index &lt; 0 </code>：没有键为<code>key</code>的数据，对数组进行扩容，并保存对应数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = ~index;<span class="comment">//上文indexOf()中计算得出的key应该添加的位置</span></span><br><span class="line">mHashes[index] = hash;</span><br><span class="line">mArray[index&lt;&lt;<span class="number">1</span>] = key;</span><br><span class="line">mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="V-get-Object-key"><a href="#V-get-Object-key" class="headerlink" title="V get(Object key)"></a>V get(Object key)</h2><p><code>get()</code>方法就比较简单了，先查找<code>key</code>的索引，然后取出<code>对应的数据value</code>并返回即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indexOfKey(key);</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? (V)mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="V-remove-Object-key"><a href="#V-remove-Object-key" class="headerlink" title="V remove(Object key)"></a>V remove(Object key)</h2><p><code>remove()</code>方法也会先使用<code>indexOfKey()</code>计算<code>key的index</code>，然后删除<code>对应位置的数据</code>。</p>
<p>此外，如果<code>mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3</code>的话，还会缩减<code>数组的大小</code>为<code>osize &gt; (BASE_SIZE*2) ? (osize + (osize&gt;&gt;1)) : (BASE_SIZE*2)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">removeAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  <span class="comment">//...其他代码</span></span><br><span class="line">  <span class="keyword">if</span>(mHashes.length &gt; (BASE_SIZE*<span class="number">2</span>) &amp;&amp; mSize &lt; mHashes.length/<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//...其他代码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> osize &gt; (BASE_SIZE*<span class="number">2</span>) ? (osize + (osize&gt;&gt;<span class="number">1</span>)) : (BASE_SIZE*<span class="number">2</span>);</span><br><span class="line">    allocArrays(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">allocArrays</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">   <span class="comment">//...其他代码</span></span><br><span class="line">   mHashes = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">   mArray = <span class="keyword">new</span> <span class="title class_">Object</span>[size&lt;&lt;<span class="number">1</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/core/java/com/android/internal/util/GrowingArrayUtils.java">GrowingArrayUtils.java 源码</a></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/SparseArray.java">SparseArray.java 源码</a></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/ArrayMap.java">ArrayMap.java 源码</a></p>
<p><a href="https://android.jlelse.eu/app-optimization-with-arraymap-sparsearray-in-android-c0b7de22541a">App optimization with ArrayMap &amp; SparseArray in Android</a></p>
<p><a href="https://xiaoyong.ml/blog/posts/ff927bd4/">Java笔记之HashMap保存数据</a></p>
<p><a href="https://xiaoyong.ml/blog/posts/b0793c74/">Java笔记之计算Java对象的大小及其应用</a></p>
<p><a href="https://extremej.itscoder.com/sparsearray_source_analyse/">SparseArray 的使用及实现原理</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android今日头条屏幕适配方案的原理梳理</title>
    <url>/blog/posts/76d69fc6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目里面遇到了屏幕适配的问题，UI要求APP在不同手机上展示效果和设计稿保持“像素级”同步，在对比了几种屏幕适配方案之后，选择了基于今日头条的<a href="https://github.com/JessYanCoding/AndroidAutoSize">AndroidAutoSize</a>适配方案。</p>
<p>本文主要简单分析其适配原理，以及在实际使用中遇到的一个问题，需要更深入了解原理可以阅读文末参考文献。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>UI给的设计稿一般都是以像素px为单位，而在Android开发中官方推荐的使用的单位是dp。</p>
<blockquote>
<p>dp 是一个虚拟像素单位，1 dp 约等于中密度屏幕（160dpi；“基准”密度）上的 1 像素。对于其他每个密度，Android 会将此值转换为相应的实际像素数。</p>
<p>—— Android Developer</p>
</blockquote>
<p>根据Android官方的定义，dp在屏幕上实际对应的像素px计算方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">px = dp * (dpi / <span class="number">160</span>)</span><br></pre></td></tr></table></figure>

<p>其中 dpi表示：<strong>屏幕每平方英寸有多少像素</strong>，可以通过屏幕对角线的像素数px&#x2F;屏幕尺寸inch计算。</p>
<p>而<code>DisplayMetrics.density</code> 字段表示根据当前像素密度指定将 <code>dp</code> 单位转换为像素时所必须使用的缩放系数，即上述方程等价于：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">px = dp * (dpi / <span class="number">160</span>)</span><br><span class="line">   = dp * getResources().getDisplayMetrics().density</span><br></pre></td></tr></table></figure>

<p>这样，在dpi为160的屏幕上1dp占1px，在dpi为320的屏幕上占2px，那么就能保证同一dp的在不同dpi上占得像素是等比例变化的。</p>
<p>但是，在现实生活中面对千变万化的Android屏幕，根据Jessyan的文章可知由于每种屏幕宽&#x2F;高对应的总dp数不一定都是相同的，所以即使使用了dp作为单位，还是会出现同一dp在有些屏幕上刚好占满全屏，在有的屏幕上会无法占满全屏或超出屏幕范围。</p>
<blockquote>
<p><strong>density</strong> 在每个设备上都是固定的，<strong>DPI &#x2F; 160 &#x3D; density</strong>，<strong>屏幕的总 px 宽度 &#x2F; density &#x3D; 屏幕的总 dp 宽度</strong></p>
<ul>
<li>设备 1，屏幕宽度为 <strong>1080px</strong>，<strong>480DPI</strong>，屏幕总 <strong>dp</strong> 宽度为 <strong>1080 &#x2F; (480 &#x2F; 160) &#x3D; 360dp</strong></li>
<li>设备 2，屏幕宽度为 <strong>1440px</strong>，<strong>560DPI</strong>，屏幕总 <strong>dp</strong> 宽度为 <strong>1440 &#x2F; (560 &#x2F; 160) &#x3D; 411dp</strong></li>
</ul>
<p>——Jessyan</p>
</blockquote>
<p>那么该怎么适配呢，再看一眼上述的公式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">屏幕的总 px 宽度 / density = 屏幕的总 dp 宽度</span><br></pre></td></tr></table></figure>

<p>以适配<strong>屏幕宽度</strong>为例，要使得dp在不同屏幕上对应的像素等比例变化，就要<strong>保证屏幕的总dp宽度一致</strong>，而屏幕的总 px 宽度是物理条件无法更改，那么就只能<strong>更改density</strong>。</p>
<p>以我们使用的设计稿宽度为375dp为例：</p>
<p>在分辨率为2160*1080 、尺寸为5.99英寸的屏幕上：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">density = 1080px / 375dp = <span class="number">2.88</span></span><br></pre></td></tr></table></figure>

<p> 而在分辨率为2400*1176、尺寸为6.53英寸的屏幕上：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">density = 1176px / 375dp = <span class="number">3.136</span></span><br></pre></td></tr></table></figure>

<p>这样就保证了，不管在什么样的屏幕上，375dp始终都能够占满屏幕宽度，保证了布局在不同大小的屏幕上，在屏幕宽度上的比例一致性，也就解决屏幕适配的问题。</p>
<h1 id="获取状态栏高度的问题"><a href="#获取状态栏高度的问题" class="headerlink" title="获取状态栏高度的问题"></a>获取状态栏高度的问题</h1><p>上述的屏幕适配方案使用简单，且侵入小，在使用到项目中之后，除了部分字体等显示需要微调外，其余内容基本上都完美还原了设计稿的内容。</p>
<p>但是在后续使用到状态栏相关代码的时候发现<strong>获取到的状态栏高度和实际高度不一致</strong>，导致显示异常，而使用<a href="http://blankj.com/">Blankj</a>的工具类 <code>BarUtils.getStatusBarHeight()</code>却可以获取到正确的高度。</p>
<p>对比两种代码发现获取状态栏高度的代码逻辑几乎一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getStatusBarHeight</span><span class="params">(Resources resources)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resourceId</span> <span class="operator">=</span> resources.getIdentifier(<span class="string">&quot;status_bar_height&quot;</span>, <span class="string">&quot;dimen&quot;</span>, <span class="string">&quot;android&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> resources.getDimensionPixelSize(resourceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的是，两种方法使用到的resources一个是APP的，一个是系统的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 我使用到的resources，从当前activity获取</span></span><br><span class="line">resources.displayMetrics.density</span><br><span class="line"><span class="comment">// 2. Blankj使用的resources，从系统获取</span></span><br><span class="line">Resources.getSystem().displayMetrics.density</span><br></pre></td></tr></table></figure>

<p>通过分别打印这两种resources可以发现，二者的density值不一样（以2160*1080 、尺寸为5.99英寸的屏幕为例）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">context.resources.DisplayMetrics: DisplayMetrics&#123;density=<span class="number">2.88</span>, width=<span class="number">1080</span>, height=<span class="number">2033</span>, scaledDensity=<span class="number">2.88</span>, xdpi=<span class="number">403.411</span>, ydpi=<span class="number">403.411</span>&#125;</span><br><span class="line"></span><br><span class="line">Resources.getSystem().DisplayMetrics: DisplayMetrics&#123;density=<span class="number">2.7</span>, width=<span class="number">1080</span>, height=<span class="number">2033</span>, scaledDensity=<span class="number">2.7</span>, xdpi=<span class="number">403.411</span>, ydpi=<span class="number">403.411</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这是由于使用了<a href="https://github.com/JessYanCoding/AndroidAutoSize">AndroidAutoSize</a>适配方案后，APP内部的density已经被改成了2.88，而系统实际的density是2.7。</p>
<p>又知道android中将像素和dp等单位转化的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android.util.TypedValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">applyDimension</span><span class="params">(<span class="type">int</span> unit, <span class="type">float</span> value,</span></span><br><span class="line"><span class="params">                                       DisplayMetrics metrics)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_DIP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.density;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.scaledDensity;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_PT:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">72</span>);</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_IN:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_MM:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">25.4f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析可知，通过getStatusBarHeight()获取到的状态栏是系统的状态栏69px（即25dp），但当使用APP内部的density&#x3D;2.88计算时就会只有24dp，和实际的状态栏高度不一致，所以使用状态栏高度来控制布局的时候就会展示异常。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://jessyan.me/autosize-introduce/">骚年你的屏幕适配方式该升级了!-今日头条适配方案——jessyan</a></p>
<p><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA">一种极低成本的Android屏幕适配方式——字节跳动</a></p>
<p><a href="https://developer.android.google.cn/training/multiscreen/screendensities#top_of_page">支持不同的像素密度——Android Developers</a></p>
<p><a href="https://mp.weixin.qq.com/s/X-aL2vb4uEhqnLzU5wjc4Q">Android 目前稳定高效的UI适配方案——拉丁吴</a></p>
<p><a href="https://github.com/JessYanCoding/AndroidAutoSize">AndroidAutoSize</a></p>
<p><a href="https://github.com/gyf-dev/ImmersionBar/issues/298">请问两种获取屏幕密度的方式有什么区别，望解答多谢</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多渠道打包知识</title>
    <url>/blog/posts/a3a3dc4c/</url>
    <content><![CDATA[<p>国内Android应用常常要分发到多个应用商店，使用Android Studio正确配置build.gradle与AndroidManifest.xml文件可以<strong>一步打包多个渠道</strong>。</p>
<p>本文实现的多渠道打包可实现不同渠道：</p>
<ul>
<li>有不同的项目id（applicationId）</li>
<li>不同App名称（android:label）</li>
<li>不同App图标（android:icon）</li>
<li>等等</li>
</ul>
<h1 id="1-友盟配置"><a href="#1-友盟配置" class="headerlink" title="1.友盟配置"></a>1.友盟配置</h1><p>*具体配置请参考UMeng官方文档。</p>
<p>作为第三方统计平台，国内很多软件都使用的是Umeng的产品，故而大多数软件多渠道打包配置如下：</p>
<ul>
<li>添加依赖</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">../app/build.gradle</span><br><span class="line">dependencies &#123;</span><br><span class="line"><span class="comment">//友盟sdk</span></span><br><span class="line">compile <span class="string">&#x27;com.umeng.sdk:common:latest.integration&#x27;</span></span><br><span class="line">compile <span class="string">&#x27;com.umeng.sdk:analytics:latest.integration&#x27;</span></span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改AndroidManifest.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">&lt;!--友盟初始化appkey和channel--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:value</span>=<span class="string">&quot;$&#123;APP_KEY&#125;&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;UMENG_APPKEY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;UMENG_CHANNEL&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改build.gradle</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line"> productFlavors &#123;</span><br><span class="line">        beta &#123;&#125;</span><br><span class="line">        baidu &#123;&#125;</span><br><span class="line">        zhushou91  &#123;&#125; <span class="comment">//不能以数字开头</span></span><br><span class="line">        anzhi &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line"></span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name</span><br><span class="line">                                                 ,APP_KEY:umenInfo[<span class="string">&#x27;APP_KEY&#x27;</span>]]</span><br><span class="line">            <span class="comment">//这里有一个知识点，用build.gradle读取properties文件信息，用于将部分信息统一放置在本地配置文件中，避免泄漏，若无此类要求可直接使用 APP_KEY:&#x27;da15d26d1a&#x27;等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决flavor Dimensions问题  http://blog.csdn.net/syif88/article/details/75009663</span></span><br><span class="line">    flavorDimensions <span class="string">&quot;versionCode&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他umeng要求的配置</span></span><br></pre></td></tr></table></figure>

<p>这样编译完之后，通过通过build&gt;Generate Signed APK…便可以打包不同渠道的apk，在友盟统计平台上统计各个渠道的App信息了。</p>
<h1 id="2-Android-Studio实现多渠道打包"><a href="#2-Android-Studio实现多渠道打包" class="headerlink" title="2.Android Studio实现多渠道打包"></a>2.Android Studio实现多渠道打包</h1><p>方法1要求依赖umeng模块，使用场景难免有些受限，其实我们也可以自己实现多渠道打包，方法1使用的应该也是此原理。</p>
<ul>
<li>AndroidManifest.xml</li>
</ul>
<p>在需要根据渠道不同而变化的地方使用<code>$&#123;KEY&#125;</code>形式替换掉原先的值。</p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:label</span>=<span class="string">&quot;$&#123;APP_NAME&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;APP_TEXT&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;$&#123;APP_TEXT&#125;&quot;</span>/&gt;</span>//可以在java文件中获取到</span><br></pre></td></tr></table></figure>

<ul>
<li>app&#x2F;build.gradle</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    beta &#123;applicationId = <span class="string">&quot;cf.android666.mykotlin.beta&quot;</span><span class="comment">//每个渠道有不同的包名</span></span><br><span class="line">        manifestPlaceholders = [APP_NAME : name ,APP_TEXT:<span class="string">&#x27;beta&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    baidu &#123;applicationId = <span class="string">&quot;cf.android666.mykotlin.baidu&quot;</span></span><br><span class="line">        manifestPlaceholders = [APP_NAME:<span class="string">&#x27;A APP&#x27;</span>,APP_TEXT:<span class="string">&#x27;baidu&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在java中获取<code>meta-data</code>（非必须）</li>
</ul>
<blockquote>
<p>Android获取Manifest中<meta-data>元素的值 - CSDN博客  <a href="https://blog.csdn.net/zhang31jian/article/details/29868235">https://blog.csdn.net/zhang31jian/article/details/29868235</a></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//application中的meta-data</span></span><br><span class="line"><span class="keyword">var</span> appInfo = context.packageManager.getApplicationInfo(context.packageName,</span><br><span class="line">        PackageManager.GET_META_DATA)</span><br><span class="line"><span class="comment">//service、receiver中的meta-data</span></span><br><span class="line"><span class="keyword">var</span> appInfo = context.packageManager.getServiceInfo(ComponentName(context,MService::<span class="keyword">class</span>.java),</span><br><span class="line">                PackageManager.GET_META_DATA)</span><br><span class="line"><span class="keyword">var</span> appName = appInfo.metaData.getString(<span class="string">&quot;APP_NAME&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="3-生成多个渠道文件夹"><a href="#3-生成多个渠道文件夹" class="headerlink" title="3.生成多个渠道文件夹"></a>3.生成多个渠道文件夹</h1><p>还有一种方法，通过在项目中生成多个渠道的文件夹，在里面替换对应的资源文件，从而实现多渠道打包不同项目名，不同icon等等</p>
<ul>
<li><p>在..&#x2F;app&#x2F;src&#x2F;目录下新建对应渠道文件夹，和main同级</p>
</li>
<li><p>在该渠道目录下新建对应的资源目录，在打包时自动替换对应资源</p>
<p>​</p>
<p>目录树如下</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"></span><br><span class="line">--baidu</span><br><span class="line"></span><br><span class="line">----res/drawable</span><br><span class="line"></span><br><span class="line">--beta</span><br><span class="line"></span><br><span class="line">--main</span><br><span class="line"></span><br><span class="line">----res/drawable</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4-More"><a href="#4-More" class="headerlink" title="4.More"></a>4.More</h1><p>此外还有美团的多渠道打包技术等</p>
<p>具体可参考文章：<a href="https://tech.meituan.com/mt-apk-packaging.html">美团Android自动化之旅—生成渠道包</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实现可折叠toolbar</title>
    <url>/blog/posts/b4832cd1/</url>
    <content><![CDATA[<p>使用到的类有：</p>
<ul>
<li>android.support.design.widget.CoordinatorLayout</li>
<li>android.support.design.widget.AppBarLayout</li>
<li>android.support.design.widget.CollapsingToolbarLayout</li>
<li>android.support.v7.widget.Toolbar</li>
</ul>
<h1 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h1><p>如图：</p>
<p><img src="http://jixiaoyong.github.io/blog/images/default/2018-02-22/coordinatorlayout.gif"></p>
<h1 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h1><p>CoordinatorLayout类，协调者布局，通过Behavior将一个子view（<code>child</code>）的行为和另一个子view（<code>dependency</code>）的活动联结起来，从而实现子view之间的联动。</p>
<p>AppBarLayout类，是一个实现了材料设计的默认垂直布局的ViewGroup，当其是CoordinatorLayout类的直接子view时,另外一个CoordinatorLayout的子view指定了behavior为AppBarLayout.ScrollingViewBehavior的实例（<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>）,且该子view需要是NestedScrollingChild的实现类。</p>
<p>CollapsingToolbarLayout类，提供一个可以折叠的toolbar布局，可以在这个布局里面，设置toolbar以及和toolbar一起联动的子view，本案例中是一张图片。</p>
<p>Toolbar类，实现toolbar的效果。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>源码：<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-02-22">github</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">              <span class="attr">app:layout_scrollFlags</span>=<span class="string">&quot;scroll|exitUntilCollapsed&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">app:layout_collapseMode</span>=<span class="string">&quot;parallax&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">app:layout_collapseMode</span>=<span class="string">&quot;pin&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>CoordinatorLayout在最外层，注意其直接子view必须就是要实现联动的view，否则联动失效。</li>
<li>CollapsingToolbarLayout必须设置layout_scrollFlags，其余属性可选。</li>
</ol>
<blockquote>
<p>layout_scrollFlags说明如下：</p>
<p><strong>scroll</strong>：所有想滚动出屏幕的view都需要设置这个flag， 没有设置这个flag的view将被固定在屏幕顶部。</p>
<p><strong>enterAlways</strong>：这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。</p>
<p><strong>enterAlwaysCollapsed</strong>：假设你定义了一个最小高度（minHeight）同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。</p>
<p><strong>exitUntilCollapsed</strong>：当你定义了一个minHeight，此布局将在滚动到达这个最小高度的时候折叠。</p>
<p><strong>snap</strong>：当一个滚动事件结束，如果视图是部分可见的，那么它将被滚动到收缩或展开。例如，如果视图只有底部25%显示，它将折叠。相反，如果它的底部75%可见，那么它将完全展开。</p>
<p>作者：尹star</p>
<p>链接：<a href="https://www.jianshu.com/p/5287d090e777">https://www.jianshu.com/p/5287d090e777</a></p>
</blockquote>
<ol>
<li>CollapsingToolbarLayout的子view需要指定layout_collapseMode，还有一点需注意：<strong>和toolbar联动的子view高度需大于toolbar高度，否则无效果。</strong></li>
<li>ViewPager就是本案例中触发子view联动效果的<code>dependency</code>，需要指定其behavior：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</span><br></pre></td></tr></table></figure>

<p>其实际对应于android.support.design.widget.AppBarLayout$ScrollingViewBehavior ，这个是系统实现的一个behavior，用于和嵌套滑动事件绑定，<strong>指定该behavior的子view需要是NestedScrollingChild的实现类</strong>（系统提供了4个实现类：NavigationMenuView、NestedScrollView、RecyclerView、SwipleRefreshLayout），所以viewPager中页面有上述4个类或其子类时，才能实现绑定效果。</p>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p><strong>自定义Behavior</strong></p>
<p>自定义Behavior有两个目的：</p>
<ol>
<li>将两个或多个子view绑定；</li>
<li>将一个子view与另一个子view的滑动事件绑定在一起</li>
</ol>
<p>两者的差异在于在实现<code>CoordinatorLayout.Behavior&lt;T&gt;</code> 类时候具体重写的方法不一样。</p>
<p><strong>目的1</strong>：需要重写的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, T child, View dependency)</span> &#123;</span><br><span class="line">    <span class="comment">//如果dependency是要依赖的子view（此处是TempView类）的实例，说明它就是我们所需要的Dependency</span></span><br><span class="line">    <span class="keyword">return</span> dependency <span class="keyword">instanceof</span> TempView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次dependency位置发生变化，都会执行onDependentViewChanged方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, T child, View dependency)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据dependency的位置，设置child的位置,对child进行想要实现的变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true表示改变了child 的尺寸和位置参数，否则返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目的2</strong>：需要重写的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否要开始根据dependency子view的行为改变child的状态</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onStartNestedScroll</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout, <span class="meta">@NonNull</span> ImageView child,<span class="meta">@NonNull</span> View directTargetChild, <span class="meta">@NonNull</span> View target, <span class="type">int</span> axes, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> child <span class="keyword">instanceof</span> ImageView &amp;&amp; axes == View.SCROLL_AXIS_VERTICAL;<span class="comment">//子view是ImageView，并且滑动的方向是垂直的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当dependency子view滑动时，对child进行相应处理</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNestedPreScroll</span><span class="params">(<span class="meta">@NonNull</span> CoordinatorLayout coordinatorLayout, <span class="meta">@NonNull</span> ImageView child, <span class="meta">@NonNull</span> View target, <span class="type">int</span> dx, <span class="type">int</span> dy, <span class="meta">@NonNull</span> <span class="type">int</span>[] consumed, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<h1 id="自定义-Behavior-的总结"><a href="#自定义-Behavior-的总结" class="headerlink" title="自定义 Behavior 的总结"></a>自定义 Behavior 的总结</h1><ol>
<li>确定 CoordinatorLayout 中 View 与 View 之间的依赖关系，通过 layoutDependsOn() 方法，返回值为 true 则依赖，否则不依赖。</li>
<li>当一个被依赖项 dependency 尺寸或者位置发生变化时，依赖方会通过 Byhavior 获取到，然后在 onDependentViewChanged 中处理。如果在这个方法中 child 尺寸或者位置发生了变化，则需要 return true。</li>
<li>当 Behavior 中的 View 准备响应嵌套滑动时，它不需要通过 layoutDependsOn() 来进行依赖绑定。只需要在 onStartNestedScroll() 方法中通过返回值告知 ViewParent，它是否对嵌套滑动感兴趣。返回值为 true 时，后续的滑动事件才能被响应。</li>
<li>嵌套滑动包括滑动(scroll) 和 快速滑动(fling) 两种情况。开发者根据实际情况运用就好了。</li>
<li>Behavior 通过 3 种方式绑定：1. xml 布局文件。2. 代码设置 layoutparam。3. 自定义 View 的注解。</li>
</ol>
<p>来源 ：<a href="http://blog.csdn.net/briblue/article/details/73076458">针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN博客</a></p>
</blockquote>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://blog.csdn.net/briblue/article/details/73076458">针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN博客</a>  </li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0824/6565.html">CoordinatorLayout 自定义Behavior并不难，由简到难手把手带你撸三款！ - 泡在网上的日子</a></li>
<li><a href="https://www.jianshu.com/p/8c92d0a1e591">一步一步深入理解CoordinatorLayout - 简书</a></li>
<li><a href="https://www.jianshu.com/p/5287d090e777">使用CoordinatorLayout打造一个炫酷的详情页 - 简书</a></li>
</ul>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android控件组</title>
    <url>/blog/posts/3b69424a/</url>
    <content><![CDATA[<p>这几天的工作中用到了控件组来实现复杂布局，效果不错，记录下来备用。</p>
<h1 id="1-定义控件组布局xxx-layout-xml"><a href="#1-定义控件组布局xxx-layout-xml" class="headerlink" title="1. 定义控件组布局xxx_layout.xml"></a>1. 定义控件组布局xxx_layout.xml</h1><p>在这里定义要使用的控件组布局，这里的布局决定了布局显示的样子。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="2-新建自定义属性文件attr-xml（可选）"><a href="#2-新建自定义属性文件attr-xml（可选）" class="headerlink" title="2.新建自定义属性文件attr.xml（可选）"></a>2.新建自定义属性文件attr.xml（可选）</h1><ul>
<li><p>在<code>values/attr.xml</code>下新建对应文件，并添加对于自定义属性，以便可以在activity布局文件里面使用到该件组时自定义控一些属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MSearchBar表明是给该控件使用的自定义属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;MSearchBar&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 以下为示例，可以根据需求增减 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;textColor&quot;</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;textSize&quot;</span> <span class="attr">format</span>=<span class="string">&quot;dimension&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在该自定义控件的类xxx.java中，通过如下语句获取从用户使用时赋给这些属性的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TypedArray</span> <span class="variable">array</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, R.styleable.MSearchBar);</span><br><span class="line"><span class="type">float</span> <span class="variable">textSize</span> <span class="operator">=</span> array.getDimension(R.styleable.MSearchBar_textSize, <span class="number">13</span>);</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>用户动态给这些属性赋值：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:textColor</span>=<span class="string">&quot;@color/colorPrimaryDark&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，这里写的是<code>app:</code>而非<code>android:</code>。</p>
<p>​</p>
</li>
</ul>
<h1 id="3-新建组合控件的类XXX-java"><a href="#3-新建组合控件的类XXX-java" class="headerlink" title="3. 新建组合控件的类XXX.java"></a>3. 新建组合控件的类XXX.java</h1><ul>
<li><p>新建XXX.java，继承自布局文件的父布局LinearLayout</p>
</li>
<li><p>更改参数少的构造方法的<code>super(a1,a2,a3)</code>为<code>this(a1,a2,a3)</code>，其中<code>this()</code>中的参数个数为参数最多的构造方法的参数数。</p>
<p><strong>注意</strong> ：一定要做这一步，否则在使用该自定义控件组时，新建该类的对象会提示出错</p>
</li>
<li><p>在最终会被调用的构造方法里面将xml里面定义的布局加载进来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意三个参数：布局文件：R.layout.weight_group_layout, root：this,是否依附到root：true</span></span><br><span class="line"><span class="comment">//必须有前两个参数，否则控件的宽高等会有异常</span></span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(context).inflate(R.layout.weight_group_layout, <span class="built_in">this</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用自定义属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MSearchBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">  </span><br><span class="line">  		<span class="comment">//do sth</span></span><br><span class="line">  </span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">array</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, R.styleable.MSearchBar);</span><br><span class="line">        <span class="type">float</span> <span class="variable">textSize</span> <span class="operator">=</span> array.getDimension(R.styleable.MSearchBar_textSize, <span class="number">13</span>);</span><br><span class="line">        editText.setTextSize(textSize);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>给控件组内部控件添加点击事件监听：</p>
<ul>
<li><p>xxx.java 要实现点击事件监听接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MSearchBar</span> <span class="keyword">extends</span> <span class="title class_">LinearLayout</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义接口，供使用xxx.java类时实现对监听事件的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImgLeftOnClickListener</span><span class="params">(OnImgClickListener listener)</span>&#123;</span><br><span class="line">    listenerL = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnImgClickListener</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> OnImgClickListener listenerL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对要监听点击事件的控件设置监听，并调用<code>listener.onClick()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在构造方法等地方设置监听事件</span></span><br><span class="line">imageViewLeft.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在xxx.java中重写onClick()方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">       <span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">           <span class="comment">//ImageLeft</span></span><br><span class="line">           <span class="keyword">case</span> R.id.imageView:</span><br><span class="line">               <span class="keyword">if</span> (listenerL != <span class="literal">null</span>) &#123;</span><br><span class="line">                   listenerL.onClick();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//imageRight</span></span><br><span class="line">           <span class="keyword">case</span> R.id.imageView2:</span><br><span class="line">               <span class="keyword">if</span> (listenerR != <span class="literal">null</span>) &#123;</span><br><span class="line">                   listenerR.onClick();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="4-使用自定义控件组xxx-java"><a href="#4-使用自定义控件组xxx-java" class="headerlink" title="4. 使用自定义控件组xxx.java"></a>4. 使用自定义控件组xxx.java</h1><ul>
<li><p>在布局文件main_activity.xml中添加该控件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/search_bar&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:textColor</span>=<span class="string">&quot;@color/colorPrimaryDark&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>在java中使用该控件，设置监听事件</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MSearchBar</span> <span class="variable">searchBar</span> <span class="operator">=</span> (MSearchBar) findViewById(R.id.search_bar);</span><br><span class="line">searchBar.setImgLeftOnClickListener(<span class="keyword">new</span> <span class="title class_">MSearchBar</span>.OnImgClickListener() &#123;</span><br><span class="line">        <span class="meta">@SuppressLint(&quot;WrongConstant&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">()</span> &#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;Click on Left&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="5-效果预览"><a href="#5-效果预览" class="headerlink" title="5.效果预览"></a>5.效果预览</h1><p><img src="http://upload-images.jianshu.io/upload_images/120748-48d0cbbf03ded7f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果预览"></p>
<h1 id="6-源码"><a href="#6-源码" class="headerlink" title="6.源码"></a>6.源码</h1><p>demo的github链接:<a href="https://github.com/jixiaoyong/my_application_on_deepin/tree/master/weightgroup">github</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android笔记之Xfermode</title>
    <url>/blog/posts/104c9058/</url>
    <content><![CDATA[<p><code>Xfermode</code>是Android中用来指示<code>Paint</code>绘制的内容与View中已有内容的混合计算方式,也就是用来确定图形绘制到目标图形的时候，如何处理两个图形重合部分的颜色变化。共18个，分为Alpha合成和混合两种。</p>
<p>设要绘制的图形为<code>src</code>，已经绘制好的图形为<code>dst</code>。</p>
<blockquote>
<p>需要注意的是，这些图片除了要绘制的图形有着色之外，其他部分要为透明，并且<strong>包括透明区域在内的图片大小（宽高）要能完全覆盖另外一张图片的图形区域</strong>，否则绘制出的图形可能与预设的效果不一致</p>
</blockquote>
<p>按照官方的定义，不同<code>Xfermode</code>绘制结果如下：</p>
<p><img src="https://jixiaoyong.github.io/images/20200415211144.png"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>要实现如上效果，需要注意：</p>
<ul>
<li><p><code>src</code>和<code>dst</code>符合要求（要有合适的透明区域）</p>
<p>这是因为<code>xfermode</code>的效果，使用透明部分的像素与已有图形对应位置交叉作用，得出所需要的效果，如果透明区域过小，则无法作用到对应的图形。下面这个来自Hencoder.com的图可以很形象的解释：</p>
<p><img src="https://jixiaoyong.github.io/images/20200416213802.jpg"></p>
</li>
<li><p>在新的图层绘制（在新的图层按照<code>xfermode</code>规则绘制，然后再将其绘制到原有图层）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建图层   </span></span><br><span class="line"><span class="keyword">val</span> saveCount = canvas.saveLayer(<span class="number">0F</span>,<span class="number">0F</span>,width.toFloat(),height.toFloat(),<span class="literal">null</span>,Canvas.ALL_SAVE_FLAG)</span><br><span class="line"></span><br><span class="line"><span class="comment">//dst  已经绘制的图形  ;  src 我们要绘制的图形</span></span><br><span class="line">canvas.drawBitmap(dst,<span class="number">0F</span>, <span class="number">0F</span>, dstPaint)</span><br><span class="line"></span><br><span class="line">srcPaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_OUT)</span><br><span class="line">canvas.drawBitmap(src,<span class="number">0F</span>, <span class="number">0F</span>, srcPaint)</span><br><span class="line">srcPaint.xfermode = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将新图层绘制到原有图层上</span></span><br><span class="line">canvas.restoreToCount(saveCount)</span><br></pre></td></tr></table></figure>


</li>
<li><p>关闭硬件加速（可选）</p>
<p>硬件加速的本质是把一部分CPU计算的工作量交给GPU完成，可以加速绘制速度。</p>
<p>但是由于硬件加速不支持<code>canvas.drawXXX()</code>的部分方法，为了避免在某些机型上面无法使用这些方法，可以关闭硬件加速：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">view.setLayerType(LAYER_TYPE_SOFTWARE, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>关于硬件加速更详细的说明可以参考这里：<a href="https://hencoder.com/ui-1-8/">HenCoder Android 自定义 View 1-8 硬件加速</a></p>
</li>
</ul>
<h1 id="Xfermode分类"><a href="#Xfermode分类" class="headerlink" title="Xfermode分类"></a>Xfermode分类</h1><p><a href="https://hencoder.com/ui-1-2/">HenCoder.com</a>关于<code>PorterDuff.Mode.DST_IN</code>的动画解释：</p>
<p><img src="https://jixiaoyong.github.io/images/20200416214402.gif"></p>
<p>可以看出，<code>Xfermode</code>的本质是处理<code>dst</code>与<code>src</code><strong>重合与未重合部分</strong>的展示与否，以及颜色变化。</p>
<blockquote>
<p>这里的“重合部分”与“未重合部分”，其实也包括了各个图形的透明部分，将<code>dst</code>与<code>src</code>的透明与不透明颜色相互作用，才会出现下述效果。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>CLEAR</code></td>
<td>清除所有内容</td>
</tr>
<tr>
<td><code>DST</code></td>
<td>只绘制<code>DST</code></td>
</tr>
<tr>
<td><code>DST_ATOP</code></td>
<td>先绘制<code>SRC</code>，再在顶部绘制<code>DST</code>与<code>SRC</code>重合的部分</td>
</tr>
<tr>
<td><code>DST_IN</code></td>
<td>只绘制<code>DST</code>与<code>SRC</code>重合部分</td>
</tr>
<tr>
<td><code>DST_OUT</code></td>
<td>只绘制<code>DST</code>与<code>SRC</code>未重合部分</td>
</tr>
<tr>
<td><code>DST_OVER</code></td>
<td>将<code>DST</code>绘制在<code>SRC</code>上面</td>
</tr>
<tr>
<td><code>SRC</code></td>
<td>只绘制<code>SRC</code></td>
</tr>
<tr>
<td><code>SRC_ATOP</code></td>
<td>先绘制<code>DST</code>，再在顶部绘制<code>SRC</code>与<code>DST</code>重合的部分</td>
</tr>
<tr>
<td><code>SRC_IN</code></td>
<td>只绘制<code>SRC</code>与<code>DST</code>重合部分</td>
</tr>
<tr>
<td><code>SRC_OUT</code></td>
<td>只绘制<code>SRC</code>与<code>DST</code>未重合部分</td>
</tr>
<tr>
<td><code>SRC_OVER</code></td>
<td>将<code>SRC</code>绘制在<code>DST</code>上面</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>XOR</code></td>
<td></td>
</tr>
<tr>
<td><code>ADD</code></td>
<td></td>
</tr>
<tr>
<td><code>DARKEN</code></td>
<td></td>
</tr>
<tr>
<td><code>LIGHTEN</code></td>
<td></td>
</tr>
<tr>
<td><code>MULTIPLY</code></td>
<td></td>
</tr>
<tr>
<td><code>OVERLAY</code></td>
<td></td>
</tr>
<tr>
<td><code>SCREEN</code></td>
<td></td>
</tr>
</tbody></table>
<p>各个效果如下(源码及使用见<a href="https://github.com/jixiaoyong/library/commit/71864b6546460acfaae6299890a0cf76da76b7d7">github</a>)：</p>
<p><img src="https://jixiaoyong.github.io/images/20200415211144.png"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://hencoder.com/ui-1-2/">HenCoder Android 开发进阶: 自定义 View 1-2 Paint 详解</a></p>
<p><a href="https://hencoder.com/ui-1-8/">HenCoder Android 自定义 View 1-8 硬件加速</a></p>
<p><a href="https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode.html">PorterDuff.Mode</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android笔记之跨进程通信</title>
    <url>/blog/posts/7e97a976/</url>
    <content><![CDATA[<p>Android中的跨进程通信IPC主要有以下几种方式：</p>
<ul>
<li>BroadcastReceiver</li>
<li>ContentProvider</li>
<li>AIDL</li>
<li>Messenger</li>
<li>Socket</li>
<li>文件</li>
</ul>
<p>Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制</p>
<p><strong>进程是资源分配的基本单位，线程是调度的基本单位。</strong></p>
<h1 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h1><p> 以下内容来自：</p>
<p>作者：SylvanasSun<br>链接：<a href="https://juejin.im/post/59f8691b51882534af254317">https://juejin.im/post/59f8691b51882534af254317</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>Linux为每个进程维护了一个单独的虚拟地址空间。<strong>虚拟地址空间分为内核空间与用户空间</strong>，用户空间包括代码、数据、堆、共享库以及栈，内核空间包括内核中的代码和数据结构，内核空间的某些区域被映射到所有进程共享的物理页面。Linux也将一组连续的虚拟页面（大小等于内存总量）映射到相应的一组连续的物理页面，这种做法为内核提供了一种便利的方法来访问物理内存中任何特定的位置。</p>
<p><img src="https://jixiaoyong.github.io/images/20200422114446.png" alt="示意图来自https://juejin.im/post/59f8691b51882534af254317"></p>
<p>Linux通过将一个虚拟内存区域与一个硬盘上的文件关联起来，以初始化这个虚拟内存区域的内容，这个过程称为<strong>内存映射</strong>（memory mapping）。这种将虚拟内存系统集成到文件系统的方法可以简单而高效地把程序和数据加载到内存中。</p>
<p><strong>普通文件映射就是将一个文件与一块内存建立起映射关系，对该文件进行IO操作可以绕过内核直接在用户态完成（用户态在该虚拟地址区域读写就相当于读写这个文件）</strong>。匿名文件映射一般在用户空间需要分配一段内存来存放数据时，由内核创建匿名文件并与内存进行映射，之后用户态就可以通过操作这段虚拟地址来操作内存了。匿名文件映射最熟悉的应用场景就是动态内存分配（malloc()函数）。</p>
<p><strong>内存映射提供了共享对象的机制，来避免内存资源的浪费。一个对象被映射到虚拟内存的一个区域，要么是作为共享对象，要么是作为私有对象的。</strong> 进程对共享对象的写操作对于其他也使用到该共享对象的进程是可见的。</p>
<p>CPU获取到虚拟地址，然后通过MMU（内存管理单元）将其翻译为物理地址。</p>
<h1 id="linux-IPC"><a href="#linux-IPC" class="headerlink" title="linux IPC"></a>linux IPC</h1><p>优缺点参考：</p>
<blockquote>
<ol>
<li>管道：在创建时分配一个page大小的内存，缓存区大小比较有限；</li>
<li>消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li>
<li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li>套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li>
<li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ol>
<p>作者：Gityuan<br>链接：<a href="https://www.zhihu.com/question/39440766/answer/89210950">https://www.zhihu.com/question/39440766/answer/89210950</a></p>
</blockquote>
<ul>
<li>管道Pipe</li>
</ul>
<p><a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)">管道</a> 是将标准输入输出连接起来的进程。 <strong>数据复制2次，有长度限制</strong></p>
<p><img src="https://jixiaoyong.github.io/images/20200422114721.jpg" alt="示意图来自https://pic002.cnblogs.com/images/2012/426620/2012110216160766.jpg"></p>
<p>如图，进程1将数据<strong>写入</strong>到管道（内存缓存区），进程2从管道中<strong>读取</strong>数据。数据从写端流入管道，从读端流出，这样就实现了进程间通信</p>
<p>每个进程的输出被当做下一个进程的输入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l | less //将ls -l 的结果输入到less中，实现分页</span><br></pre></td></tr></table></figure>


<p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html">Linux进程间通信之管道(pipe)、命名管道(FIFO)与信号(Signal)</a><br><a href="https://blog.csdn.net/skyroben/article/details/71513385">https://blog.csdn.net/skyroben/article/details/71513385</a></p>
<ul>
<li>消息队列Message</li>
</ul>
<p>是一串可以有不同类型的消息块的链表，可以避免阻塞。<strong>数据复制2次，有长度限制</strong>，缓冲小。</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html">https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html</a></p>
<ul>
<li>共享内存</li>
</ul>
<p>多个进程可以访问一个公用的内存空间。效率最高的IPC。<strong>数据内存复制0次,但是没有同步互斥机制</strong></p>
<ul>
<li>套接字Socket</li>
</ul>
<p>传输效率低，<strong>数据复制2次</strong></p>
<ul>
<li>信号量 semaphore</li>
</ul>
<p>与管道不同，信号量是为了保护进程共享资源在同一时刻只能被一个进程访问。解决同步和互斥问题。</p>
<p>sv：信号变量</p>
<p>对信号量的操作只有一下P(sv)和V(sv)两个原子操作:</p>
<ol>
<li>进程1访问资源时对信号量进行等待操作P(sv)（如果sv&gt;0则操作资源并将信号量-1，否则挂起进程等待）；</li>
<li>当该进程1对资源执行完操作后，对信号量进行发送操作V(sv)（此时如果有进程2等待sv而挂起，则恢复进程2，否则就给sv+1）</li>
</ol>
<p><a href="https://blog.csdn.net/skyroben/article/details/72513985">https://blog.csdn.net/skyroben/article/details/72513985</a></p>
<ul>
<li>信号 Signal</li>
</ul>
<p>信号是进程间通信中唯一的异步通信机制，通知接收信号的进程发生了什么事情。而进程接受到信号后可以忽略，捕获处理，或者使用系统默认操作。</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html">https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html</a></p>
<p>只能承载很小的信息量，主要用在进程的中断控制</p>
<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><p>数据拷贝1次，有权限校验（为发送方添加了UID&#x2F;PID身份）</p>
<p><img src="https://jixiaoyong.github.io/images/20200422115508.gif" alt="参与Binder通信的所有角色 图片来自https://blog.csdn.net/universus/article/details/6211589"></p>
<p>时序图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title:  Binder交互时序图 </span><br><span class="line"></span><br><span class="line">participant Client</span><br><span class="line">participant ServerManager</span><br><span class="line">participant Binder驱动</span><br><span class="line">participant Server</span><br><span class="line"></span><br><span class="line">note over Server: 服务创建Binder</span><br><span class="line">Server-&gt; Binder驱动: Binder对象及名字</span><br><span class="line">note over Binder驱动: Binder驱动在内核创建Binder对应实体节点及引用</span><br><span class="line">Binder驱动-&gt; ServerManager: 内核中的Binder对象引用及名字</span><br><span class="line">note over ServerManager: 注册Binder（将名字和应用填入查找表）</span><br><span class="line">Client -&gt; ServerManager: 客户端需要的Binder对象名字</span><br><span class="line">note over ServerManager: 查找保存的内核Binder对象应用</span><br><span class="line">ServerManager -&gt; Client: 客户端需要的Binder对象引用</span><br><span class="line">note over Client: 操作内核Binder</span><br><span class="line">Client --&gt;&gt; Server:相当于操作Server</span><br></pre></td></tr></table></figure>

<p><img src="https://jixiaoyong.github.io/images/20200422115253.png" alt="20200422115253"></p>
<p>理论上的Binder逻辑：</p>
<blockquote>
<p>SMgr提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成SMgr时Binder驱动会自动为它创建Binder实体（这就是那只预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。</p>
<p>在数据从发送方向接收方拷贝时，驱动会根据发送数据包的大小，使用最佳匹配算法从缓存池中找到一块大小合适的空间，<strong>将数据从发送缓存区复制过来</strong>。</p>
<p>为了实现用户空间到用户空间的拷贝，Binder驱动的mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。</p>
<p>版权声明：本文为CSDN博主「universus」的原创文章，遵循 CC 4.0 BY-SA </p>
<p>版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/universus/article/details/6211589">https://blog.csdn.net/universus/article/details/6211589</a></p>
</blockquote>
<p>主要参考文章：<a href="https://blog.csdn.net/universus/article/details/6211589">https://blog.csdn.net/universus/article/details/6211589</a></p>
<p><a href="https://blog.csdn.net/freekiteyu/article/details/70082302">https://blog.csdn.net/freekiteyu/article/details/70082302</a></p>
<p>Binder通信主要涉及一下对象：</p>
<ul>
<li>Server</li>
<li>Client</li>
<li>ServerManager</li>
<li>Binder驱动</li>
</ul>
<p>首先要知道，Server，Client以及ServerManager一般都在不同的进程之中，那么Server，Client如何与ServerManager通信并注册&#x2F;查询所需的服务呢？这里就需要用到<strong>0号引用Binder</strong>。</p>
<p><strong>0号引用Binder</strong> 是ServerManager内部创建匿名Binder，所有的Client（相对于ServerManager来说其他和他交互的都是Client）都默认持有这个Binder的引用。</p>
<p>所以一个完整的AIDL通信过程如下：</p>
<ol>
<li>Server创建一个Binder和对应名字</li>
<li>Server通过持有的0号引用Binder和ServerManager通信。<br>将生成的Binder和对应名字发送到Binder驱动，Binder驱动会为这个Binder在内核空间创建对应实体节点及其引用（<strong>复制了一次</strong>），并通过0号引用将其发给ServerManager。</li>
<li>ServerManager收到内核中的Binder对象引用及名字后将其保存到查找表中。</li>
<li>Client通过0号引用Binder和ServerManager通信。<br>Client将需要的Binder的名字发给ServerManager，ServerManager查询到已经注册的内核Binder引用并将其发给Client。</li>
<li>Client获取到内核Binder的引用进行操作。</li>
</ol>
<p>再来看看一个完整的流程：</p>
<p>在Service中，我们会先创建一个mIBinder对象并且在<code>public IBinder onBind(Intent intent)</code>方法返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">IBinder</span> <span class="variable">mIBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AidlBinderInterface</span>.Stub() &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//这里实现我们服务能够提供的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追踪onBind方法，我们会发现<code>mIBinder</code>的对象会在ActivityThread中的<code>private void handleBindService(BindServiceData data)</code>方法中被传入到IActivityManager的publishService方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">    ActivityManager.getService().publishService(</span><br><span class="line">                                data.token, data.intent, binder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityManager.getService()方法是通过IPC获取到ActivityManager的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Singleton</span>&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> IActivityManager <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> IActivityManager.Stub.asInterface(b);</span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>而根据<a href="https://www.jianshu.com/p/91c97710976a">这篇文章</a>，这个binder最终会被传输到绑定这个服务时所用的ServiceConnection对象的<code>onServiceConnected</code>方法中（<strong>即mIBinder通过ServerManager从Service传递到了Client</strong>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">mConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            mServiceInterface = AidlBinderInterface.Stub.asInterface(service);</span><br><span class="line">            <span class="comment">//我们通过得到的这个mServiceInterface可以在客户端调用服务所实现的方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>根据<a href="https://blog.csdn.net/zhangyongfeiyong/article/details/51953300">Android服务之bindService源码分析</a>mConnection会通过<code>context.bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</code>最终在ActivityManagerService通过Binder驱动程序调用ActivityThread类中的scheduleBindService方法传递到Service所在进程中，并根据Service的状态不同而被调用对应方法（<strong>即mConnection通过ServerManager从Client传递到了Service</strong>）。</p>
<p><img src="https://jixiaoyong.github.io/images/20200422115031.jpg" alt="图片来自https://img-blog.csdn.net/20160719100800917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>在这其中我们用到了两个涉及到AIDL文件：</p>
<ul>
<li>private IBinder mIBinder &#x3D; new AidlBinderInterface.Stub() {}</li>
<li>mServiceInterface &#x3D; AidlBinderInterface.Stub.asInterface(service);</li>
</ul>
<p>再来看看我们写的对应的AIDL文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface AidlBinderInterface &#123;</span><br><span class="line"> //在这里定义服务需要提供的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个文件中都是我们自己定义的方法，系统自动帮我们实现了更详细的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aidl;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AidlBinderInterface</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">com</span>.example.aidl.AidlBinderInterface &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.example.aidl.AidlBinderInterface&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         * 将DESCRIPTOR和这个接口绑定到一起</span></span><br><span class="line"><span class="comment">         * 本方法会在服务创建IBinder对象的时候调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.example.aidl.AidlBinderInterface interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.aidl.AidlBinderInterface <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查询本地是否有符合该描述（DESCRIPTOR）接口的Binder对象</span></span><br><span class="line">            android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="comment">// 有的话直接返回本地对象</span></span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="literal">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.aidl.AidlBinderInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.aidl.AidlBinderInterface) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有的话，创建代理类，进行跨进程通信</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.example.aidl.AidlBinderInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在通信时，如果asInterface返回本地对象，则会执行本地对接口（DESCRIPTOR）的实现方法，</span></span><br><span class="line">        <span class="comment">// 否则就会调用代理类com.example.aidl.AidlBinderInterface.Stub.Proxy中对应的方法进行跨进程通信</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">            java.lang.<span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> DESCRIPTOR;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getAvailablePointTags: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;String&gt; _result = <span class="built_in">this</span>.getAllStringTags();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               ...</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 代理类</span></span><br><span class="line"><span class="comment">         * 通过Binder对象mRemote执行AidlBinderInterface接口的具体方法</span></span><br><span class="line"><span class="comment">         * 具体则在mRemote.transact()实现了跨进程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">com</span>.example.aidl.AidlBinderInterface &#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//系统对我们在AIDL中定义的方法的具体实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;StringTag&gt; <span class="title function_">getAllStringTags</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;StringTags&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                     <span class="comment">// mRemote.transact()方法会：1.给服务端发消息 2.挂起当前线程 3.收到服务端返回后唤醒当前线程</span></span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getAllStringTags, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(StringTag.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//系统对每个接口方法的编号</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_getAllStringTags</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面这些是系统根据我们在aidl中定义的方法写的接口</span></span><br><span class="line">        <span class="keyword">public</span> java.util.List&lt;StringTag&gt; <span class="title function_">getAllStringTags</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可知<code>mRemote</code>便是指向AMS服务的<code>BinderProxy</code>对象 <a href="https://www.diycode.cc/topics/384">https://www.diycode.cc/topics/384</a></p>
<p><a href="https://www.cnblogs.com/a284628487/p/3187320.html">https://www.cnblogs.com/a284628487/p/3187320.html</a></p>
<p><img src="https://jixiaoyong.github.io/images/20200422114923.jpg" alt="图片来自https://images0.cnblogs.com/blog/391137/201307/12211553-49c477a875e84b2aae764c67f38f26b2.jpg"></p>
<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><p>如果在BroadcastReceiver 的onReceive方法中创建一个线程，那么当该方法返回时，Android系统就会认为该BroadcastReceiver已经完成任务了，从而会在需要回收内存时杀死进程以及其中的Thread。创建一个<a href="https://developer.android.google.cn/reference/android/app/job/JobService.html?hl=zh-cn">JobService</a>可以避免这个情况。</p>
<blockquote>
<p>So, the system may kill the process at any time to reclaim memory, and in doing so, it terminates the spawned thread running in the process.</p>
<p><a href="https://developer.android.google.cn/guide/components/activities/process-lifecycle?hl=zh-cn">https://developer.android.google.cn/guide/components/activities/process-lifecycle?hl=zh-cn</a></p>
</blockquote>
<p><a href="https://blog.csdn.net/universus/article/details/6211589">https://blog.csdn.net/universus/article/details/6211589</a></p>
<p><a href="https://www.jianshu.com/p/429a1ff3560c">https://www.jianshu.com/p/429a1ff3560c</a></p>
<p><a href="https://www.cnblogs.com/a284628487/p/3187320.html">https://www.cnblogs.com/a284628487/p/3187320.html</a></p>
<p><a href="http://hoyouly.fun/2019/07/17/Android-AIDL/">http://hoyouly.fun/2019/07/17/Android-AIDL/</a></p>
<p><a href="https://juejin.im/entry/59c9cd59f265da065754e6f1">https://juejin.im/entry/59c9cd59f265da065754e6f1</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统架构简介</title>
    <url>/blog/posts/e3bb9a54/</url>
    <content><![CDATA[<blockquote>
<p>说明：本文基于<a href="http://gityuan.com/android/">Android系统开篇 - Gityuan博客 | 袁辉辉博客 </a> 的学习笔记整理</p>
</blockquote>
<p>Android系统大体分为4个模块，从底层开始依次是1.linux内核、2.系统库+Android运行时、3.框架层、4.应用层。</p>
<p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidSystemArchitecture.png"></p>
<p>下图描述了Android系统从开机到Apk运行的整个流程。</p>
<p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/androidBoot.jpg" alt="系统启动框架图，来自gityuan.com"></p>
<p>流程如下：<code>Loader</code> -&gt; <code>Kernel</code> -&gt; <code>Native</code>-&gt; <code>Framework</code> -&gt; <code>App</code></p>
<p><strong>Loader层</strong></p>
<ol>
<li>Boot ROM ：开机时，引导芯片从ROM读取读取初始化代码，加载引导程序到RAM中。</li>
<li>Boot Loader：是启动Android系统之前的引导程序，检查RAM、初始化硬件参数等。</li>
</ol>
<p><strong>Kernel层</strong>（即Android内核层，进入Android系统）</p>
<ol>
<li>swapper进程（pid&#x3D;0）：Boot Loader启动swapper（idle）进程，是由内核创建的第一个进程，用来初始化进程管理、内存管理、驱动等等。</li>
<li>kthreadd进程（pid&#x3D;2）：是Linux系统的内核进程，<strong>是所有内核进程的鼻祖</strong>。</li>
</ol>
<hr>
<p><strong>Syscall</strong>，在Native和Kernel之间的系统调用层。</p>
<hr>
<p><strong>Native层</strong></p>
<ol>
<li>init进程（pid&#x3D;1）：由swapper进程创建，<strong>是所有用户进程鼻祖</strong></li>
<li>init进程孵化出用户守护进程、启动ServiceManager管理系统服务，启动开机动画Bootnaim。</li>
</ol>
<hr>
<p><strong>JNI</strong>，Java层和Native（C&#x2F;C++）层之间。</p>
<hr>
<p><strong>Framework层</strong></p>
<ol>
<li>Zygote进程：由init进程fork生成，是<strong>Android系统第一个java进程，是所有java进程的父进程</strong></li>
<li>SystemServer进程：由Zygote进程fork而来，<strong>是Zygote孵化的第一个进程</strong>，负责启动和管理整个<strong>java framework</strong>，如ActivityManager、PowerManager…</li>
<li>MediaServer进程：由init进程fork而来，负责启动和管理整个<strong>C++ framework</strong></li>
</ol>
<p><strong>APP层</strong></p>
<ol>
<li>Launcher：<strong>Zygote进程孵化的第一个App进程</strong>，桌面App。</li>
<li>其他由Zygote进程孵化的系统进程（Browser、Phone…）和非系统app进程。</li>
</ol>
<p>扼要内容如图：</p>
<p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidBootImg.png" alt="系统启动示意图"></p>
<p>Android常用的通信方式</p>
<ol>
<li>Binder</li>
<li>Socket</li>
<li>Handler</li>
</ol>
<p><strong>Binder&#x2F;Socket用于进程间（都具有独立的地址空间）通信，而Handler消息机制用于同进程的线程间（共享内存空间）通信</strong></p>
<p>在Android系统中：</p>
<ul>
<li>Zygote进程  –&gt;  Socket机制</li>
<li>SystemServer、MediaServer、App之间  –&gt;  Binder IPC</li>
<li>同一进程不同线程间 –&gt;  Handler</li>
</ul>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android笔记之贝塞尔曲线的应用</title>
    <url>/blog/posts/5c023044/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF">贝塞尔曲线</a>是用节点和控制点绘制的高精度曲线，Android中常用的有二阶、三阶贝塞尔曲线。本文介绍使用贝塞尔曲线绘制折线图，并实现动画效果。</p>
<p><img src="https://jixiaoyong.github.io/images/20200413215502.jpg"></p>
<p>本文代码链接：<a href="https://github.com/jixiaoyong/library/blob/master/library/src/main/java/cf/android666/applibrary/view/BezierViewAnim.kt">https://github.com/jixiaoyong/library/blob/master/library/src/main/java/cf/android666/applibrary/view/BezierViewAnim.kt</a></p>
<h1 id="贝塞尔曲线介绍"><a href="#贝塞尔曲线介绍" class="headerlink" title="贝塞尔曲线介绍"></a>贝塞尔曲线介绍</h1><p>下图是二阶贝塞尔曲线绘制方法介绍，只要各个点满足条件：AD&#x2F;AB &#x3D; BE&#x2F;BC &#x3D; DF&#x2F;DE，那么当沿着当前线段移动D、E点时，F点的运动轨迹就是一个贝塞尔曲线：</p>
<p><img src="https://jixiaoyong.github.io/images/20200413215622.png" alt="图片来自: https://www.cnblogs.com/wjtaigwh/p/6647114.html"></p>
<p>动图示意如下：</p>
<p><img src="https://jixiaoyong.github.io/images/20200413222352.webp"></p>
<p>可以在下面的两个网站在线体验贝塞尔曲线：</p>
<p><a href="https://aaaaaaaty.github.io/bezierMaker.js/playground/playground.html">https://aaaaaaaty.github.io/bezierMaker.js/playground/playground.html</a></p>
<p><a href="https://bezier.method.ac/">https://bezier.method.ac/</a></p>
<h1 id="计算控制点坐标"><a href="#计算控制点坐标" class="headerlink" title="计算控制点坐标"></a>计算控制点坐标</h1><p>在绘制折线图时，我们获取的数据可以当做贝塞尔曲线的端点，Android为我们提供了绘制二阶和三阶贝塞尔曲线的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path.quadTo(<span class="type">float</span> x1, <span class="type">float</span> y1, <span class="type">float</span> x2, <span class="type">float</span> y2)<span class="comment">//二阶贝塞尔曲线：分别是控制点的x、y坐标和结束的的x、y坐标</span></span><br><span class="line">Path.cubicTo(<span class="type">float</span> x1, <span class="type">float</span> y1, <span class="type">float</span> x2, <span class="type">float</span> y2, <span class="type">float</span> x3, <span class="type">float</span> y3)<span class="comment">//三阶贝塞尔曲线：分别是控制点1、2的x、y坐标和结束的的x、y坐标</span></span><br></pre></td></tr></table></figure>

<p>以<code>Path.cubicTo()</code>方法为例，在绘制三阶贝塞尔曲线时，起点和终点已知，剩下工作就是计算两个控制点的坐标。</p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>按照贝塞尔曲线的定义，计算各个点对应控制点的坐标，具体的计算原理我们可以参考<a href="https://wenku.baidu.com/view/c790f8d46bec0975f565e211.html">这篇文章</a></p>
<p>假设起点、终点分别为<code>startPoint</code>，<code>endPoint</code>，起点前一个点为<code>beforePointF</code>，终点后一个点为<code>afterPoint</code>，那么终止点1、2（<code>controlPoint1</code>、<code>controlPoint2</code>）的坐标满足（其中a,b为任意正数，比如1&#x2F;6）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> controlPoint1X = startPoint.x + (endPoint.x - beforePointF.x) * a</span><br><span class="line"><span class="keyword">val</span> controlPoint1Y = startPoint.y + (endPoint.y - beforePointF.y) * a</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> controlPoint2X = endPoint.x - (afterPoint.x - startPoint.x) * b</span><br><span class="line"><span class="keyword">val</span> controlPoint2Y = endPoint.y - (afterPoint.y - startPoint.y) * b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要处理特殊情况：第一个点P<del>0</del>的前一个仍然为P<del>0</del>，最后一个点P<del>n</del>的后一个点仍为P<del>n</del></p>
</blockquote>
<p>但这种情况绘制出来的贝塞尔曲线如下：</p>
<p><img src="https://jixiaoyong.github.io/images/20200413220840.jpg"></p>
<p>可以看到除了P<del>0</del>和P<del>n</del>外，其他点的曲线坐标和对应的点坐标不一致。</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>为了解决方法1存在的问题，我们人为的在两个点之间加入两个控制点，这样在<code>startPoint</code>，<code>endPoint</code>之间的贝塞尔曲线首尾点的坐标必定落在起点和终点上（思路来自<a href="https://blog.csdn.net/laizuling/article/details/51162011">这里</a>）。</p>
<p>所以，两个控制点的坐标为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> controlPoint1X = (startPoint.x + endPoint.x) / <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> controlPoint1Y = startPoint.y</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> controlPoint2X = (startPoint.x + endPoint.x) / <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> controlPoint2Y = endPoint.y</span><br></pre></td></tr></table></figure>

<p>这样绘制出来的曲线比较符合我们的要求。</p>
<p>所以，最终贝塞尔曲线path计算方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bezierPath = Path()</span><br><span class="line">bezierPath.moveTo(pointList.first().x, -pointList.first().y)</span><br><span class="line">pointList.forEachIndexed &#123; index, startPoint -&gt;</span><br><span class="line">    <span class="keyword">when</span> (index) &#123;</span><br><span class="line">        pointList.lastIndex -&gt; &#123;</span><br><span class="line">            <span class="comment">//在绘制P(n-1) ~ P(n)点的贝塞尔曲线时，已经绘制到了P(n)点，所以此处不用再绘制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> endPoint = pointList[index + <span class="number">1</span>]</span><br><span class="line">            bezierPath.cubicTo(</span><br><span class="line">                (startPoint.x + endPoint.x) / <span class="number">2</span>,</span><br><span class="line">                -startPoint.y, <span class="comment">//为了解决view坐标原点在左上角而做的特殊处理，下同</span></span><br><span class="line">                (startPoint.x + endPoint.x) / <span class="number">2</span>,</span><br><span class="line">                -endPoint.y,</span><br><span class="line">                endPoint.x,</span><br><span class="line">                -endPoint.y</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="给Path添加渐变背景"><a href="#给Path添加渐变背景" class="headerlink" title="给Path添加渐变背景"></a>给Path添加渐变背景</h1><p>我们可以使用<code>Paint.setShader(Shader shader)</code>方法，在绘制Path的时候绘制渐变背景。</p>
<p>渐变背景使用Shader实现。</p>
<p>为了确保绘制效果，我们需要在Path计算完成后，将其闭合，以确保绘制的背景在我们需要的范围内：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> shadowPaint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">shadowPaint.style = Paint.Style.FILL</span><br><span class="line"><span class="keyword">val</span> shader =</span><br><span class="line">    LinearGradient(<span class="number">0F</span>, <span class="number">0F</span>, <span class="number">0F</span>, <span class="number">500F</span>, Color.GREEN, Color.TRANSPARENT, Shader.TileMode.CLAMP)</span><br><span class="line"></span><br><span class="line">shadowPaint.shader = shader</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> shadowPath = Path(path)</span><br><span class="line">shadowPath.lineTo(endPoint.x, <span class="number">800F</span>)</span><br><span class="line">shadowPath.lineTo(startPoint.x, <span class="number">800F</span>)</span><br><span class="line">shadowPath.lineTo(startPoint.x, startPoint.y)</span><br><span class="line">shadowPath.close()</span><br><span class="line">canvas.drawPath(shadowPath, shadowPaint)</span><br></pre></td></tr></table></figure>

<h1 id="给Path添加动画"><a href="#给Path添加动画" class="headerlink" title="给Path添加动画"></a>给Path添加动画</h1><p>为了让Path看起来是从起点慢慢绘制到终点去的，我们可以先计算path的总长度，然后结合<code>ValueAnimator</code>实时获得对应长度的path并绘制：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mValueAnimator = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>)</span><br><span class="line">mValueAnimator.duration = <span class="number">10000</span></span><br><span class="line">mValueAnimator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">mValueAnimator.interpolator = AccelerateDecelerateInterpolator()</span><br><span class="line">mValueAnimator.addUpdateListener &#123; animation -&gt; <span class="comment">//获取从0-1的变化值</span></span><br><span class="line">    progress = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Float</span></span><br><span class="line">    <span class="comment">//不断刷新绘图，实现路径绘制</span></span><br><span class="line">    invalidate()</span><br><span class="line">&#125;</span><br><span class="line">mValueAnimator.start()</span><br></pre></td></tr></table></figure>

<p>然后在<code>onDraw()</code>方法中绘制对应的path：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mPathMeasure: PathMeasure = PathMeasure(bezierPath, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">val</span> totalPathLength = mPathMeasure.length <span class="comment">//获取path总长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照进度绘制贝塞尔曲线</span></span><br><span class="line"><span class="keyword">val</span> stopD = progress * totalPathLength</span><br><span class="line">mPathMeasure.getSegment(<span class="number">0F</span>, stopD, dstPath, <span class="literal">true</span>) <span class="comment">//按照长度比例截取对应的path并赋值给dstPath</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bezier anim</span></span><br><span class="line">canvas.drawPath(dstPath, bezierPaint) <span class="comment">//绘制对应的path</span></span><br></pre></td></tr></table></figure>



<p><img src="https://jixiaoyong.github.io/images/20200413222302.jpg"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>使用canvas绘制坐标时，需要注意android的坐标原点位于屏幕左上角。所以在绘制曲线图时可以先将坐标原点向下平移一段距离，再绘制对应坐标（可以绘制实际的y坐标负值）</p>
</li>
<li><p>在拼接贝塞尔曲线的path时候注意，<code>path.moveTo()</code>方法会将path切断</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wenku.baidu.com/view/c790f8d46bec0975f565e211.html">https://wenku.baidu.com/view/c790f8d46bec0975f565e211.html</a><br><a href="https://blog.csdn.net/laizuling/article/details/51162011">https://blog.csdn.net/laizuling/article/details/51162011</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android自定义View实现联系人列表</title>
    <url>/blog/posts/a2c96aac/</url>
    <content><![CDATA[<h1 id="自定义的view"><a href="#自定义的view" class="headerlink" title="自定义的view"></a>自定义的view</h1><ul>
<li>LetterIndex.java extends View</li>
<li>ContactsListView.java extends RecyclerView<br>#分析</li>
<li>联系人列表有两个要点<ul>
<li>字母导航栏<br>通过自定义View画出26个字母，设置滑动监听事件，根据上下滑动的距离判断当前选中的字母，并相应更新界面。</li>
<li>列表中的字母标题<br>针对item中的联系人姓名首字母对应的tag作比较，若与前一个相同则不显示title，否则显示。</li>
</ul>
</li>
<li>事件联动<ul>
<li>当滑动字母导航栏时，除了处理本身的变化外，还要留出接口，以便其他控件获取当前选中的字母。</li>
<li>联系人列表滑动时，除了处理本身变化外，同样要留出接口以便获取当前置顶的item对应的字母</li>
<li>字母导航栏要留出方法，以便其他控件指定选中的字母，并更新界面<h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><strong>ContactsListView.java</strong><br>重写该类主要是为了实现ItemDecoration根据不同的item变化，同时可以从xml布局文件中获取ItemDecoration的自定义属性。<br>主要代码：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ContactsListView(Context context) &#123;</span><br><span class="line">    this(context, null, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ContactsListView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ContactsListView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">    super(context, attrs, defStyle);</span><br><span class="line">    mTypeArray = context.obtainStyledAttributes(attrs, R.styleable.MyRecyclerDecoration);</span><br><span class="line">    mContext = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>故而在其内部自定义了一个继承自ItemDecoratio得静态内部类Decorationn类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Decoration(List&lt;String&gt; data)&#123;</span><br><span class="line">//获取要显示的联系人数据对应的英文tag集合</span><br><span class="line">//初始化各种自定义属性</span><br><span class="line">//例如颜色：mColorLetterText = mTypeArray.getColor(R.styleable.MyRecyclerDecoration_color_letter_text, 0xff152648);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">        public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state)&#123;</span><br><span class="line">//画出各个导航title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">        public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">//画出置顶的导航title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State</span><br><span class="line">                state) &#123;</span><br><span class="line">//判断是否画出导航title</span><br><span class="line"> super.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">            int position = ((RecyclerView.LayoutParams) (view.getLayoutParams())).getViewAdapterPosition();</span><br><span class="line"></span><br><span class="line">            if (position != -1) &#123;</span><br><span class="line">                String text = mDatas.get(position).substring(0, 1).toUpperCase();</span><br><span class="line">                if (position == 0) &#123;</span><br><span class="line">                    outRect.set(0, mTitleHeight, 0, 0);</span><br><span class="line">                &#125; else if (text != null &amp;&amp; !text.equals(mDatas.get(position - 1).substring(0, 1).toUpperCase())) &#123;</span><br><span class="line">                    outRect.set(0, mTitleHeight, 0, 0);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    outRect.set(0, 0, 0, 0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawText(Canvas canvas, float left, float right, View child, String text) &#123;</span><br><span class="line">//画出文字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LetterIndex.java</strong><br>该类用来画出字母导航栏，并且提供方法获取&#x2F;设置当前选中的字母</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface onIndexClickListener &#123;</span><br><span class="line">       void onIndexClick(int chooseId);</span><br><span class="line">       void onActionUp();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setOnIndexClickListener(onIndexClickListener listener) &#123;</span><br><span class="line">       this.mClickListener = listener;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setChooseId(int chooseId) &#123;</span><br><span class="line">       if (chooseId &gt;= 0 &amp;&amp; chooseId &lt; mIndexTexts.length) &#123;</span><br><span class="line">           mChooseId = chooseId;</span><br><span class="line">           invalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后重写<code>onTouchEvent(MotionEvent event)</code>方法，在ACTION_DOWN、ACTION_MOVE、ACTION_UP时调用对应的方法即可。</p>
<p>重写onDraw()方法，画出对应的界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"> protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">     super.onDraw(canvas);</span><br><span class="line">     int height = getHeight() - getPaddingTop() - getPaddingBottom();</span><br><span class="line">     float width = getWidth();</span><br><span class="line">     //childHeight 是每一个字母所在单元的高度</span><br><span class="line">     float childHeight = (float) height / mIndexTexts.length;</span><br><span class="line"></span><br><span class="line">     //如果被点击了，就画出背景</span><br><span class="line">     if (isClick) &#123;</span><br><span class="line">         mPaint.setColor(mColorIndexBg);</span><br><span class="line">         canvas.drawRect(0, 0, width, height, mPaint);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Rect bounds = new Rect();</span><br><span class="line">     mPaint.setTextSize(mSizeText);</span><br><span class="line">     mPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">     for (int i = 0; i &lt; mIndexTexts.length; i++) &#123;</span><br><span class="line">         String text = mIndexTexts[i];</span><br><span class="line">         mPaint.setColor(mColorText);</span><br><span class="line">         //在被选中的字后面画一个圆，并改变字的颜色</span><br><span class="line">         if (i == mChooseId) &#123;</span><br><span class="line">             mPaint.setColor(mColorChooseTextBg);</span><br><span class="line">             canvas.drawCircle(width / 2, childHeight / 2 + i * childHeight,</span><br><span class="line">                     mSizeText / 2 + 2, mPaint);</span><br><span class="line">             mPaint.setColor(mColorChooseText);</span><br><span class="line">         &#125;</span><br><span class="line">         mPaint.getTextBounds(text, 0, text.length(), bounds);</span><br><span class="line">         //bounds里面保存着要画的字的一些属性，如x，y，centerX，centerY等，</span><br><span class="line">         //要注意 canvas.drawText（text,x,y,mpaint）中y并不是text的最低端，而是baseline。</span><br><span class="line">         float x = width / 2;</span><br><span class="line">         float y = -bounds.centerY() + childHeight / 2 + i * childHeight;</span><br><span class="line">         canvas.drawText(text, x, y, mPaint);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源代码在我的Github，<a href="https://github.com/jixiaoyong/my_application_on_deepin/tree/master/contactsdemo/src/main">点这里</a>可以找到。</p>
<h1 id="预览如下"><a href="#预览如下" class="headerlink" title="预览如下"></a>预览如下</h1><p><img src="http://upload-images.jianshu.io/upload_images/120748-183eea3cad2b42ac.gif?imageMogr2/auto-orient/strip" alt="预览.gif"></p>
]]></content>
  </entry>
  <entry>
    <title>Android自定义view的一些知识点</title>
    <url>/blog/posts/e41787ec/</url>
    <content><![CDATA[<h1 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h1><p>View的绘制分为3部分：</p>
<ol>
<li><p>measure</p>
<p>测量，决定了View的测量宽、高。几乎所有情况下都等同于View的最终宽、高（如果View需要多次measure才能确定大小，或者重写了<code>layout()</code>方法，并修改了传入的值的话则不会相等）。</p>
</li>
<li><p>layout</p>
<p>布局，决定View的四个顶点坐标和实际的宽、高。</p>
</li>
<li><p>draw</p>
<p>绘制，决定了View的具体显示内容。</p>
</li>
</ol>
<p>其中通过ViewRootImpl类的<code>performTraversals()</code>依次调用<code>performXXX()</code>方法。</p>
<h1 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h1><p>MeasureSpec是一个32位int值，高2位表示SpecMode，低30位表示SpecSize。</p>
<p>SpecMode有3种可能值：</p>
<ul>
<li>UNSPECIFIED 父容器没有限定View大小，可以是任意需要的大小</li>
<li>EXACTLY 父类指定了View的具体大小，View的最终大小就是这个值(match_parent或者具体数值)</li>
<li>AT_MOST View可以是这个值以内的任意大小(wrap_content)</li>
</ul>
<p>我们指定的View的LayoutParams和父容器（DecorView则是窗口的尺寸，普通View是父容器的MeasureSpec）一起决定了View的MeasureSpec，进而决定了View的宽高。</p>
<p>SpecSize决定于父容器的尺寸、以及View的margin和padding。</p>
<h1 id="View绘制流程"><a href="#View绘制流程" class="headerlink" title="View绘制流程"></a>View绘制流程</h1><p>final类型的<code>measure()</code>方法调用<code>onMeasure()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">measure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cacheIndex</span> <span class="operator">=</span> forceLayout ? -<span class="number">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>onMeasure()</code>调用了<code>setMeasuredDimension()</code>方法设置了View宽、高的测量值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDefaultSize</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;<span class="comment">//返回getSuggestedMinimumWidth/Height的大小</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;<span class="comment">//返回测量大小</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getSuggestedMinimumXXX()</code>的值：</p>
<p>如果View没有背景，则返回的是View的<code>android:miniWidth</code>指定的值；</p>
<p>如果View有背景，则返回的是背景的<code>minimumWidth</code>的值和<code>android:miniWidth</code>指定的值中最大的一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getSuggestedMinimumWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mBackground == <span class="literal">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getSuggestedMinimumHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mBackground == <span class="literal">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由此，我们知道，如果直接继承自View的控件必须重写<code>onMeasure()</code>方法，设置wrap_content时候控件的大小。这是因为：</p>
<p>wrap_content对应的specMode是AT_MOST模式，其宽高等于<code>specSize</code>。</p>
<p>根据ViewGroup的<code>getChildMeasureSpec()</code>方法，我们知道此时的<code>specSize</code>是父容器目前可以用的大小，即这种情况下wrap_content的效果和match_parent的效果是一样的。</p>
<p>要避免这种情况，就需要重写<code>onMeasure()</code>方法，在里面专门指定wrap_content时View对应的大小。</p>
<h1 id="获取View的宽高"><a href="#获取View的宽高" class="headerlink" title="获取View的宽高"></a>获取View的宽高</h1><p>由于View的绘制和Activity的生命周期不同步，所以在<code>onCreate()/onStart()/onResume()</code>中都无法有效获取View的宽高。使用以下方式则可以正常获取View的宽高：</p>
<ol>
<li><p>Activity&#x2F;View#onWindowFocusChanged()</p>
<p>当前的Window获取或失去焦点的时候调用，此时View已经初始化完毕，可以获取宽、高。</p>
<p>Activity窗口焦点变化(onPause&#x2F;onResume)时会被调用多次。</p>
</li>
<li><p>View#post(runnable)</p>
<p>该runnable在view的消息队列尾部，被执行时View已经初始化好了，可以在这里获取宽高。</p>
</li>
<li><p>ViewTreeObserver</p>
<p>注册onGlobalLayoutListener，当View树的状态变更，或者View树内部View可见性发生变化就会被回调。</p>
<p>当View树的状态变更可能被调用多次。</p>
</li>
<li><p>View#measure()</p>
<p>手动调用<code>measure()</code>方法获取宽高。</p>
</li>
</ol>
<h1 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a>draw过程</h1><p>绘制过程分为以下几步：</p>
<ol>
<li>绘制背景 <code>background.draw(canvas);</code></li>
<li>绘制自身 <code>onDraw(canvas);</code></li>
<li>绘制children <code>dispatchDraw(canvas);</code></li>
<li>绘制装饰 <code>onDrawForeground(canvas);</code></li>
</ol>
<p><code>setWillNotDraw()</code>表示当前的ViewGroup不需要绘制任何内容，系统会对此进行优化（默认启用）。如果ViewGroup需要绘制内容时，则需要手动关闭这个标志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWillNotDraw</span><span class="params">(<span class="type">boolean</span> willNotDraw)</span> &#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="绘制两个图形重叠部分"><a href="#绘制两个图形重叠部分" class="headerlink" title="绘制两个图形重叠部分"></a>绘制两个图形重叠部分</h1><p>android自定义view时两个图形重叠部分的绘制方式,一定要调用<code>canvas.saveLayer()</code> ，否则不生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个步骤十分重要，将当前画布保存为新的一层</span></span><br><span class="line"><span class="type">int</span> <span class="variable">save</span> <span class="operator">=</span> canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,mWidth,mHeight,<span class="literal">null</span>,Canvas.ALL_SAVE_FLAG);</span><br><span class="line"></span><br><span class="line"><span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">paint.setColor(mBackgroundColor);</span><br><span class="line"></span><br><span class="line"><span class="type">RectF</span> <span class="variable">backgroundRectF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</span><br><span class="line">canvas.drawRoundRect(backgroundRectF, mRadius, mRadius, paint);</span><br><span class="line"></span><br><span class="line">paint.setColor(mForwardColor);</span><br><span class="line"><span class="comment">//设置二者重叠部分的绘制方式</span></span><br><span class="line">paint.setXfermode(<span class="keyword">new</span> <span class="title class_">PorterDuffXfermode</span>(PorterDuff.Mode.SRC_IN));</span><br><span class="line"><span class="type">RectF</span> <span class="variable">progressRectF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="number">0</span>, <span class="number">0</span>, mWidth * mProgress, mHeight);</span><br><span class="line">canvas.drawRect(progressRectF,paint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//restore to canvas</span></span><br><span class="line">canvas.restoreToCount(save);</span><br></pre></td></tr></table></figure>

<p><code>paint.setXfermode()</code>可以设置的值参考下图：</p>
<p><img src="http://jixiaoyong.github.io/images/20190408175100.png"></p>
<p>参考自<a href="https://www.cnblogs.com/DarkMaster/p/4618872.html">【原】使用Xfermode正确的绘制出遮罩效果 - sky0014 - 博客园  </a></p>
<h1 id="适配自定义view宽高，设置默认值"><a href="#适配自定义view宽高，设置默认值" class="headerlink" title="适配自定义view宽高，设置默认值"></a>适配自定义view宽高，设置默认值</h1><p>以其宽度为例，在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">widthMode</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">widthSize</span> <span class="operator">=</span> MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">    mWidth = widthSize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mWidth = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        mWidth = Math.min(mWidth, widthSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Android开发艺术探索》</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android自定义透明背景的Dialog</title>
    <url>/blog/posts/f20627c9/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通过自定义Dialog类，使用Style、AnimationDrawable等实现一个透明背景的、带进度更新的弹窗。</p>
<p>主要涉及Style自定义以及AnimationDrawable的使用。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul>
<li><strong>布局文件</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/dialog_bg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/image&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;250dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;250dp&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>资源文件</strong></li>
</ul>
<p>1）下载对应进度条的图片资源，放到drawable目录下</p>
<p>2）在drawable下新建dialog_progress.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/progress_1&quot;</span> //资源文件</span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;300&quot;</span> /&gt;</span> //持续时间ms</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/progress_2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;300&quot;</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3）dialog圆角背景（非必须）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;#6fb6d4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">&quot;500dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4）自定义dialog的style</p>
<p><code>windowBackground</code>使背景透明</p>
<p><code>backgroundDimEnabled</code>则可以去除半透明遮罩效果</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;diyDialogStyle&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@android:style/Theme.Dialog&quot;</span> &gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="comment">&lt;!--背景透明--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:backgroundDimEnabled&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="comment">&lt;!--半透明，模糊--&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DIYDialog.java</strong></li>
</ul>
<p>继承自<code>Dialog.java</code> ，并用构造函数调用<code>initView()</code>方法初始化dialog样式，有其他需求可以再自己实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化view、控件</span></span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> View.inflate(context, R.layout.layout_dialog, <span class="literal">null</span>);</span><br><span class="line"><span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> view.findViewById(R.id.image);</span><br><span class="line">imageView.setBackgroundResource(R.drawable.dialog_progress);</span><br><span class="line"><span class="comment">//填充布局</span></span><br><span class="line">setContentView(view);</span><br><span class="line"><span class="comment">//实现动画</span></span><br><span class="line"><span class="type">AnimationDrawable</span> <span class="variable">animationDrawable</span> <span class="operator">=</span> (AnimationDrawable) imageView.getBackground();</span><br><span class="line">animationDrawable.run();</span><br></pre></td></tr></table></figure>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/DIY_Dialog">github源码路径</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android运行时权限</title>
    <url>/blog/posts/a2863875/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了Android运行时权限的一些处理流程。</p>
<p>Android运行时权限是Android6之后出现的处理权限的新方式，此前开发者只需要应用需要的权限在AndroidManifest.xml文件中声明即可，现在则需要在使用到对应权限时检测是否有该权限并作出相应处理。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><ol>
<li><p>在<code>AndroidManifest.xml</code>中声明所需权限</p>
</li>
<li><p>在使用之前检查是否有该权限<code>checkSelfPermission()</code>,如果有则继续相应操作</p>
</li>
<li><p>如果没有权限则检测是否需要向用户解释为什么需要该权限<code>ActivityCompat.shouldShowRequestPermissionRationale()</code>，再决定如何申请权限<code>requestPermissions()</code></p>
<blockquote>
<p>需要说明的是，shouldShowRequestPermissionRationale()在第一次申请该权限时会返回false，第二次申请时返回true；</p>
<p>但是如果用户选择了<em>不再提醒</em> 则会一直返回false。所以如果判断当前并非第一次申请该权限，并且返回结果为false，就说明用户选择了不再提示，一般就需要提示用户到设置中开启对应权限。</p>
</blockquote>
</li>
<li><p>申请权限的结果在<code>onRequestPermissionsResult()</code>方法中返回，根据用户对权限的处理结果决定接下来的操作</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>onCreate()</code>方法中调用对应方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mSharedPreferences = getSharedPreferences(packageName, Context.MODE_PRIVATE)</span><br><span class="line">checkCameraDeviceAndPremissions()</span><br></pre></td></tr></table></figure>

<p><code>checkCameraDeviceAndPremissions()</code>具体内容</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkCameraDeviceAndPremissions</span><span class="params">()</span></span> &#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">//[2]每次使用之前检测是否有改权限</span></span><br><span class="line">        <span class="keyword">if</span> (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            safeRequestCameraPermission()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            safeOpenCamera(cameraId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对申请结果进行处理：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            <span class="comment">//[4]处理请求权限的结果</span></span><br><span class="line">            REQUEST_CAMERA -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    safeOpenCamera(cameraId)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> noCameraPermissionDialog = AlertDialog.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">                        .setTitle(<span class="string">&quot;警告⚠️&quot;</span>)</span><br><span class="line">                        .setMessage(<span class="string">&quot;没有相机权限，不可继续！\n请赋予相机权限&quot;</span>)</span><br><span class="line">                        .setCancelable(<span class="literal">false</span>)</span><br><span class="line">                        .setPositiveButton(<span class="string">&quot;Yes&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                            safeRequestCameraPermission()</span><br><span class="line">                        &#125;</span><br><span class="line">                        .setNegativeButton(<span class="string">&quot;No&quot;</span>) &#123; _, _ -&gt; finish() &#125;</span><br><span class="line">                        .create()</span><br><span class="line">                    noCameraPermissionDialog.show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>safeRequestCameraPermission()</code>的内容，这里才是处理申请权限的相关代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">safeRequestCameraPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//[3]检测是否需要解释为什么需要改权限</span></span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, Manifest.permission.CAMERA)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次请求时为false</span></span><br><span class="line"><span class="comment">         * 第二次请求时为true，需要解释为什么需要这个权限</span></span><br><span class="line"><span class="comment">         * 若用户选择了不再提示则一直为false</span></span><br><span class="line"><span class="comment">         * 综上，如果不是第一次请求该权限，并且返回值为false，那么可以判断用户选择了不再提示</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//向用户解释为什么需要改权限</span></span><br><span class="line">        <span class="keyword">var</span> noCameraDialog = AlertDialog.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">            .setTitle(<span class="string">&quot;提示️&quot;</span>)</span><br><span class="line">            .setMessage(<span class="string">&quot;本应用正常运行需要相机权限，点击确认开始赋予权限&quot;</span>)</span><br><span class="line">            .setCancelable(<span class="literal">false</span>)</span><br><span class="line">            .setPositiveButton(<span class="string">&quot;Yes&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                <span class="comment">//用户同意后开始申请权限</span></span><br><span class="line">                doRequestCameraPermission()</span><br><span class="line">            &#125;</span><br><span class="line">            .create()</span><br><span class="line">        noCameraDialog.show()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;count &quot;</span> + mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> (mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//TODO 用户拒绝了赋予权限，并且选择了“不再提醒”，提示用户到设置中开启</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doRequestCameraPermission()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doRequestCameraPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//每次申请权限时更新计数器</span></span><br><span class="line">    <span class="keyword">var</span> count = mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    mSharedPreferences.edit().putInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, count).apply()</span><br><span class="line">    requestPermissions(arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>样例代码: <a href="https://github.com/jixiaoyong/Notes-Files/commit/f41afa99c24cde1dab619462754435f2a2afc64e#diff-67ccb5e5c6c34760486a1071b23338a2">Github</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android通过Hook启动未注册Activity</title>
    <url>/blog/posts/26eab50a/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hook是钩子的意思，hook的过程是通过反射、代理等改变系统原有的行为以达到自己的目的。</p>
<p>本文主要是通过hook android 中的ActivityManagerService和Handler.CallBack，欺骗系统调起activity的过程，在调用startActivity时将targetIntent通过proxy伪装为proxyIntent，等到通过系统验证，正式启动activity时，再讲proxyIntent恢复为targetIntent，从而实现调用未在AndroidManifest.xml中注册的activity。</p>
<blockquote>
<p>需要注意，本方法只在Api&lt;26下有效。具体原因见后面。</p>
</blockquote>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="1-新建Activity等"><a href="#1-新建Activity等" class="headerlink" title="1.新建Activity等"></a>1.新建Activity等</h2><p><code>IndexActivity.java</code>用于启动<code>targetIntent</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((Button)findViewById(R.id.btn1)).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">               <span class="comment">//启动未在AndroidManifest.xml注册的activity</span></span><br><span class="line">               mContext.startActivity(<span class="keyword">new</span> <span class="title class_">Intent</span>(mContext,TargetActivity.class));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p><code>TargetActivity.java</code> 和<code>ProxyActivity.java</code> 分别设置对应页面布局<code>setContentView(R.layout.activity_xxx);</code></p>
<p><code>HookApplication.java</code> 用于调用hook方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HookApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        Utils.hookAms(<span class="built_in">this</span>);</span><br><span class="line">        Utils.hookHandle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AndroidManifest.xml</code>中注册<code>IndexActivity</code>和<code>ProxyActivity</code>，Application使用<code>HookApplication</code>。</p>
<h2 id="2-Utils-java实现hook具体逻辑"><a href="#2-Utils-java实现hook具体逻辑" class="headerlink" title="2.Utils.java实现hook具体逻辑"></a>2.Utils.java实现hook具体逻辑</h2><p><code>Utils.hookAms()</code> 实现拦截targetIntent并发起proxyIntent，欺骗系统对activity是否已注册的验证，其中proxyIntent通过<code>proxyIntent.putExtra(TARGET_KEY, targetIntent);</code> 方法携带targetIntent。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hookAms()核心代码</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">hookActivityManagerNative</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.app.ActivityManagerNative&quot;</span>);</span><br><span class="line">            <span class="comment">//在api&gt;26时无此变量：gDefault，该方法失效</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">gDefault</span> <span class="operator">=</span> hookActivityManagerNative.getDeclaredField(<span class="string">&quot;gDefault&quot;</span>);</span><br><span class="line">            gDefault.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> gDefault.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Class</span> <span class="variable">hookSingleton</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.util.Singleton&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">mInstance</span> <span class="operator">=</span> hookSingleton.getDeclaredField(<span class="string">&quot;mInstance&quot;</span>);</span><br><span class="line">            mInstance.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">oldAms</span> <span class="operator">=</span> mInstance.get(object);</span><br><span class="line"></span><br><span class="line">            <span class="type">Class</span> <span class="variable">hookIActivityManagerService</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.app.IActivityManager&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;hookIActivityManagerService&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MAmsInvocationHandler</span>(context,oldAms));</span><br><span class="line"></span><br><span class="line">			<span class="comment">//将原有的ActivityManagerService替换为我们自定义的</span></span><br><span class="line">            mInstance.set(object,proxy);</span><br></pre></td></tr></table></figure>

<p>在<code>MAmsInvocationHandler</code> 里面实现targetIntent和proxy的转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MAmsInvocationHandler核心代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MAmsInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TARGET_KEY</span> <span class="operator">=</span> <span class="string">&quot;targetIntent&quot;</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;startActivity&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">targetIntent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    targetIntent = (Intent) args[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetIntent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">proxyIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(mContext, ProxyActivity.class);</span><br><span class="line">                proxyIntent.putExtra(TARGET_KEY, targetIntent);</span><br><span class="line">                args[index] = proxyIntent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mOldAms,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，已经对activity.startActivity做了拦截，所有的targetIntent都会被拦截，存储在proxyIntent中，以通过系统的检查。</p>
<p>接下来，通过系统检查后，<code>hookHandle()</code>通过重写Handler.CallBack，对启动proxyIntent事件做拦截，使之启动targetIntent对应的Activity。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hookHandle()核心代码</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">activityThreadCls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">currentActivityThread</span> <span class="operator">=</span> activityThreadCls.getDeclaredMethod(<span class="string">&quot;currentActivityThread&quot;</span>);</span><br><span class="line">currentActivityThread.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">activityThread</span> <span class="operator">=</span> currentActivityThread.invoke(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">mH</span> <span class="operator">=</span> activityThreadCls.getDeclaredField(<span class="string">&quot;mH&quot;</span>);</span><br><span class="line">mH.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> (Handler) mH.get(activityThread);</span><br><span class="line"><span class="type">Field</span> <span class="variable">callBack</span> <span class="operator">=</span> Handler.class.getDeclaredField(<span class="string">&quot;mCallback&quot;</span>);</span><br><span class="line">callBack.setAccessible(<span class="literal">true</span>);</span><br><span class="line">callBack.set(handler, <span class="keyword">new</span> <span class="title class_">ActivityThreadHandlerCallBack</span>(handler));</span><br></pre></td></tr></table></figure>

<p>其中<code>ActivityThreadHandlerCallBack</code> 将返回我们自定义的CallBack以替换系统的，实现启动targetIntent而非proxyIntent。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ActivityThreadHandlerCallBack核心代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityThreadHandlerCallBack</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>.Callback&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what == <span class="number">100</span>) &#123;</span><br><span class="line">            handleLaunchActivity(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//主要代码，在这里将proxyIntent转化为targetIntent</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleLaunchActivity</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> msg.obj;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">intent</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;intent&quot;</span>);</span><br><span class="line">            intent.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">proxyIntent</span> <span class="operator">=</span> (Intent) intent.get(object);</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">targetIntent</span> <span class="operator">=</span> proxyIntent.getParcelableExtra(MAmsInvocationHandler.TARGET_KEY);</span><br><span class="line">            <span class="keyword">if</span> (targetIntent != <span class="literal">null</span>) &#123;</span><br><span class="line">                proxyIntent.setComponent(targetIntent.getComponent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，就实现了启动通过已经注册了的ProxyActivity启动未注册TargetActivity的全过程。</p>
<p>主要思想是找到系统实现该过程的逻辑，在对应地方通过反射获取到对应变量，插入自己的逻辑，从而达到目的。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>上面涉及到的代码路径：</p>
<p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/AndroidHook/20180116">github源代码路径</a></p>
<p>参考了几篇文章，其中较为完整的一篇如下：</p>
<p><a href="https://www.jianshu.com/p/69bfbda302df">Android插件化系列第（一）篇—Hook技术之Activity的启动过程拦截</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android阅读笔记</title>
    <url>/blog/posts/aacd75ab/</url>
    <content><![CDATA[<h2 id="layout-weight"><a href="#layout-weight" class="headerlink" title="layout_weight"></a>layout_weight</h2><p>layout_weight 重要性，默认的是0,0等级最高，要显示，数字越大重要性越低。</p>
<p>例：a，b的宽度为0，layout_weight分别为1、2，则a，b宽度分别为父容器的2&#x2F;3、1&#x2F;3。</p>
<h2 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h2><p>PendingIntent是封装后的intent，有intent执行所需的context，所以即使要执行intent的activity已经消失或者还没生成，其他activity依然可以通过PendingIntent执行intent。</p>
<blockquote>
<p>PendingIntent is a description of an Intent and target action to perform with it. Instances of this class are created with <code>getActivity(Context, int, Intent, int)</code>, <code>getActivities(Context, int, Intent[], int)</code>, <code>getBroadcast(Context, int, Intent, int)</code>, and <code>getService(Context, int, Intent, int)</code>; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.</p>
</blockquote>
<p>也就是把自己要执行的intent和执行所需的context封装后给别人，请别人在适当的时候执行。</p>
<h2 id="android模拟器访问电脑localhost"><a href="#android模拟器访问电脑localhost" class="headerlink" title="android模拟器访问电脑localhost"></a>android模拟器访问电脑localhost</h2><p>电脑<code>localhost</code>或者<code>127.0.0.1</code>访问本地网址。</p>
<p>模拟器访问<code>localhost</code>会默认访问手机的本地网址，要访问电脑的本地网址则需要访问<code>10.0.2.2:8080</code>，记得加上对应的端口。</p>
<h2 id="获取屏幕画面"><a href="#获取屏幕画面" class="headerlink" title="获取屏幕画面"></a>获取屏幕画面</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> MainActivity.<span class="built_in">this</span>.getWindow().getDecorView();</span><br><span class="line">decor.setDrawingCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">imageView.setImageBitmap(decor.getDrawingCache());</span><br></pre></td></tr></table></figure>

<h2 id="获取网络信息，请求网络"><a href="#获取网络信息，请求网络" class="headerlink" title="获取网络信息，请求网络"></a>获取网络信息，请求网络</h2><p>需要请求权限</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">chackNetWork</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isNetAvailable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">ConnectivityManager</span> <span class="variable">manager</span> <span class="operator">=</span> (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (manager.getActiveNetworkInfo() != <span class="literal">null</span>) &#123;</span><br><span class="line">        isNetAvailable = manager.getActiveNetworkInfo().isAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isNetAvailable) &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;open network&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">        intent.setAction(Settings.ACTION_NETWORK_OPERATOR_SETTINGS);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h1><p><code>LiveData</code>可以在数据有变化的时候调用订阅者并执行指定方法。</p>
<p><code>Transformations</code>有两个转化<code>LiveData</code>的方法：<code>map()</code>和<code>switchMap()</code>。</p>
<p><code>map()</code>可以将一个<code>LiveData</code>经过处理转化为另外一个<code>LiveData</code>。</p>
<p>而<code>switchMap()</code>则可以根据不同的需要切换不同的<code>LiveData</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> live = MutableLiveData&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> d : LiveData&lt;String&gt; = map(live)&#123;</span><br><span class="line">  <span class="string">&quot;this is <span class="variable">$it</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> e = switchMap(live) &#123;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@switchMap</span> <span class="keyword">when</span> (it) &#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span> -&gt; MutableLiveData&lt;String&gt;(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="string">&quot;b&quot;</span> -&gt; MutableLiveData(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; MutableLiveData(<span class="string">&quot;else&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，<code>LiveData</code>的子类<code>MediatorLiveData</code>可以添加多个监听项，每个项目改变都会回调对应的<code>onChange()</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mediatorLiveData = MediatorLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">mediatorLiveData.addSource(d) &#123;</span><br><span class="line">    update(it, e.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mediatorLiveData.addSource(e) &#123;</span><br><span class="line">    update(d.value, it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(a: <span class="type">String</span>? = <span class="string">&quot;&quot;</span>, b: <span class="type">String</span>? = <span class="string">&quot;&quot;</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/dab2ee97d680">【译】LiveData 使用详解</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>AppWidget的使用之PendingIntent</title>
    <url>/blog/posts/fcfc830b/</url>
    <content><![CDATA[<p>这几天学习 AppWidget ，很简单的组件却花费了不少功夫，今天对 PendingIntent 的用法做了一些简单的整理。</p>
<p><strong>PendingIntent</strong></p>
<blockquote>
<p>PandingIntent 就像是一个设计好的处理预案，当达到某个特定条件时，便会调用该 Intent 所指定动作（打开服务，Activity或者发送广播）。</p>
<p>这里使用该方法在 AppWidget 里面为按钮添加监听事件，当按钮被点击的时候触发相应的动作</p>
</blockquote>
<p>AppWidget 和应用程序不再同一个进程当中，而是在 HomeScreen 上面执行,所以不能直接为 AppWidget 中的 Button 添加监听事件，需要用 <code>remoteViews.setPendingIntent(R.id.widget_button,pendingIntent);</code>意思是当按下按钮的时候 pendingIntent 中的 Intent 就会执行</p>
<p>PendingIntent 当某个事件出现之后才会执行</p>
<p>RemoteViews对象 代表了一系列的 View 对象，和主程序不在同一个进程为 AppWidget 控件绑定处理器</p>
<p><strong>流程概述：</strong></p>
<ul>
<li><p>添加 appwidget_provider_info.xml 在 res&#x2F;xml 下新建 appwidget_provider_info.xml</p>
<ul>
<li>描述 AppWidget 的基本信息如最小高度、宽度等，还有就是该挂件的布局文件</li>
</ul>
</li>
<li><p>在 res&#x2F;layout 下面为该挂件设置具体的布局样式</p>
<ul>
<li>向 AppWidget 的布局文件中添加一个 Button</li>
<li>向 AppWidget 的布局文件中添加一个 TextView</li>
</ul>
</li>
<li><p>新建 MyAppWidget.java 继承自 AppWidgetProvider</p>
<p>在该类的 onUpdate() 方法中为 Button 设置、添加监听事件</p>
<ul>
<li>建立一个 Intent 对象</li>
<li>用该 Intent 对象创建一个 PendingIntent 对象</li>
<li>创建一个 RemoteViews 对象</li>
<li>用该 RemoveViews 对象为 按钮绑定事件处理器</li>
<li>更新按钮</li>
</ul>
</li>
<li><p>注册事件</p>
</li>
<li><p>备注：要是为 AppWidget 中的 Button 设置的事件是打开一个 TargetActivity ，还需要添加一个 TargetActivity 类和对应的布局文件</p>
</li>
</ul>
<p><strong>以下是代码</strong></p>
<ul>
<li>appwidget_provider_info.xml</li>
</ul>
<p>这个布局文件是 AppWidget 的信息</p>
<p>描述了 AppWidget 的最小高，最小宽以及它的布局文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;appwidget-provider</span><br><span class="line">    android:minHeight=&quot;200dp&quot;</span><br><span class="line">    android:minWidth=&quot;300dp&quot;</span><br><span class="line">    android:initialLayout=&quot;@layout/app_widget&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">&lt;/appwidget-provider&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>app_widget.xml</li>
</ul>
<p>这个布局文件是 Widget 在桌面上显示的样式</p>
<p>定义了 AppWidget 中各个组件及其样式</p>
<p>其中 Button 用来响应点击事件，加入 TargetActivity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;200dp&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;hello,world!&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=&quot;@+id/app_widget_btn&quot;</span><br><span class="line">        android:layout_width=&quot;200dp&quot;</span><br><span class="line">        android:layout_height=&quot;150dp&quot;</span><br><span class="line">        android:background=&quot;#ff00ff&quot;</span><br><span class="line">        android:text=&quot;this is my app widget button&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>target_activity.xml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;50sp&quot;</span><br><span class="line">        android:background=&quot;#00ff00&quot;</span><br><span class="line">        android:text=&quot;\n hello,welcome to target activity!&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>MyAppWidget.java</li>
</ul>
<p>主要是修改了 update() 方法：</p>
<p>定义了一个预先设定的动作—- Intent 对象；</p>
<p>利用该 Intent 读写，创建一个 PendingIntent 对象；</p>
<p>创建一个 RemoteView 对象，并为按钮绑定监听事件</p>
<p>刷新 AppWidget。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyAppWidget extends AppWidgetProvider &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onReceive(context, intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onUpdate(Context context, AppWidgetManager appWidgetManager,</span><br><span class="line">                         int[] appWidgetIds) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class="line"></span><br><span class="line">        //appWidgetIds 每一次向屏幕添加 AppWidget 的时候都会增加一个唯一的 appWidget 的 Id</span><br><span class="line">        for(int i = 0; i &lt; appWidgetIds.length;i++)&#123;</span><br><span class="line">          //创建一个 Intent 对象</span><br><span class="line">            Intent intent = new Intent(context,TargetActivity.class);</span><br><span class="line">            //创建一个 PendingIntent 对象</span><br><span class="line">            PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0);</span><br><span class="line">            // remoteViews 代表 AppWidget 上所有的控件</span><br><span class="line">            RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget);</span><br><span class="line">            //为按钮绑定事件处理器</span><br><span class="line">            /*</span><br><span class="line">            * 参1，指定被绑定处理器的控件id</span><br><span class="line">            * 参2，指定事件发生时会被执行的 PendingIntent</span><br><span class="line">             */</span><br><span class="line">            remoteViews.setOnClickPendingIntent(R.id.app_widget_btn,pendingIntent);</span><br><span class="line">            //更新 AppWidget ，参1是用于指定被更新 appWidget 的ID</span><br><span class="line">            appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDeleted(Context context, int[] appWidgetIds) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onDeleted(context, appWidgetIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onEnabled(Context context) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onEnabled(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDisabled(Context context) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onDisabled(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>TargetActivity.java</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TargetActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.target_activity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>AndroidManifest.xml</li>
</ul>
<p>在 AndroidManifest.xml 中注册 TargetActivity 和 MyAppWidget</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.TargetActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里注册了一个 MyAppWidget 接收数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyAppWidget&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;android.appwidget.provider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:resource</span>=<span class="string">&quot;@xml/appwidget_provider_info&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>AsyncTask源码解析</title>
    <url>/blog/posts/7ee9086b/</url>
    <content><![CDATA[<blockquote>
<p>这是AsyncTask源码的简单分析，主要基于《Android开发艺术探索》一书的内容。</p>
</blockquote>
<p>AsyncTask是Android中多线程处理方式之一（其余为1.HandlerThread、2.IntentService以及普通的线程Thread）。</p>
<p>AsyncTask本质是线程池和Handler的包装类，适合实时更新后台任务进度的工作，特别耗时的工作应当交给线程池处理。</p>
<p>AsyncTask常用方法：</p>
<ul>
<li>onPreExecute()</li>
<li>doInBackground()</li>
<li>onProgressUpdate()</li>
<li>onPostExecute()</li>
</ul>
<p>AsyncTask有一下限制：</p>
<ol>
<li>AsyncTask对象必须在主线程（UI线程，下同）创建</li>
<li>AsyncTask的execute()必须在主线程调用，且只能被调用一次</li>
<li>不能<strong>直接调用</strong>其4种常用方法（见上）</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li>继承自AsyncTask，重写对应方法。（注意如果需要更新进度，要在doInBackground()方法中调用publishProgress()方法）</li>
<li>在<strong>UI线程</strong> 实例化AsyncTask对象，并调用其execute()方法，传入参数开始执行。</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>在execute(params)执行后，将参数params传入mWorker.call()方法</strong></p>
<p>{调用doInBackground(params)后台执行任务，同时通过postResult()方法发送执行结果，由InternalHandler.handleMessage()判断该执行finish()还是onProgressUpdate()}</p>
<p>{将mWorker传入mFuture中作为其callable在runAndReset()方法中执行c.call()方法。}</p>
<p><strong>通过exec.execute(mFuture)将其压入SerialExecutor线程池中排队，并在THREAD_POOL_EXECUTOR.execute(mActive)真正执行。</strong></p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>创建对象（代码有节略，下同）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment">//注意这里的要求，必须在ui线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Looper callbackLooper)</span> &#123;</span><br><span class="line">    mHandler = callbackLooper == <span class="literal">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()<span class="comment">//此处创建InternalHandler用于在UI线程处理消息</span></span><br><span class="line">        : <span class="keyword">new</span> <span class="title class_">Handler</span>(callbackLooper);</span><br><span class="line"></span><br><span class="line">    mWorker = <span class="keyword">new</span> <span class="title class_">WorkerRunnable</span>&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Result <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = doInBackground(mParams);<span class="comment">//注意这里会调用doInBackground()方法，后台线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> tr;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postResult(result);<span class="comment">//此处发送msg到mHandler那里接受处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mFuture = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Result&gt;(mWorker) &#123;<span class="comment">//这里将mWorker传了进去</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看FutureTask</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable; <span class="comment">//将mWorker当做了他的callable</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                 result = c.call(); <span class="comment">//会在这里回调mWorker的call()方法，即前文所说的doInBackgroud()之类的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在主线程调用execute()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title function_">execute</span><span class="params">(Params... params)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title function_">executeOnExecutor</span><span class="params">(Executor exec,</span></span><br><span class="line"><span class="params">        Params... params)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123; <span class="comment">//此处限制execute()只能被执行一次</span></span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task is already running.&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task has already been executed &quot;</span></span><br><span class="line">                        + <span class="string">&quot;(a task can be executed only once)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    onPreExecute(); <span class="comment">//开始前准备工作</span></span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params; <span class="comment">//将参数传入mWorker，并一并传入mFuture中</span></span><br><span class="line">    exec.execute(mFuture);<span class="comment">//将准备好参数、执行时间的mFuture排队放入串行线程池中，等待执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了常用方法之一onPreExecute();</p>
<p>mWorker和mFuture的关系前文已经描述了，在看一下exec.execute(mFuture)执行了什么：</p>
<p>exec是execute()传入的，对应于sDefaultExecutor，再查下去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An &#123;<span class="doctag">@link</span> Executor&#125; that executes tasks one at a time in serial</span></span><br><span class="line"><span class="comment">     * order.  This serialization is global to a particular process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">SERIAL_EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerialExecutor</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Executor</span> <span class="variable">sDefaultExecutor</span> <span class="operator">=</span> SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure>

<p>再看看SerialExecutor这个线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SerialExecutor主要的作用是将这些线程放到线程池中，并按照串行的顺序依次调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SerialExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> &#123;</span><br><span class="line">        <span class="comment">//offer() Inserts the specified element at the end of this deque.</span></span><br><span class="line">        <span class="comment">//将r插入到线程池中</span></span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//等到当前的执行完了，就调用下一个</span></span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="literal">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">scheduleNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);<span class="comment">//在这里面才是真正的执行线程的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再仔细看一下THREAD_POOL_EXECUTOR</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">        sPoolWorkQueue, sThreadFactory);</span><br><span class="line">threadPoolExecutor.allowCoreThreadTimeOut(<span class="literal">true</span>);</span><br><span class="line">THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Executes the given task sometime in the future.  The task</span></span><br><span class="line"> <span class="comment">//may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line">ThreadPoolExector.executr()</span><br></pre></td></tr></table></figure>

<p>以上介绍了线程和线程池部分的内容，接下来看一下在主线程和后台线程之间是如何依靠handler机制来传递消息的。</p>
<p>关于构造函数，由于我们开发者只能接触到AsyncTask()这个构造函数，所以<code>mHandler=getMainHandler()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AsyncTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>((Looper) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@hide，普通开发者不可见</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Looper callbackLooper)</span> &#123;</span><br><span class="line">        mHandler = callbackLooper == <span class="literal">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : <span class="keyword">new</span> <span class="title class_">Handler</span>(callbackLooper);</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title function_">getMainHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                sHandler = <span class="keyword">new</span> <span class="title class_">InternalHandler</span>(Looper.getMainLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sHandler;<span class="comment">//sHandler是一个类变量，取的是主线程的looper,所以限制了AsyncTask只能在主线程实例化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下InternalHandler类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InternalHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InternalHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123; <span class="comment">//在这里处理后台线程发过来的消息，UI线程</span></span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，在doInBackground()方法中可以使用publishProgress()在后台更新进度，即是使用了handler发送消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">publishProgress</span><span class="params">(Progress... values)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AsyncTaskResult</span>&lt;Progress&gt;(<span class="built_in">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，AsyncTask的finish()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">(Result result)</span> &#123;</span><br><span class="line">    <span class="comment">//可见，最后会根据情况调用onCancelled()或者onPostExecute()</span></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose屏幕适配</title>
    <url>/blog/posts/e15dda2e/</url>
    <content><![CDATA[<h1 id="Compose屏幕适配"><a href="#Compose屏幕适配" class="headerlink" title="Compose屏幕适配"></a>Compose屏幕适配</h1><p>一种<strong>Compose</strong>中屏幕适配的解决方案，灵感参考<em>头条屏幕适配</em>、<em>AndroidAutoSize</em>等，以设计稿宽度和屏幕水平方法大小为准，等比拉伸控件大小。</p>
<p>后文附有本方案的Kotlin语言实现，使用只需要两个步骤即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        SizeEtx.<span class="keyword">init</span>(<span class="keyword">this</span>, <span class="number">375</span>) <span class="comment">// 375为设计稿宽度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 使用</span></span><br><span class="line">size(width = <span class="number">9.</span>composeDp, height = <span class="number">16.</span>composeDp)</span><br></pre></td></tr></table></figure>

<h1 id="主要的设计思想"><a href="#主要的设计思想" class="headerlink" title="主要的设计思想"></a>主要的设计思想</h1><p>假设如下变量：设计稿总宽度<code>dpx</code>，控件在设计稿中的大小<code>n</code>，屏幕的实际水平dp大小<code>rdp</code>，以及我们需要求得的控件在设备中的dp值<code>m</code>。</p>
<p>那么我们不难得到以下方程：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">n / dpx = m / rdp</span><br></pre></td></tr></table></figure>

<p>也就可以推导出：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">m = n * (rdp / dpx)</span><br></pre></td></tr></table></figure>

<p>上述值中，只有屏幕水平dp值<code>rdp</code>还是未知的，又根据<strong>（<code>density</code> 在每个设备上都是固定的，<code>DPI</code> &#x2F; 160 &#x3D; <code>density</code>，屏幕的总 px 宽度<code>wpx</code> &#x2F; <code>density</code> &#x3D; 屏幕的总 dp 宽度<code>rdp</code>）</strong>可知：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">rdp = wpx / density</span><br></pre></td></tr></table></figure>

<p>所以，我们可以推导出：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">m = n * (rdp / dpx)</span><br><span class="line">  = n * ( wpx / density ) / dpx</span><br><span class="line">  = n * wpx / (density * dpx)</span><br></pre></td></tr></table></figure>

<p>到这里，等式后面的所有数据都为已知或者在app运行时可知，由此我们可以计算出设计稿中的控件在Compose中对应的dp大小。</p>
<p>下面是以上思路的kotlin实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.res.Configuration</span><br><span class="line"><span class="keyword">import</span> android.content.res.Resources</span><br><span class="line"><span class="keyword">import</span> android.graphics.Point</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.Dp</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : jixiaoyong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> ：Compose 屏幕适配方案</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据设计稿宽度（设计稿宽度对应设备水平方向）和设计稿对应物体大小，计算实际应该填写的dp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用：</span></span><br><span class="line"><span class="comment"> * 在Application onCreate()方法中执行</span></span><br><span class="line"><span class="comment"> * SizeEtx.init(this, 375)</span></span><br><span class="line"><span class="comment"> * 其中375位设计稿屏幕宽度，然后在代码中使用width(315.composeDp)作为大小单位即可，</span></span><br><span class="line"><span class="comment"> * 其中315为设计稿中的控件大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 计算方式为：</span></span><br><span class="line"><span class="comment"> * wpx 屏幕实际像素宽度</span></span><br><span class="line"><span class="comment"> * dpx 设计稿屏幕宽度</span></span><br><span class="line"><span class="comment"> * n 控件设计稿中的宽度（dp、px都可，与dpx单位保持一致）</span></span><br><span class="line"><span class="comment"> * m 控件在app中对应的dp</span></span><br><span class="line"><span class="comment"> * rpx 控件在屏幕中应该展示的像素大小</span></span><br><span class="line"><span class="comment"> * 已知条件：dp = px / density</span></span><br><span class="line"><span class="comment"> * （density 在每个设备上都是固定的，DPI / 160 = density，屏幕的总 px 宽度 / density = 屏幕的总 dp 宽度）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DisplayMetrics#density 就是上述的density</span></span><br><span class="line"><span class="comment"> * DisplayMetrics#densityDpi 就是上述的dpi</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 综上得出如下结论(以竖屏情况下屏幕宽度为例)：</span></span><br><span class="line"><span class="comment"> * 屏幕宽度总dp ： rdp = wpx / density</span></span><br><span class="line"><span class="comment"> * m / rdp = n / dpx</span></span><br><span class="line"><span class="comment"> * 那么，m = (rdp / dpx) * n</span></span><br><span class="line"><span class="comment"> * 其中(rdp / dpx)被我们当做设计稿中控件大小与设备中控件dp大小之间的缩放系数：dpWidthScale</span></span><br><span class="line"><span class="comment"> * 所以：m = dpWidthScale * n</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> : jixiaoyong1995<span class="doctag">@gmail</span>.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2021/8/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeEtx</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context, dpx: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> density = Resources.getSystem().displayMetrics.density</span><br><span class="line">        <span class="keyword">var</span> wpx = Resources.getSystem().displayMetrics.widthPixels</span><br><span class="line">        dpWidthScale = wpx.toFloat() / (dpx * density)</span><br><span class="line">        dpHeightScale =</span><br><span class="line">            getScreenRealHeightPx(context).toFloat() / (dpx * density)</span><br><span class="line">        pxWidthScale = wpx.toFloat() / dpx.toFloat()</span><br><span class="line"><span class="comment">// 以下数据为Redmi Note 5 的测试数据</span></span><br><span class="line"><span class="comment">//        &quot;getScreenRealHeight $&#123;getScreenRealHeightPx(context)&#125;&quot;.logd() // 2160,实际设备高度为2160</span></span><br><span class="line"><span class="comment">//        &quot;Resources.getSystem().displayMetrics.heightPixels $&#123;Resources.getSystem().displayMetrics.heightPixels&#125;&quot;.logd() // 2033,实际设备高度为2160</span></span><br><span class="line"><span class="comment">//        &quot;Resources.getSystem().displayMetrics.density $&#123;Resources.getSystem().displayMetrics.density&#125;&quot;.logd() // 2.7</span></span><br><span class="line"><span class="comment">//        &quot;Resources.getSystem().displayMetrics.densityDpi $&#123;Resources.getSystem().displayMetrics.densityDpi&#125;&quot;.logd() // 432</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得屏幕真实高度（包含底部导航栏）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getScreenRealHeightPx</span><span class="params">(context: <span class="type">Context</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> windowManager = context.getSystemService(Context.WINDOW_SERVICE) <span class="keyword">as</span> WindowManager</span><br><span class="line">        <span class="keyword">val</span> display = windowManager.defaultDisplay</span><br><span class="line">        <span class="keyword">val</span> outPoint = Point()</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            <span class="comment">// 可能有虚拟按键的情况</span></span><br><span class="line">            display.getRealSize(outPoint)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不可能有虚拟按键</span></span><br><span class="line">            display.getSize(outPoint)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 手机屏幕真实高度</span></span><br><span class="line">        <span class="keyword">return</span> outPoint.y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化大小适配工具类</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> dpx 设计稿中的屏幕宽度，例如375，在使用到本工具的所有地方，都应该以此宽度为准来获取其他控件的大小</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>, dpx: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            SizeEtx(context, dpx)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> dpWidthScale = <span class="number">1.0f</span></span><br><span class="line">        <span class="keyword">var</span> dpHeightScale = <span class="number">1.0f</span></span><br><span class="line">        <span class="keyword">var</span> pxWidthScale = <span class="number">1.0f</span></span><br><span class="line">        <span class="keyword">var</span> pxHeightScale = <span class="number">1.0f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compose 屏幕适配方案</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Compose中对应的dp，输入值为设计稿中对应的控件大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">val</span> Number.composeDp: Dp</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> isPortrait = isPortrait()</span><br><span class="line">        <span class="keyword">return</span> Dp(<span class="keyword">this</span>.toFloat() * <span class="keyword">if</span> (isPortrait) SizeEtx.dpWidthScale <span class="keyword">else</span> SizeEtx.dpHeightScale)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Compose中对应的px，输入值为设计稿中对应的控件大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">val</span> Number.composePx: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> isPortrait = isPortrait()</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.toFloat() * <span class="keyword">if</span> (isPortrait) SizeEtx.pxWidthScale <span class="keyword">else</span> SizeEtx.pxHeightScale).toInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否竖屏</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPortrait</span><span class="params">()</span></span> =</span><br><span class="line">    Resources.getSystem().configuration.orientation == Configuration.ORIENTATION_PORTRAIT</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://github.com/JessYanCoding/AndroidAutoSize">AndroidAutoSize</a></p>
<p><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA">一种极低成本的Android屏幕适配方式</a></p>
]]></content>
  </entry>
  <entry>
    <title>Dagger 2 从0到1之旅</title>
    <url>/blog/posts/2822c354/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Dagger 2</code>是Google维护的一款可用于<code>Java</code>和<code>Android</code>的依赖注入框架。</p>
<p>本文主要是简单梳理<code>Dagger 2</code>中各个注解的作用，以及其简单用法，不涉及具体项目应用。</p>
<p>先解释几个概念：</p>
<ul>
<li><p>**<code>依赖注入</code>**：是一个对象（或静态方法）给另一个对象提供依赖的技术。</p>
</li>
<li><p>**<code>依赖</code>**是可以使用的对象（<code>Service</code>），而把依赖提供给使用该依赖的对象（<code>Client</code>）的过程叫做<code>注入</code>。</p>
</li>
</ul>
<p>例如，下面这段代码中<code>Service</code>就是<code>Client</code>的依赖。：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>()&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> service = Service()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果每个依赖都这样写的话，如果<code>Service</code>类的构造方法有变更，就需要同时也更改<code>Client</code>对应的方法，这样深耦合的代码显然不是我们需要的。</p>
<p><code>Dagger 2 </code>就是为了帮助我们解决这个问题，在使用它之后，<code>Client</code>类的代码只需要这样写成类似下面这样（示例代码）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> service: Service</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 某个将Service依赖注入的方法 magicFun()</span></span><br><span class="line">        <span class="keyword">val</span> newService = service<span class="comment">//使用Service的实例service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这时<code>Service</code>的实例化过程被移到了<code>Client</code>的外部某处，这样如果<code>Service</code>构造方法有更新时，我们只需要统一去修改<code>magicFun()</code>中对应的代码即可。</p>
<p>那么这一切<code>Dagger 2</code>到底是如何实现的呢？</p>
<h1 id="Dagger-2-具体实现"><a href="#Dagger-2-具体实现" class="headerlink" title="Dagger 2 具体实现"></a>Dagger 2 具体实现</h1><h2 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h2><p>首先需要请出第一个主角——**<code>@Inject</code>**。</p>
<p>在<code>Dagger 2</code>中，<code>@Inject</code>主要做两件事❶标记依赖类的构造方法；❷标记需要框架自动实例化的对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>()<span class="comment">//❶标记依赖类的构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> service: Service<span class="comment">//❷标记需要框架自动实例化的对象</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样<code>Dagger 2 </code>就知道了有个对象需要它来帮助我们注入，同时也知道了有一个构造方法来实例化<code>Service</code>对象。但这时如何将二者联系起来呢？</p>
<h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>这就要提到第二个主角——**<code>@Component</code>**。</p>
<p><code>@Component</code>标记的类是将一个类和他的依赖联系在一起的桥梁，通常是一个<strong>抽象类或者接口</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClientComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(client: <span class="type">Client</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>Client</code>和<code>Service</code>通过<code>ClientComponent</code>联系在一起，在使用时只需要将<code>Client</code>的引用传入即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="comment">//方式❶ DaggerClientComponent.create().inject(this)</span></span><br><span class="line">    <span class="comment">//方式❷ DaggerClientComponent.builder().build().inject(this)</span></span><br><span class="line">    <span class="keyword">val</span> newService = service</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上完整的代码可以参考这里,<a href="https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8#file-dagger2_basic_guide_line_part1-kt">若无法显示可点击这里查看</a>：</p>
<script src="https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8.js"></script>

<p>到目前为止，对于我们自己定义的类，我们只需要使用<code>@Inject</code>标记其构造方法，然后再在使用该类的时候使用<code>@Inject</code>标记该对象，在需要使用该对象的地方通过<code>@Component</code>类传入使用该依赖的类的引用即可。</p>
<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://jixiaoyong.github.io/images/20190126184230.png"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">@Component自动实现依赖注入的示意图</div> </center>

<p>但是很显然实际开发中，不是所有的<code>Service</code>类都可以被我们随意修改，如果<code>Service</code>类是第三方提供的类，显然我们是无法用<code>@Inject</code>修饰其构造函数的。</p>
<h2 id="Module和-Provides"><a href="#Module和-Provides" class="headerlink" title="@Module和@Provides"></a>@Module和@Provides</h2><p>为了解决第三方依赖的问题，我们要引入另外两个主角——**<code>@Module</code><strong>和</strong><code>@Provides</code>**。</p>
<p><code>@Provides</code>用来提供一个方法，我们可以在其内部实例化并返回<code>Service</code>类，这样子当用到<code>Service</code>的时候，<code>@Component</code>类只需要找到<code>@Provides</code>提供的这个方法，并获取到他实例化好的<code>Service</code>对象注入到<code>Client</code>中就可以了。</p>
<p><code>@Module</code>则是提供一个<strong>类</strong>（注意是类，而非接口），像一个袋子一样把<code>@Provides</code>提供的方法“装”到一起，打包提供给<code>@Component</code>类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientModule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getService</span><span class="params">()</span></span> = Service()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(modules = [ClientModule::class])</span><span class="comment">//Component可以有多个Module类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClientComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(client: <span class="type">Client</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的<code>@Component(modules = [ClientModule::class])</code>将装有可以产生依赖的<code>@Provides</code>方法的“大袋子”<code>@Module</code>和“桥梁”<code>@Component</code>关联到了一起。</p>
<p><code>@Component</code>在产生依赖的时候会先到<code>@Module</code>类中的<code>@Provides</code>方法中查找；如果找不到才会再到<code>@Inject</code>中查找。（也就是说，此时<code>Service</code>类的<code>@Inject</code>构造方法其实是失效了的，完全可以没有<code>@Inject</code>注解——第三方类即是如此）。</p>
<p>上述完整代码如下,<a href="https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb">若无法显示可点击这里查看</a>：</p>
<script src="https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb.js"></script>

<p>解决了第三方依赖引用的问题，还有一个非常重要的问题——我们使用的绝大多数类肯定不止一个构造方法，那么假设依赖类<code>Service</code>现在有两个构造方法，我们需要分别这两个构造方法，这种情况又该怎么处理呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(<span class="keyword">var</span> string: String = <span class="string">&quot;default&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>很明显，这时候<code>@Inject</code>注解已经没用了，一个类只能有一个构造方法被<code>@Inject</code>修饰，否则会报错：<code>错误: Types may only contain one @Inject constructor</code>。</p>
<p>去掉<code>@Inject</code>后<code>Service</code>类变成如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>(<span class="keyword">var</span> string: String = <span class="string">&quot;default&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>尝试在<code>@Module</code>中添加另外一个<code>@Provides</code>方法使用另外一个带参构造函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientModule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getService</span><span class="params">()</span></span> = Service()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span> </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getServiceWithArgs</span><span class="params">()</span></span> = Service(<span class="string">&quot;Args&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时发现会出错，因为有两个方法都可以提供<code>Service</code>，<code>@Component</code>产生了迷失，不知道用哪一个好，导致错误。</p>
<h2 id="Named和-Qualifier"><a href="#Named和-Qualifier" class="headerlink" title="@Named和@Qualifier"></a>@Named和@Qualifier</h2><p>为了解决多个构造函数导致的问题，这时就需要第五个主角**<code>@Named</code><strong>以及幕后英雄</strong><code>@Qualifier</code>**</p>
<p>首先，上述问题的解决方案是在另外一个方法上加一个注解<code>@Named</code>，表示他是一个特殊的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="meta">@Named(<span class="string">&quot;Args&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getServiceWithArgs</span><span class="params">()</span></span> = Service(<span class="string">&quot;Args&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当在<code>Client</code>中想使用这个方法的依赖时：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@field:是kotlin中注解字段特别需要的，在Java中可以直接写成@Named(&quot;Args&quot;)</span></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="meta">@field:Named</span>(<span class="string">&quot;Args&quot;</span>)</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> service: Service</span><br></pre></td></tr></table></figure>

<p>查看<code>@Named</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Named &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The name. */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现<code>@Qualifier</code>才是他实现标识限定符注解（Identifies qualifier annotations）的力量之源。查看<code>@Qualifier</code>注解可以知道，我们也可以自定义基于<code>@Qualifier</code>的注解来实现和<code>@Named</code>完全一致的功能。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@MustBeDocumented</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.RUNTIME)</span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">YourQualifierName</span></span>(<span class="comment">//YourQualifierName可以是任意你喜欢的名字</span></span><br><span class="line">    <span class="comment">/** The name.  */</span></span><br><span class="line">    <span class="keyword">val</span> value: String = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>之后我们就可以使用<code>@YourQualifierName</code>替代<code>@Named</code>实现标识不同注解的作用，从而支持有多个构造函数的<code>Service</code>类的初始化。</p>
<p>上述完整代码如下,<a href="https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a">若无法显示可点击这里查看</a>：：</p>
<script src="https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a.js"></script>

<p><code>@Component</code>可以有多个<code>@Module</code>，他们之间的关系可以用下图表示：</p>
<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://jixiaoyong.github.io/images/20190126201436.png"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">@Component 会先到他拥有的多个@Module中去查找Service类</div> </center>

<h2 id="Singleton和-Scope"><a href="#Singleton和-Scope" class="headerlink" title="@Singleton和@Scope"></a>@Singleton和@Scope</h2><p>在实际开发中，我们需要有的类只能有一个实例，从而在不同的地方共享一些数据——即单例，这种情况就需要另外一个角色<code>@Singleton</code>和他的幕后英雄<code>@Scope</code>。</p>
<p>@Singleton是用来标记类在其范围内只能被实例化一次。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Singleton &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看其源码可以知道其背后是<code>@Scope</code>在起作用，<code>@Scope</code>的作用是限定其修饰的类的范围，适用于有可注入的构造函数并且包含控制类型实例如何重用的类。没有<code>@Scope</code>修饰的实例在构造完毕后就会失去控制，不再关心后续的发展（<em>then forgets it</em>），而<code>@Scope</code>修饰的类会在实例构造完毕后，继续保留一遍下一次可能的复用，当有多个线程可以访问该实例时，他的实现应该是线程安全的（<em>it‘s implementation should be thread safe</em>）。</p>
<p>此外<code>@Component</code>应该和他所包含的<code>@Module</code>的<code>@Provides</code>的<code>@Scope</code>范围一致：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component(modules = [ClientModule::class])</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClientComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(client: <span class="type">Client</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientModule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getService</span><span class="params">()</span></span> = Service()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span> <span class="meta">@Choose(<span class="string">&quot;Args&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getServiceWithArgs</span><span class="params">()</span></span> = Service(<span class="string">&quot;Args&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此外两个关系为**<code>dependencies</code>*<em>的<code>@Component</code>可以分别拥有相同名称的<code>@Inject</code>、<code>@Module</code>、<code>@Provides</code>而不会被</em>merge*，两者可以相互访问。</p>
<p>而**<code>subcomponents</code>**则不能和<code>@Component</code>有以上相同的项。</p>
<blockquote>
<p><code>Subcomponent</code>从它的父类访问所有依赖</p>
<p><code>@Component</code>只能访问在基类<code>@Component</code>接口暴露的公共性的依赖</p>
<p>——<a href="https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/">Subcomponents和Component Dependencies——Sinyuk Blog</a></p>
</blockquote>
<p>他们之间的关系可以表示为下图：</p>
<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://jixiaoyong.github.io/images/20190127204658.png"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">@Subcomponent,@Component之间的关系</div> </center>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/android-cn/blog/tree/master/java/dependency-injection">android-cn：依赖注入—— Github</a></p>
<p><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection ——wikipedia</a></p>
<p><a href="https://medium.com/@elye.project">Elye的Dagger 2 系列</a></p>
<p><a href="https://google.github.io/dagger/users-guide">Dagger 2 官方手册</a></p>
<p><a href="https://www.jianshu.com/p/2cd491f0da01">Android - Dagger2使用详解——简书</a></p>
<p><a href="https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/">Subcomponents和Component Dependencies——Sinyuk Blog</a></p>
]]></content>
      <tags>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>Dagger 2 ❤️ Android</title>
    <url>/blog/posts/c04fdc6c/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="http://jixiaoyong.github.io/blog/posts/2822c354/">上篇文章</a>介绍了<code>Dagger 2</code> 的基本使用，本文跟随<a href="https://google.github.io/dagger/android">官方文档</a>实践一下<code>Dagger 2 </code>在<code>Android</code>中的使用，可以看做是官方文档的不完全翻译。</p>
<p>本文有关<code>Dagger 2</code>的使用分为<code>Activity</code>和<code>Fragment</code>两部分，二者的使用几乎没有差别，最后介绍一下在Google官方Demo中学到的一个小技巧，可以将几乎所有的和<code>Dagger 2</code>的逻辑放到一份代码里面，对<code>Android</code>工程的影响极小。</p>
<p>首先要添加相关依赖（Kotlin环境）：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;kotlin-kapt&#x27;</span><span class="comment">//引用该插件</span></span><br><span class="line">implementation <span class="string">&quot;com.google.dagger:dagger:$rootProject.dagger2Version&quot;</span></span><br><span class="line">implementation <span class="string">&quot;com.google.dagger:dagger-android-support:$rootProject.dagger2Version&quot;</span><span class="comment">//Android特需</span></span><br><span class="line">kapt <span class="string">&quot;com.google.dagger:dagger-compiler:$rootProject.dagger2Version&quot;</span><span class="comment">//注意如果是kotlin语言，这里需要时#kapt#</span></span><br></pre></td></tr></table></figure>

<h1 id="在Activity中的使用"><a href="#在Activity中的使用" class="headerlink" title="在Activity中的使用"></a>在Activity中的使用</h1><h2 id="Application范围内的-Component"><a href="#Application范围内的-Component" class="headerlink" title="Application范围内的@Component"></a>Application范围内的@Component</h2><p>首先创建整个应用程序使用的<code>@Component</code>，并将<code>AndroidInjectionModule</code>加入其中，实现<code>Inject</code>注入入口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(modules = [AndroidInjectionModule::class, MainActivityModule::class])</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(application: <span class="type">MainApplication</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AppComponent</code>的范围是整个应用程序都有效。</p>
<h2 id="创建单个Activity的-Subcomponent"><a href="#创建单个Activity的-Subcomponent" class="headerlink" title="创建单个Activity的@Subcomponent"></a>创建单个Activity的@Subcomponent</h2><p>创建某个<code>Activity</code>专属的<code>@Subcomponent</code>，用于提供<code>AndroidInjector.Builder</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subcomponent</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainActivitySubComponent</span> : <span class="type">AndroidInjector</span>&lt;<span class="type">MainActivity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> : <span class="type">AndroidInjector.Builder</span>&lt;<span class="type">MainActivity</span>&gt;</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建单个Activity的-Module"><a href="#创建单个Activity的-Module" class="headerlink" title="创建单个Activity的@Module"></a>创建单个Activity的@Module</h2><p>创建属于整个<code>Activity</code>的<code>@Module</code>，注意这里要指明<code>@subcomponents</code>为刚刚创建的<code>MainActivitySubComponent</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module(includes = [MainActivityModule.InnerModule::class], subcomponents = [MainActivitySubComponent::class])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivityModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bindWaitForInjectClass</span><span class="params">()</span></span> = WaitForInjectClass()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Module</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerModule</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Binds</span></span><br><span class="line">        <span class="meta">@IntoMap</span></span><br><span class="line">        <span class="meta">@ClassKey(MainActivity::class)</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindInjectorFactory</span><span class="params">(builder: <span class="type">MainActivitySubComponent</span>.<span class="type">Builder</span>)</span></span>: AndroidInjector.Factory&lt;*&gt;<span class="comment">//注意这里是 Factory&lt;*&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitForInjectClass</span> //一个供依赖注入的类</span></span><br></pre></td></tr></table></figure>

<p>可以看到在<code>MainActivityModule</code>中提供了一个方法利用刚刚<code>MainActivitySubComponent</code>中提供的<code>MainActivitySubComponent.Builder</code>实例生成了一个<code>AndroidInjector.Factory</code>，而这个<code>Factory</code>就是我们后面要将<code>MainActivityModule</code>中的依赖实例通过<code>AppComponent</code>传递给<code>MainActivity</code>实例的关键。</p>
<blockquote>
<p>此外还可以看到提供该Factory的方法是放到了另外一个抽象类里面然后再导入MainActivityModule中的，这是因为该方法的注解@Binds要求方法是抽象的，而MainActivityModule要是需要给Activity提供依赖实例所必须的@Provides又要求类不能是抽象的，否则就要求该方法是静态的。权衡之下我觉得这种方式是比较能接受的，当然也不排除有其他更优雅的解决方案，欢迎提<a href="https://github.com/jixiaoyong/jixiaoyong.github.io/issues">Issue</a>告知。</p>
</blockquote>
<p>然后，将<code>MainActivityModule</code>加入到应用程序的<code>@Component</code>——<code>AppComponent</code>中。</p>
<h2 id="使Application继承自-HasActivityInjector"><a href="#使Application继承自-HasActivityInjector" class="headerlink" title="使Application继承自 HasActivityInjector"></a>使Application继承自 <a href="https://google.github.io/dagger/api/latest/dagger/android/HasActivityInjector.html"><code>HasActivityInjector</code></a></h2><p>使当前<code>MainApplication</code>继承自<code>HasActivityInjector</code>，该接口只有一个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Returns an &#123;<span class="doctag">@link</span> AndroidInjector&#125; of &#123;<span class="doctag">@link</span> Activity&#125;s. */</span></span><br><span class="line">AndroidInjector&lt;Activity&gt; activityInjector();</span><br></pre></td></tr></table></figure>

<p>这个类是用来为相应的<code>Activity</code>提供一个<code>AndroidInjector</code>。由于我们已经在<code>AppComponent</code>中包括了<code>AndroidInjectionModule</code>，所以<code>Dagger 2</code>已经可以自动为我们注入<code>DispatchingAndroidInjector</code>依赖，所以接下来的代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> : <span class="type">HasActivityInjector</span>, <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        DaggerAppComponent.create().inject(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> dispatchActivityInjector: DispatchingAndroidInjector&lt;Activity&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">activityInjector</span><span class="params">()</span></span> = dispatchActivityInjector<span class="comment">//返回Dagger 2为我们注入的dispatchActivityInjector对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>onCreate()</code>方法中传入当前<code>Application</code>的依赖。</p>
<h2 id="在Activity中使用自动注入依赖"><a href="#在Activity中使用自动注入依赖" class="headerlink" title="在Activity中使用自动注入依赖"></a>在Activity中使用自动注入依赖</h2><p>做完了以上所有内容，我们只需要在<code>Activity</code>中添加如下代码就可以实现自动注入：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> waitForInjectClass: WaitForInjectClass</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        AndroidInjection.inject(<span class="keyword">this</span>)<span class="comment">//注意这里，在super()之前调用</span></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_dagger2_x_android_main)</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;The Class is <span class="variable">$waitForInjectClass</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上所有代码如下，或者也可以<a href="https://gist.github.com/jixiaoyong/db7e5f18b7106ce9cb36b61bf7134340">在这里找到</a>：</p>
<script src="https://gist.github.com/jixiaoyong/db7e5f18b7106ce9cb36b61bf7134340.js"></script>

<h2 id="这一切是怎么实现的呢？"><a href="#这一切是怎么实现的呢？" class="headerlink" title="这一切是怎么实现的呢？"></a>这一切是怎么实现的呢？</h2><p>在<code>Android</code>程序运行时，<code>AndroidInjection.inject()</code>从<code>Application</code>中的<code>activityInjector()</code>方法获取到 <code>DispatchingAndroidInjector&lt;Activity&gt;</code> ，然后将<code>Activity</code>传入<code>inject(Activity)</code>。</p>
<p><code>DispatchingAndroidInjector</code> 通过<code>AppComponent</code>找到我们在<code>MainActivityModule</code>提供的对应的<code>AndroidInjector.Factory</code>，然后创建了 <code>AndroidInjector</code> ——这就是我们当前<code>Activity</code>对应的<code>MainActivitySubComponent</code>。</p>
<p>接下来便按照之前的逻辑，从<code>MainActivitySubComponent</code>中查找提供<code>waitForInjectClass</code>的实例方法完成注入。</p>
<h1 id="在Fragment中的使用"><a href="#在Fragment中的使用" class="headerlink" title="在Fragment中的使用"></a>在Fragment中的使用</h1><p><code>Dagger 2</code>在<code>Fragment</code>的使用和在<code>Activity</code>中的使用十分相似。</p>
<p>通过之前的代码我们可以知道，其基本的原理依旧是利用<code>@Component</code>和<code>@subcomponent</code>，<code>@Module</code>之间的关联关系将<code>Application</code>和<code>Activity</code>等的依赖注入通过<code>AndroidInjector</code>关联起来的：</p>
<p><code>MainActivitySubComponent</code>通过将<code>MainActivityModule</code>加入到<code>AppComponent</code>之中，然后当<code>MainActivity</code>之中需要使用到<code>MainActivitySubComponent</code>时，又通过<code>AndroidInjector</code>从<code>AppComponent</code>中拿到<code>MainActivityModule</code>中的<code>AndroidInjector.Factory</code>，通过该<code>Factory</code>和<code>MainActivitySubComponent</code>中的<code>Builder</code>产生关联，从而获取到了<code>MainActivitySubComponent</code>的实例供<code>Activity</code>使用。</p>
<p>在<code>Fragment</code>中我们也可以这样处理，只不过由于<code>Fragment</code>的特性，他的<code>@Module</code>不仅可以交给<code>Application</code>的<code>@Component</code>，也可以交给其他<code>Fragment</code>或者<code>Activity</code>的<code>@Component</code>，让其实现<code>HasFragmentInjector</code>即可，这取决于我们想要给<code>Fragment</code>绑定的依赖。</p>
<p>具体的实现一般分为下面几步：</p>
<ul>
<li><p>创建<code>Application</code>的<code>@Component</code>并添加<code>AndroidInjectionModule</code></p>
</li>
<li><p>创建实现了<code>AndroidInjector&lt;MainFragment&gt;</code>的<code>MainFragmentSubComponent</code>，其内部有方法提供<code>AndroidInjector.Builder&lt;MainFragment&gt;</code></p>
</li>
<li><p>创建包含了提供<code>AndroidInjector.Factory&lt;*&gt;</code>的抽象方法的<code>MainFragmentModule</code>，指定其<code>subcomponents</code>为<code>MainFragmentSubComponent</code>；</p>
</li>
<li><p>将<code>MainFragmentSubComponent</code>加入到想要加入的类的<code>@Component</code>中，比如<code>AppComponent</code>类</p>
</li>
<li><p>在<code>Application</code>（如果上一步是<code>Activity</code>，则本步也是<code>Activity</code>等）中参照在<code>Activity</code>实现的步骤实现<code>HasFragmentInjector</code></p>
<p>上述完整的代码如下，或者也可以<a href="https://gist.github.com/jixiaoyong/a24e76ca29f4c8062bf5c6a98529d252">在这里找到</a>：</p>
<script src="https://gist.github.com/jixiaoyong/a24e76ca29f4c8062bf5c6a98529d252.js"></script></li>
</ul>
<p>关于<code>Fragment</code>加入到<code>Activity</code>的Demo在官方文档有，这里就不再赘述了，其实只要掌握原理，其他用法的完全可以触类旁通。</p>
<h1 id="一个小技巧"><a href="#一个小技巧" class="headerlink" title="一个小技巧"></a>一个小技巧</h1><p>通过观察上面的两份代码，我们发现虽然这<code>Dagger 2</code>已经替我们做了好多事情，我们只需要在需要使用依赖注入的类中使用诸如<code>AndroidInjection.inject(this)</code>这样的代码就可以了，但是如果<code>Activity</code>、<code>Fragment</code>类过多的时候，这样的重复性工作仍然是个不小的工作量，万一有某处遗忘了便会导致出错。</p>
<p>这时就可以用到我在<a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample">Google官方示例代码</a>中学到的一个小技巧了(针对本文中的例子做了一些修改)，或者你也可以<a href="https://gist.github.com/jixiaoyong/9260c3ae2a70555e14f40c4b95364715">到这里查看源码</a>：</p>
<script src="https://gist.github.com/jixiaoyong/9260c3ae2a70555e14f40c4b95364715.js"></script>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://google.github.io/dagger/android">Dagger 2 官方文档 Android篇</a></p>
<p><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample">Google官方示例代码——GithubBrowserSample</a></p>
]]></content>
      <tags>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart event loop</title>
    <url>/blog/posts/db62c118/</url>
    <content><![CDATA[<blockquote>
<p>本文基于Dart 2.17</p>
</blockquote>
<br>

<p>Dart App中所有的代码都在一个isolate中运行（各个isolate之间的代码运行时是隔离的），一个isolate有自己的heap，维持有一个消息队列event_loop，处理两种消息：</p>
<ol>
<li><code>event queue</code> 执行用户点击、屏幕刷新、绘制，一般的Future、IO、Stream流等，每次执行完毕都会先检查执行micro task queue中的任务，直到其为空再执行下一个event queue</li>
<li><code>microTask queue</code> 优先执行，一般执行跑完即弃的小任务，如Dart内部的微任务</li>
</ol>
<p>上述两种event会在普通的Dart同步方法执行完毕后执行，无论是microTask还是普通的event，他们都是<strong>concurrency并行</strong>执行（也就是说实际上还是<strong>上一个执行完毕，再执行另外一个</strong>），所以如果这些event中存在耗时长的方法，<strong>依旧会阻塞其他方法的执行</strong>，可能导致UI卡顿等情况。</p>
<br>

<p>在代码执行的过程中，各种事件（如用户点击、屏幕刷新、future、microtask等）都会被当做一个个event放入到event queue中，然后不停的从event loop取出事件并执行：</p>
<p><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop.png" alt="dart_event_loop"></p>
<p>他们的执行顺序如下：</p>
<p><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop_sequeue.png" alt="dart_event_loop_sequeue"></p>
<p>可以从下述例子详细看一下代码执行的时候各个方法执行过程：</p>
<p><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_test_queue_code.png" alt="dart_test_queue_code"></p>
<p><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_test_queue_output.png" alt="dart_test_queue_output"></p>
<br>

<p>本文根据Dart SDK源码分析一下event loop的实现。</p>
<p>代码参考：<a href="https://gist.github.com/jixiaoyong/ac811902db42a51cf97e3290788ade4a">https://gist.github.com/jixiaoyong/ac811902db42a51cf97e3290788ade4a</a></p>
<h1 id="1-同步方法"><a href="#1-同步方法" class="headerlink" title="1. 同步方法"></a>1. 同步方法</h1><p>同步方法包括普通的方法，以及一下几种会按照同步方法立即执行的方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future.<span class="keyword">sync</span>(() =&gt; <span class="built_in">print</span>(<span class="string">&quot;Hello, I am future created by Future.sync&quot;</span>));</span><br><span class="line">Future.forEach(</span><br><span class="line">      [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">      (element) =&gt;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Hello, I am future(<span class="subst">$element</span>) created by Future.forEach&quot;</span>));</span><br><span class="line">Future.doWhile(() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (repeatCounter++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;repeat (<span class="subst">$repeatCounter</span>/3) inner Future.doWhile&quot;</span>);</span><br><span class="line">      <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="2-micro-task"><a href="#2-micro-task" class="headerlink" title="2. micro task"></a>2. micro task</h1><p>microtask会在同步方法执行完毕之后立即被执行，一般用来执行“即抛型”的方法，不应当执行耗时方法。microtask列表会一直执行，直到event loop中没有micro task了，才会去执行Future等普通的event。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">scheduleMicrotask(() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello, world! I am a microtask.&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Future.microtask(</span><br><span class="line">      () =&gt; <span class="built_in">print</span>(<span class="string">&quot;Hello, I am microtask created by Future.microtask&quot;</span>));</span><br><span class="line"></span><br><span class="line">Future.value(<span class="number">1</span>).then((value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am future created by Future.value&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Future.error(Exception(<span class="string">&quot;Hello, I am future created by Future.error&quot;</span>))</span><br><span class="line">      .onError((error, stackTrace) =&gt; <span class="built_in">print</span>(error));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Future.value([FutureOr&lt;T&gt;? value])</code> 比较特殊，如果<code>value</code> 是future，那么他会在value执行完毕后返回他的值，如果<code>value</code>不是future，他就会立即执行属于microtask</p>
</blockquote>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>让我们看一下上述方法的具体实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\future.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">factory</span> Future.microtask(FutureOr&lt;T&gt; computation()) &#123;</span><br><span class="line">    _Future&lt;T&gt; result = <span class="keyword">new</span> _Future&lt;T&gt;();</span><br><span class="line">    scheduleMicrotask(() &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        result._complete(computation());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e, s) &#123;</span><br><span class="line">        _completeWithErrorCallback(result, e, s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>Future.microtask</code>本质还是调用<code>scheduleMicrotask</code>实现的，其实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\schedule_microtask.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&#x27;vm:entry-point&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"><span class="keyword">void</span> scheduleMicrotask(<span class="keyword">void</span> <span class="built_in">Function</span>() callback) &#123;</span><br><span class="line">  _Zone currentZone = Zone._current;</span><br><span class="line">  <span class="keyword">if</span> (identical(_rootZone, currentZone)) &#123;</span><br><span class="line">    <span class="comment">// No need to bind the callback. We know that the root&#x27;s scheduleMicrotask</span></span><br><span class="line">    <span class="comment">// will be invoked in the root zone.</span></span><br><span class="line">    _rootScheduleMicrotask(<span class="keyword">null</span>, <span class="keyword">null</span>, _rootZone, callback);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _ZoneFunction implementation = currentZone._scheduleMicrotask;</span><br><span class="line">  <span class="keyword">if</span> (identical(_rootZone, implementation.zone) &amp;&amp;</span><br><span class="line">      _rootZone.inSameErrorZone(currentZone)) &#123;</span><br><span class="line">    _rootScheduleMicrotask(</span><br><span class="line">        <span class="keyword">null</span>, <span class="keyword">null</span>, currentZone, currentZone.registerCallback(callback));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Zone.current.scheduleMicrotask(Zone.current.bindCallbackGuarded(callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Zone.scheduleMicrotask()</code>最后调用的是<code>_RootZone</code>的同名方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\zone.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RootZone</span> <span class="keyword">extends</span> <span class="title">_Zone</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span> scheduleMicrotask(<span class="keyword">void</span> f()) &#123;</span><br><span class="line">    _rootScheduleMicrotask(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">this</span>, f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _rootScheduleMicrotask(</span><br><span class="line">    Zone? self, ZoneDelegate? parent, Zone zone, <span class="keyword">void</span> f()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!identical(_rootZone, zone)) &#123;</span><br><span class="line">    <span class="built_in">bool</span> hasErrorHandler = !_rootZone.inSameErrorZone(zone);</span><br><span class="line">    <span class="keyword">if</span> (hasErrorHandler) &#123;</span><br><span class="line">      f = zone.bindCallbackGuarded(f);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      f = zone.bindCallback(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _scheduleAsyncCallback(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RootZone-scheduleAsyncCallback"><a href="#RootZone-scheduleAsyncCallback" class="headerlink" title="_RootZone._scheduleAsyncCallback"></a>_RootZone._scheduleAsyncCallback</h3><p>这里调用了<code>_RootZone._scheduleAsyncCallback</code>方法，将传入的callback当做microtask执行。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\schedule_microtask.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Schedules a callback to be called as a microtask.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The microtask is called after all other currently scheduled</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">microtasks, but as part of the current system event.</span></span></span><br><span class="line"><span class="keyword">void</span> _scheduleAsyncCallback(_AsyncCallback callback) &#123;</span><br><span class="line">  _AsyncCallbackEntry newEntry = <span class="keyword">new</span> _AsyncCallbackEntry(callback);</span><br><span class="line">  _AsyncCallbackEntry? lastCallback = _lastCallback;</span><br><span class="line">  <span class="keyword">if</span> (lastCallback == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _nextCallback = _lastCallback = newEntry;</span><br><span class="line">    <span class="keyword">if</span> (!_isInCallbackLoop) &#123;</span><br><span class="line">      _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lastCallback.next = newEntry;</span><br><span class="line">    _lastCallback = newEntry;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RootZone-startMicrotaskLoop"><a href="#RootZone-startMicrotaskLoop" class="headerlink" title="_RootZone._startMicrotaskLoop"></a>_RootZone._startMicrotaskLoop</h3><p>这里面的<code>_startMicrotaskLoop</code>方法是实际上处理microtask的地方：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\schedule_microtask.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Whether we are currently inside the callback loop.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">If we are inside the loop, we never need to schedule the loop,</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">even if adding a first element.</span></span></span><br><span class="line"><span class="built_in">bool</span> _isInCallbackLoop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _microtaskLoop() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> entry = _nextCallback; entry != <span class="keyword">null</span>; entry = _nextCallback) &#123;</span><br><span class="line">    _lastPriorityCallback = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">var</span> next = entry.next;</span><br><span class="line">    _nextCallback = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) _lastCallback = <span class="keyword">null</span>;</span><br><span class="line">    (entry.callback)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _startMicrotaskLoop() &#123;</span><br><span class="line">  _isInCallbackLoop = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Moved to separate function because try-finally prevents</span></span><br><span class="line">    <span class="comment">// good optimization.</span></span><br><span class="line">    _microtaskLoop();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _lastPriorityCallback = <span class="keyword">null</span>;</span><br><span class="line">    _isInCallbackLoop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_nextCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>_AsyncRun._scheduleImmediate</code>方法则是触发处理microtask的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\schedule_microtask.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AsyncRun</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Schedule the given callback before any other event in the event-loop.</span></span></span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="keyword">void</span> _scheduleImmediate(<span class="keyword">void</span> <span class="built_in">Function</span>() callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncRun-scheduleImmediate"><a href="#AsyncRun-scheduleImmediate" class="headerlink" title="_AsyncRun._scheduleImmediate"></a>_AsyncRun._scheduleImmediate</h3><p><code>_AsyncRun._scheduleImmediate</code>方法的实现在<code>schedule_microtask_patch.dart</code>中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk/lib/_internal/vm/lib/schedule_microtask_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AsyncRun</span> </span>&#123;</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _scheduleImmediate(<span class="keyword">void</span> callback()) &#123;</span><br><span class="line">    <span class="keyword">final</span> closure = _ScheduleImmediate._closure;</span><br><span class="line">    <span class="keyword">if</span> (closure == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedError(<span class="string">&quot;Microtasks are not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    closure(callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> _ScheduleImmediateClosure(<span class="keyword">void</span> callback());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScheduleImmediate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> _ScheduleImmediateClosure? _closure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line"><span class="keyword">void</span> _setScheduleImmediateClosure(_ScheduleImmediateClosure closure) &#123;</span><br><span class="line">  _ScheduleImmediate._closure = closure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line"><span class="keyword">void</span> _ensureScheduleImmediate() &#123;</span><br><span class="line">  _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScheduleImmediateClosure"><a href="#ScheduleImmediateClosure" class="headerlink" title="_ScheduleImmediateClosure"></a>_ScheduleImmediateClosure</h3><p>可以看到，microtask实际上是使用<code>_ScheduleImmediateClosure</code>调用的，关于他主要有两个方法：</p>
<ol>
<li><code>_setScheduleImmediateClosure</code></li>
<li><code>_ensureScheduleImmediate</code></li>
</ol>
<p>让我们先看一下第一个方法<code>_setScheduleImmediateClosure</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\dartutils.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PrepareAsyncLibrary方法会在Dart虚拟机启动的时候被调用</span></span><br><span class="line">Dart_Handle DartUtils::PrepareAsyncLibrary(Dart_Handle async_lib,</span><br><span class="line">                                           Dart_Handle isolate_lib) &#123;</span><br><span class="line">  Dart_Handle schedule_immediate_closure = Dart_Invoke(</span><br><span class="line">      isolate_lib, NewString(<span class="string">&quot;_getIsolateScheduleImmediateClosure&quot;</span>), <span class="number">0</span>, NULL);</span><br><span class="line">  RETURN_IF_ERROR(schedule_immediate_closure);</span><br><span class="line">  Dart_Handle args[<span class="number">1</span>];</span><br><span class="line">  args[<span class="number">0</span>] = schedule_immediate_closure;</span><br><span class="line">  <span class="keyword">return</span> Dart_Invoke(async_lib, NewString(<span class="string">&quot;_setScheduleImmediateClosure&quot;</span>), <span class="number">1</span>,</span><br><span class="line">                     args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要调用了Dart中的<code>_getIsolateScheduleImmediateClosure</code>方法创建了<code>schedule_immediate_closure</code>，然后通过<code>_setScheduleImmediateClosure</code>返回：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\isolate_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The embedder can execute this function to get hold of</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[<span class="emphasis">_isolateScheduleImmediate] above.</span></span></span></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line"><span class="built_in">Function</span> _getIsolateScheduleImmediateClosure() &#123;</span><br><span class="line">  <span class="keyword">return</span> _isolateScheduleImmediate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">The closure that should be used as scheduleImmediateClosure, when the VM</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">is responsible for the event loop.</span></span></span></span><br><span class="line"><span class="keyword">void</span> _isolateScheduleImmediate(<span class="keyword">void</span> callback()) &#123;</span><br><span class="line">  <span class="keyword">assert</span>((_pendingImmediateCallback == <span class="keyword">null</span>) ||</span><br><span class="line">      (_pendingImmediateCallback == callback));</span><br><span class="line">  _pendingImmediateCallback = callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">The callback that has been registered through `scheduleImmediate`.</span></span></span></span><br><span class="line">_ImmediateCallback? _pendingImmediateCallback;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法会将传递进来的<code>callback</code>赋值给<code>_pendingImmediateCallback</code>。</p>
<p>而结合上面的代码，<code>_ensureScheduleImmediate</code> 方法主要也是用来触发<code>_ScheduleImmediateClosure</code>执行回调事件。</p>
<br>

<p>到目前为止，我们能确定的是：</p>
<ul>
<li>在Dart VM启动的时候，会创建一个<code>_ScheduleImmediateClosure</code>并保存在<code>_pendingImmediateCallback</code>;</li>
<li>当有新的microtask加入的时候，会触发<code>_startMicrotaskLoop</code>方法在<code>_microtaskLoop()</code>中实际处理一个microtask（这里的<code>_startMicrotaskLoop</code>触发的实际是通过<code>_AsyncRun._scheduleImmediate(_startMicrotaskLoop)</code>将其使用<code>_pendingImmediateCallback</code> 包裹之后执行的）。</li>
</ul>
<h3 id="pendingImmediateCallback"><a href="#pendingImmediateCallback" class="headerlink" title="_pendingImmediateCallback"></a>_pendingImmediateCallback</h3><p>现在的问题是，这个<code>_pendingImmediateCallback</code> 什么时候会被安排执行呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\isolate_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line"><span class="keyword">void</span> _runPendingImmediateCallback() &#123;</span><br><span class="line">  <span class="keyword">final</span> callback = _pendingImmediateCallback;</span><br><span class="line">  <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    _pendingImmediateCallback = <span class="keyword">null</span>;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RawReceivePortImpl</span> <span class="keyword">implements</span> <span class="title">RawReceivePort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Called from the VM to retrieve  the handler and handle a message.</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line">  <span class="keyword">static</span> _handleMessage(<span class="built_in">int</span> id, <span class="keyword">var</span> message) &#123;</span><br><span class="line">    <span class="keyword">final</span> handler = _portMap[id]?[<span class="string">&#x27;handler&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(floitsch): this relies on the fact that any exception aborts the</span></span><br><span class="line">    <span class="comment">// VM. Once we have non-fatal global exceptions we need to catch errors</span></span><br><span class="line">    <span class="comment">// so that we can run the immediate callbacks.</span></span><br><span class="line">    handler(message);</span><br><span class="line">    _runPendingImmediateCallback();</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的关键代码，在<code>_handleMessage</code>方法中，会先执行<code>RawReceivePort</code>原本的handler内容，然后，执行<code>_runPendingImmediateCallback()</code>。</p>
<p>在<code>_runPendingImmediateCallback</code>则会执行<code>_pendingImmediateCallback</code>的内容，也就是前面的<code>_startMicrotaskLoop</code>，处理event loop中的micro task。</p>
<br>

<p>这也就证明了我们之前说的“<strong>microtask会在同步方法之后立即执行，并在每次普通的event loop执行完毕之后，都会检查并执行event loop中的microtask，之后才继续执行普通event</strong>”。</p>
<p>在下面的分析中，我们也还可以看到，在event每次处理Timer事件之后，都会检查执行micro task。</p>
<h1 id="3-event"><a href="#3-event" class="headerlink" title="3. event"></a>3. event</h1><blockquote>
<p>除了下面列出来的使用Future或者Timer等创建的方法外，屏幕点击、刷新等事件也在此类event中。</p>
</blockquote>
<p>当前event loop中没有micro task之后，就会执行一次此类普通event，然后再检查一次event loop，如果有micro task就执行micro task直到清空micro task，否则继续执行下一个普通event，直到event loop列表为空，退出app。</p>
<p>先看几种会触发此类事件的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am future&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Future.any([</span><br><span class="line">    Future(() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;I am Future run immediately Future.any&quot;</span>;</span><br><span class="line">    &#125;),</span><br><span class="line">    Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;I am Future run delay, will be discard Future.any&quot;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]).then((value) =&gt; <span class="built_in">print</span>(value));</span><br><span class="line"></span><br><span class="line">Future.wait([</span><br><span class="line">    Future(() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;I am Future run immediately Future.wait 1/2&quot;</span>;</span><br><span class="line">    &#125;),</span><br><span class="line">    Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;I am Future run delay Future.wait 2/2&quot;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]).then((value) =&gt; <span class="built_in">print</span>(value));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以及Timer</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Timer.periodic(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), (timer) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am running inner(<span class="subst">$&#123;timer.tick&#125;</span>/2) Timer.periodic&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (timer.tick == <span class="number">2</span>) &#123;</span><br><span class="line">      timer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;Hello, I will run asynchronously as soon as possible with Timer.run&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Timer(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I will run asynchronously after 1 second with Timer&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们依次看一下上述几个方法的具体实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\future.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">factory</span> Future.delayed(<span class="built_in">Duration</span> duration, [FutureOr&lt;T&gt; computation()?]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (computation == <span class="keyword">null</span> &amp;&amp; !typeAcceptsNull&lt;T&gt;()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ArgumentError.value(</span><br><span class="line">          <span class="keyword">null</span>, <span class="string">&quot;computation&quot;</span>, <span class="string">&quot;The type parameter is not nullable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _Future&lt;T&gt; result = <span class="keyword">new</span> _Future&lt;T&gt;();</span><br><span class="line">    <span class="keyword">new</span> Timer(duration, () &#123;</span><br><span class="line">      <span class="keyword">if</span> (computation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result._complete(<span class="keyword">null</span> <span class="keyword">as</span> T);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          result._complete(computation());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e, s) &#123;</span><br><span class="line">          _completeWithErrorCallback(result, e, s);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Future&lt;T&gt; any&lt;T&gt;(<span class="built_in">Iterable</span>&lt;Future&lt;T&gt;&gt; futures) &#123;</span><br><span class="line">    <span class="keyword">var</span> completer = <span class="keyword">new</span> Completer&lt;T&gt;.<span class="keyword">sync</span>();</span><br><span class="line">    <span class="keyword">void</span> onValue(T value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!completer.isCompleted) completer.complete(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> onError(<span class="built_in">Object</span> error, StackTrace stack) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!completer.isCompleted) completer.completeError(error, stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> future <span class="keyword">in</span> futures) &#123;</span><br><span class="line">			<span class="comment">// 一旦有一个future执行完毕，就立即返回结果，并丢弃掉后续future的返回</span></span><br><span class="line">      future.then(onValue, onError: onError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> completer.future;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:recognized&quot;</span>, <span class="string">&quot;other&quot;</span>)</span><br><span class="line">  <span class="keyword">static</span> Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; wait&lt;T&gt;(<span class="built_in">Iterable</span>&lt;Future&lt;T&gt;&gt; futures,</span><br><span class="line">      &#123;<span class="built_in">bool</span> eagerError = <span class="keyword">false</span>, <span class="keyword">void</span> cleanUp(T successValue)?&#125;) &#123;</span><br><span class="line">    <span class="comment">// This is a VM recognised method, and the _future variable is deliberately</span></span><br><span class="line">    <span class="comment">// allocated in a specific slot in the closure context for stack unwinding.</span></span><br><span class="line">    <span class="keyword">final</span> _Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; _future = _Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt;();</span><br><span class="line">    <span class="built_in">List</span>&lt;T?&gt;? values; <span class="comment">// Collects the values. Set to null on error.</span></span><br><span class="line">    <span class="built_in">int</span> remaining = <span class="number">0</span>; <span class="comment">// How many futures are we waiting for.</span></span><br><span class="line">    <span class="keyword">late</span> <span class="built_in">Object</span> error; <span class="comment">// The first error from a future.</span></span><br><span class="line">    <span class="keyword">late</span> StackTrace stackTrace; <span class="comment">// The stackTrace that came with the error.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle an error from any of the futures.</span></span><br><span class="line">    <span class="keyword">void</span> handleError(<span class="built_in">Object</span> theError, StackTrace theStackTrace) &#123;</span><br><span class="line">      remaining--;</span><br><span class="line">      <span class="built_in">List</span>&lt;T?&gt;? valueList = values;</span><br><span class="line">      <span class="keyword">if</span> (valueList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cleanUp != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">in</span> valueList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// Ensure errors from cleanUp are uncaught.</span></span><br><span class="line">              T cleanUpValue = value;</span><br><span class="line">              <span class="keyword">new</span> Future.<span class="keyword">sync</span>(() &#123;</span><br><span class="line">                cleanUp(cleanUpValue);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        values = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining == <span class="number">0</span> || eagerError) &#123;</span><br><span class="line">          _future._completeError(theError, theStackTrace);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          error = theError;</span><br><span class="line">          stackTrace = theStackTrace;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; !eagerError) &#123;</span><br><span class="line">        _future._completeError(error, stackTrace);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// As each future completes, put its value into the corresponding</span></span><br><span class="line">      <span class="comment">// position in the list of values.</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> future <span class="keyword">in</span> futures) &#123;</span><br><span class="line">        <span class="built_in">int</span> pos = remaining;</span><br><span class="line">				<span class="comment">// 在这里依次执行future</span></span><br><span class="line">        future.then((T value) &#123;</span><br><span class="line">          remaining--;</span><br><span class="line">          <span class="built_in">List</span>&lt;T?&gt;? valueList = values;</span><br><span class="line">          <span class="keyword">if</span> (valueList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valueList[pos] = value;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">              _future._completeWithValue(<span class="built_in">List</span>&lt;T&gt;.from(valueList));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cleanUp != <span class="keyword">null</span> &amp;&amp; value != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// Ensure errors from cleanUp are uncaught.</span></span><br><span class="line">              <span class="keyword">new</span> Future.<span class="keyword">sync</span>(() &#123;</span><br><span class="line">                cleanUp(value);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; !eagerError) &#123;</span><br><span class="line">              <span class="comment">// If eagerError is false, and valueList is null, then</span></span><br><span class="line">              <span class="comment">// error and stackTrace have been set in handleError above.</span></span><br><span class="line">              _future._completeError(error, stackTrace);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, onError: handleError);</span><br><span class="line">        <span class="comment">// Increment the &#x27;remaining&#x27; after the call to &#x27;then&#x27;.</span></span><br><span class="line">        <span class="comment">// If that call throws, we don&#x27;t expect any future callback from</span></span><br><span class="line">        <span class="comment">// the future, and we also don&#x27;t increment remaining.</span></span><br><span class="line">        remaining++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _future.._completeWithValue(&lt;T&gt;[]);</span><br><span class="line">      &#125;</span><br><span class="line">      values = <span class="keyword">new</span> <span class="built_in">List</span>&lt;T?&gt;.filled(remaining, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, st) &#123;</span><br><span class="line">      <span class="comment">// The error must have been thrown while iterating over the futures</span></span><br><span class="line">      <span class="comment">// list, or while installing a callback handler on the future.</span></span><br><span class="line">      <span class="comment">// This is a breach of the `Future` protocol, but we try to handle it</span></span><br><span class="line">      <span class="comment">// gracefully.</span></span><br><span class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span> || eagerError) &#123;</span><br><span class="line">        <span class="comment">// Throw a new Future.error.</span></span><br><span class="line">        <span class="comment">// Don&#x27;t just call `_future._completeError` since that would propagate</span></span><br><span class="line">        <span class="comment">// the error too eagerly, not giving the callers time to install</span></span><br><span class="line">        <span class="comment">// error handlers.</span></span><br><span class="line">        <span class="comment">// Also, don&#x27;t use `_asyncCompleteError` since that one doesn&#x27;t give</span></span><br><span class="line">        <span class="comment">// zones the chance to intercept the error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Future.error(e, st);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allocate a list for values, thus indicating that there was an</span></span><br><span class="line">        <span class="comment">// error.</span></span><br><span class="line">        <span class="comment">// Set error to the caught exception.</span></span><br><span class="line">        error = e;</span><br><span class="line">        stackTrace = st;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _future;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，除了<code>Future.wait</code>和<code>Future.any</code> <strong>这两个处理Future集合的方法外，<code>Future.delayed</code> 这个方法内部是实际上是</strong>通过Timer实现**的。</p>
<h3 id="Future-then"><a href="#Future-then" class="headerlink" title="Future.then"></a>Future.then</h3><p>在看Timer实现之前，先看一下<code>Futrue.then</code>的实现,他对应的实现是<code>_Future.then</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\future_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Future</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// Register callbacks to be called when this future completes.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// When this future completes with a value, the [onValue] callback will be called with that value.</span></span><br><span class="line"><span class="comment">//  If this future is already completed, the callback will not be called immediately, </span></span><br><span class="line"><span class="comment">// but will be scheduled in a later microtask</span></span><br><span class="line">Future&lt;R&gt; then&lt;R&gt;(FutureOr&lt;R&gt; f(T value), &#123;<span class="built_in">Function?</span> onError&#125;) &#123;</span><br><span class="line">    Zone currentZone = Zone.current;</span><br><span class="line">    <span class="keyword">if</span> (identical(currentZone, _rootZone)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onError != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">          onError <span class="keyword">is</span>! <span class="built_in">Function</span>(<span class="built_in">Object</span>, StackTrace) &amp;&amp;</span><br><span class="line">          onError <span class="keyword">is</span>! <span class="built_in">Function</span>(<span class="built_in">Object</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArgumentError.value(</span><br><span class="line">            onError,</span><br><span class="line">            <span class="string">&quot;onError&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Error handler must accept one Object or one Object and a StackTrace&quot;</span></span><br><span class="line">                <span class="string">&quot; as arguments, and return a value of the returned future&#x27;s type&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      f = currentZone.registerUnaryCallback&lt;FutureOr&lt;R&gt;, T&gt;(f);</span><br><span class="line">      <span class="keyword">if</span> (onError != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This call also checks that onError is assignable to one of:</span></span><br><span class="line">        <span class="comment">//   dynamic Function(Object)</span></span><br><span class="line">        <span class="comment">//   dynamic Function(Object, StackTrace)</span></span><br><span class="line">        onError = _registerErrorHandler(onError, currentZone);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _Future&lt;R&gt; result = <span class="keyword">new</span> _Future&lt;R&gt;();</span><br><span class="line">    _addListener(<span class="keyword">new</span> _FutureListener&lt;T, R&gt;.then(result, f, onError));</span><br><span class="line">		<span class="comment">// 返回创建好的Future</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>_Futrue.then</code>只是对传入的回调的进行了包装，实际上是通过<code>_Future._addListener()</code>实现具体的逻辑：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\future_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">get</span> _mayComplete =&gt; (_state &amp; _completionStateMask) == _stateIncomplete;</span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _isPendingComplete =&gt; (_state &amp; _statePendingComplete) != <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _mayAddListener =&gt;</span><br><span class="line">      _state &lt;= (_statePendingComplete | _stateIgnoreError);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _addListener(_FutureListener listener) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(listener._nextListener == <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">// 如果是待完成的或者忽略错误的,将当前listener添加到链表头部；</span></span><br><span class="line">		<span class="comment">// 在后文处理结果的时候，会从链表尾部开始读取</span></span><br><span class="line">    <span class="keyword">if</span> (_mayAddListener) &#123;</span><br><span class="line">      listener._nextListener = _resultOrListeners;</span><br><span class="line">      _resultOrListeners = listener;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (_isChained) &#123;</span><br><span class="line">        <span class="comment">// Delegate listeners to chained source future.</span></span><br><span class="line">        <span class="comment">// If the source is complete, instead copy its values and</span></span><br><span class="line">        <span class="comment">// drop the chaining.</span></span><br><span class="line">        _Future source = _chainSource;</span><br><span class="line">        <span class="keyword">if</span> (!source._isComplete) &#123;</span><br><span class="line">				  <span class="comment">// 如果依赖于source，那么就添加为source的listener</span></span><br><span class="line">          source._addListener(listener);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _cloneResult(source);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">assert</span>(_isComplete);</span><br><span class="line">      <span class="comment">// Handle late listeners asynchronously.</span></span><br><span class="line">      _zone.scheduleMicrotask(() &#123;</span><br><span class="line">				<span class="comment">// Propagates the value/error of [source] to its [listeners]</span></span><br><span class="line">        _propagateToListeners(<span class="keyword">this</span>, listener);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_Future._addListener(_FutureListener listener)</code>中基本上做了如下判断：</p>
<ul>
<li>如果Future是延迟完成的，就添加监听。</li>
<li>如果Future已经完成了，就加入到micro task中，安排执行listener回调（<code>_propagateToListeners(this, listener)</code>）。</li>
</ul>
<p>具体可以参考<a href="https://juejin.cn/post/6844904196819402759">Flutter之Future原理解析</a>。</p>
<br>

<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>我们再看一下Timer的实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\timer.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Timer.run</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> run(<span class="keyword">void</span> <span class="built_in">Function</span>() callback) &#123;</span><br><span class="line">    <span class="keyword">new</span> Timer(<span class="built_in">Duration</span>.zero, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">factory</span> Timer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> <span class="built_in">Function</span>() callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Zone.current == Zone.root) &#123;</span><br><span class="line">      <span class="comment">// No need to bind the callback. We know that the root&#x27;s timer will</span></span><br><span class="line">      <span class="comment">// be invoked in the root zone.</span></span><br><span class="line">      <span class="keyword">return</span> Zone.current.createTimer(duration, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Zone.current</span><br><span class="line">        .createTimer(duration, Zone.current.bindCallbackGuarded(callback));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">factory</span> Timer.periodic(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> callback(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Zone.current == Zone.root) &#123;</span><br><span class="line">      <span class="comment">// No need to bind the callback. We know that the root&#x27;s timer will</span></span><br><span class="line">      <span class="comment">// be invoked in the root zone.</span></span><br><span class="line">      <span class="keyword">return</span> Zone.current.createPeriodicTimer(duration, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> boundCallback = Zone.current.bindUnaryCallbackGuarded&lt;Timer&gt;(callback);</span><br><span class="line">    <span class="keyword">return</span> Zone.current.createPeriodicTimer(duration, boundCallback);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建Timer"><a href="#创建Timer" class="headerlink" title="创建Timer"></a>创建Timer</h3><p>可以看到，Timer的创建实际上是Zone通过两种方式创建的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\zone.dart</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Zone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// <span class="language-markdown">Creates a [Timer] where the callback is executed in this zone.</span></span></span><br><span class="line">  Timer createTimer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> <span class="built_in">Function</span>() callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a periodic [Timer] where the callback is executed in this zone.</span></span></span><br><span class="line">  Timer createPeriodicTimer(<span class="built_in">Duration</span> period, <span class="keyword">void</span> callback(Timer timer));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zone是抽象类，他的实现是<code>_RootZone</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\zone.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RootZone</span> <span class="keyword">extends</span> <span class="title">_Zone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Timer createTimer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> f()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Timer._createTimer(duration, f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Timer createPeriodicTimer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> f(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Timer._createPeriodicTimer(duration, f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里实际上是调用了Timer中对应的私有方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\timer.dart</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">external</span> <span class="keyword">static</span> Timer _createTimer(</span><br><span class="line">      <span class="built_in">Duration</span> duration, <span class="keyword">void</span> <span class="built_in">Function</span>() callback);</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> Timer _createPeriodicTimer(</span><br><span class="line">      <span class="built_in">Duration</span> duration, <span class="keyword">void</span> callback(Timer timer));</span><br></pre></td></tr></table></figure>

<p>他们的具体实现在<code>timer_patch.dart</code>中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Timer _createTimer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> callback()) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">factory</span> = VMLibraryHooks.timerFactory;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">factory</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedError(<span class="string">&quot;Timer interface not supported.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> milliseconds = duration.inMilliseconds;</span><br><span class="line">    <span class="keyword">if</span> (milliseconds &lt; <span class="number">0</span>) milliseconds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">factory</span>(milliseconds, (_) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Timer _createPeriodicTimer(</span><br><span class="line">      <span class="built_in">Duration</span> duration, <span class="keyword">void</span> callback(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">factory</span> = VMLibraryHooks.timerFactory;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">factory</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedError(<span class="string">&quot;Timer interface not supported.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> milliseconds = duration.inMilliseconds;</span><br><span class="line">    <span class="keyword">if</span> (milliseconds &lt; <span class="number">0</span>) milliseconds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">factory</span>(milliseconds, callback, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论是单次的还是循环的Timer都是使用<code>VMLibraryHooks.timerFactory</code>创建的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line">_setupHooks() &#123;</span><br><span class="line">  VMLibraryHooks.timerFactory = _Timer._<span class="keyword">factory</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The Timer factory registered with the dart:async library by the embedder.</span></span><br><span class="line">  <span class="keyword">static</span> Timer _<span class="keyword">factory</span>(</span><br><span class="line">      <span class="built_in">int</span> milliSeconds, <span class="keyword">void</span> callback(Timer timer), <span class="built_in">bool</span> repeating) &#123;</span><br><span class="line">    <span class="keyword">if</span> (repeating) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _Timer.periodic(milliSeconds, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Timer(milliSeconds, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">factory</span> _Timer(<span class="built_in">int</span> milliSeconds, <span class="keyword">void</span> callback(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> _createTimer(callback, milliSeconds, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> _Timer.periodic(<span class="built_in">int</span> milliSeconds, <span class="keyword">void</span> callback(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> _createTimer(callback, milliSeconds, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最终都是调用的<code>_Timer._createTimer</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> _Timer _createTimer(</span><br><span class="line">      <span class="keyword">void</span> callback(Timer timer), <span class="built_in">int</span> milliSeconds, <span class="built_in">bool</span> repeating) &#123;</span><br><span class="line">    <span class="comment">// Negative timeouts are treated as if 0 timeout.</span></span><br><span class="line">    <span class="keyword">if</span> (milliSeconds &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      milliSeconds = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add one because DateTime.now() is assumed to round down</span></span><br><span class="line">    <span class="comment">// to nearest millisecond, not up, so that time + duration is before</span></span><br><span class="line">    <span class="comment">// duration milliseconds from now. Using microsecond timers like</span></span><br><span class="line">    <span class="comment">// Stopwatch allows detecting that the timer fires early.</span></span><br><span class="line">    <span class="built_in">int</span> now = VMLibraryHooks.timerMillisecondClock();</span><br><span class="line">    <span class="built_in">int</span> wakeupTime = (milliSeconds == <span class="number">0</span>) ? now : (now + <span class="number">1</span> + milliSeconds);</span><br><span class="line"></span><br><span class="line">    _Timer timer =</span><br><span class="line">        <span class="keyword">new</span> _Timer._internal(callback, wakeupTime, milliSeconds, repeating);</span><br><span class="line">    <span class="comment">// Enqueue this newly created timer in the appropriate structure and</span></span><br><span class="line">    <span class="comment">// notify if necessary.</span></span><br><span class="line">    timer._enqueue();</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在创建timer的时候，先获取了当前的时间戳，然后计算出timer的唤醒时间<code>wakeupTime</code> ，最后调用<code>_Timer._internal</code>创建timer。</p>
<p><code>_Timer._internal</code>只是简单创建了Timer:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_Timer._internal(</span><br><span class="line">      <span class="keyword">this</span>._callback, <span class="keyword">this</span>._wakeupTime, <span class="keyword">this</span>._milliSeconds, <span class="keyword">this</span>._repeating)</span><br><span class="line">      : _id = _nextId();</span><br></pre></td></tr></table></figure>

<p>在创建根据需要创建好Timer之后，使用<code>_Timer._enqueue</code>方法把Timer放入到相应的队列中。</p>
<h3 id="timer-enqueue"><a href="#timer-enqueue" class="headerlink" title="timer._enqueue"></a>timer._enqueue</h3><p>主要看一下<code>timer._enqueue()</code>方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Timers are ordered by wakeup time. Timers with a timeout value of &gt; 0 do</span></span><br><span class="line">  <span class="comment">// end up on the TimerHeap. Timers with a timeout of 0 are queued in a list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _heap = <span class="keyword">new</span> _TimerHeap();</span><br><span class="line">  <span class="keyword">static</span> _Timer? _firstZeroTimer;</span><br><span class="line">  <span class="keyword">static</span> _Timer _lastZeroTimer = _sentinelTimer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adds a timer to the heap or timer list. Timers with the same wakeup time</span></span><br><span class="line">  <span class="comment">// are enqueued in order and notified in FIFO order.</span></span><br><span class="line">  <span class="keyword">void</span> _enqueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_milliSeconds == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_firstZeroTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        _lastZeroTimer = <span class="keyword">this</span>;</span><br><span class="line">        _firstZeroTimer = <span class="keyword">this</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _lastZeroTimer._indexOrNext = <span class="keyword">this</span>;</span><br><span class="line">        _lastZeroTimer = <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Every zero timer gets its own event.</span></span><br><span class="line">      _notifyZeroHandler();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _heap.add(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (_heap.isFirst(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        _notifyEventHandler();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到无论是单次还是循环的Timer最后都是使用<code>_Timer._internal</code>创建的，然后再使用<code>_Timer._enqueue()</code>方法将timer添加到<code>heap</code>或者<code>timer list</code>中：</p>
<ul>
<li>如果Timer的<code>_milliSeconds</code>为0，则会被添加到<code>_lastZeroTimer</code>中（并将上一个timer的_indexOrNext指向自己），并在<code>_notifyZeroHandler()</code>方法发送_ZERO_EVENT事件（最终会触发<code>_Timer._handleMessage</code> ）；</li>
<li>否则则将其加入到<code>_heap</code>中，如果他是第一个timer，就通过<code>_notifyEventHandler()</code>启动处理Timer的event handler（这个线程会在合适的时间唤起Timer执行<code>_Timer._handleMessage</code>方法）。</li>
</ul>
<p>在具体分析整个过程之前，我们先看一下几个属性的创建过程：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Timer</span> <span class="keyword">implements</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> _RawReceivePortImpl? _receivePort;</span><br><span class="line">  <span class="keyword">static</span> SendPort? _sendPort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the event handler to wake this isolate at a specific time.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _scheduleWakeup(<span class="built_in">int</span> wakeupTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_receivePortActive) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    VMLibraryHooks.eventHandlerSendData(<span class="keyword">null</span>, _sendPort!, wakeupTime);</span><br><span class="line">    _scheduledWakeupTime = wakeupTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue one message for each zero timer. To be able to distinguish from</span></span><br><span class="line">  <span class="comment">// EventHandler messages we send a _ZERO_EVENT instead of a _TIMEOUT_EVENT.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _notifyZeroHandler() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_receivePortActive) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    _sendPort!.send(_ZERO_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a receive port and register a message handler for the timer</span></span><br><span class="line">  <span class="comment">// events.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _createTimerHandler() &#123;</span><br><span class="line">    <span class="keyword">var</span> receivePort = _receivePort;</span><br><span class="line">    <span class="keyword">if</span> (receivePort == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_sendPort == <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">final</span> port = _RawReceivePortImpl(<span class="string">&#x27;Timer&#x27;</span>);</span><br><span class="line">      port.handler = _handleMessage;</span><br><span class="line">      _sendPort = port.sendPort;</span><br><span class="line">      _receivePort = port;</span><br><span class="line">      _scheduledWakeupTime = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      receivePort._setActive(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _receivePortActive = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码我们可以看到：</p>
<ul>
<li><code>_sendPort</code>是<code>_receivePort</code>对应的sendPort，后者的handler是<code>_handleMessage()</code>方法</li>
<li>无论是<code>_notifyEventHandler()</code>还是 <code>_notifyZeroHandler()</code>都会保证<code>_createTimerHandler()</code>被<strong>调用过</strong>。</li>
</ul>
<h4 id="milliSeconds-x3D-x3D-0"><a href="#milliSeconds-x3D-x3D-0" class="headerlink" title="_milliSeconds &#x3D;&#x3D; 0"></a>_milliSeconds &#x3D;&#x3D; 0</h4><p>先看一下<code>_milliSeconds</code>为0的情况：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue one message for each zero timer. To be able to distinguish from</span></span><br><span class="line">  <span class="comment">// EventHandler messages we send a _ZERO_EVENT instead of a _TIMEOUT_EVENT.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _notifyZeroHandler() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_receivePortActive) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    _sendPort!.send(_ZERO_EVENT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的分析，<code>_sendPort!.send(_ZERO_EVENT)</code>发送的消息，通过<code>MessageHandler::PostMessage</code>处理，最后调用<code>_receivePort</code>的handler也就是在<code>_handleMessage(msg)</code>方法中执行。</p>
<h4 id="milliSeconds-≠-0"><a href="#milliSeconds-≠-0" class="headerlink" title="_milliSeconds ≠ 0"></a>_milliSeconds ≠ 0</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _notifyEventHandler() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_handlingCallbacks) &#123;</span><br><span class="line">      <span class="comment">// While we are already handling callbacks we will not notify the event</span></span><br><span class="line">      <span class="comment">// handler. _handleTimeout will call _notifyEventHandler once all pending</span></span><br><span class="line">      <span class="comment">// timers are processed.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are no pending timers. Close down the receive port.</span></span><br><span class="line">    <span class="keyword">if</span> ((_firstZeroTimer == <span class="keyword">null</span>) &amp;&amp; _heap.isEmpty) &#123;</span><br><span class="line">      <span class="comment">// No pending timers: Close the receive port and let the event handler</span></span><br><span class="line">      <span class="comment">// know.</span></span><br><span class="line">      <span class="keyword">if</span> (_sendPort != <span class="keyword">null</span>) &#123;</span><br><span class="line">        _cancelWakeup();</span><br><span class="line">        _shutdownTimerHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_heap.isEmpty) &#123;</span><br><span class="line">      <span class="comment">// Only zero timers are left. Cancel any scheduled wakeups.</span></span><br><span class="line">      _cancelWakeup();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Only send a message if the requested wakeup time differs from the</span></span><br><span class="line">    <span class="comment">// already scheduled wakeup time.</span></span><br><span class="line">    <span class="keyword">var</span> wakeupTime = _heap.first._wakeupTime;</span><br><span class="line">    <span class="keyword">if</span> ((_scheduledWakeupTime == <span class="number">0</span>) || (wakeupTime != _scheduledWakeupTime)) &#123;</span><br><span class="line">      _scheduleWakeup(wakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the event handler to wake this isolate at a specific time.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _scheduleWakeup(<span class="built_in">int</span> wakeupTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_receivePortActive) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    VMLibraryHooks.eventHandlerSendData(<span class="keyword">null</span>, _sendPort!, wakeupTime);</span><br><span class="line">    _scheduledWakeupTime = wakeupTime;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可见，当_milliSeconds ≠ 0的时候，会将其加入到<code>_heap</code>中，如果当前的timer是<code>_heap</code>中第一个，则调用<code>_notifyEventHandler()</code>告诉event handler<strong>在指定的时间唤起isolate</strong>。</p>
<p>这里主要的实现是<code>VMLibraryHooks.eventHandlerSendData</code>，他的实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\bin\common_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line">_setupHooks() &#123;</span><br><span class="line">  VMLibraryHooks.eventHandlerSendData = _EventHandler._sendData;</span><br><span class="line">  VMLibraryHooks.timerMillisecondClock = _EventHandler._timerMillisecondClock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\bin\eventhandler_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_EventHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;EventHandler_SendData&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="keyword">void</span> _sendData(<span class="built_in">Object?</span> sender, SendPort sendPort, <span class="built_in">int</span> data);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;EventHandler_TimerMillisecondClock&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="built_in">int</span> _timerMillisecondClock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\bin\eventhandler.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Send data to the EventHandler thread to register for a given instance</span></span><br><span class="line"><span class="comment"> * args[0] a ReceivePort args[1] with a notification event args[2].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> FUNCTION_NAME(EventHandler_SendData)(Dart_NativeArguments args) &#123;</span><br><span class="line">  <span class="comment">// Get the id out of the send port. If the handle is not a send port</span></span><br><span class="line">  <span class="comment">// we will get an error and propagate that out.</span></span><br><span class="line">  Dart_Handle handle = Dart_GetNativeArgument(args, <span class="number">1</span>);</span><br><span class="line">  Dart_Port dart_port;</span><br><span class="line">  handle = Dart_SendPortGetId(handle, &amp;dart_port);</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsError(handle)) &#123;</span><br><span class="line">    Dart_PropagateError(handle);</span><br><span class="line">    UNREACHABLE();</span><br><span class="line">  &#125;</span><br><span class="line">  Dart_Handle sender = Dart_GetNativeArgument(args, <span class="number">0</span>);</span><br><span class="line">  intptr_t id;</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsNull(sender)) &#123;</span><br><span class="line">    id = kTimerId;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Socket* socket = Socket::GetSocketIdNativeField(sender);</span><br><span class="line">    ASSERT(dart_port != ILLEGAL_PORT);</span><br><span class="line">    socket-&gt;set_port(dart_port);</span><br><span class="line">    socket-&gt;Retain();  <span class="comment">// inc refcount before sending to the eventhandler.</span></span><br><span class="line">    id = reinterpret_cast&lt;intptr_t&gt;(socket);</span><br><span class="line">  &#125;</span><br><span class="line">  int64_t data = DartUtils::GetIntegerValue(Dart_GetNativeArgument(args, <span class="number">2</span>));</span><br><span class="line">  event_handler-&gt;SendData(id, dart_port, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的实现在native层的<code>EventHander</code>中名为<code>event handler</code>的子线程中<strong>通过异步IO执行任务</strong>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line"> public:</span><br><span class="line">  EventHandler() &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> SendData(intptr_t id, Dart_Port dart_port, int64_t data) &#123;</span><br><span class="line">    delegate_.SendData(id, dart_port, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的系统实现不同，对于Android来说：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\eventhandler_android.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> EventHandlerImplementation::SendData(intptr_t id,</span><br><span class="line">                                          Dart_Port dart_port,</span><br><span class="line">                                          int64_t data) &#123;</span><br><span class="line">  WakeupHandler(id, dart_port, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> EventHandlerImplementation::WakeupHandler(intptr_t id,</span><br><span class="line">                                               Dart_Port dart_port,</span><br><span class="line">                                               int64_t data) &#123;</span><br><span class="line">  InterruptMessage msg;</span><br><span class="line">  msg.id = id;</span><br><span class="line">  msg.dart_port = dart_port;</span><br><span class="line">  msg.data = data;</span><br><span class="line">  <span class="comment">// WriteToBlocking will write up to 512 bytes atomically, and since our msg</span></span><br><span class="line">  <span class="comment">// is smaller than 512, we don&#x27;t need a thread lock.</span></span><br><span class="line">  <span class="comment">// See: http://linux.die.net/man/7/pipe, section &#x27;Pipe_buf&#x27;.</span></span><br><span class="line">  ASSERT(kInterruptMessageSize &lt; PIPE_BUF);</span><br><span class="line">  intptr_t result =</span><br><span class="line">      FDUtils::WriteToBlocking(interrupt_fds_[<span class="number">1</span>], &amp;msg, kInterruptMessageSize);</span><br><span class="line">  <span class="keyword">if</span> (result != kInterruptMessageSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;Interrupt message failure:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FATAL1(<span class="string">&quot;Interrupt message failure. Wrote %&quot;</span> Pd <span class="string">&quot; bytes.&quot;</span>, result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后系统会在时间到了之后，会调用<code>EventHandlerImplementation::HandleEvents</code>通过<code>_send_port</code>发送消息，并触发<code>_receivePort</code>的hander也就是<code>_handleMessage</code>方法处理消息。</p>
<h4 id="handleMessage"><a href="#handleMessage" class="headerlink" title="_handleMessage"></a>_handleMessage</h4><p>无论是_milliSeconds &#x3D;&#x3D; 0 的时候<code>_sendPort!.send(_ZERO_EVENT);</code>，还是_milliSeconds !&#x3D; 0 通过<code>EventHandler</code>发送_TIMEOUT_EVENT消息，最终都会使用<code>_handleMessage</code>处理消息：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _handleMessage(msg) &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;_Timer&gt; pendingTimers;</span><br><span class="line">    <span class="keyword">if</span> (msg == _ZERO_EVENT) &#123;</span><br><span class="line">      pendingTimers = _queueFromZeroEvent();</span><br><span class="line">      <span class="keyword">assert</span>(pendingTimers.length &gt; <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span>(msg == _TIMEOUT_EVENT);</span><br><span class="line">      _scheduledWakeupTime = <span class="number">0</span>; <span class="comment">// Consumed the last scheduled wakeup now.</span></span><br><span class="line">      pendingTimers = _queueFromTimeoutEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    _runTimers(pendingTimers);</span><br><span class="line">    <span class="comment">// Notify the event handler or shutdown the port if no more pending</span></span><br><span class="line">    <span class="comment">// timers are present.</span></span><br><span class="line">    _notifyEventHandler();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_handleMessage</code>中按照msg的类型取出对应的<code>pendingTimers</code>然后再<code>_runTimers</code>中执行，在执行完毕或者遇到错误时，调用<code>_notifyEventHandler()</code>通知<code>event handler</code>或者关闭<code>TimerHandler</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _runTimers(<span class="built_in">List</span>&lt;_Timer&gt; pendingTimers) &#123;</span><br><span class="line">    <span class="comment">// If there are no pending timers currently reset the id space before we</span></span><br><span class="line">    <span class="comment">// have a chance to enqueue new timers.</span></span><br><span class="line">    <span class="keyword">if</span> (_heap.isEmpty &amp;&amp; (_firstZeroTimer == <span class="keyword">null</span>)) &#123;</span><br><span class="line">      _idCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast exit if no pending timers.</span></span><br><span class="line">    <span class="keyword">if</span> (pendingTimers.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all of the pending timers. New timers added as part of the</span></span><br><span class="line">    <span class="comment">// callbacks will be enqueued now and notified in the next spin at the</span></span><br><span class="line">    <span class="comment">// earliest.</span></span><br><span class="line">    _handlingCallbacks = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 在这里遍历处理所有的pendingTimers</span></span><br><span class="line">      <span class="keyword">for</span> (; i &lt; pendingTimers.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Next pending timer.</span></span><br><span class="line">        <span class="keyword">var</span> timer = pendingTimers[i];</span><br><span class="line">        timer._indexOrNext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// One of the timers in the pending_timers list can cancel</span></span><br><span class="line">        <span class="comment">// one of the later timers which will set the callback to</span></span><br><span class="line">        <span class="comment">// null. Or the pending zero timer has been canceled earlier.</span></span><br><span class="line">        <span class="keyword">var</span> callback = timer._callback;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!timer._repeating) &#123;</span><br><span class="line">            <span class="comment">// Mark timer as inactive.</span></span><br><span class="line">            timer._callback = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer._milliSeconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> ms = timer._milliSeconds;</span><br><span class="line">            <span class="built_in">int</span> overdue =</span><br><span class="line">                VMLibraryHooks.timerMillisecondClock() - timer._wakeupTime;</span><br><span class="line">            <span class="keyword">if</span> (overdue &gt; ms) &#123;</span><br><span class="line">              <span class="built_in">int</span> missedTicks = overdue ~/ ms;</span><br><span class="line">              timer._wakeupTime += missedTicks * ms;</span><br><span class="line">              timer._tick += missedTicks;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          timer._tick += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          callback(timer);</span><br><span class="line">          <span class="comment">// Re-insert repeating timer if not canceled.</span></span><br><span class="line">          <span class="keyword">if</span> (timer._repeating &amp;&amp; (timer._callback != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            timer._advanceWakeupTime();</span><br><span class="line">            timer._enqueue();</span><br><span class="line">          &#125;</span><br><span class="line">					<span class="comment">// 每次执行完event之后，都要执行没有被执行的micro task</span></span><br><span class="line">          <span class="comment">// Execute pending micro tasks.</span></span><br><span class="line">          _runPendingImmediateCallback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _handlingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// Re-queue timers we didn&#x27;t get to.</span></span><br><span class="line">      <span class="keyword">for</span> (i++; i &lt; pendingTimers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> timer = pendingTimers[i];</span><br><span class="line">        timer._enqueue();</span><br><span class="line">      &#125;</span><br><span class="line">      _notifyEventHandler();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，这里依次遍历传入的pendingTimers，并在每次执行完event后，去检查执行一下micro task。</p>
<br>

<p>根据创建Timer的时候_milliSeconds是否等于0：会分别使用<code>MessageHandler</code><strong>执行</strong>或者在<strong>名为event handler的IO线程</strong>通过<code>isolate</code>中的<code>MessageHandler</code>来执行任务；最后都会触发Timer的<code>_handleMessage</code>方法在<code>_runTimers</code>方法中执行callback。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>综上，dart中的方法总共有3种，按照优先级从前到后依次是：</p>
<ol>
<li>普通的同步方法</li>
<li>micro task</li>
<li>其他event：部分Future、Timer、点击事件、屏幕刷新等</li>
</ol>
<p>在方法执行的时候：</p>
<ol>
<li>先执行完毕所有的同步方法；</li>
<li>然后判断是否有micro task，有的话就立即执行；</li>
<li>否则，就执行普通的event，每次执行完一个event就执行一次步骤2；</li>
<li>直到当前app中既没有micro task也没有普通的event，退出app。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/dart-lang/sdk">dart sdk</a></p>
<p><a href="https://web.archive.org/web/20170704074724/https://webdev.dartlang.org/articles/performance/event-loop">The Event Loop and Dart</a></p>
<p><a href="https://juejin.cn/post/6844904196819402759#heading-0">Flutter之Future原理解析 - 掘金</a></p>
<p><a href="https://juejin.cn/post/6844904196819386375">Flutter之Timer原理解析 - 掘金</a></p>
<p><a href="https://dart.dev/">Dart 官网</a></p>
]]></content>
      <tags>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart 读取文件过程分析</title>
    <url>/blog/posts/3db5282/</url>
    <content><![CDATA[<p>Dart读取文件时，先在Dart代码创建File引用，通过与<code>IOService</code>跨<code>Isolate</code>通信（先通过IO Service而发送请求到native端，等到native执行完操作之后再回调结果）从而实现对文件的读写。</p>
<p>实现一个简单的读取文件的代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> filePath =</span><br><span class="line">      <span class="string">r&quot;G:/21996.1.210529-1541.co_release_CLIENT_CONSUMER_x64FRE_en-us.iso&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> file = File(filePath);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> startTime = printCurrentTimeMs(<span class="string">&quot;start run file.readAsBytes&quot;</span>);</span><br><span class="line">  file.readAsBytes().then((value) &#123;</span><br><span class="line">    printCurrentTimeMs(<span class="string">&quot;file.readAsBytes() finish&quot;</span>,</span><br><span class="line">        lastTimeMs: startTime,</span><br><span class="line">        suffix: <span class="string">&quot;\nfile.readAsBytes() result:<span class="subst">$&#123;value.length&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  printCurrentTimeMs(<span class="string">&quot;finish run file.readAsBytes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> printCurrentTimeMs(<span class="built_in">String</span> prefix, &#123;<span class="built_in">String?</span> suffix, <span class="built_in">int?</span> lastTimeMs&#125;) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentTimeMs = <span class="built_in">DateTime</span>.now().millisecondsSinceEpoch;</span><br><span class="line">  <span class="keyword">var</span> timeElapseString =</span><br><span class="line">      lastTimeMs == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, time elapse:<span class="subst">$&#123;currentTimeMs - lastTimeMs&#125;</span>ms &quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(</span><br><span class="line">      <span class="string">&quot;<span class="subst">$prefix</span> current time(<span class="subst">$currentTimeMs</span>)<span class="subst">$timeElapseString</span><span class="subst">$&#123;suffix ?? <span class="string">&quot;&quot;</span>&#125;</span>&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> currentTimeMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个过程如下：</p>
<p><img src="https://jixiaoyong.github.io/images/202206041125613.png"></p>
<h1 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h1><h2 id="Dart端发起文件读写请求"><a href="#Dart端发起文件读写请求" class="headerlink" title="Dart端发起文件读写请求"></a>Dart端发起文件读写请求</h2><p>其中<code>file.readAsBytes()</code> 是具体执行读取文件的地方，他的定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\io\file_impl.dart</span></span><br><span class="line">Future&lt;Uint8List&gt; readAsBytes();</span><br></pre></td></tr></table></figure>

<p>在我们创建<code>File</code>时，实际上创建的是<code>_File</code> （<code>class _File extends FileSystemEntity implements File</code>）对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\io\file_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// abstract class File implements FileSystemEntity</span></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>)</span><br><span class="line">  <span class="keyword">factory</span> File(<span class="built_in">String</span> path) &#123;</span><br><span class="line">    <span class="keyword">final</span> IOOverrides? overrides = IOOverrides.current;</span><br><span class="line">    <span class="keyword">if</span> (overrides == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _File(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overrides.createFile(path);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>_File</code> 是<code>File</code> 的实现类，所以<code>file.readAsBytes()</code>实际调用的是<code>_File</code> 实现的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\io\file_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the file in blocks of size 64k.</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> _blockSize = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_File</span> <span class="keyword">extends</span> <span class="title">FileSystemEntity</span> <span class="keyword">implements</span> <span class="title">File</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Future&lt;Uint8List&gt; readAsBytes() &#123;</span><br><span class="line">    Future&lt;Uint8List&gt; readDataChunked(RandomAccessFile file) &#123;</span><br><span class="line">			<span class="comment">// 分段读取文件，每次只读取_blockSize大小的内容</span></span><br><span class="line">      <span class="keyword">var</span> builder = <span class="keyword">new</span> BytesBuilder(copy: <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">var</span> completer = <span class="keyword">new</span> Completer&lt;Uint8List&gt;();</span><br><span class="line">      <span class="keyword">void</span> read() &#123;</span><br><span class="line">				<span class="comment">// 每次只异步读取一部分文本</span></span><br><span class="line">        file.read(_blockSize).then((data) &#123;</span><br><span class="line">          <span class="keyword">if</span> (data.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            builder.add(data);</span><br><span class="line">            read();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            completer.complete(builder.takeBytes());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, onError: completer.completeError);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      read();</span><br><span class="line">      <span class="keyword">return</span> completer.future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> open().then((file) &#123;</span><br><span class="line">      <span class="keyword">return</span> file.length().then((length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// May be character device, try to read it in chunks.</span></span><br><span class="line">          <span class="keyword">return</span> readDataChunked(file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> file.read(length);</span><br><span class="line">      &#125;).whenComplete(file.close);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论是普通的文件格式，还是character device，最后都是调用了<code>_RandomAccessFile</code>的<code>open()</code>和<code>read(int bytes)</code>方法异步读取文件。</p>
<blockquote>
<p>设备文件分为Block Device Driver和Character Device Drive两类。<br>Character Device Driver又被称为字符设备或裸设备raw devices; Block Device Driver通常成为块设备。<br>而Block Device Driver是以固定大小长度来传送转移资料 ； Character Device Driver是以不定长度的字元传送资料。 <a href="https://www.cnblogs.com/qlee/archive/2011/07/27/2118406.html#:~:text=Character">https://www.cnblogs.com/qlee/archive/2011/07/27/2118406.html#:~:text&#x3D;Character</a></p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; flutter\bin\cache\pkg\sky_engine\lib\io\file_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RandomAccessFile</span> <span class="keyword">implements</span> <span class="title">RandomAccessFile</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> path;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _asyncDispatched = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 读取文件的信息</span></span><br><span class="line">  <span class="keyword">late</span> _FileResourceInfo _resourceInfo;</span><br><span class="line">	<span class="comment">// 对文件的操作引用</span></span><br><span class="line">  _RandomAccessFileOps _ops;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>)</span><br><span class="line">  _RandomAccessFile(<span class="built_in">int</span> pointer, <span class="keyword">this</span>.path)</span><br><span class="line">      : _ops = <span class="keyword">new</span> _RandomAccessFileOps(pointer) &#123;</span><br><span class="line">    _resourceInfo = <span class="keyword">new</span> _FileResourceInfo(<span class="keyword">this</span>);</span><br><span class="line">    _maybeConnectHandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步读取文件</span></span><br><span class="line">	Future&lt;Uint8List&gt; read(<span class="built_in">int</span> bytes) &#123;</span><br><span class="line">    <span class="comment">// TODO(40614): Remove once non-nullability is sound.</span></span><br><span class="line">    ArgumentError.checkNotNull(bytes, <span class="string">&quot;bytes&quot;</span>);</span><br><span class="line">			<span class="comment">// 异步读取文件，实际上是将发送指令到IO Service，然后等待返回结果</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch(_IOService.fileRead, [<span class="keyword">null</span>, bytes]).then((response) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_isErrorResponse(response)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> _exceptionFromResponse(response, <span class="string">&quot;read failed&quot;</span>, path);</span><br><span class="line">      &#125;</span><br><span class="line">      _resourceInfo.addRead(response[<span class="number">1</span>].length);</span><br><span class="line">			<span class="comment">// 读取的文件内容</span></span><br><span class="line">      Uint8List result = response[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步读取文件</span></span><br><span class="line">  Uint8List readSync(<span class="built_in">int</span> bytes) &#123;</span><br><span class="line">    <span class="comment">// TODO(40614): Remove once non-nullability is sound.</span></span><br><span class="line">    ArgumentError.checkNotNull(bytes, <span class="string">&quot;bytes&quot;</span>);</span><br><span class="line">    _checkAvailable();</span><br><span class="line">		<span class="comment">// 同步读取文件是对文件直接操作</span></span><br><span class="line">    <span class="keyword">var</span> result = _ops.read(bytes);</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">is</span> OSError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> FileSystemException(<span class="string">&quot;readSync failed&quot;</span>, path, result);</span><br><span class="line">    &#125;</span><br><span class="line">    _resourceInfo.addRead(result.length);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Future&lt;RandomAccessFile&gt; open(&#123;FileMode mode = FileMode.read&#125;) &#123;</span><br><span class="line"><span class="comment">// FileMode  https://github.com/dart-lang/sdk/blob/main/sdk/lib/io/io_service.dart</span></span><br><span class="line">    <span class="keyword">if</span> (mode != FileMode.read &amp;&amp;</span><br><span class="line">        mode != FileMode.write &amp;&amp;</span><br><span class="line">        mode != FileMode.append &amp;&amp;</span><br><span class="line">        mode != FileMode.writeOnly &amp;&amp;</span><br><span class="line">        mode != FileMode.writeOnlyAppend) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Future.error(</span><br><span class="line">          <span class="keyword">new</span> ArgumentError(<span class="string">&#x27;Invalid file mode for this operation&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatchWithNamespace(</span><br><span class="line">				<span class="comment">// 请求操作为“打开文件”，参数为：null，文件路径，操作文件的mode</span></span><br><span class="line">        _IOService.fileOpen, [<span class="keyword">null</span>, _rawPath, mode._mode]).then((response) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_isErrorResponse(response)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> _exceptionFromResponse(response, <span class="string">&quot;Cannot open file&quot;</span>, path);</span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 从IO Service那里异步获得文件句柄response和path</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _RandomAccessFile(response, path);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_RandomAccessFile</code>中，除了同步读写文件是对返回的文件引用直接操作外，很多操作都能看到通过<code>_dispatch()</code>方法与<code>IO Service</code>通信，让我们看一下这个方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\io\file_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _RandomAccessFile</span></span><br><span class="line">Future _dispatch(<span class="built_in">int</span> request, <span class="built_in">List</span> data, &#123;<span class="built_in">bool</span> markClosed = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Future.error(<span class="keyword">new</span> FileSystemException(<span class="string">&quot;File closed&quot;</span>, path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_asyncDispatched) &#123;</span><br><span class="line">      <span class="keyword">var</span> msg = <span class="string">&quot;An async operation is currently pending&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Future.error(<span class="keyword">new</span> FileSystemException(msg, path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (markClosed) &#123;</span><br><span class="line">      <span class="comment">// Set closed to true to ensure that no more async requests can be issued</span></span><br><span class="line">      <span class="comment">// for this file.</span></span><br><span class="line">      closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _asyncDispatched = <span class="keyword">true</span>;</span><br><span class="line">    data[<span class="number">0</span>] = _pointer();</span><br><span class="line">		<span class="comment">// 主要代码在这里，通过_IOService的_dispatch发送指令</span></span><br><span class="line">    <span class="keyword">return</span> **_IOService._dispatch**(request, data).whenComplete(() &#123;</span><br><span class="line">      _asyncDispatched = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// open create之类的操作会调用这个方法，不过最后也是调用_IOService._dispatch(request, data)通信</span></span><br><span class="line"><span class="keyword">static</span> Future _dispatchWithNamespace(<span class="built_in">int</span> request, <span class="built_in">List</span> data) &#123;</span><br><span class="line">    data[<span class="number">0</span>] = _namespacePointer();</span><br><span class="line">		<span class="comment">// 与IO Service进行异步通信，request标记请求操作的类型，data则是数据</span></span><br><span class="line">    <span class="keyword">return</span> **_IOService._dispatch**(request, data);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>查阅<a href="https://github.com/dart-lang/sdk/blob/main/sdk/lib/io/io_service.dart">_IOService</a>的源码后发现这是个<code>external</code> 方法.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">external</span> <span class="keyword">static</span> Future _dispatch(<span class="built_in">int</span> request, <span class="built_in">List</span> data);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>An <code>external</code> function is connected to its body by an implementation-specific mechanism. Attempting to invoke an external function that has not been connected to its body will throw a NoSuchMethodError or some subclass thereof.<br>****<a href="https://github.com/dart-lang/sdk/issues/4300">https://github.com/dart-lang/sdk/issues/4300</a></p>
</blockquote>
<p>根据<code>external</code>的定义，<code>_dispatch</code>方法在不同的机器上面实现不同。我们只看和app相关的实现（在<code>sdk\lib\_internal\vm</code>目录下，vm同级目录还有js等实现），具体的实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\bin\io_service_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _IOService</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IOService</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 用于向IO Service发送消息</span></span><br><span class="line">  <span class="keyword">static</span> _IOServicePorts _servicePorts = <span class="keyword">new</span> _IOServicePorts();</span><br><span class="line"><span class="comment">// We use a static variable here to hold onto the last result of</span></span><br><span class="line">  <span class="comment">// calling the IO Service frome the native.</span></span><br><span class="line">  <span class="keyword">static</span> RawReceivePort? _receivePort;</span><br><span class="line">  <span class="comment">// the other side(other isolate) will send message back with the _replyToPort</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">late</span> SendPort _replyToPort;</span><br><span class="line">  <span class="comment">// a map holding the registered callbacks for each received message.</span></span><br><span class="line">  <span class="keyword">static</span> HashMap&lt;<span class="built_in">int</span>, Completer&gt; _messageMap = <span class="keyword">new</span> HashMap&lt;<span class="built_in">int</span>, Completer&gt;();</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">int</span> _id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">[request] IO操作的类型，具体值在[sdk/lib/io/io<span class="emphasis">_service.dart]中的_</span>IOService类中定义</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="code">          主要有对文件、目录、网络进行操作的请求</span></span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="code">[data]    对应的数据，如果是文件，则是文件路径，如果是目录，则是目录路径等等</span></span></span></span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Future _dispatch(<span class="built_in">int</span> request, <span class="built_in">List</span> data) &#123;</span><br><span class="line">    <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// create a special id to identify the request.</span></span><br><span class="line">      id = _getNextId();</span><br><span class="line">    &#125; <span class="keyword">while</span> (_messageMap.containsKey(id));</span><br><span class="line">		<span class="comment">// 通过_servicePorts获取一个新的SendPort以便向IOService发送消息，</span></span><br><span class="line">		<span class="comment">// 这个SendPort是IO Service返回给dart用来向他发消息的</span></span><br><span class="line">    <span class="keyword">final</span> SendPort servicePort = _servicePorts._getPort(id);</span><br><span class="line">    _ensureInitialize();</span><br><span class="line">    <span class="keyword">final</span> Completer completer = <span class="keyword">new</span> Completer();</span><br><span class="line">    _messageMap[id] = completer;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 向IOService发送消息，当request执行完毕之后，</span></span><br><span class="line">			<span class="comment">// 会调用_replyToPort触发在root zone的回调_receivePort!.handler</span></span><br><span class="line">      **servicePort**.send(&lt;<span class="built_in">dynamic</span>&gt;[id, **_replyToPort**, request, data]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      _messageMap.remove(id)!.complete(error);</span><br><span class="line">      <span class="keyword">if</span> (_messageMap.length == <span class="number">0</span>) &#123;</span><br><span class="line">        _finalize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> completer.future;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _ensureInitialize() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_receivePort == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _receivePort = <span class="keyword">new</span> RawReceivePort(<span class="keyword">null</span>, <span class="string">&#x27;IO Service&#x27;</span>);</span><br><span class="line">			<span class="comment">// 其他地方可以使用_replyToPort来发消息触发_receivePort 执行handler方法</span></span><br><span class="line">      _replyToPort = _receivePort!.sendPort;</span><br><span class="line">      _receivePort!.handler = (data) &#123;</span><br><span class="line">			<span class="comment">// 在这里处理IOService执行完方法返回的数据</span></span><br><span class="line">        <span class="keyword">assert</span>(data <span class="keyword">is</span> <span class="built_in">List</span> &amp;&amp; data.length == <span class="number">2</span>);</span><br><span class="line">				<span class="comment">// data[0]就是我们在_dispatch方法中获取的id，</span></span><br><span class="line">        <span class="comment">// 将处理结果data[1]通过Completer.complete返回</span></span><br><span class="line">        _messageMap.remove(data[<span class="number">0</span>])!.complete(data[<span class="number">1</span>]);</span><br><span class="line">				<span class="comment">// 释放这个触发这个回调的SendPort</span></span><br><span class="line">        _servicePorts._returnPort(data[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (_messageMap.length == <span class="number">0</span>) &#123;</span><br><span class="line">          _finalize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最后是通过<code>RawReceivePort</code>&#x2F;<code>SendPort</code>进行<strong>跨Isolate通信</strong>。</p>
<p><code>_IOService</code>使用<code>_servicePorts</code>对native层发送消息触发IO操作，然后使用<code>_receivePort</code>监听，当IO操作完成时会通过<code>_replyToPort</code> 回调结果，会在 <code>_receivePort!.handler</code>方法中根据当时请求的<code>id</code>找到<code>Completer</code>将结果传递回去。</p>
<p>这样当时我们在 <code>file.readAsBytes()</code>时获取到的<code>Future</code>便会收到回调，从而完成文件操作的流程。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">file.readAsBytes().then((value) &#123;</span><br><span class="line">  printCurrentTimeMs(<span class="string">&quot;file.readAsBytes() finish&quot;</span>,</span><br><span class="line">      lastTimeMs: startTime,</span><br><span class="line">      suffix: <span class="string">&quot;\nfile.readAsBytes() result:<span class="subst">$&#123;value.length&#125;</span>&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是到目前为止涉及到的类关系示意图：</p>
<p><img src="https://jixiaoyong.github.io/images//202206041127617.png"></p>
<h2 id="IO-Service中转"><a href="#IO-Service中转" class="headerlink" title="IO Service中转"></a>IO Service中转</h2><p>那么，这个IO Service是做什么的，他又是如何实现与dart中的调用方双向通信，以及执行调用方需要的功能呢？</p>
<p>位于<code>sdk\lib\_internal\vm\bin\io_service_patch.dart</code>的_IOService是一个中转站，<strong>向上承接</strong>来自Dart代码的IO请求指令（先行返回Future），<strong>向下将这些指令转发</strong>至Native层的IO Service，并<strong>监听回调</strong>，当native层处理完这些IO指令之后，将结果通过Future返回给Dart调用方。</p>
<p>让我们再看一下他的具体实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\bin\io_service_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _IOService</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IOService</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 用于向IO Service发送消息</span></span><br><span class="line">  <span class="keyword">static</span> _IOServicePorts _servicePorts = <span class="keyword">new</span> _IOServicePorts();</span><br><span class="line"><span class="comment">// We use a static variable here to hold onto the last result of</span></span><br><span class="line">  <span class="comment">// calling the IO Service frome the native.</span></span><br><span class="line">  <span class="keyword">static</span> RawReceivePort? _receivePort;</span><br><span class="line">  <span class="comment">// the other side(other isolate) will send message back with the _replyToPort</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">late</span> SendPort _replyToPort;</span><br><span class="line">  <span class="comment">// a map holding the registered callbacks for each received message.</span></span><br><span class="line">  <span class="keyword">static</span> HashMap&lt;<span class="built_in">int</span>, Completer&gt; _messageMap = <span class="keyword">new</span> HashMap&lt;<span class="built_in">int</span>, Completer&gt;();</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">int</span> _id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">[request] IO操作的类型，具体值在[sdk/lib/io/io<span class="emphasis">_service.dart]中的_</span>IOService类中定义</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="code">          主要有对文件、目录、网络进行操作的请求</span></span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="code">[data]    对应的数据，如果是文件，则是文件路径，如果是目录，则是目录路径等等</span></span></span></span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Future _dispatch(<span class="built_in">int</span> request, <span class="built_in">List</span> data) &#123;</span><br><span class="line">    <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// create a special id to identify the request.</span></span><br><span class="line">      id = _getNextId();</span><br><span class="line">    &#125; <span class="keyword">while</span> (_messageMap.containsKey(id));</span><br><span class="line">		<span class="comment">// 通过_servicePorts获取一个新的SendPort以便向IOService发送消息，</span></span><br><span class="line">		<span class="comment">// 这个SendPort是IO Service返回给dart用来向他发消息的</span></span><br><span class="line">    <span class="keyword">final</span> SendPort **servicePort** = _servicePorts.**_getPort(id);**</span><br><span class="line">    _ensureInitialize();</span><br><span class="line">    <span class="keyword">final</span> Completer completer = <span class="keyword">new</span> Completer();</span><br><span class="line">    _messageMap[id] = completer;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 向IOService发送消息，当request执行完毕之后，</span></span><br><span class="line">			<span class="comment">// 会调用_replyToPort触发在root zone的回调_receivePort!.handler</span></span><br><span class="line">      **servicePort**.send(&lt;<span class="built_in">dynamic</span>&gt;[id, **_replyToPort**, request, data]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      _messageMap.remove(id)!.complete(error);</span><br><span class="line">      <span class="keyword">if</span> (_messageMap.length == <span class="number">0</span>) &#123;</span><br><span class="line">        _finalize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> completer.future;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _ensureInitialize() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_receivePort == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _receivePort = <span class="keyword">new</span> RawReceivePort(<span class="keyword">null</span>, <span class="string">&#x27;IO Service&#x27;</span>);</span><br><span class="line">			<span class="comment">// 其他地方可以使用_replyToPort来发消息触发_receivePort 执行handler方法</span></span><br><span class="line">      _replyToPort = _receivePort!.sendPort;</span><br><span class="line">      _receivePort!.handler = (data) &#123;</span><br><span class="line">			<span class="comment">// 在这里处理IOService执行完方法返回的数据</span></span><br><span class="line">        <span class="keyword">assert</span>(data <span class="keyword">is</span> <span class="built_in">List</span> &amp;&amp; data.length == <span class="number">2</span>);</span><br><span class="line">				<span class="comment">// data[0]就是我们在_dispatch方法中获取的id，</span></span><br><span class="line">        <span class="comment">// 将处理结果data[1]通过Completer.complete返回</span></span><br><span class="line">        _messageMap.remove(data[<span class="number">0</span>])!.complete(data[<span class="number">1</span>]);</span><br><span class="line">				<span class="comment">// 释放这个触发这个回调的SendPort</span></span><br><span class="line">        _servicePorts._returnPort(data[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (_messageMap.length == <span class="number">0</span>) &#123;</span><br><span class="line">          _finalize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<ul>
<li><code>_IOService</code>持有<code>_IOServicePorts _servicePorts</code>以便获取<code>SendPort servicePort</code>和native层通信，</li>
<li>在之前的代码分析中，我们已经知道<code>_IOService</code>还在<code>_ensureInitialize()</code>中监听着<code>RawReceivePort? _receivePort</code>的回调，</li>
<li>这样当<code>_IOService</code>在<code>_dispatch()</code>方法中将<code>_replyToPort</code>（<code>_receivePort</code>的SendPort）传递给<code>servicePort</code>后，一旦native通过<code>_replyToPort</code>发送处理结果，<code>_IOService</code>立马可以收到并通过<code>Completer.complete</code>返回给<strong>Dart中的调用方</strong>。</li>
</ul>
<aside>
💡 注意这里的`SendPort **servicePort`** ，他是从native层的`_IOService` 获取到的：
1. 在native层通过`PortMap::CreatePort(MessageHandler* handler)`创建好此`Dart_Port port` 
2. `MessageHandler` 在创建`Dart_Port port`的时候就与之关联
3. 在Dart层的`_IOService` 这里监听
这样，当native层的`MessageHandler`执行指令之后，会将`Dart_Port port`传递给`IOServiceCallback`，后者将他和自身执行结果一并打包为native层的Message压入`MessageHandler`的`消息queue`中，然后由消息分发系统按照发送到Dart这里，按照`SendPort **servicePort`** 找到要执行的代码。

</aside>

<p>上述这些步骤能够实施的关键，在于<strong>Dart</strong>层的<code>_IOService</code>如何与<strong>native</strong>层的<code>_IOService</code>关联起来呢？</p>
<p>让我们来分析一下<code>SendPort servicePort</code>的获取过程：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\bin\io_service_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IOService</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 用于向IO Service发送消息</span></span><br><span class="line">	<span class="keyword">static</span> _IOServicePorts _servicePorts = <span class="keyword">new</span> _IOServicePorts();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IOServicePorts</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We limit the number of IO Service ports per isolate so that we don&#x27;t</span></span><br><span class="line">  <span class="comment">// spawn too many threads all at once, which can crash the VM on Windows.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> maxPorts = <span class="number">32</span>;</span><br><span class="line">  <span class="built_in">List</span>&lt;SendPort&gt; _ports = &lt;SendPort&gt;[];</span><br><span class="line">  <span class="built_in">List</span>&lt;SendPort&gt; _freePorts = &lt;SendPort&gt;[];</span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, SendPort&gt; _usedPorts = <span class="keyword">new</span> HashMap&lt;<span class="built_in">int</span>, SendPort&gt;();</span><br><span class="line"></span><br><span class="line">  _IOServicePorts();</span><br><span class="line"></span><br><span class="line">  SendPort _getPort(<span class="built_in">int</span> forRequestId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_freePorts.isEmpty &amp;&amp; _usedPorts.length &lt; maxPorts) &#123;</span><br><span class="line">			<span class="comment">// 如果没有可用的SendPort,就新建SendPort用于远程服务通信</span></span><br><span class="line">      <span class="keyword">final</span> SendPort port = **_newServicePort()**;</span><br><span class="line">      _ports.add(port);</span><br><span class="line">      _freePorts.add(port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_freePorts.isEmpty) &#123;</span><br><span class="line">      <span class="comment">// 有空闲SendPort，使用</span></span><br><span class="line">      <span class="keyword">final</span> SendPort port = _freePorts.removeLast();</span><br><span class="line">      <span class="keyword">assert</span>(!_usedPorts.containsKey(forRequestId));</span><br><span class="line">      _usedPorts[forRequestId] = port;</span><br><span class="line">      <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We have already allocated the max number of ports. Re-use an</span></span><br><span class="line">    <span class="comment">// existing one.</span></span><br><span class="line">    <span class="keyword">final</span> SendPort port = _ports[forRequestId % maxPorts];</span><br><span class="line">    _usedPorts[forRequestId] = port;</span><br><span class="line">    <span class="keyword">return</span> port;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放掉占用的port</span></span><br><span class="line">  <span class="keyword">void</span> _returnPort(<span class="built_in">int</span> forRequestId) &#123;</span><br><span class="line">    <span class="keyword">final</span> SendPort port = _usedPorts.remove(forRequestId)!;</span><br><span class="line">    <span class="keyword">if</span> (!_usedPorts.values.contains(port)) &#123;</span><br><span class="line">      _freePorts.add(port);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;IOService_NewServicePort&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> SendPort _newServicePort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里最后的关键方法是<code>SendPort _newServicePort()</code>，这是一个<code>external</code>方法，在native实现。</p>
<h2 id="Native处理Dart的指令"><a href="#Native处理Dart的指令" class="headerlink" title="Native处理Dart的指令"></a>Native处理Dart的指令</h2><h3 id="IOService-NewServicePort"><a href="#IOService-NewServicePort" class="headerlink" title="IOService_NewServicePort"></a>IOService_NewServicePort</h3><p><code>SendPort</code>是由<code>_newServicePort()</code>方法创建的，这是一个<code>external</code>方法，他的native层实现名称是<code>IOService_NewServicePort</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\io_service.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FUNCTION_NAME(IOService_NewServicePort)(Dart_NativeArguments args) &#123;</span><br><span class="line">  Dart_SetReturnValue(args, Dart_Null());</span><br><span class="line">	<span class="comment">// 创建一个新的native port</span></span><br><span class="line">  Dart_Port service_port = **IOService::GetServicePort();**</span><br><span class="line">  <span class="keyword">if</span> (service_port != ILLEGAL_PORT) &#123;</span><br><span class="line">		<span class="comment">// 【注意】这里根据service_port创建了Dart里面的SendPort对象</span></span><br><span class="line">    <span class="comment">// Return a send port for the service port.</span></span><br><span class="line">    Dart_Handle send_port = Dart_NewSendPort(service_port);</span><br><span class="line">		<span class="comment">// 将当前IOService对应的send_port返回给调用方</span></span><br><span class="line">    Dart_SetReturnValue(args, send_port);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dart_Port IOService::GetServicePort() &#123;</span><br><span class="line">  <span class="comment">// 注意这里的参数</span></span><br><span class="line">  <span class="comment">// 分别是 native port的名称，收到native port以后得回调方法，是否同时处理</span></span><br><span class="line">  <span class="keyword">return</span> **Dart_NewNativePort(<span class="string">&quot;IOService&quot;</span>, IOServiceCallback, <span class="keyword">true</span>);**</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\include\dart_api.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*</span></span></span> Returns a new <span class="language-markdown"><span class="strong"><span class="emphasis">SendPort</span></span></span> with the provided <span class="language-markdown"><span class="strong"><span class="emphasis">port id.</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span></span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* \param port_id The destination port.</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span></span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">* \return A new SendPort if no</span></span></span> errors occurs. Otherwise <span class="language-markdown"><span class="strong"><span class="emphasis">returns</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="language-markdown"><span class="comment"> *</span>   an error handle.</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span></span><br><span class="line">DART_EXPORT Dart_Handle Dart_NewSendPort(Dart_Port port_id);</span><br></pre></td></tr></table></figure>

<p>注意，在Dart层的<code>_IOService</code>的<code>SendPort _newServicePort()</code> 方法最后再这里调用了<code>IOService_NewServicePort</code>。</p>
<p>这里主要有3个步骤：</p>
<ol>
<li>使用<code>Dart_NewNativePort(&quot;IOService&quot;, IOServiceCallback, true);</code>创建<code>Dart_Port</code></li>
<li>使用<code>Dart_NewSendPort</code>将<code>Dart_Port</code>转化为<code>Dart_Handle</code>（也就是Dart中的<code>SendPort</code>）</li>
<li>返回上面创建好的<code>Dart_Handle</code>，Dart代码拿到返回的Dart_Handle也就是<code>SendPort servicePort</code>之后，就可以和native层的IO Service同通信。</li>
</ol>
<p>接下来我们看一下前2步分别是怎么实现的：</p>
<h3 id="Dart-NewNativePort"><a href="#Dart-NewNativePort" class="headerlink" title="Dart_NewNativePort"></a>Dart_NewNativePort</h3><p>再看一下<code>Dart_NewNativePort</code>的调用参数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Dart</span>_NewNativePort(<span class="string">&quot;IOService&quot;</span>, <span class="title class_">IOServiceCallback</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\include\dart_native_api.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Creates a new native port.  When messages are received on this</span></span><br><span class="line"><span class="comment">//  native port, then they will be dispatched to the provided native</span></span><br><span class="line"><span class="comment">//  message handler.</span></span><br><span class="line"><span class="variable constant_">DART_EXPORT</span> <span class="title class_">Dart</span>_Port <span class="title class_">Dart</span>_NewNativePort(<span class="keyword">const</span> char* name,</span><br><span class="line">                                         <span class="title class_">Dart</span>_NativeMessageHandler handler,</span><br><span class="line">                                         bool handle_concurrently);</span><br></pre></td></tr></table></figure>

<p><strong>IOServiceCallback</strong></p>
<p><code>Dart_NewNativePort</code>总共有3个参数，<code>Dart_NativeMessageHandler handler</code>是当这个<code>Dart_Port</code>收到消息的时候，会被回调的方法，也就是我们通过Dart端的<code>_IOService.dispatch</code>方法的**<code>servicePort**.send(&lt;dynamic&gt;[id, **_replyToPort**, request, data]);</code>语句执行向native发送IO指令时，在native这里真正负责执行的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\io_service.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> IOServiceCallback(Dart_Port dest_port_id, Dart_CObject* message) &#123;</span><br><span class="line">  Dart_Port reply_port_id = ILLEGAL_PORT;</span><br><span class="line">  CObject* response = CObject::IllegalArgumentError();</span><br><span class="line">  CObjectArray request(message);</span><br><span class="line">	<span class="comment">// 这里的参数顺序，与Dart层的_IOService(sdk\lib\_internal\vm\bin\io_service_patch.dart)的_dispatch()中的</span></span><br><span class="line">	<span class="comment">// **servicePort**.send(&lt;dynamic&gt;[id, **_replyToPort**, request, data]);</span></span><br><span class="line">	<span class="comment">// 代码中的参数顺序一致</span></span><br><span class="line">  <span class="keyword">if</span> ((message-&gt;type == Dart_CObject_kArray) &amp;&amp; (request.Length() == <span class="number">4</span>) &amp;&amp;</span><br><span class="line">      request[<span class="number">0</span>]-&gt;IsInt32() &amp;&amp; request[<span class="number">1</span>]-&gt;IsSendPort() &amp;&amp;</span><br><span class="line">      request[<span class="number">2</span>]-&gt;IsInt32() &amp;&amp; request[<span class="number">3</span>]-&gt;IsArray()) &#123;</span><br><span class="line">    CObjectInt32 message_id(request[<span class="number">0</span>]);</span><br><span class="line">    CObjectSendPort **reply_port**(request[<span class="number">1</span>]);</span><br><span class="line">    CObjectInt32 request_id(request[<span class="number">2</span>]);</span><br><span class="line">    CObjectArray data(request[<span class="number">3</span>]);</span><br><span class="line">    **reply_port_id** = **reply_port**.Value();</span><br><span class="line">    <span class="comment">// 这里解析完收到的参数后，回去执行对应的文件操作</span></span><br><span class="line">    <span class="keyword">switch</span> (request_id.Value()) &#123;</span><br><span class="line">      **IO_SERVICE_REQUEST_LIST(CASE_REQUEST);**</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        UNREACHABLE();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CObjectArray result(CObject::NewArray(<span class="number">2</span>));</span><br><span class="line">  result.SetAt(<span class="number">0</span>, request[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">// response在上面的IO_SERVICE_REQUEST_LIST执行完毕后就会被赋值</span></span><br><span class="line">  result.SetAt(<span class="number">1</span>, **response**);</span><br><span class="line">  ASSERT(reply_port_id != ILLEGAL_PORT);</span><br><span class="line">  **Dart_PostCObject(reply_port_id, result.AsApiCObject());**</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define **CASE_REQUEST**(type, method, id)                                         \</span><br><span class="line">  <span class="keyword">case</span> IOService::k##type##method##Request:                                    \</span><br><span class="line">    response = type::method##Request(data);                                    \</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IOService具体的执行是在<code>IO_SERVICE_REQUEST_LIST</code>根据解析到的参数执行对应的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\io_service.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This list must be kept in sync with the list in sdk/lib/io/io_service.dart</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IO_SERVICE_REQUEST_LIST(V)                                             \</span></span><br><span class="line"><span class="meta">  V(File, Exists, 0)                                                           \</span></span><br><span class="line"><span class="meta">  V(File, Create, 1)                                                           \</span></span><br><span class="line"><span class="meta">  V(File, Delete, 2)                                                           \</span></span><br><span class="line"><span class="meta">  V(File, Rename, 3)                                                           \</span></span><br><span class="line"><span class="meta">  V(File, Copy, 4)                                                             \</span></span><br><span class="line"><span class="meta">  V(File, Open, 5)                                                             \</span></span><br><span class="line"><span class="meta">  V(File, ResolveSymbolicLinks, 6)                                             \</span></span><br><span class="line"><span class="meta">  V(File, Close, 7)                                                            \</span></span><br><span class="line"><span class="meta">  V(File, Position, 8)                                                         \</span></span><br><span class="line"><span class="meta">  V(File, SetPosition, 9)                                                      \</span></span><br><span class="line"><span class="meta">  V(File, Truncate, 10)                                                        \</span></span><br><span class="line"><span class="meta">  V(File, Length, 11)                                                          \</span></span><br><span class="line"><span class="meta">  V(File, LengthFromPath, 12)                                                  \</span></span><br><span class="line"><span class="meta">  V(File, LastAccessed, 13)                                                    \</span></span><br><span class="line"><span class="meta">  V(File, SetLastAccessed, 14)                                                 \</span></span><br><span class="line"><span class="meta">  V(File, LastModified, 15)                                                    \</span></span><br><span class="line"><span class="meta">  V(File, SetLastModified, 16)                                                 \</span></span><br><span class="line"><span class="meta">  V(File, Flush, 17)                                                           \</span></span><br><span class="line"><span class="meta">  V(File, ReadByte, 18)                                                        \</span></span><br><span class="line"><span class="meta">  V(File, WriteByte, 19)                                                       \</span></span><br><span class="line"><span class="meta">  V(File, Read, 20)                                                            \</span></span><br><span class="line"><span class="meta">  V(File, ReadInto, 21)                                                        \</span></span><br><span class="line"><span class="meta">  V(File, WriteFrom, 22)                                                       \</span></span><br><span class="line"><span class="meta">  V(File, CreateLink, 23)                                                      \</span></span><br><span class="line"><span class="meta">  V(File, DeleteLink, 24)                                                      \</span></span><br><span class="line"><span class="meta">  V(File, RenameLink, 25)                                                      \</span></span><br><span class="line"><span class="meta">  V(File, LinkTarget, 26)                                                      \</span></span><br><span class="line"><span class="meta">  V(File, Type, 27)                                                            \</span></span><br><span class="line"><span class="meta">  V(File, Identical, 28)                                                       \</span></span><br><span class="line"><span class="meta">  V(File, Stat, 29)                                                            \</span></span><br><span class="line"><span class="meta">  V(File, Lock, 30)                                                            \</span></span><br><span class="line"><span class="meta">  V(Socket, Lookup, 31)                                                        \</span></span><br><span class="line"><span class="meta">  V(Socket, ListInterfaces, 32)                                                \</span></span><br><span class="line"><span class="meta">  V(Socket, ReverseLookup, 33)                                                 \</span></span><br><span class="line"><span class="meta">  V(Directory, Create, 34)                                                     \</span></span><br><span class="line"><span class="meta">  V(Directory, Delete, 35)                                                     \</span></span><br><span class="line"><span class="meta">  V(Directory, Exists, 36)                                                     \</span></span><br><span class="line"><span class="meta">  V(Directory, CreateTemp, 37)                                                 \</span></span><br><span class="line"><span class="meta">  V(Directory, ListStart, 38)                                                  \</span></span><br><span class="line"><span class="meta">  V(Directory, ListNext, 39)                                                   \</span></span><br><span class="line"><span class="meta">  V(Directory, ListStop, 40)                                                   \</span></span><br><span class="line"><span class="meta">  V(Directory, Rename, 41)                                                     \</span></span><br><span class="line"><span class="meta">  V(SSLFilter, ProcessFilter, 42)</span></span><br></pre></td></tr></table></figure>

<p>通过上述代码，可以得知，IOService主要处理的方法有四类：</p>
<ul>
<li><code>File</code></li>
<li><code>Directory</code></li>
<li><code>Socket</code></li>
<li><code>SSLFilter</code></li>
</ul>
<p>在<code>IOServiceCallback</code>方法中，我们注意到，程序最后执行的结果是通过<code>Dart_PostCObject</code>返回的，来看一下他是怎么实现的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\native_api_impl.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> PostCObjectHelper(Dart_Port port_id, Dart_CObject* message) &#123;</span><br><span class="line">  AllocOnlyStackZone zone;</span><br><span class="line">  std::unique_ptr&lt;Message&gt; msg = WriteApiMessage(</span><br><span class="line">      zone.GetZone(), message, port_id, Message::kNormalPriority);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (msg == nullptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post the message at the given port.</span></span><br><span class="line">  <span class="keyword">return</span> **PortMap::PostMessage(std::move(msg));**</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DART_EXPORT <span class="built_in">bool</span> Dart_PostCObject(Dart_Port port_id, Dart_CObject* message) &#123;</span><br><span class="line">  <span class="keyword">return</span> PostCObjectHelper(port_id, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\port.cc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> PortMap::PostMessage(std::unique_ptr&lt;Message&gt; message,</span><br><span class="line">                          <span class="built_in">bool</span> before_events) &#123;</span><br><span class="line">  MutexLocker ml(mutex_);</span><br><span class="line">  <span class="keyword">if</span> (ports_ == nullptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  auto it = ports_-&gt;TryLookup(message-&gt;dest_port());</span><br><span class="line">  <span class="keyword">if</span> (it == ports_-&gt;end()) &#123;</span><br><span class="line">    <span class="comment">// Ownership of external data remains with the poster.</span></span><br><span class="line">    message-&gt;DropFinalizers();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  MessageHandler* handler = (*it).handler;</span><br><span class="line">  ASSERT(handler != nullptr);</span><br><span class="line">  **handler-&gt;PostMessage(std::move(message), before_events);**</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\message_handler.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageHandler::PostMessage(std::unique_ptr&lt;Message&gt; message,</span><br><span class="line">                                 <span class="built_in">bool</span> before_events) &#123;</span><br><span class="line">  Message::Priority saved_priority;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MonitorLocker ml(&amp;monitor_);</span><br><span class="line">    <span class="keyword">if</span> (FLAG_trace_isolates) &#123;</span><br><span class="line">      Isolate* source_isolate = Isolate::Current();</span><br><span class="line">      <span class="keyword">if</span> (source_isolate != nullptr) &#123;</span><br><span class="line">        OS::PrintErr(</span><br><span class="line">            <span class="string">&quot;[&gt;] Posting message:\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\tlen:        %&quot;</span> Pd <span class="string">&quot;\n\tsource:     (%&quot;</span> Pd64</span><br><span class="line">            <span class="string">&quot;) %s\n\tdest:       %s\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\tdest_port:  %&quot;</span> Pd64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">            message-&gt;Size(), static_cast&lt;int64_t&gt;(source_isolate-&gt;main_port()),</span><br><span class="line">            source_isolate-&gt;name(), name(), message-&gt;dest_port());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        OS::PrintErr(</span><br><span class="line">            <span class="string">&quot;[&gt;] Posting message:\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\tlen:        %&quot;</span> Pd</span><br><span class="line">            <span class="string">&quot;\n\tsource:     &lt;native code&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\tdest:       %s\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\tdest_port:  %&quot;</span> Pd64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">            message-&gt;Size(), name(), message-&gt;dest_port());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saved_priority = message-&gt;priority();</span><br><span class="line">		<span class="comment">// **将Message加入到MessageQueue中**</span></span><br><span class="line">    <span class="keyword">if</span> (message-&gt;IsOOB()) &#123;</span><br><span class="line">      oob_queue_-&gt;Enqueue(std::move(message), before_events);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queue_-&gt;Enqueue(std::move(message), before_events);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (paused_for_messages_) &#123;</span><br><span class="line">      ml.Notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool_ != nullptr &amp;&amp; !task_running_) &#123;</span><br><span class="line">      ASSERT(!delete_me_);</span><br><span class="line">      task_running_ = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">bool</span> launched_successfully = pool_-&gt;Run&lt;MessageHandlerTask&gt;(<span class="keyword">this</span>);</span><br><span class="line">      ASSERT(launched_successfully);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke any custom message notification.</span></span><br><span class="line">  MessageNotify(saved_priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码最后将结果包装成了Message打包进<code>MessageHandler</code>的<strong>消息队列</strong>中，这样便可以在Dart端通过消息分发接收到结果。</p>
<p><strong>Dart_NewNativePort</strong></p>
<p>再来看一下<code>Dart_NewNativePort</code>的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\native_api_impl.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">DART_EXPORT Dart_Port <span class="title">Dart_NewNativePort</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Dart_NativeMessageHandler handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> handle_concurrently)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    name = <span class="string">&quot;&lt;UnnamedNativePort&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (handler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    OS::<span class="built_in">PrintErr</span>(<span class="string">&quot;%s expects argument &#x27;handler&#x27; to be non-null.\n&quot;</span>,</span><br><span class="line">                 CURRENT_FUNC);</span><br><span class="line">    <span class="keyword">return</span> ILLEGAL_PORT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此方法位于sdk/runtime/vm/dart.cc</span></span><br><span class="line">  <span class="comment">// Used to Indicate that a Dart API call is active.</span></span><br><span class="line">  <span class="keyword">if</span> (!Dart::<span class="built_in">SetActiveApiCall</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> ILLEGAL_PORT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 【注意，这里切换了isolate，退出当前isolate,直到Dart_NewNativePort执行完毕再切换回当前isolate】</span></span><br><span class="line">  <span class="comment">// Start the native port without a current isolate.</span></span><br><span class="line">  <span class="comment">//  这里的实现可以参考https://github.com/dart-lang/sdk/blob/d437877c500c77d6e08372ba2dbda9c598f5bd8e/runtime/vm/dart_api_impl.cc</span></span><br><span class="line">**<span class="function">IsolateLeaveScope <span class="title">saver</span><span class="params">(Isolate::Current())</span></span>;**</span><br><span class="line"><span class="comment">// 执行完IsolateLeaveScope 后，会切换出当前isolate直到下面的 return port_id;执行完毕，但是在此期间，下面的代码依旧是在当前isolate所在的IOThread也即系统线程下进行的</span></span><br><span class="line"></span><br><span class="line">  NativeMessageHandler* nmh = **<span class="keyword">new</span> <span class="built_in">NativeMessageHandler</span>(name, handler);**</span><br><span class="line">	<span class="comment">// 创建一个Dart_Port并且添加到PortMap中</span></span><br><span class="line">  Dart_Port port_id = **PortMap::<span class="built_in">CreatePort</span>(nmh);**</span><br><span class="line">  <span class="keyword">if</span> (port_id != ILLEGAL_PORT) &#123;</span><br><span class="line">		<span class="comment">// 激活这个端口</span></span><br><span class="line">    PortMap::<span class="built_in">SetPortState</span>(port_id, PortMap::kLivePort);</span><br><span class="line">		<span class="comment">// 在Dart线程池中执行，在这里Run()中的代码会在一个新的线程中执行</span></span><br><span class="line">    <span class="keyword">if</span> (!**nmh-&gt;Run**(**Dart::<span class="built_in">thread_pool</span>()**, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">// 执行完毕之后，在之前调用本方法的环境，回调handler，关闭Dart_Port</span></span><br><span class="line">      PortMap::<span class="built_in">ClosePort</span>(port_id);</span><br><span class="line">      port_id = ILLEGAL_PORT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Dart::<span class="built_in">ResetActiveApiCall</span>();</span><br><span class="line">  <span class="keyword">return</span> port_id;</span><br><span class="line">  <span class="comment">// 上面IsolateLeaveScope saver对象在构造方法中退出了调用方法的分支，执行到这里后saver对象被回收，执行析构函数，又将Isolate切换回来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的流程有：</p>
<ol>
<li>切换退出当前isolate</li>
<li>创建<code>NativeMessageHandler nmh</code>包裹要处理的回调</li>
<li>根据上面创建的<code>nmh</code>创建<code>Dart_Port port_id</code></li>
<li>执行**<code>nmh-&gt;Run()</code>**方法将<code>nmh</code>放到线程池中运行</li>
<li>当<code>nmh</code>执行完毕回调后，关闭<code>Dart_Port port_id</code></li>
</ol>
<p>也就是说，在Dart中向Native发送指令时，通过Dart的<code>_IOService._dispatch()</code>方法中执行<code>_servicePorts._getPort(id);</code>向Native层的IOService获取用于通信的<code>SendPort servicePort</code>时，会先通过Dart_NewNativePort创建一个<strong>NativeMessageHandler</strong>（会压入消息栈中），然后创建一个对应的<code>Dart_Port port_id</code>并返回给Dart用来触发消息。</p>
<p>让我们挨个分析一下：</p>
<p>1.退出当前isolate</p>
<p>见 <a href="https://www.notion.so/IsolateLeaveScope-d62547a99c6d464bbd1bbf5baa45de18">IsolateLeaveScope</a></p>
<p>2.创建<code>NativeMessageHandler nmh</code>包裹要处理的回调</p>
<p>3.根据上面创建的<code>nmh</code>创建<code>Dart_Port port_id</code></p>
<p>看一下<code>PortMap::CreatePort</code>的实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\port.cc</span></span><br><span class="line"></span><br><span class="line">Dart_Port PortMap::CreatePort(MessageHandler* handler) &#123;</span><br><span class="line">  ASSERT(handler != NULL);</span><br><span class="line">  MutexLocker ml(mutex_);</span><br><span class="line">  <span class="keyword">if</span> (ports_ == nullptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> ILLEGAL_PORT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(DEBUG)</span><br><span class="line">  handler-&gt;CheckAccess();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不停的遍历，直到找到一个可用的port（类型为int64_t）</span></span><br><span class="line">  <span class="keyword">const</span> Dart_Port port = AllocatePort();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取到的port 只能通过isolate_entry访问</span></span><br><span class="line">  <span class="comment">// The MessageHandler::ports_ is only accessed by [PortMap], it is guarded</span></span><br><span class="line">  <span class="comment">// by the [PortMap::mutex_] we already hold.</span></span><br><span class="line">  MessageHandler::PortSetEntry isolate_entry;</span><br><span class="line">  isolate_entry.port = port;</span><br><span class="line">  handler-&gt;ports_.Insert(isolate_entry);</span><br><span class="line"></span><br><span class="line">  Entry entry;</span><br><span class="line">  entry.port = port;</span><br><span class="line">  entry.handler = handler;</span><br><span class="line">  entry.state = kNewPort;</span><br><span class="line">  ports_-&gt;Insert(entry);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_trace_isolates) &#123;</span><br><span class="line">    OS::PrintErr(</span><br><span class="line">        <span class="string">&quot;[+] Opening port: \n&quot;</span></span><br><span class="line">        <span class="string">&quot;\thandler:    %s\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\tport:       %&quot;</span> Pd64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">        handler-&gt;name(), entry.port);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entry.port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dart_Port PortMap::AllocatePort() &#123;</span><br><span class="line">  Dart_Port result;</span><br><span class="line"></span><br><span class="line">  ASSERT(mutex_-&gt;IsOwnedByCurrentThread());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep getting new values while we have an illegal port number or the port</span></span><br><span class="line">  <span class="comment">// number is already in use.</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Ensure port ids are representable in JavaScript for the benefit of</span></span><br><span class="line">    <span class="comment">// vm-service clients such as Observatory.</span></span><br><span class="line">    <span class="keyword">const</span> Dart_Port kMask1 = <span class="number">0xFFFFFFFFFFFFF</span>;</span><br><span class="line">    <span class="comment">// Ensure port ids are never valid object pointers so that reinterpreting</span></span><br><span class="line">    <span class="comment">// an object pointer as a port id never produces a used port id.</span></span><br><span class="line">    <span class="keyword">const</span> Dart_Port kMask2 = <span class="number">0x3</span>;</span><br><span class="line">    result = (prng_-&gt;NextUInt64() &amp; kMask1) | kMask2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The two special marker ports are used for the hashset implementation and</span></span><br><span class="line">    <span class="comment">// cannot be used as actual ports.</span></span><br><span class="line">    <span class="keyword">if</span> (result == PortSet&lt;Entry&gt;::kFreePort ||</span><br><span class="line">        result == PortSet&lt;Entry&gt;::kDeletedPort) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(!static_cast&lt;ObjectPtr&gt;(static_cast&lt;uword&gt;(result))-&gt;IsWellFormed());</span><br><span class="line">  &#125; <span class="keyword">while</span> (ports_-&gt;Contains(result));</span><br><span class="line"></span><br><span class="line">  ASSERT(result != <span class="number">0</span>);</span><br><span class="line">  ASSERT(!ports_-&gt;Contains(result));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.执行**<code>nmh-&gt;Run()</code>**方法将<code>nmh</code>放到线程池中运行</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\message_handler.cc</span></span><br><span class="line">ThreadPool* pool_;</span><br><span class="line"><span class="built_in">bool</span> MessageHandler::Run(ThreadPool* pool,</span><br><span class="line">                         StartCallback start_callback,</span><br><span class="line">                         EndCallback end_callback,</span><br><span class="line">                         CallbackData data) &#123;</span><br><span class="line">  MonitorLocker ml(&amp;monitor_);</span><br><span class="line">  <span class="keyword">if</span> (FLAG_trace_isolates) &#123;</span><br><span class="line">    OS::PrintErr(</span><br><span class="line">        <span class="string">&quot;[+] Starting message handler:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\thandler:    %s\n&quot;</span>,</span><br><span class="line">        name());</span><br><span class="line">  &#125;</span><br><span class="line">  ASSERT(pool_ == NULL);</span><br><span class="line">  ASSERT(!delete_me_);</span><br><span class="line">  pool_ = pool;</span><br><span class="line">  start_callback_ = start_callback;</span><br><span class="line">  end_callback_ = end_callback;</span><br><span class="line">  callback_data_ = data;</span><br><span class="line">  task_running_ = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// 在Dart VM Thread的线程池中执行MessageHandler,会是一个新的线程</span></span><br><span class="line">  <span class="built_in">bool</span> result = pool_-&gt;Run&lt;MessageHandlerTask&gt;(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    pool_ = nullptr;</span><br><span class="line">    start_callback_ = nullptr;</span><br><span class="line">    end_callback_ = nullptr;</span><br><span class="line">    callback_data_ = <span class="number">0</span>;</span><br><span class="line">    task_running_ = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会在“线程池”运行的时候执行对应的MessageHandler回调</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageHandlerTask</span> : <span class="title">public</span> <span class="title">ThreadPool</span>::<span class="title">Task</span> </span>&#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit MessageHandlerTask(MessageHandler* handler) : handler_(handler) &#123;</span><br><span class="line">    ASSERT(handler != NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="keyword">void</span> Run() &#123;</span><br><span class="line">    ASSERT(handler_ != NULL);</span><br><span class="line">		<span class="comment">// 执行具体的逻辑</span></span><br><span class="line">    handler_-&gt;TaskCallback();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  MessageHandler* handler_;</span><br><span class="line"></span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(MessageHandlerTask);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\include\dart_api.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A port is used to send or receive inter-isolate messages</span></span><br><span class="line"><span class="keyword">typedef</span> int64_t Dart_Port;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\thread_pool.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Runs a task on the thread pool.</span></span><br><span class="line">  template &lt;typename T, typename... Args&gt;</span><br><span class="line">  <span class="built_in">bool</span> Run(Args&amp;&amp;... args) &#123;</span><br><span class="line">    <span class="keyword">return</span> RunImpl(std::unique_ptr&lt;Task&gt;(<span class="keyword">new</span> T(std::forward&lt;Args&gt;(args)...)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\thread_pool.cc</span></span><br><span class="line"><span class="built_in">bool</span> ThreadPool::RunImpl(std::unique_ptr&lt;Task&gt; task) &#123;</span><br><span class="line">  Worker* new_worker = nullptr;</span><br><span class="line">  &#123;</span><br><span class="line">    MonitorLocker ml(&amp;pool_monitor_);</span><br><span class="line">    <span class="keyword">if</span> (shutting_down_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 创建新的Worker</span></span><br><span class="line">    new_worker = ScheduleTaskLocked(&amp;ml, std::move(task));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (new_worker != nullptr) &#123;</span><br><span class="line">		<span class="comment">// 在线程中执行task</span></span><br><span class="line">    new_worker-&gt;StartThread();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\thread_pool.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Worker</span></span><br><span class="line">ThreadPool::Worker* ThreadPool::ScheduleTaskLocked(MonitorLocker* ml,</span><br><span class="line">                                                   std::unique_ptr&lt;Task&gt; task) &#123;</span><br><span class="line">  <span class="comment">// Enqueue the new task.</span></span><br><span class="line">  tasks_.Append(task.release());</span><br><span class="line">  pending_tasks_++;</span><br><span class="line">  ASSERT(pending_tasks_ &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify existing idle worker (if available).</span></span><br><span class="line">  <span class="keyword">if</span> (count_idle_ &gt;= pending_tasks_) &#123;</span><br><span class="line">    ASSERT(!idle_workers_.IsEmpty());</span><br><span class="line">    ml-&gt;Notify();</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have maxed out the number of threads running, we will not start a</span></span><br><span class="line">  <span class="comment">// new one.</span></span><br><span class="line">  <span class="keyword">if</span> (max_pool_size_ &gt; <span class="number">0</span> &amp;&amp; (count_idle_ + count_running_) &gt;= max_pool_size_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!idle_workers_.IsEmpty()) &#123;</span><br><span class="line">      ml-&gt;Notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise start a new worker.</span></span><br><span class="line">  auto new_worker = <span class="keyword">new</span> Worker(<span class="keyword">this</span>);</span><br><span class="line">  idle_workers_.Append(new_worker);</span><br><span class="line">  count_idle_++;</span><br><span class="line">  <span class="keyword">return</span> new_worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建的Woker和ThreadPool绑定</span></span><br><span class="line">ThreadPool::Worker::Worker(ThreadPool* pool)</span><br><span class="line">    : pool_(pool), join_id_(OSThread::kInvalidThreadJoinId) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new_worker-&gt;StartThread();会调用下面的方法</span></span><br><span class="line"><span class="keyword">void</span> ThreadPool::Worker::StartThread() &#123;</span><br><span class="line">  <span class="built_in">int</span> result = OSThread::Start(<span class="string">&quot;DartWorker&quot;</span>, &amp;Worker::Main,</span><br><span class="line">                               reinterpret_cast&lt;uword&gt;(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    FATAL1(<span class="string">&quot;Could not start worker thread: result = %d.&quot;</span>, result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSThread::Start每个端不一样，我们选择Android端的实现</span></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\os_thread_android.cc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> OSThread::Start(<span class="keyword">const</span> char* name,</span><br><span class="line">                    ThreadStartFunction function,</span><br><span class="line">                    uword parameter) &#123;</span><br><span class="line">  pthread_attr_t attr;</span><br><span class="line">  <span class="built_in">int</span> result = pthread_attr_init(&amp;attr);</span><br><span class="line">  RETURN_ON_PTHREAD_FAILURE(result);</span><br><span class="line"></span><br><span class="line">  result = pthread_attr_setstacksize(&amp;attr, OSThread::GetMaxStackSize());</span><br><span class="line">  RETURN_ON_PTHREAD_FAILURE(result);</span><br><span class="line"></span><br><span class="line">  ThreadStartData* data = <span class="keyword">new</span> ThreadStartData(name, function, parameter);</span><br><span class="line">	<span class="comment">// 声明系统线程类型</span></span><br><span class="line">  pthread_t tid;</span><br><span class="line">	<span class="comment">// 调用系统创建线程的函数 https://blog.csdn.net/liangxanhai/article/details/7767430</span></span><br><span class="line">	<span class="comment">// pthread_create参数含义：1. &amp;tid 指向线程的指针，2. &amp;attr 新建线程的属性 3. ThreadStart线程要执行的方法指针 4. data传给参数ThreadStart的参数</span></span><br><span class="line">  <span class="comment">// 成功执行线程则返回0</span></span><br><span class="line">  result = pthread_create(&amp;tid, &amp;attr, ThreadStart, data);</span><br><span class="line">  RETURN_ON_PTHREAD_FAILURE(result);</span><br><span class="line"></span><br><span class="line">  result = pthread_attr_destroy(&amp;attr);</span><br><span class="line">  RETURN_ON_PTHREAD_FAILURE(result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch to the thread start function provided by the caller. This trampoline</span></span><br><span class="line"><span class="comment">// is used to ensure that the thread is properly destroyed if the thread just</span></span><br><span class="line"><span class="comment">// exits.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* ThreadStart(<span class="keyword">void</span>* data_ptr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_worker_thread_priority != kMinInt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (setpriority(PRIO_PROCESS, gettid(), FLAG_worker_thread_priority) ==</span><br><span class="line">        <span class="number">-1</span>) &#123;</span><br><span class="line">      FATAL2(<span class="string">&quot;Setting thread priority to %d failed: errno = %d\n&quot;</span>,</span><br><span class="line">             FLAG_worker_thread_priority, errno);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ThreadStartData* data = reinterpret_cast&lt;ThreadStartData*&gt;(data_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> char* name = data-&gt;name();</span><br><span class="line">  OSThread::ThreadStartFunction function = data-&gt;function();</span><br><span class="line">  uword parameter = data-&gt;parameter();</span><br><span class="line">  delete data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the thread name. There is 16 bytes limit on the name (including \0).</span></span><br><span class="line">  <span class="comment">// pthread_setname_np ignores names that are too long rather than truncating.</span></span><br><span class="line">  char truncated_name[<span class="number">16</span>];</span><br><span class="line">  snprintf(truncated_name, ARRAY_SIZE(truncated_name), <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">  pthread_setname_np(pthread_self(), truncated_name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个系统线程的包装类OSThread和新建的系统线程绑定</span></span><br><span class="line">  <span class="comment">// Create new OSThread object and set as TLS for new thread.</span></span><br><span class="line">  OSThread* thread = OSThread::CreateOSThread();</span><br><span class="line">  <span class="keyword">if</span> (thread != NULL) &#123;</span><br><span class="line">		<span class="comment">// 将线程切换到新创建的系统线程</span></span><br><span class="line">    OSThread::SetCurrent(thread);</span><br><span class="line">    thread-&gt;set_name(name);</span><br><span class="line">    UnblockSIGPROF();</span><br><span class="line">    <span class="comment">// Call the supplied thread start function handing it its parameters.</span></span><br><span class="line">		<span class="comment">// 执行创建ThreadStartData时传入的方法，也就是ThreadPool::Worker::Main(uword args)</span></span><br><span class="line">    function(parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">OSThread* OSThread::CreateOSThread() &#123;</span><br><span class="line">  ASSERT(thread_list_lock_ != NULL);</span><br><span class="line">  MutexLocker ml(thread_list_lock_);</span><br><span class="line">  <span class="keyword">if</span> (!creation_enabled_) &#123;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  OSThread* os_thread = <span class="keyword">new</span> OSThread();</span><br><span class="line">  AddThreadToListLocked(os_thread);</span><br><span class="line">  <span class="keyword">return</span> os_thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建了新的系统线程后，会执行下面的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\thread_pool.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ThreadPool::Worker::Main(uword args) &#123;</span><br><span class="line">  <span class="comment">// Call the thread start hook here to notify the embedder that the</span></span><br><span class="line">  <span class="comment">// thread pool thread has started.</span></span><br><span class="line">  Dart_ThreadStartCallback start_cb = Dart::thread_start_callback();</span><br><span class="line">  <span class="keyword">if</span> (start_cb != nullptr) &#123;</span><br><span class="line">    start_cb();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  OSThread* os_thread = OSThread::Current();</span><br><span class="line">  ASSERT(os_thread != nullptr);</span><br><span class="line"></span><br><span class="line">  Worker* worker = reinterpret_cast&lt;Worker*&gt;(args);</span><br><span class="line">  ThreadPool* pool = worker-&gt;pool_;</span><br><span class="line">	<span class="comment">// 将Worker和系统线程绑定</span></span><br><span class="line">  os_thread-&gt;owning_thread_pool_worker_ = worker;</span><br><span class="line">  worker-&gt;os_thread_ = os_thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the worker quits it needs to be joined.</span></span><br><span class="line">  worker-&gt;join_id_ = OSThread::GetCurrentThreadJoinId(os_thread);</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(DEBUG)</span><br><span class="line">  &#123;</span><br><span class="line">    MonitorLocker ml(&amp;pool-&gt;pool_monitor_);</span><br><span class="line">    ASSERT(pool-&gt;idle_workers_.ContainsForDebugging(worker));</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  pool-&gt;WorkerLoop(worker);</span><br><span class="line"></span><br><span class="line">  worker-&gt;os_thread_ = nullptr;</span><br><span class="line">  os_thread-&gt;owning_thread_pool_worker_ = nullptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the thread exit hook here to notify the embedder that the</span></span><br><span class="line">  <span class="comment">// thread pool thread is exiting.</span></span><br><span class="line">  Dart_ThreadExitCallback exit_cb = Dart::thread_exit_callback();</span><br><span class="line">  <span class="keyword">if</span> (exit_cb != nullptr) &#123;</span><br><span class="line">    exit_cb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\os_thread.h</span></span><br><span class="line"><span class="comment">// OSThread</span></span><br><span class="line"><span class="comment">// The ThreadPool::Worker which owns this OSThread. If this OSThread was not</span></span><br><span class="line">  <span class="comment">// started by a ThreadPool it will be nullptr. This TLS value is not</span></span><br><span class="line">  <span class="comment">// protected and should only be read/written by the OSThread itself.</span></span><br><span class="line">  <span class="keyword">void</span>* owning_thread_pool_worker_ = nullptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// thread_list_lock_ cannot have a static lifetime because the order in which</span></span><br><span class="line">  <span class="comment">// destructors run is undefined. At the moment this lock cannot be deleted</span></span><br><span class="line">  <span class="comment">// either since otherwise, if a thread only begins to run after we have</span></span><br><span class="line">  <span class="comment">// started to run TLS destructors for a call to exit(), there will be a race</span></span><br><span class="line">  <span class="comment">// on its deletion in CreateOSThread().</span></span><br><span class="line">  <span class="keyword">static</span> Mutex* thread_list_lock_;</span><br></pre></td></tr></table></figure>

<h3 id="Dart-NewSendPort"><a href="#Dart-NewSendPort" class="headerlink" title="Dart_NewSendPort"></a>Dart_NewSendPort</h3><p>看一下<code>Dart_NewSendPort</code>如何将创建好的<code>Dart_Port service_port</code>转变为Dart的<code>SendPort</code>的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\dart_api_impl.cc</span></span><br><span class="line"></span><br><span class="line">DART_EXPORT Dart_Handle Dart_NewSendPort(Dart_Port port_id) &#123;</span><br><span class="line">  DARTSCOPE(Thread::Current());</span><br><span class="line">  CHECK_CALLBACK_STATE(T);</span><br><span class="line">  <span class="keyword">if</span> (port_id == ILLEGAL_PORT) &#123;</span><br><span class="line">    <span class="keyword">return</span> Api::NewError(<span class="string">&quot;%s: illegal port_id %&quot;</span> Pd64 <span class="string">&quot;.&quot;</span>, CURRENT_FUNC,</span><br><span class="line">                         port_id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Api::NewHandle(T, SendPort::New(port_id));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\object.cc</span></span><br><span class="line"></span><br><span class="line">SendPortPtr SendPort::New(Dart_Port id, Heap::Space space) &#123;</span><br><span class="line">  <span class="keyword">return</span> New(id, Isolate::Current()-&gt;origin_id(), space);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SendPortPtr SendPort::New(Dart_Port id,</span><br><span class="line">                          Dart_Port origin_id,</span><br><span class="line">                          Heap::Space space) &#123;</span><br><span class="line">  ASSERT(id != ILLEGAL_PORT);</span><br><span class="line">	<span class="comment">// 创建新的SendPort并将Dart_Port id和当前的isolate id与之绑定</span></span><br><span class="line">  SendPort&amp; result = SendPort::Handle();</span><br><span class="line">  &#123;</span><br><span class="line">    ObjectPtr raw =</span><br><span class="line">        <span class="built_in">Object</span>::Allocate(SendPort::kClassId, SendPort::InstanceSize(), space,</span><br><span class="line">                         SendPort::ContainsCompressedPointers());</span><br><span class="line">    NoSafepointScope no_safepoint;</span><br><span class="line">    result ^= raw;</span><br><span class="line">    result.StoreNonPointer(&amp;result.untag()-&gt;id_, id);</span><br><span class="line">    result.StoreNonPointer(&amp;result.untag()-&gt;origin_id_, origin_id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.ptr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们发现，<code>Dart_NewNativePort</code>将要处理的事件<code>handler</code>封装起来，最后在<strong>非当前isolate</strong>的线程中执行。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>从上面的分析中，我们可以知道，在Dart中通过File进行文件操作，其实是通过Dart中的_IOService进行消息中转，将用户的IO指令发送到Native层的IOService中；</p>
<p>IOService通过一些列操作，得到一个<code>SendPort servicePort</code>，与此同时对应的IO操作已经压入消息栈中等待触发在单独的线程中执行；</p>
<p>之后在_IOService中<code>servicePort</code>将用户需要的IO操作和与自己通信的<code>_replyToPort = _receivePort!.sendPort;</code> 通过<code>send</code>方法触发<code>IOServiceCallback</code>执行对应的IO操作，并且在最后调用<code>Dart_PostCObject</code>方法将结果压入消息栈中，这会触发Dart层_IOService的_receivePort!.handler回调事件，然后根据事件失败或者成功，使用Completer通过Event loop一步步将事件上报，最终回调用户需要的命令。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/eieihihi/article/details/119601010">09、Flutter FFI Dart Native API_又吹风_Bassy的博客-CSDN博客</a></p>
<p><a href="http://w4lle.com/2021/04/12/kidea-flutter/index.html">快手-开眼快创 Flutter 实践 | w4lle’s Notes</a></p>
]]></content>
  </entry>
  <entry>
    <title>Flutter APP绘制过程简析</title>
    <url>/blog/posts/4cbcfe72/</url>
    <content><![CDATA[<blockquote>
<p>本文基于Flutter 3.0</p>
</blockquote>
<p>Flutter App基于Dart语言编写，提供了一套简单易用的API，可以让开发者在Flutter中快速开发出一个精美的APP。那么在Flutter中是如何绘制一个APP呢，runApp是怎么将我们编写的Widget等添加到手机上的呢？本文简单从Widget,Element,RenderObjet三者的关系来梳理一下Flutter的绘制过程。</p>
<p>让我们运行一个“最”简单的Flutter App，分析一下在这个过程中涉及到的Widget、Element、RenderObject这三个tree的关系。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  runApp(<span class="keyword">const</span> Center(</span><br><span class="line">    <span class="comment">// Center非必须，为了让文本居中显得更清晰</span></span><br><span class="line">    child: Text(</span><br><span class="line">      <span class="string">&quot;Hello center text!&quot;</span>,</span><br><span class="line">      textDirection: TextDirection.ltr, <span class="comment">// 文本方向</span></span><br><span class="line">    ),</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的效果如下：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_hello_center_text.png" alt="flutter_run_app_hello_center_text"></p>
<p>让我们使用Flutter DevTools看一下实际生成的Widget Details Tree</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root]</span><br><span class="line"> &gt;renderObject:RenderView#a00a5</span><br><span class="line"></span><br><span class="line"> Center</span><br><span class="line">  alignment:Alignment.center </span><br><span class="line">  widthFactor:null</span><br><span class="line">  heightFactor:null</span><br><span class="line">  &gt;renderObject:RenderPositionedBox#94e0d</span><br><span class="line"></span><br><span class="line">  Text</span><br><span class="line">   &quot;Hello center text!&quot;</span><br><span class="line">   textAlign:null</span><br><span class="line">   textDirection:ltr</span><br><span class="line">   locale:null </span><br><span class="line">   softWrap:null </span><br><span class="line">   overflow:null</span><br><span class="line">   textScaleFactor:null </span><br><span class="line">   maxLines:null </span><br><span class="line">   textWidthBasis:null </span><br><span class="line">   textHeightBehavior:null</span><br><span class="line">   </span><br><span class="line">   RichText</span><br><span class="line">    textDirection:ltr</span><br><span class="line">    softWrap:wrapping at box width </span><br><span class="line">    maxLines:unlimited</span><br><span class="line">    text:&quot;Hello center text!&quot;</span><br><span class="line">    renderObject:RenderParagraph#71aa1</span><br></pre></td></tr></table></figure>

<p>可以看到，除了我们在代码里面添加的Center和Text这两个Widget之外，还多出来好几个Widget&#x2F;RenderObject，当我们仔细查看具体的Widget，可以看到其内部还有XXXElement，BuildOwner之类的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Center</span><br><span class="line"> alignment:Alignment.center </span><br><span class="line"> widthFactor:null</span><br><span class="line"> heightFactor:null</span><br><span class="line"> renderObject:RenderPositionedBox#94e0d </span><br><span class="line"> &gt;_parent:RenderObjectToWidgetElement </span><br><span class="line"> _debugReassembleConfig:null</span><br><span class="line"> _notificationTree:null </span><br><span class="line"> &gt;_slot:Object</span><br><span class="line"> _depth:2 </span><br><span class="line"> &gt;_widget:Center </span><br><span class="line"> &gt;_owner:BuildOwner</span><br><span class="line"> &gt;_lifecycleState:_ElementLifecycle</span><br><span class="line"> &gt;_debugForgottenChildrenWithGlobalKey:_HashSet </span><br><span class="line"> _inheritedWidgets:null</span><br><span class="line"> _dependencies:null</span><br><span class="line"> _hadUnsatisfiedDependencies:true </span><br><span class="line"> _dirty:false</span><br><span class="line"> _inDirtyList:false</span><br><span class="line"> _debugBuiltOnce:false</span><br><span class="line"> _debugA1lowIgnoredCallsToMarkNeedsBuild:false </span><br><span class="line"> _debugDoingBuild:false</span><br><span class="line"> &gt;_ancestorRenderObjectElement:RenderObjectToWidgetElement </span><br><span class="line"> &gt;_child:StatelessElement</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述涉及到的几个类彼此之间到底是什么关系，我们的“<code>Hello center text!</code>”又是怎样才显示到屏幕上的，让我们接下来一个一个分析一下：</p>
<h1 id="runApp"><a href="#runApp" class="headerlink" title="runApp"></a>runApp</h1><p>在执行runApp的时候主要执行了三步</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; \lib\src\widgets\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">	<span class="comment">// 创建render tree的根节点RenderView</span></span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">		<span class="comment">// 将我们的app widget绑定到RenderView</span></span><br><span class="line">    ..scheduleAttachRootWidget(app)</span><br><span class="line">		<span class="comment">// 安排屏幕帧绘制</span></span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WidgetsFlutterBinding-ensureInitialized"><a href="#WidgetsFlutterBinding-ensureInitialized" class="headerlink" title="WidgetsFlutterBinding.ensureInitialized()"></a>WidgetsFlutterBinding.ensureInitialized()</h2><p>创建RenderView具体的逻辑在<code>WidgetsFlutterBinding.ensureInitialized</code>方法中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; \lib\src\widgets\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding._instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ensureInitialized</code>方法中，如果<code>WidgetsBinding._instance</code>为null则会先用构造方法创建，因为<code>WidgetsFlutterBinding</code>继承自BindingBase，所以实际上执行下方的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\foundation\binding.dart</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> </span>&#123;</span><br><span class="line">	BindingBase() &#123;</span><br><span class="line">    initInstances();</span><br><span class="line">    initServiceExtensions();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了2件事，我们关注<code>initInstances()</code>方法，这个方法的主要逻辑都在他的子类中，也就是之前<code>WidgetsFlutterBinding</code>混合的几个BindingBase子类中，我们关注和屏幕渲染有关的RendererBinding：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\rendering\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The glue between the render tree and the Flutter engine.</span></span></span><br><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 这里创建了PipelineOwner，用来管理rendering pipeline也就是我们app中所有的RenderObject</span></span><br><span class="line">    _pipelineOwner = PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    platformDispatcher</span><br><span class="line">      ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">    <span class="comment">// 注意这里创建了RenderView</span></span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    initMouseTracker();</span><br><span class="line">    <span class="keyword">if</span> (kIsWeb) &#123;</span><br><span class="line">      addPostFrameCallback(_handleWebFirstFrame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a [RenderView] object to be the root of the</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">[RenderObject] rendering tree, and initializes it so that it</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">will be rendered when the next frame is requested.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Called automatically when the binding is created.</span></span></span><br><span class="line">  <span class="keyword">void</span> initRenderView() &#123;</span><br><span class="line">    renderView = RenderView(configuration: createViewConfiguration(), <span class="built_in">window</span>: <span class="built_in">window</span>);</span><br><span class="line">    renderView.prepareInitialFrame();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">set</span> renderView(RenderView value) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(value != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 注意这里，将renderView设置为_pipeline的根节点</span></span><br><span class="line">    _pipelineOwner.rootNode = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要关注两件事：</p>
<ul>
<li><p>创建了用于管理渲染管道的PipelineOwner <code>_pipelineOwner</code></p>
<p>Pipeline是用来管理rendering tree，其内部持有我们的renderView作为rootNode，同时维护了_nodesNeedingLayout，_nodesNeedingCompositingBitsUpdate，_nodesNeedingPaint，_nodesNeedingSemantics四个列表，当flutter framework每次需要往屏幕上绘制内容时会依次遍历这四个列表，将RenderObject绘制到屏幕上面。</p>
</li>
<li><p>创建了rendering tree的根节点<code>renderView</code> ，并将其设置为<code>_pipelineOwner</code>的根节点</p>
</li>
</ul>
<h2 id="scheduleAttachRootWidget-app"><a href="#scheduleAttachRootWidget-app" class="headerlink" title="..scheduleAttachRootWidget(app)"></a>..scheduleAttachRootWidget(app)</h2><p>此方法是<code>WidgetsFlutterBinding</code>的另外一个混合类<code>WidgetsBinding</code>负责具体实现：</p>
<p><code>WidgetsBinding</code>的<code>scheduleAttachRootWidget</code> 方法最后调用了<code>attachRootWidget(Widget rootWidget)</code> ：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The glue between the widgets layer and the Flutter engine.</span></span></span><br><span class="line"><span class="keyword">mixin</span> WidgetsBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将rootWidget绑定到renderViewElement</span></span><br><span class="line"> <span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isBootstrapFrame = renderViewElement == <span class="keyword">null</span>;</span><br><span class="line">    _readyToProduceFrames = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 用于将rootWidget绑定到renderView上面</span></span><br><span class="line">    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">      child: rootWidget,</span><br><span class="line">    )</span><br><span class="line">   <span class="comment">// 在此创建或者使用已有的RenderObjectToWidgetElement，并作为根Element</span></span><br><span class="line">   <span class="comment">// 并将RenderObjectToWidgetAdapter和RenderView与之绑定</span></span><br><span class="line">   <span class="comment">// 这里的_buildOwner在WidgetsBinding.initInstances方法创建，用于管理widget框架的类</span></span><br><span class="line">   .attachToRenderTree(buildOwner!, renderViewElement <span class="keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);</span><br><span class="line">    <span class="keyword">if</span> (isBootstrapFrame) &#123;</span><br><span class="line">      <span class="comment">// 如果是启动框架，就安排更新帧</span></span><br><span class="line">      SchedulerBinding.instance.ensureVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有3步：</p>
<ul>
<li>创建RenderObjectToWidgetAdapter包装RenderView</li>
<li>在<code>attachToRenderTree</code>方法中创建RenderObjectToWidgetElement并<code>mount</code>到element tree中（widget tree实际上并不存在，而是通过element tree管理）</li>
<li>需要的话安排一次frame（刷新页面）</li>
</ul>
<p>还需要注意一个新的角色<code>buildOwner</code>，这个对象全局唯一（一般由parent传给child），在<code>WidgetsBinding.initInstances</code>方法创建，用来管理与Widget tree相关的类，实际上就是通过管理Element的插入，移除，更新来间接管理Widget tree（对应我们在之前遇到的用来管理rendering tree的<code>pipelineOwner</code> ，这两个Owner管理着我们所说的Flutter的Widget&#x2F;Element&#x2F;RenderObject“三”个tree）。</p>
<h3 id="RenderObjectToWidgetAdapter"><a href="#RenderObjectToWidgetAdapter" class="headerlink" title="RenderObjectToWidgetAdapter"></a>RenderObjectToWidgetAdapter</h3><p>前面我们知道<code>renderView</code>其实是一个RenderObject，所以这里为他创建了一个对应的Widget——<code>RenderObjectToWidgetAdapter</code>，其主要作用是将<code>rootWidget</code>（也就是我们最开始写的Center Widget及其child）绑定到之前生成的<code>renderView</code>上面，并将<code>renderView</code>作为自己对应的RenderObject。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a bridge from a [RenderObject] to an [Element] tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Used by [WidgetsBinding] to attach the root widget to the [RenderView].</span></span></span><br><span class="line">  RenderObjectToWidgetAdapter(&#123;</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.container,</span><br><span class="line">    <span class="keyword">this</span>.debugShortDescription,</span><br><span class="line">  &#125;) : </span><br><span class="line">   <span class="comment">// 注意这里用container也就是RenderView创建了一个GlobalObjectKey，</span></span><br><span class="line">   <span class="comment">// 在RenderObjectToWidgetElementmount的时候会用到</span></span><br><span class="line">   <span class="keyword">super</span>(key: GlobalObjectKey(container));</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectWithChildMixin&lt;T&gt; createRenderObject(BuildContext context) =&gt; container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RenderObjectToWidgetAdapter.createRenderObject</code> 返回的就是<code>container</code> 也就是我们的RenderView。</p>
<h3 id="attachToRenderTree"><a href="#attachToRenderTree" class="headerlink" title="attachToRenderTree"></a>attachToRenderTree</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\binding.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        <span class="comment">// 创建RenderObjectToWidgetElement，并将RenderObjectToWidgetAdapter与之绑定</span></span><br><span class="line">        element = createElement();</span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 创建好Element之后，将BuildOwner与之绑定</span></span><br><span class="line">        element!.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      owner.buildScope(element!, () &#123;</span><br><span class="line">        <span class="comment">// 这里最终会通过updateChild方法将rootWidget对应的Element插入到</span></span><br><span class="line">        <span class="comment">// RenderObjectToWidgetElement下面,在rootWidget中第一个RenderObjectElement</span></span><br><span class="line">        <span class="comment">// 的mount方法中，通过attachRenderObject(newSlot)将自己的renderObject绑定到renderView</span></span><br><span class="line">        element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element!;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RenderObjectToWidgetAdapter</code>在<code>attachToRenderTree</code> 方法中，创建对应的<code>RenderObjectToWidgetElement</code> 与自己绑定，并且同时也将<code>rootWidget</code>和之前创建的rendering tree的根节点<code>renderView</code>绑定。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">|— RenderObjectToWidgetAdapter   —|— RenderObjectToWidgetElement  —|— RenderView —|</span><br></pre></td></tr></table></figure>

<p>我们再来看一下<code>RenderObjectToWidgetElement</code>调用的父类<code>RenderObjectElement.mount</code>方法:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="comment">// 本例中这里实际上获取到的是RenderView</span></span><br><span class="line">    _renderObject = (widget <span class="keyword">as</span> RenderObjectWidget).createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将RenderView绑定到指定newSlot(这里是null)中</span></span><br><span class="line">    attachRenderObject(newSlot);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> attachRenderObject(<span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">    _slot = newSlot;</span><br><span class="line">    <span class="comment">// 这里因为RenderView是根节点，所以_ancestorRenderObjectElement和parentDataElement都为null</span></span><br><span class="line">    <span class="comment">// 但是对于RenderView下级的节点，比如本例中的Center Widget，他对应的祖先节点就是持有RenderView</span></span><br><span class="line">    <span class="comment">// 的RenderObjectToWidgetElement，所以这里会将CenterWidget的RenderPositionedBox</span></span><br><span class="line">    <span class="comment">// 作为RenderView的child</span></span><br><span class="line">    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">    _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot);</span><br><span class="line">    <span class="keyword">final</span> ParentDataElement&lt;ParentData&gt;? parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">    <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">      _updateParentData(parentDataElement.widget <span class="keyword">as</span> ParentDataWidget&lt;ParentData&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>此外，还会调用的<code>Element.mount</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="comment">// Element的方法：</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    _parent = parent;</span><br><span class="line">    _slot = newSlot;</span><br><span class="line">    _lifecycleState = _ElementLifecycle.active;</span><br><span class="line">    _depth = _parent != <span class="keyword">null</span> ? _parent!.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Only assign ownership if the parent is non-null. If parent is null</span></span><br><span class="line">      <span class="comment">// (the root node), the owner should have already been assigned.</span></span><br><span class="line">      <span class="comment">// See RootRenderObjectElement.assignOwner().</span></span><br><span class="line">      _owner = parent.owner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(owner != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 这里将RenderObjectToWidgetElement注册到owner中，key是创建RenderObjectToWidgetAdapter时候创建的GlobalObjectKey</span></span><br><span class="line">    <span class="keyword">final</span> Key? key = widget.key;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">      owner!._registerGlobalKey(key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _updateInheritance();</span><br><span class="line">    attachNotificationTree();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里将<code>RenderObjectToWidgetElement</code> 注册到了BuildOwner中</p>
<p>在<code>RenderObjectToWidgetElement</code>的<code>mount</code>方法执行时，除了调用父类的<code>mount</code>方法外，还会触发<code>_rebuild()</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetElement</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RootRenderObjectElement</span> </span>&#123;&#123;</span><br><span class="line">  <span class="built_in">Element?</span> _child;</span><br><span class="line">  <span class="keyword">void</span> _rebuild() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里分析可知,这里的widget即`RenderObjectToWidgetElement` 的widget，也就是</span></span><br><span class="line">  <span class="comment">// `RenderObjectToWidgetAdapter`，他的child也就是rootWidget</span></span><br><span class="line">  <span class="comment">// 所以updateChild传入的值分别是null，RenderObjectToWidgetAdapter.child</span></span><br><span class="line">  <span class="comment">// 会创建rootWidget对应的element并将其作为当前element的child</span></span><br><span class="line">      _child = updateChild(_child, (widget <span class="keyword">as</span> RenderObjectToWidgetAdapter&lt;T&gt;).child, _rootChildSlot);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_rebuild</code>方法中，我们可以看到，在<code>WidgetsBinding.attachRootWidget</code>方法中给RenderObjectToWidgetAdapter作为<code>child</code>参数传入的<code>rootWidget</code>（也即我们示例中的<code>Center</code>Widget），在这里被传入了RenderView对应的RenderObjectToWidgetElement的<code>child</code>中（这里的过程我们下面Center一节再分析），从而将其插入到Flutter的渲染树中。</p>
<p>这样RenderView（<code>RenderObject</code>）就有了对应的<code>Widget</code>和<code>Element</code>，并且有了自己的<code>child</code>。</p>
<h2 id="scheduleWarmUpFrame"><a href="#scheduleWarmUpFrame" class="headerlink" title="..scheduleWarmUpFrame()"></a>..scheduleWarmUpFrame()</h2><p>这个方法则是尽快安排一个frame以便在屏幕下次刷新的时候显示app的内容（在app启动之后的第一次！！！），这样我们的app启动了，我们写的内容也能正常显示到屏幕上。</p>
<p>通过上述分析，我们可以得知，runApp方法执行之后，创建了<code>RenderView</code>对象，并将其作为整个Flutter APP的RenderObject rendering tree的根节点（后续所有的Widget创建的RenderObject都是在RenderView的下层），并且初始化它以便在下一帧的时候对其进行渲染。</p>
<br>

<p>分析完了<code>runApp</code>，我们再来看一下刚刚提到的几个类，以及他们是如何添加到我们的flutter app中的。</p>
<h1 id="RenderView"><a href="#RenderView" class="headerlink" title="RenderView"></a>RenderView</h1><p>先看一下在最顶层的<a href="https://github.com/flutter/flutter/blob/a0248ebdf20d2befe29cdf325dc7331826151dab/packages/flutter/lib/src/rendering/view.dart#L63">RenderView</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">↓[root]</span><br><span class="line"> &gt;renderObject:RenderView#a00a5</span><br><span class="line"> parent:null</span><br><span class="line"> _debugReassembleConfig:null</span><br><span class="line"> _notificationTree:nul1</span><br><span class="line"> slot:null</span><br><span class="line"> depth:1</span><br><span class="line"> _widget:RenderObjectToWidgetAdapter</span><br><span class="line"> &gt;_owner:BuildOwner</span><br><span class="line"> _lifecycleState:_ElementLifecycle</span><br><span class="line"> _debugForgottenChildrenWithGlobalKey:_HashSet</span><br><span class="line"> _inheritedWidgets:nul1</span><br><span class="line"> _dependencies:null</span><br><span class="line"> _hadUnsatisfiedDependencies:false</span><br><span class="line"> _dirty:false</span><br><span class="line"> _inDirtyList:false</span><br><span class="line"> _debugBuiltOnce:false</span><br><span class="line"> _debugA1lowIgnoredCallsToMarkNeedsBuild:false</span><br><span class="line"> _debugDoingBuild:false</span><br><span class="line"> _ancestorRenderObjectElement:null</span><br><span class="line"> _child:SingleChildRenderObjectElement</span><br><span class="line"> _newWidget:null</span><br></pre></td></tr></table></figure>

<p>查阅源码可知，RenderView是RenderObject，一般情况下是Flutter的根View，表示整个rendering tree的output surface，处理引导着render pipeline。</p>
<p>RenderView有且仅有一个RenderBox类型的<code>child</code>，他会强制将<code>child</code>的<code>size</code>改为RenderView初始化时候的入参<code>configuration</code>的值（一般是当前<code>window</code>也就是<strong>手机屏幕</strong>的逻辑像素<code>size</code>）。</p>
<h1 id="Center"><a href="#Center" class="headerlink" title="Center"></a>Center</h1><p>上节我们说道，Center Widget通过<code>RenderObjectToWidgetElement.updateChild</code>（最终调用Element同名方法）方法插入到渲染树中，下面我们详细分析一下这个过程：</p>
<p>在<code>updateChild</code>中，因为<code>child==null</code>，而<code>newWidget</code>也就是Center不为<code>null</code>，所以直接使用<code>inflateWidget(newWidget, newSlot)</code>创建新的Element并作为RenderObjectToWidgetElement的<code>_child</code>，而作为第一次创建的Center，在<code>Element.inflateWidget</code>方法中大概会执行下面几步：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="comment">// Element的inflateWidget方法：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line"><span class="keyword">return</span> newChild;</span><br></pre></td></tr></table></figure>

<p>也就是这里先执行了<code>Center.createElement</code>方法创建Element，然后调用此<code>Element.mount</code>方法将Element添加到Element tree。</p>
<p>让我们再看一下Center的Widget Details Tree：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Center</span><br><span class="line"> alignment:Alignment.center </span><br><span class="line"> widthFactor:null</span><br><span class="line"> heightFactor:null</span><br><span class="line"> renderObject:RenderPositionedBox#94e0d </span><br><span class="line"> &gt;_parent:RenderObjectToWidgetElement </span><br><span class="line"> _debugReassembleConfig:null</span><br><span class="line"> _notificationTree:null </span><br><span class="line"> &gt;_slot:Object</span><br><span class="line"> _depth:2 </span><br><span class="line"> &gt;_widget:Center </span><br><span class="line"> &gt;_owner:BuildOwner</span><br><span class="line"> &gt;_lifecycleState:_ElementLifecycle</span><br><span class="line"> &gt;_debugForgottenChildrenWithGlobalKey:_HashSet </span><br><span class="line"> _inheritedWidgets:null</span><br><span class="line"> _dependencies:null</span><br><span class="line"> _hadUnsatisfiedDependencies:true </span><br><span class="line"> _dirty:false</span><br><span class="line"> _inDirtyList:false</span><br><span class="line"> _debugBuiltOnce:false</span><br><span class="line"> _debugA1lowIgnoredCallsToMarkNeedsBuild:false </span><br><span class="line"> _debugDoingBuild:false</span><br><span class="line"> &gt;_ancestorRenderObjectElement:RenderObjectToWidgetElement </span><br><span class="line"> &gt;_child:StatelessElement</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到Center的<code>_parent</code>和<code>_ancestorRenderObjectElement</code>是RenderObjectToWidgetElement，<code>_depth</code>是2，这个和我们最初的分析一致，因为Center（其实严格来说，是Center Widget的（或子级的）RenderObject）是RenderView的<code>child</code>。</p>
<p>我们接下来主要关注一下几个属性：</p>
<ul>
<li><code>alignment</code>: Alignment.center</li>
<li><code>renderObject</code>: RenderPositionedBox</li>
<li><code>_widget</code>: Center</li>
<li><code>_child</code>: StatelessElement</li>
</ul>
<p>先看一下Center的源码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\basic.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Center</span> <span class="keyword">extends</span> <span class="title">Align</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a widget that centers its child.</span></span></span><br><span class="line">  <span class="keyword">const</span> Center(&#123; Key? key, <span class="built_in">double?</span> widthFactor, <span class="built_in">double?</span> heightFactor, Widget? child &#125;)</span><br><span class="line">    : <span class="keyword">super</span>(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Center代码十分简单，主要的逻辑在他的父类Align中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\basic.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Align</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> Align(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="comment">// 这里alignment默认是居中</span></span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.widthFactor,</span><br><span class="line">    <span class="keyword">this</span>.heightFactor,</span><br><span class="line">    Widget? child,</span><br><span class="line">    &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderPositionedBox createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// Center的父类可以创建自己的RenderObject</span></span><br><span class="line">    <span class="keyword">return</span> RenderPositionedBox(</span><br><span class="line">      alignment: alignment,</span><br><span class="line">      widthFactor: widthFactor,</span><br><span class="line">      heightFactor: heightFactor,</span><br><span class="line">      textDirection: Directionality.maybeOf(context),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderPositionedBox renderObject) &#123;</span><br><span class="line">    renderObject</span><br><span class="line">      ..alignment = alignment</span><br><span class="line">      ..widthFactor = widthFactor</span><br><span class="line">      ..heightFactor = heightFactor</span><br><span class="line">      ..textDirection = Directionality.maybeOf(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Align其实是一个<code>SingleChildRenderObjectWidget</code> ,对应的Element是<code>SingleChildRenderObjectElement</code>，他创建的RenderObject是<code>RenderPositionedBox</code> 。</p>
<p><code>SingleChildRenderObjectElement</code> 是一个<code>RenderObjectElement</code> 也就意味着他在rendering tree有一个关联的RenderObject负责layout，painting以及hit-test。</p>
<p>回到我们的Center Widget中：</p>
<h2 id="alignment-Alignment-center"><a href="#alignment-Alignment-center" class="headerlink" title="alignment: Alignment.center"></a><strong>alignment: Alignment.center</strong></h2><p><strong>Alignment.center</strong>是在创建Center的时候默认设置的对齐方式</p>
<h2 id="renderObject-RenderPositionedBox"><a href="#renderObject-RenderPositionedBox" class="headerlink" title="renderObject: RenderPositionedBox"></a><strong>renderObject: RenderPositionedBox</strong></h2><p><strong>RenderPositionedBox</strong>是Center Widget对应的RenderObject，在<code>SingleChildRenderObjectWidget.mount</code> 的时候创建。其本身并不在屏幕上绘制肉眼可见的内容，而是将child按照指定的对齐方式进行定位。</p>
<p><code>RenderPositionedBox</code> 的继承关系：<code>RenderPositionedBox</code> → <code>RenderAligningShiftedBox</code> → <code>RenderShiftedBox</code> → <code>RenderBox</code> → <code>RenderObject</code></p>
<p><strong>RenderPositionedBox</strong>可以按照给定的<code>AlignmentGeometry</code>定位child。在本例中，他的几个属性如下：</p>
<ul>
<li><code>alignment</code>: Alignment.center</li>
<li><code>_owner</code>: PipelineOwner</li>
<li><code>_parent</code>: RenderView</li>
<li><code>_child</code>: RenderParagraph</li>
</ul>
<p>前三个属性含义很明显，这里我们注意到他的<code>_child</code>并不是我们预期的<code>Text</code>，这个原因我们后面再分析。</p>
<h2 id="widget-Center"><a href="#widget-Center" class="headerlink" title="_widget: Center"></a><strong>_widget: Center</strong></h2><p>其实通过上述的分析，我们应该已经知道，我们在Widget Details Tree中看到的Center其实是Center Widget对应的Element，也就是<code>SingleChildRenderObjectElement</code> 。</p>
<p>其继承关系：<code>SingleChildRenderObjectElement</code> → <code>RenderObjectElement</code> → <code>Element</code></p>
<p>根据Element的定义，这里的Widget是在Widget创建<code>SingleChildRenderObjectElement</code>的时候传入的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Element</span>(Widget widget)</span><br><span class="line">    : <span class="keyword">assert</span>(widget != <span class="keyword">null</span>),</span><br><span class="line">      _widget = widget;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Abstract const constructor. This constructor enables subclasses to provide</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">const constructors so that they can be used in const expressions.</span></span></span><br><span class="line">  <span class="keyword">const</span> SingleChildRenderObjectWidget(&#123; Key? key, <span class="keyword">this</span>.child &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The widget below this widget in the tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">&#123;@macro flutter.widgets.ProxyWidget.child&#125;</span></span></span><br><span class="line">  <span class="keyword">final</span> Widget? child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  SingleChildRenderObjectElement createElement() =&gt; SingleChildRenderObjectElement(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个Element在上述<code>WidgetsBinding.attachRootWidget</code>步骤中通过一系列操作，最终在RenderObjectToWidgetElement的<code>updateChild</code>方法被创建并被<code>BuildOwner</code> 插入到tree中。</p>
<p>这里的<code>_widget</code>才真正对应着我们在<code>runApp</code>里面传入的Center Widget，他的<code>child</code>也正是我们的Text。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Center</span><br><span class="line"> alignment:Alignment.center</span><br><span class="line"> widthFactor:null</span><br><span class="line"> heightFactor:null</span><br><span class="line"> &gt;renderObject:RenderPositionedBox#6e802</span><br><span class="line"> &gt;_parent:RenderObjectToWidgetElement</span><br><span class="line"> _debugReassembleConfig:null</span><br><span class="line"> _notificationTree:null</span><br><span class="line"> _slot:Object</span><br><span class="line"> denth:2 _</span><br><span class="line"> [[[widget:Center]]] //注意这里</span><br><span class="line">  key:null</span><br><span class="line">  location:_Location</span><br><span class="line">  [[[child:Text]]] //注意这里</span><br><span class="line">   key:null</span><br><span class="line">   &gt;_location:_Location</span><br><span class="line">   data:&#x27;Hello center text!&#x27;</span><br><span class="line">   textSpan:null</span><br><span class="line">   style:null</span><br><span class="line">   strutStyle:null</span><br><span class="line">   textAlign:null</span><br><span class="line">   &gt;textDirection:TextDirection</span><br><span class="line">   locale:null</span><br><span class="line">   softWrap:null</span><br><span class="line">   overflow:null</span><br><span class="line">   textScaleFactor:null</span><br><span class="line">   maxLines:null</span><br><span class="line">   semanticsLabel:null</span><br><span class="line">   textWidthBasis:null</span><br><span class="line">   textHeightBehavior:null</span><br><span class="line">  &gt;alignment:Alignment</span><br><span class="line">  widthFactor:null</span><br><span class="line">  heightFactor:nul1</span><br><span class="line"> &gt;_owner:BuildOwner</span><br></pre></td></tr></table></figure>

<h2 id="child-StatelessElement"><a href="#child-StatelessElement" class="headerlink" title="_child: StatelessElement"></a><strong>_child: StatelessElement</strong></h2><p>Center对应的Element的<code>_child</code>是一个StatelessElement，按照我们上一步的分析，StatelessElement应该是Text Widget创建，事实也确实如此：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">↓_child: StatelessElement</span><br><span class="line"> &gt;_parent: SingleChildRenderObjectElement</span><br><span class="line"> debugReassembleConfig： null</span><br><span class="line"> _notificationTree: null</span><br><span class="line"> slot: null</span><br><span class="line"> depth: 3</span><br><span class="line"> &gt;_widget: Text</span><br><span class="line"> &gt;_owner: BuildOwner</span><br><span class="line"> &gt;_lifecycleState: _ElementLifecycle</span><br><span class="line"> &gt;_debugForgottenChildrenWithGlobalKey: _HashSet</span><br><span class="line"> _inheritedWidgets: null</span><br><span class="line"> dependencies: null</span><br><span class="line"> _hadUnsatisfiedDependencies: true</span><br><span class="line"> _dirty: false</span><br><span class="line"> _inDirtyList: false</span><br><span class="line"> debugBuiltOnce: false</span><br><span class="line"> _debugAllowIgnoredCallsToMarkNeedsBuild: false</span><br><span class="line"> &gt;_child: MultichildRenderObjectElement</span><br><span class="line"> debugDoingBuild: false</span><br></pre></td></tr></table></figure>

<p>让我们分析一下这个<code>_child</code>的赋值过程：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _child = updateChild(_child, (widget <span class="keyword">as</span> SingleChildRenderObjectWidget).child, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Center对应的Element——<code>SingleChildRenderObjectElement</code> 在<code>mount</code>的时候，同时也会更新<code>child</code>（本例中Center的<code>child</code>是Text），这里调用的是Element的<code>updateChild</code>方法，他的逻辑如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">|                     | **newWidget == <span class="keyword">null</span>**  | **newWidget != <span class="keyword">null</span>**   |</span><br><span class="line">| :-----------------: | :--------------------- | :---------------------- |</span><br><span class="line">|  **child == <span class="keyword">null</span>**  |  Returns <span class="keyword">null</span>.         |  Returns <span class="keyword">new</span> [<span class="built_in">Element</span>]. |</span><br><span class="line">|  **child != <span class="keyword">null</span>**  |  Old child <span class="keyword">is</span> removed, returns <span class="keyword">null</span>. | Old child updated <span class="keyword">if</span> possible, returns child or <span class="keyword">new</span> [<span class="built_in">Element</span>]. |</span><br></pre></td></tr></table></figure>

<p><code>updateChild</code>的逻辑分为4种情况：其余情况都比较简单，只有<code>newWidget != null</code>或者<code>child != null</code>的时候需要判断一下，如果可以更新就更新否则就创建新的Element，可以分为下面这几种情况：</p>
<ul>
<li><code>child.widget == newWidget</code>：两个是同一个对象，就只更新<code>child</code>的<code>slot</code></li>
<li><code>Widget.canUpdate(child.widget, newWidget)</code>：二者的<code>runtimeType</code>和<code>key</code>一样，就调用<code>child.update(newWidget)</code>更新<code>child._widget</code>，必要时更新<code>child</code>的<code>slot</code></li>
<li>否则创建新的<code>element</code>并替代</li>
</ul>
<p>到这里跟Center插入到render tree的步骤一样，将Text插入到了tree中。</p>
<h1 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h1><p>接下来我们分析一下Text是如何被加入Widget Details Tree的。</p>
<p>其继承关系：<code>Text</code> → <code>StatelessWidget</code> → <code>Widget</code></p>
<p>Text是StatelessWidget，他的内容比较简单，主要的逻辑都在<code>build</code>方法中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; \lib\src\widgets\text.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Text(</span><br><span class="line">    <span class="built_in">String</span> <span class="keyword">this</span>.data, &#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    ...</span><br><span class="line">  &#125;) : </span><br><span class="line">       textSpan = <span class="keyword">null</span>,</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultTextStyle defaultTextStyle = DefaultTextStyle.of(context);</span><br><span class="line">    TextStyle? effectiveTextStyle = style;</span><br><span class="line">    <span class="keyword">if</span> (style == <span class="keyword">null</span> || style!.inherit)</span><br><span class="line">      effectiveTextStyle = defaultTextStyle.style.merge(style);</span><br><span class="line">    <span class="keyword">if</span> (MediaQuery.boldTextOverride(context))</span><br><span class="line">      effectiveTextStyle = effectiveTextStyle!.merge(<span class="keyword">const</span> TextStyle(fontWeight: FontWeight.bold));</span><br><span class="line">    <span class="comment">// 注意这里返回了RichText</span></span><br><span class="line">    Widget result = RichText(</span><br><span class="line">      textAlign: textAlign ?? defaultTextStyle.textAlign ?? TextAlign.start,</span><br><span class="line">      textDirection: textDirection, <span class="comment">// RichText uses Directionality.of to obtain a default if this is null.</span></span><br><span class="line">      ...</span><br><span class="line">      text: TextSpan(</span><br><span class="line">        style: effectiveTextStyle,</span><br><span class="line">        text: data,</span><br><span class="line">        children: textSpan != <span class="keyword">null</span> ? &lt;InlineSpan&gt;[textSpan!] : <span class="keyword">null</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，作为StatelessWidget，他也创建了一个<code>StatelessElement</code> ：</p>
<p>其继承关系：<code>StatelessElement</code> → <code>ComponentElement</code> → <code>Element</code></p>
<p>按照之前的分析，Text插入到tree中执行的方法分别是<code>Text.createElement</code>和Text对应的Element——<code>StatelessElement.mount</code>方法：</p>
<p>Text是StatelessWidget的子类，他的主要逻辑都在StatelessWidget：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> StatelessWidget(&#123; Key? key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatelessElement createElement() =&gt; StatelessElement(<span class="keyword">this</span>);</span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其<code>createElement</code>创建的是StatelessElement，也就是说Text插入到Center过程主要在StatelessElement中。</p>
<p><code>StatelessElement.mount</code>方法主要逻辑在ComponentElement中，这个方法除了调用Element同名方法外，还调用了<code>ComponentElement._firstBuild()</code> → <code>Element.rebuild()</code> → <code>ComponentElement.performRebuild()</code> ：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="comment">// ComponentElement类中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    Widget? built;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里调用Element对应的Widget的build方法创建Widget，也就是RichText</span></span><br><span class="line">      built = build();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// We delay marking the element as clean until after calling build() so</span></span><br><span class="line">      <span class="comment">// that attempts to markNeedsBuild() during build() will be ignored.</span></span><br><span class="line">      _dirty = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">assert</span>(_debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将上述创建的Widget：built经过处理后赋值给Element的_child</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, built, slot);</span><br><span class="line">      <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      built = ErrorWidget.builder(...);</span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, built, slot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要有两个步骤：</p>
<ul>
<li>调用<code>ComponentElement.build</code>方法，生产Widget（本例中，间接调用了Text的<code>build</code>方法）</li>
<li>调用<code>ComponentElement.updateChild</code>方法，更新<code>child</code>（最终执行的是Element同名方法逻辑）</li>
</ul>
<p>到目前为止，我们的Widget&#x2F;Element&#x2F;RenderObject tree如下（第四级RichText下面再分析）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">**Widget**:       RenderObjectToWidgetAdapter → Center                         → Text              → *RichText*</span><br><span class="line"></span><br><span class="line">**<span class="built_in">Element</span>**:      RenderObjectToWidgetElement → SingleChildRenderObjectElement → StatelessElement  → *MultiChildRenderObjectElement*</span><br><span class="line"></span><br><span class="line">**RenderObject**: RenderView                  → RenderPositionedBox            → [X]               → *RenderParagraph*</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"><span class="number">1.</span> 这里的[X]实际上不存在，只是为了和Text对应表示这里本应该有一个对应的RenderObject</span><br><span class="line"><span class="number">2.</span> 最后一列*RichText*对应的节点目前还没有分析到，此处仅做提前展示</span><br></pre></td></tr></table></figure>

<p>不难看出，在从定往下数第三层也就是Text对应的这一级中，RenderObject tree这里并没有对应的对象，在上面的分析中，我们也看到了StatelessWidget本身并没有创建RenderObject的方法。实际上，Widget分为多个种类，只有RenderObject类及其子类才会创建RenderObject：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_run_app/heritance_of_widget.png" alt="Untitled"></p>
<h2 id="RichText"><a href="#RichText" class="headerlink" title="RichText"></a>RichText</h2><p>终于到了我们这个app真正在屏幕上显示的内容这里了，上面我们分析到，Text作为StatelessWidget，本身并不会产生可以在屏幕上绘制的RenderObject，而是通过他的<code>build</code>方法返回一个可以产生RenderObject的Widget，在本例中，这个Widget就是RichText：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\basic.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichText</span> <span class="keyword">extends</span> <span class="title">MultiChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">  RenderParagraph createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(textDirection != <span class="keyword">null</span> || debugCheckHasDirectionality(context));</span><br><span class="line">    <span class="keyword">return</span> RenderParagraph(text,</span><br><span class="line">      textAlign: textAlign,</span><br><span class="line">      textDirection: textDirection ?? Directionality.of(context),</span><br><span class="line">      softWrap: softWrap,</span><br><span class="line">      overflow: overflow,</span><br><span class="line">      textScaleFactor: textScaleFactor,</span><br><span class="line">      maxLines: maxLines,</span><br><span class="line">      strutStyle: strutStyle,</span><br><span class="line">      textWidthBasis: textWidthBasis,</span><br><span class="line">      textHeightBehavior: textHeightBehavior,</span><br><span class="line">      locale: locale ?? Localizations.maybeLocaleOf(context),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RichText继承自<code>MultiChildRenderObjectWidget</code> ，如上节分析的，是一种<code>RenderObjectWidget</code>，它创建了真正在屏幕上渲染的RenderObject——<code>RenderParagraph</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\rendering\paragraph.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderParagraph</span> <span class="keyword">extends</span> <span class="title">RenderBox</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">ContainerRenderObjectMixin</span>&lt;<span class="title">RenderBox</span>, <span class="title">TextParentData</span>&gt;,</span></span><br><span class="line"><span class="class">             <span class="title">RenderBoxContainerDefaultsMixin</span>&lt;<span class="title">RenderBox</span>, <span class="title">TextParentData</span>&gt;,</span></span><br><span class="line"><span class="class">                  <span class="title">RelayoutWhenSystemFontsChangeMixin</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面说道，Text本身作为StatelessWidget并不产生RenderObject，那么这里的RenderParagraph是如何找到并插入到rendering tree中的呢？</p>
<p>带着这个疑问，我们看一下<code>MultiChildRenderObjectWidget</code> 创建的<code>MultiChildRenderObjectElement</code> ：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="keyword">final</span> MultiChildRenderObjectWidget multiChildRenderObjectWidget = widget <span class="keyword">as</span> MultiChildRenderObjectWidget;</span><br><span class="line">    <span class="comment">// 本例中不涉及children</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; children = <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt;.filled(multiChildRenderObjectWidget.children.length, _NullElement.instance);</span><br><span class="line">    <span class="built_in">Element?</span> previousChild;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; children.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> newChild = inflateWidget(multiChildRenderObjectWidget.children[i], IndexedSlot&lt;<span class="built_in">Element?</span>&gt;(i, previousChild));</span><br><span class="line">      children[i] = newChild;</span><br><span class="line">      previousChild = newChild;</span><br><span class="line">    &#125;</span><br><span class="line">    _children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，在MultiChildRenderObjectElement的<code>mount</code>方法中：</p>
<ul>
<li>调用父类<code>mount</code>方法</li>
<li>遍历了所有的<code>children</code>将其插入到MultiChildRenderObjectElement中。</li>
</ul>
<p>在前面的Text源码中，我们注意到给只给<code>RichText.text</code>赋值了，RichText的<code>textSpan</code>和<code>children</code>都是<code>null</code>，所以后面对<code>children</code>的处理在本例中不涉及，让我们看一下<code>super.mount(parent, newSlot)</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="comment">// 这里调用对应的RenderObjectWidget创建_renderObject</span></span><br><span class="line">    _renderObject = (widget <span class="keyword">as</span> RenderObjectWidget).createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将其绑定到rendering tree中</span></span><br><span class="line">    attachRenderObject(newSlot);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有2步：</p>
<ul>
<li>通过<code>widget.createRenderObject</code> 创建<code>_renderObject</code>，本例中就是用RichText创建了RenderParagraph</li>
<li>调用<code>RenderObjectElement.attachRenderObject</code>方法将<code>_renderObject</code>插入到rendering tree</li>
</ul>
<p>让我们看一下attachRenderObject的实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="comment">// RenderObjectElement类的方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> attachRenderObject(<span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">    _slot = newSlot;</span><br><span class="line">    <span class="comment">// 向上遍历，找到父级节点中最近的RenderObjectElement</span></span><br><span class="line">    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">    <span class="comment">// 将renderObject插入</span></span><br><span class="line">    _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot);</span><br><span class="line">    <span class="keyword">final</span> ParentDataElement&lt;ParentData&gt;? parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">    <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">      _updateParentData(parentDataElement.widget <span class="keyword">as</span> ParentDataWidget&lt;ParentData&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RenderObjectElement? _findAncestorRenderObjectElement() &#123;</span><br><span class="line">    <span class="built_in">Element?</span> ancestor = _parent;</span><br><span class="line">    <span class="keyword">while</span> (ancestor != <span class="keyword">null</span> &amp;&amp; ancestor <span class="keyword">is</span>! RenderObjectElement)</span><br><span class="line">      ancestor = ancestor._parent;</span><br><span class="line">    <span class="keyword">return</span> ancestor <span class="keyword">as</span> RenderObjectElement?;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>attachRenderObject</code>方法中插入的方式很简单：先在当前tree中向上找到父级中离得最近的RenderObjectElement，在本例中是Center这个Widget对应的SingleChildRenderObjectElement（注意不是创建RichText的Text），然后调用其<code>insertRenderObjectChild</code>方法将当前的RenderParagraph插入到rendering tree中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> insertRenderObjectChild(RenderObject child, <span class="built_in">Object?</span> slot) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObjectWithChildMixin&lt;RenderObject&gt; renderObject = <span class="keyword">this</span>.renderObject <span class="keyword">as</span> RenderObjectWithChildMixin&lt;RenderObject&gt;;</span><br><span class="line">    renderObject.child = child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SingleChildRenderObjectElement的<code>insertRenderObjectChild</code>方法中先是查找当前Element持有的<code>renderObject</code>,然后将我们传入的RichText的RenderObject——RenderParagraph赋值给<code>renderObject.child</code>。</p>
<p>到这里，我们的所有Widget在Element的组织下，将对于的RenderObject添加到Rendering Tree中，他们的关系如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">**Widget**:       RenderObjectToWidgetAdapter → Center                         → Text              → RichText</span><br><span class="line"></span><br><span class="line">**<span class="built_in">Element</span>**:      RenderObjectToWidgetElement → SingleChildRenderObjectElement → StatelessElement  → MultiChildRenderObjectElement</span><br><span class="line"></span><br><span class="line">**RenderObject**: RenderView                  → RenderPositionedBox                                → RenderParagraph</span><br></pre></td></tr></table></figure>

<p>这样，当屏幕刷新的时候，这些内容便绘制在屏幕上面。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在<code>runApp</code>方法中，WidgetsFlutterBinding作为将flutter framework绑定到flutter engine的粘合剂：</p>
<ul>
<li><p>在<code>ensureInitialized</code>方法中创建了<code>_pipelineOwner</code>（管理rendering tree）、<code>renderView</code>和<code>buildOwner</code>（通过管理Element tree间接管理widget tree），并将<code>renderView</code>设置为<code>_pipelineOwner</code>的根节点。</p>
</li>
<li><p>在<code>scheduleAttachRootWidget</code>方法中，为<code>renderView</code>创建并绑定了对应的Widget（RenderObjectToWidgetAdapter）和Element（RenderObjectToWidgetElement）。然后通过<code>RenderObjectToWidgetElement.mount</code>方法，将之前创建的<code>buildOwner</code>与自己绑定。</p>
<p>并且将我们在<code>runApp</code>传入的Widget<code>rootWidget</code>（也就是本例中的Center Widget）对应的Element添加为RenderObjectToWidgetElement的子节点。并依此将Text、Text内部的RichText等对应的Element都加入到Element tree中，直到遍历完整个Widget tree。</p>
</li>
<li><p>在<code>scheduleWarmUpFrame</code>方法中安排在下一次屏幕刷新的时候将我们的内容展示在屏幕上面。</p>
</li>
</ul>
<p>下面是我们这个“最”简单的Flutter App的结构示意：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_widget_elelemt_renderobject_tree.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://api.flutter.dev/">Flutter - Dart API docs</a></p>
<p><a href="https://www.youtube.com/watch?v=PnWxW21vDak">Flutter, what are Widgets, RenderObjects and Elements? - Norbert Kozsir | Flutter Europe</a></p>
<p><a href="https://www.youtube.com/watch?v=FU2Eeizo95o&ab_channel=RetroPortalStudio">Flutter Widgets Explained | Understand How Flutter Works!</a></p>
<p><a href="http://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">深入浅出 Flutter Framework 之 PipelineOwner</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter UI 绘制与InheritedWidget解析</title>
    <url>/blog/posts/4c220635/</url>
    <content><![CDATA[<h1 id="Flutter-UI-绘制与InheritedWidget解析"><a href="#Flutter-UI-绘制与InheritedWidget解析" class="headerlink" title="Flutter UI 绘制与InheritedWidget解析"></a>Flutter UI 绘制与InheritedWidget解析</h1><p>Flutter的<code>Widget</code>分为<code>StatefulWidget</code>和<code>StatelessWidget</code> ，二者都继承自<code>Widget</code>。</p>
<p>此外还有一种用来传输数据的<code>Widget</code>——<code>InheritedWidget</code>，与上述两者不太一样的是，他的继承关系是：<code>InheritedWidget</code>→<code>ProxyWidget</code> →<code>Widget</code> 。</p>
<p>Flutter的渲染流程如图：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_widget_element_renderobject_relationship.png" alt="flutter_widget_element_renderobject_relationship"></p>
<p>可以简单理解为， <code>Widget</code>是配置信息，<code>Element</code>代表在树中详细的位置，而<code>RenderObject</code>则是实际渲染的对象。</p>
<p><code>StatelessWidget</code>和<code>StatefulWidget</code>在创建之后就不会再变化，而<code>StatefulWidget</code>因为有<code>State</code>，所以可以在<code>State</code>调用<code>setState()</code>方法之后，重新执行<code>State</code>的<code>build()</code>方法，从而更新界面。</p>
<p>如果<code>Widget</code>是<code>const</code>的，那么他就不会被<code>rebuild</code>。</p>
<h1 id="Widget-Rebuild的过程"><a href="#Widget-Rebuild的过程" class="headerlink" title="Widget Rebuild的过程"></a>Widget Rebuild的过程</h1><p>以StatefulWidget为例：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_render_flow_chart.png" alt="flutter_render_flow_chart"></p>
<ol>
<li><p>调用<code>setState()</code>方法，会调用对应的<code>Element</code>的<code>markNeedsBuild()</code> 方法，通过<code>BuildOwner</code>的<code>scheduleBuildFor(Element element)</code> 方法将当前<code>Element</code>标记为<code>dirty</code>，以便在下次屏幕刷新时安排<code>rebuilt</code> 。</p>
</li>
<li><p>下一帧屏幕刷新，调用<code>BuildOwner</code>的<code>buildScope(Element context, [ VoidCallback? callback ])</code> 方法。这个方法会遍历<code>_dirtyElements</code> 中所有<code>dirty</code>的<code>element</code>执行<code>element.rebuild();</code> 方法，在其内部调用了<code>Element</code>的<code>performRebuild()</code> 方法。</p>
</li>
<li><p><code>Element</code>的<code>performRebuild()</code> 方法因各个<code>Element</code>的实现而异：</p>
<ol>
<li><p><code>StatelessElement</code> 、<code>InheritedElement</code>：与父类<code>ComponentElement</code> 保持一致</p>
</li>
<li><p><code>StatefulElement</code> ：判断有需要时调用<code>state.didChangeDependencies();</code> ，其余与父类<code>ComponentElement</code> 保持一致</p>
</li>
</ol>
</li>
</ol>
<p>而<code>ComponentElement</code> 的<code>performRebuild()</code> 主要做了2件事：<br>（1）<code>built = build();</code> ；（2）<code>_child = updateChild(_child, built, slot);</code></p>
<p>在这其中<code>build()</code>：</p>
<ol>
<li><code>StatelessElement</code>:<code>build() =&gt; widget.build(this);</code></li>
<li><code>StatefulElement</code> : <code>build() =&gt; state.build(this);</code></li>
<li><code>InheritedElement</code> :<code>build() =&gt; widget.child;</code></li>
</ol>
<p><code>updateChild</code> 会判断以下几种情况：</p>
<table>
<thead>
<tr>
<th></th>
<th>newWidget &#x3D;&#x3D; null</th>
<th>newWidget !&#x3D; null</th>
</tr>
</thead>
<tbody><tr>
<td>child &#x3D;&#x3D; null</td>
<td>return null</td>
<td>return new Element</td>
</tr>
<tr>
<td>child !&#x3D; null</td>
<td>remove old child, return null</td>
<td>Old child updated if possible, returns child or new Element</td>
</tr>
</tbody></table>
<p>其中，<code>old child updated</code> 的时候调用的是<code>child.update(newWidget);</code> 方法会触发<code>Widget</code>的<code>rebuild()</code> 。</p>
<p>这样就完成了一次Rebuild。</p>
<h1 id="InheritedWidget的Rebuild过程"><a href="#InheritedWidget的Rebuild过程" class="headerlink" title="InheritedWidget的Rebuild过程"></a>InheritedWidget的Rebuild过程</h1><p><code>InheritedWidget</code>是持有状态的<code>Widget</code>，他的子<code>Widget</code>可以通过他来获取这些状态。</p>
<p>一般来说，<code>InheritedWidget</code>持有的状态是<code>final</code>的，如果要更新状态，就需要在其外部包裹一个<code>StatefulWidget</code>，通过<code>StatefulWidget</code>的<code>State.setState()</code>来触发<code>InheritedWidget</code>重建（实际上<code>InheritedElement</code>没有重新创建），从而更新那些依赖了<code>InheritedWidget</code>的子<code>Widget</code>。</p>
<p>下图是一个被<code>StatefulWidget</code>包裹的<code>InheritedWidget</code>在<code>setSate()&#123;&#125;</code>方法执行后的流程图：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_render_flow_chart_with_inheritedwidget.png" alt="flutter_render_flow_chart_with_inheritedwidget"></p>
<p>当外层<code>StatefulWidget</code>的<code>Element</code>执行到<code>updateChild(child,build,solt);</code>会调用<code>InheritedElement</code>的<code>update()</code> 方法。</p>
<p>这个方法内部会调用<code>updated(oldWidget)</code> 方法，在内部通过<code>notifyClients(oldWidget);</code> 方法，通知原先的<code>InheritedElement</code>的<code>_dependents</code> ，将其标记为<code>dirty</code>，准备<code>rebuild</code>。</p>
<p>在此之后，<code>update()</code>方法还会将当前<code>Element</code>标记为<code>dirty</code>，通过调用<code>rebuild();</code> 执行<code>performRebuild();</code> </p>
<p>在<code>performRebuild()</code>方法中：</p>
<ul>
<li><code>built = build();</code> 中的<code>build</code>方法：<code>build() =&gt; widget.child;</code> 实际上取了<code>widget</code>的<code>child</code>。</li>
<li>然后执行<code>_child = updateChild(_child, built, slot);</code> 这个过程与普通<code>Widget</code>一致。</li>
</ul>
<p>需要注意的是，<code>updateChild</code> 中，如果子<code>Widget</code>不是<code>const</code> （或者被<code>InheritedWidget</code>外层的<code>widget</code>&#x2F;<code>state</code>之类的持有）就会被认为<code>built!=_child</code>  从而导致<code>InheritedWidget</code>的子<code>Widget</code>重建。导致的结果就是：虽然<code>InheritedWidget</code>的确只标记了那些依赖了他的<code>Widget</code>，但是由于直接子<code>Widget</code>要重建，所以还是所有的<code>非const Widget</code>都重建了。</p>
<h2 id="InheritedWidget的获取方式"><a href="#InheritedWidget的获取方式" class="headerlink" title="InheritedWidget的获取方式"></a>InheritedWidget的获取方式</h2><ul>
<li><code>T? dependOnInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;(&#123; Object? aspect &#125;);</code> 获取指定类型的<code>InheritedWidget</code>，并且将自己注册到此<code>Widget</code>，以便当该<code>Widget</code>变化的时候，自己也能<code>rebuilt</code> 。复杂度<code>O(1)</code> 。</li>
<li><code>T? findAncestorWidgetOfExactType&lt;T extends Widget&gt;();</code> 只获取指定类型的<code>Widget</code> ，包括<code>InheritedWidget</code> ，仅获取该<code>Widget</code>执行一些操作，通常用在<code>interaction event handlers</code> 之类中。复杂度<code>(O(N)</code> 。</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>根据上述理论，创建一个<code>InheritedWidget</code>来传递数据：</p>
<p>1、<code>AppColor.dart</code> 一个持有<code>color</code> 的<code>InheritedWidget</code>。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppColor</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Function</span>(Color)? onColorChanged;</span><br><span class="line"></span><br><span class="line">  AppColor(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.color,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="keyword">this</span>.onColorChanged,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(<span class="keyword">covariant</span> AppColor oldWidget) =&gt;</span><br><span class="line">      color != oldWidget.color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> AppColor? of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;AppColor&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义一些类，使用或未使用到<code>InheritedWidget</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoName</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> NoName(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NoName build <span class="subst">$&#123;<span class="keyword">this</span>.hashCode&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: [</span><br><span class="line">        Column(</span><br><span class="line">          children: [</span><br><span class="line">            <span class="comment">// 这里AppColor的_dependents会加入ColorfulContainer(dependencies: [AppColor])</span></span><br><span class="line">            <span class="comment">// 因为他用了context.dependOnInheritedWidgetOfExactType&lt;AppColor&gt;();</span></span><br><span class="line">            <span class="comment">// 会将自己注册到AppColor</span></span><br><span class="line">            ColorfulContainer(),</span><br><span class="line">            ChangeStateButton(),</span><br><span class="line">            Text(<span class="string">&quot;This Text Should Not Rebuild&quot;</span>),</span><br><span class="line">          ],</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorfulContainer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  ColorfulContainer(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> appColor = AppColor.of(context);</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;_ColorfulContainerState appColor?.color:<span class="subst">$&#123;appColor?.color&#125;</span> appColor:<span class="subst">$&#123;appColor.hashCode&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: appColor?.color,</span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">      child: Text(<span class="string">&quot;hello color <span class="subst">$&#123;appColor?.color&#125;</span>&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeStateButton</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;ChangeStateButton&gt; createState() =&gt; _ChangeStateButtonState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ChangeStateButtonState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ChangeStateButton</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialButton(</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        <span class="comment">// 注意下面这个方法，只是查找到InheritedWidget的引用，并没有注册依赖</span></span><br><span class="line">        <span class="comment">// 所以当InheritedWidget变化的时候并不会触发此控件重建</span></span><br><span class="line">        <span class="comment">// 因为每次onColorChanged时AppColor都会重建，所以需要在这里获取最新的</span></span><br><span class="line">        <span class="keyword">var</span> appColor = context.findAncestorWidgetOfExactType&lt;AppColor&gt;();</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;_ChangeStateButtonState appColor?.color:<span class="subst">$&#123;appColor?.color&#125;</span> appColor:<span class="subst">$&#123;appColor.hashCode&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> color = appColor?.color;</span><br><span class="line">        <span class="keyword">var</span> newColor = color == Colors.teal ? Colors.blueAccent : Colors.teal;</span><br><span class="line">        appColor?.onColorChanged?.call(newColor);</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;_ChangeStateButtonState onPressed appColor?.color:<span class="subst">$&#123;appColor?.color&#125;</span> appColor:<span class="subst">$&#123;appColor.hashCode&#125;</span>&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Text(<span class="string">&quot;Change State Button, Shlould NOT Rebuild&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、接下来实现一种基础的使用<code>InheritedWidget</code>的方法，这种方法会在<code>InheritedWidget</code>更新的时候，rebuilt <code>InheritedWidget</code>下面的所有子类，无论他们是否使用到了<code>InheritedWidget</code>（原因是上面说到的Flutter rebuild的机制导致的，实际上<code>InheritedWidget</code>本身只标记了<code>ColorfulContainer</code>为<code>dirty</code>）。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlwaysRebuildWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  AlwaysRebuildWidget(&#123;Key? key, <span class="keyword">required</span> <span class="keyword">this</span>.color&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;AlwaysRebuildWidget&gt; createState() =&gt; _AlwaysRebuildWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AlwaysRebuildWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AlwaysRebuildWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">late</span> Color _color;</span><br><span class="line">  <span class="keyword">var</span> child = NoName();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _color = widget.color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 这种写法，AppColor的_dependents也只有1个. ColorfulContainer(dependencies: [AppColor])</span></span><br><span class="line">    <span class="comment">// 所以每次setState引起AlwaysRebuildWidget重新绘制，引起AppColor重新创建，本应该会重建ColorfulContainer</span></span><br><span class="line">    <span class="comment">// 但是因为build方法重新执行了一次，所以AppColor和整个NoName都被重建，</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;AlwaysRebuildWidget build<span class="subst">$&#123;widget.hashCode&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AppColor(</span><br><span class="line">        color: _color,</span><br><span class="line">        onColorChanged: (color) &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            _color = color;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 这种写法，AppColor在updateChild的时候会判断widget.child与_child.widget的NoName不一致</span></span><br><span class="line">        <span class="comment">// （这是因为，AppColor在notifyClients的时候修改了NoName的child之一ColorfulContainer为dirty）</span></span><br><span class="line">        <span class="comment">// 从而会更新NoName，导致NoName下面所有的子Widget全部重新绘制</span></span><br><span class="line">         child: NoName());</span><br><span class="line">    <span class="comment">// 按照上面分析的逻辑，在这里加上const，那么依旧用的是之前的NoName，就不会repaint整个的NoName了</span></span><br><span class="line">    <span class="comment">// child: const NoName());</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、接下来实现一种使用<code>InheritedWidget</code>的方法，当<code>InheritedWidget</code>更新的时候，只会更新那些在<code>InheritedWidget</code>这里注册依赖了的<code>Widget</code>。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectiveRebuildWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  SelectiveRebuildWidget(&#123;Key? key, <span class="keyword">required</span> <span class="keyword">this</span>.child, <span class="keyword">required</span> <span class="keyword">this</span>.color&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;SelectiveRebuildWidget&gt; createState() =&gt; _SelectiveRebuildWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SelectiveRebuildWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SelectiveRebuildWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">late</span> Color _color;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _color = widget.color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;SelectiveRebuildWidget build<span class="subst">$&#123;widget.child.hashCode&#125;</span>  <span class="subst">$&#123;widget.hashCode&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> AppColor(</span><br><span class="line">      color: _color,</span><br><span class="line">      onColorChanged: (color) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _color = color;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 这里的AppColor的_dependents只有1个. ColorfulContainer(dependencies: [AppColor])</span></span><br><span class="line">      <span class="comment">// 因为setState不会重新创建SelectiveRebuildWidget，所以widget.child也没有被重新</span></span><br><span class="line">      <span class="comment">// 创建（但是重新绘制了，导致AppColor也重新绘制）</span></span><br><span class="line">      <span class="comment">// 所以AppColor的child还是之前的，按照InheritedWidget的规则，只有ColorfulContainer重新绘制了</span></span><br><span class="line">      child: widget.child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://petercoding.com/flutter/2021/07/04/using-inherited-widget-in-flutter/">Using Inherited Widget In Flutter</a></p>
<p><a href="https://www.cnblogs.com/lxlx1798/p/11190230.html?share_token=1bd95081-524b-4a3b-af65-686ab5c88ce4">【Flutter学习】之Widget数据共享之InheritedWidget 梁飞宇</a></p>
<p><a href="https://stackoverflow.com/questions/54494398/inheritedwidget-confusion">InheritedWidget confusion</a></p>
<p><a href="https://medium.com/flutter/managing-flutter-application-state-with-inheritedwidgets-1140452befe1">Managing Flutter Application State With InheritedWidgets</a></p>
<p><a href="https://stackoverflow.com/questions/53492705/does-using-const-in-the-widget-tree-improve-performance">Does using const in the widget tree improve performance?</a></p>
<p><a href="https://api.flutter-io.cn/flutter/widgets/StatefulWidget-class.html">StatefulWidget</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter Expanded VS Flexible</title>
    <url>/blog/posts/767a594/</url>
    <content><![CDATA[<p>在Flutter中，当需要填充容器（<code>Row</code>, <code>Column</code>, or <code>Flex</code>）剩余空间的时候，可以使用<code>Expanded</code>或<code>Flexible</code>，本文对这二者的差异做一分析。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><code>Expanded</code> 比较容易理解，他会强制child改变大小，占据容器的剩余空间，如果有多个<code>Expanded</code>的话，会按照他们的flex占比来分配每个child可以占据的空间大小。  </p>
<p><code>Flexible</code> 稍微特殊一些，有时候看起来似乎他的child占据的大小既不全是父布局的剩余空间，也不全是刚刚包裹child内容的大小。</p>
<p>让我们看一下<code>Flexible</code>的源码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Flexible(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">this</span>.flex = <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">this</span>.fit = FlexFit.loose,</span><br><span class="line">  <span class="keyword">required</span> Widget child,</span><br><span class="line">&#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br></pre></td></tr></table></figure>
<p>可以看到，默认情况下他使用的<code>fit</code>模式是<code>FlexFit.loose</code>，查阅文档定义可知：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FlexFit.loose：The child can be at most <span class="keyword">as</span> large <span class="keyword">as</span> the available space (but <span class="keyword">is</span> allowed to be smaller).</span><br><span class="line"></span><br><span class="line">FlexFit.tight：The child <span class="keyword">is</span> forced to fill the available space.</span><br></pre></td></tr></table></figure>

<p>也就是说，默认情况下，<code>Flexible</code>的child最大可以是父容器分配给<code>Flexible</code>的大小（假设为<code>MaxSzie</code>）。</p>
<p>但是，如果child的大小比这个<code>MaxSzie</code>要小的话，那么允许child按照自己的大小来显示。</p>
<p>而如果<code>Flexible</code>的<code>fit</code>是<code>FlexFit.tight</code>的话，就会强制child大小为<code>MaxSzie</code>，效果和<code>Expanded</code>一致，实际上<code>Expanded</code>就是<code>FlexFit.tight</code>模式的<code>Flexible</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expanded</span> <span class="keyword">extends</span> <span class="title">Flexible</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a widget that expands a child of a [Row], [Column], or [Flex]</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">so that the child fills the available space along the flex widget&#x27;s</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">main axis.</span></span></span><br><span class="line">  <span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="built_in">int</span> flex = <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, flex: flex, fit: FlexFit.tight, child: child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述的结论，我们可以从下面的代码中得到证实：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/05/11/8559625d0d49ae28.png" alt="Untitled"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() =&gt; runApp(MaterialApp(home: BodyWidget()));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BodyWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _BodyState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BodyState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BodyWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> width = MediaQuery.of(context).size.width;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Material(</span><br><span class="line">      child: Container(</span><br><span class="line">        color: Colors.grey.shade200,</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: [</span><br><span class="line">            Row(</span><br><span class="line">              mainAxisSize: MainAxisSize.max,</span><br><span class="line">              children: [</span><br><span class="line">                Container(</span><br><span class="line">                    color: Colors.teal,</span><br><span class="line">                    child: Text(</span><br><span class="line">                      <span class="string">&#x27;Container Text &#x27;</span>,</span><br><span class="line">                    )),</span><br><span class="line">                Flexible(</span><br><span class="line">                  child: Container(</span><br><span class="line">                      color: Colors.blue,</span><br><span class="line">                      child: Text(<span class="string">&#x27; Text.Flexible Text.Flexible Text.Flexible.&#x27;</span>)),</span><br><span class="line">                ),</span><br><span class="line">                Flexible(</span><br><span class="line">                  child: Container(</span><br><span class="line">                      color: Colors.yellow, child: Text(<span class="string">&#x27;Flexible Text.&#x27;</span>)),</span><br><span class="line">                ),</span><br><span class="line">                Flexible(</span><br><span class="line">                  child: Container(</span><br><span class="line">                      color: Colors.lightGreen, child: Text(<span class="string">&#x27;Flexible.&#x27;</span>)),</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            SizedBox(</span><br><span class="line">              height: <span class="number">80</span>,</span><br><span class="line">              width: width,</span><br><span class="line">              child: ListView.builder(</span><br><span class="line">                itemBuilder: (context, index) &#123;</span><br><span class="line">                  <span class="keyword">return</span> SizedBox(</span><br><span class="line">                    width: width / count,</span><br><span class="line">                    child: Column(</span><br><span class="line">                      mainAxisSize: MainAxisSize.max,</span><br><span class="line">                      children: [</span><br><span class="line">                        Container(</span><br><span class="line">                          width: <span class="number">1</span>,</span><br><span class="line">                          height: index % <span class="number">5</span> == <span class="number">0</span> ? <span class="number">30</span> : <span class="number">20</span>,</span><br><span class="line">                          color: Colors.purple,</span><br><span class="line">                        ),</span><br><span class="line">                        <span class="keyword">if</span> (index % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                          Flexible(</span><br><span class="line">                            child: Text(</span><br><span class="line">                              <span class="string">&#x27;<span class="subst">$index</span>&#x27;</span>,</span><br><span class="line">                              style: <span class="keyword">const</span> TextStyle(fontSize: <span class="number">5</span>),</span><br><span class="line">                            ),</span><br><span class="line">                          ),</span><br><span class="line">                      ],</span><br><span class="line">                    ),</span><br><span class="line">                  );</span><br><span class="line">                &#125;,</span><br><span class="line">                itemCount: count,</span><br><span class="line">                scrollDirection: Axis.horizontal,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Expanded</code>和<code>Flexible</code>默认情况下都会按照<code>flex</code>占据父容器剩余的可用空间，但是不同的是，<code>Expanded</code>会强制child改变大小为父容器分配的大小，而<code>Flexible</code>则会告诉child，<strong>最大只能是父容器分配的大小，要是child想要小一些的话，也可以按照child的大小显示</strong>。</p>
<p>如果改变<code>Flexible</code>的<code>fit</code>为<code>FlexFit.tight</code>的话，<code>Expanded</code>和<code>Flexible</code>没有差别。</p>
]]></content>
  </entry>
  <entry>
    <title>Flutter Widget简单入门</title>
    <url>/blog/posts/e35c106d/</url>
    <content><![CDATA[<p>Flutter是Google提出的跨平台开发框架，使用Dart语言，支持Android，IOS系统。Flutter一个重要的概念即是——<em>“万物皆控件（Widget）”</em>，像<code>Padding</code>,<code>Center</code>等都是Widget。</p>
<p>Widget和Android中的View很相似但又有不同，Widget一旦生成便“一成不变”，直到下一次因为Widget更改或者state更新而被重新创建（Flutter’s framework creates a new tree of widget instances.），而View则只会被<code>drawn</code>一次，直到<code>invalidate</code>方法被调用。</p>
<p>本文主要记录一下Flutter中两个重要的控件：StatelessWidget和StatefulWidget，以及Flutter开发的一些基础知识。</p>
<h1 id="Flutter基础知识"><a href="#Flutter基础知识" class="headerlink" title="Flutter基础知识"></a>Flutter基础知识</h1><p>Flutter以Dart开发，其工程基本的结构如下：</p>
<ul>
<li>android</li>
<li>ios</li>
<li>lib<ul>
<li>main.dart</li>
</ul>
</li>
<li>pubspec.yaml &#x2F;&#x2F;Flutter工程的配置信息</li>
</ul>
<p>Flutter项目启动后会首先加载<code>/lib/main.dart</code>中的<code>main()</code>方法。<br>一个标准的material app的main.dart内容如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./product_manager.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line">main() =&gt; runApp(MyApp());<span class="comment">//在main()方法中调用了material的runApp()方法，里面传入了要展示的Widget——APP的界面，相当于Android的setContentView()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.deepOrange</span><br><span class="line">      ),</span><br><span class="line">      home: Scaffold(<span class="comment">//脚手架，一个预制的APP界面结构，也可以使用自定义Widget</span></span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&quot;EasyList&quot;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: ProductManager(<span class="string">&quot;Test&quot;</span>),<span class="comment">//这里是自定义的控件，布局信息主要在这里展示</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="StatelessWidget-amp-StatefulWidget"><a href="#StatelessWidget-amp-StatefulWidget" class="headerlink" title="StatelessWidget &amp; StatefulWidget"></a>StatelessWidget &amp; StatefulWidget</h1><p>StatelessWidget和StateFulWidget区别在于：前者一旦创建，状态便不会再更改，而后者则可以动态改变State从而使flutter改变其状态。但是两者都会在每一帧被rebuild。</p>
<h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><blockquote>
<p>A <code>StatelessWidget</code> is just what it sounds like—a widget with no state information.</p>
</blockquote>
<p>StatelessWidget一旦创建便不会更改，其状态只和构造函数中的参数有关。下面是一个StatelessWidget示例，一般只需要重写其build()方法，返回要展示的控件即可：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomerWidget();<span class="comment">//在这里构建一个页面并返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><blockquote>
<p><code>StatefulWidget</code> has a <code>State</code> object that stores state data across frames and restores it.</p>
</blockquote>
<p>StatefulWidget可以通过动态更改其包含的State，从而使flutter在下一次更新界面时依据state更新StateWidget，<em>本质上还是更新了一个可以在多帧之间存活的State，在下一帧更新控件</em>。</p>
<p>下面是一个StatefulWidget的示例:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductManager</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> ProductManagerState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductManagerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ProductManager</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomerWidget();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到StatefulWidget重写了<code>createState()</code>，而该方法返回了自定义的<code>ProductManagerState</code>类对象，在该类中<code>build()</code>方法实现和StatelessWidget中的方法类似，返回要展示的页面控件。</p>
<p>两者的不同之处在于，StatefulWidget中可以调用<code>setState()</code>，更改其相应的<code>state</code>，以便告诉flutter在下一次rebuild的时候更新UI。</p>
<p>StatelessWidget要想实现动态更新其内容，可以在其外部包裹一层StatefulWidget，通过StatefulWidget更改状态state，将更改后的state传给StatelessWidget，从而间接更新了StatelessWidget的状态。</p>
<p>可以通过对该方法就行包装，使得在StatelessWidget控件中调用StatefulWidget控件的<code>setState()</code>方法，达到刷新页面的效果：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StatefulWidget</span></span><br><span class="line">  <span class="keyword">void</span> aFun()&#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// update UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">AStatelessWidget(aFun);<span class="comment">// 将该方法传入StatelessWidget中</span></span><br><span class="line"><span class="comment">// StatelessWidget</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">Function</span> aFun</span><br><span class="line">AStatelessWidget(<span class="keyword">this</span>.aFun);<span class="comment">// 接收传入的方法</span></span><br><span class="line">aFun();<span class="comment">// 执行该方法，从而实现调用StatelessWidget中的方法也可以刷新UI</span></span><br></pre></td></tr></table></figure>



<h1 id="与Android的对比"><a href="#与Android的对比" class="headerlink" title="与Android的对比"></a>与Android的对比</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Android的Intent有两个主要作用：</p>
<ul>
<li>Activity间跳转</li>
<li>组件间传递数据</li>
</ul>
<p>Flutter对此相应：</p>
<ul>
<li>使用Navigator和<code>Route</code>s实现在同一个“Activity”中不同的界面间（ “screen” or “page”）跳转（push，pop），Navigator类似于Android中的Activity栈。</li>
<li>通过Android原生Intent组件获取到其他App传来的数据，然后中通过下面的方法实现Android和Flutter交互：</li>
</ul>
<p>示例代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//Android</span></span><br><span class="line"> MethodChannel(getFlutterView(), <span class="string">&quot;app.channel.shared.data&quot;</span>)</span><br><span class="line">      .setMethodCallHandler(MethodChannel.MethodCallHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public <span class="keyword">void</span> onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123;</span><br><span class="line">          <span class="keyword">if</span> (methodCall.method.contentEquals(<span class="string">&quot;getSharedText&quot;</span>)) &#123;</span><br><span class="line">            result.success(sharedText);</span><br><span class="line">            sharedText = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"> <span class="comment">//Flutter</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">_SampleAppPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SampleAppPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> platform = <span class="keyword">const</span> MethodChannel(<span class="string">&#x27;app.channel.shared.data&#x27;</span>);</span><br><span class="line">  <span class="built_in">String</span> dataShared = <span class="string">&quot;No data&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    getSharedText();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(body: Center(child: Text(dataShared)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSharedText() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sharedData = <span class="keyword">await</span> platform.invokeMethod(<span class="string">&quot;getSharedText&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sharedData != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        dataShared = sharedData;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>Flutter是单线程的，他的线程和Android的UI线程绑定，在进行网络请求，IO操作等时，可以使用<code>sync/await</code> 在执行完耗时操作后，再去更新state刷新UI。</p>
<blockquote>
<p>Since Flutter is single threaded and runs an event loop (like Node.js), you don’t have to worry about thread management or spawning background threads. If you’re doing I&#x2F;O-bound work, such as disk access or a network call, then you can safely use async&#x2F;await and you’re all set. </p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> dataURL = <span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">  http.Response response = <span class="keyword">await</span> http.<span class="keyword">get</span>(dataURL);</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    widgets = json.decode(response.body);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果有特别频繁的cpu计算以至于能导致UI挂起，可以考虑使用<code>Isolate</code>s利用CPU多核心处理任务，但是这样就不能和主线程共享数据，通过<code>ReceivePort</code>，<code>SendPort</code>等传递数据。</p>
<blockquote>
<p>Isolates(隔离) are separate execution threads that do not share any memory with the main execution memory heap. This means you can’t access variables from the main thread, or update your UI by calling <code>setState()</code>. Unlike Android threads, Isolates are true to their name, and cannot share memory (in the form of static fields, for example).</p>
</blockquote>
<h2 id="本地资源"><a href="#本地资源" class="headerlink" title="本地资源"></a>本地资源</h2><p>截止Flutter beta 2 仍然不能直接访问Android assets或者其他本地资源，但是Android可以访问flutter的assets资源：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">val flutterAssetStream = assetManager.open(<span class="string">&quot;flutter_assets/assets/my_flutter_asset.png&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过Channel，flutter可以间接访问Android资源，反之亦然。</p>
<blockquote>
<p>主要是通过Channel完成，可以称之为隧道。主要是MethodChannel和MessageChannel两种，第一种是调用方法，第二种是传递信息。首先通信的双方是Flutter和本地操作系统或者应用，而且方法的调用和消息的方法可以从任何一方发起，类似RPC（远程过程调用）。</p>
<p>作者：黄马</p>
<p>链接：掘金  <a href="https://juejin.im/post/5b35a75e51882574ea3a25e3">https://juejin.im/post/5b35a75e51882574ea3a25e3</a></p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Flutter生命周期没有Android中那么“重要”，可以重写 <code>didChangeAppLifecycleState()</code> 监听。</p>
<ul>
<li><code>inactive</code> — 应用处于非活动状态，不接受输入。iOS</li>
<li><code>paused</code> — 应用在后台运行，不可见，不接受输入。类似Android的<code>onPause()</code></li>
<li><code>resumed</code> — 应用可见，并接受输入。类似Android的<code>onPostResume()</code></li>
<li><code>suspending</code> — 应用请求暂停。类似Android的<code>onStop()</code></li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>Flutter有布局Widget如：</p>
<ul>
<li>Column 列</li>
<li>Row 行</li>
<li>Stack 左上角堆积，类似FrameLayout</li>
</ul>
<h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>FLutter中的“<code>onClick()</code>”: <code>onPressed</code>,<code>onTap</code>等等。</p>
<p>添加点击事件,在Widget外面添加一个<code>GestureDetector</code>Widget：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">  child: Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">      child: Text(<span class="string">&quot;Row <span class="subst">$i</span>&quot;</span>)),</span><br><span class="line">  onTap: () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;row tapped&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.youtube.com/watch?v=GLSG_Wh_YWc">Flutter Tutorial for Beginners - Build iOS and Android Apps with Google’s Flutter &amp; Dart</a></p>
<p><a href="https://flutter.io/flutter-for-android/">Flutter for android</a></p>
<p><a href="https://juejin.im/post/5b35a75e51882574ea3a25e3">Flutter 访问本地资源</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter中的异常处理</title>
    <url>/blog/posts/9e235953/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>FLutter</code>中的错误不会导致应用程序奔溃，只会终止执行出错代码之后的逻辑，在导致<code>Widget.build()</code>返回为<code>null</code>的错误会导致<code>Widget</code>构建失败，并返回<em>红底黄字</em>的错误原因<code>Widget</code>（在Release模式则会显示为<em>灰底区域</em>）；一般来说，Flutter中的错误都会被<code>FlutterError.onError</code>捕获并处理；对于异步方法产生异常等<code>Flutter框架</code>没有捕获的情况，会交由当前代码所在的<code>Zone</code>处理（这些异常可以使用<code>runZonedGuarded</code>捕获并处理）。</p>
<blockquote>
<p><strong>为什么 flutter 触发异常的时候不会崩溃？</strong><br>这个和 <code>flutter</code> 的消息循环机制有关，任务分两种，一个是微任务 <code>microtask</code>，一个是事件 <code>event</code>，他们有自己的队列，每个任务是相互独立的，一旦某个任务触发异常，也就是导致这个任务后续代码无法执行，并不会影响其他任务执行</p>
</blockquote>
<p><em>本文基于Flutter (Channel stable, 2.2.3)</em></p>
<h1 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h1><p>Flutter中的错误处理分为以下几种：</p>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try...catch"></a><code>try...catch</code></h2><p>对于普通的错误，可以通过<code>try...catch</code>来捕获：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">   <span class="keyword">var</span> three = list[<span class="number">3</span>];</span><br><span class="line"> &#125; <span class="keyword">on</span> RangeError <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;这里是捕获RangeError类型的异常 <span class="subst">$e</span>&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;这里是兜底的捕获异常 <span class="subst">$e</span>&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;这里是无论如何都会执行的代码&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于，异步异常，可以使用<code>await</code>等待其执行完毕，将其变为同步任务，否则无法则捕获。</p>
<h2 id="ErrorWidget-builder"><a href="#ErrorWidget-builder" class="headerlink" title="ErrorWidget.builder"></a><code>ErrorWidget.builder</code></h2><p>当在<code>Widget</code>构建过程中出现错误，导致<code>build()</code>方法返回<code>null</code>，<code>Flutter框架</code>会调用<code>ErrorWidget.builder</code>返回一个<code>Widget</code>替代<code>出错的Widget</code>。</p>
<p>默认情况下，<code>debug</code>模式返回的是红底黄字的错误提示，而<code>release</code>模式返回的是<code>灰色Widget</code>。</p>
<p>可以在<code>RunApp</code>方法中替换这个默认的错误界面：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">runApp(MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(),</span><br><span class="line">        body: BodyWidget(),</span><br><span class="line">      ),</span><br><span class="line">      builder: (context, widget) &#123;</span><br><span class="line">        <span class="comment">// Widget在Build时出错的话，展示此Widget，</span></span><br><span class="line">        <span class="comment">// 如果不定义的话，debug下为红底黄字错误信息，release会显示为灰色布局</span></span><br><span class="line">        <span class="comment">// errorDetails在release模式下为空</span></span><br><span class="line">        ErrorWidget.builder = (FlutterErrorDetails errorDetails) &#123;</span><br><span class="line">          <span class="keyword">return</span> MainErrorWidget(widget, errorDetails);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> widget ?? Container();</span><br><span class="line">      &#125;,</span><br><span class="line">    ));</span><br></pre></td></tr></table></figure>

<p>上述代码中的<code>MainErrorWidget</code>是一个自定义的展示错误信息的页面。</p>
<ul>
<li><p><code>MainErrorWidget</code>的一种实现方式</p>
  <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainErrorWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  Widget? parentWidget;</span><br><span class="line"></span><br><span class="line">  FlutterErrorDetails errorDetails;</span><br><span class="line"></span><br><span class="line">  MainErrorWidget(<span class="keyword">this</span>.parentWidget, <span class="keyword">this</span>.errorDetails);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3. 布局出现错误，展示错误页面,此处错误在release中也会调用FlutterError.onError&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Widget error = Card(</span><br><span class="line">      child: SingleChildScrollView(</span><br><span class="line">        child: Container(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20</span>),</span><br><span class="line">          color: Colors.green,</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;布局出现错误，以下是错误信息:\n<span class="subst">$errorDetails</span>&#x27;</span>,</span><br><span class="line">            style: TextStyle(fontSize: <span class="number">10</span>, color: Colors.white),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (parentWidget <span class="keyword">is</span> Scaffold || parentWidget <span class="keyword">is</span> Navigator) &#123;</span><br><span class="line">      debugPrint(</span><br><span class="line">          <span class="string">&quot;widget<span class="subst">$&#123;parentWidget?.key?.toString()&#125;</span> (<span class="subst">$parentWidget</span>)  is Scaffold <span class="subst">$&#123;parentWidget <span class="keyword">is</span> Scaffold&#125;</span> or Navigator <span class="subst">$&#123;parentWidget <span class="keyword">is</span> Navigator&#125;</span>&quot;</span>);</span><br><span class="line">      <span class="comment">// error = Container(child: error);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>需要注意的是，错误<code>Widget</code>在<code>Debug</code>和<code>Release</code>模式下有一些区别：</p>
<ul>
<li><code>Debug</code>模式下<code>ErrorWidget.builder</code>会返回错误详细信息<code>FlutterErrorDetails</code> ，<code>Release</code>下则不会；</li>
<li><code>Debug</code>模式下，<code>Widget</code>等出错会打印<code>Exception caught by widgets library ...</code> 等提示并输出错误堆栈信息，但是<code>Release</code>模式下不会；</li>
<li><code>Debug</code>模式下，出错不会调用<code>FlutterError.onError</code>，<code>Release</code>模式下会。</li>
</ul>
<h2 id="FlutterError-onError"><a href="#FlutterError-onError" class="headerlink" title="FlutterError.onError"></a><code>FlutterError.onError</code></h2><p>上述几种情况都没有处理的，被Flutter框架引起的异常，会在这里被处理。</p>
<p>在<code>Flutter 2.2.3</code>中，<code>Debug</code>模式下如<code>onPressed</code>中的未捕获错误等都会被Widget等捕获，而不会走到这里来，在<code>Release</code>模式下则会调用<code>FlutterError.onError</code>。</p>
<p>在这里可以对错误进行处理，比如输出到控制台、交给Zone统一处理、直接结束掉APP等：</p>
<ul>
<li><code>FlutterError.dumpErrorToConsole(details);</code> 输出到控制台</li>
<li><code>exit(1);</code> 退出APP</li>
<li><code>Zone.current.handleUncaughtError(details.exception, details.stack);</code> 交给Zone统一处理</li>
<li><code>defaultOnError?.call(details);</code>   自己处理完异常后，也要把异常向上抛 【推荐】，其中<code>defaultOnError</code> 可以预先缓存<code>final defaultOnError = FlutterError.onError;</code></li>
</ul>
<h2 id="runZonedGuarded-onError"><a href="#runZonedGuarded-onError" class="headerlink" title="runZonedGuarded(onError)"></a><code>runZonedGuarded(onError)</code></h2><p>上述几种情况都没有处理的异常，会被发送到这里处理，可以类比为<code>Android</code>中的<code>Thread.UncaughtExceptionHandler</code>。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">runZonedGuarded(() <span class="keyword">async</span> &#123;</span><br><span class="line">    runApp(...);</span><br><span class="line">  &#125;,</span><br><span class="line">  (<span class="built_in">Object</span> error, StackTrace stack) &#123;</span><br><span class="line">    <span class="comment">// 没有被Flutter捕获的错误,全局未捕获异常处理,类似于Android的Thread.UncaughtExceptionHandler</span></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">比如异步的方法</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2. runZonedGuarded.onError <span class="subst">$error</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>Zone可以理解为一个沙盒，其中的代码出错，包括异步的都可以捕获到。但是如果是另外一个沙盒中的错误则无法处理。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://flutter.cn/docs/testing/errors#define-a-custom-error-widget-for-build-phase-errors">Flutter 官网异常处理</a></p>
<p><a href="https://www.fnzblog.site/Flutter%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html">Flutter异常处理</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter图片加载方案分析之Image</title>
    <url>/blog/posts/1912667a/</url>
    <content><![CDATA[<p>Flutter 默认提供了<strong>Image</strong>用于从网络、文件等加载图片，并且使用<strong>ImageCache</strong>统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了<a href="https://github.com/Baseflow/flutter_cache_manager/tree/master">flutter_cache_manager</a>、<a href="https://github.com/fluttercandies/extended_image">extended_image</a>等基于 Flutter 原生的解决方案，以及<a href="https://github.com/alibaba/power_image">power_image</a>等基于混合开发的解决方案。</p>
<p>本文对 Flutter 中的 Image 加载过程、原理做一简单分析。</p>
<h1 id="图片展示的流程"><a href="#图片展示的流程" class="headerlink" title="图片展示的流程"></a>图片展示的流程</h1><p>首先，简单梳理一下图片从加载到展示的过程。</p>
<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p><em><code>A widget that displays an image.</code></em></p>
<p>在查看 Image 具体实现之前，先了解几个基础方法：</p>
<ul>
<li><code>ImageConfiguration createLocalImageConfiguration(BuildContext context, &#123; Size? size &#125;)</code> ：创建 <strong>ImageConfiguration</strong>，一般用于 <code>state.didChangeDependencies</code> 等依赖变化时会调用的地方，其创建的 ImageConfiguration 对象会传入 <code>BoxPainter.paint</code> 或者 <code>ImageProvider.resolver</code> 方法中以用来获取 <strong>ImageStream</strong>。</li>
<li><code>Future&lt;void&gt; precacheImage(...)</code> 预先加载 image 到 <strong>ImageCache</strong> 中，以便 Image、BoxDecoration、FadeInImage 等能够更快地加载 image。</li>
</ul>
<p>Image 是 Flutter 中用于展示图片的 Widget，主要有如下用法：</p>
<ul>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.html">Image.new</a>, for obtaining an image from an <a href="https://api.flutter.dev/flutter/painting/ImageProvider-class.html">ImageProvider</a>.</li>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.asset.html">Image.asset</a>, for obtaining an image from an <a href="https://api.flutter.dev/flutter/services/AssetBundle-class.html">AssetBundle</a> using a key.</li>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.network.html">Image.network</a>, for obtaining an image from a URL.</li>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.file.html">Image.file</a>, for obtaining an image from a <a href="https://api.flutter.dev/flutter/dart-io/File-class.html">File</a>.</li>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.memory.html">Image.memory</a>, for obtaining an image from a <a href="https://api.flutter.dev/flutter/dart-typed_data/Uint8List-class.html">Uint8List</a>.</li>
</ul>
<p>支持的格式有：JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP，以及依赖于特定设备的格式（Flutter 会尝试使用平台 API 解析未知格式）。</p>
<p>通过指定<code>cacheWidth</code>和<code>cacheHeight</code>可以让引擎按照指定大小解码图片，可以降低 ImageCache 占用的内存。</p>
<p><code>Image(...)</code>构造函数中只有一个必传项<code>ImageProvider image</code>用于获取图片，其余四种构造方法也都是在此方法的基础上分别指定了各自的 <strong>ImageProvider</strong>，以<code>Image.network</code>为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">    <span class="built_in">String</span> src, &#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="built_in">double</span> scale = <span class="number">1.0</span>,</span><br><span class="line">    ...,</span><br><span class="line">    <span class="built_in">int?</span> cacheWidth,</span><br><span class="line">    <span class="built_in">int?</span> cacheHeight,</span><br><span class="line">  &#125;) : image = ResizeImage.resizeIfNeeded(cacheWidth, cacheHeight, NetworkImage(src, scale: scale, headers: headers)),</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br></pre></td></tr></table></figure>

<p>上述代码中的 ResizeImage，NetworkImage 等都继承自 <strong>ImageProvider</strong>，<code>ImageProvider.resolve</code>方法创建并返回 <strong>ImageStream</strong> 供 <strong>Image</strong> 使用，内部通过<code>ImageProvider.resolveStreamForKey</code>方法从 <strong>ImageCache</strong> 或者子类指定的途径（比如 NetworkImage 会从网络）加载图片（并保存到 ImageCache）。</p>
<h2 id="ImageState"><a href="#ImageState" class="headerlink" title="_ImageState"></a>_ImageState</h2><p><strong>Image</strong>是 <em>StatefulWidget</em> ，处理 image 的主要逻辑在 <strong>_ImageState</strong> 中：其混入了<strong>WidgetsBindingObserver</strong>以便监听系统生命周期；在内部通过监听<strong>ImageStream</strong>获得<strong>ImageInfo</strong>并最终在<code>_ImageState.build</code>方法中创建<strong>RawImage</strong>；RawImage 是一个<em>LeafRenderObjectWidget</em>，会创建<strong>RenderImage</strong>并在<code>RenderImage.paint</code>根据之前获取的信息调用<code>DecorationImagePainter.paintImage</code>方法通过<code>canvas.drawImageRect</code>绘制图片。</p>
<h3 id="resolveImage"><a href="#resolveImage" class="headerlink" title="_resolveImage"></a>_resolveImage</h3><p>当依赖变化（<code>didChangeDependencies()</code>）、Widget 变化（<code>didUpdateWidget(Image oldWidget)</code>）、以及热更新（<code>reassemble()</code>）时，_ImageState 会执行<code>_resolveImage()</code>方法通过 ImageProvider 获取 ImageStream：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _resolveImage() &#123;</span><br><span class="line">  <span class="comment">// ScrollAwareImageProvider用于防止在快速滑动的时候加载图片</span></span><br><span class="line">    <span class="keyword">final</span> ScrollAwareImageProvider provider = ScrollAwareImageProvider&lt;<span class="built_in">Object</span>&gt;(</span><br><span class="line">      context: _scrollAwareContext,</span><br><span class="line">      imageProvider: widget.image,<span class="comment">// 用户/构造方法指定的ImageProvider</span></span><br><span class="line">    );</span><br><span class="line">  <span class="comment">// 通过ImageProvider获取ImageStream</span></span><br><span class="line">    <span class="keyword">final</span> ImageStream newStream =</span><br><span class="line">      provider.resolve(createLocalImageConfiguration(</span><br><span class="line">        context,</span><br><span class="line">        size: widget.width != <span class="keyword">null</span> &amp;&amp; widget.height != <span class="keyword">null</span> ? Size(widget.width!, widget.height!) : <span class="keyword">null</span>,</span><br><span class="line">      ));</span><br><span class="line">    <span class="keyword">assert</span>(newStream != <span class="keyword">null</span>);</span><br><span class="line">    _updateSourceStream(newStream);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以注意到，当在<code>_resolveImage()</code>中获取到 ImageStream 之后，会通过<code>_updateSourceStream()</code>更新 ImageStream。</p>
<h3 id="updateSourceStream"><a href="#updateSourceStream" class="headerlink" title="_updateSourceStream"></a>_updateSourceStream</h3><p>在此方法中，先是更新了<code>ImageStream? _imageStream</code> 对象，然后根据<code>_isListeningToStream</code>的值执行<code>_imageStream!.addListener(_getListener())</code>更新 ImageStream 的 Listener：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ImageStreamListener _getListener(&#123;<span class="built_in">bool</span> recreateListener = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(_imageStreamListener == <span class="keyword">null</span> || recreateListener) &#123;</span><br><span class="line">      _lastException = <span class="keyword">null</span>;</span><br><span class="line">      _lastStack = <span class="keyword">null</span>;</span><br><span class="line">      _imageStreamListener = ImageStreamListener(</span><br><span class="line">        _handleImageFrame,<span class="comment">// 图片加载成功，使用获得的imageInfo更新RawImage</span></span><br><span class="line">        onChunk: widget.loadingBuilder == <span class="keyword">null</span> ? <span class="keyword">null</span> : _handleImageChunk,<span class="comment">// 展示loading动画</span></span><br><span class="line">        onError: widget.errorBuilder != <span class="keyword">null</span> || kDebugMode</span><br><span class="line">            ? (<span class="built_in">Object</span> error, StackTrace? stackTrace) &#123;</span><br><span class="line">               ...</span><br><span class="line">              &#125;</span><br><span class="line">            : <span class="keyword">null</span>,<span class="comment">// 展示加载失败</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _imageStreamListener!;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <strong>ImageStreamListener</strong> 中，根据 ImageStream 的不同状态分别更新 Image 的显示。</p>
<h3 id="handleImageFrame"><a href="#handleImageFrame" class="headerlink" title="_handleImageFrame"></a>_handleImageFrame</h3><p><code>_handleImageFrame()</code>方法使用 ImageStream 中返回的<strong>ImageInfo</strong>，调用<code>setState</code>方法更新_ImageState 中的<code>ImageInfo? **_imageInfo**</code>属性，从而刷新 Image 展示。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _handleImageFrame(ImageInfo imageInfo, <span class="built_in">bool</span> synchronousCall) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _replaceImage(info: imageInfo);<span class="comment">// 在这里刷新imageInfo，触发重建</span></span><br><span class="line">      _loadingProgress = <span class="keyword">null</span>;</span><br><span class="line">      _lastException = <span class="keyword">null</span>;</span><br><span class="line">      _lastStack = <span class="keyword">null</span>;</span><br><span class="line">      _frameNumber = _frameNumber == <span class="keyword">null</span> ? <span class="number">0</span> : _frameNumber! + <span class="number">1</span>;</span><br><span class="line">      _wasSynchronouslyLoaded = _wasSynchronouslyLoaded | synchronousCall;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _replaceImage(&#123;<span class="keyword">required</span> ImageInfo? info&#125;) &#123;</span><br><span class="line">    _imageInfo?.dispose();</span><br><span class="line">    _imageInfo = info;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>ImageInfo</strong>类内部持有<strong>ui.Image</strong>和其对应的<code>scale</code>，以及一个获取图片像素大小的<code>sizeBytes</code>方法。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ImageInfo: a [dart:ui.Image] object with its corresponding scale.</span></span><br><span class="line">ImageInfo(&#123; <span class="keyword">required</span> <span class="keyword">this</span>.image, <span class="keyword">this</span>.scale = <span class="number">1.0</span>, <span class="keyword">this</span>.debugLabel &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">get</span> sizeBytes =&gt; image.height * image.width * <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>上面分析了_ImageState 如何监听使用 ImageProvider 获取到的 ImageStream，从中获取 ImageInfo 更新自己的 <code>ImageInfo? _imageInfo</code> 属性，那么这个属性是如何影响到我们的 Image 展示图片的呢，关键就在 <code>build</code> 方法中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_lastException != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (widget.errorBuilder != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> widget.errorBuilder!(context, _lastException!, _lastStack);</span><br><span class="line">      <span class="keyword">if</span> (kDebugMode)</span><br><span class="line">        <span class="keyword">return</span> _debugBuildErrorWidget(context, _lastException!);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意_ImageState内部其实是使用ui.Image _imageInfo?.image创建了RawImage来展示图片</span></span><br><span class="line">    Widget result = RawImage(</span><br><span class="line">      <span class="comment">// Do not clone the image, because RawImage is a stateless wrapper.</span></span><br><span class="line">      <span class="comment">// The image will be disposed by this state object when it is not needed</span></span><br><span class="line">      <span class="comment">// anymore, such as when it is unmounted or when the image stream pushes</span></span><br><span class="line">      <span class="comment">// a new image.</span></span><br><span class="line">      image: _imageInfo?.image,<span class="comment">// 这里会在ImageStream获取到ImageInfo之后更新</span></span><br><span class="line">      debugImageLabel: _imageInfo?.debugLabel,</span><br><span class="line">      width: widget.width,</span><br><span class="line">      height: widget.height,</span><br><span class="line">      scale: _imageInfo?.scale ?? <span class="number">1.0</span>,</span><br><span class="line">      color: widget.color,</span><br><span class="line">      opacity: widget.opacity,</span><br><span class="line">      colorBlendMode: widget.colorBlendMode,</span><br><span class="line">      fit: widget.fit,</span><br><span class="line">      alignment: widget.alignment,</span><br><span class="line">      repeat: widget.repeat,</span><br><span class="line">      centerSlice: widget.centerSlice,</span><br><span class="line">      matchTextDirection: widget.matchTextDirection,</span><br><span class="line">      invertColors: _invertColors,</span><br><span class="line">      isAntiAlias: widget.isAntiAlias,</span><br><span class="line">      filterQuality: widget.filterQuality,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!widget.excludeFromSemantics) &#123;</span><br><span class="line">      result = Semantics(</span><br><span class="line">        container: widget.semanticLabel != <span class="keyword">null</span>,</span><br><span class="line">        image: <span class="keyword">true</span>,</span><br><span class="line">        label: widget.semanticLabel ?? <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        child: result,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget.frameBuilder != <span class="keyword">null</span>)</span><br><span class="line">      result = widget.frameBuilder!(context, result, _frameNumber, _wasSynchronouslyLoaded);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widget.loadingBuilder != <span class="keyword">null</span>)</span><br><span class="line">   <span class="comment">// 如果有loadingBuilder就包裹result，所以注意进度为100%时要切换回图片，</span></span><br><span class="line">   <span class="comment">// 否则会一直显示进度，而非加载的图片</span></span><br><span class="line">      result = widget.loadingBuilder!(context, result, _loadingProgress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>ImageInfo.image</code> 是<strong>ui.Image</strong>对象，是原始的 image 像素，通过<strong>RawImage</strong>传入到<code>Canvas.drawImageRect</code>或者<code>Canvas.drawImageNine</code>绘制图片。</p>
<h2 id="RawImage"><a href="#RawImage" class="headerlink" title="RawImage"></a>RawImage</h2><p><em>A widget that displays a <code>[dart:ui.Image]</code> directly.</em></p>
<p>RawImage 继承自 _LeafRenderWidget_，可以直接展示<code>ui.Image</code>的内容，后者是解码的图片数据的不透明句柄（_Opaque handle to raw decoded image data (pixels)_）、是对<code>_Image</code>类的封装、对外提供宽高以及<code>Image.toByteData</code>（将<code>ui.Image</code>对象转化为<code>ByteData</code>，ByteData 可以直接传入<code>Canvas.drawImageRect</code>方法第一个参数）。</p>
<p>RawImage 主要逻辑就是创建&#x2F;更新 RenderImage 的时候将从<code>_ImageState.build</code>方法获得的<code>ui.Image? image</code> 的 clone 传入（其实就是使用<code>ui.Image? image</code>对应的<code>_Image _image</code> 新建了一个 ui.Image，每一个 ui.Image 都是_image 的一个句柄，只有当没有 ui.Image 指向_image 时后者才会真正的 dispose）。</p>
<h2 id="RenderImage"><a href="#RenderImage" class="headerlink" title="RenderImage"></a>RenderImage</h2><p><em>An image in the render tree.</em></p>
<p>RenderImage 作为一个 RenderBox，在从 RawImage 那里拿到<code>ui.Image? _image</code>之后，然后在其<code>RenderImage.paint</code>方法中，会调用<code>paintImage</code>方法绘制<code>_image</code>代表的图片。</p>
<blockquote>
<p>ui.Image实际是ui._Image的包装类，它的width、height、toByteData等方法最终都是调用ui._Image对应的实现。</p>
</blockquote>
<p><code>paintImage</code> 方法是位于 <em>lib\src\painting\decoration_image.dart</em> 的全局方法，在其内部调用 canvas 绘制_image 对应的图片。</p>
<br/>

<p>至此，我们可以看到，在<strong>Image</strong>中，根据构造方法的不同创建了不同的<strong>ImageProvider</strong>对象作为<code>Image.image</code>参数；</p>
<p>然后在 <strong>_ImageState</strong> 中，使用<code>ImageProvider.resolve</code>方法创建并更新<code>ImageStream? _imageStream</code>，并且监听<strong>ImageStream</strong>以便在图片加载成功之后获取<code>ImageInfo? _imageInfo</code>；</p>
<p>这个<strong>ImageInfo</strong>是对<strong>ui.Image</strong>的封装类，在<code>_ImageState.build</code>方法中被传入<strong>RawImage</strong>，后者则创建了<strong>RenderImage</strong>并最终将 ui.Image 的内容绘制在屏幕上面。</p>
<br/>

<h1 id="图片获取与缓存"><a href="#图片获取与缓存" class="headerlink" title="图片获取与缓存"></a>图片获取与缓存</h1><p>到目前为止，我们大体梳理了图片展示的这部分流程，此外，还有一部分同样重要的流程——图片的获取与缓存。</p>
<h2 id="ImageProvider"><a href="#ImageProvider" class="headerlink" title="ImageProvider"></a>ImageProvider</h2><p><strong>ImageProvider</strong> 是获取图片资源的基类，其他类可以调用<code>ImageProvider.resolve</code>方法获取 <strong>ImageStream</strong> ，此方法会调用<code>ImageCache.putIfAbsent</code>优先从 <strong>ImageCache</strong> 中获取，如果没有则调用<code>ImageProvider.load</code>方法获取并缓存到 ImageCache 中。</p>
<p>其子类一般只需要重写<code>ImageProvider</code>的<code>ImageStreamCompleter load(T key, DecoderCallback decode)</code>和<code>Future&lt;T&gt; obtainKey(ImageConfiguration configuration)</code>方法即可。</p>
<p>以<code>NetworkImage</code>加载网络图片的过程为例：</p>
<blockquote>
<p>我们通过<code>NetworkImage()</code>方法获取的实际是<code>network_image.NetworkImage</code>对象。</p>
</blockquote>
<p>当<code>_ImageState._resolveImage()</code>方法调用<code>ImageProvider.resolve</code>方法时，内部会调用<code>ImageProvider.resolveStreamForKey</code>方法，在其内部会执行：</p>
<ul>
<li>通过<code>ImageProvider.obtainKey</code>获取图片对应的 key</li>
<li>执行<code>PaintingBinding.*instance*!.imageCache!.putIfAbsent(key,() =&gt;</code> <code>load(key, PaintingBinding.*instance*!.instantiateImageCodec),onError: handleError,)</code>方法，优先从 imageCache 中获取缓存的图片，没有的话执行<code>ImageProvider.load</code>方法获取图片。</li>
</ul>
<p>对于<code>network_image.NetworkImage</code>对象，他的<code>obtainKey()</code>和<code>load()</code>方法实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkImage</span> <span class="keyword">extends</span> <span class="title">image_provider</span>.<span class="title">ImageProvider</span>&lt;<span class="title">image_provider</span>.<span class="title">NetworkImage</span>&gt; <span class="keyword">implements</span> <span class="title">image_provider</span>.<span class="title">NetworkImage</span> </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> NetworkImage(<span class="keyword">this</span>.url, &#123; <span class="keyword">this</span>.scale = <span class="number">1.0</span>, <span class="keyword">this</span>.headers &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line">  Future&lt;NetworkImage&gt; obtainKey(image_provider.ImageConfiguration configuration) &#123;</span><br><span class="line">    <span class="comment">// 注意这里的key是NetworkImage对象，也就是说网络图片加载的url，scale，</span></span><br><span class="line">    <span class="comment">// header等一致的话才会被认为命中缓存</span></span><br><span class="line">    <span class="keyword">return</span> SynchronousFuture&lt;NetworkImage&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line">  ImageStreamCompleter load(image_provider.NetworkImage key, image_provider.DecoderCallback decode) &#123;</span><br><span class="line">    <span class="comment">// Ownership of this controller is handed off to [_loadAsync]; it is that</span></span><br><span class="line">    <span class="comment">// method&#x27;s responsibility to close the controller&#x27;s stream when the image</span></span><br><span class="line">    <span class="comment">// has been loaded or an error is thrown.</span></span><br><span class="line">    <span class="keyword">final</span> StreamController&lt;ImageChunkEvent&gt; chunkEvents = StreamController&lt;ImageChunkEvent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiFrameImageStreamCompleter(</span><br><span class="line">      codec: _loadAsync(key <span class="keyword">as</span> NetworkImage, chunkEvents, decode),<span class="comment">// 真正从网络加载图片的方法</span></span><br><span class="line">      chunkEvents: chunkEvents.stream,</span><br><span class="line">      scale: key.scale,</span><br><span class="line">      debugLabel: key.url,</span><br><span class="line">      informationCollector: () =&gt; &lt;DiagnosticsNode&gt;[</span><br><span class="line">        DiagnosticsProperty&lt;image_provider.ImageProvider&gt;(<span class="string">&#x27;Image provider&#x27;</span>, <span class="keyword">this</span>),</span><br><span class="line">        DiagnosticsProperty&lt;image_provider.NetworkImage&gt;(<span class="string">&#x27;Image key&#x27;</span>, key),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这其中，<code>network_image.NetworkImage._loadAsync()</code>方法才是真正使用<code>HttpClient</code>从网上获取图片资源的方法（实际上 AssetBundleImageProvider、FileImage 和 MemoryImage 等一众 ImageProvider 等都约定俗成在<code>_loadAsync</code> 中执行真正获取图片的逻辑），返回值 Future&lt;ui.Codec&gt;和 ui.Image 的关系如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;ui.Image&gt; decodeImageFromList(Uint8List bytes) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> ui.Codec codec = <span class="keyword">await</span> PaintingBinding.instance.instantiateImageCodec(bytes);</span><br><span class="line">  <span class="keyword">final</span> ui.FrameInfo frameInfo = <span class="keyword">await</span> codec.getNextFrame();</span><br><span class="line">  <span class="keyword">return</span> frameInfo.image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ImageCache"><a href="#ImageCache" class="headerlink" title="ImageCache"></a>ImageCache</h2><p><em>Class for caching images.</em></p>
<p>在上面方分析 ImageProvider 的时候，我们注意到，每次通过<code>ImageProvider.resolveStreamForKey</code>方法获取 ImageStream 时，都会调用<code>PaintingBinding.instance!.imageCache.putIfAbsent</code>方法优先获取<strong>Image 对象的缓存</strong>，这就涉及到和 Image 缓存有关的类——<strong>ImageCache</strong>。</p>
<p>ImageCache 对象全局唯一，使用 LRU 算法最多缓存<strong>1000 张或者最大 100MB 图片</strong>，可以分别使用<code>maximumSize</code>和<code>maximumSizeBytes</code>修改配置。</p>
<p>其内部维持有三个 Map：</p>
<ul>
<li><code>Map&lt;Object, PendingImage&gt; _pendingImages</code> 正在加载中的图片，可能可能同时也是<code>_liveImage</code>（对应的 ImageStream 已经被监听了）。</li>
<li><code>Map&lt;Object, _CachedImage&gt; _cache</code> 缓存的图片，maximumSize 和 maximumSizeBytes 限制针对的是<code>_cache</code>。</li>
<li><code>Map&lt;Object, _LiveImage&gt; _liveImages</code> 正在使用的图片，他的 ImageStreamCompleters 至少有一个 listener，可能同时在<code>_pendingImages</code>（所以这里的_LiveImage 的<code>sizeBytes</code>可能为 null）或者<code>_liveImages</code>中。</li>
</ul>
<p><code>_CachedImage</code>和<code>_LiveImage</code>都继承自<code>_CachedImageBase</code>，其内部持有<code>ImageStreamCompleter</code>，图片的 handler<code>ImageStreamCompleterHandle</code>，以及图片大小<code>sizeBytes</code>。</p>
<p><code>ImageCacheStatus</code>处理 ImageCache 缓存的图片状态：</p>
<ul>
<li><code>pending</code>，还没有加载完成的 image，如果被监听的话，还会是<code>live</code>的</li>
<li><code>keepAlive</code>，图片会被<code>ImageCache._cache</code>保存。可能是 live 的，但不会 pending 的。</li>
<li><code>live</code>，图片会一直被持有，除非<code>ImageStreamCompleter</code>没有 listener 了。可能是 pending 的，也可能是 keepAlive 的</li>
<li><code>untracked</code>，不会被缓存的图片（上述三值都为 false）。</li>
</ul>
<p>可以使用<code>ImageCache.statusForKey</code>或者<code>ImageProvider.obtainCacheStatus</code>获取图片状态<code>ImageCacheStatus</code>。</p>
<p>当 ImageProvider 调用<code>ImageCache.putIfAbsent</code>方法获取 ImageStreamCompleter 时，会依次尝试从<code>_pendingImages</code> 、<code>_cache</code> 、<code>_liveImages</code> 中读取，如果都没有则会尝试执行传入的 loader 方法获取。</p>
<br/>

<p>可以看到，以从网络加载图片为例，Flutter 原生提供的 Image 只有内存中的 ImageCache 一级缓存，如果 ImageCache 没有指定的图片（首次加载或者缓存被清空）则会再次从网络加载，这会导致多图列表的时候图片被频繁的回收&#x2F;重新下载，从而影响用户体验。</p>
<p>为了解决上述问题，涌现了很多第三方图片加载控件：</p>
<ul>
<li><a href="https://github.com/fluttercandies/extended_image">extended_image</a> 对官方 Image 的二次开发，增加了磁盘缓存。</li>
<li><a href="https://github.com/Baseflow/flutter_cached_network_image">flutter_cached_network_image</a> 使用<em>sqflite 数据库</em>管理缓存的<strong>网络图片加载</strong>库，增加了磁盘缓存。</li>
<li><a href="https://github.com/alibaba/power_image">power_image</a> 使用于<strong>混合项目</strong>的图片加载库，提供<em>ffi</em>和<em>texture</em>两种图片展示方式，依赖于原生图片加载库（比如<em>Glide</em>）加载图片、管理缓存。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单总结一下 Flutter 原生 Image 组件加载图片的流程：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_image_class_structure.png" alt="flutter_image_class_structure.png"></p>
<p>简单来说如下：</p>
<ul>
<li>用户通过 Image Widget 的各个构造方法创建指定的 ImageProvider；</li>
<li>在_ImageState 中使用<code>ImageProvider.resolve(ImageConfiguration)</code>获取并监听 ImageStream（listener 为 ImageStreamListener）；</li>
<li>ImageProvider 会按照传入的 ImageConfiguration 生成的 key 在 ImageCache 中查找对应的缓存，没有的话则先加载再缓存；</li>
<li>当 ImageProvider 成功加载图片时，ImageStreamListener 获得 ImageInfo 时，并触发<code>_ImageState.build()</code>方法将<code>ui.Image _imageInfo?.image</code>传入 RawImage 中；</li>
<li>作为一个 LeafRenderObjectWidget，RawImage 创建 RenderImage 并传入<code>ui.Image? image?.clone()</code>作为<code>RenderImage.image</code>，此后再在<code>RenderImage.paint</code>方法中调用系统的<code>paintImage()</code>方法通过<code>canvas.drawImageRect</code>绘制图片内容。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://api.flutter.dev/flutter/widgets/Image-class.html">Image_api.flutter.dev</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter图片加载方案分析之extended_image</title>
    <url>/blog/posts/23ac516a/</url>
    <content><![CDATA[<p>Flutter 默认提供了<strong>Image</strong>用于从网络、文件等加载图片，并且使用<strong>ImageCache</strong>统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了<a href="https://github.com/Baseflow/flutter_cache_manager/tree/master">flutter_cache_manager</a>、<a href="https://github.com/fluttercandies/extended_image">extended_image</a>等基于 Flutter 原生的解决方案，以及<a href="https://github.com/alibaba/power_image">power_image</a>等基于混合开发的解决方案。</p>
<p>本文对 Flutter 中的 extended_image 加载过程、原理做一简单分析。</p>
<h1 id="extended-image"><a href="#extended-image" class="headerlink" title="extended_image"></a>extended_image</h1><p><a href="https://github.com/fluttercandies/extended_image">extended_image</a>是基于官方 Image 的拓展组件，支持加载以及失败显示，缓存网络图片，缩放拖拽图片，图片浏览(微信掘金效果)，滑动退出页面(微信掘金效果)，编辑图片(裁剪旋转翻转)，保存，绘制自定义效果等功能。</p>
<p>本文主要对其<strong>加载缓存网络图片</strong>的流程做一分析，因为这个库是官方 Image 的拓展，所以我们会在之前<a href="https://xiaoyong.ml/blog/posts/1912667a/">对 Image 的分析</a>基础上进行对比分析。</p>
<p>extended_image 的架构图如下：</p>
<p><img src="https://jixiaoyong.github.io/images/extended_image_class_structure.png" alt="extended_image_class_structure"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>因为 extended_image 的定位是官方 Image 的拓展版，所以大部分使用方式和官方类似。</p>
<h2 id="ExtendedImage"><a href="#ExtendedImage" class="headerlink" title="ExtendedImage"></a>ExtendedImage</h2><p>他的构造函数分别是：</p>
<ul>
<li>ExtendedImage</li>
<li>ExtendedImage.asset</li>
<li>ExtendedImage.file</li>
<li>ExtendedImage.memory</li>
<li>ExtendedImage.network</li>
</ul>
<p>同样是在构造函数中指定并创建 ImageProvider，不过 extented_image 库的 ImageProvider 都是继承自官方 ImageProvider 并且混入了<strong>ExtendedImageProvider</strong>的子类。以<code>ExtendedImage.network</code>为例，创建的 ImageProvider 类型是<strong>ExtendedNetworkImageProvider</strong>。</p>
<p>其余的步骤和我们之前分析的官方 Image 组件类似，在 <strong>_ExtendedImageState</strong> 中使用 <strong>ImageProvider</strong> 获取并监听 <strong>ImageStream</strong>，当成功加载图片之后获得<code>ImageInfo? _imageInfo</code>并刷新页面，在<code>_ExtendedImageState.build</code>方法中，虽然 extended_image 增加了一些特有的加载中、加载失败、手势等封装，但最后还是使用<code>ImageInfo.image</code>创建<strong>ExtendedRawImage</strong>以展示图片内容。</p>
<p>如此可见，在从网络加载图片这部分内容来看，ExtendedImage 和 Image 的主要不同在于<strong>ExtendedNetworkImageProvider</strong>的实现：</p>
<h2 id="ExtendedNetworkImageProvider"><a href="#ExtendedNetworkImageProvider" class="headerlink" title="ExtendedNetworkImageProvider"></a>ExtendedNetworkImageProvider</h2><blockquote>
<p>这部分内容的代码在<a href="https://github.com/fluttercandies/extended_image_library">extended_image_library</a>中。</p>
</blockquote>
<p>ExtendedNetworkImageProvider 继承自<strong>ImageProvider</strong>，混入了<strong>ExtendedImageProvider</strong>，后者提供了<code>get imageCache</code>&#x2F;<code>instantiateImageCodec</code>&#x2F;<code>resolveStreamForKey</code>等一系列通用方法。</p>
<p>下面是 ExtendedNetworkImageProvider 的源码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedNetworkImageProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">ExtendedNetworkImageProvider</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">ExtendedImageProvider</span>&lt;<span class="title">ExtendedNetworkImageProvider</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">factory</span> ExtendedNetworkImageProvider(</span><br><span class="line">    <span class="built_in">String</span> url, &#123;</span><br><span class="line">    <span class="built_in">double</span> scale,</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;? headers,</span><br><span class="line">    <span class="built_in">bool</span> cache,</span><br><span class="line">    <span class="built_in">int</span> retries,</span><br><span class="line">    <span class="built_in">Duration?</span> timeLimit,</span><br><span class="line">    <span class="built_in">Duration</span> timeRetry,</span><br><span class="line">    CancellationToken? cancelToken,</span><br><span class="line">    <span class="built_in">String?</span> cacheKey,</span><br><span class="line">    <span class="built_in">bool</span> printError,</span><br><span class="line">    <span class="built_in">bool</span> cacheRawData,</span><br><span class="line">    <span class="built_in">String?</span> imageCacheName,</span><br><span class="line">    <span class="built_in">Duration?</span> cacheMaxAge,</span><br><span class="line">  &#125;) = network_image.ExtendedNetworkImageProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExtendedNetworkImageProvider 是个抽象类，他的逻辑在<code>network_image.ExtendedNetworkImageProvider</code>中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;extended_network_image_provider.dart&#x27;</span> <span class="keyword">as</span> image_provider;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedNetworkImageProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">image_provider</span>.<span class="title">ExtendedNetworkImageProvider</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">ExtendedImageProvider</span>&lt;<span class="title">image_provider</span>.<span class="title">ExtendedNetworkImageProvider</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">image_provider</span>.<span class="title">ExtendedNetworkImageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法获取的图片会被ImageProvider缓存到ImageCache中</span></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    ImageStreamCompleter load(</span><br><span class="line">      image_provider.ExtendedNetworkImageProvider key, DecoderCallback decode) &#123;</span><br><span class="line">    <span class="keyword">final</span> StreamController&lt;ImageChunkEvent&gt; chunkEvents =</span><br><span class="line">        StreamController&lt;ImageChunkEvent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiFrameImageStreamCompleter(</span><br><span class="line">      codec: _loadAsync(<span class="comment">// 调用_loadAsync方法加载图片</span></span><br><span class="line">        key <span class="keyword">as</span> ExtendedNetworkImageProvider,</span><br><span class="line">        chunkEvents,</span><br><span class="line">        decode,</span><br><span class="line">      ),</span><br><span class="line">      scale: key.scale,</span><br><span class="line">      chunkEvents: chunkEvents.stream,</span><br><span class="line">      informationCollector: () &#123;</span><br><span class="line">       ...</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    Future&lt;ui.Codec&gt; _loadAsync(</span><br><span class="line">    ExtendedNetworkImageProvider key,</span><br><span class="line">    StreamController&lt;ImageChunkEvent&gt; chunkEvents,</span><br><span class="line">    DecoderCallback decode,</span><br><span class="line">  ) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span>(key == <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> md5Key = cacheKey ?? keyToMd5(key.url);</span><br><span class="line">    ui.Codec? result;</span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果需要缓存图片，就调用_loadCache优先从缓存中读取，没有的话先从网络下载，</span></span><br><span class="line">        <span class="comment">// 成功之后再缓存到本地缓存文件目录</span></span><br><span class="line">        <span class="keyword">final</span> Uint8List? data = <span class="keyword">await</span> _loadCache(</span><br><span class="line">          key,</span><br><span class="line">          chunkEvents,</span><br><span class="line">          md5Key,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析加载的图片信息</span></span><br><span class="line">          result = <span class="keyword">await</span> instantiateImageCodec(data, decode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (printError) &#123;</span><br><span class="line">          <span class="built_in">print</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不需要缓存或者从缓存中读取/下载失败了，就从网络加载</span></span><br><span class="line">        <span class="keyword">final</span> Uint8List? data = <span class="keyword">await</span> _loadNetwork(</span><br><span class="line">          key,</span><br><span class="line">          chunkEvents,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">          result = <span class="keyword">await</span> instantiateImageCodec(data, decode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (printError) &#123;</span><br><span class="line">          <span class="built_in">print</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是失败，就展示失败信息</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//result = await ui.instantiateImageCodec(kTransparentImage);</span></span><br><span class="line">      <span class="keyword">return</span> Future&lt;ui.Codec&gt;.error(StateError(<span class="string">&#x27;Failed to load <span class="subst">$url</span>.&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看到，如果需要缓存时，除了 ImageCache 本身的缓存外，ExtendedNetworkImageProvider 还会执行<code>_loadCache</code>尝试从本地文件中读取缓存：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;Uint8List?&gt; _loadCache(</span><br><span class="line">    ExtendedNetworkImageProvider key,</span><br><span class="line">    StreamController&lt;ImageChunkEvent&gt;? chunkEvents,</span><br><span class="line">    <span class="built_in">String</span> md5Key,</span><br><span class="line">  ) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Directory _cacheImagesDirectory = Directory(</span><br><span class="line">        join((<span class="keyword">await</span> getTemporaryDirectory()).path, cacheImageFolderName));</span><br><span class="line">    Uint8List? data;</span><br><span class="line">    <span class="comment">// 1. 先尝试从缓存文件中读取图片</span></span><br><span class="line">    <span class="keyword">if</span> (_cacheImagesDirectory.existsSync()) &#123;</span><br><span class="line">      <span class="keyword">final</span> File cacheFlie = File(join(_cacheImagesDirectory.path, md5Key));</span><br><span class="line">      <span class="keyword">if</span> (cacheFlie.existsSync()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.cacheMaxAge != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="built_in">DateTime</span> now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">          <span class="keyword">final</span> FileStat fs = cacheFlie.statSync();</span><br><span class="line">          <span class="keyword">if</span> (now.subtract(key.cacheMaxAge!).isAfter(fs.changed)) &#123;</span><br><span class="line">            cacheFlie.deleteSync(recursive: <span class="keyword">true</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="keyword">await</span> cacheFlie.readAsBytes();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          data = <span class="keyword">await</span> cacheFlie.readAsBytes();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create folder</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> _cacheImagesDirectory.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load from network</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1 缓存不存在或者读取失败，先仅从网络加载图片</span></span><br><span class="line">      data = <span class="keyword">await</span> _loadNetwork(</span><br><span class="line">        key,</span><br><span class="line">        chunkEvents,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cache image file</span></span><br><span class="line">        <span class="comment">// 2.2 如果从网络成功加载图片，则将图片写入文件缓存</span></span><br><span class="line">        <span class="keyword">await</span> File(join(_cacheImagesDirectory.path, md5Key)).writeAsBytes(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中执行到的<code>ExtendedNetworkImageProvider._loadNetwork()</code>方法只会使用<code>HttpClient</code>从网络中下载图片并返回。</p>
<h2 id="ExtendedImageProvider"><a href="#ExtendedImageProvider" class="headerlink" title="ExtendedImageProvider"></a>ExtendedImageProvider</h2><p>此外，之前提到的<code>ExtendedImageProvider</code>为 extended_image 库中的 ImageProvider 提供了一些通用的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The cached raw image data 缓存图片原始数据，而不必每次都使用ui.Image.toByteData()获取</span></span></span><br><span class="line"><span class="built_in">Map</span>&lt;ExtendedImageProvider&lt;<span class="built_in">dynamic</span>&gt;, Uint8List&gt; rawImageDataMap =</span><br><span class="line">    &lt;ExtendedImageProvider&lt;<span class="built_in">dynamic</span>&gt;, Uint8List&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The imageCaches to store custom ImageCache，缓存ImageCache</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">可以指定一个 ImageCache 来缓存一些图片。这样可以一起处理它们，不会影响其他的图片缓存.</span></span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ImageCache&gt; imageCaches = &lt;<span class="built_in">String</span>, ImageCache&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> ExtendedImageProvider&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt; <span class="keyword">on</span> ImageProvider&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">bool</span> <span class="keyword">get</span> cacheRawData;</span><br><span class="line">    <span class="built_in">String?</span> <span class="keyword">get</span> imageCacheName;</span><br><span class="line">    ImageCache <span class="keyword">get</span> imageCache &#123;</span><br><span class="line">    <span class="keyword">if</span> (imageCacheName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> imageCaches.putIfAbsent(imageCacheName!, () =&gt; ImageCache());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> PaintingBinding.instance.imageCache;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还改动了<code>ExtendedImageProvider.resolveStreamForKey</code>方法以使用指定的 ImageCache。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> resolveStreamForKey(</span><br><span class="line">    ImageConfiguration configuration,</span><br><span class="line">    ImageStream stream,</span><br><span class="line">    T key,</span><br><span class="line">    ImageErrorListener handleError,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is an unusual edge case where someone has told us that they found</span></span><br><span class="line">    <span class="comment">// the image we want before getting to this method. We should avoid calling</span></span><br><span class="line">    <span class="comment">// load again, but still update the image cache with LRU information.</span></span><br><span class="line">    <span class="keyword">if</span> (stream.completer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> ImageStreamCompleter? completer = imageCache.putIfAbsent(</span><br><span class="line">        key,</span><br><span class="line">        () =&gt; stream.completer!,</span><br><span class="line">        onError: handleError,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">assert</span>(identical(completer, stream.completer));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ImageStreamCompleter? completer = imageCache.putIfAbsent(</span><br><span class="line">      key,</span><br><span class="line">      () =&gt; load(key, PaintingBinding.instance.instantiateImageCodec),</span><br><span class="line">      onError: handleError,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (completer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stream.setCompleter(completer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>综上所见，ExtendedImageProvider 的主要作用是借助<code>rawImageDataMap</code>提供了缓存图片原始数据的功能，此外还提供了一个 ImageCache 分组的方法，以便对一部分图片缓存统一处理。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>仅就从网络加载图片而言，extended_image 和 Flutter 官方 Image 组件的主要区别在于：在 ImageCache 之外，<strong>多了一层本地磁盘缓存</strong>，如果这二者都未命中缓存则从网络下载图片。</p>
<p>除此之外，extended_image 本身还提供了诸如图片缩放拖拽、滑动退出等图片操作常用的“大而全”的功能。这部分见仁见智，如果 APP 需求刚好需要用到这些功能的话，extended_image 是个不错的选择，但是如果只是想解决图片缓存问题的话，可能会显得有些臃肿。</p>
<p>另外一个常用的图片库<a href="https://github.com/fluttercandies/extended_image">flutter_cached_network_image</a>则是借助<a href="https://github.com/Baseflow/flutter_cache_manager">flutter_cache_manager</a>实现缓存网络图片的功能，相对比较轻量。</p>
<p>上述两种库都是基于 Flutter Image 组件实现图片加载、缓存，阿里巴巴出品的<a href="https://github.com/alibaba/power_image">power_image</a>则是一款为 Flutter-Native 混合项目开发的图片加载库，借助 Texture 和 ffi 通过 Native 端已有的图片加载库完成图片加载、缓存的功能，Flutter 端只负责展示（以及 ImageCache 缓存）。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/fluttercandies/extended_image">extended_image</a></p>
<p><a href="https://github.com/fluttercandies/extended_image_library">extended_image_library</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter滑动分析之NestedScrollView</title>
    <url>/blog/posts/ae8e53be/</url>
    <content><![CDATA[<p>Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：</p>
<ul>
<li>基于 RenderBox 的 box protocol 实现的，主要基于 Size 实现布局。常见的有<a href="https://xiaoyong.ml/blog/posts/d3bdcb53/">SingleChildScrollView</a>。</li>
<li>基于 RenderSliver 的 sliver protocol 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自<a href="https://xiaoyong.ml/blog/posts/60f8d92f/">ScrollView</a>的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。</li>
</ul>
<p>上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。</p>
<p>本文只对 NestedScrollView 的源码实现做一简单分析：它是如何实现联动滚动效果，有什么优势和限制。</p>
<p>官方对其定义是：“A scrolling view inside of which can be nested other scrolling views, with their scroll positions being intrinsically linked.”。</p>
<p>顾名思义，NestedScrollView 是一个可以在<strong>内部嵌套其他 scrolling views 的滑动 View</strong>，按照所处位置的不同，使用<code>headerSliverBuilder</code>提供 header 部分的 scrolling views（限制只能是可以产生 RenderSliver 的 widget），而使用<code>body</code>提供在填充 header 之下所有区域的 widget（限制只能是产生 RenderBox 的 widget）。</p>
<h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><p>下面是一个 NestedScrollView 经典的使用方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">var</span> _tabBar = TabBar(</span><br><span class="line">    isScrollable: <span class="keyword">true</span>,</span><br><span class="line">    tabs: tabs</span><br><span class="line">        .map((e) =&gt; Tab(</span><br><span class="line">              child: Container(</span><br><span class="line">                height: <span class="built_in">double</span>.infinity,</span><br><span class="line">                child: Center(child: Text(<span class="string">&quot;Tab<span class="subst">$e</span>&quot;</span>)),</span><br><span class="line">              ),</span><br><span class="line">            ))</span><br><span class="line">        .toList(),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    body: DefaultTabController(<span class="comment">// 此处的controller是给TabBar和TabBarView使用的</span></span><br><span class="line">        length: tabs.length,</span><br><span class="line">        child: NestedScrollView(</span><br><span class="line">          headerSliverBuilder: (context, innerScroll) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="comment">// 必须是能够产生RenderSliver的Widget</span></span><br><span class="line">              SliverAppBar(</span><br><span class="line">                pinned: <span class="keyword">true</span>,</span><br><span class="line">                toolbarHeight: <span class="number">0</span>,</span><br><span class="line">                expandedHeight: <span class="number">200</span>,</span><br><span class="line">                bottom: _tabBar,<span class="comment">//在这里传入TabBar</span></span><br><span class="line">              ),</span><br><span class="line">            ];</span><br><span class="line">          &#125;,</span><br><span class="line">          body: TabBarView(<span class="comment">// body必须是能产生RenderBox的widget</span></span><br><span class="line">              children: tabs</span><br><span class="line">                  .map((e) =&gt; ListView(<span class="comment">// 这里的列表滑动和header的滑动联动</span></span><br><span class="line">                        children: <span class="built_in">List</span>.generate(</span><br><span class="line">                            <span class="number">100</span>,</span><br><span class="line">                            (index) =&gt; SizedBox(</span><br><span class="line">                                height: <span class="number">80</span>,</span><br><span class="line">                                child: Text(<span class="string">&quot;Hello TabBarView <span class="subst">$e</span>   <span class="subst">$index</span>&quot;</span>))),</span><br><span class="line">                      ))</span><br><span class="line">                  .toList()),</span><br><span class="line">        )),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，NestedScrollView 包括了 headerSliverBuilder 创建的 header 部分，以及 header 下面的 body 部分，二者的滑动效果联动在一起，好像是同一个 scrolling view。比如，当向上滑动 TabBarView 中列表时，会先向上滑动 header 内容，等到 header 无需再滑动才会向上滑动列表。而如果没有 NestedScrollView 的话，ListView 和 header 的滑动是独立的两个事件。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>NestedScrollView 本质上还是对 CustomScrollView（的子类_NestedScrollViewCustomScrollView）的进一步封装。</p>
<p>它借助于_NestedScrollCoordinator 的<code>_outerController</code> 和<code>_innerController</code> 这两个分别传入_NestedScrollViewCustomScrollView（header 和 body 其实是他的 <code>slivers</code>，其最大滑动范围为 header 的 scrollExtent） 和 body 中的 scrolling view（其最大滑动范围为内部滑动视图最大滑动范围之和） 的 ScrollController，创建并应用_NestedScrollPosition；当用户滑动等事件发生，通过_NestedScrollViewCustomScrollView 的_NestedScrollPosition 接收外部所有的滑动事件全部归集到_NestedScrollCoordinator （比如 applyUserOffset 方法）统一处理，按照 ScrollPhysics 等分别修改 header 和 body 的 ScrollPosition，从而实现了这两处滑动事件的联动。</p>
<p>所以，在分析 NestedScrollView 的时候，主要涉及到以下类：</p>
<ul>
<li><strong>NestedScrollViewState</strong>：是 NestedScrollView 真正执行逻辑的类，将_NestedScrollCoordinator、_NestedScrollViewCustomScrollView、ScrollController 等组装在一起，对外暴露操纵_NestedScrollCoordinator 的方法</li>
<li>_NestedScrollViewCustomScrollView：继承自 CustomScrollView，主要作用是创建自定义的 NestedScrollViewViewport，后者又创建了 RenderNestedScrollViewViewport 主要用途是更新 SliverOverlapAbsorberHandle</li>
<li><strong>_NestedScrollCoordinator</strong>：处理_NestedScrollPosition 转发过来的滑动事件，将其分发给 header（其实是容纳 header 和 body 的_NestedScrollViewCustomScrollView）和 body。</li>
<li><strong>_NestedScrollController</strong>：给_NestedScrollCoordinator 的 inner 和 outer 的 ScrollController，内部创建_NestedScrollPosition。</li>
<li><strong>_NestedScrollPosition</strong>：给_NestedScrollCoordinator 的 inner 和 outer 的 ScrollPosition，会将 animateTo、jumpTo、pointerScroll、updateCanDrag、hold、drag 等和滑动有关的事件转发给_NestedScrollCoordinator 统一处理。</li>
<li>其余辅助类</li>
</ul>
<p>下面对这些类逐一分析：</p>
<h2 id="NestedScrollViewState"><a href="#NestedScrollViewState" class="headerlink" title="NestedScrollViewState"></a>NestedScrollViewState</h2><p>NestedScrollView 是 StatefulWidget，其主要逻辑都在创建的 State——NestedScrollViewState 中。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedScrollView</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; _buildSlivers(BuildContext context, ScrollController innerController, <span class="built_in">bool</span> bodyIsScrolled) &#123;</span><br><span class="line">    <span class="comment">// _buildSlivers的主轴尺寸为header的scrollExtent+viewport主轴尺寸，所以创建好的viewport滑动范围</span></span><br><span class="line">    <span class="comment">// 为header的滑动scrollExtent</span></span><br><span class="line">    <span class="keyword">return</span> &lt;Widget&gt;[</span><br><span class="line">      ...headerSliverBuilder(context, bodyIsScrolled),<span class="comment">// header部分</span></span><br><span class="line">      SliverFillRemaining(<span class="comment">//body部分，其尺寸为所处的viewport的主轴尺寸</span></span><br><span class="line">        child: PrimaryScrollController(</span><br><span class="line">          controller: innerController,</span><br><span class="line">          child: body,<span class="comment">// SliverFillRemaining只能容纳可以产生RenderBox的widget</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  NestedScrollViewState createState() =&gt; NestedScrollViewState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NestedScrollView._buildSlivers 方法将 headerSliverBuilder 创建的 header 和 body 放到一个列表中，会被 NestedScrollViewState 传入到自定义的 CustomScrollView——_NestedScrollViewCustomScrollView 中。</p>
<p>需要注意 SliverFillRemaining 默认会创建_SliverFillRemainingWithScrollable，后者创建的 RenderObject 是_SliverFillRemainingWithScrollable。在 RenderSliverFillRemainingWithScrollable.performLayout 方法会使用他所处 viewport 主轴方向的尺寸作为自己的 scrollExtent。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">  <span class="keyword">final</span> SliverConstraints constraints = <span class="keyword">this</span>.constraints;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> extent = constraints.remainingPaintExtent - math.min(constraints.overlap, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    child!.layout(constraints.asBoxConstraints(</span><br><span class="line">      minExtent: extent,</span><br><span class="line">      maxExtent: extent,</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> paintedChildSize = calculatePaintOffset(constraints, from: <span class="number">0.0</span>, to: extent);</span><br><span class="line">  <span class="keyword">assert</span>(paintedChildSize.isFinite);</span><br><span class="line">  <span class="keyword">assert</span>(paintedChildSize &gt;= <span class="number">0.0</span>);</span><br><span class="line">  geometry = SliverGeometry(</span><br><span class="line">    scrollExtent: constraints.viewportMainAxisExtent,<span class="comment">// 这里使用的是viewport的主轴尺寸</span></span><br><span class="line">    paintExtent: paintedChildSize,</span><br><span class="line">    maxPaintExtent: paintedChildSize,</span><br><span class="line">    hasVisualOverflow: extent &gt; constraints.remainingPaintExtent || constraints.scrollOffset &gt; <span class="number">0.0</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    setChildParentData(child!, constraints, geometry!);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说无论 inner scrolling view 的尺寸如何，它（下面称其为 body）占用的 scrollExtent 都是所处的 viewport 的主轴尺寸 mainAxisExtent；再加上 headerSliverBuilder 方法创建的 header，导致_NestedScrollViewCustomScrollView 所创建的 viewport 的最大可滑动范围_maxScrollExtent（其值等于 header+body 的 scrollExtent）一定大于 viewport 的主轴方向尺寸 mainAxisExtent，从而计算出_NestedScrollViewCustomScrollView 的 ScrollPosition 的最大滑动范围（maxScrollExtent）为:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_outScrollPosition.maxScrollExtent = viewport._maxScrollExtent - viewport.mainAxisExtent</span><br><span class="line">                = (body.scrollExtent + header.scrollExtent) - viewport.mainAxisExtent</span><br><span class="line">                = (viewport.mainAxisExtent + header.scrollExtent) - viewport.mainAxisExtent</span><br><span class="line">                = header.scrollExtent</span><br></pre></td></tr></table></figure>

<p>所以，无论 NestedScrollView 的 body 内容尺寸如何，它为 header+body 分配的尺寸只比 viewport 的尺寸多出一个 header 的尺寸。这个也是 NestedScrollView 实现协调 header 和 body 滑动的基础。</p>
<p>让我们再看一下 NestedScrollViewState 的实现：</p>
<p>NestedScrollViewState 中一个重要的属性就是<code>_NestedScrollCoordinator? _coordinator</code>，它在<code>initState()</code>方法中初始化。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedScrollViewState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NestedScrollView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// inner和outer controller都来自_coordinator</span></span><br><span class="line">  ScrollController <span class="keyword">get</span> innerController =&gt; _coordinator!._innerController;</span><br><span class="line">  ScrollController <span class="keyword">get</span> outerController =&gt; _coordinator!._outerController;</span><br><span class="line"></span><br><span class="line">  _NestedScrollCoordinator? _coordinator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _coordinator = _NestedScrollCoordinator(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      widget.controller,<span class="comment">// 注意这里传入了widget处获取的controller</span></span><br><span class="line">      _handleHasScrolledBodyChanged,</span><br><span class="line">      widget.floatHeaderSlivers,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能注意到，_NestedScrollCoordinator 中持有了 widget.controller，并且还会在 didChangeDependencies、didUpdateWidget 方法被调用时通过_NestedScrollCoordinator.setParent 方法更新，主要有两个作用：1. 获取 initialScrollOffset；2. 通过_outerPosition?.setParent 使得 widget.controller 可以监听 outerPosition 的变化。</p>
<p>然后，在 NestedScrollViewState.build 方法中，会创建_NestedScrollViewCustomScrollView 对象：</p>
<ul>
<li><p>将_coordinator!._outerController 作为其 controller，这样会创建，_outerPosition,后者会将_NestedScrollViewCustomScrollView 的事件转发给_coordinator,这样其接管了外层的滑动事件；</p>
</li>
<li><p>此外在 NestedScrollView._buildSlivers 方法中创建的 header 和 body 作为_NestedScrollViewCustomScrollView 也就是 CustomScrollView 的 slivers。</p>
<p>这也是创建 header 的<strong>NestedScrollView.headerSliverBuilder 只接受可以创建 RenderSliver 的 widget</strong>的原因。</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">final</span> ScrollPhysics scrollPhysics = widget.physics?.applyTo(<span class="keyword">const</span> ClampingScrollPhysics())</span><br><span class="line">    ?? widget.scrollBehavior?.getScrollPhysics(context).applyTo(<span class="keyword">const</span> ClampingScrollPhysics())</span><br><span class="line">    ?? <span class="keyword">const</span> ClampingScrollPhysics();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _InheritedNestedScrollView(</span><br><span class="line">    state: <span class="keyword">this</span>,</span><br><span class="line">    child: Builder(</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        _lastHasScrolledBody = _coordinator!.hasScrolledBody;</span><br><span class="line">        <span class="keyword">return</span> _NestedScrollViewCustomScrollView(</span><br><span class="line">          dragStartBehavior: widget.dragStartBehavior,</span><br><span class="line">          scrollDirection: widget.scrollDirection,</span><br><span class="line">          reverse: widget.reverse,</span><br><span class="line">          physics: scrollPhysics,</span><br><span class="line">          scrollBehavior: widget.scrollBehavior ?? ScrollConfiguration.of(context).copyWith(scrollbars: <span class="keyword">false</span>),</span><br><span class="line">          <span class="comment">// 注意这里使用的从_coordinator获取的_outerController</span></span><br><span class="line">          controller: _coordinator!._outerController,</span><br><span class="line">          <span class="comment">// 这里将header和body传入slivers，</span></span><br><span class="line">          <span class="comment">// _NestedScrollViewCustomScrollView创建的viewport是继承自</span></span><br><span class="line">          <span class="comment">// Viewport的NestedScrollViewViewport，其只接受可以创建</span></span><br><span class="line">          <span class="comment">// RenderSliver的widget</span></span><br><span class="line">          slivers: widget._buildSlivers(</span><br><span class="line">            context,</span><br><span class="line">            _coordinator!._innerController,</span><br><span class="line">            _lastHasScrolledBody!,</span><br><span class="line">          ),</span><br><span class="line">          handle: _absorberHandle,</span><br><span class="line">          clipBehavior: widget.clipBehavior,</span><br><span class="line">          restorationId: widget.restorationId,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_NestedScrollViewCustomScrollView 继承自 CustomScrollView，主要作用是创建继承自 Viewport 的 NestedScrollViewViewport，而后者又主要负责创建和更新继承自 RenderViewport 的 RenderNestedScrollViewViewport——其在内部更新和维护 SliverOverlapAbsorberHandle。</p>
<blockquote>
<p><code>SliverOverlapAbsorberHandle</code>: Handle to provide to a <code>SliverOverlapAbsorber</code>, a <code>SliverOverlapInjector</code>, and an <code>NestedScrollViewViewport</code>, to shift overlap in a <code>NestedScrollView</code>.</p>
</blockquote>
<p>到目前位置，UI 展示部分的内容已经完成，我们的 NestedScrollView 可以将 header 和 body 显示在屏幕上面，但是如果要联动处理在 header 和 body 上面的滑动事件，还需要_NestedScrollCoordinator、_NestedScrollController 和_NestedScrollPosition 的配合。</p>
<h2 id="NestedScrollController"><a href="#NestedScrollController" class="headerlink" title="_NestedScrollController"></a>_NestedScrollController</h2><p>_NestedScrollController 继承自 ScrollController，其逻辑比较简单，主要添加了两项功能：</p>
<h3 id="创建-NestedScrollPosition"><a href="#创建-NestedScrollPosition" class="headerlink" title="创建_NestedScrollPosition"></a>创建_NestedScrollPosition</h3><p>创建_NestedScrollPosition 的逻辑比较简单，主要是将 coordinator 也一并传入。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ScrollPosition createScrollPosition(</span><br><span class="line">  ScrollPhysics physics,</span><br><span class="line">  ScrollContext context,</span><br><span class="line">  ScrollPosition? oldPosition,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> _NestedScrollPosition(</span><br><span class="line">    coordinator: coordinator,</span><br><span class="line">    physics: physics,</span><br><span class="line">    context: context,</span><br><span class="line">    initialPixels: initialScrollOffset,</span><br><span class="line">    oldPosition: oldPosition,</span><br><span class="line">    debugLabel: debugLabel,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在-ScrollPosition-变化时通知-coordinator"><a href="#在-ScrollPosition-变化时通知-coordinator" class="headerlink" title="在 ScrollPosition 变化时通知 coordinator"></a>在 ScrollPosition 变化时通知 coordinator</h3><p>在 attach(ScrollPosition position)中调用_scheduleUpdateShadow()和_NestedScrollCoordinator 的 updateParent、updateCanDrag，对传入的 ScrollPosition 添加回调_scheduleUpdateShadow()。</p>
<p>在 detach(ScrollPosition position)中调用_scheduleUpdateShadow()，对传入的 ScrollPosition 移除回调_scheduleUpdateShadow()。</p>
<p>而这个_scheduleUpdateShadow()方法主要作用是异步执行 coordinator.updateShadow()更新 NestedScrollView，实现滑动效果。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _scheduleUpdateShadow() &#123;</span><br><span class="line">  <span class="comment">// We do this asynchronously for attach() so that the new position has had</span></span><br><span class="line">  <span class="comment">// time to be initialized, and we do it asynchronously for detach() and from</span></span><br><span class="line">  <span class="comment">// the position change notifications because those happen synchronously</span></span><br><span class="line">  <span class="comment">// during a frame, at a time where it&#x27;s too late to call setState. Since the</span></span><br><span class="line">  <span class="comment">// result is usually animated, the lag incurred is no big deal.</span></span><br><span class="line">  SchedulerBinding.instance.addPostFrameCallback(</span><br><span class="line">    (<span class="built_in">Duration</span> timeStamp) &#123;</span><br><span class="line">      coordinator.updateShadow();</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NestedScrollPosition"><a href="#NestedScrollPosition" class="headerlink" title="_NestedScrollPosition"></a>_NestedScrollPosition</h2><p>在 inner scrolling widget 和 outer viewport 都使用_NestedScrollPosition，它追踪这些 viewport 使用的 offset，并且内部持有_NestedScrollCoordinator，所以此 class 上触发 activities 时，可以推迟或者影响 coordinator。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NestedScrollPosition</span> <span class="keyword">extends</span> <span class="title">ScrollPosition</span> <span class="keyword">implements</span> <span class="title">ScrollActivityDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _NestedScrollCoordinator coordinator; <span class="comment">// 协调inner和outer滑动事件</span></span><br><span class="line">  <span class="comment">// 是在NestedScrollView中传给_NestedScrollViewCustomScrollView的ScrollController</span></span><br><span class="line">  ScrollController? _parent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setParent(ScrollController? value) &#123;</span><br><span class="line">    _parent?.detach(<span class="keyword">this</span>);</span><br><span class="line">    _parent = value;</span><br><span class="line">    _parent?.attach(<span class="keyword">this</span>);<span class="comment">// 将此ScrollPosition和_parent绑定</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setParent"><a href="#setParent" class="headerlink" title="setParent"></a>setParent</h3><p>_NestedScrollPosition.setParent 中，将自己和传入的 ScrollController 绑定在一起：</p>
<ul>
<li>将自身加入 ScrollController._positions</li>
<li>ScrollController 监听自身变化时执行 notifyListeners 通知监听者</li>
</ul>
<h3 id="absorb"><a href="#absorb" class="headerlink" title="absorb"></a>absorb</h3><p>在 absorb 方法中将 activity 的 delegate 更新为当前 ScrollPosition：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> absorb(ScrollPosition other) &#123;</span><br><span class="line">  <span class="keyword">super</span>.absorb(other);</span><br><span class="line">  <span class="comment">// 部分activity会使用此来操作scroll view</span></span><br><span class="line">  activity!.updateDelegate(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyClampedDragUpdate"><a href="#applyClampedDragUpdate" class="headerlink" title="applyClampedDragUpdate"></a>applyClampedDragUpdate</h3><p>此方法返回的是没有使用的 delta，此方法不会主动创建 overscroll&#x2F;underscroll，如果当前 ScrollPosition 在范围内，则不会发送 overscroll&#x2F;underscroll；如果已经超出范围，则只会“减轻”这种情况，而不会“加重”。</p>
<p>之所以不会 overscroll，是因为 min 和 max 的取值限定了他们的范围，以一个垂直方向向下布局的滑动列表为例：</p>
<ul>
<li><p>delat &lt; 0，即向上滑动，范围是 min：-double.infinity ~ max： 0（overscroll 时）或者 maxScrollExtent 和 pixels 中最大值（只能滑到最大范围）。</p>
<p>也就是说，向上滑动时，如果已经在顶部出现 overscroll（此时 pixels 应该为负值），那么最多滑动到 0（也就是恢复到初始位置），没有顶部 overscroll 时（此时 pixels 为正值，可能在 maxScrollExtent 范围内，也可能超出范围，即底部出现 overscroll），那么此时最多向上滑动 maxScrollExtent 和 pixels，也就是说要么不能超范围，要是超了范围，就不能再超了。</p>
<p>而最小滑动范围为-double.infinity，无论 pixels 正负，当其 delta 为负时，其值都只会增大，取值-double.infinity 是为了将 pixels 包含在内。</p>
</li>
<li><p>delta &gt; 0，即向下滑动，范围是 min：minScrollExtent 和 pixels 最小值 ~ double.infinity。</p>
<p>也就是说，向下滑动最小到初始位置，最大值不限定（因为此时可能 offset 已经由于某种原因超过 maxScrollExtent 了）。</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns the amount of delta that was not used.</span></span><br><span class="line"><span class="comment">// Positive delta means going down (exposing stuff above), negative delta</span></span><br><span class="line"><span class="comment">// going up (exposing stuff below).</span></span><br><span class="line"><span class="built_in">double</span> applyClampedDragUpdate(<span class="built_in">double</span> delta) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(delta != <span class="number">0.0</span>);</span><br><span class="line">  <span class="comment">// If we are going towards the maxScrollExtent (negative scroll offset),</span></span><br><span class="line">  <span class="comment">// then the furthest we can be in the minScrollExtent direction is negative</span></span><br><span class="line">  <span class="comment">// infinity. For example, if we are already overscrolled, then scrolling to</span></span><br><span class="line">  <span class="comment">// reduce the overscroll should not disallow the overscroll.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If we are going towards the minScrollExtent (positive scroll offset),</span></span><br><span class="line">  <span class="comment">// then the furthest we can be in the minScrollExtent direction is wherever</span></span><br><span class="line">  <span class="comment">// we are now, if we are already overscrolled (in which case pixels is less</span></span><br><span class="line">  <span class="comment">// than the minScrollExtent), or the minScrollExtent if we are not.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// In other words, we cannot, via applyClampedDragUpdate, _enter_ an</span></span><br><span class="line">  <span class="comment">// overscroll situation.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// An overscroll situation might be nonetheless entered via several means.</span></span><br><span class="line">  <span class="comment">// One is if the physics allow it, via applyFullDragUpdate (see below). An</span></span><br><span class="line">  <span class="comment">// overscroll situation can also be forced, e.g. if the scroll position is</span></span><br><span class="line">  <span class="comment">// artificially set using the scroll controller.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// delat &lt; 0，即向上滑动，范围是 min：-double.infinity ~ max： 0</span></span><br><span class="line">  <span class="comment">//（overscroll时）或者 maxScrollExtent和pixels中最大值（只能滑到最大范围）</span></span><br><span class="line">  <span class="comment">// delta &gt; 0，即向下滑动，范围是 min：minScrollExtent和pixels最小值 ~</span></span><br><span class="line">  <span class="comment">// double.infinity（也就是说，向下滑动最小到初始位置，最大值不限定</span></span><br><span class="line">  <span class="comment">// [因为此时可能offset已经由于某种原因超过maxScrollExtent了]）</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> min = delta &lt; <span class="number">0.0</span></span><br><span class="line">    ? -<span class="built_in">double</span>.infinity<span class="comment">// 向上滑动</span></span><br><span class="line">    : math.min(minScrollExtent, pixels);<span class="comment">// 向下滑动</span></span><br><span class="line">  <span class="comment">// The logic for max is equivalent but on the other side.</span></span><br><span class="line">  <span class="comment">// 这里的逻辑是，如果向下滑动，那么max为无限大；</span></span><br><span class="line">  <span class="comment">// 如果向上滑动并且已经overscroll了，那么max是0（即恢复初始位置），否则为maxScrollExtent即最大滑动范围</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> max = delta &gt; <span class="number">0.0</span></span><br><span class="line">    ? <span class="built_in">double</span>.infinity<span class="comment">// 向下滑动</span></span><br><span class="line">    <span class="comment">// If pixels &lt; 0.0, then we are currently in overscroll. The max should be</span></span><br><span class="line">    <span class="comment">// 0.0, representing the end of the overscrolled portion.</span></span><br><span class="line">    <span class="comment">// pixels比maxScrollExtent大可能是由于jumpTo等情况，此时max为pixels表示不能继续滑动超出此值</span></span><br><span class="line">    : pixels &lt; <span class="number">0.0</span> ? <span class="number">0.0</span> : math.max(maxScrollExtent, pixels);<span class="comment">// 向上滑动</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> oldPixels = pixels;</span><br><span class="line">  <span class="comment">//newPixels是可以应用到ScrollPosition的pixels，其范围：</span></span><br><span class="line">  <span class="comment">// 1. delta为负，即向上滑动，pixels - delta = pixels + |delta| &gt; pixels，</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.1 当pixels小于0也就是存在overscroll时，其范围是pixels + |delta|~0，</span></span><br><span class="line">  <span class="comment">// 此时overscroll偏移量为pixels + |delta|，newPixels在pixels + |delta|~0之间，【不会再加深越界】</span></span><br><span class="line">  <span class="comment">// 1.2 当pixels大于等于0也就是不存在overscroll时，其范围是pixels + |delta|~maxScrollExtent</span></span><br><span class="line">  <span class="comment">// 此时，newPixels在pixels + |delta|~maxScrollExtent之间，最大为maxScrollExtent【newPixels不会越界】</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. delta为正，即向下滑动，pixels - delta = pixels - |delta| &lt; pixels</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1 当pixels小于0也就是存在overscroll时，pixels - delta = pixels - |delta| &lt; pixels，</span></span><br><span class="line">  <span class="comment">// 其范围是（pixels和minScrollExtent较小值）~double.infinity，也就是delta不会</span></span><br><span class="line">  <span class="comment">// 被应用，newPixels会等于pixels，如果已经越界了，【不会再加深越界】</span></span><br><span class="line">  <span class="comment">// 2.2 当pixels大于等于0也就是不存在overscroll时，其范围是minScrollExtent~double.infinity，</span></span><br><span class="line">  <span class="comment">// newPixels会在minScrollExtent和pixels之间，【newPixels的值不会越界】</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> newPixels = (pixels - delta).clamp(min, max);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> clampedDelta = newPixels - pixels;<span class="comment">// 对比ScrollPosition变化的值</span></span><br><span class="line">  <span class="comment">// position的pixels为0且向下滑动时这里clampedDelta为0，不执行剩余步骤</span></span><br><span class="line">  <span class="keyword">if</span> (clampedDelta == <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> delta;</span><br><span class="line">  <span class="comment">// 返回超出界限的值overscroll，如果为0表示可以任意超出界限，不为0表示不可以应用到</span></span><br><span class="line">  <span class="comment">//ScrollPosition上的值，根据physics而不同</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> overscroll = physics.applyBoundaryConditions(<span class="keyword">this</span>, newPixels);</span><br><span class="line">  <span class="comment">// 减去了overscroll，所以这里actualNewPixels是真正可以应用的pixels</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> actualNewPixels = newPixels - overscroll;</span><br><span class="line">  <span class="comment">// offset表示经过上述计算之后，ScrollPosition实际将要产生的变化</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> offset = actualNewPixels - oldPixels;</span><br><span class="line">  <span class="keyword">if</span> (offset != <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据physics的不同，这里offset可能会导致ScrollPosition内部视觉上出现越界现象，此时overscroll为0，</span></span><br><span class="line">    <span class="comment">// 或者没有越界内容，overscroll为0或者应用了delta之后会出现的越界值</span></span><br><span class="line">    forcePixels(actualNewPixels);<span class="comment">//更新pixels</span></span><br><span class="line">    didUpdateScrollPositionBy(offset);<span class="comment">// 发出ScrollUpdateNotification通知</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// delta为负时，offset为正值；delta为正值时，offset为负值。总之delta绝对值减少了。</span></span><br><span class="line">  <span class="keyword">return</span> delta + offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyFullDragUpdate"><a href="#applyFullDragUpdate" class="headerlink" title="applyFullDragUpdate"></a>applyFullDragUpdate</h3><p>此方法在满足 overscroll 条件时，会应用 overscroll，并发出 OverscrollNotification 通知。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> applyFullDragUpdate(<span class="built_in">double</span> delta) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(delta != <span class="number">0.0</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> oldPixels = pixels;</span><br><span class="line">  <span class="comment">// Apply friction:</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> newPixels = pixels - physics.applyPhysicsToUserOffset(</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    delta,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (oldPixels == newPixels)<span class="comment">// 应用delta之后没有变化，返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// delta must have been so small we dropped it during floating point addition</span></span><br><span class="line">  <span class="comment">// Check for overscroll:</span></span><br><span class="line">  <span class="comment">// 按照physics的规则，如果可以overscroll则返回0，下面的actualNewPixels会展示出越界的效果</span></span><br><span class="line">  <span class="comment">// 否则返回不能消耗的delta，会发出overscroll通知</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> overscroll = physics.applyBoundaryConditions(<span class="keyword">this</span>, newPixels);</span><br><span class="line">  <span class="comment">// 如果physics允许越界返回overscroll是0，则这里actualNewPixels最终是越界的pixels</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> actualNewPixels = newPixels - overscroll;</span><br><span class="line">  <span class="keyword">if</span> (actualNewPixels != oldPixels) &#123;</span><br><span class="line">    forcePixels(actualNewPixels);<span class="comment">// 更新当前ScrollPosition的pixels值</span></span><br><span class="line">    didUpdateScrollPositionBy(actualNewPixels - oldPixels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (overscroll != <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 发出overscroll的OverscrollNotification通知，然后会有地方处理overscroll</span></span><br><span class="line">    <span class="comment">// 比如Android会触发在ScrollableState.build方法中的_configuration.buildOverscrollIndicator</span></span><br><span class="line">    <span class="comment">// 对应的ScrollBehavior.buildViewportChrome创建蓝色波纹效果</span></span><br><span class="line">    didOverscrollBy(overscroll);</span><br><span class="line">    <span class="keyword">return</span> overscroll;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyClampedPointerSignalUpdate"><a href="#applyClampedPointerSignalUpdate" class="headerlink" title="applyClampedPointerSignalUpdate"></a>applyClampedPointerSignalUpdate</h3><p>applyClampedPointerSignalUpdate 方法返回未使用的 delta，不考虑 ScrollPhysics 的影响。</p>
<h3 id="applyNewDimensions"><a href="#applyNewDimensions" class="headerlink" title="applyNewDimensions()"></a>applyNewDimensions()</h3><p>此方法是_outerScrollPosition 接管 body 滑动事件的关键，也是<strong>body 中 scrolling view 使用了自己的 ScrollController 之后 NestedScrollView 就无法协调 header 和 body 滑动</strong>的原因。</p>
<p>在默认的 ScrollController 中，createScrollPosition()方法创建的是 ScrollPositionWithSingleContext，当 content 或者 viewport 的尺寸变化之后会调用其 applyNewDimensions()方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ScrollPositionWithSingleContext类</span></span><br><span class="line"><span class="keyword">void</span> applyNewDimensions() &#123;</span><br><span class="line">  <span class="keyword">super</span>.applyNewDimensions();</span><br><span class="line">  <span class="comment">// 此处的context一般是ScrollableState</span></span><br><span class="line">  context.setCanDrag(physics.shouldAcceptUserOffset(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后会调用 ScrollableState 的 setCanDrag 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ScrollableState类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 识别用户手势的属性，用于RawGestureDetector.gestures</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, GestureRecognizerFactory&gt; _gestureRecognizers = <span class="keyword">const</span> &lt;<span class="built_in">Type</span>, GestureRecognizerFactory&gt;&#123;&#125;;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> setCanDrag(<span class="built_in">bool</span> value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == _lastCanDrag &amp;&amp; (!value || widget.axis == _lastAxisDirection))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">    _gestureRecognizers = <span class="keyword">const</span> &lt;<span class="built_in">Type</span>, GestureRecognizerFactory&gt;&#123;&#125;;</span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新_gestureRecognizers的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见_gestureRecognizers 默认为空，只有主动调用 ScrollableState.setCanDrag(true)之后滑动视图中的 Scrollable 才能识别手势并处理。</p>
<p>而在_NesetedScrollPosition 的方法中，并没有调用，而是：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _NestedScrollPosition类</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> applyNewDimensions() &#123;</span><br><span class="line">  <span class="keyword">super</span>.applyNewDimensions();</span><br><span class="line">  coordinator.updateCanDrag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _NestedScrollCoordinator类</span></span><br><span class="line"><span class="keyword">void</span> updateCanDrag() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_outerPosition!.haveDimensions) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">double</span> maxInnerExtent = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!position.haveDimensions) <span class="keyword">return</span>;</span><br><span class="line">    maxInnerExtent = math.max(</span><br><span class="line">      maxInnerExtent,</span><br><span class="line">      position.maxScrollExtent - position.minScrollExtent,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意这里只给_outerPosition调用了updateCanDrag方法</span></span><br><span class="line">  _outerPosition!.updateCanDrag(maxInnerExtent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码分析可知，如果使用默认的_NestedScrollController 创建的_NestedScrollPosition，最后只有_outerPosition 更新了_gestureRecognizers 可以识别手势，而使用_innerScrollPosition 的 body 内部的 scrolling view 无法识别手势。</p>
<p>所以，当没有给 body 中的 scrolling view 主动设置 ScrollController 时，无论是在 header 还是 body 的手势事件都会由 ScrollPosition 来转发给_NestedScrollCoordinator 统一协调处理；而<strong>如果给 body 中的 scrolling view 主动设置 ScrollController</strong>，由于 ScrollController 默认创建的 ScrollPositionWithSingleContext 会按照实际情况更新_gestureRecognizers，<strong>从而当用户手势在 body 中 scrolling view 的范围时，手势事件会被其捕获并内部消耗，而非转发到_NestedScrollCoordinator 处理，所以就会使 NestedScrollView 失效</strong>。</p>
<br>

<p>此外还持有了_NestedScrollCoordinator，在 animateTo&#x2F;jumpTo&#x2F;pointerScroll&#x2F;applyNewDimensions&#x2F;hold&#x2F;drag 等与滑动相关的方法被调用时执行_NestedScrollCoordinator 中对应的方法，这样就将 outer viewport 和 inner scrolling view 的滑动事件都归集到_NestedScrollCoordinator 统一处理。</p>
<h2 id="NestedScrollCoordinator"><a href="#NestedScrollCoordinator" class="headerlink" title="_NestedScrollCoordinator"></a>_NestedScrollCoordinator</h2><p>为了与_NestedScrollPosition 保持一致，方便接收其转发的事件，_NestedScrollCoordinator 也实现了 ScrollActivityDelegate 接口：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NestedScrollCoordinator</span> <span class="keyword">implements</span> <span class="title">ScrollActivityDelegate</span>, <span class="title">ScrollHoldController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> NestedScrollViewState _state;<span class="comment">// 用于获取NestedScrollView的ScrollController</span></span><br><span class="line">  ScrollController? _parent;<span class="comment">// 用户传入的NestedScrollView的ScrollController</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> _floatHeaderSlivers;<span class="comment">// header是否悬浮，是的话向“下”滑动时会先将header滑动出来</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分别应用于outer（即_NestedScrollViewCustomScrollView）和inner（即body中的</span></span><br><span class="line">  <span class="comment">// scrolling view）的ScrollController</span></span><br><span class="line">  <span class="keyword">late</span> _NestedScrollController _outerController;</span><br><span class="line">  <span class="keyword">late</span> _NestedScrollController _innerController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beginActivity"><a href="#beginActivity" class="headerlink" title="beginActivity"></a>beginActivity</h3><p>beginActivity 用来对 outer 和 inner 应用 ScrollActivity，在 goIdle&#x2F;goBallistic&#x2F;animateTo&#x2F;jumpTo&#x2F;pointerScroll&#x2F;drag&#x2F;hold 等与滑动有关的方法中都有直接或间接的调用。</p>
<p>其中 outer activity 是直接指定的，而 inner activity 则是根据 innerActivityGetter 和 inner position 动态计算。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> beginActivity(ScrollActivity newOuterActivity, _NestedScrollActivityGetter innerActivityGetter) &#123;</span><br><span class="line">  _outerPosition!.beginActivity(newOuterActivity);<span class="comment">// outer直接应用ScrollActivity</span></span><br><span class="line">  <span class="built_in">bool</span> scrolling = newOuterActivity.isScrolling;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions) &#123;</span><br><span class="line">    <span class="comment">// 依次遍历inner scrolling view计算对应的newInnerActivity</span></span><br><span class="line">    <span class="keyword">final</span> ScrollActivity newInnerActivity = innerActivityGetter(position);</span><br><span class="line">    position.beginActivity(newInnerActivity);</span><br><span class="line">    scrolling = scrolling &amp;&amp; newInnerActivity.isScrolling;</span><br><span class="line">  &#125;</span><br><span class="line">  _currentDrag?.dispose();</span><br><span class="line">  _currentDrag = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!scrolling)</span><br><span class="line">    <span class="comment">// 如果都没有滑动，就表示当前NestedScrollView停止</span></span><br><span class="line">    updateUserScrollDirection(ScrollDirection.idle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的一种使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> goBallistic(<span class="built_in">double</span> velocity) &#123;</span><br><span class="line">  beginActivity(</span><br><span class="line">    createOuterBallisticScrollActivity(velocity),<span class="comment">// 创建outer activity</span></span><br><span class="line">    (_NestedScrollPosition position) &#123;<span class="comment">// 根据position创建inner activity</span></span><br><span class="line">      <span class="keyword">return</span> createInnerBallisticScrollActivity(</span><br><span class="line">        position,</span><br><span class="line">        velocity,</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 outer scroll activity 的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ScrollActivity createOuterBallisticScrollActivity(<span class="built_in">double</span> velocity) &#123;</span><br><span class="line">  <span class="comment">// This function creates a ballistic scroll for the outer scrollable.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// It assumes that the outer scrollable can&#x27;t be overscrolled, and sets up a</span></span><br><span class="line">  <span class="comment">// ballistic scroll over the combined space of the innerPositions and the</span></span><br><span class="line">  <span class="comment">// outerPosition.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// First we must pick a representative inner position that we will care</span></span><br><span class="line">  <span class="comment">// about. This is somewhat arbitrary. Ideally we&#x27;d pick the one that is &quot;in</span></span><br><span class="line">  <span class="comment">// the center&quot; but there isn&#x27;t currently a good way to do that so we</span></span><br><span class="line">  <span class="comment">// arbitrarily pick the one that is the furthest away from the infinity we</span></span><br><span class="line">  <span class="comment">// are heading towards.</span></span><br><span class="line">  _NestedScrollPosition? innerPosition;</span><br><span class="line">  <span class="keyword">if</span> (velocity != <span class="number">0.0</span>) &#123;<span class="comment">// 选择在正方向上离我们最远的inner position</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (innerPosition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (velocity &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (innerPosition.pixels &lt; position.pixels)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">assert</span>(velocity &lt; <span class="number">0.0</span>);</span><br><span class="line">          <span class="keyword">if</span> (innerPosition.pixels &gt; position.pixels)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      innerPosition = position;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (innerPosition == <span class="keyword">null</span>) &#123;<span class="comment">// 这里表示只有outer或者velocity为0</span></span><br><span class="line">    <span class="comment">// It&#x27;s either just us or a velocity=0 situation.</span></span><br><span class="line">    <span class="keyword">return</span> _outerPosition!.createBallisticScrollActivity(</span><br><span class="line">      _outerPosition!.physics.createBallisticSimulation(</span><br><span class="line">        _outerPosition!,</span><br><span class="line">        velocity,</span><br><span class="line">      ),</span><br><span class="line">      mode: _NestedBallisticScrollActivityMode.independent,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里表示NestedScrollView中存在inner和outer scrolling view，且velocity不为0</span></span><br><span class="line">  <span class="comment">// 在innerPosition和outerPosition组合的space之上设置overscroll</span></span><br><span class="line">  <span class="keyword">final</span> _NestedScrollMetrics metrics = _getMetrics(innerPosition, velocity);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _outerPosition!.createBallisticScrollActivity(</span><br><span class="line">    _outerPosition!.physics.createBallisticSimulation(metrics, velocity),</span><br><span class="line">    mode: _NestedBallisticScrollActivityMode.outer,</span><br><span class="line">    metrics: metrics,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见在计算 outer scroll activity 的时候，需判断 body 内是不是有 inner scrolling view：</p>
<ul>
<li>没有，按照正常创建 BallisticScrollActivity 的流程创建</li>
<li>有，将 inner 的 space 也计入，然后以此计算 BallisticScrollActivity</li>
</ul>
<p>创建 inner scroll activity 的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ScrollActivity createInnerBallisticScrollActivity(_NestedScrollPosition position, <span class="built_in">double</span> velocity) &#123;</span><br><span class="line">  <span class="keyword">return</span> position.createBallisticScrollActivity(</span><br><span class="line">    position.physics.createBallisticSimulation(</span><br><span class="line">      _getMetrics(position, velocity),</span><br><span class="line">      velocity,</span><br><span class="line">    ),</span><br><span class="line">    mode: _NestedBallisticScrollActivityMode.inner,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyUserOffset"><a href="#applyUserOffset" class="headerlink" title="applyUserOffset"></a>applyUserOffset</h3><p>applyUserOffset() 是_NestedScrollCoordinator 的重点，也是 NestedScrollView 能够实现协调 inner 和 outer 滑动事件的关键。</p>
<p>在看 applyUserOffset() 方法之前，先看一下 drag()方法，在此方法中创建 ScrollDragController 时 delegate 传入的是_NestedScrollCoordinator。</p>
<p>当用户操作屏幕发生 drag 事件时，手势事件会被 ScrollableState 中的 RawGestureDetector 识别到：</p>
<ul>
<li>drag 开始时调用<code>_handleDragStart</code>，通过_NestedScrollPosition 转发调用<code>_NestedScrollCoordinator.drag</code>方法创建了<code>ScrollDragController drag</code></li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此方法在ScrollableState中被RawGestureDetector通过</span></span><br><span class="line"><span class="comment">// ScrollableState._handleDragStart -&gt; _NestedScrollPosition.drag</span></span><br><span class="line"><span class="comment">// -&gt; _NestedScrollCoordinator.drag链路调用</span></span><br><span class="line">Drag drag(DragStartDetails details, VoidCallback dragCancelCallback) &#123;</span><br><span class="line">  <span class="keyword">final</span> ScrollDragController drag = ScrollDragController(</span><br><span class="line">    delegate: <span class="keyword">this</span>,</span><br><span class="line">    details: details,</span><br><span class="line">    onDragCanceled: dragCancelCallback,</span><br><span class="line">  );</span><br><span class="line">  beginActivity(</span><br><span class="line">    DragScrollActivity(_outerPosition!, drag),</span><br><span class="line">    (_NestedScrollPosition position) =&gt; DragScrollActivity(position, drag),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assert</span>(_currentDrag == <span class="keyword">null</span>);</span><br><span class="line">  _currentDrag = drag;</span><br><span class="line">  <span class="keyword">return</span> drag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>drag 开始时更新时<code>_handleDragUpdate</code>，内部调用<code>ScrollDragController.update</code>,在 update 方法内部执行了<code>delegate.applyUserOffset</code>，此处的<code>delegate</code>就是我们之前传入的_NestedScrollCoordinator</li>
</ul>
<p>根据上述分析，在用户滑动屏幕时，会执行<code>_NestedScrollCoordinator.applyUserOffset</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> applyUserOffset(<span class="built_in">double</span> delta) &#123;</span><br><span class="line">  <span class="comment">// 更新scroll方向</span></span><br><span class="line">  updateUserScrollDirection(</span><br><span class="line">    delta &gt; <span class="number">0.0</span> ? ScrollDirection.forward : ScrollDirection.reverse,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assert</span>(delta != <span class="number">0.0</span>);</span><br><span class="line">  <span class="keyword">if</span> (_innerPositions.isEmpty) &#123;</span><br><span class="line">    <span class="comment">// 如果没有inner（body内部没有scrolling view），就由outer完全处理滑动事件</span></span><br><span class="line">    _outerPosition!.applyFullDragUpdate(delta);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delta &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// Dragging &quot;up&quot;</span></span><br><span class="line">    <span class="comment">// 先恢复inner overscroll，然后是outer view，以便header内容尽快scroll out</span></span><br><span class="line">    <span class="built_in">double</span> outerDelta = delta;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (position.pixels &lt; <span class="number">0.0</span>) &#123; <span class="comment">// This inner position is in overscroll.</span></span><br><span class="line">        <span class="comment">// 先从overscrolled恢复并返回剩余没有使用的delta</span></span><br><span class="line">        <span class="comment">// 因为delta是负值，如果“消耗”掉了一部分，那么potentialOuterDelta会比delta大</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">double</span> potentialOuterDelta = position.applyClampedDragUpdate(delta);</span><br><span class="line">        <span class="comment">// In case there are multiple positions in varying states of</span></span><br><span class="line">        <span class="comment">// overscroll, the first to &#x27;reach&#x27; the outer view above takes</span></span><br><span class="line">        <span class="comment">// precedence.此处outerDelta为剩余没有消耗的delta</span></span><br><span class="line">        outerDelta = math.max(outerDelta, potentialOuterDelta);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outerDelta != <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果还有剩下的，让outer view消耗</span></span><br><span class="line">      <span class="comment">// delta &lt; 0;所以如果outer有underscroll则会先恢复到0然后返回（现有限制下不会出现</span></span><br><span class="line">      <span class="comment">// 此情况），否则最多可以向上滑动到maxScrollExtent</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">double</span> innerDelta = _outerPosition!.applyClampedDragUpdate(</span><br><span class="line">        outerDelta,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (innerDelta != <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="comment">// 还有剩下的，让inner开始滑动</span></span><br><span class="line">        <span class="comment">// 这里吧剩下的innerDelta完全给了inner scroll position的applyFullDragUpdate方法</span></span><br><span class="line">        <span class="comment">// inner会先向上滑动，如果physics支持underscroll会执行underscroll，否则最多滑动</span></span><br><span class="line">        <span class="comment">// 到maxScrollExtent，然后发出overscroll的通知，让Scrollable绘制蓝色波纹（Android）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions)</span><br><span class="line">          position.applyFullDragUpdate(innerDelta);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Dragging &quot;down&quot; - delta is positive</span></span><br><span class="line">    <span class="built_in">double</span> innerDelta = delta;</span><br><span class="line">    <span class="comment">// Apply delta to the outer header first if it is configured to float.</span></span><br><span class="line">    <span class="keyword">if</span> (_floatHeaderSlivers)</span><br><span class="line">    <span class="comment">// _floatHeaderSlivers为true，先让outer复现出来，最多向下滑动到minScrollExtent</span></span><br><span class="line">      <span class="comment">// 也就是恢复原位</span></span><br><span class="line">      innerDelta = _outerPosition!.applyClampedDragUpdate(delta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (innerDelta != <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="comment">// Apply the innerDelta, if we have not floated in the outer scrollable,</span></span><br><span class="line">      <span class="comment">// any leftover delta after this will be passed on to the outer</span></span><br><span class="line">      <span class="comment">// scrollable by the outerDelta.</span></span><br><span class="line">      <span class="built_in">double</span> outerDelta = <span class="number">0.0</span>; <span class="comment">// it will go positive if it changes</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; overscrolls = &lt;<span class="built_in">double</span>&gt;[];</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;_NestedScrollPosition&gt; innerPositions = _innerPositions.toList();</span><br><span class="line">      <span class="comment">// inner scrolling view先消耗delta</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> innerPositions) &#123;</span><br><span class="line">        <span class="comment">// 向下滑动inner scrolling view</span></span><br><span class="line">        <span class="comment">// 如果inner physics不支持overscroll，则执行完innerDelta之后，最多会返回未执行的overscroll</span></span><br><span class="line">        <span class="comment">// 如果支持，则会消耗完innerDelta，这里的overscroll为0</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">double</span> overscroll = position.applyClampedDragUpdate(innerDelta);</span><br><span class="line">        outerDelta = math.max(outerDelta, overscroll);</span><br><span class="line">        overscrolls.add(overscroll);<span class="comment">// 保存没有被使用的overscroll</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (outerDelta != <span class="number">0.0</span>)</span><br><span class="line">        <span class="comment">// 在此处，即使设置了outer的physics为BouncingScrollPhysics，因为当ScrollPosition的</span></span><br><span class="line">        <span class="comment">// offset为0时，applyClampedDragUpdate不会主动从0变为负值，所以无法应用underscroll效果</span></span><br><span class="line">        <span class="comment">// 此处outerDelta-=overscroll的结果是outerDelta是outer消耗的那一部分内容</span></span><br><span class="line">        outerDelta -= _outerPosition!.applyClampedDragUpdate(outerDelta);</span><br><span class="line">        <span class="comment">// 这里outerDelta是剩下的delta</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now deal with any overscroll 最后交给inner处理overscroll</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; innerPositions.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// 此处的remainingDelta是未执行的overscroll减去了outer消耗的内容</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">double</span> remainingDelta = overscrolls[i] - outerDelta;</span><br><span class="line">        <span class="keyword">if</span> (remainingDelta &gt; <span class="number">0.0</span>)</span><br><span class="line">          <span class="comment">// 如果还有剩下的overscroll，与physics等结合计算之后，继续消耗（之前在</span></span><br><span class="line">          <span class="comment">// applyClampedDragUpdate无法消耗，在这里也消耗不了，不过可以发送overscroll</span></span><br><span class="line">          <span class="comment">// 的通知，让Scrollable知道之后做出蓝色波纹（Android机型）等效果）</span></span><br><span class="line">          innerPositions[i].applyFullDragUpdate(remainingDelta);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析为何 inner 有 scrolling view 时，NestedScrollView.physics 为 BouncingScrollPhysics()不生效：</p>
<p>从上述代码我们看到，可以产生 overscroll 效果的 applyFullDragUpdate 只有在 inner 中没有 scrolling view 的时候才会被_outerPosition 应用，其他两个场景都只有 inner position 应用。</p>
<p>而其余场景中，_outerPosition 和 inner position 都应用的是 applyClampedDragUpdate 方法：</p>
<ul>
<li>向下滑动 delta 大于 0，代码会执行到<code>outerDelta -= _outerPosition!.applyClampedDragUpdate(outerDelta)</code>，因为此时限制了 applyClampedDragUpdate 中的 newPixels 范围为（当 ScrollPosition 的 pixels 等于 0 时）minScrollExtent~double.infinity，所以 clampedDelta &#x3D; newPixels - pixels 等于 minScrollExtent（也就是 0），跳过剩余步骤直接返回了 delta。所以没有执行 BouncingScrollPhysics()逻辑</li>
<li>向上滑动 delta 小于 0，代码会执行<code>final double innerDelta = _outerPosition!.applyClampedDragUpdate(outerDelta,);</code>，在此方法中，如果有 overscroll 则会先恢复到 0，否则最多上划到 maxScrollExtent，所以也不会执行 BouncingScrollPhysics()逻辑</li>
</ul>
<br>

<p>通过上述步骤，NestedScrollView 将 header 和 body 的滚动事件进行组合、分发。</p>
<h1 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h1><p>NestedScrollView 将 header 和 body 中可滑动 view（inner）的滑动事件组合起来：向上滑动时，先等达到 header 最大滑动范围之后，再将滑动分配给 inner 消耗；当向下滑动时，一般先恢复 inner 的 overscroll（如果_floatHeaderSlivers 为 true，会先尝试下滑 header），尝试将其恢复至 offset 为 0 的状态，再尝试将 header 向下滑动到初始位置，最后如果有 overscroll，会尝试应用到 inner 上面。</p>
<p>CustomScrollView 也支持在同一个页面内嵌套多个滑动列表并关联（在其 slivers 中传入多个 SliverList,SliverGrid 等），但是 CustomScrollView 不支持普通的滑动 view，比如 ListView 等，这些滑动布局会内部消耗掉滑动事件，从而无法与 CustomScrollView 内其余 sliver 正常联动。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>NestedScrollView 内部通过 NestedScrollViewState.build()创建继承自 CustomScrollView 的_NestedScrollViewCustomScrollView。</p>
<p>通过 NestedScrollView._buildSlivers()将 NestedScrollView.headerSliverBuilder 返回的 sliver 列表（下称 header）和被 SliverFillRemaining 包裹的 body 组合在一起，使得在_NestedScrollViewCustomScrollView 中创建的 viewport 的创建的_NestedScrollCoordinator.outerPosition 的_maxScrollExtent 为 NestedScrollView 的 header 的主轴尺寸，而_NestedScrollCoordinator._innerPositions 的_maxScrollExtent 则是与 body 实际内容一致。</p>
<p>_NestedScrollViewCustomScrollView 的 ScrollController 是_NestedScrollCoordinator._outerController，其创建了_NestedScrollCoordinator.outerPosition，所以整个 NestedScrollView 的滑动事件都会通过_NestedScrollCoordinator._outerController 转到给_NestedScrollCoordinator.applyUserOffset 方法。</p>
<p>在_NestedScrollCoordinator.applyUserOffset 方法中，根据滑动方向的不同，依次协调_NestedScrollCoordinator.outerPosition 和_NestedScrollCoordinator._innerPositions 处理用户 drag 等产生的 delta，修改这两个 ScrollPosition 的值，从而实现 header 和 body 的滑动联动。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://api.flutter.dev/flutter/widgets/NestedScrollView-class.html">NestedScrollView_api.flutter.dev</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter滑动分析之Scrollview</title>
    <url>/blog/posts/60f8d92f/</url>
    <content><![CDATA[<p>Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：</p>
<ul>
<li>基于 RenderBox 的 <em>box protocol</em> 实现的，主要基于 Size 实现布局。常见的有 SingleChildScrollView。</li>
<li>基于 RenderSliver 的 <em>sliver protocol</em> 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自 ScrollView 的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。</li>
</ul>
<p>上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。</p>
<br>

<p>上回我们对 SingleChildScrollView 的实现做了简单分析（见《<a href="https://xiaoyong.ml/blog/posts/d3bdcb53/">Flutter 滑动分析之 SingleChildScrollView</a>》），本文将对另外一种遵循 <em>sliver protocol</em> 的 ScrollView 做一分析。</p>
<p>官方对 ScrollView 的定义是：“A widget that scrolls”。</p>
<p>其主要由三部分组成：</p>
<ul>
<li><p>一个<strong>ScrollWidget</strong>，监听用户手势，实现 scrolling 的交互设计</p>
</li>
<li><p>一个<strong>viewport widget</strong>，根据传入的 shrinkwrap 值的 true&#x2F;false 分别会是 ShrinkWrappingViewport 或者 Viewport。通过根据传入的 ViewportOffset 不同而值展示 slivers 的一部分内容来实现滑动的视觉设计效果。</p>
</li>
<li><p>一个或多个<strong>slivers</strong>，可以被组合起来创建各种 scrolling effects（比如 list，grids，expanding header 等）的 widget，是真正显示在屏幕上的 widget。</p>
<p>由于默认的 ScrollView 创建的 viewport 的 slivers 属性只接受能创建 RenderSliver 的 Widget，所以 ScrollView 的<code>List&lt;Widget&gt; buildSlivers(BuildContext context)</code>方法只能返回 SliverXXX 之类（比如 SliverList）可以创建 RenderSliver 的 Widget。</p>
</li>
</ul>
<br>

<p>ScrollView 是一个抽象类，它主要的作用是将上面提到的三部分组合起来，为（遵从 sliver protocol 的）scrollable widget 封装屏蔽掉滑动底层细节，提供像<code>buildSlivers</code>之类的方法方便子类能够快速实现一个 scrollable widget。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><code>abstract class ScrollView extends StatelessWidget&#123;&#125;</code></p>
<p>ScrollView 继承自 StatelessWidget，他的主要逻辑在 build 方法中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// 这里创建slivers</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; slivers = buildSlivers(context);</span><br><span class="line">  <span class="keyword">final</span> AxisDirection axisDirection = getDirection(context);</span><br><span class="line">  <span class="comment">// scrollController要么使用最近的PrimaryScrollController，要么使用自己的controller</span></span><br><span class="line">  <span class="keyword">final</span> ScrollController? scrollController =</span><br><span class="line">      primary ? PrimaryScrollController.of(context) : controller;</span><br><span class="line">  <span class="comment">// 这里是主要创建Scrollable的地方</span></span><br><span class="line">  <span class="keyword">final</span> Scrollable scrollable = Scrollable(</span><br><span class="line">    dragStartBehavior: dragStartBehavior,</span><br><span class="line">    axisDirection: axisDirection,</span><br><span class="line">    controller: scrollController,</span><br><span class="line">    physics: physics,</span><br><span class="line">    scrollBehavior: scrollBehavior,</span><br><span class="line">    semanticChildCount: semanticChildCount,</span><br><span class="line">    restorationId: restorationId,</span><br><span class="line">    viewportBuilder: (BuildContext context, ViewportOffset offset) &#123;</span><br><span class="line">      <span class="comment">// 在这里创建viewport，使用我们创建好的slivers填充viewport</span></span><br><span class="line">      <span class="comment">// 并传入Scrollable.ScrollPosition作为这里的入参offset，在viewport中</span></span><br><span class="line">      <span class="comment">// 会监听offset的变化来重新绘制slivers从而实现滑动效果</span></span><br><span class="line">      <span class="keyword">return</span> buildViewport(context, offset, axisDirection, slivers);</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">final</span> Widget scrollableResult = primary &amp;&amp; scrollController != <span class="keyword">null</span></span><br><span class="line">      ? PrimaryScrollController.none(child: scrollable)</span><br><span class="line">      : scrollable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里是处理当scrollable view滑动时隐藏键盘的逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (keyboardDismissBehavior == ScrollViewKeyboardDismissBehavior.onDrag) &#123;</span><br><span class="line">    <span class="keyword">return</span> NotificationListener&lt;ScrollUpdateNotification&gt;(</span><br><span class="line">      child: scrollableResult,</span><br><span class="line">      onNotification: (ScrollUpdateNotification notification) &#123;</span><br><span class="line">        <span class="keyword">final</span> FocusScopeNode focusScope = FocusScope.of(context);</span><br><span class="line">        <span class="keyword">if</span> (notification.dragDetails != <span class="keyword">null</span> &amp;&amp; focusScope.hasFocus) &#123;</span><br><span class="line">          focusScope.unfocus();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> scrollableResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码，我们可以验证之前的判断：ScrollView 本身是对 Scrollable、viewport、slivers 的封装。具体的处理滑动手势、更新 ScrollPosition、发送 ScrollNotification 等等都在 Scrollable 中处理了，ScrollView 的子类只需要按照要求提供 slivers（通过 buildSlivers 方法）和其他一些必须的信息即可。</p>
<p>上面的代码中还分别调用了 buildViewport 和 buildSlivers 方法，接下来我们逐一分析一下他们的源码。</p>
<h2 id="Widget-buildViewport"><a href="#Widget-buildViewport" class="headerlink" title="Widget buildViewport()"></a>Widget buildViewport()</h2><p>buildViewport 方法顾名思义，是用来创建 viewport 的。在 ScrollView 中默认会按照 shrinkWrap 的不同创建两种 viewport，他的子类也可以根据需要重写此方法以返回自己的 viewport。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget buildViewport(</span><br><span class="line">  BuildContext context,</span><br><span class="line">  ViewportOffset offset,</span><br><span class="line">  AxisDirection axisDirection,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; slivers,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">switch</span> (axisDirection) &#123;</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.up:</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.down:</span><br><span class="line">        <span class="comment">// 如果是上述两种AxisDirection说明Axis是Axis.vertical的，那么就</span></span><br><span class="line">        <span class="comment">// 需要判断是否此widget是否有Directionality可以用来判断文本布局方向</span></span><br><span class="line">        <span class="comment">// 如果没法判断则抛出FlutterError，否则返回true</span></span><br><span class="line">        <span class="keyword">return</span> debugCheckHasDirectionality(</span><br><span class="line">          context,</span><br><span class="line">          why: <span class="string">&#x27;to determine the cross-axis direction of the scroll view&#x27;</span>,</span><br><span class="line">          hint: <span class="string">&#x27;Vertical scroll views create Viewport widgets that try to determine their cross axis direction &#x27;</span></span><br><span class="line">                <span class="string">&#x27;from the ambient Directionality.&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">      <span class="comment">// 如果getDirection()能得出下面两种AxisDirection说明Axis是</span></span><br><span class="line">      <span class="comment">// Axis.horizontal的，并且已经得知文本方向，所以直接返回true</span></span><br><span class="line">      <span class="keyword">case</span> AxisDirection.left:</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.right:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="comment">// 经过上述检查，到这里widget的文本方向（TextDirection）一定已经确定了</span></span><br><span class="line">  <span class="comment">// 这里根据shrinkWrap的不同分别创建两种viewport</span></span><br><span class="line">  <span class="keyword">if</span> (shrinkWrap) &#123;</span><br><span class="line">    <span class="keyword">return</span> ShrinkWrappingViewport(</span><br><span class="line">      axisDirection: axisDirection,</span><br><span class="line">      offset: offset,</span><br><span class="line">      slivers: slivers,</span><br><span class="line">      clipBehavior: clipBehavior,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Viewport(</span><br><span class="line">    axisDirection: axisDirection,</span><br><span class="line">    offset: offset,</span><br><span class="line">    slivers: slivers,</span><br><span class="line">    cacheExtent: cacheExtent,</span><br><span class="line">    center: center,</span><br><span class="line">    anchor: anchor,</span><br><span class="line">    clipBehavior: clipBehavior,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 buildViewport()方法中，显示在 debug 模式下检查确保 widget 已经确定了文本方向（TextDirection 是 rtl 还是 ltr）；然后根据 shrinkWrap 的不同分别创建 ShrinkWrappingViewport 或者 Viewport，他们会根据 offset 的变化展示不同部分的 slivers。</p>
<p>ShrinkWrappingViewport 和 Viewport 都是继承自 MultiChildRenderObjectWidget 的 widget，主要逻辑是分别创建对应的 RenderObject：RenderShrinkWrappingViewport 和 RenderViewport，而这两者又都继承自 RenderViewportBase。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Viewport</span> <span class="keyword">extends</span> <span class="title">MultiChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderViewport createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderViewport(...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderViewport renderObject) &#123;</span><br><span class="line">    renderObject...;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  MultiChildRenderObjectElement createElement() =&gt; _ViewportElement(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShrinkWrappingViewport</span> <span class="keyword">extends</span> <span class="title">MultiChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderShrinkWrappingViewport createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RenderShrinkWrappingViewport(...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderShrinkWrappingViewport renderObject) &#123;</span><br><span class="line">    renderObject...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RenderViewportBase"><a href="#RenderViewportBase" class="headerlink" title="RenderViewportBase"></a>RenderViewportBase</h3><p><code>abstract class RenderViewportBase&lt;ParentDataClass extends ContainerParentDataMixin&lt;RenderSliver&gt;&gt; extends RenderBox with ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt; implements RenderAbstractViewport &#123;&#125;</code></p>
<p>RenderViewportBase 继承自 RenderBox，混入了 ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;类，本身不持有 children，但提供了在 RenderBox 中容纳 RenderSliver 的一些通用方法：</p>
<ul>
<li>自动添加监听_offset 的方法，在其变化时执行 markNeedsLayout()方法实现滑动效果</li>
<li>提供按照_offset 的值 layout、paint 持有的 children 的方法</li>
<li>通过 hitTestChildren 实现 children 的 hit test</li>
</ul>
<h4 id="校验-children-类型是否为-RenderSliver"><a href="#校验-children-类型是否为-RenderSliver" class="headerlink" title="校验 children 类型是否为 RenderSliver"></a>校验 children 类型是否为 RenderSliver</h4><p>在 RenderViewportBase 混入的 ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;的 debugValidateChild()方法中会<strong>检验 child 的类型是否为指定的 ChildType</strong>（在 RenderViewportBase 中 ChildType 为 RenderSliver），如果不是则会抛出 FlutterError，这也是 ScrollView 默认 Viewport 只支持可以创建 RenderSliver 的 Widget 的原因。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mixin</span> ContainerRenderObjectMixin&lt;ChildType <span class="keyword">extends</span> RenderObject, ParentDataType <span class="keyword">extends</span> ContainerParentDataMixin&lt;ChildType&gt;&gt; <span class="keyword">on</span> RenderObject &#123;</span><br><span class="line">  <span class="built_in">bool</span> debugValidateChild(RenderObject child) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (child <span class="keyword">is</span>! ChildType) &#123;<span class="comment">// 此处会校验child的类型</span></span><br><span class="line">        <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[</span><br><span class="line">          ...</span><br><span class="line">        ]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见 ContainerRenderObjectMixin 提供了检测 child 类型的方法，那么它是在什么时候被调用的呢？</p>
<p>无论是 Viewport 还是 ShrinkWrappingViewport 都继承自 MultiChildRenderObjectWidget，其会创建 MultiChildRenderObjectElement。</p>
<p>MultiChildRenderObjectElement.insertRenderObjectChild()添加 child 中的 RenderObject 时都会先检查一下 child 的类型：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> insertRenderObjectChild(RenderObject child, IndexedSlot&lt;<span class="built_in">Element?</span>&gt; slot) &#123;</span><br><span class="line">    <span class="keyword">final</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject = <span class="keyword">this</span>.renderObject;</span><br><span class="line">    <span class="comment">// 注意这里调用MultiChildRenderObjectElement持有的RenderObject的</span></span><br><span class="line">    <span class="comment">// debugValidateChild方法校验child类型</span></span><br><span class="line">    <span class="keyword">assert</span>(renderObject.debugValidateChild(child));</span><br><span class="line">    renderObject.insert(child, after: slot.value?.renderObject);</span><br><span class="line">    <span class="keyword">assert</span>(renderObject == <span class="keyword">this</span>.renderObject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而因为不管是 RenderShrinkWrappingViewport 还是 RenderViewport 都是继承自 RenderViewportBase，也就会执行<code>ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;.debugValidateChild(child)</code>方法,校验 child 类型是否为 RenderSliver，所以会在其<code>slivers</code>中直接传入 box widget 则会报错“A RenderViewport expected a child of type <strong>RenderSliver</strong> but received a child of type RenderXXX.”</p>
<h3 id="RenderViewport"><a href="#RenderViewport" class="headerlink" title="RenderViewport"></a>RenderViewport</h3><p><code>class RenderViewport extends RenderViewportBase&lt;SliverPhysicalContainerParentData&gt; &#123;&#125;</code></p>
<p>RenderViewport 是 Flutter 滑动机制的主力，他通过监听<code>offset</code>的变化展示<code>children</code>的一部分来实现滑动的视觉效果,他会占据父级给的最大空间（<strong>大小由父级指定</strong>）。</p>
<p>其内部持有一个双向的 slivers 列表<code>children</code>，以在 zero scroll offset 的<code>center</code>为锚点：</p>
<ul>
<li>slivers 列表中在 center 之前的 Slivers 按照列表反方向，沿着 axisDirection 的反方向展示。</li>
<li>slivers 列表中在 center 之后的 Slivers 按照列表的方向，沿着 axisDirection 的方向展示。</li>
</ul>
<p>比如一个 axisDirection 为 AxisDirection.down，children 列表为[“1”, “2”, “3”, “center”, “5”, “6”, “7”]，center 为“center”，那么默认会展示[“center”, “5”, “6”, “7”]，当手指向下滑动的时候，会依次展示出“3”、“2”、“1”，等完全下拉之后，展示内容为：[“1”, “2”, “3”, “center”, “5”, “6”, “7”]。</p>
<h3 id="RenderShrinkWrappingViewport"><a href="#RenderShrinkWrappingViewport" class="headerlink" title="RenderShrinkWrappingViewport"></a>RenderShrinkWrappingViewport</h3><p><code>class RenderShrinkWrappingViewport extends RenderViewportBase&lt;SliverLogicalContainerParentData&gt;&#123;&#125;</code></p>
<p>RenderShrinkWrappingViewport 通过监听<code>offset</code>的变化展示<code>children</code>的一部分来实现滑动的视觉效果,与 Viewport 不同的是，他会 shrinkWrap（收缩包装）自己以便在主轴上匹配 children 的 size（<strong>大小由 RenderShrinkWrappingViewport 根据 children 计算而来</strong>），<strong>比较耗费性能</strong>（特别是当 item 可能会通过折叠展开等方式改变尺寸时）。</p>
<h2 id="List-buildSlivers"><a href="#List-buildSlivers" class="headerlink" title="List buildSlivers()"></a>List<Widget> buildSlivers()</h2><p>ScrollView 的 buildSlivers 方法是抽象方法，由子类根据需要实现，_一般子类也只需要重写此方法即可_。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Build the list of widgets to place inside the viewport.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Subclasses should override this method to build the slivers for the inside</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">of the viewport.</span></span></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">List</span>&lt;Widget&gt; buildSlivers(BuildContext context);</span><br></pre></td></tr></table></figure>

<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>CustomScrollView 就是继承自 ScrollView：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomScrollView</span> <span class="keyword">extends</span> <span class="title">ScrollView</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a [ScrollView] that creates custom scroll effects using slivers.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">See the [ScrollView] constructor for more details on these arguments.</span></span></span><br><span class="line">  <span class="keyword">const</span> CustomScrollView(&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The slivers to place inside the viewport.</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; slivers;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; buildSlivers(BuildContext context) =&gt; slivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 CustomScrollView 的实现比较简单，主要逻辑是将传入的参数<code>slivers</code>作为<code>List&lt;Widget&gt; buildSlivers(BuildContext context)</code>的返回值。这导致我们在使用 CustomScrollView 的时候，需要传入 SliverList、SliverAppBar 等这些继承自 SliverMultiBoxAdaptorWidget 能创建 RenderSliver 的 Widget，而不是普通的 box widget。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ScrollView 的子类借助 SliverMultiBoxAdaptorWidget 及其子类可以实现<strong>对 item 的懒加载</strong>从而避免创建无法通过 viewport 可见的 children（这种类型的传参一般都需传入 SliverChildDelegate 的子类），从而优化性能。</p>
<p>而根据 shrinkWrap 的不同，分别使用 Viewport 和 ShrinkWrappingViewport 创建 viewport，从而分别实现按照父级指定 size 或按照子级计算 size（比较耗性能）。</p>
<p>ScrollView 是 Flutter 中基于 sliver protocol 的 scrollable widget 的父类，因为 viewport 的限制只接受创建 RenderSliver 的 widget 作为其直接子类。其子类则通过 SliverMultiBoxAdaptorWidget 及其子类实现加载 box widget。</p>
<p>以下类都是基于 ScrollView 实现的 scrollable widget：</p>
<ul>
<li><a href="https://api.flutter.dev/flutter/widgets/CustomScrollView-class.html">CustomScrollView</a></li>
<li><a href="https://api.flutter.dev/flutter/widgets/BoxScrollView-class.html">BoxScrollView</a><ul>
<li><a href="https://api.flutter.dev/flutter/widgets/ListView-class.html">ListView</a></li>
<li><a href="https://api.flutter.dev/flutter/widgets/GridView-class.html">GridView</a></li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://api.flutter.dev/flutter/widgets/ScrollView-class.html">ScrollView_api.flutter.dev</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter滑动分析之SingleChildScrollView</title>
    <url>/blog/posts/d3bdcb53/</url>
    <content><![CDATA[<p>Flutter中的scrollable widget根据实现方式的不同，可以分为两大类：</p>
<ul>
<li>基于RenderBox的box protocol实现的，主要基于Size实现布局。常见的有SingleChildScrollView。</li>
<li>基于RenderSliver的sliver protocol实现的，主要基于SliverGeometry实现布局。比如CustomScrollView及其子类ListView、GridView等继承自ScrollView的Widget，以及基于CustomScrollView的NestedScrollView、基于Viewport等的PageView、TabBarView等直接对SliverFillViewport等进行封装的Widget。</li>
</ul>
<p>上述所有的scrollable widget其底层逻辑依然是对Scrollable的封装，其内部处理了ScrollController、ScrollPosition（viewport的offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理scrollable view的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出ScrollNotification）、RawGestureDetector（手势识别）等等一系列与scroll有关的逻辑，从而使得其他scrollable view能够比较方便的实现scroll效果。</p>
<p>本文只对SingleChildScrollView的源码实现做一简单分析：它是如何实现滚动效果，有什么优势和限制。</p>
<p>官方对其定义是：“A box in which a single widget can be scrolled”。明确表明，SingleChildScrollView是遵守box protocol的widget，在其内部也只能有一个<strong>box widget</strong>。</p>
<h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><p>下面是一个SingleChildScrollView的简单使用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SingleChildScrollView(</span><br><span class="line">          child: Column(</span><br><span class="line">            children: <span class="built_in">List</span>.generate(</span><br><span class="line">                <span class="number">20</span>,</span><br><span class="line">                (index) =&gt; SizedBox(</span><br><span class="line">                      height: <span class="number">50</span>,</span><br><span class="line">                      child: Center(child: Text(<span class="string">&quot;item <span class="subst">$index</span>&quot;</span>)),</span><br><span class="line">                    )),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，SingleChildScrollView中容纳了一个叫Column的child，如果Column的高度无法在屏幕中完全展示，就SingleChildScrollView就会保证用户可以上下滑动，从而展示对应的内容；否则如果能够完全显示，则内容无法滑动。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h2><p><code>class SingleChildScrollView extends StatelessWidget &#123;&#125;</code></p>
<p>作为一个StatelessWidget，SingleChildScrollView的主要逻辑在他的<code>build()</code>方法中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">final</span> AxisDirection axisDirection = _getDirection(context);</span><br><span class="line">  Widget? contents = child;</span><br><span class="line">  <span class="keyword">if</span> (padding != <span class="keyword">null</span>)</span><br><span class="line">    contents = Padding(padding: padding!, child: contents);</span><br><span class="line">  <span class="comment">// 这里scrollController如果没有指定或者primary为true的话会使用上级最近的</span></span><br><span class="line">  <span class="comment">// PrimaryScrollController</span></span><br><span class="line">  <span class="keyword">final</span> ScrollController? scrollController = primary</span><br><span class="line">      ? PrimaryScrollController.of(context)</span><br><span class="line">      : controller;</span><br><span class="line">  <span class="comment">// 正如我们之前所说，SingleChildScrollView实现其实也就是对Scrollable的</span></span><br><span class="line">  <span class="comment">// 进一步封装，提供一些自己特有的内容，比如_SingleChildViewport</span></span><br><span class="line">  Widget scrollable = Scrollable(</span><br><span class="line">    dragStartBehavior: dragStartBehavior,</span><br><span class="line">    axisDirection: axisDirection,</span><br><span class="line">    controller: scrollController,</span><br><span class="line">    physics: physics,</span><br><span class="line">    restorationId: restorationId,</span><br><span class="line">    viewportBuilder: (BuildContext context, ViewportOffset offset) &#123;</span><br><span class="line">      <span class="comment">// 这里使用了自定义的Viewport来实现布局逻辑</span></span><br><span class="line">      <span class="keyword">return</span> _SingleChildViewport(</span><br><span class="line">        axisDirection: axisDirection,</span><br><span class="line">        offset: offset,<span class="comment">// offset就是Scrollable处理的ScrollPosition</span></span><br><span class="line">        clipBehavior: clipBehavior,</span><br><span class="line">        child: contents,<span class="comment">// 就是我们传入的child</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里处理了滑动时键盘隐藏的问题</span></span><br><span class="line">  <span class="keyword">if</span> (keyboardDismissBehavior == ScrollViewKeyboardDismissBehavior.onDrag) &#123;</span><br><span class="line">    scrollable = NotificationListener&lt;ScrollUpdateNotification&gt;(</span><br><span class="line">      child: scrollable,</span><br><span class="line">      onNotification: (ScrollUpdateNotification notification) &#123;</span><br><span class="line">        <span class="keyword">final</span> FocusScopeNode focusNode = FocusScope.of(context);</span><br><span class="line">        <span class="keyword">if</span> (notification.dragDetails != <span class="keyword">null</span> &amp;&amp; focusNode.hasFocus) &#123;</span><br><span class="line">          focusNode.unfocus();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> primary &amp;&amp; scrollController != <span class="keyword">null</span></span><br><span class="line">    ? PrimaryScrollController.none(child: scrollable)</span><br><span class="line">    : scrollable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，正如之前所言，SingleChildScrollView是依赖于封装Scrollable实现滑动效果。我们注意到在Scrollable.viewportBuilder中传入的是_SingleChildViewport，这个类处理了Scrollable传入的ScrollPosition也即这里的ViewportOffset：</p>
<h2 id="SingleChildViewport"><a href="#SingleChildViewport" class="headerlink" title="_SingleChildViewport"></a>_SingleChildViewport</h2><p>_SingleChildViewport继承自SingleChildRenderObjectWidget，主要逻辑是创建和更新RenderObject——_RenderSingleChildViewport。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SingleChildViewport</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _RenderSingleChildViewport createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> _RenderSingleChildViewport(</span><br><span class="line">      axisDirection: axisDirection,</span><br><span class="line">      offset: offset,<span class="comment">// 此处的offset是来自于Scrollable的ScrollPosition</span></span><br><span class="line">      clipBehavior: clipBehavior,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, _RenderSingleChildViewport renderObject) &#123;</span><br><span class="line">    <span class="comment">// Order dependency: The offset setter reads the axis direction.</span></span><br><span class="line">    renderObject</span><br><span class="line">      ..axisDirection = axisDirection</span><br><span class="line">      ..offset = offset<span class="comment">// 此处的offset是来自于Scrollable的ScrollPosition</span></span><br><span class="line">      ..clipBehavior = clipBehavior;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见处理offset以便更新content实现滑动效果的主要逻辑在_RenderSingleChildViewport这个RenderObject中。</p>
<h2 id="RenderSingleChildViewport"><a href="#RenderSingleChildViewport" class="headerlink" title="_RenderSingleChildViewport"></a>_RenderSingleChildViewport</h2><p>先看一下_RenderSingleChildViewport的继承关系：<br><code>class _RenderSingleChildViewport extends RenderBox with RenderObjectWithChildMixin&lt;RenderBox&gt; implements RenderAbstractViewport&#123;&#125;</code></p>
<p>由上述代码可知，_RenderSingleChildViewport：</p>
<ul>
<li>是RenderBox，也就是说其内部lay out遵守box protocol</li>
<li>混入了RenderObjectWithChildMixin<RenderBox>，RenderObjectWithChildMixin为RenderObject提供一套管理单个child的模式，它的<strong>泛型指定了child的类型只能是RenderBox</strong>，这也就是为什么我们之前说SingleChildScrollView的child只能是box widget。</li>
<li>实现了RenderAbstractViewport接口，这个接口表示render object是内部比实际要大，提供了一些方法供ScrollPosition和其他viewport调用，来获取一些使此viewport在屏幕上可见的信息。</li>
</ul>
<p>在修改axisDirection、offset、cacheExtent等三个属性的时候会触发markNeedsLayout()方法重新进行lay out；<br>在修改clipBehavior属性的时候只会触发markNeedsPaint()和markNeedsSemanticsUpdate()方法。</p>
<p>此外，在每次设置offset的时候，都会对齐添加监听，这样当Scrollable中由于用户手势或者通过ScrollController调用jumpTo&#x2F;animateTo等方法修改了ScrollPosition的时候，都会使得Scrollab的viewport也就是我们这里的_RenderSingleChildViewport收到通知、从而进行对应处理：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> offset(ViewportOffset value) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(value != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (value == _offset)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (attached)</span><br><span class="line">  <span class="comment">// 先移除已有的监听</span></span><br><span class="line">    _offset.removeListener(_hasScrolled);</span><br><span class="line">  _offset = value;</span><br><span class="line">  <span class="keyword">if</span> (attached)</span><br><span class="line">  <span class="comment">// 再为新的offset添加监听</span></span><br><span class="line">    _offset.addListener(_hasScrolled);</span><br><span class="line">  markNeedsLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _hasScrolled() &#123;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">  markNeedsSemanticsUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上述在修改offset的时候添加&#x2F;移除监听，在attach&#x2F;detach方法中也有对应操作：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> attach(PipelineOwner owner) &#123;</span><br><span class="line">  <span class="keyword">super</span>.attach(owner);</span><br><span class="line">  _offset.addListener(_hasScrolled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> detach() &#123;</span><br><span class="line">  _offset.removeListener(_hasScrolled);</span><br><span class="line">  <span class="keyword">super</span>.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的分析我们也可以看出，除了设置修改axisDirection、offset、cacheExtent等属性的时候会触发layout外，其余时候只会触发重新paint。</p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>一般来说Flutter Widget要展示在屏幕上需要经历build、layout、paint三步，在分析SingleChildScrollView如何根据offset的变化实现scroll效果之前，我们先看一下他是如何实现layout的。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    <span class="keyword">final</span> BoxConstraints constraints = <span class="keyword">this</span>.constraints;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">      size = constraints.smallest;<span class="comment">// 如果child为空，则按照父级的最小尺寸来</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果有child，就不限制主轴方向的尺寸，让child进行layout（会得到最大的主轴尺寸）</span></span><br><span class="line">      child!.layout(_getInnerConstraints(constraints), parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 在父级约束范围内尽可能满足child的尺寸</span></span><br><span class="line">      size = constraints.constrain(child!.size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用_viewportExtent作为offset的viewport范围</span></span><br><span class="line">    offset.applyViewportDimension(_viewportExtent);</span><br><span class="line">    <span class="comment">// 更新viewport的内容content的大小范围</span></span><br><span class="line">    offset.applyContentDimensions(_minScrollExtent, _maxScrollExtent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有横轴方向的约束，没有主轴方向的约束</span></span><br><span class="line">BoxConstraints _getInnerConstraints(BoxConstraints constraints) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (axis) &#123;</span><br><span class="line">      <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">        <span class="comment">// 如果是水平布局，就只限制高度，不限制宽度</span></span><br><span class="line">        <span class="keyword">return</span> constraints.heightConstraints();</span><br><span class="line">      <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">        <span class="comment">// 如果是垂直布局，就只限制宽度，不限制高度</span></span><br><span class="line">        <span class="keyword">return</span> constraints.widthConstraints();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在SingleChildScrollView先让child在主轴方向尽可能自由布局，取得其最大值，然后自身在满足父级约束的情况下应用child的size：如果child.size在父级约束内就直接应用，负责采用父级的约束。</p>
<p>这样最终的效果就是我们的SingleChildScrollView在child不超过父级约束的时候只占据child的内容，当child的内容大于父级约束时，SingleChildScrollView自身的尺寸是父级给定的最大尺寸，而child本身在主轴方向上的尺寸是大于SingleChildScrollView的尺寸。这样也为我们后续通过监听offset修改显示部分child的内容实现滑动效果提供了可能。</p>
<blockquote>
<p>这也告诉我们SingleChildScrollView的父级需要指定指定主轴方向约束，否则会出现异常。<br>比如在Column中直接使用SingleChildScrollView就会在内容过长的时候发生<em>overflowed</em>错误并且无法滑动SingleChildScrollView，这是因为SingleChildScrollView和child都按照最长的尺寸布局，并且这个尺寸超过了父级约束。<br>在SingleChildScrollView外层添加Expanded作为父级，相当于给他指定了一个约束（占据剩余空间），所以可以解决这个问题。</p>
</blockquote>
<p>之后，又根据_viewportExtent以及_minScrollExtent&#x2F;_maxScrollExtent分别设置了viewport和content的范围，让我们看一下这三个值的来历：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> _viewportExtent &#123;</span><br><span class="line">  <span class="keyword">assert</span>(hasSize);</span><br><span class="line">  <span class="keyword">switch</span> (axis) &#123;</span><br><span class="line">    <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">      <span class="keyword">return</span> size.width;</span><br><span class="line">    <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">      <span class="keyword">return</span> size.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，_viewportExtent是取值主轴方向的size大小，也就是SingleChildScrollView的尺寸。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> _minScrollExtent &#123;</span><br><span class="line">  <span class="keyword">assert</span>(hasSize);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> _maxScrollExtent &#123;</span><br><span class="line">  <span class="keyword">assert</span>(hasSize);</span><br><span class="line">  <span class="keyword">if</span> (child == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (axis) &#123;</span><br><span class="line">    <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">      <span class="keyword">return</span> math.max(<span class="number">0.0</span>, child!.size.width - size.width);</span><br><span class="line">    <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">      <span class="keyword">return</span> math.max(<span class="number">0.0</span>, child!.size.height - size.height);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_minScrollExtent默认返回0.0；<br>_maxScrollExtent返回的是主轴方向上child减去SingleChildScrollView之后的尺寸和0.0之间的最大值，换言之，如果child比SingleChildScrollView尺寸大，_maxScrollExtent就是多出来的那一部分，也就是我们可以滑动的范围，否则为0.0，也就是SingleChildScrollView不可滑动。</p>
<h3 id="paint"><a href="#paint" class="headerlink" title="paint"></a>paint</h3><p>到目前为止，我们的SingleChildScrollView顺利得到了尺寸，假设child尺寸大于SingleChildScrollView的最大尺寸，那么当用户滑动屏幕导致offset改变的时候，又是如何实现滑动效果的呢？</p>
<p>先看一个属性：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// offset.pixels表示child沿着与轴方向axis direction相反的方法offset的pixels</span></span><br><span class="line"><span class="comment">// 比如axis direction是down的话，手指向上滑动屏幕此值增大，否则减小</span></span><br><span class="line">Offset <span class="keyword">get</span> _paintOffset =&gt; _paintOffsetForPosition(offset.pixels);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据position计算出child实际在SingleChildScrollView中的offset</span></span><br><span class="line"><span class="comment">// 以child的左上角在SingleChildScrollView左上角为0.0，向上为负，向下为正</span></span><br><span class="line">Offset _paintOffsetForPosition(<span class="built_in">double</span> position) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(axisDirection != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">switch</span> (axisDirection) &#123;</span><br><span class="line">    <span class="keyword">case</span> AxisDirection.up:</span><br><span class="line">      <span class="keyword">return</span> Offset(<span class="number">0.0</span>, position - child!.size.height + size.height);</span><br><span class="line">    <span class="keyword">case</span> AxisDirection.down:</span><br><span class="line">      <span class="keyword">return</span> Offset(<span class="number">0.0</span>, -position);</span><br><span class="line">    <span class="keyword">case</span> AxisDirection.left:</span><br><span class="line">      <span class="keyword">return</span> Offset(position - child!.size.width + size.width, <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">case</span> AxisDirection.right:</span><br><span class="line">      <span class="keyword">return</span> Offset(-position, <span class="number">0.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，_paintOffset是根据ScrollPosition计算出来的真正的child和SingleChildScrollView的偏移offset。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> Offset paintOffset = _paintOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> paintContents(PaintingContext context, Offset offset) &#123;</span><br><span class="line">      <span class="comment">// 可以看到这里，除了父级传入的offset外，还应用了ScrollPosition改变而变化的</span></span><br><span class="line">      <span class="comment">// paintOffset。这样每次Scrollable修改ScrollPosition之后都会触发paint</span></span><br><span class="line">      <span class="comment">// 方法，使用新的paintOffset绘制child</span></span><br><span class="line">      context.paintChild(child!, offset + paintOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_shouldClipAtPaintOffset(paintOffset) &amp;&amp; clipBehavior != Clip.none) &#123;</span><br><span class="line">      _clipRectLayer.layer = context.pushClipRect(</span><br><span class="line">        needsCompositing,</span><br><span class="line">        offset,</span><br><span class="line">        Offset.zero &amp; size,</span><br><span class="line">        paintContents,</span><br><span class="line">        clipBehavior: clipBehavior,</span><br><span class="line">        oldLayer: _clipRectLayer.layer,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _clipRectLayer.layer = <span class="keyword">null</span>;</span><br><span class="line">      paintContents(context, offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们可以得出以下结论：</p>
<p>_RenderSingleChildViewport接收传入的child，并监听传入的Offset，当其变化时执行markNeedPaint()；<br>其先让child在主轴方向尽可能大的进行layout，然后自身在父级约束条件下尽可能满足child size，这样当child比父级给的约束大时，child保持自身大小，而viewport的size则在父级给的最大尺寸内展示一部分child内容；<br>当Offset变化时，按照Offset.pixels计算出对应的paintOffset，重新绘制child，展示另外一部分child的内容，从而实现滑动效果。</p>
<h3 id="hitTest"><a href="#hitTest" class="headerlink" title="hitTest"></a>hitTest</h3><p>_RenderSingleChildViewport将hitTest直接转发给了child：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> hitTestChildren(BoxHitTestResult result, &#123; <span class="keyword">required</span> Offset position &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result.addWithPaintOffset(</span><br><span class="line">      offset: _paintOffset,</span><br><span class="line">      position: position,</span><br><span class="line">      hitTest: (BoxHitTestResult result, Offset transformed) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(transformed == position + -_paintOffset);</span><br><span class="line">        <span class="keyword">return</span> child!.hitTest(result, position: transformed);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>至此，SingleChildScrollView基于Scrollable、ScrollPosition和_RenderSingleChildView完成了支持内部单个box widget的滑动效果。</p>
<h1 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h1><p>相对于使用Sliver实现滑动效果的Widget来说，SingleChildScrollView使用简单，使用的是box protocol，适用于child通常是完全可见的，但是在某些特殊场景（比如竖屏变为横屏等）下可能显示不全的情况，SingleChildScrollView可以保证在父级无法完整显示child的时候使其支持滑动。<br>SingleChildScrollView使用起来也比较方便。</p>
<p>但是，正如上面分析的，无论content是否可见，SingleChildScrollView都会将其layout&#x2F;paint（也就是说<strong>会将所有内容全部加载</strong>），这样如果content超出viewport的部分比较多就会非常<strong>耗费性能</strong>。</p>
<p>对于这种情况，就应该考虑使用ListView&#x2F;GridView&#x2F;CustomScrollView等基于sliver protocol的scrollable widget。在shrinkWrap属性为false的情况下，viewport会只创建<strong>屏幕可见部分 + viewport前后缓存区域</strong>的内容，在content滑出这部分区域时dispose，当其再次滑入时再recreate，从而保证性能。</p>
<h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1><h2 id="为Column的children安全应用spacedAround，center等效果"><a href="#为Column的children安全应用spacedAround，center等效果" class="headerlink" title="为Column的children安全应用spacedAround，center等效果"></a>为Column的children安全应用spacedAround，center等效果</h2><p>想要给Column的children设置spacedAround效果，又需要保证在父级空间不足时能够完整显示所有children的内容的话，就需要结合SingleChildScrollView（空间不足时可滑动）、LayoutBuilder（获取父级约束信息）、ConstrainedBox（设置Column约束）来实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: LayoutBuilder(<span class="comment">// 获取父级约束信息</span></span><br><span class="line">        builder: (BuildContext context, BoxConstraints viewportConstraints) &#123;</span><br><span class="line">          <span class="keyword">return</span> SingleChildScrollView(<span class="comment">// 父级空间不足时可以滚动</span></span><br><span class="line">            child: ConstrainedBox(</span><br><span class="line">              constraints: BoxConstraints(</span><br><span class="line">        <span class="comment">// 这里指定最小高度为父级高度，所以空间足够时Column可以按需分布children，</span></span><br><span class="line">        <span class="comment">// 空间不足时则将children一个个依次排列（互相之间space为0）</span></span><br><span class="line">                minHeight: viewportConstraints.maxHeight,</span><br><span class="line">              ),</span><br><span class="line">              child: Column(</span><br><span class="line">                mainAxisSize: MainAxisSize.min,<span class="comment">// 默认主轴尺寸尽可能的小</span></span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  Container(</span><br><span class="line">                    <span class="comment">// A fixed-height child.</span></span><br><span class="line">                    color: <span class="keyword">const</span> Color(<span class="number">0xffeeee00</span>), <span class="comment">// Yellow</span></span><br><span class="line">                    height: <span class="number">120.0</span>,</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    child: <span class="keyword">const</span> Text(<span class="string">&#x27;Fixed Height Content&#x27;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                  Container(</span><br><span class="line">                    <span class="comment">// Another fixed-height child.</span></span><br><span class="line">                    color: <span class="keyword">const</span> Color(<span class="number">0xff008000</span>), <span class="comment">// Green</span></span><br><span class="line">                    height: <span class="number">120.0</span>,</span><br><span class="line">                    alignment: Alignment.center,</span><br><span class="line">                    child: <span class="keyword">const</span> Text(<span class="string">&#x27;Fixed Height Content&#x27;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<p>这里使用ConstrainedBox确保了Column主轴方向最小尺寸是父级大小：</p>
<ul>
<li>当父级尺寸大于Column的children尺寸时，多出的空隙由Column按照MainAxisAlignment.spaceAround原则分配，由于SingleChildScrollView的child尺寸和父级一致，所需不会滑动；</li>
<li>当父级尺寸小于Column的children尺寸时，Column的尺寸为children的尺寸之和（相互之间没有间隙），此时SingleChildScrollView的child尺寸大于父级尺寸，所以可以上下滑动，保证了Column的children可以完全显示。</li>
</ul>
<h2 id="为Column的children安全应用Expanded、Space等效果"><a href="#为Column的children安全应用Expanded、Space等效果" class="headerlink" title="为Column的children安全应用Expanded、Space等效果"></a>为Column的children安全应用Expanded、Space等效果</h2><p>在一些场景下，需要用到Expanded、Space等填充Column剩余的空间以展示某些内容，比如一直位于屏幕下方的版权信息，但是当Column的children尺寸大于父级尺寸时，又会导致children内容无法完整显示，如果直接在Column上加一个SingleChildScrollView作为父级，又会因为SingleChildScrollView给child在主轴方向的尺寸无限制，而Expanded又要求占据所有剩余空间从而导致出错。</p>
<p>此时可以在上面例子的基础上增加IntrinsicHeight&#x2F;InstrinsicWidth来解决此问题：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">LayoutBuilder(<span class="comment">// 获取父级约束信息</span></span><br><span class="line">        builder: (BuildContext context, BoxConstraints viewportConstraints) &#123;</span><br><span class="line">          <span class="keyword">return</span> SingleChildScrollView(<span class="comment">// 保证child超出父级限制时可以滑动</span></span><br><span class="line">            child: ConstrainedBox(</span><br><span class="line">              constraints: BoxConstraints(</span><br><span class="line">        <span class="comment">// 这里指定最小高度为父级高度，所以空间足够时Column可以按需分布children，</span></span><br><span class="line">        <span class="comment">// 空间不足时则将children一个个依次排列（互相之间space为0）</span></span><br><span class="line">                minHeight: viewportConstraints.maxHeight,</span><br><span class="line">              ),</span><br><span class="line">              child: IntrinsicHeight(</span><br><span class="line">        <span class="comment">// 当minHeight:viewportConstraints.maxHeight比Column想要的大时，</span></span><br><span class="line">        <span class="comment">// 那么Column采用viewportConstraints.maxHeight的值</span></span><br><span class="line">        <span class="comment">// 否则Column按照自己的内容大小来</span></span><br><span class="line">                child: Column(</span><br><span class="line">                  children: &lt;Widget&gt;[</span><br><span class="line">                    Container(</span><br><span class="line">                      <span class="comment">// A fixed-height child.</span></span><br><span class="line">                      color: <span class="keyword">const</span> Color(<span class="number">0xffeeee00</span>), <span class="comment">// Yellow</span></span><br><span class="line">                      height: <span class="number">320.0</span>,</span><br><span class="line">                      alignment: Alignment.center,</span><br><span class="line">                      child: <span class="keyword">const</span> Text(<span class="string">&#x27;Fixed Height Content&#x27;</span>),</span><br><span class="line">                    ),</span><br><span class="line">                    Expanded(</span><br><span class="line">                      <span class="comment">// A flexible child that will grow to fit the viewport but</span></span><br><span class="line">                      <span class="comment">// still be at least as big as necessary to fit its contents.</span></span><br><span class="line">                      child: Container(</span><br><span class="line">                        color: <span class="keyword">const</span> Color(<span class="number">0xffee0000</span>), <span class="comment">// Red</span></span><br><span class="line">                        height: <span class="number">120.0</span>,</span><br><span class="line">                        alignment: Alignment.center,</span><br><span class="line">                        child: <span class="keyword">const</span> Text(<span class="string">&#x27;Flexible Content&#x27;</span>),</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                  ],</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<p>在上面例子中，作为SingleChildScrollView子级的Column内部能够使用Expanded的关键在于InstrinsicHeight：它的定义是“一个将child调整为child固有高度的widget”，也就是说，当<strong>child可能有无限的高度时，与其无限拓展，它更希望将自己size定位一个更加合理的固有高度</strong>（Expanded、Spacer等非RenderObjectWidget本身没有高度，所以在这里不会被计算）。</p>
<p>那么，当父级指定的最小约束minHeight大于InstrinsicHeight.child的最大固有高度时，child将按照父级的最小高度设置；<br>当父级指定的最大约束是double.infinity无限大时，InstrinsicHeight会强制其child的大小为固有高度。</p>
<p>但是需要注意的是，IntrinsicHeight&#x2F;InstrinsicWidth因为至少需要对child进行两次layout（一次获取intrinsic dimensions，一次真正的执行layout），所以会<strong>比较耗费性能</strong>。因此应当保证Column子级数量尽可能少，并且可以使用SizeBox给child指定大小以减轻计算intrinsic dimensions的压力。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SingleChildScrollView作为遵守box protocol的scrollable widget，使用简单，适用于页面内容通常为全部可见，但特殊情况下可能无法完整显示因而需要支持滚动的情况。</p>
<p>其child只支持可以生成RenderBox的Widget，会一次性创建所有child内容，在其内部使用ListView等时需要开启shrinkWrap从而导致其懒创建item失效，比较耗费性能。</p>
<p>因此，如果是大量item、child内容超出viewport部分时，应当考虑使用基于Sliver的ListView&#x2F;GridView&#x2F;CustomScrollView等。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://api.flutter.dev/flutter/widgets/SingleChildScrollView-class.html">SingleChildScrollView_api.flutter.dev</a></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JVM内存分配</title>
    <url>/blog/posts/f31c11c5/</url>
    <content><![CDATA[<blockquote>
<p>本笔记基于《深入理解Java虚拟机：JVM高级特性与最佳实践》及部分在线博客整理。</p>
</blockquote>
<p>JVM：java virtual machine，一个java程序（进程）拥有一个jvm实例</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>JVM区域总体分两类，heap区和非heap区:</p>
<p><strong>heap区</strong>：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。<br><strong>非heap区</strong>：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(Java虚拟机栈)、Local Method Statck(本地方 法栈)。</p>
<h1 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h1><h2 id="1-head"><a href="#1-head" class="headerlink" title="1.head"></a>1.head</h2><p>堆，所有线程共享，存放所有对象实例、数组，GC主要场所，会OOM</p>
<p>分类</p>
<p><strong>1.新生代</strong></p>
<ul>
<li><p>eden  刚刚创建的对象优先</p>
</li>
<li><p>s1  经历几次GC</p>
</li>
<li><p>s2  经历几次GC</p>
</li>
</ul>
<p><strong>2.老年代</strong></p>
<ul>
<li><p>存活时间长的老年对象</p>
</li>
<li><p>大对象，如数组，大String…</p>
</li>
</ul>
<h2 id="2-stack"><a href="#2-stack" class="headerlink" title="2.stack"></a>2.stack</h2><p>栈，线程私有，存放基本数据和对象的引用，LIFO，会OOM，StackOverflow</p>
<h3 id="java-virtual-machine-stack"><a href="#java-virtual-machine-stack" class="headerlink" title="java virtual machine stack"></a>java virtual machine stack</h3><p>线程请求的栈深度大于JVM允许的深度会导致Stack Overflow<br>在编译期完成内存分配，如果虚拟机栈可以动态扩展，但是当拓展时无法申请到足够内存时会导致OutOfMemory</p>
<p><strong>stack  frame</strong></p>
<p>stack frame：栈帧，每执行一个方法就会产生一个栈帧并压入栈中</p>
<ul>
<li><p>局部变量表</p>
<ul>
<li>基本数据类型</li>
<li>对象引用</li>
<li>returnAddress 类型,指向了一条字节码指令的位置</li>
</ul>
</li>
<li><p>操作数栈</p>
</li>
<li><p>动态链接</p>
</li>
<li><p>方法出口等</p>
</li>
</ul>
<h3 id="native-method-stack"><a href="#native-method-stack" class="headerlink" title="native method stack"></a>native method stack</h3><p>与java虚拟机栈作用类似，不过native method stack是为native方法服务。<br>jvm可以自由实现它，甚至在sun HotSpot VM中将他与虚拟机栈合并<br>会OOM，stackOverflow</p>
<h2 id="3-method-area"><a href="#3-method-area" class="headerlink" title="3.method area"></a>3.method area</h2><p>方法区，线程共享，存放类信息，常量，静态变量，即时编译器编译后的代码，会OOM</p>
<p><strong>运行时常量池</strong></p>
<p>类加载后，编译器生成的各种字面量和符号引用会放到方法区的运行时常量池中，会OOM<br><code>String.intern()</code>，有该string对象则返回，无则创建并返回</p>
<blockquote>
<p><code>String.intern()</code>方法的注意事项：</p>
<p>JDK1.6及以下：将首次出现的对象实例<strong>复制</strong>到永久代，返回其引用</p>
<p>JDK1.7及以上：只会<strong>记录</strong>下首次出现的实例的引用，返回其引用</p>
<p>所以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">System.out.println(s2.intern() == s2);</span><br></pre></td></tr></table></figure>

<p>在JDK1.6及以下输出<code>false</code>，在JDK1.7及以上输出<code>true</code></p>
<p>此外，由于<code>String</code>类是<code>final</code>的，每次<code>new String(&quot;str&quot;)</code>会产生两个对象：一个是字符串<code>str</code>本身，一个是值为<code>str</code>的字符串。</p>
</blockquote>
<p>以<code>String s = &quot;Hello&quot;;</code>为例，解释几个概念：</p>
<p><strong>字面量</strong> 源码中表示具体的值，如<code>Hello</code></p>
<p><strong>符号引用</strong> 用来指代某种值得符号，如<code>s</code></p>
<p><strong>直接引用</strong> 可以定位到内存中的（类、对象、方法、变量）等的具体地址</p>
<h2 id="4-program-count"><a href="#4-program-count" class="headerlink" title="4.program count"></a>4.program count</h2><p><strong>程序计数器</strong>，线程私有，占用内存小，当做当前线程执行字节码的行号指示器。</p>
<p>若执行java方法，计数器记录的是正在执行的虚拟机字节码指令的位置</p>
<p>若执行的是native方法，则计数器为空undefined。</p>
<p>此内存区域是唯一一个在java虚拟机规范字没有规定任何OOMError的区域</p>
<h1 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h1><blockquote>
<p>以Sun HotSpot VM 为例</p>
</blockquote>
<h2 id="1-java堆溢出"><a href="#1-java堆溢出" class="headerlink" title="1.java堆溢出"></a>1.java堆溢出</h2><p>对象过多导致head内存溢出</p>
<ol>
<li>是内存泄漏memory leak，定位泄露对象</li>
<li>是内存溢出memory overflow，检查虚拟机堆参数是否可以调大；去除非必须的生命周期长的对象</li>
</ol>
<h2 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.虚拟机栈和本地方法栈溢出"></a>2.虚拟机栈和本地方法栈溢出</h2><ol>
<li><p>单线程，Stack Overflow</p>
<p>单线程下，栈帧过大或者虚拟机栈容量太小，当内存无法分配时都会导致Stack Overflow异常</p>
</li>
<li><p>多线程，</p>
<p>多线程时，每个线程栈分配的内存越大，越容易尝试内存溢出OOM</p>
<p>原因：虚拟机最大内存一定的情况下，去掉共享的Head和MethodArea占的内存，剩下的内存&#x2F;单个线程最大栈内存&#x3D;最大线程数量，当单个线程最大栈内存增加时，可以产生的线程数就会越少</p>
</li>
</ol>
<h2 id="3-运行时常量池溢出"><a href="#3-运行时常量池溢出" class="headerlink" title="3.运行时常量池溢出"></a>3.运行时常量池溢出</h2><p>运行时常量池属于方法区，当常量过多时会导致OOM，可以用String.intern()方法尝试</p>
<h2 id="4-方法区溢出"><a href="#4-方法区溢出" class="headerlink" title="4.方法区溢出"></a>4.方法区溢出</h2><p>经常动态生成大量Class的应用，如Spring等框架，需要注意OOM</p>
<h2 id="5-本地直接内存溢出"><a href="#5-本地直接内存溢出" class="headerlink" title="5.本地直接内存溢出"></a>5.本地直接内存溢出</h2><p>原生方法直接操作物理内存时导致物理内存不够，产生OOM</p>
<h1 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h1><p>JVM中GC会根据不同情况采取以下一系列算法组合进行内存回收</p>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1.复制算法"></a>1.复制算法</h3><p><strong>原理</strong>：内存一分为二，只使用一半；GC时将存活对象复制到另一半内存，剩下的则清空</p>
<p><strong>优缺点</strong>：1.无STW，但不适合对象过多的情况；2.内存利用效率低</p>
<h3 id="2-标记清除法"><a href="#2-标记清除法" class="headerlink" title="2.标记清除法"></a>2.标记清除法</h3><p><strong>原理</strong>：从GC Roots开始遍历，可达标记存活，不可达则未标记</p>
<p>java中，GC Roots可以是以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<p><strong>优缺点</strong>：1.要StopTheWorld防止标记的时候新new的对象未被标记而出错；</p>
<p>2.清除对象后内存不连续，会有一定的浪费</p>
<h3 id="3-标记压缩法"><a href="#3-标记压缩法" class="headerlink" title="3.标记压缩法"></a>3.标记压缩法</h3><p><strong>原理</strong>：类似【标记清除法】，但会对标记进行压缩，如a-&gt;b-&gt;c，会被压缩为a-&gt;c，具体试讲所有存活的对象都向一端移动，直接清理掉端边界外的内存</p>
<p><strong>优缺点</strong>：1.也要StopTheWorld</p>
<h3 id="4-引用计数算法"><a href="#4-引用计数算法" class="headerlink" title="4.引用计数算法"></a>4.引用计数算法</h3><p><strong>原理</strong>：引用+1，不引用-1，为0则删除，但是会有相互循环引用的问题，java未使用</p>
<p><strong>优缺点</strong>：相互循环使用：<br>a &#x3D; b<br>b &#x3D; a<br>除此之外再没有用到a，b的地方，但是由于a，b的引用不为0所以无法被回收，导致内存浪费</p>
<h2 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h2><p>一个不可达对象在“死缓”到“执行死刑”前至少经历两个标记过程</p>
<ol>
<li><p>第一次标记，筛选：是否有必要执行finalize()方法，若是则放到F-Queue队列中【触发】该方法，但不保证执行完该方法。</p>
<p>可以在finlize()方法中<strong>自救一次</strong>：在该方法中将<em>自身this</em>赋值给其他变量，这样在第二次标记时会被移出<em>即将回收</em>集合；但是由于finlize()方法只会被调用一次，所以只能自救一次。并<em>不推荐该方法</em>，该方法所有可以做的工作，可以用<strong>try…finally</strong>或者其他方法更好的实现</p>
</li>
<li><p>第二次标记，若finalize()方法以及调用过，或者为重写该方法，则“没必要执行”，可以回收</p>
</li>
</ol>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><h3 id="强引用StrongReference"><a href="#强引用StrongReference" class="headerlink" title="强引用StrongReference"></a>强引用StrongReference</h3><p>People p &#x3D; new People();哪怕抛出OOM也不会被GC回收的对象</p>
<h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h3><p>SoftReference sf &#x3D; new SoftReference(p);只要有足够内存就不会被GC回收，若内存不够则会被GC回收，常用作服务器缓存</p>
<h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h3><p>在下次GC回收之前都存在，用作android等内存紧张的设备中的缓存</p>
<h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a>虚引用PhantomReference</h3><p>无法影响其生存时间，也无法通过虚引用获取其实例，设置虚引用只是为了在对象被GC回收时获取系统通知</p>
<h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="https://jixiaoyong.github.io/images/blog/2018-02/JVMMemory.png"></p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载机制之ClassLoader</title>
    <url>/blog/posts/b3994218/</url>
    <content><![CDATA[<blockquote>
<p>本文为<a href="https://blog.csdn.net/briblue/article/details/54973413">《一看你就懂，超详细java中的ClassLoader详解 - CSDN博客》</a>阅读笔记</p>
</blockquote>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>JVM有三种类加载器：</p>
<ol>
<li><strong>BootStrap ClassLoader</strong> 启动类加载器，加载核心类库，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。</li>
<li><strong>Extention ClassLoader</strong> 扩展类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。</li>
<li><strong>App ClassLoader</strong> 应用程序加载器，加载当前应用的classpath的所有类。</li>
</ol>
<p>除以上三种外，还有用户自定义的类加载器。</p>
<p>每个类由加载它的类加载器和类本身确定其唯一性。也就是说，类加载器不同，类肯定不同。</p>
<h1 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h1><p>在加载类时，通过<strong>“双亲委托”</strong>机制，依次从<strong>1</strong> -&gt; <strong>3</strong>向上查询，再从<strong>3</strong>-&gt;<strong>1</strong>依次返回结果：</p>
<ol>
<li>调用<code>findLoadedClass(className) </code>查询是否已经加载该类</li>
<li>调用父加载器的<code>loadClass(className,false)</code>，若父加载器为空，则调用<code>BootStrap ClassLoader</code></li>
<li>如果还是没有加载到该类，调用<code>findClass(className)</code></li>
</ol>
<p>这样子保证了每个类都是先经过最顶端的类加载器<code>BootStrap ClassLoader</code>，如果没有加载到再依次经过<code>Extention ClassLoader</code>、<code>App ClassLoader</code> 加载，确保如String等关键类不会被自定义的ClassLoader加载而导致异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="comment">//父加载器没有找到，则调用findclass</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                <span class="comment">//调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>AppClassLoader</code>和<code>ExtClassLoader</code>都继承自<code>URLClassLoader</code></p>
<p><code>AppClassLoader</code>的父加载器是<code>ExtClassLoader</code>，<code>ExtClassLoader</code>的父加载器为<code>null</code>，故而会调用<code>BootStrap ClassLoader</code></p>
<p>ClassLoader如果没有指定父加载器，则默认的父加载器为<code>AppClassLoader</code>，自定义ClassLoader也是如此。</p>
<h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h1><p>自定义ClassLoader一般步骤：</p>
<ol>
<li>继承自<code>ClassLoader</code></li>
<li>重写<code>findClass()</code></li>
<li>在<code>findClass()</code>方法中调用并返回<code>defineClass()</code></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MClasLoader</span>:<span class="type">ClassLoader</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findClass</span><span class="params">(name: <span class="type">String</span>?)</span></span>: Class&lt;*&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sysDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> classPath = <span class="string">&quot;<span class="variable">$sysDir</span>/src/main/res/<span class="variable">$name</span>.class&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> classFile = File(classPath)</span><br><span class="line">        <span class="comment">//【注意】这里一次只读取一个字节，否则会报错java.lang.ClassFormatError:</span></span><br><span class="line">        <span class="comment">// Extra bytes at the end of class file TestClass</span></span><br><span class="line">        <span class="keyword">var</span> bytes = ByteArray(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> fileInputStream = FileInputStream(classFile)</span><br><span class="line">        <span class="keyword">var</span> len = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> byteBuffer = ByteOutputStream()</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            len = fileInputStream.read(bytes)</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.write(bytes)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> byteArr = byteBuffer.toByteArray()</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,byteArr,<span class="number">0</span>,byteArr.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clazz = MClasLoader().loadClass(<span class="string">&quot;TestClass&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> say = clazz.getDeclaredMethod(<span class="string">&quot;say&quot;</span>,String::<span class="keyword">class</span>.java)</span><br><span class="line">    say.invoke(clazz.newInstance(),<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(MClasLoader().parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>defineClass()</code>则将一个字节数组转化为一个类的实例（Converts an array of bytes into an instance of class with an optional ProtectionDomain）</p>
<h1 id="contextClassLoader"><a href="#contextClassLoader" class="headerlink" title="contextClassLoader"></a>contextClassLoader</h1><p>每个线程都有一个ClassLoader：<code>contextClassLoader</code>，通过将其设置为自定义的ClassLoader可以在加载类的时候做一些特殊的事情。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().contextClassLoader = MClasLoader()</span><br><span class="line"><span class="keyword">var</span> clazz = Class.forName(<span class="string">&quot;TestClass&quot;</span>,</span><br><span class="line">        <span class="literal">true</span>, Thread.currentThread().contextClassLoader)</span><br><span class="line"><span class="keyword">var</span> say = clazz.getDeclaredMethod(<span class="string">&quot;say&quot;</span>,String::<span class="keyword">class</span>.java)</span><br><span class="line">say.invoke(clazz.newInstance(),<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">println(Thread.currentThread().contextClassLoader )</span><br><span class="line">println(Thread.currentThread().contextClassLoader.parent )</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">MClasLoader@1d44bcfa</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载机制解析</title>
    <url>/blog/posts/cf83ef31/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文介绍了java虚拟机类加载机制。</p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>JVM类加载一共7步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的1,2,3步，在实际中有可能从其中间某一步开始。</p>
<p>类加载机制一般分为三部分：<strong>加载Loading -&gt; 连接Linking -&gt; 初始化Initializing</strong></p>
<p><img src="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true" alt="JVM Class Loader"></p>
<p>其中<strong>加载、验证、准备和初始化</strong>发生的顺序是确定的，但<strong>解析</strong>可以在初始化之后开始（java动态绑定）</p>
<blockquote>
<p>java绑定分为静态绑定和动态绑定：</p>
<ul>
<li><strong>静态绑定</strong>：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</li>
<li><strong>动态绑定</strong>：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</li>
</ul>
<p><a href="http://blog.csdn.net/ns_code/article/details/17881581">http://blog.csdn.net/ns_code/article/details/17881581</a></p>
</blockquote>
<h1 id="类加载机制具体过程"><a href="#类加载机制具体过程" class="headerlink" title="类加载机制具体过程"></a>类加载机制具体过程</h1><h2 id="I-Loading"><a href="#I-Loading" class="headerlink" title="**I.Loading **"></a>**I.Loading **</h2><p><strong>加载</strong>，JVM将文件（class，jar，zip，网络等）中的二进制字节流保存到虚拟机方法区和堆中,并用该二进制表示形式创建类或者接口的过程。</p>
<blockquote>
<p>Loading is the process of finding the binary representation of a class or interface type with a particular name and <em>creating</em> a class or interface from that binary representation</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html">https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html</a> (<em>英文文档若无特殊说明都是引用官方文档，下同</em>)</p>
</blockquote>
<ol>
<li><p>用<strong>类全限定名</strong>获取类的二进制字节流</p>
</li>
<li><p>将字节流中<strong>静态存储结构</strong>转化为<strong>方法区</strong>的运行时数据结构</p>
</li>
<li><p><u><em>在<strong>堆</strong>中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口。</em></u></p>
<p>（<del><strong>这句话存疑</strong> ，有人说<a href="http://blog.csdn.net/ns_code/article/details/17881581">在堆中</a> ,也有人说在<a href="http://gityuan.com/2015/10/25/jvm-class-loading/">方法区</a> ,官方文档未相关描述</del> </p>
<p><code>2019/01/12 更新</code> Class对象没有明确规定实在<strong>JAVA堆</strong>中，对应HotSpot虚拟机来说，该对象在<strong>方法区</strong>中）</p>
</li>
</ol>
<p>类加载的地方是开发人员可控性最强的地方。除了可以使用系统的ClassLoader外还可以自定义ClassLoader（后文详述）。</p>
<p>类加载根据加载的类不同分为两种：</p>
<ul>
<li>非数组类 使用系统&#x2F;自定义的类加载器完成加载</li>
<li>数组类 数组类不通过类加载器创建，而是通过JVM直接创建，但是数组类的元素类型要通过类加载器创建</li>
</ul>
<p>数组类的元素加载，根据数组元素的类型不同，分为两类：</p>
<ul>
<li>引用类 通过普通类加载器加载，并将数组用该类加载器标识</li>
<li>非引用类 将数组与引导类加载器标识</li>
</ul>
<p>数组类的可见性与其元素类的可见性一致。</p>
<hr>
<h2 id="II-Linking"><a href="#II-Linking" class="headerlink" title="**II.Linking **"></a>**II.Linking **</h2><p><strong>连接</strong>，是将类或者接口组合到java虚拟机运行状态的过程，这样他就可以被运行。</p>
<blockquote>
<p>Linking is the process of taking a class or interface and combining(组合) it into the run-time state of the Java Virtual Machine so that it can be executed(运行)</p>
</blockquote>
<p>连接一般分为3部分：验证Verification 、准备Preparation 、解析Resolution 。</p>
<blockquote>
<p>Linking a class or interface involves(包括) verifying and preparing(验证和准备) that class or interface, its direct(直接) superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.</p>
</blockquote>
<h3 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a><strong>Verification</strong></h3><p><strong>验证</strong>，保证class文件中的字节流信息符合虚拟机的要求。</p>
<blockquote>
<p>Verification(<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.10">§4.10</a>) ensures that the binary representation(二进制格式) of a class or interface is structurally correct(结构正确) (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.9">§4.9</a>). Verification may cause additional classes and interfaces to be loaded (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.3">§5.3</a>) but need not cause them to be verified or prepared.</p>
</blockquote>
<p>验证内容包括：</p>
<ol>
<li>文件格式验证，验证字节流符合class文件格式规范；</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h3 id="Preparation"><a href="#Preparation" class="headerlink" title="**Preparation **"></a>**Preparation **</h3><p><strong>准备</strong>，在方法区对类变量分配内存，<strong>初始化为默认值</strong>（“零值”）。</p>
<p>比如：<code>static int i = 5；</code>在这一步只会进行到<code>i = 0</code> ，而<code>i = 5</code>要在初始化那一步才进行；</p>
<p>但是如果是final修饰的<strong>常量</strong>，则在此分配具体值。</p>
<blockquote>
<p><em>Preparation</em> involves creating the static fields for a class or interface and initializing such fields to their default values (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.3">§2.3</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.4">§2.4</a>). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.5">§5.5</a>), not preparation.</p>
</blockquote>
<p>准备工作可能在创建之后的任何时候发生，但是必须在初始化之前完成。</p>
<h3 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a><strong>Resolution</strong></h3><p><strong>解析</strong>，是在运行时常量池中动态确定符号引用的具体值的过程。</p>
<p>每个栈帧frame都有一个<code>当前方法</code>到<code>运行时常量池</code> 的引用，用来支持方法代码(method code)的<strong>动态链接（dynamic linking）</strong>。</p>
<p>method code：要被执行的方法以及通过符号引用的变量。</p>
<blockquote>
<p>Each frame (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.6">§2.6</a>) contains a reference to the run-time constant pool (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.5">§2.5.5</a>) for the type of the current method to support <em>dynamic linking</em> of the method code.</p>
</blockquote>
<p>动态链接将符号引用（symbolic references）转化为具体方法的调用（concrete method references）即直接引用，根据需要加载类来解析未定义的符号，将变量访问转化为运行时内存（runtime location）。</p>
<blockquote>
<p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p>
<p><em>方法和变量的这种后期绑定,使得方法使用的其他类的更改不太可能破坏这个代码。</em></p>
<p>直接引用可以直接定位到内存中某一段地址；符号引用则与JVM内存无管</p>
</blockquote>
<p>解析分为：</p>
<ol>
<li>类，接口解析</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
</ol>
<hr>
<h2 id="III-Initialization"><a href="#III-Initialization" class="headerlink" title="III.Initialization"></a><strong>III.Initialization</strong></h2><p><strong>初始化</strong> ，<em>Initialization</em> of a class or interface consists of executing its class or interface initialization method（执行类，接口的构造方法<code>clinit()</code>）</p>
<p>类或接口在被初始化之前，必须先被连接linked（ verified, prepared, and optionally（可选） resolved.）。</p>
<p>初始化有且只有以下五种情况：</p>
<ul>
<li><code>new</code>、读取&#x2F;设置类（只有直接定义其的类才会，子类等不受影响）的静态变量（final修饰的常量除外）、执行静态方法</li>
<li><code>java.lang.reflect</code>反射调用类</li>
<li>初始化时，如果父类未初始化，先触发父类的初始化（接口类除外）</li>
<li>虚拟机等启动时执行主类的<code>main()</code>方法时，需要先初始化主类</li>
<li>JDK1.7 动态支持时，如果<code>java.lang.invoke.MethodHandle</code>实例最后解析结果<code>REF_get/put/invokeStatic的方法句柄对应的类未被初始化时，需要先初始化对应的类</code></li>
</ul>
<p>以上5种称为对一个类的<strong>主动引用</strong>，其余不会触发初始化，称为<strong>被动引用</strong></p>
<p><code>clinit()</code> ,有<strong>类变量赋值，静态语句块</strong>会由编译器合并为<code>clinit()</code>方法,分为两种：</p>
<ol>
<li>类 父类的<code>clinit()</code>方法会先于子类执行</li>
<li>接口  接口<code>clinit()</code>方法无需调用父类接口的<code>clinit()</code>方法；接口的实现类也无需执行接口的<code>clinit()</code>方法</li>
</ol>
<p><code>clinit()</code> 是线程安全的，在同一个类加载器中，多个线程的中只会有**一个线程执行一次<code>clinit()</code>**，其余线程阻塞等待</p>
<p><code>clinit()</code>和<code>init()</code>不同如下：</p>
<blockquote>
<p><strong>init</strong>是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法<u>（是在<strong>new对象</strong>的时候<strong>初始化非静态变量</strong>）</u>；</p>
<p>而clinit是类构造器方法，也就是在jvm进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段jvm会调用clinit方法<u>（是在<strong>JVM初始化类</strong>的时候<strong>初始化静态变量</strong>）</u>。</p>
<p><a href="http://blog.csdn.net/u013309870/article/details/72975536">http://blog.csdn.net/u013309870/article/details/72975536</a></p>
</blockquote>
<p>如果类没有静态赋值、静态语句块等则不会有<code>clinit()</code>方法。</p>
<p><code>clinit()</code>先于<code>init()</code>执行。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html">Java Virtual Machine Specification Chapter 5. Loading, Linking, and Initializing</a></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.2">Chapter 2. The Structure of the Java Virtual Machine</a></p>
<p><a href="http://blog.csdn.net/ns_code/article/details/17881581">【深入Java虚拟机】之四：类加载机制</a></p>
<p><a href="http://blog.csdn.net/zhangliangzi/article/details/51319033">JVM类加载机制详解（一）JVM类加载过程</a></p>
<p><a href="http://gityuan.com/2015/10/25/jvm-class-loading/">Jvm系列3—类的加载 - Gityuan博客 | 袁辉辉博客  </a></p>
<p><a href="http://wiki.jikexueyuan.com/project/java-vm/class-loading-mechanism.html">类加载机制 - 深入理解 Java 虚拟机 - 极客学院Wiki </a></p>
<p><a href="http://blog.csdn.net/javazejian/article/details/70768369">深入理解Java类型信息(Class对象)与反射机制 - CSDN博客</a></p>
<p><a href="http://blog.csdn.net/u013309870/article/details/72975536">深入理解jvm–Java中init和clinit区别完全解析 - CSDN博客</a></p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记之HashMap保存数据</title>
    <url>/blog/posts/ff927bd4/</url>
    <content><![CDATA[<img src="https://images.pexels.com/photos/159644/art-supplies-brushes-rulers-scissors-159644.jpeg?cs=srgb&dl=art-supplies-arts-and-crafts-ballpens-159644.jpg&fm=jpg" class="full-image" />

<p>Photo by **<a href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels">Pixabay </a>**from <strong><a href="https://www.pexels.com/photo/pencils-in-stainless-steel-bucket-159644/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels">Pexels</a></strong></p>
<p><code>HashMap</code>使用由<code>Node&lt;K,V&gt;</code>（继承自<code>Map.Entry&lt;K,V&gt;</code>）组成的<strong>数组</strong><code>table</code>保存数据。</p>
<p>在<code>table</code>中保存数据时根据<code>key</code>的<code>hashCode</code>计算到一个<strong>随机保存位置（但都在<code>table</code>数组的大小范围内）</strong>，当存储的<strong>数据总量</strong>超过加载系数<code>loadFactor</code>规定的<strong>阈值</strong>时则对<code>table</code>进行<strong>扩容</strong>。</p>
<h1 id="HashMap有以下全局变量"><a href="#HashMap有以下全局变量" class="headerlink" title="HashMap有以下全局变量"></a>HashMap有以下全局变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="comment">//实际保存键值对的数组</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<span class="comment">//Holds cached entrySet().用来遍历HashMap</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;<span class="comment">//本HashMap实际保存的键值对个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;<span class="comment">//HashMap修改的次数，每次修改HashMap都会叠加，</span></span><br><span class="line"><span class="comment">//用来在遍历的过程中检查HashMap是否被改动过来，如果有则抛出异常ConcurrentModificationException</span></span><br><span class="line"><span class="type">int</span> threshold;<span class="comment">//是否扩容的阈值</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;<span class="comment">//加载系数,默认0.75f</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>loadFactor</code>：默认的负载因子<strong>0.75</strong>是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下：</p>
<p>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；</p>
<p>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子<code>loadFactor</code>的值，这个值可以大于1。</p>
<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>
</blockquote>
<p>每个<code>Node</code>包含了以下信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在执行<code>hashMap.put(&quot;k&quot;, &quot;v&quot;);</code>时，会先计算<code>key</code>的<code>hash</code>值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="comment">//这里原始hash值(32位)的高位和地位进行按位异或（不同为，相同为0），</span></span><br><span class="line">  <span class="comment">//增加了随机性，避免因为hashCode计算得到的hash值（低位相同概率高）</span></span><br><span class="line">  <span class="comment">//计算索引时（见下文↓）一直取低位值而可能导致的索引一直的重复问题。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="V-put-K-key-V-value"><a href="#V-put-K-key-V-value" class="headerlink" title="V put(K key, V value)"></a><code>V put(K key, V value)</code></h1><p>使用<code>HashMap</code>保存数据时：</p>
<ol>
<li><p>使用<code>hash(Object key)</code>计算<code>key</code>的<code>hash</code>值</p>
</li>
<li><p>通过<code>hash</code>值计算<code>value</code>应该保存的位置<code>i</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = (table.length - <span class="number">1</span>) &amp; hash</span><br><span class="line"><span class="comment">//由于table.length限定为2的n次方，所以上面的等式相当于给table.length取余数</span></span><br><span class="line"><span class="comment">//即i永远&lt;=table.length</span></span><br></pre></td></tr></table></figure>

<p>在此时会判断是否需要扩容(<strong>只有<code>table</code>为空，或者当前存储的数据总数<code>size</code>大于阈值<code>threshold</code>时才会扩容</strong><code>resize()</code>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threshold = capacity * loadFactor</span><br><span class="line">阈值 = 容量 * 负载系数（默认为<span class="number">0.75</span>）</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来会插入数据</p>
<ul>
<li>指定位置为空（没有<em>hash冲突</em>），或已有<code>key</code>相同的值：则直接插入<code>value</code></li>
<li>已经存在值并且数量大于8：则将链表转化为红黑树（JDK1.8），否则以链表形式保存数据</li>
<li>在移除数据时，如果红黑树数量小于6：则将红黑树转化为链表</li>
</ul>
</li>
</ol>
<blockquote>
<p>在JDK1.7中，数据以数组或链表形式保存，JDK1.8中则新增了红黑树。</p>
<p>发生hash冲突时，JDK1.7采用采用头插法，可能会产生逆序和环形链表；JDK1.8采用尾插法，直接插入链表或红黑树尾部。</p>
<p>具体JDK1.7与1.8对比查看<a href="https://blog.csdn.net/qq_36520235/article/details/82417949">这里</a></p>
</blockquote>
<h1 id="V-get-Object-key"><a href="#V-get-Object-key" class="headerlink" title="V get(Object key)"></a><code>V get(Object key)</code></h1><p>使用<code>HashMap</code>获取数据时:</p>
<ol>
<li><p>计算key的<code>hash值</code></p>
</li>
<li><p>查找对应位置的<code>node</code></p>
<ul>
<li><p><code>null</code>：返回<code>null</code></p>
</li>
<li><p><code>node</code>不为空且<code>key</code>一致：返回该<code>node</code></p>
</li>
<li><p><code>node</code>不为空且<code>key</code>不一致：</p>
<p>如果是<em>链表</em>：遍历链表查找是否存在与<code>key</code>一致的<code>node</code></p>
<p>如果是<em>树</em>：遍历树查找是否存在与<code>key</code>一致的<code>node</code></p>
</li>
</ul>
</li>
</ol>
<h1 id="V-remove-Object-key"><a href="#V-remove-Object-key" class="headerlink" title="V remove(Object key)"></a><code>V remove(Object key)</code></h1><p>使用<code>HashMap</code>移除数据时:</p>
<p>其大体过程与<code>get(Object key)</code>类似，遍历找到对应的<code>node</code>并删除。</p>
<h1 id="计算索引"><a href="#计算索引" class="headerlink" title="计算索引"></a>计算索引</h1><p>一个<code>key</code>对应的索引<code>index</code>是由这个<code>key</code>的<code>hash()</code>值对<code>HashMap</code>的数组长度<code>length</code>的余数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = hash % length;</span><br></pre></td></tr></table></figure>

<p>又有<strong>在<code>Length</code>为2^n^</strong>时：</p>
<p>hash % 2^n^ &#x3D;  hash &amp; ( 2^n^ - 1)</p>
<blockquote>
<p>hash % 2^n^ &#x3D; hash - (hash &#x2F; 2^n^) * 2^n^<br>&#x3D; hash - (hash&gt;&gt;n) * 2^n^<br>&#x3D; hash &amp; ( 2^n^ - 1)</p>
</blockquote>
<p>而<code>HashMap</code>的长度<code>Length</code>又只能是2^n^，所以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = (length - <span class="number">1</span>) &amp; hash;</span><br></pre></td></tr></table></figure>

<h1 id="保存值"><a href="#保存值" class="headerlink" title="保存值"></a>保存值</h1><ul>
<li><p>当<code>table</code>为空或者长度超过加载因子<code>DEFAULT_LOAD_FACTOR</code>规定的容量(默认容量为16，加载因子为0.75)时会自动扩容。</p>
</li>
<li><p>当<code>table[index]</code>为空时，直接新建<code>Node</code>并保存到<code>table[index]</code>中。</p>
</li>
<li><p>当<code>table[index]</code>不为空时：</p>
<ul>
<li>如果是同一个<code>key</code>则覆盖旧的值</li>
<li>如果是不同的<code>key</code>则先尝试以链表保存数据</li>
<li>如果是不同的<code>key</code>，并且链表长度超过<code>MIN_TREEIFY_CAPACITY</code>规定的长度（默认64），则将链表转化为红黑树(JDK1.8新增)</li>
</ul>
</li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>在<a href="#HashMap%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">第一节</a>我们可以看到，<code>HashMap</code>的很多变量都被标记为<code>transient</code>，这表示在<code>Serializable</code>序列化时不主动去序列化这些值，那这样岂不是没法反序列化这些数据了？</p>
<p>其实在后面我们可以看到，**<code>HashMap</code>在<code>writeObject()</code>方法中主动保存了部分数据**（原因是默认的<code>Serializable</code>由于不同JVM实现对同一对象如<code>String</code>的<code>HashCode</code>不一定一致，会导致严重的问题——<code>HashMap</code>基于<code>hash</code>值保存数据）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">buckets</span> <span class="operator">=</span> capacity();<span class="comment">//容量</span></span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);<span class="comment">//保存size</span></span><br><span class="line">    internalWriteEntries(s);<span class="comment">//保存table数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* table不为空则返回table长度</span></span><br><span class="line"><span class="comment">* 否则threshold不为空则返回threshold</span></span><br><span class="line"><span class="comment">* 否则返回默认的DEFAULT_INITIAL_CAPACITY</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (table != <span class="literal">null</span>) ? table.length :</span><br><span class="line">            (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">            DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在<code>readObject()</code>恢复了这些值。</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><table>
<thead>
<tr>
<th>位运算</th>
<th>符号</th>
<th>计算</th>
</tr>
</thead>
<tbody><tr>
<td>按位与</td>
<td>&amp;</td>
<td>相同为1，不同为0</td>
</tr>
<tr>
<td>按位或</td>
<td>&amp;#124;</td>
<td>有1则1</td>
</tr>
<tr>
<td>按位异或</td>
<td>^</td>
<td>相同为0，不同位1</td>
</tr>
<tr>
<td>按位取反</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>左移</td>
<td>&lt;&lt;</td>
<td>相当于乘以2^n^</td>
</tr>
<tr>
<td>右移</td>
<td><code>&gt;&gt;</code></td>
<td>相当于除以2^n^</td>
</tr>
<tr>
<td>无符号右移</td>
<td><code>&gt;&gt;&gt;</code></td>
<td></td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/28562088/answer/111668116">HashCode计算扰动分析-关于hashMap的一些按位与计算的问题？ - 胖君的回答 - 知乎 </a></p>
<p><a href="http://baijiahao.baidu.com/s?id=1646023968436883100&wfr=spider&for=pc">一文读懂Java之HashMap索引位置计算</a></p>
<p><a href="https://blog.csdn.net/changhangshi/article/details/82114727">hashMap在jdk1.7与jdk1.8中的原理及不同</a></p>
<p><a href="https://blog.csdn.net/qq_36520235/article/details/82417949">真实面试题之：Hashmap的结构，1.7和1.8有哪些区别</a></p>
<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></p>
<p><a href="http://www.blogjava.net/killme2008/archive/2009/04/15/265721.html">java.util.HashMap源码要点浅析</a></p>
<p><a href="https://coderanch.com/t/469720/java/HashMap-Entry-transient">Why HashMap.Entry is transient?</a></p>
<p><a href="https://segmentfault.com/q/1010000000630486">Java中HashMap关键字transient的疑惑</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记之匿名内部类和final</title>
    <url>/blog/posts/875283bd/</url>
    <content><![CDATA[<h1 id="为什么匿名内部类使用局部引用要用final？"><a href="#为什么匿名内部类使用局部引用要用final？" class="headerlink" title="为什么匿名内部类使用局部引用要用final？"></a>为什么<code>匿名内部类</code>使用<code>局部引用</code>要用<code>final</code>？</h1><p>先说结论：</p>
<p>由于JAVA匿名内部类的实现并不是真正的闭包，而是在生成内部类的时候<strong>将局部变量的引用拷贝了一份到内部类中</strong>。如果不将这个外部类设置为<code>final</code>的话，外部类或者内部类修改这个局部变量后，另外一处使用的仍然是修改前的值，这样就会产生问题，而如果将其修改为<code>final</code>则保证了局部变量与内部类使用的值是一致的。</p>
<h1 id="JDK1-8-后局部变量不要求用final了？"><a href="#JDK1-8-后局部变量不要求用final了？" class="headerlink" title="JDK1.8 后局部变量不要求用final了？"></a>JDK1.8 后局部变量不要求用<code>final</code>了？</h1><p>不对，仍然是要求<code>final</code>的。</p>
<p>只不过编译器判断该局部变量不会再被修改时（<em>effectively final</em> 事实上的<code>final</code>），可以省略。</p>
<blockquote>
<p>Any local variable, formal parameter, or exception parameter used but not declared in an inner class <strong>must either be declared final or be effectively final</strong> (§4.12.4), or a compile-time error occurs where the use is attempted.</p>
<p>Any local variable used but not declared in an inner class must be definitely assigned (§16 (Definite Assignment)) before the body of the inner class, or a compile-time error occurs.</p>
<p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3">https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3</a></p>
</blockquote>
<h1 id="为什么外部类的全局变量不需要final？"><a href="#为什么外部类的全局变量不需要final？" class="headerlink" title="为什么外部类的全局变量不需要final？"></a>为什么外部类的全局变量不需要<code>final</code>？</h1><p>因为全局变量是通过传入内部类的**外部类引用<code>this$0</code>**来引用的(而非直接复制全局变量的值)，这样内部类和外部类持有的是同一个全部变量，自然不会存在两处更新不同步的问题。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OutClass</span> <span class="variable">outClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutClass</span>();</span><br><span class="line">        outClass.outMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">AnObj</span> <span class="variable">anObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnObj</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AnObj</span> <span class="variable">anObj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnObj</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//内部类访问外部类的全部变量和局部变量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> anObj1.getI() + anObj.getI();</span><br><span class="line">                System.out.println(<span class="string">&quot;inner:&quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        o.doSth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这两个类无需关注</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnObj</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnObj</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OutClass.class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">AnObj</span> <span class="variable">anObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnObj</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    OutClass() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//可以看到，在编译之后，将外部类的引用和局部变量作为内部类的参数传入到内部类中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="number">1</span>(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">AnObj</span>(<span class="number">6</span>)).doSth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看内部类<code>OutClass$1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OutClass$1.class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutClass$1</span> <span class="keyword">implements</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="comment">/* synthetic */</span> OutClass <span class="built_in">this</span>$<span class="number">0</span>;<span class="comment">//这个是外部类的引用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="comment">/* synthetic */</span> AnObj val$anObj1;<span class="comment">//这个引用指向局部变量引用指向的内存空间</span></span><br><span class="line"></span><br><span class="line">    OutClass$<span class="number">1</span>(OutClass <span class="built_in">this</span>$<span class="number">0</span>, AnObj anObj) &#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.val$anObj1 = anObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在这里可以看出，内部类通过局部变量的备份引用访问的this.val$anObj1.getI()，</span></span><br><span class="line">        <span class="comment">//所以如果内部类所处的方法，修改了这个局部变量（假设将这个引用指向了另外一个AnObj对象），</span></span><br><span class="line">        <span class="comment">//但这里的this.val$anObj1指向的仍然是旧的AnObj对象，从而出现了对“同一个局部变量”在内部类和内部类外部分别有不同值的问题，所以需要final来限制对局部变量的更改</span></span><br><span class="line">        System.out.println(<span class="string">&quot;inner:&quot;</span> + (<span class="built_in">this</span>.val$anObj1.getI() + </span><br><span class="line">                                       <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0.</span>anObj.getI()));</span><br><span class="line">        <span class="comment">//但是再看外部类的全局变量，在内部类中仍然是通过外部类的引用this.this$0来引用anObj的，所以无论何时，内部类中的外部类全局变量都是最新的，所做的更改也会实时更新到外部类中，所以不需要final</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/w3cnote/inner-lambda-final.html">https://www.runoob.com/w3cnote/inner-lambda-final.html</a></p>
<p><a href="https://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class/4732617#4732617">Why are only final variables accessible in anonymous class?–stackoverflow</a></p>
<p><a href="https://www.zhihu.com/question/21395848/answer/110829597">java为什么匿名内部类的参数引用时final？ - 胖君的回答 - 知乎</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记之计算Java对象的大小及其应用</title>
    <url>/blog/posts/b0793c74/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><strong>注意 除非特殊说明，以下所说的计算Java对象大小，不涉及该对象所持有的对象本身的大小，只计算该Java对象本身的大小（其中引用类型对象大小只计算为4 bytes），如果要遍历计算Java对象大小（包含其持有对象的大小）可以参考<a href="https://www.javaworld.com/article/2077408/sizeof-for-java.html">这篇文章 Sizeof for Java</a></strong></p>
<p>一个Java对象在内存中的大小包括以下(以64位JVM启用压缩为例，综合<a href="https://blog.csdn.net/ITer_ZC/article/details/41822719">这里</a>和<a href="https://blog.csdn.net/u013380694/article/details/102739636">这里</a>的信息整理)：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>大小（byte）</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>对象头</td>
<td>8</td>
<td>保存对象的 class 信息、ID、在虚拟机中的状态</td>
</tr>
<tr>
<td>Oop指针</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>数据区</td>
<td></td>
<td>对象实际包含的数据,引用类型大小为4 bytes</td>
</tr>
<tr>
<td>数组长度</td>
<td>4</td>
<td>只有数组对象才有</td>
</tr>
<tr>
<td>8比特对齐</td>
<td></td>
<td>将对象总大小对齐到8字节所需的填充</td>
</tr>
</tbody></table>
<blockquote>
<p>此外，如果是（非静态）内部类的话，由于他默认持有外部类的引用，所以会比普通类的对象多4个byte。</p>
<p><a href="https://stackoverflow.com/a/12193259/8389461">https://stackoverflow.com/a/12193259/8389461</a></p>
</blockquote>
<p>可以参照<a href="https://www.jianshu.com/p/9d729c9c94c4">这张图</a></p>
<p><img src="https://jixiaoyong.github.io/images/20191221191518.webp" alt="图片来自https://www.jianshu.com/p/9d729c9c94c4"></p>
<p>其中，数据区占用的大小如下：</p>
<p>（图片来自于<a href="https://speakerdeck.com/romainguy/android-memories?slide=29">android-memories</a>）</p>
<p><img src="https://jixiaoyong.github.io/images/20191221104050.png" alt="Size of data from speakerdeck.com"></p>
<p>#示例</p>
<p>根据<a href="https://speakerdeck.com/romainguy">Romain Guy</a>在<a href="https://speakerdeck.com/romainguy/android-memories?slide=34">SpeakerDeck</a>中的说法：</p>
<blockquote>
<p>一个空的class占用了4+8&#x3D;12个byte的内存，再加上8比特对齐，实际占用大小为16比特。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>占用大小：</p>
<table>
<thead>
<tr>
<th>Allocation</th>
<th>Size in bytes</th>
</tr>
</thead>
<tbody><tr>
<td>dlmalloc 引用</td>
<td>4</td>
</tr>
<tr>
<td>Object overhead（对象头）</td>
<td>8</td>
</tr>
</tbody></table>
<p>Total  &#x3D; 4 + 8 &#x3D;12 bytes</p>
<p>经过<em>8-byte aligned</em>后： total &#x3D; 16 bytes</p>
<p><a href="https://speakerdeck.com/romainguy/android-memories?slide=34">https://speakerdeck.com/romainguy/android-memories?slide=34</a></p>
</blockquote>
<p>此外还有<strong>包含了数据的对象</strong>大小计算方式如下：</p>
<p><img src="https://jixiaoyong.github.io/images/20191221171816.png" alt="图片来自https://speakerdeck.com/romainguy/android-memories?slide=42"></p>
<p>对于数组的大小计算（参考<a href="https://www.cnblogs.com/zhanjindong/p/3757767.html">一个Java对象到底占用多大内存？</a>和<a href="https://speakerdeck.com/romainguy/android-memories?slide=54">romainguy&#x2F;android-memories</a>，后者关于数组大小的计算中<code>width&amp;padding = 8 </code>的意义存疑）:</p>
<p>按照开头的公式：<code>数组大小 = 8 对象头 + 4 Oop指针 + 4 数组大小标记length + 数组数据占用大小 + 8比特对齐 </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr0大小 = 8 + 4 + 4 + 0 + 8比特对齐(0) = 16 bytes</span></span><br><span class="line"><span class="type">int</span> <span class="variable">arr0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// arr1大小 = 8 + 4 + 4 + 4*1 + 8比特对齐(4) = 16 + 4 = 20 + 8比特对齐(4) = 24 bytes</span></span><br><span class="line"><span class="type">int</span> <span class="variable">arr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// arr1大小 = 8 + 4 + 4 + 4*10 + 8比特对齐(0) = 16 + 40 = 56 + 8比特对齐(0) = 56 bytes</span></span><br><span class="line"><span class="type">int</span> <span class="variable">arra10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<h1 id="计算对象大小的工具"><a href="#计算对象大小的工具" class="headerlink" title="计算对象大小的工具"></a>计算对象大小的工具</h1><p>具体的如何计算Java中Object大小，可以参考<a href="https://stackoverflow.com/a/52682/8389461">stackoverflow的这个回答</a>（<a href="https://github.com/cirosantilli/java-cheat/tree/a907ad2243dce2109c54d27323f9387065b5ca5c/instrument">这里</a>有一份Github上面的实现源码）</p>
<p>可以参考文章：</p>
<p><a href="https://blog.csdn.net/ITer_ZC/article/details/41822719">聊聊JVM（三）两种计算Java对象大小的方法</a></p>
<p><a href="https://www.iteye.com/blog/brandnewuser-2113828">准确计算Java中对象的大小</a></p>
<p><a href="https://www.cnblogs.com/zhanjindong/p/3757767.html">一个Java对象到底占用多大内存？</a></p>
<p>这里提供一个实例（<a href="https://github.com/cirosantilli/java-cheat/tree/a907ad2243dce2109c54d27323f9387065b5ca5c/instrument">参考自这里</a>）：</p>
<p><code>Sizeof.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sizeof</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation inst)</span> &#123;</span><br><span class="line">        instrumentation = inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sizeof</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instrumentation.getObjectSize(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">//Makefile文件</span><br><span class="line"><span class="section">.POSIX:</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	javac *.java</span><br><span class="line">	jar -cfm Sizeof.jar META-INF/MANIFEST.MF Sizeof.class</span><br><span class="line">	java -ea -javaagent:Sizeof.jar Main</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.class *.jar</span><br></pre></td></tr></table></figure>

<p>在使用时先新建一个Java类，在其中调用<code>sizeof()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Sizeof.sizeof(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac *.java //编译当前目录下的java文件</span><br><span class="line">jar -cfm Sizeof.jar META-INF/MANIFEST.MF Sizeof.class //将Sizeof.class打包为Sizeof.jar</span><br><span class="line">java -ea -javaagent:Sizeof.jar Main //输出sizeOf计算结果</span><br></pre></td></tr></table></figure>

<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="String最长为65534"><a href="#String最长为65534" class="headerlink" title="String最长为65534"></a><code>String</code>最长为65534</h2><p><code>String s = “”;</code>中，在编译期最多可以有65534个字符</p>
<blockquote>
<p><del>原因是，Java中的UTF-8编码的Unicode字符串在常量池中以<code>CONSTANT_Utf8</code>类型表示，常量池中的所有字面量几乎都是通过<code>CONSTANT_Utf8_info</code>描述的。</del></p>
<p><del>这里面的<code>u2 length</code>表明了该类型存储数据的长度，而<code>u2</code>是无符号的16位整数，因此理论上允许的的最大长度是<code>2^16=65536</code>。而 Java class 文件是使用一种变体<code>UTF-8</code>格式来存放字符的，<code>null</code> 值使用两个字节来表示，因此只剩下<code> 65536－ 2 ＝ 65534</code>个字节。</del></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;CONSTANT_Utf8_info &#123;</span><br><span class="line">&gt;u1 tag;</span><br><span class="line">&gt;u2 length;</span><br><span class="line">&gt;u1 bytes[length];</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以，在Java中，所有需要保存在常量池中的数据，长度最大不能超过65535，这当然也包括字符串的定义</strong></p>
<p>上面提到的这种String长度的限制是<em>编译期的限制</em>，也就是使用<code>String s= “”;</code>这种字面值方式定义的时候才会有的限制。</p>
<p>String在<em>运行期</em>有没有限制呢，答案是有的，就是我们前文提到的那个<code>Integer.MAX_VALUE </code>，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）</p>
<p><a href="https://blog.csdn.net/u013380694/article/details/102739636">https://blog.csdn.net/u013380694/article/details/102739636</a></p>
</blockquote>
<p><strong>一个String对象,占用大小（JDK1.8）为24 bytes</strong>（不计算持有的char数组占用的大小）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];  <span class="comment">//一个数组对象的引用，占用4 bytes</span></span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0   //一个int类型，占用4 bytes</span></span><br></pre></td></tr></table></figure>

<p>再加上在64位JVM中，一个对象具有12 bytes的<code>对象头+引用</code>，要求对齐到8的倍数(来源<a href="https://www.baeldung.com/java-size-of-object#1-objects-references-and-wrapper-classes">2.1. Objects, References and Wrapper Classes</a>)，所以一个String对象的大小是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size = ( 12 对象头 + 4 value + 4 hash ) + 4 8byte对齐 = 24 bytes</span><br></pre></td></tr></table></figure>

<h2 id="枚举类enum"><a href="#枚举类enum" class="headerlink" title="枚举类enum"></a>枚举类enum</h2><h3 id="枚举类大小的计算"><a href="#枚举类大小的计算" class="headerlink" title="枚举类大小的计算"></a>枚举类大小的计算</h3><p>枚举类中的每个枚举都是该枚举类的一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumClazz</span>&#123;</span><br><span class="line">    Day,Hour,Minute,Second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们用<code>javap</code>查看其编译后的字节码可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//javac EnumClazz.java</span></span><br><span class="line"><span class="comment">//javap EnumClazz.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EnumClazz</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;EnumClazz&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumClazz Day;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumClazz Hour;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumClazz Minute;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumClazz Second;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumClazz[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumClazz <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单计算一下这个<code>EnumClazz</code>的大小（不含引用对象的大小）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">enumClassSize = <span class="number">8</span> + <span class="number">4</span> + <span class="number">4</span>*<span class="number">4</span> + <span class="number">4</span> = <span class="number">32</span> bytes</span><br><span class="line">       对象头 +  引用 + 枚举类值的引用类型 * <span class="number">4</span>个 + <span class="number">4</span> 数组引用类型</span><br></pre></td></tr></table></figure>

<p>然后，我们再看一下每个枚举类的值（以<code>EnumClazz.Day</code>为例）的大小：</p>
<p><code>enum</code>类的每个值实际上都继承自<code>java.lang.Enum</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123;</span><br><span class="line">        <span class="comment">//枚举值名称</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="comment">//枚举值次序，从0开始</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> ordinal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由此，我们可以计算<code>EnumClazz.Day</code>的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">daySize = <span class="number">8</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span>比特对齐(<span class="number">4</span>) = <span class="number">20</span> + <span class="number">4</span> = <span class="number">24</span> bytes</span><br><span class="line">     对象头 + Oop引用 + name + ordinal + <span class="number">8</span>比特对齐</span><br></pre></td></tr></table></figure>

<p>也就是说，本例中<strong>每一个枚举类值占用24 bytes</strong>，由此可以计算出<code>EnumClazz</code>实际占用的大小应该是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">realSize = enumClassSize + daySize * <span class="number">4</span>  = <span class="number">128</span> bytes</span><br></pre></td></tr></table></figure>

<h3 id="Android中是否应该使用枚举"><a href="#Android中是否应该使用枚举" class="headerlink" title="Android中是否应该使用枚举"></a>Android中是否应该使用枚举</h3><p>关于Android中使用枚举和常量所占用的大小对比<em>RomainGuy</em>有<a href="https://speakerdeck.com/romainguy/android-memories?slide=67">下图</a>的对比。</p>
<p><img src="https://jixiaoyong.github.io/images/20191221172243.png" alt="https://speakerdeck.com/romainguy/android-memories?slide=67"></p>
<p>关于是否应该在Android中使用枚举类，可以参考下文：</p>
<p><a href="https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/">https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/</a></p>
<p><a href="https://stackoverflow.com/a/29972028/8389461">https://stackoverflow.com/a/29972028/8389461</a></p>
<p>总结起来其结论就是：</p>
<p><strong>当需要用到枚举类的特性时，比如非连续判断，方法重载等时就使用枚举，否则就使用占用内存更小的常量类。</strong></p>
<h2 id="SparseArray-amp-ArrayMap-VS-HashMap"><a href="#SparseArray-amp-ArrayMap-VS-HashMap" class="headerlink" title="SparseArray&amp;ArrayMap VS HashMap"></a>SparseArray&amp;ArrayMap VS HashMap</h2><p><code>HashMap</code>的数据是经过包装后保存在<code>HashMap.Node&lt;K,V&gt;</code>数组中。</p>
<p>下面是<code>HashMap</code>的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//4+ bytes，保存HashMap的键值对等信息</span></span><br><span class="line">  <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">//4+ bytes</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="type">int</span> size; <span class="comment">//4 bytes</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="type">int</span> modCount; <span class="comment">//4 bytes</span></span><br><span class="line">  <span class="type">int</span> threshold; <span class="comment">//4 bytes</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">float</span> loadFactor; <span class="comment">//4 bytes</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//继承自AbstractMap</span></span><br><span class="line">  <span class="keyword">transient</span> Set&lt;K&gt;        keySet; <span class="comment">//4+ bytes</span></span><br><span class="line">  <span class="keyword">transient</span> Collection&lt;V&gt; values; <span class="comment">//4+ bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看Android提供的<code>android.util.SparseArray</code>类(具体分析可参考：<a href="https://juejin.im/entry/57c3e8c48ac24700634bd3cf">SparseArray 的使用及实现原理</a>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mGarbage</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//4 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] mKeys; <span class="comment">//4+ bytes</span></span><br><span class="line">    <span class="keyword">private</span> Object[] mValues; <span class="comment">//4+ bytes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mSize; <span class="comment">//4 bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再结合<a href="https://developer.android.google.cn/reference/android/util/SparseArray">官方的描述</a>，<code>SparseArray</code>类很明显要比<code>HashMap</code>占用更少的内存：</p>
<ul>
<li>将<code>KEY</code>和<code>VALUE</code>直接保存在数组中，避免了将其包装为一个<code>Node</code>对象的开销</li>
<li>由于<code>SparseArray</code>类的key是<code>int</code>类型而非被自动装箱后的<code>Integer</code>对象，所以当同样使用<code>int</code>类型的<code>key</code>保存数据时，<code>SparseArray</code>类的<code>key</code>要占用更少的内存。</li>
</ul>
<blockquote>
<p><code>SparseArray</code> is intended to be more memory-efficient than a <a href="https://developer.android.google.cn/reference/java/util/HashMap"><code>HashMap</code></a>, because it <strong>avoids auto-boxing keys</strong> and its data structure <strong>doesn’t rely on an extra entry</strong> object for each mapping.</p>
<p><a href="https://developer.android.google.cn/reference/android/util/SparseArray">https://developer.android.google.cn/reference/android/util/SparseArray</a></p>
</blockquote>
<p>但是，<code>SparseArray</code>有以下局限性：</p>
<ul>
<li><p>在每次<code>put/get/remove</code>的时候都需要使用二分法(<code>ContainerHelpers.binarySearch(mKeys, mSize, key)</code>)查找是否已经存在<code>KEY</code>对应的值（有的话查找其位置）</p>
</li>
<li><p>在添加和删除item的时候都需要在数组中增删条目（耗时，尽管为了优化性能，<code>SparseArray</code>在删除时只是将对于的值标记为<code>DELETED</code>，在下次更新该<code>KEY</code>对于的值时直接覆盖，或者在<code>GC</code>时删除）。</p>
<p><code>  private static final Object DELETED = new Object();</code></p>
<p>HashMap的删除涉及到数组、链表和红黑树（JDK1.8）</p>
</li>
<li><p>**在容纳数百个项目时性能会比HashMap小大约50%**。</p>
</li>
</ul>
<blockquote>
<p>每当需要<strong>增长数组</strong>或<strong>获取数组大小</strong>或<strong>获取条目值</strong>时，都必须执行垃圾回收GC。</p>
</blockquote>
<p>此外，还有以下可以替换HashMap的(数据来自<a href="https://stackoverflow.com/a/31413003/8389461">这里</a>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SparseArray          &lt;Integer, Object&gt;</span><br><span class="line">SparseBooleanArray   &lt;Integer, Boolean&gt;</span><br><span class="line">SparseIntArray       &lt;Integer, Integer&gt;</span><br><span class="line">SparseLongArray      &lt;Integer, Long&gt;</span><br><span class="line">LongSparseArray      &lt;Long, Object&gt;</span><br><span class="line">LongSparseLongArray  &lt;Long, Long&gt;   <span class="comment">//this is not a public class                                 </span></span><br><span class="line">                                    <span class="comment">//but can be copied from  Android source code </span></span><br></pre></td></tr></table></figure>

<p>此外，还有<code>android.util.ArrayMap</code>其特性与<code>SparseArray</code>类似（<strong>两者占用内存小，但是慢并且最好不要用来存储大容量的数据</strong>），只不过它支持key值为其他类型，占用内存大小在<code>SparseArray</code>和<code>HashMap</code>之间(参考<a href="https://blog.csdn.net/u010687392/article/details/47809295">这里</a>)，此外<code>ArrayMap</code>的API和<code>HashMap</code>类似。</p>
<blockquote>
<p>根据<a href="https://speakerdeck.com/romainguy">Romain Guy</a>的<a href="https://speakerdeck.com/romainguy/android-memories?slide=94">计算</a>：</p>
<p>保存1000个int对象的<code>SparseArray</code>                       占用大小为：8072 bytes</p>
<p>保存1000个对象的<code>HashMap&lt;Integer,Integer&gt;</code>    占用大小为：64136 bytes</p>
<p>几乎相差8倍！</p>
</blockquote>
<p>综上，<strong>当要保存的数据量比较小（小于几千个）的时候，如果KEY是基本类型，推荐使用<code>SparseArray</code>及其衍生类以节省内存，如果KEY是其他类型则使用<code>ArrayMap</code>;否则使用<code>HashMap</code>更加高效</strong>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>除文章中罗列的链接外：</p>
<p><a href="https://blog.csdn.net/u013380694/article/details/102739636">https://blog.csdn.net/u013380694/article/details/102739636</a></p>
<p><a href="https://www.javaworld.com/article/2077408/sizeof-for-java.html">Sizeof for Java – javaworld.com</a></p>
<p><a href="https://speakerdeck.com/romainguy/android-memories">RomainGuy-Android Memories</a>（推荐）</p>
<p><a href="https://stackoverflow.com/a/31413003/8389461">SparseArray vs HashMap</a></p>
<p><a href="https://blog.csdn.net/u010687392/article/details/47809295">Android内存优化（使用SparseArray和ArrayMap代替HashMap）</a></p>
<p><a href="https://juejin.im/entry/57c3e8c48ac24700634bd3cf">SparseArray 的使用及实现原理</a></p>
<p><a href="https://developer.android.google.cn/reference/android/util/SparseArray">SparseArray – developer.android.google.cn</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记之ThreadLocal</title>
    <url>/blog/posts/9a8e41a8/</url>
    <content><![CDATA[<p><code>ThreadLocal</code>是<code>Thread</code>中用来保存<strong>线程私有变量</strong>的数据结构。</p>
<p>一个<code>ThreadLocal</code>只能保存一个值，有<code>set/get/remove</code>方法。</p>
<p>在<code>Thread</code>有一个<code>threadLocals</code>（<code>ThreadLocal.ThreadLocalMap</code>）变量，该变量是一个定制的Hash Map，用来保存线程私有的数据（类型为<code>ThreadLocal&lt;?&gt; Key, Object Value</code>）。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol>
<li><p>一个<code>Thread</code>可以有多个<code>ThreadLocal</code>变量</p>
</li>
<li><p><strong>不同<code>Thread</code>可以通过一个<code>ThreadLocal</code>变量分别保存不同的变量而互不影响</strong>。</p>
</li>
<li><p>如果不同的<code>Thread</code>使用的<code>ThreadLocal</code>变量保存的是<strong>同一个引用类型的对象</strong>（假设为<code>obj</code>），无论这些<code>Thread</code>使用的是同一个<code>ThreadLocal</code>对象还是完全不同的<code>ThreadLocal</code>对象，只要<code>obj</code>指向的对象改变，其余线程中的<code>ThreadLocal</code>对象也会访问到<code>obj</code>的最新值。</p>
</li>
</ol>
<h1 id="使用与解析"><a href="#使用与解析" class="headerlink" title="使用与解析"></a>使用与解析</h1><p>当我们新建一个<code>ThreadLocal</code>并为之赋值时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1.</span></span><br><span class="line"><span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">threadLocal.set(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//方式2.</span></span><br><span class="line"><span class="type">ThreadLocal</span> <span class="variable">threadLocal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> Object <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>这个时候就会调用<code>set()</code>方法（方式1）或者<code>setInitialValue()</code>方法（方式2）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//注意这里获取到是线程本身的threadLocals对象</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);<span class="comment">//ThreadLocal对象只是在Thread所属的threadLocals中充当一个key，</span></span><br><span class="line">        <span class="comment">//所以即使在其他线程执行threadLocal.set(value);</span></span><br><span class="line">        <span class="comment">//也只是更新该线程本身的threadLocal对应的value，而不会影响其他线程分毫！！！（好精巧的设计）</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这两个方法到最后都相当于调用了<code>Thread</code>对象的<code>threadLocals</code>的<code>set(ThreadLocal&lt;?&gt; key, Object value)</code>方法，这个方法最终以<code>ThreadLocal</code>对象为KEY，将数据保存到了<code>Thread</code>对象自己的<code>threadLocals</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">//其他逻辑...</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以即使是<strong>同一个<code>ThreadLocal</code>对象，在不同的线程中进行<code>set/get/remove</code>都只是更新了本线程中<code>ThreadLocal</code>对象对应的值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//MainThread</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    threadLocal.set(<span class="string">&quot;THREAD-Main-&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;THREAD-Main-BEFORE：&quot;</span>+threadLocal.get());<span class="comment">//THREAD-Main-BEFORE：THREAD-Main-main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            threadLocal.set(<span class="string">&quot;THREAD-1-&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;THREAD-1：&quot;</span>+threadLocal.get());<span class="comment">//THREAD-1：THREAD-1-Thread-0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;THREAD-2：&quot;</span>+threadLocal.get());<span class="comment">//THREAD-2：null</span></span><br><span class="line">            <span class="comment">//本线程中threadLocal没有赋值，所以为null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MainThread</span></span><br><span class="line">    System.out.println(<span class="string">&quot;THREAD-Main-AFTER：&quot;</span>+threadLocal.get());<span class="comment">//THREAD-Main-AFTER：THREAD-Main-main </span></span><br><span class="line">    <span class="comment">//其他线程对threadLocal对象的操作不会影响本线程</span></span><br><span class="line">    <span class="comment">//但是如果threadLocal保存的是一个引用类型的对象，并且这个对象在其他线程被更改，那么本线程获取到的也会是变更后的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>在<code>ThreadLocal.ThreadLocalMap</code>中，最终用来保存<code>ThreadLocal</code>以及对应值的是一个<code>Entry</code>数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);<span class="comment">//对ThreadLocal对象的弱引用</span></span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，<code>Entry</code>对<code>ThreadLocal</code>是<strong>弱引用</strong>，按照“强软弱虚”引用的等级来划分，每次GC的时候，如果这个<code>ThreadLocal</code>对象没有被引用，就会被回收掉，这时如果该<code>Thread</code>还在运行，那么<code>threadLocals</code>中保存的<code>ThreadLocal&lt;?&gt; k</code>已经被回收了，但是<code>Object v</code>对象仍然保存在<code>threadLocals</code>中但是没有办法再访问到，造成内存泄漏。</p>
<p>解决方法参考：</p>
<blockquote>
<p>使用<code>ThreadLocal</code>时会发生内存泄漏的前提条件：</p>
<p>①<code>ThreadLocal</code>引用被设置为<code>null</code>，且后面没有<code>set，get,remove</code>操作。</p>
<p>②线程一直运行，不停止。（线程池）</p>
<p>③触发了垃圾回收。（Minor GC或Full GC）</p>
<p>我们看到<code>ThreadLocal</code>出现内存泄漏条件还是很苛刻的，所以我们只要破坏其中一个条件就可以避免内存泄漏，单但为了更好的避免这种情况的发生我们使用<code>ThreadLocal</code>时遵守以下两个小原则:</p>
<p>①<code>ThreadLocal</code>申明为<code>private static final</code>。 <code>Private</code>与<code>final </code>尽可能不让他人修改变更引用， <code>Static </code>表示为类属性，只有在程序结束才会被回收。</p>
<p>②<code>ThreadLocal</code>使用后务必调用<code>remove</code>方法。 最简单有效的方法是使用后将其移除。</p>
<p>版权声明：本文为CSDN博主「pony-zi」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：<a href="https://blog.csdn.net/zzg1229059735/article/details/82715741">https://blog.csdn.net/zzg1229059735/article/details/82715741</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在我们知道了，所谓的<em>通过<code>ThreadLocal</code>实现线程本地变量与其他线程隔离</em>，是在创建<code>ThreadLocal</code>的时候，<strong>保存的就是属于当前线程的独立的变量，并且之后的修改也不会（无法）修改到其他线程中对应的值</strong>，但如果<code>ThreadLocal</code>本身保存的都是同一个对象，则这个对象在所有的线程中还是共享的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/whoislcj/p/5811989.html">Android线程管理之ThreadLocal理解及应用场景</a></p>
<p><a href="https://blog.csdn.net/shenyo/article/details/80391818">ThreadLocal深入分析（Jdk 1.8）</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中三种常用的排序方法</title>
    <url>/blog/posts/1fd30f6e/</url>
    <content><![CDATA[<p>今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。<br>以下示例皆为从小到大的排序</p>
<h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h1><p>每一次比较都可能要交换元素。<br>冒泡排序的思想是：<br>每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。<br>在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。<br>依次类推，总共遍历n-1轮，即可完成排序。<br>具体代码如下：</p>
<pre><code> void bubble(int[] arr)&#123;
    int temp;
    for (int i = 0; i &lt; arr.length - 1; i++) &#123;
        for (int j = 0; j &lt; arr.length - i - 1; j++) &#123;
            if (arr[j] &gt; arr[j + 1]) &#123;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            &#125;
        &#125;
    &#125;
    
    System.out.println(&quot;\n--bubble :&quot;);
    for (int i = 0; i &lt; arr.length; i++) &#123;
        System.out.print(arr[i] + &quot; &quot;);
    &#125;
&#125;
</code></pre>
<h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h1><p>每次比较的时候不交换<br>选择排序的思想：<br>每次比较的时候找到的两个数中的较大值并记下其位置，等到当前一轮的遍历完成之后，将最后一个未排序元素与这一轮遍历找到的最大值交换<br>最多交换n-1次<br>代码如下：</p>
<pre><code>   void select(int[] arr)&#123;

    for (int i = 0; i &lt; arr.length; i++) &#123;
        int maxIndex = 0;
        int temp = 0;
    
        for (int j = 1; j &lt; arr.length - i; j++) &#123;
            if (arr[maxIndex] &lt; arr[j]) &#123;
                maxIndex = j;
            &#125;
        &#125;
        
        temp = arr[maxIndex];
        arr[maxIndex] = arr[arr.length - i - 1];
        arr[arr.length - i - 1] = temp;
    &#125;


    System.out.println(&quot;\n--select :&quot;);

    for (int i = 0; i &lt; arr.length; i++) &#123;
        System.out.print(arr[i] + &quot; &quot;);
    &#125;
&#125;
</code></pre>
<h1 id="3-插入排序法"><a href="#3-插入排序法" class="headerlink" title="3.插入排序法"></a>3.插入排序法</h1><p>插入排序法思想：<br>将待排序的元素分为有序和无序两种，刚开始排序的时候假设只有第一个元素是有序的，其余n-1个元素都是无序的；<br>排序开始的时，将无序部分的一个元素（a）与有序部分的最后一个元素（b）进行比较，如果a&lt;b，则将a与b交换，再将a与下一个有序元素进行比较；否则，将a加到b后面，作为有序部分的最后一个元素。<br>接着再从无序部分取出一个元素与有序部分的元素依次比较，直达所有元素都为有序元素。<br>遍历n-1次<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">instertValue</span> <span class="operator">=</span> arr[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (instertValue &lt; arr[j]) &#123;</span><br><span class="line">				arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">				arr[j] = instertValue;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 第二种表示形式</span></span><br><span class="line"><span class="comment">	for (int i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">		int instertVal = arr[i];</span></span><br><span class="line"><span class="comment">		int index = i - 1;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		while (index &gt;= 0 &amp;&amp; instertVal &lt; arr[index]) &#123;</span></span><br><span class="line"><span class="comment">			arr[index + 1] = arr[index];</span></span><br><span class="line"><span class="comment">			index--;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		arr[index + 1] = instertVal;</span></span><br><span class="line"><span class="comment">	&#125;		</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;\n--insertSort :&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java中的泛型</title>
    <url>/blog/posts/b2cdb69e/</url>
    <content><![CDATA[<p>Java中的泛型实现了<strong>参数类型化</strong>的概念。</p>
<p>主要有以下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OneClazz</span>&lt;T&gt;&#123;</span><br><span class="line">    T t;</span><br><span class="line">    &lt;Y&gt; <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文主要记录Java泛型一些比较特殊的知识点。</p>
<h1 id="泛型特性"><a href="#泛型特性" class="headerlink" title="泛型特性"></a>泛型特性</h1><p>泛型在Java SE5被引入，可以在类和方法中，将类型作为类型参数传入。</p>
<p>泛型类型参数会在实际运行时被<strong>擦除</strong>到他的第一个边界。如<code>&lt;T&gt;</code>会被擦除为<code>Objet</code>，而<code>&lt;T extends ClazzA&gt;</code>则会被擦除为<code>ClazzA</code>。</p>
<h1 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h1><h2 id="不能有泛型数组"><a href="#不能有泛型数组" class="headerlink" title="不能有泛型数组"></a>不能有泛型数组</h2><p>这是因为Java中Object[]默认为所有数组的父类，如下代码虽然在编译期不会报错，但是在运行时会被检查出objArr指向的数组实际类型（String）和要赋予的类型（Integer）不一致而报错。</p>
<p>也就是说，数组只能存放<strong>定义的实际类型</strong>以及他们的<strong>子类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">objArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>但是，如果支持泛型数组：由于泛型类型参数会在运行时被擦除，导致即使到了运行时也无法发现这个错误，从而会导致错误。</p>
<p>如下，加入支持泛型参数，则objArr1中实际保存的类型（Map&lt;String,Integer&gt;），在编译的时候由于objArr1和objArr2都是Object类型的数组，编译通过；在运行的时候，由于Map中的泛型参数类型已经被擦除，也无法区分objArr1和objArr2中实际指向的两个Map&lt;K,V&gt;数组，也是合法的，这样原本定义的是Map&lt;String,Integer&gt;数组，却可以保存任何类似的Map，而这本来是不允许的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objArr1 = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;String,Integer&gt;[<span class="number">10</span>];</span><br><span class="line">Object[] objArr2 = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;Double,Integer&gt;[<span class="number">10</span>];</span><br><span class="line">objArr1[<span class="number">0</span>] = objArr2[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Collections 类通过一种别扭的方法绕过了这个问题，在 Collections 类编译时会产生类型未检查转换的警告。</p>
<p><code>ArrayList</code>具体实现的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;V&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> V[] backingArray;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span>&#123;</span><br><span class="line">        backingArray = (V[])<span class="keyword">new</span> <span class="title class_">Object</span>()[DEFAULT_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为何这些代码在访问 <code>backingArray</code>时没有产生 <code>ArrayStoreException</code>呢？无论如何，都不能将 <code>Object</code>数组赋给 <code>String</code>数组。因为泛型是通过擦除实现的，<code>backingArray</code>的类型实际上就是 <code>Object[]</code>，因为 <code>Object</code>代替了 <code>V</code>。</p>
<p><strong>这意味着：实际上这个类期望 <code>backingArray</code>是一个 <code>Object</code>数组，但是编译器要进行额外的类型检查，以确保它包含 <code>V</code>类型的对象。</strong></p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html">https://www.ibm.com/developerworks/cn/java/j-jtp01255.html</a></p>
</blockquote>
<h1 id="泛型容器"><a href="#泛型容器" class="headerlink" title="泛型容器"></a>泛型容器</h1><p>由于泛型的类型在运行时会被擦除，所以将类型检查放到了编译期。</p>
<p><code>List&lt;Clazz&gt;</code> 泛型列表只能保存指定泛型类型<code>T</code>的数据，而不能保存其子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jonathan</span> <span class="keyword">extends</span> <span class="title class_">Apple</span>&#123;&#125;</span><br><span class="line"><span class="comment">//编译时报错，类型不兼容</span></span><br><span class="line">List&lt;Fruit&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();</span><br></pre></td></tr></table></figure>

<p>但是能保存Fruit的容器应该也要能安全的保存Apple，为了实现这一点，类似于数组中<code>Object[] arr = Apple[]</code>的向上转型，可以使用<code>?</code>引入协变。</p>
<h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p><code>List&lt;? extends T&gt;</code> 可以<strong>合法的指向一个<code>List&lt; SubT&gt;</code><strong>，这个过程会完成自动</strong>向上转型</strong>，成为可以持有<strong>某个诸如T或者T的子类</strong>的List，但是编译器不知道这个<strong>类</strong>具体是什么，所以拒绝向其中传递任何类型对象，即使Object也不行。</p>
<p>可以这么想，<code>&lt;? extends T&gt;</code>表示的是T的子类，那么<code>List&lt;? extends T&gt;</code> 保存的便是<strong>T的某个子类</strong>，所以不能保存Object或者T等类型，又由于列表不能保存不同的类型，所以也不能保存任何T的子类,即容器将数组在运行时才会有的类型检查放到了编译期（原因是运行时类型会被擦除）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; fruits = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();<span class="comment">//可以安全的应用</span></span><br><span class="line">fruits2.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());<span class="comment">//编译时报错，类型转化错误</span></span><br><span class="line">fruits2.add(<span class="keyword">new</span> <span class="title class_">Fruit</span>());<span class="comment">//编译时报错</span></span><br></pre></td></tr></table></figure>

<h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p><code>List&lt;? super T&gt;</code> <strong>主动声明</strong>通配符<code>?</code>的超类型为<code>T</code>,即List保存的是<strong>T的某个父类</strong>，那么List也可以安全的保存<strong>T或者T的子类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(List&lt;? <span class="built_in">super</span> Apple&gt; apples)</span>&#123;</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Jonathan</span>());</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Fruit</span>());<span class="comment">//error 类型错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/20928981/answer/39234969">java为什么不支持泛型数组？ - ylxfc的回答 - 知乎</a></p>
<p><a href="https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html">Oracle Java 泛型原理</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html">Java 理论和实践-了解泛型-识别和避免学习使用泛型过程中的陷阱</a></p>
<p><a href="https://www.jianshu.com/p/2bf15c5265c5">Java泛型（二） 协变与逆变</a></p>
<p>《Java编程思想 第4版》</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java创建线程安全的单例Singleton</title>
    <url>/blog/posts/36721083/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在编码中常常会用到单例，来确保类有一个唯一的对象，一般情况下将构造方法私有化既可以实现，但当考虑到多线程时事情会变得有些复杂，本文讨论的正是几种多线程的情况下实现单例的方法。</p>
<h1 id="1-普通单例"><a href="#1-普通单例" class="headerlink" title="1.普通单例"></a>1.普通单例</h1><p>私有化构造方法，对外提供一个公有、静态的方法，在其内部判断类对象是否已经存在，否的话生成类对象再返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ASingleton</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ASingleton as;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ASinleton</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;ASingleton init!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(as == <span class="literal">null</span>) &#123;              <span class="comment">//tag1</span></span><br><span class="line">			as = <span class="keyword">new</span> <span class="title class_">ASingleton</span>();    <span class="comment">//tag2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> as;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在考虑多线程时，由于java代码是一行行进行的，假设有两个线程t1、t2，当as为null的时候t1执行到tag1位置，判断为true，于是准备执行tag2，就在此时，cup调度t2开始执行tag1，此时t1尚未执行tag2，所以在t2中tag1判断为true,t2也开始执行tag2生成一个新对象,这样当t1再次执行tag2时就会再生成一个新对象，这样就同时存在多个类的对象。</p>
<h1 id="2-同步锁"><a href="#2-同步锁" class="headerlink" title="2.同步锁"></a>2.同步锁</h1><p>对上面的代码稍作优化,可以看到使用了synchronized，对判断是否需要初始化进行了同步锁，这样当线程t1访问时，语句被锁定，t2运行到这里时，只能等t1运行完这段语句并释放之后，才能继续访问，此时as已经被赋予了对象，所以不会再继续新建，这样就保证了单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ASingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ASingleton as;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ASinleton</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;ASingleton init!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (ASingleton.class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (as == <span class="literal">null</span>) &#123;</span><br><span class="line">				as = <span class="keyword">new</span> <span class="title class_">ASingleton</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> as;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样也存在一个问题，每个线程每次获取单例都要进入同步锁，这样累计下来必然影响效率。</p>
<h1 id="3-双重检查锁定"><a href="#3-双重检查锁定" class="headerlink" title="3.双重检查锁定"></a>3.双重检查锁定</h1><p>那么在判断as为null后，对as的初始化进行同步锁呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (as == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (ASingleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (as == <span class="literal">null</span>) &#123;           <span class="comment">//tag1</span></span><br><span class="line">					as = <span class="keyword">new</span> <span class="title class_">ASingleton</span>();  <span class="comment">//tag2</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> as;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这样子，当判断as为null时，才会进行初始化，同时由于初始化过程加锁，所以t1和t2无法同时访问初始化语句tag2，也保证了只能创建一个单例。</p>
<p>看起来很完美，但是由于java语言的特性，在该段代码编译为汇编语言时，上述方法会被编译为类似下面的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>判断as是否为null</span><br><span class="line"><span class="number">2.</span>令as = ASingleton() <span class="comment">//注意此时只是为as分配了内存，并未执行ASingleton的构造方法</span></span><br><span class="line"><span class="number">3.</span>开始执行ASingleton构造方法，as有了初始化的值</span><br><span class="line"><span class="number">4.</span>返回as</span><br></pre></td></tr></table></figure>

<p>那么，当t1执行到语句2，而t2开始执行语句1时，此时由于as已经分配了内存不为null，所以t2直接执行语句4，此时t2获取到的是一个没有执行构造方法的ASingleton对象，显然这样十分危险。在线程复杂的情况下很容易出现问题。</p>
<p>下面提供了两个结局思路，为简便起见，将其简单分为“饿汉模式”和“懒汉模式”（其实上述方法也可分为这两个模式，but，who cares…）。</p>
<h1 id="4-饿汉模式实现单例"><a href="#4-饿汉模式实现单例" class="headerlink" title="4.饿汉模式实现单例"></a>4.饿汉模式实现单例</h1><p>饿汉模式，即在声明的时候就将对象初始化。</p>
<p>这样实现单例的原理是类的静态变量全局唯一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ASingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ASingleton</span> <span class="variable">as</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASingleton</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ASinleton</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;ASingleton init!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> as;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样仍然有个问题，可能在用到ASingleton类的时候，并不需要立即获取到其单例，在这种情况下，饿汉模式仍然有浪费资源的嫌疑。</p>
<h1 id="5-懒汉模式实现单例"><a href="#5-懒汉模式实现单例" class="headerlink" title="5.懒汉模式实现单例"></a>5.懒汉模式实现单例</h1><p>懒汉模式，只有要用到该实例时，才获取该单例。</p>
<p>这次我们用到的时静态内部类，静态内部类与类的静态变量不同，只有明确调用静态内部类的时候才会初始化静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ASingletonFactory</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ASingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ASingleton</span> <span class="variable">as</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASingleton</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ASinleton</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.print(<span class="string">&quot;ASingleton init!\n&quot;</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ASingleton.as;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，至此已经完成了java实现单例的绝大部分方法，但其实还有一张更加简洁的方法，那就是用enmu实现。</p>
<h1 id="6-enmu实现单例"><a href="#6-enmu实现单例" class="headerlink" title="6.enmu实现单例"></a>6.enmu实现单例</h1><p>由于枚举类型的对象是唯一的，所以是实现单例的较优选择。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SingletonEnum</span>&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosth</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，android开发者要注意，枚举占用的内存是普通单例的两倍多，所以，并不推荐在android中使用。</p>
<p>关于枚举的更详细资料，参阅(深入理解Java枚举类型(enum))[<a href="http://blog.csdn.net/javazejian/article/details/71333103#t7]">http://blog.csdn.net/javazejian/article/details/71333103#t7]</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射简单应用</title>
    <url>/blog/posts/3e9e8cb1/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>反射，用来在运行时获取给定类的构造函数，变量，方法，并对其作以修改，而不必在编译时获取该类。</p>
<blockquote>
<p>Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</p>
<p>–<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html</a></p>
</blockquote>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>定义一个待反射的类ATestClass.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cf.android666.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATestClass</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ATestClass</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot; age: &quot;</span> + age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在TestReflect.java中反射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="comment">//注意这里需要是完整的类名，包括包名</span></span><br><span class="line">	Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cf.android666.reflect.ATestClass&quot;</span>);</span><br><span class="line">	ATestClass aTestClsObj=(ATestClass) clazz.newInstance();</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//反射获取变量</span></span><br><span class="line">	<span class="type">Field</span> <span class="variable">mName</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	mName.setAccessible(<span class="literal">true</span>);</span><br><span class="line">			</span><br><span class="line">	mName.set(aTestClsObj, <span class="string">&quot;aReflect&quot;</span>);</span><br><span class="line">	System.out.println(aTestClsObj.name);</span><br><span class="line">			</span><br><span class="line">	<span class="comment">//反射获取方法</span></span><br><span class="line">	Method mInit= clazz.getDeclaredMethod(<span class="string">&quot;init&quot;</span>, String.class,<span class="type">int</span>.class);</span><br><span class="line">	mInit.setAccessible(<span class="literal">true</span>);<span class="comment">//解除私有限定，让我们在用反射时访问私有变量</span></span><br><span class="line">	mInit.invoke(aTestClsObj, <span class="string">&quot;aInitName&quot;</span>,<span class="number">66</span>);</span><br><span class="line">	System.out.println(aTestClsObj.name + aTestClsObj.getAge());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>反射的用法较为简单</p>
<ul>
<li>通过<code>Class.froName()</code> 获取Class对象<code>clazz</code> ，获取要反射的Class对象<code>aTestClsObj</code> </li>
<li>通过<code>clazz</code> 获取要反射Class的变量、方法</li>
<li>通过<code>aTestClsObj</code> 操作这些变量，方法</li>
</ul>
<p>其中需要注意的有</p>
<ul>
<li><code>f.setAccessible(true);</code> 方法可以解除<code>private</code> 限制，进而可以操作类的私有变量，方法</li>
<li><code>clazz.getXXX()</code> 方法获取<strong>全部公有</strong>变量、方法 ，<strong>包括父类或接口</strong>的xx，<code>clazz.getDeclaredXXX()</code> 方法获取<strong>全部</strong> 变量、方法，包括私有的，实现接口的方法，<strong>但是不包括父类的</strong></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现AES加密解密应用</title>
    <url>/blog/posts/375fcf66/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近手机中涉及到用户账户密码保存的问题，选用AES加密算法进行加密后，再通过SharedPreferences保存在手机端。</p>
<p>本文主要介绍AES的加密、解密用法。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>初始化秘钥</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AES</span> <span class="operator">=</span> <span class="string">&quot;AES&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWPRD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SecretKeySpec <span class="title function_">initKey</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SecretKeySpec</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(AES);</span><br><span class="line">        kg.init(<span class="number">128</span>,<span class="keyword">new</span> <span class="title class_">SecureRandom</span>(PASSWPRD.getBytes()));<span class="comment">//通过这种算法，每次生成的key都是一样的</span></span><br><span class="line">      <span class="comment">//也可以kg.init(128),这样每次生成的key都不一样</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">securityKey</span> <span class="operator">=</span> kg.generateKey();</span><br><span class="line">        <span class="type">byte</span>[] encodedKey = securityKey.getEncoded();</span><br><span class="line">        key = <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(encodedKey, AES);<span class="comment">//AES也可以替换为&quot;AES/CBC/PKCS5PADDING&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="comment">//source是要加密的内容</span></span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(AES);<span class="comment">//创建密码器</span></span><br><span class="line"><span class="type">byte</span>[] byteContent = source.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);<span class="comment">//创建密码器</span></span><br><span class="line"><span class="type">byte</span>[] result = cipher.doFinal(byteContent);<span class="comment">//加密</span></span><br></pre></td></tr></table></figure>

<p>解密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(AES);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"><span class="type">byte</span>[] result = cipher.doFinal(source);</span><br></pre></td></tr></table></figure>

<p>加密和解密的结果都是二进制的，无法直接转化为字符串，所以还需要将二进制与十六进制互转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">parseByte2HexStr</span><span class="params">(<span class="type">byte</span> buf[])</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(buf[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            hex = <span class="string">&#x27;0&#x27;</span> + hex;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.append(hex.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] parseHexStr2Byte(String hexStr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (hexStr.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] result = <span class="keyword">new</span> <span class="title class_">byte</span>[hexStr.length() / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hexStr.length() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Integer.parseInt(hexStr.substring(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">1</span>), <span class="number">16</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> Integer.parseInt(hexStr.substring(i * <span class="number">2</span> + <span class="number">1</span>, i * <span class="number">2</span> + <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">        result[i] = (<span class="type">byte</span>) (high * <span class="number">16</span> + low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在初始化一个key后，对文本进行加密和解密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化key</span></span><br><span class="line"><span class="type">SecretKeySpec</span> <span class="variable">key</span> <span class="operator">=</span> initKey();</span><br><span class="line"><span class="comment">//加密文本并转化为16进制，方便保存</span></span><br><span class="line"><span class="type">String</span> <span class="variable">eStr</span> <span class="operator">=</span> parseByte2HexStr(encrypt(resource,key));</span><br><span class="line"><span class="comment">//将加密16进制文本转为二进制，进行解密</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dStr</span> <span class="operator">=</span> decrypt(parseHexStr2Byte(estr));</span><br></pre></td></tr></table></figure>



<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://blog.csdn.net/hbcui1984/article/details/5201247">JAVA实现AES加密 - CSDN博客</a></p>
<p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-22/encryption">源码github链接</a></p>
]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程笔记</title>
    <url>/blog/posts/b4abf652/</url>
    <content><![CDATA[<h1 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h1><p><code>cThread.join()</code>方法使当前线程阻塞，直到子线程<code>cThread</code>执行完毕后，当前线程才会恢复运行。</p>
<p>实现原理：</p>
<ol>
<li><p><code> join()</code>方法调用了<code>join(0)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code> join(long millis)</code>是一个同步方法，最后会通过调用<code>wait()</code>方法挂起当前线程（即<code>调用线程</code>），直到其他线程调用子线程<code>cThread</code>的<code>notify()</code>或者<code>notifyAll()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子线程<code>run()</code>执行完毕后，系统在关闭该子线程前，会调用其<code>exit()</code>方法，继而在<code>ThreadGroup.threadTerminated(Thread t)</code>中唤醒被阻塞的调用线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is called by the system to give a Thread</span></span><br><span class="line"><span class="comment"> * a chance to clean up before it actually exits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="literal">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="built_in">this</span>);<span class="comment">//提心ThreadGroup当前线程已经被终止</span></span><br><span class="line">        group = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他代码 ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadGroup</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">threadTerminated</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123;<span class="comment">//线程组线程数为0时</span></span><br><span class="line">            notifyAll();<span class="comment">//唤醒所有等待中的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="notify-和notifyAll-的区别"><a href="#notify-和notifyAll-的区别" class="headerlink" title="notify()和notifyAll()的区别"></a>notify()和notifyAll()的区别</h1><p>先了解两个概念：</p>
<p><strong>锁池</strong>：某个<code>Thread</code>调用某个对象的同步方法（<code>synchronized</code>），但还没获取到该对象的锁时，会进入锁池和其他类似的线程一起竞争该对象的锁。</p>
<p><strong>等待池</strong>：当某个<code>Thread</code>调用某个对象的<code>wait()</code>方法释放掉该对象的锁进入阻塞后（waiting on this object’s monitor），会进入等待池。等待池中的线程不会竞争该对象的锁。</p>
<p><code>notify()</code>方法会从等待池中唤醒一个指定线程，该线程可以再次回到锁池竞争该对象的锁，<strong>但可能会导致死锁</strong>（如果唯一唤醒的线程阻塞了并依赖其他线程唤醒，但其他线程都在等待池无法竞争锁，导致死锁）。</p>
<p><code>notifyAll()</code>方法则会唤醒所有在等待池中的线程，之后他们都可以回到锁池竞争该对象的锁。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/5b3054c66fb9a00e4d53ef75#heading-2">Java Thread的join() 之刨根问底</a></p>
<p><a href="https://www.zhihu.com/question/37601861/answer/145545371">java中的notify和notifyAll有什么区别？ - 大王叫我来巡山的回答 - 知乎</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/blog/posts/3f6454bb/</url>
    <content><![CDATA[<p>注解，<em>是描述Java代码的代码，它能够被编译器解析，向编译器、虚拟机说明一些事情，就像java中给程序员看的注释一样</em>。</p>
<p>Android应用开发这方面比较火的是<a href="http://jakewharton.github.io/butterknife/">Butter Knife</a> ,本文讲述如何自定义注解替换findViewById()。</p>
<p>实现<strong>注解（annotation）</strong>的思路：通过<strong>反射</strong>获取到类中使用注解的变量，方法，再调用不同的方法对这些变量，方法进行处理以达到目的。</p>
<p>主要涉及三方面：</p>
<ul>
<li>定义一个注解类</li>
<li>定义一个注解帮助类</li>
<li>使用注解</li>
</ul>
<h1 id="java元注解"><a href="#java元注解" class="headerlink" title="java元注解"></a>java元注解</h1><p>java语言有四个预留的注解，用来生成其他自定义的注解：</p>
<ul>
<li>@Target</li>
</ul>
<p>说明注解所能修饰的范围。其值一般为ElementType.xxx，主要有：</p>
<ol>
<li>CONSTRUCTOR 描述构造器</li>
<li>FIELD 描述域</li>
<li>LOCAL_VARIABLE 描述局部变量</li>
<li>METHOD 描述方法</li>
<li>PACKAGE 描述包</li>
<li>PARAMETER 描述参数</li>
<li>TYPE 描述类，接口，enum声明</li>
</ol>
<ul>
<li>@Retention</li>
</ul>
<p>说明注解存活的生命周期,其值一般为RetentionPolicy.xxx，主要有</p>
<ol>
<li>SOURCE 仅源文件有效，被编译器丢弃</li>
<li>CLASS 在class文件中有效，可能被虚拟机忽略</li>
<li>RUNTIME 在运行时有效，在class被装载时被获取</li>
</ol>
<ul>
<li>@Documented</li>
</ul>
<blockquote>
<p>用于描述其它类型的annotation应该被作为被标注的程序成员的公共API</p>
</blockquote>
<p>表示是否将注解信息添加在java文档中。有该注解则会被Javadoc工具文档化</p>
<p>是一个标记注解，没有值</p>
<ul>
<li>@Inherited</li>
</ul>
<p>表示该标记会被标记的class的子类继承，在查找该注解时，如果当前类没有，会自动向上到其父类中查找，直到<em>该注解类型被找到或是查找完了Object类还未找到</em></p>
<p>是一个标记注解，没有值</p>
<p><strong>注解不能继承其他注解或接口</strong></p>
<h1 id="内建注解"><a href="#内建注解" class="headerlink" title="内建注解"></a>内建注解</h1><p>java中常见的内建注解：</p>
<ul>
<li><code>@Override</code> 重写父类方法</li>
<li><code>@Deprecated</code> 不赞成使用的api</li>
<li><code>@SuppressWarnings() </code> 忽略指定警告</li>
</ul>
<p>参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>deprecation</td>
<td>使用了过时的类或方法时的警告</td>
</tr>
<tr>
<td>unchecked</td>
<td>执行了未检查的转换时的警告</td>
</tr>
<tr>
<td>fallthrough</td>
<td>当Switch程序块进入进入下一个case而没有Break时的警告</td>
</tr>
<tr>
<td>path</td>
<td>在类路径、源文件路径等有不存在路径时的警告</td>
</tr>
<tr>
<td>serial</td>
<td>当可序列化的类缺少serialVersionUID定义时的警告</td>
</tr>
<tr>
<td>finally</td>
<td>任意finally子句不能正常完成时的警告</td>
</tr>
<tr>
<td>all</td>
<td>以上所有情况的警告</td>
</tr>
</tbody></table>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><h2 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">    <span class="comment">//注解参数只可以为public或者默认</span></span><br><span class="line">    <span class="comment">//如果注解中的值不是value，那么在进行注解的时候，需要给出对应的值的名字</span></span><br><span class="line">    <span class="comment">//如@ViewInject(id = R.id.buy)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//注解元素必须有明确的值，要不在定义注解时指定默认值，要不在使用注解时指定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">18</span>;<span class="comment">//指定默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注解参数支持数据类型如下：</p>
<p>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>2.String类型<br>3.Class类型<br>4.enum类型<br>5.Annotation类型<br>6.以上所有类型的数组</p>
</blockquote>
<h2 id="注解帮助类"><a href="#注解帮助类" class="headerlink" title="注解帮助类"></a>注解帮助类</h2><p>主要提供使用注解的方法，代码中的注解替换为真正要实现的逻辑，为注解和使用注解的类搭建一个桥梁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心方法如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindViews</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">  		<span class="comment">//获取到使用注解的类</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Activity</span>&gt; clazz = activity.getClass();</span><br><span class="line">  		<span class="comment">//获取该类中的所有域变量</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">  		<span class="comment">//通过遍历，将使用到注解的变量初始化</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">          	<span class="comment">//获取注解对象</span></span><br><span class="line">            <span class="type">BindView</span> <span class="variable">bindView</span> <span class="operator">=</span> field.getAnnotation(BindView.class);</span><br><span class="line">            <span class="keyword">if</span> (bindView != <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">//获取注解的值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">viewId</span> <span class="operator">=</span> bindView.value();</span><br><span class="line">                <span class="keyword">if</span> (viewId != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">//注解要实现的逻辑，此处为替代clazz中的findViewById()方法，注意getMethod()是获取该类及其实现的接口中所有的public方法</span></span><br><span class="line">                        <span class="type">Method</span> <span class="variable">findViewById</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;findViewById&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">                        findViewById.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> findViewById.invoke(activity, viewId);</span><br><span class="line">                      	<span class="comment">//修改要注解的类，到此注解目的达到</span></span><br><span class="line">                        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        field.set(activity,o);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>在类中通过<code>@xxx()</code> 使用注解，并通过帮助类真正实现注解逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记注解</span></span><br><span class="line"><span class="meta">@BindView(R.id.text)</span></span><br><span class="line"><span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用帮助类方法</span></span><br><span class="line">AnnotationUtils.bindViews(ASampleActivity.<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用初始化之后的变量</span></span><br><span class="line">textView.setText(<span class="string">&quot;hello annotation&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.importnew.com/23816.html">Java核心技术点之注解 - ImportNew</a></li>
<li><a href="http://gityuan.com/2016/01/23/java-annotation/">java注解–gityuan</a></li>
</ul>
]]></content>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记之YYYY格式化日期</title>
    <url>/blog/posts/87a89a43/</url>
    <content><![CDATA[<p>最近看到一个<a href="https://v2ex.com/t/633650?p=1">帖子</a>，表示有人以<code>&quot;YYYY-MM-dd&quot;</code>格式化日期时，在<code>2019-12-30</code>时出现<code>2020-12-30</code>的BUG。</p>
<p>本文来简单分析一下为什么会出现这个情况。</p>
<p>根据<a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#year">JDK文档关于日期的定义</a>，<code>y</code>表示的是我们日常使用的年份，而<code>Y</code>表示的是<code>Week year</code>。</p>
<p>先了解几个知识点：</p>
<h1 id="Week-year"><a href="#Week-year" class="headerlink" title="Week year"></a>Week year</h1><p><code>Week year</code>表示的是<strong>这个周所属的年份</strong>。</p>
<blockquote>
<p>A <em>week year</em> is in sync with a <code>WEEK_OF_YEAR</code> cycle. All weeks between the first and last weeks (inclusive) have the same <em>week year</em> value. Therefore, the first and last days of a week year may have different calendar year values.</p>
<p>来源：<a href="https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year">https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year</a></p>
</blockquote>
<h1 id="WEAK-OF-YEAR"><a href="#WEAK-OF-YEAR" class="headerlink" title="WEAK_OF_YEAR"></a>WEAK_OF_YEAR</h1><p>指的是这一年所有的周，从第01周开始到该年最后一周。</p>
<p>要注意这个周不一定是自然周，所包含的日期也不一定全部都是当年的日期。</p>
<blockquote>
<p>Values calculated for the <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html#WEEK_OF_YEAR"><code>WEEK_OF_YEAR</code></a> field range from 1 to 53. The first week of a calendar year is the earliest seven day period starting on <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html#getFirstDayOfWeek()"><code>getFirstDayOfWeek()</code></a> that contains at least <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html#getMinimalDaysInFirstWeek()"><code>getMinimalDaysInFirstWeek()</code></a> days from that year.</p>
</blockquote>
<h1 id="第01周"><a href="#第01周" class="headerlink" title="第01周"></a>第01周</h1><p>根据这份<a href="https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year">JDK文档</a>，当 <code>getFirstDayOfWeek()</code> is <code>MONDAY</code>（2） and <code>getMinimalDaysInFirstWeek()</code> is 4时，JAVA判断周日期的标准与<a href="https://en.wikipedia.org/wiki/ISO_8601">ISO_8601</a>兼容：</p>
<blockquote>
<p>第01周有几个相互等效且兼容的描述：</p>
<p>一年中第一个星期四的星期（正式的ISO定义），</p>
<p>1月4日这一周，</p>
<p>起始年份中大部分（四天或以上）的第一周，以及</p>
<p>从12月29日至1月4日的星期一开始的一周。</p>
<p>来源：<a href="https://en.wikipedia.org/wiki/ISO_8601">https://en.wikipedia.org/wiki/ISO_8601</a></p>
</blockquote>
<p>按照JAVA文档中的定义，每年最开始的几天和最后的几天的<code>Week year</code>不一定是当年的年份值，而是受到每年的<em>第01周&#x2F;最后一周</em>的影响。</p>
<p>JAVA中判断周主要受到<code>Calendar</code>对象的<code>getFirstDayOfWeek()</code>和<code>getMinimalDaysInFirstWeek()</code>这两个本地值的影响。</p>
<p>其中：</p>
<ul>
<li><code>getFirstDayOfWeek() </code>指定一周的第一天，比如, 美国一周从<code>SUNDAY</code> 开始,法国则是<code>MONDAY</code> 。</li>
<li><code>getMinimalDaysInFirstWeek()</code> 一年第一周所需最小的天数。比如1表示只要包含第一天就算该年的第一周，而7表示只有完整的一周都在该年才算该年的第一周。</li>
</ul>
<p><strong>注意</strong>：真正影响我们格式化日期结果的是<code>SimpleDateFormat</code>中的<code>calendar</code>对象对应的值。</p>
<p>而通过打印这个<code>simpleDateFormat.calendar</code>，我们看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK1.7</span></span><br><span class="line">minimalDaysInFirstWeek:<span class="number">1</span></span><br><span class="line">firstDayOfWeek:<span class="number">1</span> <span class="comment">//SUNDAY</span></span><br></pre></td></tr></table></figure>

<p>所以可以得出结论，JAVA<strong>默认只要次年的1月1日在在这个跨年周，那么本周所有日期的<code>Week year</code>都是次年的</strong>（<code>JDK1.7</code>）。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>有了以上知识，我们再看看<code>2019-12-30</code>以<code>YYYY</code>格式化为什么会出现问题：</p>
<p>先看一下这些日期对应的星期：</p>
<table>
<thead>
<tr>
<th>周日</th>
<th>周一</th>
<th>周二</th>
<th>周三</th>
<th>周四</th>
<th>周五</th>
<th>周六</th>
</tr>
</thead>
<tbody><tr>
<td>29</td>
<td>30</td>
<td>31</td>
<td><strong>1</strong></td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<p>首先根据JDK默认的<code>第01周</code>的定义，<code>2020-01-01</code>所在的周为<code>2020的第一周</code>，所以<code>2019-12-29到2020-01-04</code>都属于是<code>2020年的第01周</code>。</p>
<p>再根据<code>YYYY</code>表示的是<code>Week year</code>的结论，可以知道，当使用<code>YYYY</code>格式化时，<code>2019-12-29到2020-01-04</code>都会得到<code>2020</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> calendar = Calendar.getInstance()</span><br><span class="line"><span class="keyword">val</span> simpleDateFormat = SimpleDateFormat(<span class="string">&quot;YYYY yyyy MM dd&quot;</span>)</span><br><span class="line">calendar.<span class="keyword">set</span>(<span class="number">2019</span>, <span class="number">12</span>-<span class="number">1</span>, <span class="number">29</span>)</span><br><span class="line">println(simpleDateFormat.format(calendar.time))</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">DATE:<span class="number">2019</span> <span class="number">12</span> <span class="number">29</span></span><br><span class="line">minimalDaysInFirstWeek:<span class="number">1</span></span><br><span class="line">firstDayOfWeek:<span class="number">1</span></span><br><span class="line">YYYY yyyy MM dd</span><br><span class="line"><span class="number">2020</span> <span class="number">2019</span> <span class="number">12</span> <span class="number">29</span></span><br></pre></td></tr></table></figure>

<p>而如果我们把第一周最小天数<code>minimalDaysInFirstWeek</code>改为<code>5</code>天，那么很明显这一周属于<code>2020</code>年的天数（从周日到周一，只有1号到4号4天）不够5天，所以这一周被划归为<code>2019</code>年的第<code>53周</code>，<code>2019-12-29到2020-01-04</code>的<code>week year</code>都是属于<code>2019</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> calendar = Calendar.getInstance()</span><br><span class="line"><span class="keyword">val</span> simpleDateFormat = SimpleDateFormat(<span class="string">&quot;YYYY yyyy MM dd&quot;</span>)</span><br><span class="line">calendar.<span class="keyword">set</span>(<span class="number">2019</span>, <span class="number">12</span>-<span class="number">1</span>, <span class="number">29</span>)</span><br><span class="line">simpleDateFormat.calendar.minimalDaysInFirstWeek = <span class="number">5</span></span><br><span class="line">println(simpleDateFormat.format(calendar.time))</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">DATE:<span class="number">2019</span> <span class="number">12</span> <span class="number">29</span></span><br><span class="line">minimalDaysInFirstWeek:<span class="number">5</span></span><br><span class="line">firstDayOfWeek:<span class="number">1</span></span><br><span class="line">YYYY yyyy MM dd</span><br><span class="line"><span class="number">2019</span> <span class="number">2019</span> <span class="number">12</span> <span class="number">29</span></span><br></pre></td></tr></table></figure>

<p>再比如下面这个<a href="https://blog.csdn.net/bewilderment/article/details/48391717">示例</a>中的<code>2010-12-26</code>。</p>
<p><img src="https://img-blog.csdn.net/20150912103324519?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>按照<code>JDK1.7</code>默认算法，一周从周日（<code>2010-12-26</code>）开始，并且当年的1月1日（<code>2011-01-01</code>）所在周为该年第一周，所以<code>2010-12-26到2011-01-01</code>都被划到了<code>2011</code>年的第一周。</p>
<p>但如果按照<a href="https://en.wikipedia.org/wiki/ISO_8601">ISO_8601</a>的标准，一周从周一开始，并且起始年份包含的天数至少要有<code>4</code>天：</p>
<p>则很明显<code>2010-12-26</code>属于<code>2010</code>年的<code>51周</code>，而<code>2010-12-27到2011-01-02</code>都属于<code>2010</code>年的第<code>52周</code>（属于2020年的只有2天，不满足第一周的条件）。</p>
<table>
<thead>
<tr>
<th>周一</th>
<th>周二</th>
<th>周三</th>
<th>周四</th>
<th>周五</th>
<th>周六</th>
<th>周日</th>
</tr>
</thead>
<tbody><tr>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
</tr>
<tr>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>结合以上结论，我们可以看到，在JAVA中（<code>JDK1.7</code>）：</p>
<ul>
<li><p><code>“YYYY” </code>表示<code>Week year</code></p>
</li>
<li><p>每年最开始的几天和最后的几天的<code>Week year</code>不一定是当年的值，而是受到当年的第一周&#x2F;最后一周的影响。</p>
</li>
<li><p>JAVA周的判断与<code>simpleDateFormat.calendar.minimalDaysInFirstWeek</code>和<code>simpleDateFormat.calendar.firstDayOfWeek</code>有关。</p>
<p>而这两个值都属于本地化值，<strong>在国内可以简单理解为一年1月1日所在的周就是当年的第一周。</strong></p>
</li>
<li><p>我们可以通过修改<code>minimalDaysInFirstWeek</code>和<code>firstDayOfWeek</code>来更改<code>YYYY</code>格式化的值。</p>
</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>JDK中日期格式化的参数及含义（来自<a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#month%EF%BC%89%EF%BC%9A">https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#month）：</a></p>
<table>
<thead>
<tr>
<th>Letter</th>
<th>Date or Time Component</th>
<th>Presentation</th>
<th>Examples</th>
</tr>
</thead>
<tbody><tr>
<td><code>G</code></td>
<td>Era designator</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#text">Text</a></td>
<td><code>AD</code></td>
</tr>
<tr>
<td><code>y</code></td>
<td>Year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#year">Year</a></td>
<td><code>1996</code>; <code>96</code></td>
</tr>
<tr>
<td><code>Y</code></td>
<td>Week year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#year">Year</a></td>
<td><code>2009</code>; <code>09</code></td>
</tr>
<tr>
<td><code>M</code></td>
<td>Month in year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#month">Month</a></td>
<td><code>July</code>; <code>Jul</code>; <code>07</code></td>
</tr>
<tr>
<td><code>w</code></td>
<td>Week in year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>27</code></td>
</tr>
<tr>
<td><code>W</code></td>
<td>Week in month</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>D</code></td>
<td>Day in year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>189</code></td>
</tr>
<tr>
<td><code>d</code></td>
<td>Day in month</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>F</code></td>
<td>Day of week in month</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td>Day name in week</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#text">Text</a></td>
<td><code>Tuesday</code>; <code>Tue</code></td>
</tr>
<tr>
<td><code>u</code></td>
<td>Day number of week (1 &#x3D; Monday, …, 7 &#x3D; Sunday)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>a</code></td>
<td>Am&#x2F;pm marker</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#text">Text</a></td>
<td><code>PM</code></td>
</tr>
<tr>
<td><code>H</code></td>
<td>Hour in day (0-23)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>k</code></td>
<td>Hour in day (1-24)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>24</code></td>
</tr>
<tr>
<td><code>K</code></td>
<td>Hour in am&#x2F;pm (0-11)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>h</code></td>
<td>Hour in am&#x2F;pm (1-12)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>12</code></td>
</tr>
<tr>
<td><code>m</code></td>
<td>Minute in hour</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>30</code></td>
</tr>
<tr>
<td><code>s</code></td>
<td>Second in minute</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>55</code></td>
</tr>
<tr>
<td><code>S</code></td>
<td>Millisecond</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number">Number</a></td>
<td><code>978</code></td>
</tr>
<tr>
<td><code>z</code></td>
<td>Time zone</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#timezone">General time zone</a></td>
<td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td>
</tr>
<tr>
<td><code>Z</code></td>
<td>Time zone</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#rfc822timezone">RFC 822 time zone</a></td>
<td><code>-0800</code></td>
</tr>
<tr>
<td><code>X</code></td>
<td>Time zone</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#iso8601timezone">ISO 8601 time zone</a></td>
<td><code>-08</code>; <code>-0800</code>; <code>-08:00</code></td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>感谢这篇文章，让我推翻了上一次的结论，发现了真正的原因：<a href="https://blog.csdn.net/bewilderment/article/details/48391717">JAVA中的SimpleDateFormat yyyy和YYYY的区别</a></p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year">GregorianCalenda jdk1.7</a></p>
<p>在线显示本周是一年第几周的网站：<a href="https://www.epochconverter.com/weeknumbers">What’s the Current Week Number?</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java笔记之序列化与反序列化：Serializable、Externalizable和Parcelable</title>
    <url>/blog/posts/9d9183ec/</url>
    <content><![CDATA[<img src="https://images.pexels.com/photos/2881229/pexels-photo-2881229.jpeg?cs=srgb&dl=white-and-blue-cables-2881229.jpg&fm=jpg" class="full-image" />
Photo by **[Pixabay ](https://www.pexels.com/@pixabay?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)**from **[Pexels](https://www.pexels.com/photo/close-up-of-telephone-booth-257736/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)**



<p><strong>序列化</strong>：指将<code>Java对象</code>转化为<code>字节流</code>以便在网络、文件中保存、传输。</p>
<p><strong>反序列化</strong>：指的是从字节流中恢复Java对象。</p>
<p>本文主要讨论Android和Java中实现序列化的4种方式，并探讨一下其实现原理。</p>
<p>Android &amp; Java中实现序列化的方式有：</p>
<ul>
<li><code>android.os.Parcelable</code> Android平台特有，需要自己实现具体细节，性能消耗小，只能在内存中存在</li>
<li><code>java.io.Serializable</code> 实现简单，只需要实现<code>Serializable</code>接口即可，可以输出到文件、网络等</li>
<li><code>java.io.Externalizable</code> 需要自己实现具体细节</li>
<li><a href="https://github.com/twitter/Serial/blob/master/README-CHINESE.rst/"><code>Twitter Serial</code></a> Twitter出品的高性能序列化方案，它力求帮助开发者实现高性能和高可控的序列化过程。（本文不详细介绍，可以参考<a href="https://www.jianshu.com/p/1b42608478c0">这篇文章</a>）</li>
</ul>
<h1 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h1><p><code>Serializable</code>接口没有任何方法，只是一个标记——表示这个类可以用来<code>序列化/反序列化</code>（由<code>ObjectOutputStream/ObjectInputStream</code>实现具体细节）。</p>
<p>一个类没有实现<code>Serializable接口</code>，或者包含没有<code>实现Serializable接口的变量</code>，则会序列化失败<code>NotSerializableException</code>。</p>
<h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>使用<code>serialVersionUID</code>标记当前<code>Serializable</code>的版本。</p>
<p>如果没有指定，系统会自动用对象的<code>hashCode()</code>指定<code>serialVersionUID</code>，该值会在类发生改变时变化，从而导致反序列化失败。</p>
<p>而如果<code>serialVersionUID</code>一致，即使类结构有变化，也会反序列化（给新增的变量默认值），所以最好赋予一个默认的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以手动指定，也可以随机数，只要保持一致即可，如果不一致则会使反序列化失败</span></span><br><span class="line">ANY-ACCESS-MODIFIER <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<h2 id="readResolve"><a href="#readResolve" class="headerlink" title="readResolve()"></a>readResolve()</h2><p>如果<code>class</code>实现了<code>readResolve()</code>方法，会在反序列化时用到并返回这里提供的对象（反序列化得到的对象会被丢弃）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 反序列化</span></span><br><span class="line"><span class="type">SerializableClass</span> <span class="variable">serializableClass</span> <span class="operator">=</span> (SerializableClass) objectInputStream.readObject();</span><br><span class="line"><span class="comment">// 2.readObject()内部调用了readObject0(false):</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">                <span class="comment">// 这里匹配了TC_NULL,TC_REFERENCE,TC_CLASS,TC_CLASSDESC,</span></span><br><span class="line">                <span class="comment">// TC_PROXYCLASSDESC,TC_STRING,TC_LONGSTRING,TC_ARRAY,TC_ENUM</span></span><br><span class="line">                <span class="comment">// TC_EXCEPTION,TC_BLOCKDATA,TC_BLOCKDATALONG,TC_ENDBLOCKDATA等等类型</span></span><br><span class="line">               </span><br><span class="line">                <span class="keyword">case</span> TC_OBJECT:<span class="comment">//如果是OBECJT类型，就调用下面的方法👇</span></span><br><span class="line">                    <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">                <span class="comment">// ... </span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">                        String.format(<span class="string">&quot;invalid type code: %02X&quot;</span>, tc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            bin.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 3. 在这里会检测是否存在readResolve()方法，有的话就返回从readResolve()获取的对象</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Object obj;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 看这里，如果hasReadResolveMethod()为真则执行invokeReadResolve()并返回其结果</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            desc.hasReadResolveMethod())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">            <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">                rep = cloneArray(rep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">                <span class="comment">// Filter the replacement object</span></span><br><span class="line">                <span class="keyword">if</span> (rep != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                        filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                handles.setObject(passHandle, obj = rep);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Invokes the readResolve method of the represented serializable class and returns the result.</span></span><br><span class="line">    Object <span class="title function_">invokeReadResolve</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException, UnsupportedOperationException&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个特性我们可以确保在反序列化的时候也能实现<strong>单例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object readResolve() throws ObjectStreamException &#123;</span><br><span class="line">    return this;//返回单例本身，而非新建的对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是根据下面的说法，要实现可以序列化的单例最简单安全的，还是使用枚举：</p>
<blockquote>
<p><strong>事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域则都必须声明为transient的</strong>。否则，利用<code>readResolve()</code>方法实现的单例也会遭受到攻击。</p>
<p>实现可序列化最简单安全的方式是采用枚举的形式，应该尽可能采用这种方式。如果采用<code>readResolve</code>实现的话，要确保该类的所有实例域都为<code>基本类型</code>，或者是<code>transient</code>的。</p>
<p>[77.单例模式，枚举类型优先于readResolve](<a href="https://cl0610.github.io/effective-java-learning/%E7%AC%AC%E5%8D%81%E7%AB%A0">https://cl0610.github.io/effective-java-learning/第十章</a> 序列化&#x2F;77.单例模式，枚举类型优先于readResolve.html)</p>
</blockquote>
<h2 id="自定义序列化过程"><a href="#自定义序列化过程" class="headerlink" title="自定义序列化过程"></a>自定义序列化过程</h2><p>如果想要自己处理序列化的过程，可以实现下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException;</span><br></pre></td></tr></table></figure>

<p>其中，可以使用下面的方法实现<code>读/写</code><strong>该类自身的属性</strong>（<code>All non-static and non-transient fields of the current class, include private</code>），然后在调用诸如<code>out.writeObject(string);</code>等方法<strong>保存其他变量</strong>。</p>
<blockquote>
<p>The method does not need to concern itself with the state belonging to its superclasses or subclasses.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">in.defaultReadObject();</span><br><span class="line">out.defaultWriteObject();</span><br></pre></td></tr></table></figure>

<p><code>readObjectNoData</code>方法主要用在序列化流和我们要反序列化的类不一致时初始化一些必要的状态。</p>
<blockquote>
<p>这种情况可能出现在接收方使用了一个与发送方不同版本的类。接收方的版本多扩展了一些字段，而发送方的版本没有这些字段。还有一种可能就是序列化流被篡改了。这时，无论是恶意的流还是不完整的流，都可以用 <code>readObjectNoData</code> 方法来将序列化得到的对象初始化到正确的状态。<br>作者：福尔马林<br>链接：<a href="https://juejin.im/post/5d7206c5f265da03ab427181">https://juejin.im/post/5d7206c5f265da03ab427181</a></p>
</blockquote>
<p>此外，还可以使用<code>ObjectOutputStream</code>的<code>putFields()</code>和<code>ObjectInputStream</code>的<code>readFields()</code>写入&#x2F;读取变量。使用这种方法可以<em>加密&#x2F;解密</em>部分变量，或者在序列化的时候<em>只处理部分变量</em>。</p>
<p>具体使用方法见如下：</p>
<blockquote>
<p><strong>注意</strong>：<code>putFields()/readFields()</code>方法分别不能与<code>defaultWriteObject/defaultReadObject</code>一起使用；</p>
<p><code>putFields.put()</code>之后必须调用<code>out.writeFields()</code>方法</p>
<p>并且，没有在<code>putFields()</code>中加入的数据，在<code>readObject</code>中只能获取到该类型的默认值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这段示例代码来自 https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">PutField</span> <span class="variable">putFields</span> <span class="operator">=</span> out.putFields();</span><br><span class="line">           System.out.println(<span class="string">&quot;原密码：&quot;</span> + password);</span><br><span class="line">           password = <span class="string">&quot;encryption&quot;</span>;<span class="comment">//模拟加密</span></span><br><span class="line">           putFields.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">           System.out.println(<span class="string">&quot;加密后的密码：&quot;</span> + password);</span><br><span class="line">           out.writeFields();<span class="comment">// putFields.put()之后必须调用本方法</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">GetField</span> <span class="variable">readFields</span> <span class="operator">=</span> in.readFields();</span><br><span class="line">           <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> readFields.get(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;要解密的字符串：&quot;</span> + object.toString());</span><br><span class="line">           password = <span class="string">&quot;pass&quot;</span>;<span class="comment">//模拟解密,需要获得本地的密钥</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 执行反序列化结果：</span></span><br><span class="line"><span class="comment">// 原密码：pass</span></span><br><span class="line"><span class="comment">// 加密后的密码：encryption</span></span><br><span class="line"><span class="comment">// 要解密的字符串：encryption</span></span><br><span class="line"><span class="comment">// 最后反序列化后的password为pass</span></span><br></pre></td></tr></table></figure>



<h2 id="父类未继承Serializable的类的序列化"><a href="#父类未继承Serializable的类的序列化" class="headerlink" title="父类未继承Serializable的类的序列化"></a>父类未继承Serializable的类的序列化</h2><p>如果一个类实现了序列化，但他的父类没有实现序列化，那么父类<strong>必须要有一个公开的无参构造函数</strong>，否则反序列化时会出错。</p>
<p>此时反序列化时，父类的变量值（<code>public, protected, and (if accessible) package fields</code>）都会是<strong>默认的值</strong>或者是在<strong>父类无参构造函数中初始化的值</strong>（即使这些值在子类对象中已经被修改了）。</p>
<p>要想使得这些值也可以支持序列化，可以通过<code>writeObject/readObject</code>自己处理这些值的序列化。</p>
<p>反之，如果一个类实现了<code>Serializable</code>接口，那么他的子类也自动支持序列化与反序列化。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面是使用<code>Serializable</code>实现序列化与反序列化的简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: jixiaoyong</span></span><br><span class="line"><span class="comment"> * email: jixiaoyong1995@gmail.com</span></span><br><span class="line"><span class="comment"> * website: https://jixiaoyong.github.io</span></span><br><span class="line"><span class="comment"> * date: 12/24/19</span></span><br><span class="line"><span class="comment"> * description: 演示序列化功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SerializableClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">anInt</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="variable">aLong</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">String</span> <span class="variable">aTransient</span> <span class="operator">=</span> <span class="string">&quot;transient filed cannot be serialized&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">A_STATIC_FILED</span> <span class="operator">=</span> <span class="string">&quot;static filed belong to class not object, cannot be serialized&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SerializableClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerializableClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;ObjectOutputFile&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//write object to byte sequences</span></span><br><span class="line">            objectOutputStream.writeObject(clazz);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//chang the object filed</span></span><br><span class="line">            clazz.aLong = <span class="number">666L</span>;</span><br><span class="line">            <span class="comment">// A_STATIC_FILED belong to the class, so you can see it has the value read form</span></span><br><span class="line">            <span class="comment">// the JVM rather the object you serialized before when you deserializes it.</span></span><br><span class="line">            SerializableClass.A_STATIC_FILED = <span class="string">&quot;Change the static filed!&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">SerializableClass</span> <span class="variable">serializableClass</span> <span class="operator">=</span> (SerializableClass) objectInputStream.readObject();</span><br><span class="line">            System.out.println(serializableClass);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SerializableClass&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;anInt=&quot;</span> + anInt +</span><br><span class="line">                <span class="string">&quot;, aLong=&quot;</span> + aLong +</span><br><span class="line">                <span class="string">&quot;, aTransient=&#x27;&quot;</span> + aTransient + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, A_STATIC_FILED=&#x27;&quot;</span> + A_STATIC_FILED + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// SerializableClass&#123;anInt=10, aLong=100, aTransient=&#x27;null&#x27;, A_STATIC_FILED=&#x27;Change the static filed!&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="多次序列化同一个对象"><a href="#多次序列化同一个对象" class="headerlink" title="多次序列化同一个对象"></a>多次序列化同一个对象</h2><p>返序列化读取的过程在<code>readResolve()</code>方法一节已经涉及到了，我们在看一下保存的部分，这里会有一个有意思的现象：</p>
<blockquote>
<p>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html</a></p>
</blockquote>
<p>这会导致一个问题：当使用同一个<code>ObjectOutputStream对象</code>序列化<code>同一个序列化对象</code>时，即使在第一次序列化并保存后修改了这个对象的部分属性，当再次序列化时保存的<strong>只是前一个对象的引用</strong>——也就是说将完全相同一个对象保存了两次，<strong>第二次做的修改在序列化的时候并没有保存</strong>。</p>
<p>我们写个简单的DEMO验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readAndwriteObject2</span><span class="params">(SerializableClass clazz)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;ObjectOutputFile&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file))</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一次序列化</span></span><br><span class="line">            objectOutputStream.writeObject(clazz);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line"></span><br><span class="line">            clazz.aLong = <span class="number">9344L</span>;<span class="comment">//在这里修改了部分属性</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二次序列化</span></span><br><span class="line">            objectOutputStream.writeObject(clazz);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 反序列化，读取之前序列化的两个对象</span></span><br><span class="line">            <span class="type">SerializableClass</span> <span class="variable">serializableClass</span> <span class="operator">=</span> (SerializableClass) objectInputStream.readObject();</span><br><span class="line">            System.out.println(serializableClass);</span><br><span class="line">            <span class="type">SerializableClass</span> <span class="variable">serializableClass1</span> <span class="operator">=</span> (SerializableClass) objectInputStream.readObject();</span><br><span class="line">            System.out.println(serializableClass1);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;serializableClass == serializableClass1: &quot;</span> + (serializableClass == serializableClass1));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// output </span></span><br><span class="line"><span class="comment">// SerializableClass&#123;anInt=10, aLong=100, aaLong=100, aTransient=&#x27;null&#x27;, A_STATIC_FILED=&#x27;static filed belong to class not object, cannot be serialized&#x27;&#125;</span></span><br><span class="line"><span class="comment">// SerializableClass&#123;anInt=10, aLong=100, aaLong=100, aTransient=&#x27;null&#x27;, A_STATIC_FILED=&#x27;static filed belong to class not object, cannot be serialized&#x27;&#125;</span></span><br><span class="line"><span class="comment">// serializableClass == serializableClass1: true //可以看到两次获取的是完全相同的对象</span></span><br></pre></td></tr></table></figure>

<p>这是为什么呢，我们可以在源码中看到原因：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化时，我们会调用ObjectOutputStream的writeObject方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">            writeObjectOverride(obj);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObject0(obj, <span class="literal">false</span>);<span class="comment">//注意这里，第二个参数unshared是false</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">                writeFatalException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** obj -&gt; wire handle map */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandleTable handles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">            <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">              <span class="comment">// 可以看到这里，如果unshared为false的话，</span></span><br><span class="line">              <span class="comment">// 就会去找这个对象是否已经被序列化过了，是的话就直接写入引用,</span></span><br><span class="line">              <span class="comment">// 而不是再次序列化</span></span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Writes given object handle to stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeHandle</span><span class="params">(<span class="type">int</span> handle)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        bout.writeByte(TC_REFERENCE);</span><br><span class="line">        bout.writeInt(baseWireHandle + handle);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为了避免这种情况，在保存同一个对象时要注意使用不同的<code>ObjectOutputStream</code>对象，或者可以使用<code>writeUnshared</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Writes an &quot;unshared&quot; object to the ObjectOutputStream.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeUnshared</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writeObject0(obj, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            writeFatalException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>简单，只需要实现接口</li>
<li>序列化的字节流可以在文件、网络中传递，可以持久化保存</li>
<li>性能差，序列化过程大量使用反射和临时变量</li>
</ul>
<h1 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h1><p><code>Externalizable</code>继承自<code>Serializable</code>。</p>
<p>用户需要通过<code>writeExternal(ObjectOutput out)</code>和<code>readExternal(ObjectInput in)</code>实现序列化与反序列化的细节，并且需要一个明确实现的**<code>public no-arg constructor</code>**</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewClass</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">anInt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">aLong</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">float</span> <span class="variable">aFloat</span> <span class="operator">=</span> <span class="number">10F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NewClass</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeInt(anInt);</span><br><span class="line">        out.writeObject(string);</span><br><span class="line">        out.writeLong(aLong);</span><br><span class="line">        out.writeFloat(aFloat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        anInt = in.readInt();</span><br><span class="line">        string = (String) in.readObject();</span><br><span class="line">        aLong = in.readLong();</span><br><span class="line">        aFloat = in.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NewClass&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;anInt=&quot;</span> + anInt +</span><br><span class="line">                <span class="string">&quot;, string=&#x27;&quot;</span> + string + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, aFloat=&quot;</span> + aFloat +</span><br><span class="line">                <span class="string">&quot;, aLong=&quot;</span> + aLong +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>看源码可以知道，如果检测到当前对象是<code>Externalizable</code>时，就会去调用该对象的<code>writeExternal方法</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable </span><br><span class="line">    </span><br><span class="line"><span class="comment">// writeObject0 方法中：</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                writeString((String) obj, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                writeArray(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">                writeOrdinaryObject(obj, desc, unshared);<span class="comment">//如果是Serializable就执行这个</span></span><br><span class="line">            &#125; </span><br><span class="line"><span class="comment">// writeOrdinaryObject方法中：</span></span><br><span class="line">            <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">                writeExternalData((Externalizable) obj);<span class="comment">//如果是Externalizable就执行这个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                writeSerialData(obj, desc);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// writeExternalData方法中</span></span><br><span class="line"><span class="comment">// Writes externalizable data of given object by invoking its writeExternal() method.</span></span><br><span class="line">            <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">                obj.writeExternal(<span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">                obj.writeExternal(<span class="built_in">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>比<code>Serializable</code>麻烦，序列化与反序列化都需要用户自己实现</li>
<li>灵活，可以自定义要参与到序列化与反序列化的变量</li>
</ul>
<h1 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h1><p><code>Parcelable</code>是Android为了解决<code>Serializable</code>性能问题而推出的,主要用在Android的<code>Intent</code>或<code>线程间通信</code>中。</p>
<p><code>Parcelable</code>通过<code>Parcel</code>传输到<code>IBinder</code>中，从而实现跨进程传输。</p>
<blockquote>
<p>对于<code>kotlin</code>语言来说，Android Studio自动生成的<code>Parcelable</code>代码不会处理val变量（因为这些变量不会变化）</p>
<p>此外，<code>Parcelable</code>在反序列化时，调用<code>parcel.readParcelable(classLoader)</code>传入的是<code>ClassLoader</code>。</p>
</blockquote>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>下面是一个<code>Parcelable</code>的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AParcelable</span></span>() : Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Parcel中恢复数据，必须按照写入的顺序读取</span></span><br><span class="line">    <span class="keyword">constructor</span>(parcel: Parcel) : <span class="keyword">this</span>() &#123;</span><br><span class="line">        i = parcel.readInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将变量写入到Parcel中，必须与读取的顺序对应</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeToParcel</span><span class="params">(parcel: <span class="type">Parcel</span>, flags: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        parcel.writeInt(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述，一般默认为0</span></span><br><span class="line">    <span class="comment">// 如果这个对象的writeToParcel方法的输出中有特殊的对象则传递对应的描述代码</span></span><br><span class="line">    <span class="comment">// 如：如果包含一个文件描述符FileDescriptor，就要返回CONTENTS_FILE_DESCRIPTOR</span></span><br><span class="line">    <span class="comment">//  https://developer.android.google.cn/reference/android/os/Parcelable.html#CONTENTS_FILE_DESCRIPTOR</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">describeContents</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有这个变量，用来从Parcel中创建Parcelable类</span></span><br><span class="line">    <span class="comment">// 在JAVA中是public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() &#123;...&#125;</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> CREATOR : Parcelable.Creator&lt;AParcelable&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span>: AParcelable &#123;</span><br><span class="line">            <span class="keyword">return</span> AParcelable(parcel)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new array of the Parcelable class.</span></span><br><span class="line">        <span class="comment">// Returns an array of the Parcelable class, with every entry</span></span><br><span class="line">        <span class="comment">// initialized to null.</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newArray</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Array&lt;AParcelable?&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfNulls(size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>原理参考这篇文章<a href="https://www.kancloud.cn/xcy396/android_tech/1296524">Parcelable源码分析</a></p>
<h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>性能好，<code>Parcelable</code>接口比<code>Serializable</code>接口效率更高，性能方面高出10多倍 <a href="https://www.kancloud.cn/xcy396/android_tech/1296524">^Parcelable源码分析</a>:</li>
<li>较复杂，需要自己实现对象的序列化内容</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一般需要持久化保存数据或在网络间传输时推荐使用<code>Serializable</code>或者<code>Externalizable</code>。</p>
<p>在Android中<code>Activity</code>之间等传递对象，以及跨进程传递对象等时使用<code>Parcelable</code>以节省性能。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://darryrzhong.xyz/2019/09/15/Android%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/">Android之序列化详解</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html">Java 序列化的高级认识</a></p>
<p><a href="https://juejin.im/post/5d7206c5f265da03ab427181#heading-0">https://juejin.im/post/5d7206c5f265da03ab427181#heading-0</a></p>
<p><a href="https://www.javacodegeeks.com/2019/08/serialization-everything-java-serialization-explained.htmlhttps://juejin.im/post/5ce3cdc8e51d45777b1a3cdf#heading-0">https://www.javacodegeeks.com/2019/08/serialization-everything-java-serialization-explained.htmlhttps://juejin.im/post/5ce3cdc8e51d45777b1a3cdf#heading-0</a></p>
<p><a href="https://blog.csdn.net/qq_16628781/article/details/70049623">https://blog.csdn.net/qq_16628781/article/details/70049623</a></p>
<p>[77.单例模式，枚举类型优先于readResolve](<a href="https://cl0610.github.io/effective-java-learning/%E7%AC%AC%E5%8D%81%E7%AB%A0">https://cl0610.github.io/effective-java-learning/第十章</a> 序列化&#x2F;77.单例模式，枚举类型优先于readResolve.html)</p>
<p>Pareclable实现原理：<a href="https://juejin.im/post/5a3b24ab6fb9a04515440bd7">Parcelable最强解析</a></p>
<p>Parcelable使用：<a href="https://www.jianshu.com/p/32a2ec8f35ae">详细介绍Android中Parcelable的原理和使用方法</a></p>
<p><a href="https://www.kancloud.cn/xcy396/android_tech/1296524">Parcelable源码分析</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程安全与volatile和synchronize</title>
    <url>/blog/posts/24967ad4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java多线程编码中，保证线程安全的实质是保证对数据操作的原子性，即一个线程对数据的操作能够及时的更新到其他使用该数据的线程中，这样就可以避免多个线程因为操作的数据值不一致而产生错误。</p>
<p><img src="https://jixiaoyong.github.io/images/20190112144856.png" alt="线程、主内存、工作内存三者交互关系——深入理解JAVA虚拟机"></p>
<p>由于Java内存模型（JMM）规定，所有线程公用的数据保存在主内存中，而线程在使用时先从主内存中取到线程私有的工作内存中，之后再在使用完毕后同步到主内存中，在这过程中，如果其他线程也用到了该数据则可能会出现问题，因此在线程操作数据时需要考虑线程并发时操作数据的同步问题。</p>
<p><code>volatile</code>和<code>synchronize</code>因此而生。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p><code>volatile</code>修饰的变量有两个特性：</p>
<ul>
<li>变量对所有线程可见  普通变量则需要等线程操作完毕，将结果从工作内存写入到主内存中才可以被其他线程可见，volatile修饰的变量会在修改后通知其他线程该变量已经被更改，从而让其他线程再去主内存中读取最新的值</li>
<li>禁止指令重排优化</li>
</ul>
<p><code>volatile</code>修饰的变量执行效率和普通变量差别不大，其写操作因为要插入内存屏障，所以会稍微慢一些</p>
<p>需要注意的是：</p>
<ul>
<li><p>由于Java运算的具体实现并非原子性的，故而虽然<code>volatile</code>修饰的变量在所有线程可见，但是并发下并不线程安全。</p>
<blockquote>
<p>Java代码编译成class文件后可以看到，类似<code>c = c + 1</code>这样的语句，会被分为：读取<code>c</code>的值；计算<code>c+1</code>的值；将结果赋予<code>c</code>这几步来完成。所以在此期间如果有其他的线程访问这段代码，就会发生冲突。</p>
</blockquote>
</li>
<li><p>Java会通过<strong>指令重排</strong>来优化代码</p>
<blockquote>
<p>指令重排 指对于变量的赋值会在定义该变量和使用该变量的值之间的任意位置执行，不一定和代码中的顺序一致</p>
</blockquote>
<p><code>volatile</code>修饰的变量则会插入<em>内存屏障</em>，从而实现屏蔽指令重排的效果</p>
</li>
</ul>
<h1 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h1><p><code>synchronize</code>实现的原理是<strong>锁定指定的对象</strong>（如果没有指定则锁定对应的类对象或class对象），然后阻塞其他线程进入（获取到该锁的线程可以多次重入）。</p>
<p>由于Java的线程实现是映射到系统线程的，阻塞和唤醒需要由系统内核完成，会消耗大量的时间，因此<code>synchronize</code>是<strong>重量级操作</strong>。</p>
<h1 id="JMM与三个特征"><a href="#JMM与三个特征" class="headerlink" title="JMM与三个特征"></a>JMM与三个特征</h1><p>JMM的设计是围绕着<strong>原子性、可见性、有序性</strong>三个特征进行的。</p>
<ul>
<li><p><strong>原子性</strong> JVM中的<code>read,load,assign,use,store,write</code>操作和<code>synchronize</code></p>
</li>
<li><p><strong>可见性</strong> 一个线程更改了共享变量的值时，其余线程能够立即得知这个更改。通过<code>synchronize</code>，<code>final</code>和<code>volatile</code>保证。</p>
<p><code>final</code>要保证可见性的前提是要被<strong>安全的构建出来</strong>，避免<strong>“this引用逃逸”</strong></p>
<blockquote>
<p><strong>this引用逃逸</strong> 对象还没有被构造完成，他的<code>this引用</code>就已经被发布出去了。</p>
<p>在构造函数中生成内部类，由于内部类自动持有外部类的<code>this引用</code>，如果有对象在内部类语句之后构造，则就有可能发生“内部类访问这个对象时，该对象还没有构造完毕”的情况。</p>
</blockquote>
</li>
<li><p><strong>有序性</strong> 通过<code>synchronize</code>,<code>volatile</code>保证。</p>
</li>
</ul>
<p>线程从内部观察时有序（线程内是串行的语义），线程外部观察是无序（由指令重排、工作内存与主内存同步延迟导致）</p>
<h1 id="实现线程安全"><a href="#实现线程安全" class="headerlink" title="实现线程安全"></a>实现线程安全</h1><p>实现线程安全有以下几种方法：</p>
<h2 id="互斥同步（阻塞同步）"><a href="#互斥同步（阻塞同步）" class="headerlink" title="互斥同步（阻塞同步）"></a>互斥同步（阻塞同步）</h2><p>互斥同步的思想是：多个线程使用同一个共享数据时，保证同一时刻只能被一个线程使用</p>
<p>有两种途径：</p>
<ul>
<li><code>synchronize</code> （原生语法层），优先使用</li>
<li><code>ReentrantLock</code> 重入锁（API层），功能有：1.等待可中断（可以放弃等待）2.公平锁 多个线程申请锁时必须按照申请时间顺序获得锁 3.锁绑定多个条件</li>
</ul>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>减少了阻塞&#x2F;唤醒的耗时，在操作时进行CAS（比较并交换），在冲突发生的时候不断尝试执行所需操作，直到执行成功。</p>
<p>但是有一个逻辑漏洞：如果在第一次操作失败到第二次再次尝试操作之间，<em>其他线程对齐进行了操作但是该数据最终没有被变化</em>，当第二次再次尝试时，其实已经被其他线程访问过了。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>保证线程安全，不一定需要同步，当线程操作的数据不是共享数据时，即使不同步也是线程安全的。</p>
<ul>
<li><strong>可重入代码</strong> 指在代码执行的过程中，如果中断其运行并运行其他的线程，当再次返回继续执行该代码时不会影响到其执行结果的代码。这种代码一般没有用到堆中的公用资源。</li>
<li><strong>线程本地存储</strong> 共享数据值存在于同一个线程中，如每个线程的ThreadLocal对象</li>
</ul>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>JDK1.6以后，在HotSpot虚拟机上实现了许多锁优化技术：</p>
<ul>
<li><p>自旋锁</p>
<p>实现阻塞同步时，阻塞和唤醒会很耗时，为了避免这种情况，可以先对其进行<em>忙循环</em>，如果还不行再去执行阻塞操作</p>
<p><em>自适应自旋</em> 由JVM智能决定自旋次数</p>
</li>
<li><p>锁消除</p>
<p>JVM会自动取出不必要的锁</p>
</li>
<li><p>锁粗化</p>
<p>如果一段代码中有连续的锁，则JVM会将这些锁合并为一个大锁</p>
</li>
<li><p>轻量级锁</p>
<p>轻量级锁消耗比传统锁机制小，会优先尝试使用轻量级锁，如果不行，在升级为互斥锁</p>
<p>大多数情况下会减少消耗，但如果存在锁竞争，则除了互斥锁的开销外，还有轻量级锁的开销</p>
</li>
<li><p>偏向锁</p>
<p>在无竞争的情况下消除同步</p>
</li>
<li><p>乐观锁</p>
<p>读取数据时默认该对象不会被其他对象更改而不加锁，每次写数据时对比当前值与持有值是否一致，一致时才去更新数据</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《深入理解Java虚拟机——JVM高级特性与最佳实践》 周志明</p>
<p><a href="https://blog.csdn.net/u010571316/article/details/77993309">this引用逃逸——蜡笔小勋</a></p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin学习笔记1</title>
    <url>/blog/posts/135b2780/</url>
    <content><![CDATA[<p>这是我在学习Bennyhuo（ <a href="https://github.com/enbandari/Kotlin-Tutorials">github</a> ）的kotlin入门视频时的一些笔记，比较偏基础，用于查缺补漏。</p>
<ul>
<li><p>xx.map() &amp; xx.flatMap()</p>
<p>xx.flatMap()用于返回<strong>可迭代</strong>的数组，而xx.map()则是任何<strong>可迭代</strong>数据都有的用来遍历的方法。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = arrayListOf&lt;String&gt;(<span class="string">&quot;a c v de  fb s e  gf d&quot;</span>)</span><br><span class="line">arr.flatMap &#123;</span><br><span class="line">    it.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;.map&#123; </span><br><span class="line">    print(<span class="string">&quot;<span class="subst">$&#123;it.toUpperCase()&#125;</span>&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>enum class 枚举类型</p>
<p>分为有参和无参，枚举变量以<code>,</code>分隔，如果enum还有方法或者伴生对象，则最后一个变量后为<code>;</code>，否则可为<code>,</code>、<code>;</code>或者没有。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    UK,USA,EU;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下为非必须代码，仅表示可以有这些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(s:<span class="type">String</span>)</span></span>:City&#123;</span><br><span class="line">            <span class="keyword">return</span> valueOf(s.toUpperCase())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        有参的情况如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span></span>(<span class="keyword">val</span> aName:String)&#123;</span><br><span class="line">    CHINA(<span class="string">&quot;中国&quot;</span>),</span><br><span class="line">    JAPAN(<span class="string">&quot;日本&quot;</span>),</span><br><span class="line">    USA(<span class="string">&quot;美国&quot;</span>),</span><br><span class="line">    UK(<span class="string">&quot;英国&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>​        使用：通过enum的valueOf()方法获取枚举对象实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var s = &quot;uk&quot;</span><br><span class="line">var city = City.valueOf(s.toUpperCase())</span><br><span class="line">//或者通过伴生对象：</span><br><span class="line">var city = City.fun1(s)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>companion object伴生对象</p>
<p>在类的定义，可以直接用<code>类名.方法名()</code>调用，相当于java中的静态方法</p>
<p>一个类中只能有一个伴生对象</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(x: <span class="type">String</span>)</span></span>: Country &#123;</span><br><span class="line">            <span class="keyword">return</span> valueOf(x.toUpperCase())</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>object修饰的类</p>
<p>等同于只有一个实例的类，相当于java中的静态类，所有方法可以直接用类名调用</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ClassName&#123;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fun ClassName.funName()为类添加新的方法</p>
<p>对于不能直接修改的类，有需要对其增加一个方法，可以自定义一个<code>ClassName.funName()</code>的方法来达到这个目的。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Country.<span class="title">sayNum</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this引用的是country对象</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        CHINA -&gt; <span class="number">1</span></span><br><span class="line">        JAPAN -&gt; <span class="number">2</span></span><br><span class="line">        USA -&gt; <span class="number">3</span></span><br><span class="line">        UK -&gt; <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在使用时可以通过<code>Country</code>的对象调用<code>syaNum()</code>方法</p>
<ul>
<li><p>data class 数据类</p>
<p>可以有方法，方便复制。</p>
<p>必须至少有一个参数，并且参数都需要用var&#x2F;val修饰</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">dataClass</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">val</span> age :<span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>文件读取<ul>
<li>resource目录下的文件读取</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = File(ClassLoader.getSystemResource(<span class="string">&quot;input&quot;</span>).path).readText()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>与RxJava结合</p>
<p>统计文本中字母个数，基于RxJava 1.2.1</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.from(input.toCharArray().asIterable())</span><br><span class="line">        .filter &#123; !it.isWhitespace() &#125;</span><br><span class="line">        .groupBy &#123; it &#125;</span><br><span class="line">        .map&#123;</span><br><span class="line">            o -&gt;o.count().subscribe&#123;</span><br><span class="line">                print(<span class="string">&quot;<span class="subst">$&#123;o.key&#125;</span>-&gt; <span class="variable">$it</span>  ,&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin学习笔记2</title>
    <url>/blog/posts/8a52763a/</url>
    <content><![CDATA[<h1 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h1><p>把递归通过编译器转化为迭代，从而避免Stack Overflow</p>
<p>“以时间换取空间”</p>
<p>普通递归：</p>
<p>调用函数之后，还需要使用其返回值供自己使用，即自身返回值依赖于下一级函数，一般是调用自身的代码后面，还有其他的代码要执行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: BigInteger &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> BigInteger.valueOf(<span class="number">1L</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n.toBigInteger().times(fun1(n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾递归：</p>
<p>调用自身之后，无需再返回当前函数,将处理结果以其他形式返回。</p>
<p>普通递归和尾递归都存在栈溢出风险（未优化前，例子中的函数计算10000到100000的阶乘时会溢出），kotlin提供了一种尾递归优化的方法——<code>tailrec</code>，使得编译器在编译时将递归转化为迭代，从而避免栈溢出。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>(<span class="keyword">var</span> value: BigInteger = BigInteger.valueOf(<span class="number">1L</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾递归，tailrec为kotlin中优化关键字</span></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">(n: <span class="type">Int</span>, m: <span class="type">Result</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        m.value = m.value.times(BigInteger.valueOf(<span class="number">1L</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m.value = m.value.times(n.toBigInteger())</span><br><span class="line">        fun2(n-<span class="number">1</span>,m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中传入<code>fun2()</code>的<code>Result</code>实例保存了计算结果</p>
<h1 id="sealed-class-密封类"><a href="#sealed-class-密封类" class="headerlink" title="sealed class 密封类"></a>sealed class 密封类</h1><p>密封类的所有子类必须在一个文件(xx.kt)中，他的子类是有限的，所以当<code>when()</code>的时候不需要<code>else</code>。</p>
<p>某种意义上他们像是一种<code>enum class</code>，只不过他的子类可以有多个实例。</p>
<blockquote>
<p>Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sealed class</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Play</span></span>(<span class="keyword">var</span> arg:String) : Player()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> Stop : Player()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">p2</span></span>():Player()</span><br></pre></td></tr></table></figure>

<h1 id="kotlin抛出异常"><a href="#kotlin抛出异常" class="headerlink" title="kotlin抛出异常"></a>kotlin抛出异常</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getBookList</span><span class="params">()</span></span>:List&lt;Book&gt;</span><br></pre></td></tr></table></figure>

<h1 id="kotlin中的泛型"><a href="#kotlin中的泛型" class="headerlink" title="kotlin中的泛型"></a>kotlin中的泛型</h1><p><code>out</code> 协变，使用子类泛型的对象可以赋值给使用父类泛型的对象，相当于<code>extend</code>，用于方法的返回值（生产者）时使用</p>
<p><code>in</code> 逆变，使用父类泛型的对象可以赋值给使用子类泛型的对象，相当于<code>super</code>，用于方法的参数（消费者）时使用</p>
<p>不变，当泛型即当消费者，又当生产者时，不用<code>in</code>或者<code>out</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> from = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> to = arrayOf(Any())</span><br><span class="line"></span><br><span class="line">    copyArray(from,to)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyArray</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里的from被out修饰，只能作为生产者调用get之类的方法，不能作为消费者调用set之类的方法</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="星号投射"><a href="#星号投射" class="headerlink" title="星号投射"></a>星号投射</h1><blockquote>
<p>你对类型参数一无所知，但仍然希望以安全的方式使用它。</p>
</blockquote>
<p><strong>安全的使用</strong>，则表示该类<code>Group&lt;T&gt;</code>满足</p>
<blockquote>
<p>1.子类至少接收和父类一样范围的参数 &gt;&#x3D;  —&gt; 父类入参为Noting 不能安全写入</p>
<p>2.子类最多返回和父类一样范围的参数 &lt;&#x3D;  —&gt; 父类出参为Any? 可以安全读取</p>
</blockquote>
<p>则有以下三种实现方式</p>
<p><img src="https://jixiaoyong.github.io/images/20191022194750.png" alt="in-out-star-projection-approaches"></p>
<p>其中：</p>
<p><code>Group&lt;in Noting&gt;</code> 的<code>fetch()</code>方法一直返回<code>Any?</code></p>
<p><code>Group&lt;out Any?&gt;</code> 的<code>T</code>需要与实际的<code>Group</code>的<code>T</code>保持一致，否则会报错</p>
<p><code>Group&lt;*&gt;</code> 既能<code>insert</code>正确返回对应的类型，也不用实时修改</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> TClass &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readIn</span><span class="params">(group: <span class="type">Group</span>&lt;<span class="type">in</span> <span class="type">Nothing</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> d = group.fetch()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readOut</span><span class="params">(group: <span class="type">Group</span>&lt;<span class="type">out</span> <span class="type">Animal</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> d = group.fetch()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(group: <span class="type">Group</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> d = group.fetch()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Group</span>&lt;<span class="type">T : Dog</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(member: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetch</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托是将重复出现的代码放到一个地方。</p>
<p><img src="https://jixiaoyong.github.io/images/20191023194526.png" alt="委托示意图"></p>
<ul>
<li>类委托 ：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;	<span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span>	&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> : <span class="type">Interface</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>(a: Interface) : Interface <span class="keyword">by</span> a</span><br></pre></td></tr></table></figure>

<p>这样B便可以将<code>Interface</code>中方法的实现委托给类<code>A</code>的对象<code>a</code></p>
<ul>
<li>委托属性：</li>
</ul>
<p>将同一类型的属性的<code>get</code>、<code>set</code>方法放到一个地方实现，可以在加入<code>其它操作</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(clazz: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;get()&quot;</span>)<span class="comment">//其它操作</span></span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(clazz: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, t: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot; set()&quot;</span>)</span><br><span class="line">        name = t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegate()</span><br><span class="line">    <span class="keyword">var</span> age: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>委托类的初始化函数：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">delegate</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span> = Delegate(initializer)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> delegate &#123;</span><br><span class="line">        println(<span class="string">&quot;MyClass1.name init&quot;</span>)</span><br><span class="line">        <span class="string">&quot;MyClass1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span>&lt;<span class="type">T</span>&gt;</span>(initializer: () -&gt; T) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(myClass1: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$className</span> get()&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(myClass1: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;, t: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$className</span> set()&quot;</span>)</span><br><span class="line">        name = t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> className = initializer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Map委托：</li>
</ul>
<p>将类的<code>属性</code>名称和<code>map</code>中的<code>key</code>一一对应，从而将对于<code>value</code>赋值给<code>属性</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span>(map: Map&lt;String, Any&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;shany&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span> to <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">val</span> b = ClassB(map)</span><br><span class="line">    print(b.name)<span class="comment">//shayn</span></span><br><span class="line">    print(b.age)<span class="comment">//18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>veroable</li>
</ul>
<p>可以拦截赋值操作</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span>() &#123;</span><br><span class="line">   <span class="keyword">var</span> name:String <span class="keyword">by</span> Delegates.vetoable(<span class="string">&quot;ThisIsInitialValue&quot;</span>)&#123;</span><br><span class="line">       property, oldValue, newValue -&gt;</span><br><span class="line">       <span class="keyword">return</span><span class="symbol">@vetoable</span> <span class="literal">false</span> <span class="comment">//返回true允许更改值，false不允许更改</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="中缀函数"><a href="#中缀函数" class="headerlink" title="中缀函数"></a>中缀函数</h1><p>需要满足三个条件：</p>
<ol>
<li>成员函数或拓展函数</li>
<li>只有一个参数</li>
<li>infix声明</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">div</span><span class="params">(string: <span class="type">String</span>)</span></span>:String&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(string,<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;bababbaab&quot;</span> div <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h1><p><code>inline</code>修饰的函数在被调用时将字节码动态插入到被到调用的地方。</p>
<p><code>inline</code>修饰的函数的<code>lambda参数</code>如果运行在该函数内部的*<code>子函数/其他环境</code><em>，则不允许这个lambda函数<strong>非局部返回</strong>（因为没有办法从该 <code>子函数/其他环境</code> 中直接退出lambda所在的外层函数），对于这种lambda函数需要添加*</em><code>crossinline</code>**修饰。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**非局部返回**指从lambda2中执行return语句，推出的是整个func()</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">func1</span><span class="params">(<span class="keyword">crossinline</span> lambda1:()-&gt;<span class="type">Unit</span>,  lambda2:()-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> f = Runnable &#123;</span><br><span class="line">        lambda1()<span class="comment">//不可以调用非局部返回，所以用crossinline修饰</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    lambda2()<span class="comment">//可以调用非局部返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Kotlin也存在Java泛型所具有的<strong>类型擦除</strong>问题，为了优化该问题，inline函数可以结合<code>reified</code>实现<strong>实体化类型参数</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isInstanceOf</span><span class="params">(value: <span class="type">Any</span>)</span></span> = value <span class="keyword">is</span> T <span class="comment">//在这里仍然可以知道T是什么类型的，所以可以执行value is T </span></span><br><span class="line">print(isInstanceOf&lt;String&gt;(<span class="string">&quot;&quot;</span>))<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>**原理:**内联函数会直接被插入到被调用的地方，而<code>reified</code>修饰的类型参数会保证将用户调用时写的类型<code>String</code>同时也写入到被调用的地方，如此便没有发生类型擦除。</p>
<h1 id="coroutines-协程"><a href="#coroutines-协程" class="headerlink" title="coroutines 协程"></a>coroutines 协程</h1><p>协程可以看做是一个轻量级的thread，他运行在线程当中，由用户控制，没有上下文切换的开销。</p>
<p>在Android中使用协程，特别是在IO操作及网络请求等需要根据耗时操作更新界面的需求时，可以将IO操作和界面操作串行，避免切换线程、回调嵌套等导致代码可读性查的问题。</p>
<p>如配合支持协程的retrofit，我们可以将网络请求简化如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="comment">//这里是主线程</span></span><br><span class="line">    showProgressOnMainThread()</span><br><span class="line">    <span class="keyword">val</span> repos = withContext(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="comment">//这里是UI线程</span></span><br><span class="line">        retrofitApi.getRepos(<span class="string">&quot;jixiaoyong&quot;</span>).string()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是主线程</span></span><br><span class="line">    updateUIOnMainThread(repos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin协程需要单独添加依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2&#x27;</span></span><br><span class="line">implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2&quot;</span> <span class="comment">//Android可以再添加这个依赖，会有一些特殊方法</span></span><br></pre></td></tr></table></figure>

<p> 一个父协程总是等待所有的子协程执行结束， 父协程被取消的时候，所有它的子协程也会被递归的取消。 </p>
<h2 id="协程中runBlocking与coroutineScope的区别"><a href="#协程中runBlocking与coroutineScope的区别" class="headerlink" title="协程中runBlocking与coroutineScope的区别"></a>协程中<code>runBlocking</code>与<code>coroutineScope</code>的区别</h2><p>相同点：</p>
<p>依次执行内部代码，如果<code>代码1</code>是启动协程，那么启动该子协程后，继续执行<code>代码1</code>后面的代码直到最后一行（类似启动新线程，不会阻塞当前线程），然后再等待所有内部协程结束，才会退出。</p>
<p>不同点：</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html"><strong><code>runBlocking</code></strong></a>：会运行一个新的协程线程，并阻塞其所在<code>线程</code>,直到其内部所有协程&#x2F;子协程执行完毕才会退出。设计用来以阻塞的方式执行协程代码，不应该在协程中使用。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html"><strong><code>coroutineScope</code></strong></a>：不会阻塞其所在线程，要在协程中使用，当其内部所有协程&#x2F;子协程执行完毕才会退出。设计用来执行并行操作，一旦有子协程失败，则其他子协程都会被取消，整个代码块执行失败。</p>
<h2 id="协程的思维导图"><a href="#协程的思维导图" class="headerlink" title="协程的思维导图"></a>协程的思维导图</h2><iframe width='853' height='480' src='https://embed.coggle.it/diagram/Xb_CZoumpCamgUAj/1235701ea5f157867e045f0f5ac28f886effdb5fa1e27b72afa5266e6e3e8891' frameborder='0' allowfullscreen></iframe>


<p>需要说明的是</p>
<p><code>Dispatchers.Unconfined</code> 非受限，不会限定协程运行的线程，而是随环境切换</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">    <span class="comment">// main thread</span></span><br><span class="line">    withContext(newSingleThreadContext(<span class="string">&quot;hello&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//hello thread</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hello thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协程局部变量"><a href="#协程局部变量" class="headerlink" title="协程局部变量"></a>协程局部变量</h2><p>通过<code>ThreadLocal</code>、<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/index.html"><code>ThreadContextElement</code></a>，配合<code>asContextElement(&quot;value&quot;)</code>方法实现。和协程所在的线程没有关系。</p>
<p>直接修改<code>ThreadLocal</code>的值，会在切换协程的时候失效（会被改为切换到的协程所使用的的值），当再次切回本协程时，被重置为上一个通过<code>asContextElement(&quot;value&quot;)</code>方法更新的值或者<code>null</code>（如果没有指定）。</p>
<blockquote>
<p> 原理：<strong>启动和恢复时保存<code>ThreadLocal</code>在当前线程的值，并修改为 value，挂起和结束时修改当前线程<code>ThreadLocal</code>的值为之前保存的值</strong> </p>
<p> —— <a href="https://johnnyshieh.me/posts/kotlin-coroutine-concurrency/">Kotlin Coroutines(协程) 完全解析（五），协程的并发</a></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> threadLocal = ThreadLocal&lt;String?&gt;() <span class="comment">// 声明线程局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    threadLocal.<span class="keyword">set</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    printValue(<span class="number">1</span>) <span class="comment">// main</span></span><br><span class="line">    async (Dispatchers.Default + threadLocal.asContextElement(value = <span class="string">&quot;launch&quot;</span>)) &#123;</span><br><span class="line">        printValue(<span class="number">2</span>) <span class="comment">// launch</span></span><br><span class="line">        threadLocal.<span class="keyword">set</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//        threadLocal.asContextElement(&quot;hello&quot;) //如果使用这个方法更新，则 printValue(4) 会打印 hello</span></span><br><span class="line">        printValue(<span class="number">3</span>) <span class="comment">// hello</span></span><br><span class="line">        yield()</span><br><span class="line">        printValue(<span class="number">4</span>)<span class="comment">// launch</span></span><br><span class="line">    &#125;.await()</span><br><span class="line">    printValue(<span class="number">5</span>) <span class="comment">// main</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printValue</span><span class="params">(number: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$number</span>: <span class="subst">$&#123;Thread.currentThread()&#125;</span>, thread local value: &#x27;<span class="subst">$&#123;threadLocal.get()&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="在Android中使用"><a href="#在Android中使用" class="headerlink" title="在Android中使用"></a>在Android中使用</h2><p>Kotlin官方推荐一下两种方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> CoroutineScope</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> : <span class="type">CoroutineScope by CoroutineScope</span></span>(Dispatchers.Default) &#123;</span><br><span class="line">    <span class="comment">// 继续运行……</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> MainScope</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续运行……</span></span><br></pre></td></tr></table></figure>




<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://typealias.com/guides/star-projections-and-how-they-work/">Star-Projections and How They Work</a></p>
<p><a href="https://blog.csdn.net/u013064109/article/details/83507076">Kotlin的独门秘籍Reified实化类型参数(下篇)</a></p>
<p><a href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html">Kotlin 协程官网</a></p>
<p><a href="https://johnnyshieh.me/posts/kotlin-coroutine-concurrency/">Kotlin Coroutines(协程) 完全解析（五），协程的并发</a></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin学习笔记3</title>
    <url>/blog/posts/fd5546ac/</url>
    <content><![CDATA[<blockquote>
<p>本文为笔记性质，尚未成文，待整理</p>
</blockquote>
<h1 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h1><ol>
<li><p>lazy方式创建一个序列，只有在访问的时候才生产对应的项目</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Sequence&lt;<span class="built_in">Int</span>&gt; = sequence&#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)<span class="comment">//会阻塞调用线程</span></span><br><span class="line">        yield(i)<span class="comment">//生产一个项目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Flow流在不阻塞主线程的情况下，延迟生产多个值并返回</p>
<p> 当流在一个可取消的挂起函数（例如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>）中挂起的时候取消，否则不能取消。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flow 构建器中的代码直到流被收集的时候才运行，并且每次collect都会被启动</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// 流构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们在这里做了一些有用的事情，这里可以被取消</span></span><br><span class="line">        emit(i) <span class="comment">// 发送下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m not blocked <span class="variable">$k</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集这个流</span></span><br><span class="line">    foo().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html">flowOf</a> 构建器定义了一个发射固定值集的流。</p>
<p>使用 <code>.asFlow()</code> 扩展函数，可以将各种集合与序列转换为流。</p>
<p> 可以使用操作符转换流，就像使用集合与序列一样。 过渡操作符应用于上游流，并返回下游流。 这些操作符也是冷操作符，就像流一样。这类操作符（<code>map</code>、<code>fliter</code>…）本身不是挂起函数，但是可以调用挂起函数<code>suspend</code>。它运行的速度很快，返回新的转换流的定义。 </p>
<p> 在流转换操作符中，最通用的一种称为 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html">transform</a>。它可以用来模仿简单的转换，例如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html">map</a> 与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a>，以及实施更复杂的转换。 使用 <code>transform</code> 操作符，我们可以 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">发射</a> 任意值任意次 </p>
<p> 限长过渡操作符（例如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html">take</a>）在流触及相应限制的时候会将它的执行取消。 </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">numbers</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;                          </span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>) </span><br><span class="line">        println(<span class="string">&quot;This line will not execute&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Finally in numbers&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    numbers() </span><br><span class="line">        .take(<span class="number">2</span>) <span class="comment">// 只获取前两个</span></span><br><span class="line">        .collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>流构造器中的协程上下文默认和collect的协程上下文一致，如果强行转换上下文会出错。</p>
<p>而使用<code>flowOn()</code>则可以指定流创建的协程上下文：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class="line">        log(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 在流构建器中改变消耗 CPU 代码上下文的正确方式</span></span><br></pre></td></tr></table></figure>

<p>如果flow的生产和收集很消耗时间时，可以用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html"><code>buffer()</code></a>函数将<code>buffer()</code>之前的代码在一个单独的协程运行，collect则在调用协程运行，这样将flow的构建、收集由串行转化为并行可以节约时间（如果构建运行的快，则会挂起直到collect赶上来）。</p>
<blockquote>
<p> It will use two coroutines for execution of the code. A coroutine <code>Q</code> that calls this code is going to execute <code>collect</code>, and the code before <code>buffer</code> will be executed in a separate new coroutine <code>P</code> concurrently with <code>Q</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">foo()</span><br><span class="line">       .buffer() <span class="comment">// buffer emissions, don&#x27;t wait</span></span><br><span class="line">       .collect &#123; value -&gt; </span><br><span class="line">               delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">           println(value) </span><br><span class="line">       &#125; </span><br></pre></td></tr></table></figure>

<h1 id="合并conflate"><a href="#合并conflate" class="headerlink" title="合并conflate"></a>合并conflate</h1><p> <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> operator can be used to skip intermediate values when a collector is too slow to process them. </p>
<p>当collect比构建慢的时候，就只会请求最新的值，而跳过中间生产的这些值。</p>
<p>比如，构建器生产了1，2，… ,100这些数，而collect读取的慢，第一次读的时候是1，等处理完再读取的时候构建器生产的是5，那么collect就读取5，中间的2，3，4都会被丢弃。</p>
<p> Conflation is one way to speed up processing when both the emitter and collector are slow 。 The other way is to cancel a slow collector and restart it every time a new value is emitted.  </p>
<p><code>collectLatest</code>可以保证每次都获取最新的值，如果collect比生产慢，那么当新的值生产出来时，collect会被取消，并且去处理最新的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// pretend we are asynchronously waiting 100 ms</span></span><br><span class="line">        emit(i) <span class="comment">// emit next value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        foo()</span><br><span class="line">            .collectLatest &#123; value -&gt; <span class="comment">// cancel &amp; restart on the latest value</span></span><br><span class="line">                    println(<span class="string">&quot;Collecting <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// pretend we are processing it for 300 ms</span></span><br><span class="line">                println(<span class="string">&quot;Done <span class="variable">$value</span>&quot;</span>) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Collecting <span class="number">1</span></span><br><span class="line">Collecting <span class="number">2</span></span><br><span class="line">Collecting <span class="number">3</span></span><br><span class="line">Done <span class="number">3</span></span><br><span class="line">Collected <span class="keyword">in</span> <span class="number">694</span> ms</span><br></pre></td></tr></table></figure>

<h1 id="组合多个流"><a href="#组合多个流" class="headerlink" title="组合多个流"></a>组合多个流</h1><p><code>zip</code>将两个流“压缩”为一个流：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">val</span> number = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">    <span class="keyword">val</span> strs = flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>)</span><br><span class="line">    number.zip(strs) &#123; a, b -&gt;</span><br><span class="line">        <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span></span><br><span class="line">    &#125;.collect&#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">1</span> -&gt; one</span><br><span class="line"><span class="number">2</span> -&gt; two</span><br><span class="line"><span class="number">3</span> -&gt; three</span><br></pre></td></tr></table></figure>

<p> 当 flow 表示变量或操作的最新值时(参见关于合并的相关章节) ，可能需要执行依赖于相应流的最新值的计算，并在任何上游流发出值时重新计算它。 相应的操作符族称为联合操作符 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html"><code>combine</code></a>。即每个构建值发生变化时都会触发collect。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125; <span class="comment">// numbers 1..3 every 300 ms</span></span><br><span class="line"><span class="keyword">val</span> strs = flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>).onEach &#123; delay(<span class="number">400</span>) &#125; <span class="comment">// strings every 400 ms          </span></span><br><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis() <span class="comment">// remember the start time </span></span><br><span class="line">nums.combine(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125; <span class="comment">// compose a single string with &quot;combine&quot;</span></span><br><span class="line">    .collect &#123; value -&gt; <span class="comment">// collect and print </span></span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$value</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start&quot;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//output    </span></span><br><span class="line"><span class="number">1</span> -&gt; one at <span class="number">452</span> ms from start</span><br><span class="line"><span class="number">2</span> -&gt; one at <span class="number">651</span> ms from start</span><br><span class="line"><span class="number">2</span> -&gt; two at <span class="number">854</span> ms from start</span><br><span class="line"><span class="number">3</span> -&gt; two at <span class="number">952</span> ms from start</span><br><span class="line"><span class="number">3</span> -&gt; three at <span class="number">1256</span> ms from start</span><br></pre></td></tr></table></figure>



<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html"><code>flatMapConcat</code></a> 可以将flow的内容“抹平”（即假设原先为<code>Array&lt;Array&lt;Int&gt;&gt;</code>，则押平后为：<code>Array&lt;Int&gt;</code>）。串行执行，即先执行代码块，然后对其<code>flatMapConcat</code>，然后collect，之后再执行下一轮的Flow项目。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html"><code>flatMapMerge</code></a> 按顺序调用它的代码块 ，但是同时收集结果流，这相当于首先执行一个顺序映射 ，然后对结果调用 flattonmerge。并行执行，先依次对Flow项目调用代码块，然后哪个值先出来，就先对其调用 <code>flatMapMerge</code>，然后collect。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html"><code>flatMapLatest</code></a> 类似 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html"><code>collectLatest</code></a> ，每次新值出来就会取消还没有处理结束的旧流的操作。</p>
<h1 id="流异常"><a href="#流异常" class="headerlink" title="流异常"></a>流异常</h1><p>流的异常有如下捕获方式：</p>
<ol>
<li><p><a href="https://kotlinlang.org/docs/reference/exceptions.html"><code>try/catch</code></a> block </p>
</li>
<li><p>透明捕获  <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a>  ，只会捕获发送在他之前的异常</p>
</li>
<li><h4 id="声明式捕获-将collect的主要逻辑放到onEach中，保证onEach在catch之前"><a href="#声明式捕获-将collect的主要逻辑放到onEach中，保证onEach在catch之前" class="headerlink" title="声明式捕获 将collect的主要逻辑放到onEach中，保证onEach在catch之前"></a>声明式捕获 将collect的主要逻辑放到onEach中，保证onEach在catch之前</h4></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">foo()</span><br><span class="line">    .onEach &#123; value -&gt;</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected value&quot;</span> &#125;                 </span><br><span class="line">        println(value) </span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="keyword">catch</span> &#123; e -&gt; println(<span class="string">&quot;Caught e&quot;</span>) &#125;</span><br><span class="line">    .collect()</span><br></pre></td></tr></table></figure>

<h1 id="流完成"><a href="#流完成" class="headerlink" title="流完成"></a>流完成</h1><ol>
<li><p><code>try</code>&#x2F;<code>finally</code> </p>
</li>
<li><p><code>onCompletion()</code></p>
</li>
</ol>
   <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">foo()</span><br><span class="line">    .onCompletion &#123; println(<span class="string">&quot;Done&quot;</span>) &#125;</span><br><span class="line">    .collect &#123; value -&gt; println(value) &#125;</span><br></pre></td></tr></table></figure>

<p>   而且他还可以判断是否是异常退出。但是只是判断，并不会处理、拦截异常，并且只能处理上游的异常。</p>
   <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">foo()</span><br><span class="line">    .onCompletion &#123; cause -&gt; <span class="keyword">if</span> (cause != <span class="literal">null</span>) println(<span class="string">&quot;Flow completed exceptionally&quot;</span>) &#125;</span><br><span class="line">    .<span class="keyword">catch</span> &#123; cause -&gt; println(<span class="string">&quot;Caught exception&quot;</span>) &#125;</span><br><span class="line">    .collect &#123; value -&gt; println(value) &#125;</span><br></pre></td></tr></table></figure>



<h1 id="launchIn-this-与collect"><a href="#launchIn-this-与collect" class="headerlink" title="launchIn(this) 与collect"></a>launchIn(this) 与collect</h1><p><code>collect</code>后的代码只有在collect执行完后才能执行，而<code>launchIn</code>可以指定其在单独的协程程序中启动流的集合，从而不会阻塞当前协程。</p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p> <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html">Channel</a>  类似于BlockingQueue。但他的操作是挂起的。<br> Channel提供了在协程之间传递多个值的方法 </p>
<p><code>send</code> 发送 缓存区已满或不存在时调用方会被挂起</p>
<p><code>channel.receive()</code> 接收</p>
<p><code>channel.close()</code> 关闭通道，表示没有更多的元素进入通道</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html"><code>CoroutineScope.produce</code></a>  Launches new coroutine to produce a stream of values by sending them to a channel and returns a reference to the coroutine as a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/index.html">ReceiveChannel</a>. This resulting object can be used to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html">receive</a> elements produced by this coroutine. 在新的协程中生产并返回了一个<code>ReceiveChannel&lt;T&gt;</code>对象。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html"><code>ReceiveChannel&lt;E&gt;.consumeEach</code></a> 遍历ReceiveChannel的item执行指定action，并在块执行完毕后消耗掉这个ReceiveChannel（调用cancel()）。</p>
<p> <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/index.html">ReceiveChannel</a>.<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html">cancel()</a> 取消接收来自这个通道的剩余元素，关闭通道并从中删除所有缓存的元素。</p>
<p><code>tickerChannel</code> 定时返回<code>Unit</code>的<code>channel</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tickerChannel = ticker(delayMillis = <span class="number">1000</span>, initialDelayMillis = <span class="number">0</span>) <span class="comment">// 创建计时器通道</span></span><br><span class="line"></span><br><span class="line">repeat(<span class="number">10</span>) &#123;</span><br><span class="line">    println(tickerChannel.receive())<span class="comment">// 每隔1s会打印一个kotlin.Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tickerChannel.cancel() <span class="comment">// 表明不再需要更多的元素</span></span><br></pre></td></tr></table></figure>

<h1 id="Flow-x2F-Channel-x2F-Sequence的区别"><a href="#Flow-x2F-Channel-x2F-Sequence的区别" class="headerlink" title="Flow&#x2F;Channel&#x2F;Sequence的区别"></a>Flow&#x2F;Channel&#x2F;Sequence的区别</h1><p><code>Flow</code>是用来异步返回多个值，其内部操作可以挂起</p>
<p><code>Channel</code> 用来在协程之间传递多个值（transfer a stream of values）</p>
<p><code>Sequence</code> 用来逐个在item中延迟执行完整操作，相比于<code>list</code>等整体执行完毕才进行下一级操作的“弓”字型，<code>Sequence</code>多级操作是逐个item依次完整执行多级操作的“几”字型。</p>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道指：1.一个协程在流中开始生产无穷多个元素 2.另一个或多个协程消费这些流</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = produceNumbers() <span class="comment">// 从 1 开始生产整数</span></span><br><span class="line">    <span class="keyword">val</span> squares = square(numbers) <span class="comment">// 对整数做平方</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) println(squares.receive()) <span class="comment">// 打印前 5 个数字</span></span><br><span class="line">    println(<span class="string">&quot;Done!&quot;</span>) <span class="comment">// 我们的操作已经结束了</span></span><br><span class="line">    coroutineContext.cancelChildren() <span class="comment">// 取消子协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">produceNumbers</span><span class="params">()</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) send(x++) <span class="comment">// 从 1 开始的无限的整数流</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">square</span><span class="params">(numbers: <span class="type">ReceiveChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span>: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = produce &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> numbers) send(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有缓冲的通道： 如果发送先被调用，则它将被挂起直到接收被调用， 如果接收先被调用，它将被挂起直到发送被调用。 </p>
<p>带缓冲的通道： <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel.html">Channel()</a> 工厂函数与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a> 建造器通过一个可选的参数 <code>capacity</code> 来指定 <em>缓冲区大小</em> 。缓冲允许发送者在被挂起前发送多个元素， 就像 <code>BlockingQueue</code> 有指定的容量一样，当缓冲区被占满的时候将会引起阻塞。 </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">4</span>) <span class="comment">// 启动带缓冲的通道</span></span><br></pre></td></tr></table></figure>



<p> 发送和接收操作是 <em>公平的</em> 并且尊重调用它们的多个协程。它们遵守先进先出原则。</p>
<p> 计时器通道是一种特别的会合通道，每次经过特定的延迟都会从该通道进行消费并产生 <code>Unit</code> 。如果在间隔还没到的时候调用<code>tickerChannel.receive()</code>则会返回<code>null</code>。产生的间隔由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-ticker-mode/index.html"><code>TickerModel</code></a>控制</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tickerChannel =  ticker(delayMillis = <span class="number">100</span>, initialDelayMillis = <span class="number">0</span>,mode = TickerMode.FIXED_PERIOD) <span class="comment">//创建计时器通道 mode默认为TickerMode.FIXED_PERIOD</span></span><br><span class="line"> tickerChannel.receive() <span class="comment">//第一次调用立马返回Unit</span></span><br></pre></td></tr></table></figure>



<p><code>coroutineContext.cancelChildren()</code> &#x2F;&#x2F; 取消所有的子协程来让主协程结束</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h2><p> 协程构建器有两种风格：自动的传播异常（<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 以及 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html">actor</a>） 或者将它们暴露给用户（<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 以及 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a>）。 前者对待异常是不处理的，类似于 Java 的 <code>Thread.uncaughtExceptionHandler</code>， 而后者依赖用户来最终消耗异常，比如说，通过 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a> 或 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html">receive</a>  </p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html">CoroutineExceptionHandler</a> 仅在预计不会由用户处理的异常上调用， 所以在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 构建器中注册它没有任何效果。</p>
<p> 协程内部使用 <code>CancellationException</code> 来进行取消，这个异常会被所有的处理者忽略，所以那些可以被 <code>catch</code> 代码块捕获的异常仅仅应该被用来作为额外调试信息的资源。 </p>
<p> 如果协程遇到除 <code>CancellationException</code> 以外的异常，它将取消具有该异常的父协程。 这种行为不能被覆盖，且它被用来提供一个稳定的协程层次结构来进行<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/composing-suspending-functions.md#structured-concurrency-with-async">结构化并发</a>而无需依赖 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html">CoroutineExceptionHandler</a> 的实现。 且当所有的子协程被终止的时候，原本的异常被父协程所处理。 </p>
<p>应该将<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html">CoroutineExceptionHandler</a> 总是被设置在由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a> 启动的协程中。将异常处理者设置在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 主作用域内启动的协程中是没有意义的，尽管子协程已经设置了异常处理者， 但是主协程也总是会被取消的。 </p>
<p>异常被抛出后，所有同级的子协程都会被关闭，然后异常传递给父协程，直到异常被处理。</p>
<p> 一个协程的多个子协程抛出异常将会发生什么？ 通常的规则是“第一个异常赢得了胜利“。</p>
<h2 id="监督"><a href="#监督" class="headerlink" title="监督"></a>监督</h2><p>普通的取消 是一种双向机制，在协程的整个层次结构之间传播。 </p>
<p> SupervisorJob  它类似于常规的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job.html">Job</a>， 但他的取消只会向下传播 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val supervisor = SupervisorJob()with(CoroutineScope(coroutineContext + supervisor)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">supervisor取消的话，会取消掉所有子协程</span><br></pre></td></tr></table></figure>

<h4 id="监督作业"><a href="#监督作业" class="headerlink" title="监督作业"></a>监督作业</h4><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html">SupervisorJob</a> 可以被用于这些目的。它类似于常规的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job.html">Job</a>，唯一的不同是：SupervisorJob 的取消只会向下传播。这是非常容易从示例中观察到的：</p>
<h4 id="监督作用域"><a href="#监督作用域" class="headerlink" title="监督作用域"></a>监督作用域</h4><p>对于<em>作用域</em>的并发，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html">supervisorScope</a> 可以被用来替代 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 来实现相同的目的。它只会单向的传播并且当子作业自身执行失败的时候将它们全部取消。它也会在所有的子作业执行结束前等待， 就像 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 所做的那样。</p>
<h4 id="监督协程中的异常"><a href="#监督协程中的异常" class="headerlink" title="监督协程中的异常"></a>监督协程中的异常</h4><p>常规的作业和监督作业之间的另一个重要区别是异常处理。 每一个子作业应该通过异常处理机制处理自身的异常。 这种差异来自于子作业的执行失败不会传播给它的父作业的事实。</p>
<h2 id="协程的线程安全"><a href="#协程的线程安全" class="headerlink" title="协程的线程安全"></a>协程的线程安全</h2><ol>
<li><p>使用线程安全的数据结构</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = AtomicInteger()</span><br><span class="line"> withContext(Dispatchers.Default) &#123;</span><br><span class="line">        counter.incrementAndGet()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>以细粒度限制线程</p>
</li>
<li><p>以粗粒度限制线程</p>
<p>2、3都是保证将对共享变量的操作限制在同一个线程中，从而保证线程安全。</p>
</li>
<li><p>互斥</p>
<p>类似于线程的锁，协程的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html">Mutex</a> 的lock和unlock方法可以保证同一时间只有一个协程访问指定代码。Mutex不会阻塞线程。</p>
</li>
<li><p>Actors</p>
<p> 一个 <a href="https://en.wikipedia.org/wiki/Actor_model">actor</a> 是由协程、 被限制并封装到该协程中的状态以及一个与其它协程通信的 <em>通道</em> 组合而成的一个实体。 </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个函数启动一个新的计数器 actor</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">counterActor</span><span class="params">()</span></span> = actor&lt;CounterMsg&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">// actor 状态</span></span><br><span class="line">    <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123; <span class="comment">// 即将到来消息的迭代器</span></span><br><span class="line">        <span class="keyword">when</span> (msg) &#123;</span><br><span class="line">            <span class="keyword">is</span> IncCounter -&gt; counter++</span><br><span class="line">            <span class="keyword">is</span> GetCounter -&gt; msg.response.complete(counter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.要递增状态时</span></span><br><span class="line">counter.send(IncCounter)</span><br><span class="line"><span class="comment">//2.要获取当前状态时</span></span><br><span class="line"><span class="comment">// 发送一条消息以用来从一个 actor 中获取计数值</span></span><br><span class="line"><span class="keyword">val</span> response = CompletableDeferred&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">counter.send(GetCounter(response))</span><br><span class="line">println(<span class="string">&quot;Counter = <span class="subst">$&#123;response.await()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>  <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html">CompletableDeferred</a> 通信原语表示未来可知（可传达）的单个值 。</p>
<p>在使用时，由于actor 是一个协程，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html"><code> SendChannel .send()</code></a> 方法会在通道缓存满的时候挂起调用方，从而最终保证了<code>counter++</code>方法是依次执行的，不会产生并发问题。</p>
<p>actor 在高负载下比锁更有效，因为在这种情况下它总是有工作要做，而且根本不需要切换到不同的上下文。</p>
</li>
</ol>
<blockquote>
<p> 注意，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html">actor</a> 协程构建器是一个双重的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a> 协程构建器。一个 actor 与它接收消息的通道相关联，而一个 producer 与它发送元素的通道相关联。 </p>
</blockquote>
<h1 id="Select表达式"><a href="#Select表达式" class="headerlink" title="Select表达式"></a>Select表达式</h1><p>  <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html">select</a> 表达式允许我们使用其 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html">onReceive</a> 子句 <em>同时</em> 从两个生产者接收数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">selectFizzBuzz</span><span class="params">(fizz: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;, buzz: <span class="type">ReceiveChannel</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    select&lt;<span class="built_in">Unit</span>&gt; &#123; <span class="comment">// &lt;Unit&gt; 意味着该 select 表达式不返回任何结果</span></span><br><span class="line">        fizz.onReceive &#123; value -&gt;  <span class="comment">// 这是第一个 select 子句</span></span><br><span class="line">            println(<span class="string">&quot;fizz -&gt; &#x27;<span class="variable">$value</span>&#x27;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        buzz.onReceive &#123; value -&gt;  <span class="comment">// 这是第二个 select 子句</span></span><br><span class="line">            println(<span class="string">&quot;buzz -&gt; &#x27;<span class="variable">$value</span>&#x27;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html">onReceiveOrNull</a>  可以允许为空，这样可以在关闭通道时执行特定操作 </p>
<p> <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/on-send.html">onSend</a> 子句 发送消息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">produceNumbers</span><span class="params">(side: <span class="type">SendChannel</span>&lt;<span class="type">Int</span>&gt;)</span></span> = produce&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123; <span class="comment">// 生产从 1 到 10 的 10 个数值</span></span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 延迟 100 毫秒</span></span><br><span class="line">        select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">            onSend(num) &#123;&#125; <span class="comment">// 发送到主通道</span></span><br><span class="line">            side.onSend(num) &#123;&#125; <span class="comment">// 或者发送到 side 通道</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Select延迟值可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html">onAwait</a> 子句查询 </p>
<iframe width='853' height='480' src='https://embed.coggle.it/diagram/Xb_CZoumpCamgUAj/1235701ea5f157867e045f0f5ac28f886effdb5fa1e27b72afa5266e6e3e8891' frameborder='0' allowfullscreen></iframe>






<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/u013064109/article/details/83507076">Kotlin的独门秘籍Reified实化类型参数(下篇)</a></p>
<p><a href="https://www.kotlincn.net/docs/reference/coroutines/flow.html">Kotlin 协程 中文官网–异步流</a></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin笔记之Flow</title>
    <url>/blog/posts/10414aef/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Flow</code>是Kotlin协程库中的库，用于<strong>异步返回多个值</strong>，官方介绍是参考<code>RxJava</code>等响应式流实现的，但是“<em>拥有尽可能简单的设计， 对 Kotlin 以及挂起友好且遵从结构化并发</em>”。本文主要参考<a href="https://www.kotlincn.net/docs/reference/coroutines/flow.html">Flow中文文档</a>，梳理了学习过程中的要点和理解，以便日后查验。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>对于异步返回多个值的需求，集合（如<code>List</code>等）只能一次性返回多个值，而序列（ <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html"><code>Sequence</code></a> ）只支持阻塞代码，<code>Flow</code>则支持挂起函数异步返回多个值。</p>
<h2 id="创建Flow"><a href="#创建Flow" class="headerlink" title="创建Flow"></a>创建Flow</h2><ol>
<li><p><code>flow&#123;...&#125;</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒，也可以用Thread.sleep()但是会阻塞当前线程</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.asFlow()</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = (<span class="number">1.</span><span class="number">.10</span>).asFlow()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flowOf&#123;&#125;</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>因为<strong>流只会在被收集的时候才会被启动</strong>（指执行类似<code>flow&#123;...&#125;</code>中的内容），所以上述<code>simple()</code>在被调用时会尽快返回且不等待，所以无需<code>suspend</code>修饰。</p>
<h2 id="流的收集-x2F-末端流操作符"><a href="#流的收集-x2F-末端流操作符" class="headerlink" title="流的收集&#x2F;末端流操作符"></a>流的收集&#x2F;末端流操作符</h2><ul>
<li><p><code>collect&#123;...&#125;</code> 收集<code>emit</code>发送的值</p>
<p>配合<code>onEach&#123;&#125;</code>可以将<code>collect</code>中执行的代码放到<code>onEach</code>中。</p>
</li>
<li><p><code>collectLatest&#123;...&#125;</code> 收集<code>emit</code>发送的值，但每次新的<code>emit</code>到来时，取消之前的收集器，创建新的收集器（用新的值执行<code>&#123;...&#125;</code>中的代码）</p>
</li>
<li><p><code>launchIn</code> 指定在单独的协程中启动流的收集，这样就可以立即继续进一步执行代码，不会挂起后面的协程代码。</p>
</li>
<li><p><code>single()</code> 只接受flow发送的一个值，0个或多个都会报错</p>
</li>
<li><p><code>first&#123;...&#125;</code> 查找符合条件的第一个值</p>
</li>
<li><p><code>reduce()</code> 求和</p>
</li>
<li><p><code>fold(initial,&#123;...&#125;)</code> 在初始值<code>initial</code>的基础上求和</p>
</li>
<li><p><code>toList</code>、<code>toSet</code></p>
</li>
</ul>
<h2 id="过渡流操作符"><a href="#过渡流操作符" class="headerlink" title="过渡流操作符"></a>过渡流操作符</h2><p>过渡操作符应用于上游流，并返回下游流。就像流一样。这类操作符本身不是挂起函数。它运行的速度很快，返回新的转换流的定义。</p>
<ul>
<li><code>map&#123;&#125;</code></li>
<li><code>filter&#123;&#125;</code></li>
<li><code>take(n)</code> 限长操作符，只取前n个发射的值</li>
</ul>
<h2 id="流上下文"><a href="#流上下文" class="headerlink" title="流上下文"></a>流上下文</h2><p>流默认运行在收集器提供的上下文中，但是可以通过<code>flowOn </code>更改：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 在流构建器中改变消耗 CPU 代码上下文的正确方式</span></span><br></pre></td></tr></table></figure>

<h2 id="展平流"><a href="#展平流" class="headerlink" title="展平流"></a>展平流</h2><p>将嵌套有<code>Flow</code>的<code>Flow</code>（如<code>Flow&lt;Flow&lt;String&gt;&gt;</code>）<strong>展平</strong>为单个流（如<code>Flow&lt;String&gt;</code>）。</p>
<ul>
<li><p><code>flatMapConcat</code> 将收集到的流交给<code>&#123;...&#125;</code>处理后，等待内部流处理完毕后，再去请求下一个流</p>
</li>
<li><p><code>flatMapMerge</code> 先顺序收集所有流，再同时收集结果流</p>
</li>
<li><p><code>flatMapLatest&#123;...&#125;</code> 类似于<code>collectLatest&#123;...&#125;</code>，在新流发出的时候，立即取消<code>&#123;...&#125;</code>中所有的代码</p>
</li>
<li><p><code>flattenConcat</code> 依次展平流</p>
</li>
<li><p><code>flattenMerge&#123;...&#125;</code> 并发拼接，先执行<code>&#123;...&#125;</code>中的方法，再执行<code>collect</code>等方法，顺序会乱。</p>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p><code>try/catch</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        simple().collect &#123; value -&gt;         </span><br><span class="line">            println(value)</span><br><span class="line">            check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>catch()</code></p>
<p><strong>透明捕获</strong>：只捕获上游异常，其之后的异常不会被处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">simple()</span><br><span class="line">    .<span class="keyword">catch</span> &#123; e -&gt; emit(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>) &#125; <span class="comment">// 发射一个异常</span></span><br><span class="line">    .collect &#123; </span><br><span class="line">        value -&gt; println(value) <span class="comment">//此处如有异常，不会被catch捕获</span></span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明式捕获</strong>：将<code>collect</code>的代码移动到<code>onEach</code>中，将其放到<code>catch</code>之前，从而使其被<code>catch</code>捕获。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">simple()</span><br><span class="line">    .onEach &#123; value -&gt;</span><br><span class="line">        check(value &lt;= <span class="number">1</span>) &#123; <span class="string">&quot;Collected <span class="variable">$value</span>&quot;</span> &#125; <span class="comment">//此处异常会被catch捕获             </span></span><br><span class="line">        println(value) </span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="keyword">catch</span> &#123; e -&gt; println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>) &#125;</span><br><span class="line">    .collect()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流取消"><a href="#流取消" class="headerlink" title="流取消"></a>流取消</h2><ul>
<li><code>flow &#123; ... &#125;</code> 创建的流的繁忙循环默认可以取消</li>
<li>其他流如果需要取消，可以添加 <code>.onEach &#123; currentCoroutineContext().ensureActive() &#125;</code> 或者<code>.cancellable()</code></li>
</ul>
<h2 id="流完成"><a href="#流完成" class="headerlink" title="流完成"></a>流完成</h2><ul>
<li><p>命令式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       simple().collect &#123; value -&gt; println(value) &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       println(<span class="string">&quot;Done&quot;</span>) <span class="comment">//监听流完成</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">simple()</span><br><span class="line">    .onCompletion &#123; println(<span class="string">&quot;Done&quot;</span>) &#125; <span class="comment">//监听流完成，在collect执行结束后才执行</span></span><br><span class="line">    .collect &#123; value -&gt; println(value) &#125;</span><br></pre></td></tr></table></figure>

<p><code>onCompletion</code>的可空参数 <code>Throwable</code> 可以用于确定流收集是正常完成（为<code>null</code>）还是有异常发生。他不会处理异常。</p>
</li>
</ul>
<h2 id="其余操作"><a href="#其余操作" class="headerlink" title="其余操作"></a>其余操作</h2><ul>
<li><p><code>buffer()</code> 缓冲发射项，收集完成后再传给下一步</p>
</li>
<li><p><code>conflate()</code> 合并发射项，会丢弃来不及处理的中间值，只获取并处理最新的值</p>
</li>
<li><p><code>zip()</code> 合并两个流的值,两个流中的值一一对应</p>
<p>例如<code>(1,2,3) 3s发射一次,(a,b,c) 4s发射一次</code>直接拼接，合并之后为 <code>(1a,2b,3c)</code></p>
</li>
<li><p><code>combine()</code> 结合两个流的值，任意一个流中的值发生变化都会触发执行计算</p>
<p>例如<code>(1,2,3) 3s发射一次,(a,b,c) 4s发射一次</code>直接拼接，合并之后为 <code>(1a,2a,2b,3b,3c)</code></p>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.kotlincn.net/docs/reference/coroutines/flow.html">Kotlin Flow 中文文档</a></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式在kotlin中的应用</title>
    <url>/blog/posts/53875104/</url>
    <content><![CDATA[<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p><strong>普通写法</strong>：</p>
<ol>
<li>定义一个接口OnClickListener</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义方法SetOnClickListener</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnCLickListener</span><span class="params">(listener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义的方法和Java中写法类似，在使用该方法时也类似：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testInterface = TestInterface()</span><br><span class="line"></span><br><span class="line">testInterface.setOnCLickListener(<span class="keyword">object</span> : TestInterface.ClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">            TODO(<span class="string">&quot;not implemented&quot;</span>) <span class="comment">//To change body of created functions use File | Settings | File Templates.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>lambda写法</strong>：</p>
<p>定义只需要一步：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在初始化的时初始化listener</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span></span>(<span class="keyword">var</span> listener : (uri:String) -&gt; <span class="built_in">Unit</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者直接定义这个变量</span></span><br><span class="line">listener:((uri : String)-&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在需要用到方法时，listener的方法，比如onClickListener()&#123;&#125;</span></span><br><span class="line">listener.invoke(agrs)</span><br></pre></td></tr></table></figure>

<p>使用起来也更加简洁：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = TestInterface&#123; uri: String -&gt; print(uri) &#125;<span class="comment">//获取对象的同时初始化listener</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法最后一个参数是lambda表达式时，lambda表达式的方法<code>&#123;&#125;</code>可以放到<code>()</code>的后面，如果只有这一个参数时，<code>()</code>也可以省略</p>
</blockquote>
<p>当方法只有一个参数时，可以省略参数，还用<code>it</code>代替：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">testInterface.setNewOnClickListener &#123; print(it) &#125;</span><br></pre></td></tr></table></figure>

<p>甚至更加简洁，如果要执行的方法和listener定义的方法返回值类型相同，可以直接引用该方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">testInterface.setNewOnClickListener(::print)</span><br></pre></td></tr></table></figure>



<h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><p>lambda在Java8中引进，可以很好的替代匿名内部类，使代码更加简洁。</p>
<p>lambda表达式形式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>lambda 表达式总是被大括号括着， 完整语法形式的参数声明放在大括号内，并有可选的类型标注， 函数体跟在一个 <code>-&gt;</code> 符号之后。如果推断出的该 lambda 的返回类型不是 <code>Unit</code>，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。</p>
<p>kotlincn.net <a href="http://www.kotlincn.net/docs/reference/lambdas.html#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">高阶函数和lambda表达式</a></p>
</blockquote>
<p>使用lambda的形式如下<code>() -&gt; &#123;&#125;</code>,<code>()</code>内是参数，<code>&#123;&#125;</code>是函数具体的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java 8方式：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>( () -&gt; System.out.println(<span class="string">&quot;In Java8, Lambda expression rocks !!&quot;</span>) ).start();</span><br></pre></td></tr></table></figure>

<p>这个例子来自importNew.com,<a href="http://www.importnew.com/16436.html">Java8 lambda表达式10个示例</a></p>
<h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><ul>
<li>xx.map()</li>
</ul>
<p>凡是<strong>可迭代</strong>的数据都可以使用<code>map()</code>函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> args: Array&lt;String&gt; = arrayOf()</span><br><span class="line">args.map &#123;</span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以更简洁：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">args.map(::print)</span><br><span class="line"><span class="comment">//::print表示引用该方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>xx.flatMap()</li>
</ul>
<p>返回<strong>可迭代</strong>的数组，可以和<code>xx.map()</code>一起使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">args.flatMap &#123;</span><br><span class="line">    it.split(<span class="string">&quot; &quot;</span>) <span class="comment">//把字符串按照&quot; &quot;切割</span></span><br><span class="line">&#125;.map&#123; </span><br><span class="line">    print(<span class="string">&quot;<span class="subst">$&#123;it.toUpperCase()&#125;</span>&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode笔记--重建二叉树</title>
    <url>/blog/posts/a64dc0bc/</url>
    <content><![CDATA[<p>二叉树的遍历根据根节点与左右子节点的遍历顺序的不同分为三种：</p>
<ul>
<li><p>前序遍历</p>
<p>根左右：先遍历根节点，再左子树，再右子树（先从根节点开始，记录左节点直到没有）</p>
<p>第一个为根节点</p>
</li>
<li><p>中序遍历</p>
<p>左根右：先左子树，再根子树，再右子树（从树的最左边的节点开始遍历）</p>
</li>
<li><p>后序遍历</p>
<p>左右根：先左子树，后右子树，再根节点</p>
<p>最后一个为根节点</p>
</li>
</ul>
<p>在遍历的时候，当父节点只有一个子节点时，依然要遵循以上三种遍历的先后顺序（没有该子节点则不写内容），以保证某一侧的子树（“左边的子树”或“右边的子树”）所有节点都被完全遍历，之后才可以根据遍历的规则切换到下一子树。</p>
<p>如如下子树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      G</span><br><span class="line">   /     \</span><br><span class="line">  D       M</span><br><span class="line"> / \     / \</span><br><span class="line">A   F   H   Z</span><br><span class="line">   /</span><br><span class="line">  E</span><br></pre></td></tr></table></figure>
<p>前序遍历：GDAFEMHZ</p>
<p>中序遍历：ADEFGHMZ</p>
<p>后续遍历：AEFDHZMG</p>
<h1 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h1><p>一般都是给定中序排序，再加上一个前序排序、后续排序来逆向生成二叉树。</p>
<p>根据之前的知识，此类题的解答思路一般为：</p>
<p>先根据前序排序、后续排序的特点，找到根节点，之后再根据找到的根节点将中序排序分为左、右子树两个部分。这样循环直到整个树的每个节点都被遍历完毕，完整的二叉树也会被建立起来。</p>
<p>我们以下面这个二叉树为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure>

<p>使用代码表示如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> preorder = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)<span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">val</span> inorder  = intArrayOf(<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>)<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">val</span> tree = buildTree(preorder, inorder)</span><br><span class="line">    print(tree)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildTree</span><span class="params">(preorder: <span class="type">IntArray</span>, inorder: <span class="type">IntArray</span>)</span></span>: TreeNode? &#123;</span><br><span class="line">    <span class="keyword">var</span> tree : TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (preorder.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> root = preorder[<span class="number">0</span>]<span class="comment">//获取根节点</span></span><br><span class="line">        <span class="keyword">val</span> indexOfRoot = inorder.indexOf(root)<span class="comment">//获取中序排序中根节点的坐标</span></span><br><span class="line">        tree = TreeNode(root)</span><br><span class="line">        <span class="comment">//根据根节点坐标，将二叉树分为左、右两个子树</span></span><br><span class="line">        <span class="keyword">val</span> leftTree = inorder.copyOfRange(<span class="number">0</span>, indexOfRoot)</span><br><span class="line">        <span class="keyword">val</span> rightTree = inorder.copyOfRange(indexOfRoot + <span class="number">1</span>, inorder.size)</span><br><span class="line">        <span class="comment">//将前序排序也分为左右两个子树的前序排序</span></span><br><span class="line">        <span class="keyword">val</span> leftPreOrder = preorder.copyOfRange(<span class="number">1</span>, preorder.size).filter &#123; leftTree.contains(it) &#125;.toIntArray()</span><br><span class="line">        <span class="keyword">val</span> rightPreOrder = preorder.copyOfRange(<span class="number">1</span>, preorder.size).filter &#123; rightTree.contains(it) &#125;.toIntArray()</span><br><span class="line">        <span class="comment">//再次分别循环分析左右两个子树的结构</span></span><br><span class="line">        tree.left = buildTree(leftPreOrder, leftTree)</span><br><span class="line">        tree.right = buildTree(rightPreOrder, rightTree)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>(<span class="keyword">var</span> `<span class="keyword">val</span>`: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left: TreeNode? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> right: TreeNode? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/9e8922486154">https://www.jianshu.com/p/9e8922486154</a></p>
<p><a href="https://charlesliuyx.github.io/2018/10/22/[%E7%9B%B4%E8%A7%82%E7%AE%97%E6%B3%95]%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">【直观算法】二叉树遍历算法总结</a></p>
<p><a href="https://jingyan.baidu.com/album/cdddd41cb8d79753ca00e144.html?picindex=1">知道中序和后序遍历，画二叉树和写出前序遍历 </a></p>
<p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">leetcode-重建二叉树</a></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下配置Git，使用AndroidStudio同步工程到Github</title>
    <url>/blog/posts/25db0a11/</url>
    <content><![CDATA[<p>这篇文章介绍了如何在 linux 环境下安装和配置 git 与 github ，并且使用 Android Studio 将本地的项目同步到 github 上面。</p>
<h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-gat install git</span><br></pre></td></tr></table></figure>

<h1 id="配置-git-和-github"><a href="#配置-git-和-github" class="headerlink" title="配置 git 和 github"></a>配置 git 和 github</h1><ul>
<li><p>创建 Github 账号</p>
</li>
<li><p>生成 ssh key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@youremail.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 github 上面添加 ssh key</p>
</li>
</ul>
<p>进入 Account Settings –&gt; SSH Keys –&gt; Add SSH Key 添加 SSH Keys ：<br>名字起一个容易识别的名字，key 是生成的 <code>/home/username/.ssh/id_rsa.pub.</code> 中的内容，直接粘贴到指定位置就行</p>
<ul>
<li><p>测试 ssh key 是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li>
</ul>
<p>提示如<code>You’ve successfully authenticated, but GitHub does not provide shell access</code>则说明成功连接 github</p>
<ul>
<li><p>配置 Github</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot; //配置用户名</span><br><span class="line">git config --global user.email &quot;your email&quot; //配置email</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="用-Android-Studio-同步工程到-Github"><a href="#用-Android-Studio-同步工程到-Github" class="headerlink" title="用 Android Studio 同步工程到 Github"></a>用 Android Studio 同步工程到 Github</h1><ul>
<li><p>启动android studio</p>
<p>进入<code>android studio/bin</code>，终端输入<code>./studio.sh</code></p>
</li>
<li><p>选择 <code>VCS ---&gt; Import into Version Control --&gt; Share Project on Github</code></p>
</li>
</ul>
<p>第一次进入会要求输入 github 的账号和密码 按照要求输入即可<br>此后还会要求你输入一个本地密码，当下次同步的时候需要输入<br>之后就进入到选择同步的仓库，新建一个仓库，开始同步就可以了</p>
<p><strong>到这里就顺利的在 Android Studio 上面将工程同步到 Github 上面了</strong></p>
<hr>
<p><strong>以下为原文提到的其他方法，摘录如下，以备后用：</strong></p>
<h1 id="利用Git从本地上传到GitHub"><a href="#利用Git从本地上传到GitHub" class="headerlink" title="利用Git从本地上传到GitHub"></a>利用Git从本地上传到GitHub</h1><p>第一步： 进入要所要上传文件的目录</p>
<p>输入命令 <code>git init</code></p>
<p>第二步： 创建一个本地仓库 origin</p>
<p>使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:yourName/yourRepo.git</span><br></pre></td></tr></table></figure>

<p><code>youname</code>是你的GitHub的用户名，<code>yourRepo</code>是你要上传到GitHub的仓库</p>
<p>第三步： 比如你要添加一个文件xxx到本地仓库，使用命令 <code>git add xxx</code>，可以使用 <code>git add .</code> 自动判断添加哪些文件</p>
<p>然后把这个添加提交到本地的仓库，使用命令 <code>git commit -m</code>说明这次的提交</p>
<p>最后把本地仓库origin提交到远程的GitHub仓库，使用命令 <code>git push origin master</code></p>
<h1 id="从GitHub克隆项目到本地"><a href="#从GitHub克隆项目到本地" class="headerlink" title="从GitHub克隆项目到本地"></a>从GitHub克隆项目到本地</h1><p>第一步： 到GitHub的某个仓库，然后复制右边的有个<code>HTTPS clone url</code></p>
<p>第二步： 回到要存放的目录下，使用命令 <code>git clone https://github.com/chenguolin/scrapy.git</code>，这里的url只是一个例子</p>
<p>第三步： 如果本地的版本不是最新的，可以使用命令 <code>git fetch origin</code>，origin是本地仓库</p>
<p>第四步： 把更新的内容合并到本地分支，可以使用命令 <code>git merge origin/master</code></p>
<p>如果你不想手动去合并，那么你可以使用：<br><code>git pull &lt;本地仓库&gt; master</code> &#x2F;&#x2F; 这个命令可以拉去最新版本并自动合并</p>
<h1 id="GitHub的分支管理"><a href="#GitHub的分支管理" class="headerlink" title="GitHub的分支管理"></a>GitHub的分支管理</h1><ul>
<li>创建</li>
</ul>
<p>1 创建一个本地分支： <code>git branch &lt;新分支名字&gt;</code></p>
<p>2 将本地分支同步到GitHub上面： <code>git push &lt;本地仓库名&gt; &lt;新分支名&gt;</code></p>
<p>3 切换到新建立的分支： <code>git checkout &lt;新分支名&gt;</code></p>
<p>4 为你的分支加入一个新的远程端： <code>git remote add &lt;远程端名字&gt; &lt;地址&gt;</code></p>
<p>5 查看当前仓库有几个分支: <code>git branch</code></p>
<ul>
<li>删除</li>
</ul>
<p>1 从本地删除一个分支： <code>git branch -d &lt;分支名称&gt;</code></p>
<p>2 同步到GitHub上面删除这个分支： <code>git push &lt;本地仓库名&gt; :&lt;GitHub端分支&gt;</code></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这篇文章是我今天在 linux 下安装 git ，上传工程到 github 上面时的步骤的总结，大部分内容都参考&#x2F;摘录自下面这篇文章，感谢原作者的分享，原文信息及链接如下：</p>
<blockquote>
<p>Linux下Git和GitHub使用方法总结<br>[日期：2014-03-07] 来源：Linux社区 作者：chenguolin<br><a href="http://www.linuxidc.com/Linux/2014-03/97821.htm">http://www.linuxidc.com/Linux/2014-03/97821.htm</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Linux下配置JDK和AndroidStudio开发环境</title>
    <url>/blog/posts/ca532ade/</url>
    <content><![CDATA[<h1 id="下载-JDK-并解压"><a href="#下载-JDK-并解压" class="headerlink" title="下载 JDK 并解压"></a>下载 JDK 并解压</h1><ul>
<li>到官网下载 jdk</li>
<li>下载到的 JDK 文件解压</li>
</ul>
<h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>管理员权限进入 etc&#x2F;environment 写入以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=&quot;JDK主目录的绝对路径&quot;</span><br></pre></td></tr></table></figure>

<h1 id="配置-alternatives"><a href="#配置-alternatives" class="headerlink" title="配置 alternatives"></a>配置 alternatives</h1><p>打开终端执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install  /usr/bin/java java  JDK主目录的绝对路径/bin/java 300</span><br><span class="line"></span><br><span class="line">sudo update-alternatives --install  /usr/bin/javac javac  JDK主目录的绝对路径/bin/javac 300</span><br></pre></td></tr></table></figure>

<p>到这里 JDK 的环境就配置好了</p>
<h1 id="运行-Android-Studio"><a href="#运行-Android-Studio" class="headerlink" title="运行 Android Studio"></a>运行 Android Studio</h1><p>进入 android studio&#x2F;bin 目录下，打开终端，</p>
<p>输入 <code>./studio.sh</code></p>
<p>到这里，就可以正常运行 android studio 了</p>
]]></content>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/blog/posts/d0edc1ed/</url>
    <content><![CDATA[<h1 id="复制，删除，移动"><a href="#复制，删除，移动" class="headerlink" title="复制，删除，移动"></a>复制，删除，移动</h1><p><code>cp</code>拷贝，<code>rm</code>删除，<code>mv</code>移动。</p>
<p><code>-r</code>表示递归 <code>-f</code>强制，无提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [-r] fromFilePath toFilePath</span><br><span class="line"><span class="built_in">rm</span> [-r] fromFilePath toFilePath</span><br><span class="line"><span class="built_in">mv</span> [-r] fromFilePath toFilePath</span><br></pre></td></tr></table></figure>

<h1 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> - 返回上次所在目录</span><br><span class="line"><span class="built_in">cd</span> ~ 切换到当前用户home路径下</span><br><span class="line"><span class="built_in">cd</span> . 当前路径</span><br><span class="line"><span class="built_in">cd</span> .. 上层路径</span><br><span class="line"><span class="built_in">cd</span> ../linux 切换到同一级的linux目录</span><br></pre></td></tr></table></figure>

<h1 id="新建文件、文件夹"><a href="#新建文件、文件夹" class="headerlink" title="新建文件、文件夹"></a>新建文件、文件夹</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dirName 创建文件夹</span><br><span class="line"><span class="built_in">touch</span> fileName 创建文件</span><br></pre></td></tr></table></figure>

<p>Linux文件和目录名字除了“&#x2F;”都合法，但是尽量不要用正则表达式之类的符号，因为有可能会在进行正则匹配时造成误删等问题</p>
<p>假设当前目录有文件<code>f1,f2,f3</code>和<code>f[123]</code><br>执行：<code>rm f[123]</code>本来是希望删除<code>f[123]</code>,但是由于正则匹配，会先删除<code>f1,f2,f3</code>这三个文件。</p>
<h1 id="查看文件信息"><a href="#查看文件信息" class="headerlink" title="查看文件信息"></a>查看文件信息</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file fileName 查看文件格式信息</span><br><span class="line"><span class="built_in">cat</span> fileName 以文本格式查看文件全部内容</span><br><span class="line">less fileName 以分页形式查看文件内容，Q键退出</span><br></pre></td></tr></table></figure>

<h1 id="常用目录"><a href="#常用目录" class="headerlink" title="常用目录"></a>常用目录</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home 当前用户主目录，root用户为/root</span><br><span class="line">/bin、/usr/bin 常用的可执行文件，root用户为/sbin</span><br><span class="line">/media、/mnt 用户硬件挂载点</span><br><span class="line">/etc 系统的配置文件，所有用户可见，root用户可以更改</span><br><span class="line">/boot 系统内核，开机必备文件</span><br><span class="line">/dev 系统的所有设备文件，如硬盘、光驱等</span><br><span class="line">/var和/srv 系统运行时的用户数据</span><br><span class="line">/proc 内存中的状态信息</span><br><span class="line">/lib、/usr/lib、/usr/local/lib 库文件</span><br><span class="line">/temp 临时文件，所有用户可见</span><br><span class="line">/usr 程序相关文件unix system resource</span><br></pre></td></tr></table></figure>

<h1 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h1><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p><strong><code>ls</code></strong>  展示当前目录下文件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls [-alhd] l </span><br></pre></td></tr></table></figure>

<p><code>l</code>展示目录下的文件列表，<code>a </code>展示所有文件（包括隐藏文件），<code> h</code> 展示带单位的文件大小， <code>d</code>展示当前目录本身信息</p>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p><strong><code>chmod</code></strong>  更改权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [-R] mode fileName</span><br></pre></td></tr></table></figure>

<p><code>mode</code>组成如下：<code>[范围] [操作] [权限]</code></p>
<p><code>范围</code>：<code>u</code>用户、<code>g</code>群组、<code>o</code>其他、<code>a</code>以上所有（ugo）</p>
<p><code>操作</code>：<code>+</code> 增加、<code>-</code> 减去、<code>=</code> 等于</p>
<p><code>权限</code>：<code>r</code> 读权限<code>4</code>、<code> w</code> 写权限<code>2</code>、 <code>x</code> 执行权限<code>1</code> 、无权限  <code>0</code></p>
<p><strong>权限验证</strong> ： root用户可以访问任何用户文件，不受权限限制；普通用户需要验证权限</p>
<p><em>要读取文件夹中的内容，也需要执行权限<code>x</code></em></p>
<h2 id="文件权限与umask"><a href="#文件权限与umask" class="headerlink" title="文件权限与umask"></a>文件权限与umask</h2><p>Linux创建新项目时默认的权限分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件夹 777</span><br><span class="line">文件 666</span><br></pre></td></tr></table></figure>

<p>但是，经过umask（此处为0022）遮盖后，变成了755 ，644，这才是真正创建后的结果</p>
<p>可以通过<code>umask查看</code>umask的值，一般只去其<strong>后3位</strong>，遮盖的原则是从原先的权限中<strong>减去</strong>umask中的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始权限  ： r w x      7</span><br><span class="line">umask	： -  w x      3</span><br><span class="line">结   果  ： r - -      4</span><br></pre></td></tr></table></figure>

<h2 id="查看、管理当前用户信息"><a href="#查看、管理当前用户信息" class="headerlink" title="查看、管理当前用户信息"></a>查看、管理当前用户信息</h2><p><code>users</code> 和<code>whoami</code>输出当前用户名</p>
<p>增、删、改用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd / userdel / usermod username</span><br><span class="line">group群组管理也类似</span><br><span class="line">groupadd / groupmod ...</span><br></pre></td></tr></table></figure>

<p>其中<code>userdel -r username</code>在删除用户时，也会删除用户对应的主目录<code>home</code></p>
<p><code>groups</code> 查看用户所在群组，其中第一个是主要群组，其余是次要群组。</p>
<p><em>主要群组</em> 在用户创建新的文件时，文件群组权限一项默认为该群组</p>
<p><code>who</code> 、<code>w</code>可以查看用户相关信息</p>
<p><code>id</code> 查看某人或者自己相关的<code>UID、GID</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">finger [-s] username</span><br><span class="line">查看用户相关信息</span><br><span class="line">-s 仅显示用户账号、全名、登录时间</span><br></pre></td></tr></table></figure>

<p><code>GID</code> 系统 &lt;500 ，用户 &gt;500</p>
<h2 id="改密码"><a href="#改密码" class="headerlink" title="改密码"></a>改密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>

<h2 id="文件打包、压缩和解压缩"><a href="#文件打包、压缩和解压缩" class="headerlink" title="文件打包、压缩和解压缩"></a>文件打包、压缩和解压缩</h2><p><code>.gz</code> 压缩后格式，<code>.tar </code>打包后格式，<code>tar.gz</code>先打包后压缩的格式（常用）</p>
<h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>gzip压缩会删除源文件,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip [-cdtv#] filename</span><br></pre></td></tr></table></figure>

<p><code>#</code> 压缩等级</p>
<p><code>v</code> 显示压缩前后压缩比</p>
<p><code>t</code> 校验是否是gzip压缩的文件</p>
<p><code>c</code> 压缩文件并输出到屏幕</p>
<p><code>d</code> 解压文件</p>
<p>使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gizp file 将file压缩成file.gz，会删除file</span><br><span class="line">gzip -c file &gt; file.gz 压缩文件file并输出到file.gz</span><br></pre></td></tr></table></figure>

<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>打包，在压缩文件夹时，一般为了效率都会先打包，在压缩，由此形成的格式一般是类似<code>*.tar.gz*</code>的后缀。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打包</span><br><span class="line">tar [-jcv] -f outFileName.tar inDirPath</span><br><span class="line">解包</span><br><span class="line">tar [-jxv] -f inFileName.tar -C outputPath</span><br></pre></td></tr></table></figure>

<p><code>c</code> 建立打包文档</p>
<p><code>x</code> 解包<code> -C</code> 输出目录</p>
<p><code>t</code> 查看打包文件的内容</p>
<p><code>j</code> &#x2F; <code>z</code> 使用<code>bz2</code> &#x2F; <code>gzip</code> 压缩、解压</p>
<p><code>v</code> 输出信息</p>
<p><code>f</code> 后面紧跟要操作的文件</p>
<h1 id="bash-shell"><a href="#bash-shell" class="headerlink" title="bash shell"></a>bash shell</h1><p>bash是用户和内容交互的桥梁 <code>用户 ↔ bash ↔ Unix内核</code></p>
<p><code>env</code> 查看环境变量</p>
<p><code>type</code> 查看类型</p>
<p><code>which</code> 查看指令的位置</p>
<p><code>clear</code> 、 <code>cls</code> 清屏</p>
<p><strong>bash shell 设置</strong></p>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p><code>key=value</code> 增加一个值为<code>value</code>的变量<code>key</code></p>
<p>其中，如果value有空格的话需要用引号包住：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">双引号 可以用$KEY 引用其他KEY的值</span><br><span class="line">单引号 内容是纯文本</span><br></pre></td></tr></table></figure>

<p><code>echo $KEY​ </code>可以输出<code>KEY</code>的值</p>
<p><code>set</code> 查看所有变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set | grep HIST 查看shell命令历史</span><br><span class="line">set | grep PSI 提示符前面的内容，username-MBP:dirpath username$ </span><br></pre></td></tr></table></figure>

<h2 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h2><p><code>alias</code> 查看所有别名</p>
<p><code>alias newCmd=oldCmd</code>使用<code>newCmd</code>表示<code>oldCmd</code></p>
<p><code>unalias newCmd</code> 删除别名</p>
<p>如:<code>alias cls=clear</code>,执行<code>cls</code>就等于执行<code>clear</code></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>export KEY=VALUE</code> 将值为<code>VALUE</code>的<code>KEY</code>添加到环境变量（本次shell有效）</p>
<p>此外还可以写到一些文件中，在开机、登录、注销登录时调用执行——自动执行脚本**<code>shell startup scripts</code>**</p>
<h2 id="shell-startup-scripts"><a href="#shell-startup-scripts" class="headerlink" title="shell startup scripts"></a>shell startup scripts</h2><p>开机时执行：</p>
<ul>
<li><p><code>/etc/profile</code></p>
</li>
<li><p><code>/ect/profile.d/*.sh</code></p>
</li>
<li><p><code>~/.bash_profile , ~/.bash_login , ~/.profile</code>这三个只要其中一个成功执行了，后面的就不会执行，<code>~/.bash_profile</code>会执行<code>~/.bashrc</code></p>
</li>
<li><p><code>/etc/.bashrc</code></p>
</li>
</ul>
<p>未登录时会执行：</p>
<ul>
<li><code>~/.bashrc</code></li>
<li><code>/etc/bashrc</code></li>
<li><code>/etc/profile.d/*.sh</code></li>
</ul>
<p>注销时执行<code>~/bash_logout</code></p>
<p><strong>在修改了以上文件后，可以使用<code>source path_to_file</code>或者重新登录使其立即生效</strong></p>
<h1 id="标准输入输出等"><a href="#标准输入输出等" class="headerlink" title="标准输入输出等"></a>标准输入输出等</h1><table>
<thead>
<tr>
<th>代码编号</th>
<th>名称</th>
<th>代码</th>
<th>作用对象</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>标准输入</td>
<td>stdin</td>
<td>键盘等</td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
<td>stdout</td>
<td>屏幕等</td>
</tr>
<tr>
<td>2</td>
<td>标准错误</td>
<td>stderr</td>
<td>屏幕等</td>
</tr>
</tbody></table>
<p>定向</p>
<ul>
<li><code>&lt;</code>和<code>&lt;&lt;</code> 输入和 追加输入</li>
<li><code>&gt;</code> 和<code>&gt;&gt;</code> 输出 和追加输出</li>
</ul>
<p>使用：<code>ls -al | &gt;&gt; result.txt</code>将<code>ls</code>的内容追加输出到<code>result.txt</code>文件中。</p>
<p><code>|</code>叫做管道，可以将前者的<strong>标准输出</strong>当做后者的输入。</p>
<p> <code>cmd0 &amp;&amp; cmd1</code> 前者执行成功才会执行后者；</p>
<p><code>cmd0 || cmd1</code> 前者执行失败才会执行后者。</p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>查询内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [-cinv] &#x27;key&#x27; filename</span><br></pre></td></tr></table></figure>

<p><code>c</code> 计算次数</p>
<p><code>i</code> 忽略大小写</p>
<p><code>n</code> 行号</p>
<p><code>v</code> 显示没有该字符的行号</p>
<p><code>&#39;key&#39; </code>可以是正则表达式</p>
<p><code>--color=auto</code> 对查找到的文本显示颜色</p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>排序，默认以第一列排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort [-fbknrtu] filename</span><br></pre></td></tr></table></figure>

<p><code>f</code> 忽略大小写</p>
<p><code>b</code>忽略最前面的空格（要是排序不生效时可以试一下，推荐）</p>
<p><code>k</code> 以第几列为标准排序，默认第一列</p>
<p><code>n</code> 以数组排序</p>
<p><code>r</code> 逆序</p>
<p><code>t</code> 待排序的文件的分隔符，默认是tab</p>
<p><code>M</code> 以英文月份排序</p>
<h1 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h1><p>统计字符数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc [lwm] filename</span><br></pre></td></tr></table></figure>

<p><code>l</code> 行</p>
<p><code>w</code> 词</p>
<p><code>m</code> 字符</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OKHttpUtils分析</title>
    <url>/blog/posts/6ff87ae7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是对张鸿洋的OKHttp辅助类<a href="https://github.com/hongyangAndroid/okhttputils"><strong>okhttputils</strong></a>简要分析，以便学习如何封装常见工具的思想，建议配合源码食用。</p>
<p>主要涉及类：</p>
<ul>
<li>OkHttpUtils</li>
<li>OkHttpRequestBuilder</li>
<li>OkHttpRequest</li>
<li>RequestCall</li>
<li>Callback</li>
</ul>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><a href="https://github.com/square/okhttp">OkHttp</a>是可以用于Android和Java的Http框架，经典的使用分为3步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个OkHttpClient客户端，在这里配置网络超时等全局配置</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建一个网络请求，每个Http访问对应一个Request，详细配置了访问的URL，类型，参数等信息</span></span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span></span><br><span class="line">        .Builder()</span><br><span class="line">        .url(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 使用OkHttpClient客户端创建Call并执行该网络请求，分为阻塞和异步两种方式，异步会有对应回调</span></span><br><span class="line">okHttpClient.newCall(request)</span><br><span class="line">        .enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>虽然整体的逻辑已经很简单了，但是在实际使用的时候，不可能对每个网络请求都写一次上述代码，所以就需要对齐进行必要的封装以简化网络请求流程。</p>
<p>okhttputils就做到了这一点，并且将上述第二步常见网络请求的过程也加入链式调用中，使用起来更加连贯：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 全局配置唯一的OkHttpClient</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">10000L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        .readTimeout(<span class="number">10000L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        .build();</span><br><span class="line">OkHttpUtils.initClient(okHttpClient);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.在需要网络请求的时候，执行对应代码</span></span><br><span class="line">OkHttpUtils.get()</span><br><span class="line">                .url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                .build()</span><br><span class="line">                .execute(<span class="keyword">new</span> <span class="title class_">com</span>.zhy.http.okhttp.callback.Callback() &#123;</span><br><span class="line">                  <span class="comment">//回调方法</span></span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>其中<code>9~10</code>行相当于OKHttp步骤2创建网络请求，<code>11~14</code>则就是步骤3执行网络请求的过程。</p>
<p>每次使用网络请求时只需要选择<code>get</code>、<code>post</code>等方法获取并配置相应<code>builder</code>，然后选择<code>execute</code>执行即可。</p>
<h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>那么okhttputils是如何实现这一点的呢？</p>
<p>首先看看<code>OkHttpUtils</code>的结构：</p>
<p><img src="https://jixiaoyong.github.io/images/20190317141417.png"></p>
<p>可以看到大体上可以将其分为3个部分：</p>
<ol>
<li>OkHttpClient相关</li>
<li>网络请求相关信息</li>
<li>与具体执行网络请求有关的方法</li>
</ol>
<h2 id="OkHttpClient相关"><a href="#OkHttpClient相关" class="headerlink" title="OkHttpClient相关"></a>OkHttpClient相关</h2><p>我们先来看第一部分，OkHttpUtils本质上只是对OkHttpClient的方法进行了一次封装，所以其肯定要持有OkHttpClient对象，一般来说一个APP只需要一个OkHttpClient对象即可，所以可以看到OkHttpUtils做了双重锁定的单例处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpUtils <span class="title function_">initClient</span><span class="params">(OkHttpClient okHttpClient)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (OkHttpUtils.class)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mInstance = <span class="keyword">new</span> <span class="title class_">OkHttpUtils</span>(okHttpClient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在第一次使用<code>OkHttpUtils</code>的时候初始化的<code>OkHttpClient</code>便会被保存到这里，之后的使用中就不需要再去反复创建了。</p>
<p>此外在<code>OkHttpUtils</code>的结构中可以注意到有一个<code>mPlatform</code>的变量，他会根据当前是Android还是其他平台的不同被初始化为Android主线程或者普通线程池，这个我们在后面回调网络请求状态的时候会用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Platform</span> <span class="variable">mPlatform</span> <span class="operator">=</span> findPlatform();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title function_">findPlatform</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;android.os.Build&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Android</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Platform</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络请求相关信息"><a href="#网络请求相关信息" class="headerlink" title="网络请求相关信息"></a>网络请求相关信息</h2><p>有了<code>OkHttpClient</code>对象之后，下一步便是创建一个适当的网络请求。</p>
<p>在<code>OkHttpUtils</code>中使用的是<code>OkHttpRequestBuilder &lt;T extends OkHttpRequestBuilder&gt;</code>的子类来收集、配置相关的一些属性。</p>
<p>在该类中，定义了一系列网络请求基本的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String url;</span><br><span class="line"><span class="keyword">protected</span> Object tag;</span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, String&gt; headers;</span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, String&gt; params;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> id;</span><br></pre></td></tr></table></figure>

<p>此外还有一个抽象方法，用来创建执行网络请求的<code>RequestCall</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> RequestCall <span class="title function_">build</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法在其子类中的实现一般是调用<code>OkHttpRequest</code>子类的<code>build</code>方法，可以看到<code>OkHttpRequestBuilder</code>只是将网络请求的相关参数传递到<code>OkHttpRequest</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.builder.GetBuilder</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RequestCall <span class="title function_">build</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (params != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        url = appendParams(url, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(url, tag, params, headers,id).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>OkHttpRequest</code>中，利用上述的参数可以并通过<code>generateRequest(Callback callback)</code>方法创建<code>Request</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.request.OkHttpRequest</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">OkHttpRequest</span><span class="params">(String url, Object tag,</span></span><br><span class="line"><span class="params">                   Map&lt;String, String&gt; params, Map&lt;String, String&gt; headers,<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.tag = tag;</span><br><span class="line">        <span class="built_in">this</span>.params = params;</span><br><span class="line">        <span class="built_in">this</span>.headers = headers;</span><br><span class="line">        <span class="built_in">this</span>.id = id ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Exceptions.illegalArgument(<span class="string">&quot;url can not be null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initBuilder();<span class="comment">//初始化okhttp3.Request.Builder用于生成Request</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Request <span class="title function_">generateRequest</span><span class="params">(Callback callback)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> buildRequestBody();</span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">wrappedRequestBody</span> <span class="operator">=</span> wrapRequestBody(requestBody, callback);<span class="comment">//用于更新下载进度等，为okhttp3.Callback增加更多功能</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(wrappedRequestBody);<span class="comment">//在子类中使用okhttp3.Request.Builder对象生成对应的Request</span></span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的抽象方法<code>wrapRequestBody()</code>，<code>buildRequest()</code>的实现，也是<code>OkHttpRequest</code>各个子类主要的不同点。</p>
<blockquote>
<p><code>Callback</code>是在<code>okhttp3.Callback</code>的基础上增加了before，progress和对请求结果的处理等的回调。</p>
</blockquote>
<p><code>OkHttpRequest</code>类的<code>build</code>方法则只是将其自身传递给<code>okhttp3.Call</code>的封装类<code>RequestCall</code>，创建并返回该类的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.request.OkHttpRequest</span></span><br><span class="line"><span class="keyword">public</span> RequestCall <span class="title function_">build</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestCall</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行网络请求"><a href="#执行网络请求" class="headerlink" title="执行网络请求"></a>执行网络请求</h2><p><code>RequestCall</code>类则是对<code>okhttp3.Call</code>类的进一步封装，对外提供更多的接口：开始、取消网络请求<code>cancel()</code>,<code>readTimeOut()</code>…等接口。</p>
<p>当执行<code>RequestCall</code>的<code>execute</code>方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.request.RequestCall</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Callback callback)</span></span><br><span class="line">&#123;</span><br><span class="line">    buildCall(callback);<span class="comment">//创建okhttp3.Call对象，其所用的Request对象来自于okHttpRequest.generateRequest(callback)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        callback.onBefore(request, getOkHttpRequest().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OkHttpUtils.getInstance().execute(<span class="built_in">this</span>, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看其最后只是将<code>RequestCall</code>和<code>callback</code>传递给了<code>OkHttpUtils</code>类的<code>execute</code>方法，也就是说，最终还是调用了<code>okhttp3.Call</code>的<code>enqueue()</code>方法，在这里执行了真正的网络请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.OkHttpUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> RequestCall requestCall, Callback callback)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="literal">null</span>)</span><br><span class="line">        callback = Callback.CALLBACK_DEFAULT;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">finalCallback</span> <span class="operator">=</span> callback;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> requestCall.getOkHttpRequest().getId();</span><br><span class="line"></span><br><span class="line">    requestCall.getCall().enqueue(<span class="keyword">new</span> <span class="title class_">okhttp3</span>.Callback()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, <span class="keyword">final</span> IOException e)</span></span><br><span class="line">        &#123;</span><br><span class="line">            sendFailResultCallback(call, e, finalCallback, id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="keyword">final</span> Call call, <span class="keyword">final</span> Response response)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (call.isCanceled())</span><br><span class="line">                &#123;</span><br><span class="line">                    sendFailResultCallback(call, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled!&quot;</span>), finalCallback, id);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!finalCallback.validateReponse(response, id))</span><br><span class="line">                &#123;</span><br><span class="line">                    sendFailResultCallback(call, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;request failed , reponse&#x27;s code is : &quot;</span> + response.code()), finalCallback, id);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> finalCallback.parseNetworkResponse(response, id);</span><br><span class="line">                sendSuccessResultCallback(o, finalCallback, id);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                sendFailResultCallback(call, e, finalCallback, id);</span><br><span class="line">            &#125; <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.body() != <span class="literal">null</span>)</span><br><span class="line">                    response.body().close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而网络请求的回调，则是在本文最开始的<code>mPlatform</code>提供的线程中进行。这样保证了在Android中，<code>onBefore</code>、<code>onAfter</code>、<code>inProgress</code>等回调能够在UI线程进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSuccessResultCallback</span><span class="params">(<span class="keyword">final</span> Object object, <span class="keyword">final</span> Callback callback, <span class="keyword">final</span> <span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    mPlatform.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            callback.onResponse(object, id);</span><br><span class="line">            callback.onAfter(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文中，<code>okhttputils</code>将初始化<code>OkHttpClient</code>的动作提取出来，这样同一个应用只需要在最开始的时候配置一下诸如网络超时、cookie等既可。</p>
<p>在具体的实现中，通过<code>OkHttpRequestBuilder</code>收集网络请求的属性并传递给<code>OkHttpRequest</code>，在其子类中按照不同的需要实现生成<code>Request</code>的方法。</p>
<p><code>OkHttpRequestBuilder</code>的<code>build()</code>方法会生成<code>RequestCall</code>对象，<code>RequestCall</code>对象的<code>execute()</code>方法会调用<code>OkHttpRequestBuilder</code>对象的<code>generateRequest()</code>方法产生<code>Request</code>，并据此产生<code>Call</code>对象，最后通过该<code>Call</code>对象的enqueue方法执行网络请求。</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动创建发布hexo文章并同步github</title>
    <url>/blog/posts/d9a2e1ba/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>环境 linux(deepin)</p>
<p>python 2.7</p>
</blockquote>
<p>这是一个Python脚本，用于实现hexo文章创建、生成网页并预览、发布到对应xxx.github.io博客的全过程。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="使用时需要根据自己的项目更新main-py的一下变量："><a href="#使用时需要根据自己的项目更新main-py的一下变量：" class="headerlink" title="使用时需要根据自己的项目更新main.py的一下变量："></a>使用时需要根据自己的项目更新main.py的一下变量：</h2><ul>
<li><p>hexo_url &#x3D; ‘your_path&#x2F;hexo&#x2F;blog’</p>
<p>【必需】本地hexo博客路径</p>
</li>
<li><p>hexo_public_dir &#x3D; ‘your_path&#x2F;hexo&#x2F;blog&#x2F;public’</p>
<p>【必需】本地hexo博客输出路径</p>
</li>
<li><p>hexo_post_dir &#x3D; ‘your_path&#x2F;hexo&#x2F;blog&#x2F;source&#x2F;_posts’</p>
<p>【可选】本地hexo博客文章源文件路径</p>
</li>
<li><p>git_dir &#x3D; ‘your_path&#x2F;xxx.github.io’</p>
<p>【必需】博客要同步的git工程路径</p>
</li>
<li><p>git_backup_dir &#x3D; ‘your_path&#x2F;xxx.github.io&#x2F;blog&#x2F;backup&#x2F;sources&#x2F;_posts’</p>
<p>【可选】本路径用于备份post源文件到github</p>
</li>
<li><p>hexo.py 中的<code>post()</code>方法中<code>webbrowser.open(&#39;http://jixiaoyong.github.io/blog/&#39;)</code>中的博客地址，发布完后默认打开该网页。（后期也可以改为<code>post()</code>参数传入，这样只需要更改<code>main.py</code>就行）</p>
</li>
</ul>
<h2 id="运行main-py文件"><a href="#运行main-py文件" class="headerlink" title="运行main.py文件"></a>运行<code>main.py</code>文件</h2><ul>
<li>在Linux命令行输入如下命令，并回车，根据提示操作即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure>

<p>​    Windows下可以运行<code>start.cmd</code>脚本（待实现）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//start.cmd脚本内容</span><br><span class="line">python main.py</span><br><span class="line">cmd</span><br></pre></td></tr></table></figure>

<ul>
<li><p>操作过程提示及说明如下：（渣英语请忽略…）</p>
<ul>
<li><p>input yout file name 输入要发布的文章名称xxx（当前版本暂不支持中文）</p>
<p>输入回车会自动创建xxx.md文件并打开（需要系统支持该格式）</p>
</li>
<li><p>are you finish your post 输入y或n，选择是否用hexo编译文章</p>
<p>y:编译文章  n:不编译文章，退出命令行</p>
</li>
<li><p>post or not  输入y或n，选择是否发布文章到网站,可以在打开的页面预览后做决定</p>
<p>y:发布文章  n:不发布文章，退出命令行</p>
</li>
<li><p>update post  《xxx》 提示开始发布文章，自动打开网页，并保存源文件</p>
</li>
</ul>
</li>
</ul>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>源代码已经上传<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-31/python%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%96%87%E7%AB%A0">github</a></p>
<h1 id="后期计划"><a href="#后期计划" class="headerlink" title="后期计划"></a>后期计划</h1><ul>
<li>增加文件名中文支持</li>
<li><del>增加图片自动上传、替换为github链接</del>(2018&#x2F;2&#x2F;2已实现)</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门知识</title>
    <url>/blog/posts/a8f97c56/</url>
    <content><![CDATA[<p>基于Python3.x</p>
<p>Python文件默认格式<code>.py</code></p>
<p>首行默认以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br></pre></td></tr></table></figure>



<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li><p><strong>数字</strong></p>
<p>整数int  1，2，3</p>
<p>长整数long  1112L</p>
<p>浮点数float （小数）1.23，3.14</p>
<p>复数complex  3.14j</p>
</li>
<li><p><strong>字符串</strong></p>
<p> ‘abc’，”abc”，’’’abc‘’‘</p>
<p>‘x’和”x” 区别不大</p>
<p>‘’’abc‘’‘ 文本可以跨行</p>
<p>字符串前面加r或者R表示字符串内部不需要转义，否则要用<code>\</code> 转义</p>
<p>支持<code>a[0]</code>取值</p>
</li>
<li><p><strong>布尔值</strong></p>
<p> <code>True</code> 和<code>False</code></p>
<p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算</p>
</li>
<li><p><strong>空值</strong></p>
<p> <code>None</code></p>
</li>
<li><p><strong>变量</strong> </p>
<p>命名规则：开头<code>aA_</code>，其后可以包含<code>aA_1</code></p>
</li>
<li><p><strong>常量</strong></p>
<p> 不能变的变量</p>
</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li><p><strong>列表list</strong></p>
<p> [1,2,3,3]</p>
<p>插入list.insert(1,’vaule’)</p>
<p>删除list.pop() &#x2F; list.pop(1)</p>
</li>
<li><p>**元组tuple **</p>
<p>(1,2,3,3)</p>
<p>与列表类似，但是一旦初始化就不能再修改</p>
<hr>
</li>
<li><p><strong>字典dict</strong></p>
<p> {‘a’:1,’b’:’vaule’}</p>
<p>键值对，读取快，相当于java的map</p>
</li>
<li><p><strong>set</strong></p>
<p> set([1,2,3])</p>
<p>键的集合，不能有重复的，相当于java的set</p>
</li>
</ul>
<h1 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h1><ul>
<li>if … : … elif … : … else : …</li>
<li>for x in xs : …</li>
<li>while x : …</li>
</ul>
<h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">n</span>)</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>return</strong></li>
</ul>
<p>可以没有return，默认返回None</p>
<p>可以return 多个值，实际上返回的是一个tuple</p>
<ul>
<li><strong>pass</strong></li>
</ul>
<p> 不想执行任何语句，但是为了符合语法规范，可以用pass当做占位符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>()</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>抛出异常</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> TypeError(<span class="string">&#x27;an error&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其中TypeError需要继承自<code>error</code>或者<code>Exception</code></p>
<ul>
<li><strong>参数</strong></li>
</ul>
<p>位置参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg</span>)</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>默认参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg0,arg1 = <span class="number">1</span></span>)</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 默认参数必须是参数中后面的几位；默认值必须不可变，如int，string等</p>
<p>可变参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg,*args</span>)</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>*args</code> 表示参数个数可变，可以输入list&#x2F;tuple等，或者依次输入多个参数，用逗号分隔</p>
<p>关键词参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg,**keywords</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="string">&#x27;city&#x27;</span> <span class="keyword">in</span> kw:</span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>**keywords</code> 表示接受关键词作为参数传入，可以传入dict，或者依次输入多个关键词参数</p>
<p>命名关键词参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun0</span>(<span class="params">args,*，name,age</span>)</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>(<span class="params">arg.*args,name,age</span>)<span class="comment">#如果命名关键词前面有可变参数，则不用*分隔</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>限制输入的关键字，限制只有name和age作为关键词参数</p>
<h1 id="使用其他文件的函数"><a href="#使用其他文件的函数" class="headerlink" title="使用其他文件的函数"></a>使用其他文件的函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用时 sys.fun()</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#使用时直接fun()</span></span><br><span class="line"><span class="keyword">from</span> xxFile <span class="keyword">import</span> fun</span><br><span class="line">form sys <span class="keyword">import</span> *</span><br><span class="line">form sys <span class="keyword">import</span> fun</span><br></pre></td></tr></table></figure>

<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul>
<li><strong>定义类</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;doc for AClass</span></span><br><span class="line"><span class="string">	you can use this by</span></span><br><span class="line"><span class="string">	AClass.__doc__&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">  	<span class="comment">#默认的初始化方法</span></span><br><span class="line">  	<span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">aFun</span>(<span class="params">self</span>):</span><br><span class="line">  	<span class="keyword">pass</span></span><br><span class="line"><span class="comment">#创建类对象</span></span><br><span class="line">a = AClass()</span><br><span class="line"><span class="comment">#调用方法</span></span><br><span class="line">a.aFun()</span><br></pre></td></tr></table></figure>

<p>所有的类方法必须至少有一个参数，推荐命名为self，系统会自动传入类对象，无需手动传入。</p>
<ul>
<li><strong>继承</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;father&quot;</span>)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am f&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#子类方法不会自己调用父类方法，需要手动调用</span></span><br><span class="line">    <span class="built_in">super</span>(Child,self).__init__()</span><br><span class="line">    <span class="comment">#调用父类方法2：</span></span><br><span class="line">    <span class="comment">#Father.__init__(self)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;child&quot;</span>)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i am c&#x27;</span>)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">self,where</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;go to %s&#x27;</span>%where)</span><br><span class="line"></span><br><span class="line">c = Child() <span class="comment">#father child</span></span><br><span class="line">c.say() <span class="comment">#i am c</span></span><br><span class="line">c.go(<span class="string">&#x27;home&#x27;</span>) <span class="comment">#go ro home</span></span><br></pre></td></tr></table></figure>

<p>子类继承父类，则需要在子类定义时传入父类</p>
<p>子类如果有与父类同名方法，则优先调用子类方法，除非子类特别调用父类的方法</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬取gityuan所有文章列表</title>
    <url>/blog/posts/6e070881/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>更新内容：</p>
<ul>
<li>爬取gityuan.com网站所有文章列表并输出json</li>
<li>汇总信息输出config.json为后面的客户端做准备</li>
</ul>
<p>更新文件：</p>
<ul>
<li>spider_main.py</li>
<li>html_output.py</li>
<li><strong>gityuan_urls.py</strong></li>
<li><strong>html_downloader.py</strong></li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul>
<li><strong>spider_main.py</strong></li>
</ul>
<p>作为入口类，主要增加了初始化所有URL，以及便利这些URL的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp = SpiderMain()</span><br><span class="line"></span><br><span class="line">gityuan = gityuan_urls.GitYuanUrls()</span><br><span class="line"></span><br><span class="line">gityuan_urls = gityuan.get_urls(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;gityuan_page_&#x27;</span></span><br><span class="line"></span><br><span class="line">sp.craw(gityuan_urls,file_name)</span><br></pre></td></tr></table></figure>

<p>其<code>craw()</code>方法修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">craw</span>(<span class="params">self, root_urls, file_name</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#将所有有效链接全部加入</span></span><br><span class="line">        self.urls.add_new_urls(root_urls)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#循环遍历这些链接</span></span><br><span class="line">        <span class="keyword">while</span> self.urls.has_next():</span><br><span class="line"></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            new_url = self.urls.get_new_url()</span><br><span class="line"></span><br><span class="line">            html_cont = self.downloader.download(new_url)</span><br><span class="line"></span><br><span class="line">            new_url, new_data = self.parser.parse(new_url, html_cont)</span><br><span class="line"></span><br><span class="line">            self.output.collect_data(new_data)</span><br><span class="line"></span><br><span class="line">            new_file_name = file_name + (<span class="string">&#x27;%d.json&#x27;</span>%i)</span><br><span class="line"></span><br><span class="line">            self.output.output_html(new_file_name)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#等待3s，防止太频繁访问被识别</span></span><br><span class="line">            sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#结束遍历，输出汇总信息</span></span><br><span class="line">        self.output.end(file_name,root_urls[<span class="number">0</span>],i)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>html_output.py</strong></li>
</ul>
<p>主要改动如下：</p>
<ol>
<li><code>output_html(self,file_name)</code>方法增加一个<code>file_name</code>的参数，并在内部调用<code>self.mkdir()</code>方法生成output目录，方便同时输出多个文档</li>
<li><code>mkdir()</code>方法，创建文件</li>
<li><code>end(self,file_name_start, url, num)</code>方法，输出汇总文档，代码如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>(<span class="params">self,file_name_start, url, num</span>):</span><br><span class="line"></span><br><span class="line">    self.mkdir()</span><br><span class="line"></span><br><span class="line">    file_name = self.output_dir + <span class="string">&#x27;config.json&#x27;</span></span><br><span class="line"></span><br><span class="line">    file_out = <span class="built_in">open</span>(file_name,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    current_time = time.time()</span><br><span class="line"></span><br><span class="line">    config_str = (<span class="string">&#x27;&#123;&quot;url&quot;:&quot;%s&quot;,&quot;total&quot;:&quot;%d&quot;,&quot;update_time&quot;:&quot;%d&quot;,&quot;file_name&quot;:&quot;%s&quot;&#125;&#x27;</span> % (url,num,current_time,file_name_start))</span><br><span class="line"></span><br><span class="line">    file_out.write(config_str)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>gityuan_urls.py</strong></li>
</ul>
<p>主要代码如下，通过循环遍历获取所有文章列表信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GitYuanUrls</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;docstring for GitYuanUrls&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_urls</span>(<span class="params">self, num</span>):</span><br><span class="line"></span><br><span class="line">		urls = []</span><br><span class="line"></span><br><span class="line">		urls.append(<span class="string">&#x27;http://www.gityuan.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,num):</span><br><span class="line">			url_ = (<span class="string">&#x27;http://www.gityuan.com/page%d/&#x27;</span>%x)</span><br><span class="line">			urls.append(url_)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> urls</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>html_downloader.py</strong></li>
</ul>
<p>就在本文编辑的过程中，爬虫被识别，并且限制访问文件数量，所以对下载功能做了简单的伪装、增加超时处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download2</span>(<span class="params">self, url</span>):</span><br><span class="line">        <span class="comment">#升级版</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#伪装为浏览器</span></span><br><span class="line">        req_header = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request = urllib2.Request(url,<span class="literal">None</span>,req_header)</span><br><span class="line"></span><br><span class="line">            response = urllib2.urlopen(request,<span class="literal">None</span>,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response.read()</span><br><span class="line">        <span class="keyword">except</span> socket.timeout <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment">#超时处理</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">type</span>(e))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当前爬虫主体功能以及实现，可以爬取gityuan.com所有有效文章列表，可以满足客户端需求。但仍然存在以下问题：</p>
<ol>
<li>没有伪装，爬虫<strong>很容易</strong>被识别并被拒绝服务（<del>就在刚刚写下这句话的时候，就发生了被限制访问，真*乌鸦嘴</del>）。</li>
<li>由于原网站特性，其置顶文章每页都有，会导致部分数据重复。</li>
<li>未爬取具体文章内容。</li>
</ol>
<blockquote>
<p><strong>说明</strong></p>
<p>本文只为学术研究，其中涉及到的第三方网站及其所有资源均属原主所有。向gityuan大神致敬，欢迎访问其<a href="http://gityuan.com/">blog</a>。</p>
</blockquote>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/gityuan_spider">github链接</a></p>
<p><code>tag</code>为<code>gityuan_spider1.5</code></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫爬取gityuan.com数据并输出json</title>
    <url>/blog/posts/9c0ccf0d/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>本文基于Python2.7</p>
</blockquote>
<p>这篇文章基于我在<a href="www.imooc.com">慕课网</a>上面学习Python简单爬虫写的内容，教程内容是爬取1000条百度百科的数据，但是教程中爬虫截止2018-01-27已经失效，刚好看到大神gityuan.com的内容，于是用Python实现爬取其网页内容并生成json数据。</p>
<p>本文即上述过程整理。</p>
<p>本文涉及源代码已上传github（<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/gityuan_spider">点这里查看</a>）。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>爬虫主要活动是：</p>
<ol>
<li>爬取目标网页内容</li>
<li>对获取到的内容进行分析，获取有用数据</li>
<li>将处理好的数据按格式输出</li>
</ol>
<p>此外还需要有一个专门管理爬虫活动的主类，故而文件结构如下：</p>
<ol>
<li>spider_main.py             入口类</li>
<li>url_manager.py             管理要下载的链接</li>
<li>html_downloader.py    下载网页内容</li>
<li>html_paeser.py              对获取到的数据进行解析、加工</li>
<li>html_out.py                     输出格式化的数据</li>
</ol>
<p>目前只实现了爬取gityuan.com第一页内容并输出json，所以暂时不需要实现url_manager.py</p>
<h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><p><strong>spider_main.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入用到的各个类</span></span><br><span class="line"><span class="keyword">import</span> html_downloader</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义入口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpiderMain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化各个变量downloader、parser、output...</span></span><br><span class="line">    self.downloader = html_downloader.HtmlDownloader()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#略</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">craw</span>(<span class="params">self,root_url</span>):</span><br><span class="line">    </span><br><span class="line">    html_cont = self.downloader.download(root_url)</span><br><span class="line">    </span><br><span class="line">    new_data = self.parser.parse(html_cont)</span><br><span class="line">    </span><br><span class="line">    self.output.collect_data(new_data)</span><br><span class="line">    </span><br><span class="line">    self.output.output_json()</span><br><span class="line">    </span><br><span class="line">root_url = <span class="string">&#x27;http://www.gityuan.com/&#x27;</span></span><br><span class="line">sp = SpiderMain()</span><br><span class="line">sp.craw(root_url)</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>__init__()</code> 方法初始化各个变量；</li>
<li>在<code>craw()</code>中分别实现下载、解析网页内容、输出加工数据</li>
</ul>
<p><strong>html_download.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HtmlDownLoader</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">self,url</span>):</span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    respone = urllib2.urlopen(url,timeout=<span class="number">300</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> respone.getcode() != <span class="number">200</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> respone.read()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>下载并返回网页内容，比较简单</p>
<p><strong>html_parser.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="comment">#第三方包，需要单独下载</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HtmlParser</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self,html_cont</span>):</span><br><span class="line">    <span class="keyword">if</span> html_cont <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#用BeautifulSoup解析文档内容</span></span><br><span class="line">    soup = BeautifulSoup(html_cont,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    res_data = [] <span class="comment">#数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取所有的文章节点nodes</span></span><br><span class="line">    post_div_nodes = soup.find_all(<span class="string">&#x27;div&#x27;</span>,class_=<span class="string">&#x27;post-preview&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#遍历nodes，读取每一项内容并保存</span></span><br><span class="line">    <span class="keyword">for</span> post_div_node <span class="keyword">in</span> post_div_nodes:</span><br><span class="line">      post_div_soup = BeautifulSoup(<span class="built_in">str</span>(post_div_node))</span><br><span class="line">      </span><br><span class="line">      post_info = &#123;&#125; <span class="comment">#字典dict</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">#判断URL是否是完整</span></span><br><span class="line">      url_ = post_div_soup.a[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">      <span class="keyword">if</span> <span class="string">&#x27;http://&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> url_:</span><br><span class="line">        url_ = <span class="string">&quot;http://gityuan.com&quot;</span> + url_</span><br><span class="line">       </span><br><span class="line">      <span class="comment">#保存数据</span></span><br><span class="line">      post_info[<span class="string">&#x27;url&#x27;</span>] = url_</span><br><span class="line">      post_info[<span class="string">&#x27;title&#x27;</span>] = post_div_soup.find(<span class="string">&#x27;h2&#x27;</span>).get_text()</span><br><span class="line">      post_info[<span class="string">&#x27;summary&#x27;</span>] = post_div_soup.find(<span class="string">&#x27;div&#x27;</span>,class_=<span class="string">&#x27;post-content-preview&#x27;</span>).get_text()</span><br><span class="line">       </span><br><span class="line">      res_data.append(post_info)</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">return</span> res_data   </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>这是爬虫功能的重点之一：对网页数据进行解析，由此数据才变为可用数据</p>
<p>主要是通过第三方插件<code>BeautifulSoup</code>解析数据，并保存到数组<code>res_data</code>中，具体见代码中实现</p>
<p><strong>html_output.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#下面两行代码解决编码问题，强制使用utf-8，而非默认的unicode编码</span></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JsonOutput</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.datas = []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">collect_data</span>(<span class="params">self,new_data</span>):</span><br><span class="line">    <span class="keyword">if</span> new_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      self.datas.append(new_data)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">output_json</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#打开文件，并以json格式输出</span></span><br><span class="line">    fout = <span class="built_in">open</span>(<span class="string">&#x27;output.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    fout.write(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">    fout.write(<span class="string">r&#x27;&quot;data&quot;:[&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> self.datas:</span><br><span class="line">      <span class="keyword">for</span> post_info <span class="keyword">in</span> data:</span><br><span class="line">        </span><br><span class="line">        fout.write(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        fout.write(<span class="string">&#x27;&quot;url&quot;:&quot;%&quot;,&#x27;</span> % post_info[<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">        fout.write(<span class="string">&#x27;&quot;title&quot;:&quot;%&quot;,&#x27;</span> % post_info[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">        fout.write(<span class="string">&#x27;&quot;summary&quot;:&quot;%&quot;,&#x27;</span> % post_info[<span class="string">&#x27;summary&#x27;</span>])</span><br><span class="line">        fout.write(<span class="string">&#x27;&#125;,&#x27;</span>)</span><br><span class="line">    <span class="comment">#为了符合json规范，最后一个输入空数据，无末尾逗号</span></span><br><span class="line">    fout.write(<span class="string">r&#x27;&#123;&#125;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    fout.write(<span class="string">&#x27;]&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>本类也很重要，主要是数据存取，以及将解析好的数据格式化输出</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文中代码经二次处理，不一定与源代码一致，但思路如此，以供参考。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>EventBus3简介</title>
    <url>/blog/posts/c1d65822/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>EventBus is a publish&#x2F;subscribe event bus for Android and Java.</p>
<p>若无特殊说明，英文注释引自官方源码或文档，后同</p>
</blockquote>
<p>EventBus在android中可以用于组件间，组件和后台线程间的通信，他基于订阅、发布的机制，将事件的收&#x2F;发解耦，开销小。</p>
<p>其流程如下（示意图来自官方github库）：</p>
<p><img src="https://github.com/greenrobot/EventBus/raw/master/EventBus-Publish-Subscribe.png" alt="EventBus-Publish-Subscribe"></p>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="EventBus的三个要素"><a href="#EventBus的三个要素" class="headerlink" title="EventBus的三个要素"></a>EventBus的三个要素</h2><ul>
<li><p>Event</p>
<p>事件，要传递的事件（一个类），EventBus传递该事件的对象，要传递的信息包含在该对象的属性中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>Subscriber</p>
<p>订阅者，当事件发生时要对事件执行的操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span>  <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Publisher</p>
<p>发布者，在合适的时候发布事件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().post(Event())</span><br></pre></td></tr></table></figure>

<p>此外还需要注册、注销EventBus以便订阅者能够正常接收消息</p>
</li>
</ul>
<h2 id="Subscriber的5个线程模式（ThreadMode）"><a href="#Subscriber的5个线程模式（ThreadMode）" class="headerlink" title="Subscriber的5个线程模式（ThreadMode）"></a>Subscriber的5个线程模式（ThreadMode）</h2><ul>
<li><p>POSTING</p>
<p>默认的，订阅者和发布者在同一个线程（Subscriber will be called directly in the same thread, which is posting the event）。因为有可能是在主线程，所以不要耗时操作，以免ANR。</p>
</li>
<li><p>MAIN</p>
<p>Android中，订阅者会在UI线程被唤起，同样不能耗时操作</p>
<blockquote>
<p>If the posting thread is the main thread, subscriber methods will be called directly, blocking the posting thread. Otherwise the event is queued for delivery (non-blocking). </p>
</blockquote>
</li>
<li><p>MAIN_ORDERED</p>
<p>Android，订阅者会在UI线程被唤起，不能耗时操作。</p>
<blockquote>
<p>Different from MAIN, the event will always be queued for delivery. This ensures that the post call is non-blocking.</p>
</blockquote>
</li>
<li><p>BACKGROUND</p>
<p>Android中，如果post在主线程，那么订阅者在新开的后台线程，否则在post的线程被唤起。</p>
<p>在如果不是在Android中，则都在后台线程唤起。</p>
</li>
<li><p>ASYNC</p>
<p>订阅者在新的子线程中运行，独立于UI线程和post线程</p>
</li>
</ul>
<h1 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h1><h2 id="普通事件"><a href="#普通事件" class="headerlink" title="普通事件"></a>普通事件</h2><ol>
<li><p>定义事件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span>(s: String)&#123;</span><br><span class="line">    <span class="keyword">var</span> string : String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        string = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().register(context)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置订阅者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">      Log.d(<span class="string">&quot;tag&quot;</span>,event.string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().post(Event(<span class="string">&quot;hello&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>注销</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().unregister(context)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="粘性事件"><a href="#粘性事件" class="headerlink" title="粘性事件"></a>粘性事件</h2><p>粘性事件即事件发生（<code>postSticky()</code>）之后，再订阅，也可对事件进行处理</p>
<p>发布（<code>postSticky()</code>）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(Event(<span class="string">&quot;粘性事件&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>订阅者（<code>sticky = true</code>）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true)</span><span class="comment">//sticky默认为false，可以不写</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;tag&quot;</span>,event.string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上修改<code>发布</code>和<code>订阅者</code> 之后，当<code>postSticky()</code>之后，只有下次<code>注册事件</code>时，<code>订阅者</code>才会对事件进行反应。</p>
<p>如下代码就只会在点击事件之后，<code>订阅者</code>才会对<code>postSticky()</code>事件做反应</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span>&#123;</span><br><span class="line">    EventBus.getDefault().register(context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/greenrobot/EventBus">greenrobot&#x2F;EventBus: Event bus for Android and Java that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality.</a></p>
<p><a href="http://blog.csdn.net/itachi85/article/details/52205464">Android事件总线（一）EventBus3.0用法全解析 - CSDN博客</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart Isolate源码分析</title>
    <url>/blog/posts/a951661c/</url>
    <content><![CDATA[<h1 id="Isolate"><a href="#Isolate" class="headerlink" title="Isolate"></a>Isolate</h1><p>💡 本文基于Dart 2.17.1</p>
<p><a href="https://api.dart.cn/stable/2.17.1/dart-isolate/Isolate-class.html">Isolate</a>, an isolated Dart execution context.</p>
<p>All Dart code runs in an isolate, and <strong>code can access classes and values only from the same isolate</strong>. Different isolates can communicate by <strong>sending values through ports</strong> (see <a href="https://api.dart.cn/stable/2.17.1/dart-isolate/ReceivePort-class.html">ReceivePort</a>, <a href="https://api.dart.cn/stable/2.17.1/dart-isolate/SendPort-class.html">SendPort</a>).</p>
<blockquote>
<p>In Dart an isolate has its own event loop, its own global fields, can run in parallel with other isolates and have their own live-cycle.<br>— <a href="https://github.com/dart-lang/sdk/issues/36097#issuecomment-746510375">https://github.com/dart-lang/sdk/issues/36097#issuecomment-746510375</a></p>
</blockquote>
<p> The new isolate has its <strong>own memory and its own thread</strong> working in parallel with the main isolate.</p>
<p><img src="https://jixiaoyong.github.io/images/isolate_and_isolate_group.png" alt="[https://www.youtube.com/watch?v=NoVYI94MJio&amp;ab_channel=Flutterly](https://www.youtube.com/watch?v=NoVYI94MJio&amp;ab_channel=Flutterly)"></p>
<p><a href="https://www.youtube.com/watch?v=NoVYI94MJio&ab_channel=Flutterly">https://www.youtube.com/watch?v=NoVYI94MJio&ab_channel&#x3D;Flutterly</a></p>
<p>Isolate创建会占用内存，可以使用<code>IsolateGroup</code>来解决，并且目前为止Dart和Flutter都默认支持在使用<code>Isolate.spawn</code>创建新Isolate的时候使用IsolateGroup（<code>Isolate.spwanUri</code>创建的时候会创建<strong>单独</strong>的IsolateGroup和Isolate）。</p>
<blockquote>
<p>💡 在创建isolate的时候可以添加<code>addOnExitListener</code> 或者<code>addErrorListener</code>之类的监听，但是可能在执行添加代码的时候<strong>isolate就已经终止了</strong>而导致这些方法收不到回调。<br>为了避免这种情况，可以在创建isolate的时候指定他的状态为**<code>paused</code>**。</p>
</blockquote>
<p>与isolate有关的类有：</p>
<ul>
<li><code>Isolate</code> 位置在<code>sdk\lib\isolate\isolate.dart</code>。主要是<code>Isolate</code> 通用方法、属性的抽象描述，没有具体实现。</li>
<li><code>Isolate</code> 位置在<code>sdk\lib\_internal\vm\lib\isolate_patch.dart</code>，是app等平台对应的具体实现，部分方法调用了native层的Isolate实现。</li>
<li><code>Isolate</code>  位置在<code>runtime\vm\isolate.h</code>以及<code>runtime\vm\isolate.cc</code>中，是Isolate的native层实现。</li>
</ul>
<p>他们的关系大致如图：</p>
<p><img src="https://jixiaoyong.github.io/images/isolate_class_dart_and_native.png" alt="Untitled"></p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="创建新Isolate的方式"><a href="#创建新Isolate的方式" class="headerlink" title="创建新Isolate的方式:"></a>创建新Isolate的方式:</h2><ul>
<li><code>Isolate(``SendPort controlPort``, &#123;this.pauseCapability, this.terminateCapability&#125;);</code> 这种方式创建一种<strong>能力受限</strong>的Isolate。The capabilities should be the subset of the capabilities that are available to the original isolate.本质上并没有在native层孵化一个新的Isolate。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newIsolate = Isolate(Isolate.current.controlPort);</span><br><span class="line">  newIsolate.addOnExitListener(Isolate.current.controlPort);</span><br><span class="line">  newIsolate.addErrorListener(Isolate.current.controlPort);</span><br><span class="line">  Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>),()&#123;</span><br><span class="line">    newIsolate.kill();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;try kill new isolate&quot;</span>); <span class="comment">// after this，the dart code finish</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;finish&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Isolate.spawn(``void entryPoint(T message), T message,...)</code> 创建一个和当前Isolate<strong>共享同一份代码</strong>的Isolate，并执行entryPoint方法，一般在message中传入SendPort以便从entryPoint中向来时的Isolate发送消息，新建的Isolate和当前Isolate在同一个IsolateGroup中。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> spawnIsolate() &#123;</span><br><span class="line">  <span class="keyword">var</span> receivePort = ReceivePort();</span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;receivePort(<span class="subst">$&#123;Isolate.current.debugName&#125;</span>) received msg: <span class="subst">$message</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//创建一个和当前的isolate共享同一份代码的Isolate</span></span><br><span class="line"><span class="keyword">var</span> isolate = Isolate.spawn((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Isolate initial function(<span class="subst">$&#123;Isolate.current.debugName&#125;</span>) received msg: <span class="subst">$message</span>&quot;</span>);</span><br><span class="line">    (message <span class="keyword">as</span> SendPort).send(<span class="string">&quot;HELLO_FORM_ISOLATE(<span class="subst">$&#123;Isolate.current.debugName&#125;</span>)&quot;</span>);</span><br><span class="line">  &#125;, receivePort.sendPort,debugName: <span class="string">&quot;another_isolate&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Isolate.spawnUri（Uri uri,List&lt;String&gt; args,var message,...）</code>* 指定的<code>uri</code>中创建并孵化一个isolate，执行uri对应的library中的<code>main</code>方法（0~2个入参），并传入无参、args或message作为参数</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> receivePort = ReceivePort();</span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;receivePort(<span class="subst">$&#123;Isolate.current.debugName&#125;</span>) received msg: <span class="subst">$message</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 创建一个和当前的isolate共享同一份代码的Isolate</span></span><br><span class="line">  <span class="keyword">var</span> isolate = <span class="keyword">await</span> Isolate.spawnUri(</span><br><span class="line">      <span class="built_in">Uri</span>.file(</span><br><span class="line">          <span class="string">r&quot;E:\workspace\others\flutter_dart_source_code_analysis\lib\dart\another_dart_file_to_spawn_uri.dart&quot;</span>),</span><br><span class="line">      [],</span><br><span class="line">      receivePort.sendPort,</span><br><span class="line">      debugName: <span class="string">&quot;another_isolate&quot;</span>);</span><br><span class="line">  Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () &#123;</span><br><span class="line">    receivePort.close();</span><br><span class="line">    isolate.kill(priority: Isolate.immediate);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;try kill new isolate&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a><strong>pause</strong></h3><p><code>Capability pause([Capability? resumeCapability])</code>，暂停Isolate，停止从*<code>event loop queue</code>* 中取（并处理）消息，但是依然可以往里面加入消息</p>
<p><em><code>resumeCapability</code></em> 是用来区分pause的，必须使用同一个*<code>resumeCapability</code>*来resume isolate。</p>
<ul>
<li>使用同一个*<code>resumeCapability</code>*多次<code>pause</code>，只需一次<code>resume</code>就可以恢复<code>isolate</code></li>
<li>使用不同*<code>resumeCapability</code><em>多次<code>pause</code>，必须使用对应的</em><code>resumeCapability</code><em>依次<code>resume</code>才可以恢复<code>isolate</code> （<strong>注意</strong>：这里也只需要使用当时pause isolate的</em><code>resumeCapability</code>* 依次调用resume即可，而不用保持次数一致，比如，有2个*<code>resumeCapability</code> ，*调用pause次数分别为a 1,b 2，那么要想resume isolate，也只需要分别使用a,b调用一次resume即可）</li>
</ul>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>使用isolate往<code>receivePort.sendPort</code>发送response消息，<strong>即使isolate当前被pause也可以正常发送</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">isolate.pause();</span><br><span class="line">isolate.ping(receivePort.sendPort, response: <span class="string">&quot;is isolate resume?&quot;</span>);<span class="comment">//receivePort依然可以收到消息</span></span><br></pre></td></tr></table></figure>

<p>ping可以正常发送的原因是：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\isolate\isolate.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ping方法是一个external方法</span></span><br><span class="line"><span class="keyword">external</span> <span class="keyword">void</span> ping(SendPort responsePort,</span><br><span class="line">      &#123;<span class="built_in">Object?</span> response, <span class="built_in">int</span> priority = immediate&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; sdk/lib/_internal/vm/lib/isolate_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">void</span> ping(SendPort responsePort,</span><br><span class="line">      &#123;<span class="built_in">Object?</span> response, <span class="built_in">int</span> priority: immediate&#125;) &#123;</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">Object?</span>&gt;.filled(<span class="number">5</span>, <span class="keyword">null</span>)</span><br><span class="line">      ..[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// Make room for OOM message type.</span></span><br><span class="line">      ..[<span class="number">1</span>] = _PING</span><br><span class="line">      ..[<span class="number">2</span>] = responsePort</span><br><span class="line">      ..[<span class="number">3</span>] = priority</span><br><span class="line">      ..[<span class="number">4</span>] = response;</span><br><span class="line">    _sendOOB(controlPort, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;Isolate_sendOOB&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="keyword">void</span> _sendOOB(port, msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime/lib/isolate.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个oob消息并压入oob_queue_</span></span><br><span class="line">DEFINE_NATIVE_ENTRY(Isolate_sendOOB, <span class="number">0</span>, <span class="number">2</span>) &#123;</span><br><span class="line">  GET_NON_NULL_NATIVE_ARGUMENT(SendPort, port, arguments-&gt;NativeArgAt(<span class="number">0</span>));</span><br><span class="line">  GET_NON_NULL_NATIVE_ARGUMENT(Array, msg, arguments-&gt;NativeArgAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure to route this request to the isolate library OOB mesage handler.</span></span><br><span class="line">  msg.SetAt(<span class="number">0</span>, Smi::Handle(Smi::New(Message::kIsolateLibOOBMsg)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure message writer (and it&#x27;s resources, e.g. forwarding tables) are</span></span><br><span class="line">  <span class="comment">// cleaned up before handling interrupts.</span></span><br><span class="line">  &#123;</span><br><span class="line">    PortMap::PostMessage(WriteMessage(<span class="comment">/* can_send_any_object */</span> <span class="keyword">false</span>,</span><br><span class="line">                                      <span class="comment">/* same_group */</span> <span class="keyword">false</span>, msg, port.Id(),</span><br><span class="line">                                      Message::kOOBPriority));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drain interrupts before running so any IMMEDIATE operations on the current</span></span><br><span class="line">  <span class="comment">// isolate happen synchronously.</span></span><br><span class="line">  <span class="keyword">const</span> Error&amp; error = Error::Handle(thread-&gt;HandleInterrupts());</span><br><span class="line">  <span class="keyword">if</span> (!error.IsNull()) &#123;</span><br><span class="line">    Exceptions::PropagateError(error);</span><br><span class="line">    UNREACHABLE();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>::<span class="keyword">null</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在MessageHandler中有两种MessageQueue：<code>oob_queue_</code>和<code>queue_</code> ，前者优先级高，即使isolate被pause也会执行</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\message_handler.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通消息，暂停时不能处理</span></span><br><span class="line">MessageQueue* queue_;</span><br><span class="line"><span class="comment">// 优先消息，即使处理消息时，优先处理obb_queue消息，如果为空再去考虑处理普通消息</span></span><br><span class="line"><span class="comment">// 即使isolate被pause也可以被处理</span></span><br><span class="line">MessageQueue* oob_queue_;</span><br></pre></td></tr></table></figure>

<p>像是<code>ping</code>&#x2F;<code>kill</code>&#x2F;<code>pause</code>&#x2F;<code>addOnExitListener</code>&#x2F;<code>removeOnExitListener</code>这些指令消息都是压入到<code>obb_queue_</code>中优先处理的。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>先看一下常用的几个方法是怎么实现的。</p>
<h2 id="获取当前Isolate"><a href="#获取当前Isolate" class="headerlink" title="获取当前Isolate"></a>获取当前Isolate</h2><p>（<em>sdk&#x2F;lib&#x2F;isolate&#x2F;isolate.dart</em>）<code>Isolate.current</code> →</p>
<p>  (<em>sdk&#x2F;lib&#x2F;_internal&#x2F;vm&#x2F;lib&#x2F;isolate_patch.dart</em>) <code>Isolate get current</code>  → <code>Isolate._getCurrentIsolate()</code> → <code>_getPortAndCapabilitiesOfCurrentIsolate()</code></p>
<p>（<em>runtime&#x2F;lib&#x2F;isolate.cc</em>）<code>DEFINE_NATIVE_ENTRY(Isolate_getPortAndCapabilitiesOfCurrentIsolate, 0, 0)</code></p>
<p>先看一下<em>sdk&#x2F;lib&#x2F;_internal&#x2F;vm&#x2F;lib&#x2F;isolate_patch.dart</em>中的实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk/lib/_internal/vm/lib/isolate_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> _currentIsolate = _getCurrentIsolate();</span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Isolate <span class="keyword">get</span> current =&gt; _currentIsolate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Isolate _getCurrentIsolate() &#123;</span><br><span class="line">    <span class="built_in">List</span> portAndCapabilities = _getPortAndCapabilitiesOfCurrentIsolate();</span><br><span class="line">		<span class="comment">// 这里的参数分别是SendPort，Capability，Capability</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Isolate(portAndCapabilities[<span class="number">0</span>],</span><br><span class="line">        pauseCapability: portAndCapabilities[<span class="number">1</span>],</span><br><span class="line">        terminateCapability: portAndCapabilities[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;Isolate_getPortAndCapabilitiesOfCurrentIsolate&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="built_in">List</span> _getPortAndCapabilitiesOfCurrentIsolate();</span><br></pre></td></tr></table></figure>

<p>可以看到，最后是根据native端返回的信息，新建了一个Isolate引用，但是因为<code>_currentIsolate</code>是<code>static final</code>的，所以只会被调用一次，确保了在Dart SDK中调用<code>Isolate.current</code> 时获取的是当前唯一的Isolate。</p>
<p>让我们看一下在native中是如何找到当前的Isolate的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; \runtime\lib\isolate.cc</span></span><br><span class="line"></span><br><span class="line">DEFINE_NATIVE_ENTRY(Isolate_getPortAndCapabilitiesOfCurrentIsolate, <span class="number">0</span>, <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> Array&amp; result = Array::Handle(Array::New(<span class="number">3</span>));</span><br><span class="line">  result.SetAt(<span class="number">0</span>, SendPort::Handle(SendPort::New(isolate-&gt;main_port())));</span><br><span class="line">  result.SetAt(</span><br><span class="line">      <span class="number">1</span>, Capability::Handle(Capability::New(isolate-&gt;pause_capability())));</span><br><span class="line">  result.SetAt(</span><br><span class="line">      <span class="number">2</span>, Capability::Handle(Capability::New(isolate-&gt;terminate_capability())));</span><br><span class="line">  <span class="keyword">return</span> result.ptr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见是直接取的<strong>当前线程对应的isolate</strong>对应的值，经过包装再返回到调用方。</p>
<h2 id="创建Isolate"><a href="#创建Isolate" class="headerlink" title="创建Isolate"></a>创建Isolate</h2><p>在Dart中创建Isolate有3种方式：</p>
<ul>
<li><code>Isolate(this.controlPort, &#123;this.pauseCapability, this.terminateCapability&#125;);</code>  <em><strong>create</strong> an</em> <em>isolate，本质上只是将</em><code>controlPort</code> 等设置为传入的对象，并没有在native层新建Isolate</li>
<li><code>Isolate.spawn</code>  <strong>create</strong> and <strong>spawns</strong> an <em>isolate</em></li>
<li><code>Isolate.spawnUri</code>  <strong>create</strong> and <strong>spawns</strong> an <em>isolate</em></li>
</ul>
<p><img src="https://jixiaoyong.github.io/images/Isolate_spawn_spawnuri.png"></p>
<p>这里分析一下后面两种方式，对比一下差异：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\isolate\isolate.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new [Isolate] object with a restricted set of capabilities.</span></span><br><span class="line">Isolate(<span class="keyword">this</span>.controlPort, &#123;<span class="keyword">this</span>.pauseCapability, <span class="keyword">this</span>.terminateCapability&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Creates and spawns an isolate that shares the same code as the current</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">isolate.</span></span></span><br><span class="line"><span class="keyword">external</span> <span class="keyword">static</span> Future&lt;Isolate&gt; spawn&lt;T&gt;(</span><br><span class="line">      <span class="keyword">void</span> entryPoint(T message), T message,</span><br><span class="line">      &#123;<span class="built_in">bool</span> paused = <span class="keyword">false</span>,</span><br><span class="line">      <span class="built_in">bool</span> errorsAreFatal = <span class="keyword">true</span>,</span><br><span class="line">      SendPort? onExit,</span><br><span class="line">      SendPort? onError,</span><br><span class="line">      <span class="meta">@Since</span>(<span class="string">&quot;2.3&quot;</span>) <span class="built_in">String?</span> debugName&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// <span class="language-markdown">Creates and spawns an isolate that runs the code from the library with</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">the specified URI.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The isolate starts executing the top-level <span class="code">`main`</span> function of the library</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">with the given URI.</span></span></span><br><span class="line">	<span class="keyword">external</span> <span class="keyword">static</span> Future&lt;Isolate&gt; spawnUri(</span><br><span class="line">      <span class="built_in">Uri</span> uri,</span><br><span class="line">      <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args,</span><br><span class="line">      <span class="keyword">var</span> message,</span><br><span class="line">      &#123;<span class="built_in">bool</span> paused = <span class="keyword">false</span>,</span><br><span class="line">      SendPort? onExit,</span><br><span class="line">      SendPort? onError,</span><br><span class="line">      <span class="built_in">bool</span> errorsAreFatal = <span class="keyword">true</span>,</span><br><span class="line">      <span class="built_in">bool?</span> checked,</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;? environment,</span><br><span class="line">      <span class="meta">@Deprecated</span>(<span class="string">&#x27;The packages/ dir is not supported in Dart 2&#x27;</span>)</span><br><span class="line">          <span class="built_in">Uri?</span> packageRoot,</span><br><span class="line">      <span class="built_in">Uri?</span> packageConfig,</span><br><span class="line">      <span class="built_in">bool</span> automaticPackageResolution = <span class="keyword">false</span>,</span><br><span class="line">      <span class="meta">@Since</span>(<span class="string">&quot;2.3&quot;</span>)</span><br><span class="line">          <span class="built_in">String?</span> debugName&#125;);</span><br></pre></td></tr></table></figure>

<p>对于APP等来说，上述<code>Isolate.spawn</code>和<code>Isolate.spawnUri</code>的实现都在<code>vm</code>下面的<code>isolate_patch.dart</code>中（js会返回<code>_unsupported()</code>）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\isolate_patch.dart</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Future&lt;Isolate&gt; spawn&lt;T&gt;(<span class="keyword">void</span> entryPoint(T message), T message,</span><br><span class="line">      &#123;<span class="built_in">bool</span> paused = <span class="keyword">false</span>,</span><br><span class="line">      <span class="built_in">bool</span> errorsAreFatal = <span class="keyword">true</span>,</span><br><span class="line">      SendPort? onExit,</span><br><span class="line">      SendPort? onError,</span><br><span class="line">      <span class="built_in">String?</span> debugName&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// `paused` isn&#x27;t handled yet.</span></span><br><span class="line">    <span class="comment">// Check for the type of `entryPoint` on the spawning isolate to make</span></span><br><span class="line">    <span class="comment">// error-handling easier.</span></span><br><span class="line">    <span class="keyword">if</span> (entryPoint <span class="keyword">is</span>! _UnaryFunction) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentError(entryPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The VM will invoke [_startIsolate] with entryPoint as argument.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We do not inherit the package config settings from the parent isolate,</span></span><br><span class="line">    <span class="comment">// instead we use the values that were set on the command line.</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RawReceivePort readyPort =</span><br><span class="line">        <span class="keyword">new</span> RawReceivePort(<span class="keyword">null</span>, <span class="string">&#x27;Isolate.spawn ready&#x27;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      **_spawnFunction**(readyPort.sendPort, script.toString(), entryPoint, message,</span><br><span class="line">          paused, errorsAreFatal, onExit, onError, packageConfig, debugName);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> **_spawnCommon**(readyPort);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, st) &#123;</span><br><span class="line">      readyPort.close();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> Future&lt;Isolate&gt;.error(e, st);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Future&lt;Isolate&gt; spawnUri(<span class="built_in">Uri</span> uri, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args, <span class="keyword">var</span> message,</span><br><span class="line">      &#123;<span class="built_in">bool</span> paused = <span class="keyword">false</span>,</span><br><span class="line">      SendPort? onExit,</span><br><span class="line">      SendPort? onError,</span><br><span class="line">      <span class="built_in">bool</span> errorsAreFatal = <span class="keyword">true</span>,</span><br><span class="line">      <span class="built_in">bool?</span> checked,</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;? environment,</span><br><span class="line">      <span class="built_in">Uri?</span> packageRoot,</span><br><span class="line">      <span class="built_in">Uri?</span> packageConfig,</span><br><span class="line">      <span class="built_in">bool</span> automaticPackageResolution = <span class="keyword">false</span>,</span><br><span class="line">      <span class="built_in">String?</span> debugName&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that no mutually exclusive arguments have been passed.</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Resolve the uri against the current isolate&#x27;s root Uri first.</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The VM will invoke [_startIsolate] and not `main`.</span></span><br><span class="line">    <span class="keyword">final</span> packageConfigString = packageConfig?.toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RawReceivePort readyPort =</span><br><span class="line">        <span class="keyword">new</span> RawReceivePort(<span class="keyword">null</span>, <span class="string">&#x27;Isolate.spawnUri ready&#x27;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      **_spawnUri**(</span><br><span class="line">          readyPort.sendPort,</span><br><span class="line">          spawnedUri.toString(),</span><br><span class="line">          args,</span><br><span class="line">          message,</span><br><span class="line">          paused,</span><br><span class="line">          onExit,</span><br><span class="line">          onError,</span><br><span class="line">          errorsAreFatal,</span><br><span class="line">          checked,</span><br><span class="line">          <span class="keyword">null</span>,</span><br><span class="line">          <span class="comment">/* environment */</span></span><br><span class="line">          packageConfigString,</span><br><span class="line">          debugName);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> **_spawnCommon**(readyPort);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      readyPort.close();</span><br><span class="line">      <span class="keyword">rethrow</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Isolate.spawn call</span></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;Isolate_spawnFunction&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="keyword">void</span> _spawnFunction(</span><br><span class="line">      SendPort readyPort,</span><br><span class="line">      <span class="built_in">String</span> uri,</span><br><span class="line">      <span class="built_in">Function</span> topLevelFunction,</span><br><span class="line">      <span class="keyword">var</span> message,</span><br><span class="line">      <span class="built_in">bool</span> paused,</span><br><span class="line">      <span class="built_in">bool</span> errorsAreFatal,</span><br><span class="line">      SendPort? onExit,</span><br><span class="line">      SendPort? onError,</span><br><span class="line">      <span class="built_in">String?</span> packageConfig,</span><br><span class="line">      <span class="built_in">String?</span> debugName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Isolate.spawnUri call</span></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;Isolate_spawnUri&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="keyword">void</span> _spawnUri(</span><br><span class="line">      SendPort readyPort,</span><br><span class="line">      <span class="built_in">String</span> uri,</span><br><span class="line">      <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args,</span><br><span class="line">      <span class="keyword">var</span> message,</span><br><span class="line">      <span class="built_in">bool</span> paused,</span><br><span class="line">      SendPort? onExit,</span><br><span class="line">      SendPort? onError,</span><br><span class="line">      <span class="built_in">bool</span> errorsAreFatal,</span><br><span class="line">      <span class="built_in">bool?</span> checked,</span><br><span class="line">      <span class="built_in">List?</span> environment,</span><br><span class="line">      <span class="built_in">String?</span> packageConfig,</span><br><span class="line">      <span class="built_in">String?</span> debugName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听Isolate spawn状态，等成功之后将其处理后返回给Dart层的调用者</span></span><br><span class="line"><span class="keyword">static</span> Future&lt;Isolate&gt; _spawnCommon(RawReceivePort readyPort) &#123;</span><br><span class="line">    <span class="keyword">final</span> completer = <span class="keyword">new</span> Completer&lt;Isolate&gt;.<span class="keyword">sync</span>();</span><br><span class="line">    readyPort.handler = (readyMessage) &#123;</span><br><span class="line">      readyPort.close();</span><br><span class="line">      <span class="keyword">if</span> (readyMessage <span class="keyword">is</span> <span class="built_in">List</span> &amp;&amp; readyMessage.length == <span class="number">2</span>) &#123;</span><br><span class="line">        SendPort controlPort = readyMessage[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">List</span> capabilities = readyMessage[<span class="number">1</span>];</span><br><span class="line">        **completer.complete(<span class="keyword">new</span> Isolate(controlPort,</span><br><span class="line">            pauseCapability: capabilities[<span class="number">0</span>],</span><br><span class="line">            terminateCapability: capabilities[<span class="number">1</span>]));**</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readyMessage <span class="keyword">is</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="comment">// We encountered an error while starting the new isolate.</span></span><br><span class="line">        completer.completeError(<span class="keyword">new</span> IsolateSpawnException(</span><br><span class="line">            <span class="string">&#x27;Unable to spawn isolate: <span class="subst">$&#123;readyMessage&#125;</span>&#x27;</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This shouldn&#x27;t happen.</span></span><br><span class="line">        completer.completeError(<span class="keyword">new</span> IsolateSpawnException(</span><br><span class="line">            <span class="string">&quot;Internal error: unexpected format for ready message: &quot;</span></span><br><span class="line">            <span class="string">&quot;&#x27;<span class="subst">$&#123;readyMessage&#125;</span>&#x27;&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> completer.future;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实，根据上述的代码，不管是<code>Isolate.spawnUri()</code> 还是<code>Isolate.spawn</code>，都是先调用<code>RawReceivePort</code>获取<code>RawReceivePort readyPort</code>，最后都是调用了<code>_spawnCommon(readyPort)</code> 方法，最终通过<code>new Isolate(controlPort, pauseCapability: capabilities[0], terminateCapability: capabilities[1])</code>方法创建了新的<code>Isolate</code> 。</p>
<p>这个方法的定义在<code>sdk/lib/isolate/isolate.dart</code>中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk/lib/isolate/isolate.dart</span></span><br><span class="line"><span class="keyword">final</span> SendPort controlPort;</span><br><span class="line"></span><br><span class="line">Isolate(<span class="keyword">this</span>.controlPort, &#123;<span class="keyword">this</span>.pauseCapability, <span class="keyword">this</span>.terminateCapability&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，在Dart中，我们拿到的Isolate主要是<strong>持有一个和native中对应SendPort</strong>。</p>
<p>通过上面的分析：</p>
<ul>
<li><code>Isolate.spawn</code>最后调用了<code>_spawnFunction</code>方法（native层实现为<code>Isolate_spawnFunction</code>）；</li>
<li><code>Isolate.spawnUri</code>最后调用了<code>_spawnUri</code>方法（native层实现为<code>Isolate_spawnUri</code>）。</li>
</ul>
<blockquote>
<p>💡 <code>new RawReceivePort()</code>方法主要是创建一个不存在于<code>_RawReceivePortImpl</code>的<code>static final _portMap = &lt;int, Map&lt;String, dynamic&gt;&gt;&#123;&#125;;</code> 中的SendPort（具体实现在<code>PortMap::CreatePort</code>中）。</p>
</blockquote>
<h3 id="Isolate-spawnFunction"><a href="#Isolate-spawnFunction" class="headerlink" title="Isolate_spawnFunction"></a>Isolate_spawnFunction</h3><p><code>Isolate.spawn</code>最后调用了<code>_spawnFunction</code>方法，来看一下对应的<code>Isolate_spawnFunction</code> 的实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\lib\isolate.cc</span></span><br><span class="line"></span><br><span class="line">DEFINE_NATIVE_ENTRY(Isolate_spawnFunction, <span class="number">0</span>, <span class="number">10</span>) &#123;</span><br><span class="line"><span class="comment">// 解析参数</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// closure_tuple_handle对应我们在Dart中Isolate.spawn()中传入的entryPoint</span></span><br><span class="line">    <span class="comment">// 也就是isolate创建好以后执行的方法</span></span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;IsolateSpawnState&gt; state(<span class="keyword">new</span> IsolateSpawnState(</span><br><span class="line">      port.Id(), isolate-&gt;origin_id(), String2UTF8(script_uri),</span><br><span class="line">      closure_tuple_handle, &amp;message_buffer, utf8_package_config,</span><br><span class="line">      paused.value(), fatal_errors, on_exit_port, on_error_port,</span><br><span class="line">      utf8_debug_name, **isolate-&gt;group()**));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since this is a call to Isolate.spawn, copy the parent isolate&#x27;s code.</span></span><br><span class="line">  state-&gt;isolate_flags()-&gt;copy_parent_code = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  **isolate-&gt;group()**-&gt;thread_pool()-&gt;Run&lt;SpawnIsolateTask&gt;(isolate,</span><br><span class="line">                                                         std::move(state));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>::<span class="keyword">null</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，<code>Isolate_spawnFunction</code>方法中主要还是解析收到的各种参数，最后在当前isolate对应的IsolateGroup的线程池中执行<code>SpawnIsolateTask</code>：</p>
<h4 id="SpawnIsolateTask"><a href="#SpawnIsolateTask" class="headerlink" title="SpawnIsolateTask"></a>SpawnIsolateTask</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\lib\isolate.cc</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpawnIsolateTask</span> : <span class="title">public</span> <span class="title">ThreadPool</span>::<span class="title">Task</span> </span>&#123;</span><br><span class="line">	SpawnIsolateTask(Isolate* parent_isolate,</span><br><span class="line">                   std::unique_ptr&lt;IsolateSpawnState&gt; state)</span><br><span class="line">      : parent_isolate_(parent_isolate), state_(std::move(state)) &#123;</span><br><span class="line">    parent_isolate-&gt;IncrementSpawnCount();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> Run() override &#123;</span><br><span class="line">    <span class="keyword">const</span> char* name = (state_-&gt;debug_name() == nullptr)</span><br><span class="line">                           ? state_-&gt;function_name()</span><br><span class="line">                           : state_-&gt;debug_name();</span><br><span class="line">    ASSERT(name != nullptr);</span><br><span class="line"></span><br><span class="line">    auto group = state_-&gt;isolate_group();</span><br><span class="line">    <span class="keyword">if</span> (group == nullptr) &#123;</span><br><span class="line">      RunHeavyweight(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      RunLightweight(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RunLightWeight"><a href="#RunLightWeight" class="headerlink" title="RunLightWeight"></a>RunLightWeight</h4><p>因为这里我们的<code>isolate→group</code>不为空，所以走的是<code>RunLightWeight</code>:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\lib\isolate.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RunLightweight(<span class="keyword">const</span> char* name) &#123;</span><br><span class="line">    <span class="comment">// The create isolate initialize callback is mandatory.</span></span><br><span class="line">    auto initialize_callback = **Isolate::InitializeCallback();**</span><br><span class="line">    <span class="keyword">if</span> (initialize_callback == nullptr) &#123;</span><br><span class="line">      FailedSpawn(</span><br><span class="line">          <span class="string">&quot;Lightweight isolate spawn is not supported by this Dart embedder\n&quot;</span>,</span><br><span class="line">          <span class="comment">/*has_current_isolate=*/</span><span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* error = nullptr;</span><br><span class="line"></span><br><span class="line">    auto group = state_-&gt;isolate_group();</span><br><span class="line">    **Isolate* isolate = CreateWithinExistingIsolateGroup(group, name, &amp;error);**</span><br><span class="line">    parent_isolate_-&gt;DecrementSpawnCount();</span><br><span class="line">    parent_isolate_ = nullptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isolate == nullptr) &#123;</span><br><span class="line">      FailedSpawn(error, <span class="comment">/*has_current_isolate=*/</span><span class="keyword">false</span>);</span><br><span class="line">      free(error);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* child_isolate_data = nullptr;</span><br><span class="line">    **<span class="keyword">const</span> <span class="built_in">bool</span> success = initialize_callback(&amp;child_isolate_data, &amp;error);**</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      FailedSpawn(error);</span><br><span class="line">      Dart_ShutdownIsolate();</span><br><span class="line">      free(error);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    **isolate-&gt;set_init_callback_data(child_isolate_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的Run方法，在**RunHeavyweight方法的最后也调用了</span></span><br><span class="line">    <span class="comment">// 到时候会一起分析一下</span></span><br><span class="line">    **Run(isolate);**</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\dart_api_impl.cc</span></span><br><span class="line"></span><br><span class="line">Isolate* CreateWithinExistingIsolateGroup(IsolateGroup* group,</span><br><span class="line">                                          <span class="keyword">const</span> char* name,</span><br><span class="line">                                          char** error) &#123;</span><br><span class="line">  API_TIMELINE_DURATION(Thread::Current());</span><br><span class="line">  CHECK_NO_ISOLATE(Isolate::Current());</span><br><span class="line"></span><br><span class="line">  auto spawning_group = group;</span><br><span class="line"></span><br><span class="line">  **Isolate* isolate =** reinterpret_cast&lt;Isolate*&gt;(</span><br><span class="line">      **CreateIsolate**(spawning_group, <span class="comment">/*is_new_group=*/</span><span class="keyword">false</span>, name,</span><br><span class="line">                    <span class="comment">/*isolate_data=*/</span>nullptr, error));</span><br><span class="line">  <span class="keyword">if</span> (isolate == nullptr) <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为执行到这里的都有IsolateGroup，共享同一份代码</span></span><br><span class="line">  auto source = spawning_group-&gt;source();</span><br><span class="line">  ASSERT(isolate-&gt;source() == source);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isolate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要进行了2步：</p>
<ul>
<li>使用<code>CreateWithinExistingIsolateGroup</code>创建Isolate</li>
<li>使用全局的<code>initialize_callback</code> （也就是<code>Isolate::InitializeCallback()</code>）初始化Isolate</li>
</ul>
<h5 id="Isolate-InitializeCallback"><a href="#Isolate-InitializeCallback" class="headerlink" title="Isolate::InitializeCallback()"></a>Isolate::InitializeCallback()</h5><p>这其中的<code>Isolate::InitializeCallback()</code>是在<code>Dart::Init</code>的时候就已经设置了的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime/bin/main.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">int</span> argc, char** argv) &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Initialize the Dart VM.</span></span><br><span class="line">  Dart_InitializeParams init_params;</span><br><span class="line">	init_params.version = DART_INITIALIZE_PARAMS_CURRENT_VERSION;</span><br><span class="line">  init_params.vm_snapshot_data = vm_snapshot_data;</span><br><span class="line">  init_params.vm_snapshot_instructions = vm_snapshot_instructions;</span><br><span class="line">  **init_params.create_group = CreateIsolateGroupAndSetup;**</span><br><span class="line">  **init_params.initialize_isolate = OnIsolateInitialize;**</span><br><span class="line">  init_params.shutdown_isolate = OnIsolateShutdown;</span><br><span class="line">  init_params.cleanup_isolate = DeleteIsolateData;</span><br><span class="line">  init_params.cleanup_group = DeleteIsolateGroupData;</span><br><span class="line">  init_params.file_open = DartUtils::OpenFile;</span><br><span class="line">  init_params.file_read = DartUtils::ReadFile;</span><br><span class="line">  init_params.file_write = DartUtils::WriteFile;</span><br><span class="line">  init_params.file_close = DartUtils::CloseFile;</span><br><span class="line">  init_params.entropy_source = DartUtils::EntropySource;</span><br><span class="line"></span><br><span class="line">	error = Dart_Initialize(&amp;init_params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\dart_api_impl.cc</span></span><br><span class="line"></span><br><span class="line">DART_EXPORT char* Dart_Initialize(Dart_InitializeParams* params) &#123;</span><br><span class="line">  <span class="keyword">if</span> (params == NULL) &#123;</span><br><span class="line">    <span class="keyword">return</span> Utils::StrDup(</span><br><span class="line">        <span class="string">&quot;Dart_Initialize: &quot;</span></span><br><span class="line">        <span class="string">&quot;Dart_InitializeParams is null.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (params-&gt;version != DART_INITIALIZE_PARAMS_CURRENT_VERSION) &#123;</span><br><span class="line">    <span class="keyword">return</span> Utils::StrDup(</span><br><span class="line">        <span class="string">&quot;Dart_Initialize: &quot;</span></span><br><span class="line">        <span class="string">&quot;Invalid Dart_InitializeParams version.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Dart::Init(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\dart.cc</span></span><br><span class="line"></span><br><span class="line">char* Dart::Init(<span class="keyword">const</span> Dart_InitializeParams* params) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!init_state_.SetInitializing()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Utils::StrDup(</span><br><span class="line">        <span class="string">&quot;Bad VM initialization state, &quot;</span></span><br><span class="line">        <span class="string">&quot;already initialized or &quot;</span></span><br><span class="line">        <span class="string">&quot;multiple threads initializing the VM.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  char* retval = DartInit(params);</span><br><span class="line">  <span class="keyword">if</span> (retval != NULL) &#123;</span><br><span class="line">    init_state_.ResetInitializing();</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  init_state_.SetInitialized();</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char* Dart::DartInit(<span class="keyword">const</span> Dart_InitializeParams* params) &#123;</span><br><span class="line">...</span><br><span class="line">	OSThread::Init();</span><br><span class="line">  Zone::Init();</span><br><span class="line">	IsolateGroup::Init();</span><br><span class="line">  Isolate::InitVM();</span><br><span class="line">	PortMap::Init();</span><br><span class="line">  Service::Init();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	Thread::ExitIsolate();  <span class="comment">// Unregister the VM isolate from this thread.</span></span><br><span class="line">  **Isolate::SetCreateGroupCallback(params-&gt;create_group);**</span><br><span class="line">  **Isolate::SetInitializeCallback_(params-&gt;initialize_isolate);**</span><br><span class="line">  Isolate::SetShutdownCallback(params-&gt;shutdown_isolate);</span><br><span class="line">  Isolate::SetCleanupCallback(params-&gt;cleanup_isolate);</span><br><span class="line">  Isolate::SetGroupCleanupCallback(params-&gt;cleanup_group);</span><br><span class="line">  Isolate::SetRegisterKernelBlobCallback(params-&gt;register_kernel_blob);</span><br><span class="line">  Isolate::SetUnregisterKernelBlobCallback(params-&gt;unregister_kernel_blob);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，上文的<code>Isolate::InitializeCallback()</code>实际上就是<code>OnIsolateInitialize</code>，它的主要作用就是在isolate创建好之后进行统一的初始化操作，绑定一些数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\main.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">OnIsolateInitialize</span><span class="params">(<span class="type">void</span>** child_callback_data, <span class="type">char</span>** error)</span> </span>&#123;</span><br><span class="line">  Dart_Isolate isolate = <span class="built_in">Dart_CurrentIsolate</span>();</span><br><span class="line">  <span class="built_in">ASSERT</span>(isolate != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> isolate_group_data =</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;IsolateGroupData*&gt;(<span class="built_in">Dart_CurrentIsolateGroupData</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> isolate_data = <span class="keyword">new</span> <span class="built_in">IsolateData</span>(isolate_group_data);</span><br><span class="line">  *child_callback_data = isolate_data;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Dart_EnterScope</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> **script_uri** = isolate_group_data-&gt;script_url;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> **isolate_run_app_snapshot** =</span><br><span class="line">      isolate_group_data-&gt;<span class="built_in">RunFromAppSnapshot</span>();</span><br><span class="line">  Dart_Handle **result** = <span class="built_in">SetupCoreLibraries</span>(isolate, isolate_data,</span><br><span class="line">                                          <span class="comment">/*group_start=*/</span><span class="literal">false</span>,</span><br><span class="line">                                          <span class="comment">/*resolved_packages_config=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Dart_IsError</span>(result)) <span class="keyword">goto</span> failed;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isolate_run_app_snapshot) &#123;</span><br><span class="line">    result = Loader::<span class="built_in">InitForSnapshot</span>(script_uri, isolate_data);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dart_IsError</span>(result)) <span class="keyword">goto</span> failed;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = DartUtils::<span class="built_in">ResolveScript</span>(<span class="built_in">Dart_NewStringFromCString</span>(script_uri));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dart_IsError</span>(result)) <span class="keyword">goto</span> failed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isolate_group_data-&gt;<span class="built_in">kernel_buffer</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Various core-library parts will send requests to the Loader to resolve</span></span><br><span class="line">      <span class="comment">// relative URIs and perform other related tasks. We need Loader to be</span></span><br><span class="line">      <span class="comment">// initialized for this to work because loading from Kernel binary</span></span><br><span class="line">      <span class="comment">// bypasses normal source code loading paths that initialize it.</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* resolved_script_uri = <span class="literal">NULL</span>;</span><br><span class="line">      result = <span class="built_in">Dart_StringToCString</span>(result, &amp;resolved_script_uri);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Dart_IsError</span>(result)) <span class="keyword">goto</span> failed;</span><br><span class="line">      result = Loader::<span class="built_in">InitForSnapshot</span>(resolved_script_uri, isolate_data);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Dart_IsError</span>(result)) <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Dart_ExitScope</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">  *error = Utils::<span class="built_in">StrDup</span>(<span class="built_in">Dart_GetError</span>(result));</span><br><span class="line">  <span class="built_in">Dart_ExitScope</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="CreateWithinExistingIsolateGroup"><a href="#CreateWithinExistingIsolateGroup" class="headerlink" title="CreateWithinExistingIsolateGroup"></a>CreateWithinExistingIsolateGroup</h5><p><code>CreateWithinExistingIsolateGroup</code> → <code>CreateIsolate</code></p>
<p>再看一下创建Isolate的具体方法，这个在不同的device上面不一样，我们只关注vm下面的实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\dart_api_impl.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Dart_Isolate CreateIsolate(IsolateGroup* group,</span><br><span class="line">                                  <span class="built_in">bool</span> is_new_group,</span><br><span class="line">                                  <span class="keyword">const</span> char* name,</span><br><span class="line">                                  <span class="keyword">void</span>* isolate_data,</span><br><span class="line">                                  char** error) &#123;</span><br><span class="line">  **CHECK_NO_ISOLATE**(Isolate::Current());</span><br><span class="line"></span><br><span class="line">  auto source = group-&gt;source();</span><br><span class="line">  **Isolate* I = Dart::CreateIsolate(name, source-&gt;flags, group);**</span><br><span class="line">  <span class="keyword">if</span> (I == NULL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error != NULL) &#123;</span><br><span class="line">      *error = Utils::StrDup(<span class="string">&quot;Isolate creation failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;Dart_Isolate&gt;(NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread* T = Thread::Current();</span><br><span class="line">  <span class="built_in">bool</span> success = <span class="keyword">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    StackZone zone(T);</span><br><span class="line">    <span class="comment">// We enter an API scope here as InitializeIsolate could compile some</span></span><br><span class="line">    <span class="comment">// bootstrap library files which call out to a tag handler that may create</span></span><br><span class="line">    <span class="comment">// Api Handles when an error is encountered.</span></span><br><span class="line">    T-&gt;EnterApiScope();</span><br><span class="line">    <span class="keyword">const</span> Error&amp; error_obj = Error::Handle(</span><br><span class="line">        Z, **Dart::InitializeIsolate(</span><br><span class="line">               source-&gt;snapshot_data, source-&gt;snapshot_instructions,</span><br><span class="line">               source-&gt;kernel_buffer, source-&gt;kernel_buffer_size,</span><br><span class="line">               is_new_group ? nullptr : group, isolate_data)**);</span><br><span class="line">    <span class="keyword">if</span> (error_obj.IsNull()) &#123;</span><br><span class="line">#<span class="keyword">if</span> defined(DEBUG) &amp;&amp; !defined(DART_PRECOMPILED_RUNTIME)</span><br><span class="line">      <span class="keyword">if</span> (FLAG_check_function_fingerprints &amp;&amp; !FLAG_precompiled_mode) &#123;</span><br><span class="line">        Library::CheckFunctionFingerprints();</span><br><span class="line">      &#125;</span><br><span class="line">#endif  <span class="comment">// defined(DEBUG) &amp;&amp; !defined(DART_PRECOMPILED_RUNTIME).</span></span><br><span class="line">      success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != NULL) &#123;</span><br><span class="line">      *error = Utils::StrDup(error_obj.ToErrorCString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We exit the API scope entered above.</span></span><br><span class="line">    T-&gt;ExitApiScope();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_new_group) &#123;</span><br><span class="line">      group-&gt;heap()-&gt;InitGrowthControl();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A Thread structure has been associated to the thread, we do the</span></span><br><span class="line">    <span class="comment">// safepoint transition explicitly here instead of using the</span></span><br><span class="line">    <span class="comment">// TransitionXXX scope objects as the reverse transition happens</span></span><br><span class="line">    <span class="comment">// outside this scope in Dart_ShutdownIsolate/Dart_ExitIsolate.</span></span><br><span class="line">    T-&gt;set_execution_state(Thread::kThreadInNative);</span><br><span class="line">    T-&gt;EnterSafepoint();</span><br><span class="line">    <span class="keyword">if</span> (error != NULL) &#123;</span><br><span class="line">      *error = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Api::CastIsolate(I);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Dart::ShutdownIsolate();</span><br><span class="line">  <span class="keyword">return</span> reinterpret_cast&lt;Dart_Isolate&gt;(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有两步：</p>
<ul>
<li><code>Dart::CreateIsolate</code>创建了<code>Isolate* I</code>；</li>
<li>然后调用<code>Dart::InitializeIsolate</code>初始化isolate。</li>
</ul>
<p><strong>Dart::CreateIsolate：</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\dart.cc</span></span><br><span class="line"></span><br><span class="line">Isolate* Dart::CreateIsolate(<span class="keyword">const</span> char* name_prefix,</span><br><span class="line">                             <span class="keyword">const</span> Dart_IsolateFlags&amp; api_flags,</span><br><span class="line">                             IsolateGroup* isolate_group) &#123;</span><br><span class="line">  <span class="comment">// Create a new isolate.</span></span><br><span class="line">  Isolate* isolate =</span><br><span class="line">      Isolate::InitIsolate(name_prefix, isolate_group, api_flags);</span><br><span class="line">  <span class="keyword">return</span> isolate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>💡 在Dart虚拟机启动（<code>Dart::DartInit</code>）的时候，也会调用<code>Dart::InitIsolate</code>创建虚拟机对应的Isolate，执行UI操作：<br><code>vm_isolate_ = Isolate::InitIsolate(kVmIsolateName, group, api_flags, is_vm_isolate);</code></p>
</blockquote>
<p>在<code>Isolate::InitIsolate</code>方法中，先是用<code>isolate_group</code>创建了新的Isolate，然后将其与<code>Thread</code>，<code>MessageHandler</code>，<code>SendPort</code>等绑定：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\isolate.cc</span></span><br><span class="line"></span><br><span class="line">Isolate* Isolate::InitIsolate(<span class="keyword">const</span> char* name_prefix,</span><br><span class="line">                              IsolateGroup* isolate_group,</span><br><span class="line">                              <span class="keyword">const</span> Dart_IsolateFlags&amp; api_flags,</span><br><span class="line">                              <span class="built_in">bool</span> is_vm_isolate) &#123;</span><br><span class="line">	<span class="comment">// 创建新的Isolate</span></span><br><span class="line">  **Isolate* result = <span class="keyword">new</span> Isolate(isolate_group, api_flags);**</span><br><span class="line">  result-&gt;BuildName(name_prefix);</span><br><span class="line">  <span class="keyword">if</span> (!is_vm_isolate) &#123;</span><br><span class="line">    <span class="comment">// vm isolate object store is initialized later, after null instance</span></span><br><span class="line">    <span class="comment">// is created (in Dart::Init).</span></span><br><span class="line">    <span class="comment">// Non-vm isolates need to have isolate object store initialized is that</span></span><br><span class="line">    <span class="comment">// exit_listeners have to be null-initialized as they will be used if</span></span><br><span class="line">    <span class="comment">// we fail to create isolate below, have to do low level shutdown.</span></span><br><span class="line">    ASSERT(result-&gt;group()-&gt;object_store() != nullptr);</span><br><span class="line">    result-&gt;isolate_object_store()-&gt;Init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ASSERT(result != nullptr);</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> !defined(PRODUCT)</span><br><span class="line"><span class="comment">// Initialize metrics.</span></span><br><span class="line">#define ISOLATE_METRIC_INIT(type, variable, name, unit)                        \</span><br><span class="line">  result-&gt;metric_##variable##_.InitInstance(result, name, NULL, Metric::unit);</span><br><span class="line">  ISOLATE_METRIC_LIST(ISOLATE_METRIC_INIT);</span><br><span class="line">#undef ISOLATE_METRIC_INIT</span><br><span class="line">#endif  <span class="comment">// !defined(PRODUCT)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// First we ensure we enter the isolate. This will ensure we&#x27;re participating</span></span><br><span class="line">  <span class="comment">// in any safepointing requests from this point on. Other threads requesting a</span></span><br><span class="line">  <span class="comment">// safepoint operation will therefore wait until we&#x27;ve stopped.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Though the [result] isolate is still in a state where no memory has been</span></span><br><span class="line">  <span class="comment">// allocated, which means it&#x27;s safe to GC the isolate group until here.</span></span><br><span class="line">  <span class="comment">// 创建一个Thread并和当前isolate绑定</span></span><br><span class="line">  <span class="keyword">if</span> (!**Thread::EnterIsolate(result)**) &#123;</span><br><span class="line">    delete result;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup the isolate message handler.</span></span><br><span class="line">  MessageHandler* handler = <span class="keyword">new</span> IsolateMessageHandler(result);</span><br><span class="line">  ASSERT(handler != nullptr);</span><br><span class="line">	<span class="comment">// 在这里绑定了message handler</span></span><br><span class="line">  **result-&gt;set_message_handler(handler);**</span><br><span class="line"></span><br><span class="line">  **result-&gt;set_main_port(PortMap::CreatePort(result-&gt;message_handler()));**</span><br><span class="line">#<span class="keyword">if</span> defined(DEBUG)</span><br><span class="line">  <span class="comment">// Verify that we are never reusing a live origin id.</span></span><br><span class="line">  VerifyOriginId id_verifier(result-&gt;main_port());</span><br><span class="line">  Isolate::VisitIsolates(&amp;id_verifier);</span><br><span class="line">#endif</span><br><span class="line">  result-&gt;set_origin_id(result-&gt;main_port());</span><br><span class="line">  result-&gt;set_pause_capability(result-&gt;random()-&gt;NextUInt64());</span><br><span class="line">  result-&gt;set_terminate_capability(result-&gt;random()-&gt;NextUInt64());</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> !defined(PRODUCT)</span><br><span class="line">  result-&gt;debugger_ = <span class="keyword">new</span> Debugger(result);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we register the isolate in the group. From this point on any GC would</span></span><br><span class="line">  <span class="comment">// traverse the isolate roots (before this point, the roots are only pointing</span></span><br><span class="line">  <span class="comment">// to vm-isolate objects, e.g. null)</span></span><br><span class="line">  **isolate_group-&gt;RegisterIsolate(result);**</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ServiceIsolate::NameEquals(name_prefix)) &#123;</span><br><span class="line">    ASSERT(!ServiceIsolate::Exists());</span><br><span class="line">    ServiceIsolate::SetServiceIsolate(result);</span><br><span class="line">#<span class="keyword">if</span> !defined(DART_PRECOMPILED_RUNTIME)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KernelIsolate::NameEquals(name_prefix)) &#123;</span><br><span class="line">    ASSERT(!KernelIsolate::Exists());</span><br><span class="line">    KernelIsolate::SetKernelIsolate(result);</span><br><span class="line">#endif  <span class="comment">// !defined(DART_PRECOMPILED_RUNTIME)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_trace_isolates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name_prefix == nullptr || strcmp(name_prefix, <span class="string">&quot;vm-isolate&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      OS::PrintErr(</span><br><span class="line">          <span class="string">&quot;[+] Starting isolate:\n&quot;</span></span><br><span class="line">          <span class="string">&quot;\tisolate:    %s\n&quot;</span>,</span><br><span class="line">          result-&gt;name());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add to isolate list. Shutdown and delete the isolate on failure.</span></span><br><span class="line">  <span class="keyword">if</span> (!TryMarkIsolateReady(result)) &#123;</span><br><span class="line">    result-&gt;LowLevelShutdown();</span><br><span class="line">    Isolate::LowLevelCleanup(result);</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Dart::InitializeIsolate</strong></p>
<p>这里主要是对isolate进行初始化，并在初始化完成后通知创建这个isolate的isolate。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\dart.cc</span></span><br><span class="line"></span><br><span class="line">ErrorPtr Dart::InitializeIsolate(<span class="keyword">const</span> uint8_t* snapshot_data,</span><br><span class="line">                                 <span class="keyword">const</span> uint8_t* snapshot_instructions,</span><br><span class="line">                                 <span class="keyword">const</span> uint8_t* kernel_buffer,</span><br><span class="line">                                 intptr_t kernel_buffer_size,</span><br><span class="line">                                 IsolateGroup* source_isolate_group,</span><br><span class="line">                                 <span class="keyword">void</span>* isolate_data) &#123;</span><br><span class="line">  <span class="comment">// Initialize the new isolate.</span></span><br><span class="line">  Thread* T = Thread::Current();</span><br><span class="line">  Isolate* I = T-&gt;isolate();</span><br><span class="line">  auto IG = T-&gt;isolate_group();</span><br><span class="line">#<span class="keyword">if</span> defined(SUPPORT_TIMELINE)</span><br><span class="line">  TimelineBeginEndScope tbes(T, Timeline::GetIsolateStream(),</span><br><span class="line">                             <span class="string">&quot;InitializeIsolate&quot;</span>);</span><br><span class="line">  tbes.SetNumArguments(<span class="number">1</span>);</span><br><span class="line">  tbes.CopyArgument(<span class="number">0</span>, <span class="string">&quot;isolateName&quot;</span>, I-&gt;name());</span><br><span class="line">#endif</span><br><span class="line">  ASSERT(I != NULL);</span><br><span class="line">  StackZone zone(T);</span><br><span class="line">  HandleScope handle_scope(T);</span><br><span class="line">  <span class="built_in">bool</span> was_child_cloned_into_existing_isolate = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (source_isolate_group != nullptr) &#123;</span><br><span class="line">    <span class="comment">// If a static field gets registered in [IsolateGroup::RegisterStaticField]:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   * before this block it will ignore this isolate. The [Clone] of the</span></span><br><span class="line">    <span class="comment">//     initial field table will pick up the new value.</span></span><br><span class="line">    <span class="comment">//   * after this block it will add the new static field to this isolate.</span></span><br><span class="line">    &#123;</span><br><span class="line">      SafepointReadRwLocker reader(T, source_isolate_group-&gt;program_lock());</span><br><span class="line">      **I-&gt;set_field_table**(T,</span><br><span class="line">                         source_isolate_group-&gt;initial_field_table()-&gt;Clone(I));</span><br><span class="line">      **I-&gt;field_table()-&gt;MarkReadyToUse();**</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    was_child_cloned_into_existing_isolate = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Error&amp; error = Error::Handle(</span><br><span class="line">				<span class="comment">// 从IsolateGroup中引用一些通用的变量（常量等等）</span></span><br><span class="line">        **InitIsolateFromSnapshot**(T, I, snapshot_data, snapshot_instructions,</span><br><span class="line">                                kernel_buffer, kernel_buffer_size));</span><br><span class="line">    <span class="keyword">if</span> (!error.IsNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> error.ptr();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>::VerifyBuiltinVtables();</span><br><span class="line">  <span class="keyword">if</span> (T-&gt;isolate()-&gt;origin_id() == <span class="number">0</span>) &#123;</span><br><span class="line">    DEBUG_ONLY(IG-&gt;heap()-&gt;Verify(kForbidMarked));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(DART_PRECOMPILED_RUNTIME)</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">bool</span> kIsAotRuntime = <span class="keyword">true</span>;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">bool</span> kIsAotRuntime = <span class="keyword">false</span>;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (kIsAotRuntime || was_child_cloned_into_existing_isolate) &#123;</span><br><span class="line">#<span class="keyword">if</span> !defined(TARGET_ARCH_IA32)</span><br><span class="line">    ASSERT(IG-&gt;object_store()-&gt;build_generic_method_extractor_code() !=</span><br><span class="line">           Code::<span class="keyword">null</span>());</span><br><span class="line">    ASSERT(IG-&gt;object_store()-&gt;build_nongeneric_method_extractor_code() !=</span><br><span class="line">           Code::<span class="keyword">null</span>());</span><br><span class="line">#endif</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> !defined(TARGET_ARCH_IA32)</span><br><span class="line">    <span class="keyword">if</span> (I != Dart::vm_isolate()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (IG-&gt;object_store()-&gt;build_generic_method_extractor_code() !=</span><br><span class="line">          nullptr) &#123;</span><br><span class="line">        SafepointWriteRwLocker ml(T, IG-&gt;program_lock());</span><br><span class="line">        <span class="keyword">if</span> (IG-&gt;object_store()-&gt;build_generic_method_extractor_code() !=</span><br><span class="line">            nullptr) &#123;</span><br><span class="line">          IG-&gt;object_store()-&gt;set_build_generic_method_extractor_code(</span><br><span class="line">              Code::Handle(</span><br><span class="line">                  StubCode::GetBuildGenericMethodExtractorStub(nullptr)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (IG-&gt;object_store()-&gt;build_nongeneric_method_extractor_code() !=</span><br><span class="line">          nullptr) &#123;</span><br><span class="line">        SafepointWriteRwLocker ml(T, IG-&gt;program_lock());</span><br><span class="line">        <span class="keyword">if</span> (IG-&gt;object_store()-&gt;build_nongeneric_method_extractor_code() !=</span><br><span class="line">            nullptr) &#123;</span><br><span class="line">          IG-&gt;object_store()-&gt;set_build_nongeneric_method_extractor_code(</span><br><span class="line">              Code::Handle(</span><br><span class="line">                  StubCode::GetBuildNonGenericMethodExtractorStub(nullptr)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif  <span class="comment">// !defined(TARGET_ARCH_IA32)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  I-&gt;set_ic_miss_code(StubCode::SwitchableCallMiss());</span><br><span class="line"></span><br><span class="line">  Error&amp; error = Error::Handle();</span><br><span class="line">  <span class="keyword">if</span> (snapshot_data == nullptr || kernel_buffer != nullptr) &#123;</span><br><span class="line">    error ^= IG-&gt;object_store()-&gt;PreallocateObjects();</span><br><span class="line">    <span class="keyword">if</span> (!error.IsNull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> error.ptr();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> auto&amp; out_of_memory =</span><br><span class="line">      <span class="built_in">Object</span>::Handle(IG-&gt;object_store()-&gt;out_of_memory());</span><br><span class="line">  error ^= I-&gt;isolate_object_store()-&gt;PreallocateObjects(out_of_memory);</span><br><span class="line">  <span class="keyword">if</span> (!error.IsNull()) &#123;</span><br><span class="line">    <span class="keyword">return</span> error.ptr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!was_child_cloned_into_existing_isolate) &#123;</span><br><span class="line">    IG-&gt;heap()-&gt;InitGrowthControl();</span><br><span class="line">  &#125;</span><br><span class="line">  I-&gt;set_init_callback_data(isolate_data);</span><br><span class="line">  <span class="keyword">if</span> (FLAG_print_class_table) &#123;</span><br><span class="line">    IG-&gt;class_table()-&gt;Print();</span><br><span class="line">  &#125;</span><br><span class="line">#<span class="keyword">if</span> !defined(PRODUCT)</span><br><span class="line">  ServiceIsolate::MaybeMakeServiceIsolate(I);</span><br><span class="line">  <span class="keyword">if</span> (!Isolate::IsSystemIsolate(I)) &#123;</span><br><span class="line">    I-&gt;message_handler()-&gt;set_should_pause_on_start(</span><br><span class="line">        FLAG_pause_isolates_on_start);</span><br><span class="line">    I-&gt;message_handler()-&gt;set_should_pause_on_exit(FLAG_pause_isolates_on_exit);</span><br><span class="line">  &#125;</span><br><span class="line">#endif  <span class="comment">// !defined(PRODUCT)</span></span><br><span class="line"></span><br><span class="line">  ServiceIsolate::SendIsolateStartupMessage();</span><br><span class="line">#<span class="keyword">if</span> !defined(PRODUCT)</span><br><span class="line">  I-&gt;debugger()-&gt;NotifyIsolateCreated();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create tag table.</span></span><br><span class="line">  I-&gt;set_tag_table(GrowableObjectArray::Handle(GrowableObjectArray::New()));</span><br><span class="line">  <span class="comment">// Set up default UserTag.</span></span><br><span class="line">  <span class="keyword">const</span> UserTag&amp; default_tag = UserTag::Handle(UserTag::DefaultTag());</span><br><span class="line">  I-&gt;set_current_tag(default_tag);</span><br><span class="line"></span><br><span class="line">  I-&gt;init_loaded_prefixes_set_storage();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Error::<span class="keyword">null</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，如果是调用<code>Isolate.spawn()</code>的话，先从当前isolate获取对应的Isolate Group，然后使用这个Isolate Group创建配置一个新的isolate，这样在同一个isolate group中的Isolate可以共享常量，heap等。</p>
<h3 id="Isolate-spawnUri"><a href="#Isolate-spawnUri" class="headerlink" title="Isolate_spawnUri"></a>Isolate_spawnUri</h3><p>如果是使用<code>Isolate.spawnUri()</code>的话，就会通过<code>Isolate_spawnUri</code>来创建isolate。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\lib\isolate.cc</span></span><br><span class="line"></span><br><span class="line">	DEFINE_NATIVE_ENTRY(Isolate_spawnUri, <span class="number">0</span>, <span class="number">12</span>) &#123;</span><br><span class="line"><span class="comment">// 解析参数</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Canonicalize the uri with respect to the current isolate.</span></span><br><span class="line">  <span class="keyword">const</span> Library&amp; root_lib =</span><br><span class="line">      Library::Handle(isolate-&gt;group()-&gt;object_store()-&gt;root_library());</span><br><span class="line">  char* error = NULL;</span><br><span class="line"><span class="comment">// 获取canonical_uri </span></span><br><span class="line">  <span class="keyword">const</span> char* **canonical_uri = CanonicalizeUri**(thread, root_lib, uri, &amp;error);</span><br><span class="line">  <span class="keyword">if</span> (canonical_uri == NULL) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">String</span>&amp; msg = <span class="built_in">String</span>::Handle(<span class="built_in">String</span>::New(error));</span><br><span class="line">    ThrowIsolateSpawnException(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> char* utf8_package_config =</span><br><span class="line">      packageConfig.IsNull() ? NULL : String2UTF8(packageConfig);</span><br><span class="line">  <span class="keyword">const</span> char* utf8_debug_name =</span><br><span class="line">      debugName.IsNull() ? NULL : String2UTF8(debugName);</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;IsolateSpawnState&gt; state(<span class="keyword">new</span> **IsolateSpawnState**(</span><br><span class="line">      port.Id(), canonical_uri, utf8_package_config, &amp;arguments_buffer,</span><br><span class="line">      &amp;message_buffer, paused.value(), fatal_errors, on_exit_port,</span><br><span class="line">			<span class="comment">// 注意下面这里的group=nullptr</span></span><br><span class="line">      on_error_port, utf8_debug_name, **<span class="comment">/*group=*/</span>nullptr**));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we were passed a value then override the default flags state for</span></span><br><span class="line">  <span class="comment">// checked mode.</span></span><br><span class="line">  <span class="keyword">if</span> (!checked.IsNull()) &#123;</span><br><span class="line">    Dart_IsolateFlags* flags = state-&gt;isolate_flags();</span><br><span class="line">    flags-&gt;enable_asserts = checked.value();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since this is a call to Isolate.spawnUri, don&#x27;t copy the parent&#x27;s code.</span></span><br><span class="line">  state-&gt;isolate_flags()-&gt;copy_parent_code = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  isolate-&gt;group()-&gt;thread_pool()-&gt;**Run&lt;SpawnIsolateTask&gt;**(isolate,</span><br><span class="line">                                                         std::move(state));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>::<span class="keyword">null</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>Isolate_spawnUri</code>还是执行了<code>SpawnIsolateTask</code> 。</p>
<h4 id="SpawnIsolateTask-1"><a href="#SpawnIsolateTask-1" class="headerlink" title="SpawnIsolateTask"></a>SpawnIsolateTask</h4><p>在<code>SpawnIsolateTask.Run</code>方法中，因为<code>spawnUri</code>中<code>IsolateSpawnState</code>的<code>IsolateGroup</code>为<code>nulltrp</code>，所以这里执行的是<code>RunHeavyweight(name)</code>：</p>
<h4 id="RunHeavyweight"><a href="#RunHeavyweight" class="headerlink" title="RunHeavyweight"></a>RunHeavyweight</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpawnIsolateTask</span> : <span class="title">public</span> <span class="title">ThreadPool</span>::<span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Run() override &#123;</span><br><span class="line">    <span class="keyword">const</span> char* name = (state_-&gt;debug_name() == nullptr)</span><br><span class="line">                           ? state_-&gt;function_name()</span><br><span class="line">                           : state_-&gt;debug_name();</span><br><span class="line">    ASSERT(name != nullptr);</span><br><span class="line"></span><br><span class="line">    auto group = state_-&gt;isolate_group();</span><br><span class="line">    <span class="keyword">if</span> (group == nullptr) &#123;</span><br><span class="line">      **RunHeavyweight(name);**</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      RunLightweight(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RunHeavyweight(<span class="keyword">const</span> char* name) &#123;</span><br><span class="line">    <span class="comment">// The create isolate group callback is mandatory.  If not provided we</span></span><br><span class="line">    <span class="comment">// cannot spawn isolates.</span></span><br><span class="line">		<span class="comment">// 在Dart::DartInit中已经被设置，在Isolate创建时会被回调</span></span><br><span class="line">    **auto create_group_callback = Isolate::CreateGroupCallback();**</span><br><span class="line">    <span class="keyword">if</span> (create_group_callback == nullptr) &#123;</span><br><span class="line">      FailedSpawn(<span class="string">&quot;Isolate spawn is not supported by this Dart embedder\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* error = nullptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a copy of the state&#x27;s isolate flags and hand it to the callback.</span></span><br><span class="line">    Dart_IsolateFlags api_flags = *(state_-&gt;isolate_flags());</span><br><span class="line">    api_flags.is_system_isolate = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 创建isolate</span></span><br><span class="line">    **Dart_Isolate isolate =</span><br><span class="line">        (create_group_callback)(state_-&gt;script_url(), name, nullptr,</span><br><span class="line">                                state_-&gt;package_config(), &amp;api_flags,</span><br><span class="line">                                parent_isolate_-&gt;init_callback_data(), &amp;error);**</span><br><span class="line">    parent_isolate_-&gt;DecrementSpawnCount();</span><br><span class="line">    parent_isolate_ = nullptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isolate == nullptr) &#123;</span><br><span class="line">      FailedSpawn(error, <span class="comment">/*has_current_isolate=*/</span><span class="keyword">false</span>);</span><br><span class="line">      free(error);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 切换到指定的isolate</span></span><br><span class="line">    Dart_EnterIsolate(isolate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里也调用了Run方法</span></span><br><span class="line">    **Run(reinterpret_cast&lt;Isolate*&gt;(isolate));**</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要创建Isolate的过程在<code>Isolate::CreateGroupCallback();</code>中，让我们看一下他是怎么来的：</p>
<h4 id="Isolate-CreateGroupCallback"><a href="#Isolate-CreateGroupCallback" class="headerlink" title="Isolate::CreateGroupCallback()"></a>Isolate::CreateGroupCallback()</h4><p>他和上述<code>Isolate::InitializeCallback_</code>的来源一致，都是在<code>Dart_Initialize</code>中配置的，此外，还使用了<code>parent_isolate_-&gt;init_callback_data()</code>。</p>
<p>先看一下的<code>CreateIsolateGroupAndSetup</code>实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\main.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Dart_Isolate CreateIsolateGroupAndSetup(<span class="keyword">const</span> char* script_uri,</span><br><span class="line">                                               <span class="keyword">const</span> char* main,</span><br><span class="line">                                               <span class="keyword">const</span> char* package_root,</span><br><span class="line">                                               <span class="keyword">const</span> char* package_config,</span><br><span class="line">                                               Dart_IsolateFlags* flags,</span><br><span class="line">                                               <span class="keyword">void</span>* callback_data,</span><br><span class="line">                                               char** error) &#123;</span><br><span class="line">  <span class="comment">// The VM should never call the isolate helper with a NULL flags.</span></span><br><span class="line">  ASSERT(flags != NULL);</span><br><span class="line">  ASSERT(flags-&gt;version == DART_FLAGS_CURRENT_VERSION);</span><br><span class="line">  ASSERT(package_root == nullptr);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> dontneed_safe = <span class="keyword">true</span>;</span><br><span class="line">#<span class="keyword">if</span> defined(DART_HOST_OS_LINUX)</span><br><span class="line">  <span class="comment">// This would also be true in Linux, except that Google3 overrides the default</span></span><br><span class="line">  <span class="comment">// ELF interpreter to one that apparently doesn&#x27;t create proper mappings.</span></span><br><span class="line">  dontneed_safe = <span class="keyword">false</span>;</span><br><span class="line">#elif defined(DEBUG)</span><br><span class="line">  <span class="comment">// If the snapshot isn&#x27;t file-backed, madvise(DONT_NEED) is destructive.</span></span><br><span class="line">  <span class="keyword">if</span> (Options::force_load_elf_from_memory()) &#123;</span><br><span class="line">    dontneed_safe = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">  flags-&gt;snapshot_is_dontneed_safe = dontneed_safe;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> exit_code = <span class="number">0</span>;</span><br><span class="line">#<span class="keyword">if</span> !defined(EXCLUDE_CFE_AND_KERNEL_PLATFORM)</span><br><span class="line">  <span class="keyword">if</span> (strcmp(script_uri, DART_KERNEL_ISOLATE_NAME) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> **CreateAndSetupKernelIsolate**(script_uri, package_config, flags, error,</span><br><span class="line">                                       &amp;exit_code);</span><br><span class="line">  &#125;</span><br><span class="line">#endif  <span class="comment">// !defined(EXCLUDE_CFE_AND_KERNEL_PLATFORM)</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> !defined(DART_PRECOMPILED_RUNTIME)</span><br><span class="line">  <span class="keyword">if</span> (strcmp(script_uri, DART_DEV_ISOLATE_NAME) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> **CreateAndSetupDartDevIsolate**(script_uri, package_config, flags,</span><br><span class="line">                                        error, &amp;exit_code);</span><br><span class="line">  &#125;</span><br><span class="line">#endif  <span class="comment">// !defined(DART_PRECOMPILED_RUNTIME)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (strcmp(script_uri, DART_VM_SERVICE_ISOLATE_NAME) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> **CreateAndSetupServiceIsolate**(script_uri, package_config, flags,</span><br><span class="line">                                        error, &amp;exit_code);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> is_main_isolate = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> **CreateIsolateGroupAndSetupHelper**(is_main_isolate, script_uri, main,</span><br><span class="line">                                          package_config, flags, callback_data,</span><br><span class="line">                                          error, &amp;exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建Isolate的时候，区分了几种情况：</p>
<ul>
<li>如果是kernel-service（<code>DART_KERNEL_ISOLATE_NAME</code>）就执行<code>CreateAndSetupKernelIsolate</code></li>
<li>如果是dartdev（<code>DART_DEV_ISOLATE_NAME</code>）就执行<code>CreateAndSetupDartDevIsolate</code></li>
<li>如果是vm-service（<code>DART_VM_SERVICE_ISOLATE_NAME</code>）就执行<code>CreateAndSetupServiceIsolate</code></li>
<li>如果以上都不满足，就执行<code>CreateIsolateGroupAndSetupHelper</code></li>
</ul>
<p>显然,当我们在Dart代码中调用<code>Isolate.spawnUri</code>的时候，这里会执行的是<code>CreateIsolateGroupAndSetupHelper</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\main.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line">	<span class="type">bool</span> is_main_isolate = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CreateIsolateGroupAndSetupHelper</span>(is_main_isolate, script_uri, main,</span><br><span class="line">                                          package_config, flags, callback_data,</span><br><span class="line">                                          error, &amp;exit_code);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns newly created Isolate on success, NULL on failure.</span></span><br><span class="line"><span class="function"><span class="type">static</span> Dart_Isolate <span class="title">CreateIsolateGroupAndSetupHelper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">bool</span> is_main_isolate,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* script_uri,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* name,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* packages_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    Dart_IsolateFlags* flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* callback_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span>** error,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>* exit_code)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 根据是AOT还是JIT获取kernel_buffer，app_snapshot，isolate_run_app_snapshot等数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DART_PRECOMPILED_RUNTIME)&#123;</span></span><br><span class="line"><span class="comment">// AOT: All isolates need to be run from AOT compiled snapshots.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>&#123;</span></span><br><span class="line">	<span class="comment">// JIT: Main isolate starts from the app snapshot, if any. Other isolates</span></span><br><span class="line">  <span class="comment">// use the core libraries snapshot.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建isolate_group_data</span></span><br><span class="line">	<span class="keyword">auto</span> isolate_group_data = <span class="keyword">new</span> <span class="built_in">IsolateGroupData</span>(</span><br><span class="line">      script_uri, packages_config, app_snapshot, isolate_run_app_snapshot);</span><br><span class="line">	<span class="comment">// copy_parent_code为true的话，这里的kernel_buffer为NULL</span></span><br><span class="line">  <span class="keyword">if</span> (kernel_buffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kernel_buffer_ptr) &#123;</span><br><span class="line">      isolate_group_data-&gt;<span class="built_in">SetKernelBufferAlreadyOwned</span>(</span><br><span class="line">          std::<span class="built_in">move</span>(kernel_buffer_ptr), kernel_buffer_size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isolate_group_data-&gt;<span class="built_in">SetKernelBufferNewlyOwned</span>(kernel_buffer,</span><br><span class="line">                                                    kernel_buffer_size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	Dart_Isolate isolate = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  IsolateData* isolate_data = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(DART_PRECOMPILED_RUNTIME)</span></span><br><span class="line">  <span class="keyword">if</span> (!isolate_run_app_snapshot &amp;&amp; (isolate_snapshot_data == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* platform_kernel_buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">intptr_t</span> platform_kernel_buffer_size = <span class="number">0</span>;</span><br><span class="line">    dfe.<span class="built_in">LoadPlatform</span>(&amp;platform_kernel_buffer, &amp;platform_kernel_buffer_size);</span><br><span class="line">    <span class="keyword">if</span> (platform_kernel_buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      platform_kernel_buffer = kernel_buffer;</span><br><span class="line">      platform_kernel_buffer_size = kernel_buffer_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (platform_kernel_buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(EXCLUDE_CFE_AND_KERNEL_PLATFORM)</span></span><br><span class="line">      <span class="built_in">FATAL</span>(</span><br><span class="line">          <span class="string">&quot;Binary built with --exclude-kernel-service. Cannot run&quot;</span></span><br><span class="line">          <span class="string">&quot; from source.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;platform_program cannot be NULL.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(EXCLUDE_CFE_AND_KERNEL_PLATFORM)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(sivachandra): When the platform program is unavailable, check if</span></span><br><span class="line">    <span class="comment">// application kernel binary is self contained or an incremental binary.</span></span><br><span class="line">    <span class="comment">// Isolate should be created only if it is a self contained kernel binary.</span></span><br><span class="line">    isolate_data = <span class="keyword">new</span> <span class="built_in">IsolateData</span>(isolate_group_data);</span><br><span class="line">    isolate = <span class="built_in">Dart_CreateIsolateGroupFromKernel</span>(</span><br><span class="line">        script_uri, name, platform_kernel_buffer, platform_kernel_buffer_size,</span><br><span class="line">        flags, isolate_group_data, isolate_data, error);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isolate_data = <span class="keyword">new</span> <span class="built_in">IsolateData</span>(isolate_group_data);</span><br><span class="line">		<span class="comment">// Creates a new isolate. The new isolate becomes the current isolate.</span></span><br><span class="line">    isolate = <span class="built_in">Dart_CreateIsolateGroup</span>(script_uri, name, isolate_snapshot_data,</span><br><span class="line">                                      isolate_snapshot_instructions, flags,</span><br><span class="line">                                      isolate_group_data, isolate_data, error);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  **isolate_data = <span class="keyword">new</span> IsolateData**(isolate_group_data);</span><br><span class="line">	<span class="comment">// Creates a new isolate. The new isolate becomes the current isolate.</span></span><br><span class="line">  **isolate = Dart_CreateIsolateGroup**(script_uri, name, isolate_snapshot_data,</span><br><span class="line">                                    isolate_snapshot_instructions, flags,</span><br><span class="line">                                    **isolate_group_data**, **isolate_data**, error);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(DART_PRECOMPILED_RUNTIME)</span></span></span><br><span class="line"></span><br><span class="line">  Dart_Isolate created_isolate = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (isolate == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> isolate_data;</span><br><span class="line">    <span class="keyword">delete</span> isolate_group_data;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    **created_isolate = IsolateSetupHelper**(</span><br><span class="line">        isolate, is_main_isolate, script_uri, packages_config,</span><br><span class="line">        isolate_run_app_snapshot, flags, error, exit_code);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int64_t</span> end = <span class="built_in">Dart_TimelineGetMicros</span>();</span><br><span class="line">  <span class="built_in">Dart_TimelineEvent</span>(<span class="string">&quot;CreateIsolateGroupAndSetupHelper&quot;</span>, start, end,</span><br><span class="line">                     Dart_Timeline_Event_Duration, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> created_isolate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，<code>CreateIsolateGroupAndSetupHelper</code>按照是JIT还是AOT的编译方式，有不同的获取数据的方式，但不管哪种方式，最后都执行了一下三步：</p>
<ul>
<li>创建<code>IsolateData* isolate_data</code> 使用<code>isolate_group_data</code>创建IsolateData</li>
<li>创建<code>Dart_Isolate isolate</code> 创建<code>Dart_Isolate</code>，将<code>script_uri</code>，<code>isolate_data</code>，和<code>isolate_group_data</code>等绑定</li>
<li>创建并返回<code>Dart_Isolate created_isolate</code>包装<code>isolate</code> ，进行数据绑定，并将isolate标记为<code>runnable</code></li>
</ul>
<h5 id="Dart-CreateIsolateGroup"><a href="#Dart-CreateIsolateGroup" class="headerlink" title="Dart_CreateIsolateGroup"></a>Dart_CreateIsolateGroup</h5><p>这里分析一下**<code>Dart_CreateIsolateGroup</code>的过程：**</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --&gt; runtime/vm/dart_api_impl.cc#L1371</span></span><br><span class="line"></span><br><span class="line">DART_EXPORT Dart_Isolate</span><br><span class="line">Dart_CreateIsolateGroup(<span class="keyword">const</span> char* script_uri,</span><br><span class="line">                        <span class="keyword">const</span> char* name,</span><br><span class="line">                        <span class="keyword">const</span> uint8_t* snapshot_data,</span><br><span class="line">                        <span class="keyword">const</span> uint8_t* snapshot_instructions,</span><br><span class="line">                        Dart_IsolateFlags* flags,</span><br><span class="line">                        <span class="keyword">void</span>* isolate_group_data,</span><br><span class="line">                        <span class="keyword">void</span>* isolate_data,</span><br><span class="line">                        char** error) &#123;</span><br><span class="line">  API_TIMELINE_DURATION(Thread::Current());</span><br><span class="line"></span><br><span class="line">  Dart_IsolateFlags api_flags;</span><br><span class="line">  <span class="keyword">if</span> (flags == nullptr) &#123;</span><br><span class="line">    Isolate::FlagsInitialize(&amp;api_flags);</span><br><span class="line">    flags = &amp;api_flags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> char* non_null_name = name == nullptr ? <span class="string">&quot;isolate&quot;</span> : name;</span><br><span class="line">  std::unique_ptr&lt;IsolateGroupSource&gt; source(</span><br><span class="line">      <span class="keyword">new</span> IsolateGroupSource(script_uri, non_null_name, snapshot_data,</span><br><span class="line">                             snapshot_instructions, nullptr, <span class="number">-1</span>, *flags));</span><br><span class="line">  <span class="comment">// 创建Isolate Group</span></span><br><span class="line">  auto group = <span class="keyword">new</span> IsolateGroup(std::move(source), isolate_group_data, *flags);</span><br><span class="line">  <span class="comment">// 创建Isolate Group持有的Heap，由所有在这个Isolate Group下的isolate共享</span></span><br><span class="line">  group-&gt;CreateHeap(</span><br><span class="line">      <span class="comment">/*is_vm_isolate=*/</span><span class="keyword">false</span>, IsServiceOrKernelIsolateName(non_null_name));</span><br><span class="line">  IsolateGroup::RegisterIsolateGroup(group);</span><br><span class="line">  <span class="comment">// 根据刚刚创建的Isolate Group创建Isolate</span></span><br><span class="line">  Dart_Isolate isolate = CreateIsolate(group, <span class="comment">/*is_new_group=*/</span><span class="keyword">true</span>,</span><br><span class="line">                                       non_null_name, isolate_data, error);</span><br><span class="line">  <span class="keyword">if</span> (isolate != nullptr) &#123;</span><br><span class="line">    group-&gt;set_initial_spawn_successful();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isolate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Run-Isolate-child"><a href="#Run-Isolate-child" class="headerlink" title="Run(Isolate* child)"></a>Run(Isolate* child)</h3><p>在上面的分析中，我们注意到，无论是<code>RunHeavyweight(const char* name)</code>还是<code>RunLightweight(const char* name)</code>方法，最后在创建了新的isolate之后，都执行了<code>Run(Isolate* child)</code>方法，在这里正式启动了isolate：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\lib\isolate.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(Isolate* child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnsureIsRunnable</span>(child)) &#123;</span><br><span class="line">      <span class="built_in">Dart_ShutdownIsolate</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state_-&gt;<span class="built_in">set_isolate</span>(child);</span><br><span class="line">    <span class="keyword">if</span> (state_-&gt;<span class="built_in">origin_id</span>() != ILLEGAL_PORT) &#123;</span><br><span class="line">      <span class="comment">// origin_id is set to parent isolate main port id when spawning via</span></span><br><span class="line">      <span class="comment">// spawnFunction.</span></span><br><span class="line">      child-&gt;<span class="built_in">set_origin_id</span>(state_-&gt;<span class="built_in">origin_id</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    &#123;</span><br><span class="line">			<span class="keyword">auto</span> thread = Thread::<span class="built_in">Current</span>();</span><br><span class="line">      <span class="comment">// TransitionNativeToVM is used to transition the safepoint state of a</span></span><br><span class="line">      <span class="comment">// thread from &quot;running native code&quot; to &quot;running vm code&quot; and ensures</span></span><br><span class="line">      <span class="comment">// that the state is reverted back to &quot;running native code&quot; when</span></span><br><span class="line">      <span class="comment">// exiting the scope/frame.</span></span><br><span class="line">      <span class="function">TransitionNativeToVM <span class="title">transition</span><span class="params">(thread)</span></span>;</span><br><span class="line">      <span class="comment">// Create an empty zone and set is at the current zone for the Thread.</span></span><br><span class="line">      <span class="function">StackZone <span class="title">zone</span><span class="params">(thread)</span></span>;</span><br><span class="line">      <span class="comment">// The class HandleScope is used to start a new handles scope in the</span></span><br><span class="line">      <span class="comment">//  code.</span></span><br><span class="line">      <span class="function">HandleScope <span class="title">hs</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line">      success = **EnqueueEntrypointInvocationAndNotifySpawner**(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      state_ = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="built_in">Dart_ShutdownIsolate</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All preconditions are met for this to always succeed.</span></span><br><span class="line">    <span class="type">char</span>* error = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">// Lets the VM run message processing for the isolate.</span></span><br><span class="line">    <span class="keyword">if</span> (!**Dart_RunLoopAsync**(state_-&gt;<span class="built_in">errors_are_fatal</span>(), state_-&gt;<span class="built_in">on_error_port</span>(),</span><br><span class="line">                           state_-&gt;<span class="built_in">on_exit_port</span>(), &amp;error)) &#123;</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Dart_RunLoopAsync() failed: %s. Please file a Dart VM bug report.&quot;</span>,</span><br><span class="line">            error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里只是做了一些环境准备，然后在<code>EnqueueEntrypointInvocationAndNotifySpawner</code>方法中将isolate要运行的所有东西都准备好，然后再在<code>Dart_RunLoopAsync</code>方法中正式开始isolate处理event queue.</p>
<p><strong>EnqueueEntrypointInvocationAndNotifySpawner</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\lib\isolate.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnqueueEntrypointInvocationAndNotifySpawner</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> isolate = thread-&gt;<span class="built_in">isolate</span>();</span><br><span class="line">    <span class="keyword">auto</span> zone = thread-&gt;<span class="built_in">zone</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> is_spawn_uri = state_-&gt;<span class="built_in">is_spawn_uri</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1) Resolve the entrypoint function.</span></span><br><span class="line">    <span class="comment">// 查找isolate开始运行的第一个方法，比如Isolate.spawn的spawn或者Isolate.spawnUri的main方法</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; entrypoint_closure = Closure::<span class="built_in">Handle</span>(zone);</span><br><span class="line">    <span class="keyword">if</span> (state_-&gt;<span class="built_in">closure_tuple_handle</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; result = Object::<span class="built_in">Handle</span>(</span><br><span class="line">          zone,</span><br><span class="line">          <span class="built_in">ReadObjectGraphCopyMessage</span>(thread, state_-&gt;<span class="built_in">closure_tuple_handle</span>()));</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="built_in">IsError</span>()) &#123;</span><br><span class="line">        <span class="built_in">ReportError</span>(</span><br><span class="line">            <span class="string">&quot;Failed to deserialize the passed entrypoint to the new isolate.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      entrypoint_closure = Closure::<span class="built_in">RawCast</span>(result.<span class="built_in">ptr</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; result = Object::<span class="built_in">Handle</span>(zone, state_-&gt;<span class="built_in">ResolveFunction</span>());</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="built_in">IsError</span>()) &#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(is_spawn_uri);</span><br><span class="line">        <span class="built_in">ReportError</span>(<span class="string">&quot;Failed to resolve entrypoint function.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">ASSERT</span>(result.<span class="built_in">IsFunction</span>());</span><br><span class="line">      <span class="keyword">auto</span>&amp; func = Function::<span class="built_in">Handle</span>(zone, Function::<span class="built_in">Cast</span>(result).<span class="built_in">ptr</span>());</span><br><span class="line">      func = func.<span class="built_in">ImplicitClosureFunction</span>();</span><br><span class="line">      entrypoint_closure = func.<span class="built_in">ImplicitStaticClosure</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2) Enqueue delayed invocation of entrypoint callback.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; args_obj = Object::<span class="built_in">Handle</span>(zone, state_-&gt;<span class="built_in">BuildArgs</span>(thread));</span><br><span class="line">    <span class="keyword">if</span> (args_obj.<span class="built_in">IsError</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReportError</span>(</span><br><span class="line">          <span class="string">&quot;Failed to deserialize the passed arguments to the new isolate.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT</span>(args_obj.<span class="built_in">IsNull</span>() || args_obj.<span class="built_in">IsInstance</span>());</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; message_obj =</span><br><span class="line">        Object::<span class="built_in">Handle</span>(zone, state_-&gt;<span class="built_in">BuildMessage</span>(thread));</span><br><span class="line">    <span class="keyword">if</span> (message_obj.<span class="built_in">IsError</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReportError</span>(</span><br><span class="line">          <span class="string">&quot;Failed to deserialize the passed arguments to the new isolate.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT</span>(message_obj.<span class="built_in">IsNull</span>() || message_obj.<span class="built_in">IsInstance</span>());</span><br><span class="line">    <span class="comment">// 解析参数，分别是isolate初始运行方法，参数args、messgae、是否spawn_uri</span></span><br><span class="line">    <span class="type">const</span> Array&amp; args = Array::<span class="built_in">Handle</span>(zone, Array::<span class="built_in">New</span>(<span class="number">4</span>));</span><br><span class="line">    args.<span class="built_in">SetAt</span>(<span class="number">0</span>, entrypoint_closure);</span><br><span class="line">    args.<span class="built_in">SetAt</span>(<span class="number">1</span>, args_obj);</span><br><span class="line">    args.<span class="built_in">SetAt</span>(<span class="number">2</span>, message_obj);</span><br><span class="line">    args.<span class="built_in">SetAt</span>(<span class="number">3</span>, is_spawn_uri ? Bool::<span class="built_in">True</span>() : Bool::<span class="built_in">False</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; lib = Library::<span class="built_in">Handle</span>(zone, Library::<span class="built_in">IsolateLibrary</span>());</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; entry_name = String::<span class="built_in">Handle</span>(zone, String::<span class="built_in">New</span>(<span class="string">&quot;_startIsolate&quot;</span>));</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; entry_point =</span><br><span class="line">        Function::<span class="built_in">Handle</span>(zone, lib.<span class="built_in">LookupLocalFunction</span>(entry_name));</span><br><span class="line">    <span class="built_in">ASSERT</span>(entry_point.<span class="built_in">IsFunction</span>() &amp;&amp; !entry_point.<span class="built_in">IsNull</span>());</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; result =</span><br><span class="line">        Object::<span class="built_in">Handle</span>(zone, DartEntry::<span class="built_in">InvokeFunction</span>(entry_point, args));</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">IsError</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReportError</span>(<span class="string">&quot;Failed to enqueue delayed entrypoint invocation.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3) Pause the isolate if required &amp; Notify parent isolate about</span></span><br><span class="line">    <span class="comment">// isolate creation.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; capabilities = Array::<span class="built_in">Handle</span>(zone, Array::<span class="built_in">New</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span>&amp; capability = Capability::<span class="built_in">Handle</span>(zone);</span><br><span class="line">    capability = Capability::<span class="built_in">New</span>(isolate-&gt;<span class="built_in">pause_capability</span>());</span><br><span class="line">    capabilities.<span class="built_in">SetAt</span>(<span class="number">0</span>, capability);</span><br><span class="line">    capability = Capability::<span class="built_in">New</span>(isolate-&gt;<span class="built_in">terminate_capability</span>());</span><br><span class="line">    capabilities.<span class="built_in">SetAt</span>(<span class="number">1</span>, capability);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; send_port =</span><br><span class="line">        SendPort::<span class="built_in">Handle</span>(zone, SendPort::<span class="built_in">New</span>(isolate-&gt;<span class="built_in">main_port</span>()));</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; message = Array::<span class="built_in">Handle</span>(zone, Array::<span class="built_in">New</span>(<span class="number">2</span>));</span><br><span class="line">    message.<span class="built_in">SetAt</span>(<span class="number">0</span>, send_port);</span><br><span class="line">    message.<span class="built_in">SetAt</span>(<span class="number">1</span>, capabilities);</span><br><span class="line">    <span class="keyword">if</span> (state_-&gt;<span class="built_in">paused</span>()) &#123;</span><br><span class="line">      capability ^= capabilities.<span class="built_in">At</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="type">const</span> <span class="type">bool</span> added = isolate-&gt;<span class="built_in">AddResumeCapability</span>(capability);</span><br><span class="line">      <span class="built_in">ASSERT</span>(added);</span><br><span class="line">      isolate-&gt;<span class="built_in">message_handler</span>()-&gt;<span class="built_in">increment_paused</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// If parent isolate died, we ignore the fact that we cannot notify it.</span></span><br><span class="line">      <span class="comment">// 创建一个新的Message并将其压入Isolate的父Isolate对应的MessageHandler的event queue中</span></span><br><span class="line">      PortMap::<span class="built_in">PostMessage</span>(<span class="built_in">WriteMessage</span>(<span class="comment">/* can_send_any_object */</span> <span class="literal">false</span>,</span><br><span class="line">                                        <span class="comment">/* same_group */</span> <span class="literal">false</span>, message,</span><br><span class="line">                                        state_-&gt;<span class="built_in">parent_port</span>(),</span><br><span class="line">                                        Message::kNormalPriority));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了3件事：</p>
<ul>
<li>查找isolate开始运行的第一个方法<code>entrypoint</code>，比如<code>Isolate.spawn</code>的<code>entrypoint</code>或者<code>Isolate.spawnUri</code>的<code>main</code>方法</li>
<li>解析参数，分别是isolate初始运行方法，参数<code>args</code>、<code>messgae</code>、是否<code>spawn_uri</code>等等，将其与上一步找到的<code>entrypoint</code>结合</li>
<li>（如果需要的话暂停创建好的isolate），并通知isolate的父isolate当前isolate创建成功（附带当前isolate的<code>send_port</code>）</li>
</ul>
<p>至此，Isolate的创建工作已经完成，在<code>Dart_RunLoopAsync</code>开始isolate处理消息：</p>
<p><strong>Dart_RunLoopAsync</strong></p>
<p>在这里主要是开始处理event loop。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt;  runtime\vm\dart_api_impl.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">DART_EXPORT <span class="type">bool</span> <span class="title">Dart_RunLoopAsync</span><span class="params">(<span class="type">bool</span> errors_are_fatal,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Dart_Port on_error_port,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Dart_Port on_exit_port,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">char</span>** error)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> thread = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="keyword">auto</span> isolate = thread-&gt;<span class="built_in">isolate</span>();</span><br><span class="line">  <span class="built_in">CHECK_ISOLATE</span>(isolate);</span><br><span class="line">  *error = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;<span class="built_in">api_top_scope</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *error = Utils::<span class="built_in">StrDup</span>(<span class="string">&quot;There must not be an active api scope.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isolate-&gt;<span class="built_in">is_runnable</span>()) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* error_msg = isolate-&gt;<span class="built_in">MakeRunnable</span>();</span><br><span class="line">    <span class="keyword">if</span> (error_msg != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *error = Utils::<span class="built_in">StrDup</span>(error_msg);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isolate-&gt;<span class="built_in">SetErrorsFatal</span>(errors_are_fatal);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (on_error_port != ILLEGAL_PORT || on_exit_port != ILLEGAL_PORT) &#123;</span><br><span class="line">    <span class="keyword">auto</span> thread = Thread::<span class="built_in">Current</span>();</span><br><span class="line">    <span class="function">TransitionNativeToVM <span class="title">transition</span><span class="params">(thread)</span></span>;</span><br><span class="line">    <span class="function">StackZone <span class="title">zone</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (on_error_port != ILLEGAL_PORT) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; port =</span><br><span class="line">          SendPort::<span class="built_in">Handle</span>(thread-&gt;<span class="built_in">zone</span>(), SendPort::<span class="built_in">New</span>(on_error_port));</span><br><span class="line">      isolate-&gt;<span class="built_in">AddErrorListener</span>(port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (on_exit_port != ILLEGAL_PORT) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; port =</span><br><span class="line">          SendPort::<span class="built_in">Handle</span>(thread-&gt;<span class="built_in">zone</span>(), SendPort::<span class="built_in">New</span>(on_exit_port));</span><br><span class="line">      isolate-&gt;<span class="built_in">AddExitListener</span>(port, Instance::<span class="built_in">null_instance</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Dart_ExitIsolate</span>();</span><br><span class="line">  **isolate-&gt;<span class="built_in">Run</span>();**</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\isolate.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Isolate::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">message_handler</span>()-&gt;<span class="built_in">Run</span>(<span class="built_in">group</span>()-&gt;<span class="built_in">thread_pool</span>(), <span class="literal">nullptr</span>, ShutdownIsolate,</span><br><span class="line">                         <span class="built_in">reinterpret_cast</span>&lt;uword&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Isolate::Run()</code>实际上是开启了处理消息队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Runs this message handler on the thread pool.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Before processing messages, the optional StartFunction is run.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// A message handler will run until it terminates either normally or</span></span><br><span class="line">  <span class="comment">// abnormally.  Normal termination occurs when the message handler</span></span><br><span class="line">  <span class="comment">// no longer has any live ports.  Abnormal termination occurs when</span></span><br><span class="line">  <span class="comment">// HandleMessage() indicates that an error has occurred during</span></span><br><span class="line">  <span class="comment">// message processing.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns false if the handler terminated abnormally, otherwise it</span></span><br><span class="line">  <span class="comment">// returns true.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MessageHandler::Run</span><span class="params">(ThreadPool* pool,</span></span></span><br><span class="line"><span class="params"><span class="function">                         StartCallback start_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                         EndCallback end_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                         CallbackData data)</span> </span>&#123;</span><br><span class="line">  <span class="function">MonitorLocker <span class="title">ml</span><span class="params">(&amp;monitor_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_trace_isolates) &#123;</span><br><span class="line">    OS::<span class="built_in">PrintErr</span>(</span><br><span class="line">        <span class="string">&quot;[+] Starting message handler:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\thandler:    %s\n&quot;</span>,</span><br><span class="line">        <span class="built_in">name</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ASSERT</span>(pool_ == <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">ASSERT</span>(!delete_me_);</span><br><span class="line">  pool_ = pool;</span><br><span class="line">  start_callback_ = start_callback;</span><br><span class="line">  end_callback_ = end_callback;</span><br><span class="line">  callback_data_ = data;</span><br><span class="line">  task_running_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">bool</span> result = **pool_-&gt;<span class="built_in">Run</span>&lt;MessageHandlerTask&gt;(<span class="keyword">this</span>);**</span><br><span class="line">  <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    pool_ = <span class="literal">nullptr</span>;</span><br><span class="line">    start_callback_ = <span class="literal">nullptr</span>;</span><br><span class="line">    end_callback_ = <span class="literal">nullptr</span>;</span><br><span class="line">    callback_data_ = <span class="number">0</span>;</span><br><span class="line">    task_running_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\thread_pool.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Run</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RunImpl</span>(std::<span class="built_in">unique_ptr</span>&lt;Task&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...)));</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\thread_pool.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ThreadPool::RunImpl</span><span class="params">(std::unique_ptr&lt;Task&gt; task)</span> </span>&#123;</span><br><span class="line">  Worker* new_worker = <span class="literal">nullptr</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MonitorLocker <span class="title">ml</span><span class="params">(&amp;pool_monitor_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (shutting_down_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 从线程池中获取task，如果有空闲的/达到最大数量就尝试复用（此时这里返回null）</span></span><br><span class="line">		<span class="comment">// 否则创建新的并返回</span></span><br><span class="line">    new_worker = **ScheduleTaskLocked**(&amp;ml, std::<span class="built_in">move</span>(task));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (new_worker != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">// 创建一个新的Worker在新的系统线程运行task</span></span><br><span class="line">    new_worker-&gt;**<span class="built_in">StartThread</span>()**;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> ThreadPool::Worker::<span class="built_in">StartThread</span>() &#123;</span><br><span class="line">	<span class="comment">// 创建一个新的系统线程，运行指定的代码，</span></span><br><span class="line">	<span class="comment">//  android的实现在runtime\vm\os_thread_android.cc</span></span><br><span class="line">  <span class="type">int</span> result = OSThread::<span class="built_in">Start</span>(<span class="string">&quot;DartWorker&quot;</span>, &amp;**Worker::Main**,</span><br><span class="line">                               <span class="built_in">reinterpret_cast</span>&lt;uword&gt;(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">FATAL1</span>(<span class="string">&quot;Could not start worker thread: result = %d.&quot;</span>, result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里通过<code>ThreadPool::ScheduleTaskLocked</code>方法获取<code>new_worker</code>：</p>
<ul>
<li>如果已有的worker有空闲的或者已经达到最大数目了，就等待已有的worker执行任务</li>
<li>否则就创建新的worker，并在新的线程运行</li>
</ul>
<p>在获取到worker之后，就执行<code>MessageHandlerTask</code>（见下文详细分析）。</p>
<p>我们主要关注3点：</p>
<ul>
<li><code>ScheduleTaskLocked</code> 分配Worker</li>
<li><code>OSThread::Start</code>中使用<code>&amp;Worker::Main</code> 在新系统线程开启Worker循环</li>
<li><code>MessageHandlerTask</code> 执行具体的消息分发内容</li>
</ul>
<h4 id="ScheduleTaskLocked"><a href="#ScheduleTaskLocked" class="headerlink" title="ScheduleTaskLocked"></a><strong>ScheduleTaskLocked</strong></h4><p>先详细看一下获取<code>new_worker</code>的<code>ThreadPool::ScheduleTaskLocked</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\thread_pool.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">ThreadPool::Worker* <span class="title">ThreadPool::ScheduleTaskLocked</span><span class="params">(MonitorLocker* ml,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   std::unique_ptr&lt;Task&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Enqueue the new task.</span></span><br><span class="line">  tasks_.<span class="built_in">Append</span>(task.<span class="built_in">release</span>());</span><br><span class="line">  pending_tasks_++;</span><br><span class="line">  <span class="built_in">ASSERT</span>(pending_tasks_ &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify existing idle worker (if available).</span></span><br><span class="line">  <span class="keyword">if</span> (count_idle_ &gt;= pending_tasks_) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!idle_workers_.<span class="built_in">IsEmpty</span>());</span><br><span class="line">    ml-&gt;<span class="built_in">Notify</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have maxed out the number of threads running, we will not start a</span></span><br><span class="line">  <span class="comment">// new one.</span></span><br><span class="line">  <span class="keyword">if</span> (max_pool_size_ &gt; <span class="number">0</span> &amp;&amp; (count_idle_ + count_running_) &gt;= max_pool_size_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!idle_workers_.<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">      ml-&gt;<span class="built_in">Notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise start a new worker.</span></span><br><span class="line">  <span class="keyword">auto</span> new_worker = <span class="keyword">new</span> <span class="built_in">Worker</span>(<span class="keyword">this</span>);</span><br><span class="line">  idle_workers_.<span class="built_in">Append</span>(new_worker);</span><br><span class="line">  count_idle_++;</span><br><span class="line">  <span class="keyword">return</span> new_worker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑是：</p>
<p>将当前任务加入到<code>tasks_</code>队列中。</p>
<ul>
<li>如果空闲<code>count_idle_</code> 的Worker比等待中的任务数<code>pending_tasks_</code>多，那就发送通知，使用已有的Worker处理任务。</li>
<li>如果当前Worker数量已经最大了，那就将等待中的任务数pending_tasks_ 加一，等待有空闲的Worker处理任务。</li>
<li>否则，就新建一个Worker（会对应创建一个新的系统线程）来处理任务。</li>
</ul>
<h4 id="amp-Worker-Main"><a href="#amp-Worker-Main" class="headerlink" title="&amp;Worker::Main"></a>&amp;<strong>Worker::Main</strong></h4><p>在<code>ThreadPool::RunImpl(std::unique_ptr&lt;Task&gt; task)</code>这里，StartThread的第二个参数，**<code>&amp;Worker::Main</code>**启动了一个循环，不断的在任务队列<code>tasks_</code>中取出消息并执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\thread_pool.cc</span></span><br><span class="line"></span><br><span class="line">ThreadPool::Worker::<span class="built_in">Main</span>(uword args)&#123;</span><br><span class="line">Worker* worker = <span class="built_in">reinterpret_cast</span>&lt;Worker*&gt;(args);</span><br><span class="line">  ThreadPool* pool = worker-&gt;pool_;</span><br><span class="line"></span><br><span class="line">pool-&gt;<span class="built_in">WorkerLoop</span>(worker);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::WorkerLoop</span><span class="params">(Worker* worker)</span> </span>&#123;</span><br><span class="line">  WorkerList dead_workers_to_join;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function">MonitorLocker <span class="title">ml</span><span class="params">(&amp;pool_monitor_)</span></span>;</span><br><span class="line">		<span class="comment">// worker会从task_取出一个task并运行</span></span><br><span class="line">    <span class="keyword">if</span> (!tasks_.<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">      <span class="built_in">IdleToRunningLocked</span>(worker);</span><br><span class="line">      <span class="keyword">while</span> (!tasks_.<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;Task&gt; <span class="title">task</span><span class="params">(tasks_.RemoveFirst())</span></span>;</span><br><span class="line">        pending_tasks_--;</span><br><span class="line">        <span class="function">MonitorLeaveScope <span class="title">mls</span><span class="params">(&amp;ml)</span></span>;</span><br><span class="line">        **task-&gt;<span class="built_in">Run</span>();**</span><br><span class="line">        <span class="built_in">ASSERT</span>(Isolate::<span class="built_in">Current</span>() == <span class="literal">nullptr</span>);</span><br><span class="line">        task.<span class="built_in">reset</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">RunningToIdleLocked</span>(worker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (running_workers_.<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">      <span class="built_in">ASSERT</span>(tasks_.<span class="built_in">IsEmpty</span>());</span><br><span class="line">      <span class="built_in">OnEnterIdleLocked</span>(&amp;ml);</span><br><span class="line">      <span class="keyword">if</span> (!tasks_.<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shutting_down_) &#123;</span><br><span class="line">      <span class="built_in">ObtainDeadWorkersLocked</span>(&amp;dead_workers_to_join);</span><br><span class="line">      <span class="built_in">IdleToDeadLocked</span>(worker);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sleep until we get a new task, we time out or we&#x27;re shutdown.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> idle_start = OS::<span class="built_in">GetCurrentMonotonicMicros</span>();</span><br><span class="line">    <span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> result = ml.<span class="built_in">WaitMicros</span>(<span class="built_in">ComputeTimeout</span>(idle_start));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We have to drain all pending tasks.</span></span><br><span class="line">      <span class="keyword">if</span> (!tasks_.<span class="built_in">IsEmpty</span>()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shutting_down_ || result == Monitor::kTimedOut) &#123;</span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">      <span class="built_in">ObtainDeadWorkersLocked</span>(&amp;dead_workers_to_join);</span><br><span class="line">      <span class="built_in">IdleToDeadLocked</span>(worker);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before we transitioned to dead we obtained the list of previously died dead</span></span><br><span class="line">  <span class="comment">// workers, which we join here. Since every death of a worker will join</span></span><br><span class="line">  <span class="comment">// previously died workers, we keep the pending non-joined [dead_workers_] to</span></span><br><span class="line">  <span class="comment">// effectively 1.</span></span><br><span class="line">  <span class="built_in">JoinDeadWorkersLocked</span>(&amp;dead_workers_to_join);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MessageHandlerTask</strong> </p>
<p>无论是哪种Worker,最后都是执行的<code>MessageHandlerTask</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\message_handler.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageHandlerTask</span> : <span class="keyword">public</span> ThreadPool::Task &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MessageHandlerTask</span><span class="params">(MessageHandler* handler)</span> : handler_(handler) &#123;</span></span><br><span class="line"><span class="built_in">ASSERT</span>(handler != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">ASSERT</span>(handler_ != <span class="literal">NULL</span>);</span><br><span class="line">handler_-&gt;<span class="built_in">TaskCallback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageHandler::TaskCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ASSERT</span>(Isolate::<span class="built_in">Current</span>() == <span class="literal">NULL</span>);</span><br><span class="line">  MessageStatus status = kOK;</span><br><span class="line">  <span class="type">bool</span> run_end_callback = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> delete_me = <span class="literal">false</span>;</span><br><span class="line">  EndCallback end_callback = <span class="literal">NULL</span>;</span><br><span class="line">  CallbackData callback_data = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// We will occasionally release and reacquire this monitor in this</span></span><br><span class="line">    <span class="comment">// function. Whenever we reacquire the monitor we *must* process</span></span><br><span class="line">    <span class="comment">// all pending OOB messages, or we may miss a request for vm</span></span><br><span class="line">    <span class="comment">// shutdown.</span></span><br><span class="line">    <span class="function">MonitorLocker <span class="title">ml</span><span class="params">(&amp;monitor_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is running on the message handler task. Which means no</span></span><br><span class="line">    <span class="comment">// other message handler tasks will be started until this one sets</span></span><br><span class="line">    <span class="comment">// [task_running_] to false.</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(task_running_);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(PRODUCT)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ShouldPauseOnStart</span>(kOK)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">is_paused_on_start</span>()) &#123;</span><br><span class="line">        <span class="built_in">PausedOnStartLocked</span>(&amp;ml, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// More messages may have come in before we (re)acquired the monitor.</span></span><br><span class="line">      status = <span class="built_in">HandleMessages</span>(&amp;ml, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ShouldPauseOnStart</span>(status)) &#123;</span><br><span class="line">        <span class="comment">// Still paused.</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(oob_queue_-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">        task_running_ = <span class="literal">false</span>;  <span class="comment">// No task in queue.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">PausedOnStartLocked</span>(&amp;ml, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_paused_on_exit</span>()) &#123;</span><br><span class="line">      status = <span class="built_in">HandleMessages</span>(&amp;ml, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ShouldPauseOnExit</span>(status)) &#123;</span><br><span class="line">        <span class="comment">// Still paused.</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(oob_queue_-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">        task_running_ = <span class="literal">false</span>;  <span class="comment">// No task in queue.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">PausedOnExitLocked</span>(&amp;ml, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(PRODUCT)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == kOK) &#123;</span><br><span class="line">      <span class="keyword">if</span> (start_callback_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// Initialize the message handler by running its start function,</span></span><br><span class="line">        <span class="comment">// if we have one.  For an isolate, this will run the isolate&#x27;s</span></span><br><span class="line">        <span class="comment">// main() function.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Release the monitor_ temporarily while we call the start callback.</span></span><br><span class="line">        ml.<span class="built_in">Exit</span>();</span><br><span class="line">        status = <span class="built_in">start_callback_</span>(callback_data_);</span><br><span class="line">        <span class="built_in">ASSERT</span>(Isolate::<span class="built_in">Current</span>() == <span class="literal">NULL</span>);</span><br><span class="line">        start_callback_ = <span class="literal">NULL</span>;</span><br><span class="line">        ml.<span class="built_in">Enter</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Handle any pending messages for this message handler.</span></span><br><span class="line">      <span class="keyword">if</span> (status != kShutdown) &#123;</span><br><span class="line">        status = <span class="built_in">HandleMessages</span>(&amp;ml, (status == kOK), <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The isolate exits when it encounters an error or when it no</span></span><br><span class="line">    <span class="comment">// longer has live ports.</span></span><br><span class="line">    <span class="keyword">if</span> (status != kOK || !<span class="built_in">HasLivePorts</span>()) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(PRODUCT)</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ShouldPauseOnExit</span>(status)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FLAG_trace_service_pause_events) &#123;</span><br><span class="line">          OS::<span class="built_in">PrintErr</span>(</span><br><span class="line">              <span class="string">&quot;Isolate %s paused before exiting. &quot;</span></span><br><span class="line">              <span class="string">&quot;Use the Observatory to release it.\n&quot;</span>,</span><br><span class="line">              <span class="built_in">name</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PausedOnExitLocked</span>(&amp;ml, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// More messages may have come in while we released the monitor.</span></span><br><span class="line">        **status = <span class="built_in">HandleMessages</span>(&amp;ml, <span class="literal">false</span>, <span class="literal">false</span>);**</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ShouldPauseOnExit</span>(status)) &#123;</span><br><span class="line">          <span class="comment">// Still paused.</span></span><br><span class="line">          <span class="built_in">ASSERT</span>(oob_queue_-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">          task_running_ = <span class="literal">false</span>;  <span class="comment">// No task in queue.</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">PausedOnExitLocked</span>(&amp;ml, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(PRODUCT)</span></span></span><br><span class="line">      <span class="keyword">if</span> (FLAG_trace_isolates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != kOK &amp;&amp; <span class="built_in">thread</span>() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="type">const</span> Error&amp; error = Error::<span class="built_in">Handle</span>(<span class="built_in">thread</span>()-&gt;<span class="built_in">sticky_error</span>());</span><br><span class="line">          OS::<span class="built_in">PrintErr</span>(</span><br><span class="line">              <span class="string">&quot;[-] Stopping message handler (%s):\n&quot;</span></span><br><span class="line">              <span class="string">&quot;\thandler:    %s\n&quot;</span></span><br><span class="line">              <span class="string">&quot;\terror:    %s\n&quot;</span>,</span><br><span class="line">              <span class="built_in">MessageStatusString</span>(status), <span class="built_in">name</span>(), error.<span class="built_in">ToCString</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          OS::<span class="built_in">PrintErr</span>(</span><br><span class="line">              <span class="string">&quot;[-] Stopping message handler (%s):\n&quot;</span></span><br><span class="line">              <span class="string">&quot;\thandler:    %s\n&quot;</span>,</span><br><span class="line">              <span class="built_in">MessageStatusString</span>(status), <span class="built_in">name</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      pool_ = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="comment">// Decide if we have a callback before releasing the monitor.</span></span><br><span class="line">      end_callback = end_callback_;</span><br><span class="line">      callback_data = callback_data_;</span><br><span class="line">      run_end_callback = end_callback_ != <span class="literal">NULL</span>;</span><br><span class="line">      delete_me = delete_me_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear task_running_ last.  This allows other tasks to potentially start</span></span><br><span class="line">    <span class="comment">// for this message handler.</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(oob_queue_-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">    task_running_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The handler may have been deleted by another thread here if it is a native</span></span><br><span class="line">  <span class="comment">// message handler.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Message handlers either use delete_me or end_callback but not both.</span></span><br><span class="line">  <span class="built_in">ASSERT</span>(!delete_me || !run_end_callback);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_end_callback) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(end_callback != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">end_callback</span>(callback_data);</span><br><span class="line">    <span class="comment">// The handler may have been deleted after this point.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (delete_me) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里执行了<code>MessageHandler::HandleMessages</code>方法，来处理消息：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\message_handler.cc</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">MessageHandler</span>::<span class="title class_">MessageStatus</span> <span class="title class_">MessageHandler</span>::<span class="title class_">HandleMessages</span>(</span><br><span class="line">    <span class="title class_">MonitorLocker</span>* ml,</span><br><span class="line">    bool allow_normal_messages,</span><br><span class="line">    bool allow_multiple_normal_messages) &#123;</span><br><span class="line">  <span class="title function_">ASSERT</span>(monitor_.<span class="title class_">IsOwnedByCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scheduling of the mutator thread during the isolate start can cause this</span></span><br><span class="line">  <span class="comment">// thread to safepoint.</span></span><br><span class="line">  <span class="comment">// We want to avoid holding the message handler monitor during the safepoint</span></span><br><span class="line">  <span class="comment">// operation to avoid possible deadlocks, which can occur if other threads are</span></span><br><span class="line">  <span class="comment">// sending messages to this message handler.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If isolate() returns nullptr [StartIsolateScope] does nothing.</span></span><br><span class="line">  ml-&gt;<span class="title class_">Exit</span>();</span><br><span class="line">  <span class="title class_">StartIsolateScope</span> <span class="title function_">start_isolate</span>(<span class="title function_">isolate</span>());</span><br><span class="line">  ml-&gt;<span class="title class_">Enter</span>();</span><br><span class="line"></span><br><span class="line">  auto idle_time_handler =</span><br><span class="line">      <span class="title function_">isolate</span>() != nullptr ? <span class="title function_">isolate</span>()-&gt;<span class="title function_">group</span>()-&gt;<span class="title function_">idle_time_handler</span>() : nullptr;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">MessageStatus</span> max_status = kOK;</span><br><span class="line">  <span class="title class_">Message</span>::<span class="title class_">Priority</span> min_priority =</span><br><span class="line">      ((allow_normal_messages &amp;&amp; !<span class="title function_">paused</span>()) ? <span class="title class_">Message</span>::kNormalPriority</span><br><span class="line">                                            : <span class="title class_">Message</span>::kOOBPriority);</span><br><span class="line">  <span class="attr">std</span>::unique_ptr&lt;<span class="title class_">Message</span>&gt; **message = <span class="title class_">DequeueMessage</span>(min_priority);**</span><br><span class="line">  <span class="keyword">while</span> (message != nullptr) &#123;</span><br><span class="line">    intptr_t message_len = message-&gt;<span class="title class_">Size</span>();</span><br><span class="line">    <span class="keyword">if</span> (FLAG_trace_isolates) &#123;</span><br><span class="line">      <span class="attr">OS</span>::<span class="title class_">PrintErr</span>(</span><br><span class="line">          <span class="string">&quot;[&lt;] Handling message:\n&quot;</span></span><br><span class="line">          <span class="string">&quot;\tlen:        %&quot;</span> <span class="title class_">Pd</span></span><br><span class="line">          <span class="string">&quot;\n&quot;</span></span><br><span class="line">          <span class="string">&quot;\thandler:    %s\n&quot;</span></span><br><span class="line">          <span class="string">&quot;\tport:       %&quot;</span> <span class="title class_">Pd64</span> <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">          message_len, <span class="title function_">name</span>(), message-&gt;<span class="title function_">dest_port</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the monitor_ temporarily while we handle the message.</span></span><br><span class="line">    <span class="comment">// The monitor was acquired in MessageHandler::TaskCallback().</span></span><br><span class="line">    ml-&gt;<span class="title class_">Exit</span>();</span><br><span class="line">    <span class="title class_">Message</span>::<span class="title class_">Priority</span> saved_priority = message-&gt;<span class="title function_">priority</span>();</span><br><span class="line">    <span class="title class_">Dart</span>_Port saved_dest_port = message-&gt;<span class="title function_">dest_port</span>();</span><br><span class="line">    <span class="title class_">MessageStatus</span> status = kOK;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title class_">DisableIdleTimerScope</span> <span class="title function_">disable_idle_timer</span>(idle_time_handler);</span><br><span class="line">      status = <span class="title class_">HandleMessage</span>(<span class="attr">std</span>::<span class="title function_">move</span>(message));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status &gt; max_status) &#123;</span><br><span class="line">      max_status = status;</span><br><span class="line">    &#125;</span><br><span class="line">    ml-&gt;<span class="title class_">Enter</span>();</span><br><span class="line">    <span class="keyword">if</span> (FLAG_trace_isolates) &#123;</span><br><span class="line">      <span class="attr">OS</span>::<span class="title class_">PrintErr</span>(</span><br><span class="line">          <span class="string">&quot;[.] Message handled (%s):\n&quot;</span></span><br><span class="line">          <span class="string">&quot;\tlen:        %&quot;</span> <span class="title class_">Pd</span></span><br><span class="line">          <span class="string">&quot;\n&quot;</span></span><br><span class="line">          <span class="string">&quot;\thandler:    %s\n&quot;</span></span><br><span class="line">          <span class="string">&quot;\tport:       %&quot;</span> <span class="title class_">Pd64</span> <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">          <span class="title class_">MessageStatusString</span>(status), message_len, <span class="title function_">name</span>(), saved_dest_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we are shutting down, do not process any more messages.</span></span><br><span class="line">    <span class="keyword">if</span> (status == kShutdown) &#123;</span><br><span class="line">      <span class="title class_">ClearOOBQueue</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember time since the last message. Don&#x27;t consider OOB messages so</span></span><br><span class="line">    <span class="comment">// using Observatory doesn&#x27;t trigger additional idle tasks.</span></span><br><span class="line">    <span class="keyword">if</span> ((FLAG_idle_timeout_micros != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (saved_priority == <span class="title class_">Message</span>::kNormalPriority)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (idle_time_handler != nullptr) &#123;</span><br><span class="line">        idle_time_handler-&gt;<span class="title class_">UpdateStartIdleTime</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some callers want to process only one normal message and then quit. At</span></span><br><span class="line">    <span class="comment">// the same time it is OK to process multiple OOB messages.</span></span><br><span class="line">    <span class="keyword">if</span> ((saved_priority == <span class="title class_">Message</span>::kNormalPriority) &amp;&amp;</span><br><span class="line">        !allow_multiple_normal_messages) &#123;</span><br><span class="line">      <span class="comment">// We processed one normal message.  Allow no more.</span></span><br><span class="line">      allow_normal_messages = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reevaluate the minimum allowable priority.  The paused state</span></span><br><span class="line">    <span class="comment">// may have changed as part of handling the message.  We may also</span></span><br><span class="line">    <span class="comment">// have encountered an error during message processing.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Even if we encounter an error, we still process pending OOB</span></span><br><span class="line">    <span class="comment">// messages so that we don&#x27;t lose the message notification.</span></span><br><span class="line">    min_priority = (((max_status == kOK) &amp;&amp; allow_normal_messages &amp;&amp; !<span class="title function_">paused</span>())</span><br><span class="line">                        ? <span class="title class_">Message</span>::kNormalPriority</span><br><span class="line">                        : <span class="title class_">Message</span>::kOOBPriority);</span><br><span class="line">    message = <span class="title class_">DequeueMessage</span>(min_priority);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MessageHandler::DequeueMessage</code>则是按照优先级，依次从<code>oob_queue_</code>和<code>queue_</code>中获取消息：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\vm\message_handler.cc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">std</span>::unique_ptr&lt;<span class="title class_">Message</span>&gt; <span class="title class_">MessageHandler</span>::<span class="title class_">DequeueMessage</span>(</span><br><span class="line">    <span class="title class_">Message</span>::<span class="title class_">Priority</span> min_priority) &#123;</span><br><span class="line">  <span class="comment">// TODO(turnidge): Add assert that monitor_ is held here.</span></span><br><span class="line">  <span class="attr">std</span>::unique_ptr&lt;<span class="title class_">Message</span>&gt; message = oob_queue_-&gt;<span class="title class_">Dequeue</span>();</span><br><span class="line">  <span class="keyword">if</span> ((message == nullptr) &amp;&amp; (min_priority &lt; <span class="title class_">Message</span>::kOOBPriority)) &#123;</span><br><span class="line">    message = queue_-&gt;<span class="title class_">Dequeue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>oob_queue_</code>和<code>queue_</code> 的区别如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageHandler</span> &#123;</span><br><span class="line">	<span class="title class_">MessageQueue</span>* queue_;</span><br><span class="line">  <span class="title class_">MessageQueue</span>* oob_queue_;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\vm\message.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">	<span class="comment">// A message processed at any interrupt point (stack overflow check) instead</span></span><br><span class="line">  <span class="comment">// of at the top of the message loop. Control messages from dart:isolate or</span></span><br><span class="line">  <span class="comment">// vm-service requests.</span></span><br><span class="line">  bool <span class="title class_">IsOOB</span>() <span class="keyword">const</span> &#123; <span class="keyword">return</span> priority_ == <span class="title class_">Message</span>::kOOBPriority; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里消息处理的步骤也启动了。</p>
<p>总结一下，<code>Dart_RunLoopAsync</code>的主要功能是触发isolate的<code>message_handler</code>处理消息分发：</p>
<p><code>Dart_RunLoopAsync</code> → <code>Isolate::Run()</code> →  <code>message_handler()-&gt;Run()</code> → <strong>pool_-&gt;</strong><code>Run&lt;MessageHandlerTask&gt;</code> <strong>→</strong> <code>ThreadPool::RunImpl</code></p>
<p>在<code>ThreadPool::RunImpl(std::unique_ptr&lt;Task&gt; task)</code>这里主要触发了2步：</p>
<ul>
<li><code>ScheduleTaskLocked</code>获取到<code>new_worker</code></li>
<li><code>new_worker</code>调用<code>ThreadPool::Worker::StartThread()</code>方法开启循环</li>
</ul>
<p>然后根据是否创建了<code>new_worker</code>有两种情况：</p>
<ul>
<li>有<code>new_worker</code>，使用在<code>OSThread::Start</code>方法中创建了一个新的系统线程，执行<code>ThreadPool::Worker::Main</code>（这个方法的主要作用使用<code>new_worker</code>从线程池中的取出任务执行）</li>
<li>没有<code>new_worker</code>，那么等待已有的Worker空闲时执行任务</li>
</ul>
<p>无论如何，这里的Worker要执行的任务都是在<code>MessageHandler::Run</code>方法中指定的<code>MessageHandlerTask</code> ，而这个任务的内容便是开启<code>MessageHandler::HandleMessages</code> 方法，按照优先级不断的依次从<code>oob_queue_</code>和<code>queue_</code>中获取消息并处理。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <img src="https://jixiaoyong.github.io/images/Isolate_spawn_spawnuri_dart_and_native.png"></p>
<p>Isolate是Dart代码运行的地方，拥有独立的event loop，和全局变量，在自己单独的线程运行。</p>
<p>Isolate.spawn默认会创建在同一个IsolateGroup中的Isolate，他们之间共享Heap（这里会发生GC）和一个线程池。</p>
<p>Isolate.spawnUri会从制定的Uri中创建一个新的IsolateGroup和对应的Isolate，并执行Uri中的main方法。</p>
<p>Isolate内部维持一个Event Loop。</p>
]]></content>
  </entry>
  <entry>
    <title>Dart VM</title>
    <url>/blog/posts/550e5790/</url>
    <content><![CDATA[<blockquote>
<p>本文是对Dart官方VM的介绍的总结摘要，推荐直接阅读<a href="https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md">官方原文</a>。</p>
</blockquote>
<p>Dart VM is a collection of components for executing Dart code natively. Notably, it includes the following:</p>
<ul>
<li><strong>Runtime System</strong><ul>
<li>Object Model</li>
<li>Garbage Collection</li>
<li>Snapshots</li>
</ul>
</li>
<li><strong>Core libraries’ native methods</strong></li>
<li><strong>Development Experience components</strong> accessible via <em>service protocol</em> * Debugging * Profiling * Hot-reload</li>
<li><strong>Just-in-Time (JIT) and Ahead-of-Time (AOT) compilation pipelines</strong></li>
<li><strong>Interpreter</strong></li>
<li><strong>ARM simulators</strong></li>
</ul>
<p>下图是runtime执行代码的示意图：</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/isolates.png" alt="isolate"></p>
<p>isolate中有两种Thread：</p>
<ul>
<li>一个mutator thread用来执行dart 代码</li>
<li>多个helper thread 用来执行GC、JIT等</li>
</ul>
<p>此外，一个isolate有一个heap，用来存储所有的dart object（GC发生在这里）。</p>
<p>一个OSThread一次只能进入一个isolate，当其进入之后，该isolate的mutator thread便和这个OSThread关联起来执行dart代码。当OSThread要进入一个isolate的时候，必须先退出当前关联的isolate。</p>
<p>isolate的mutator thread可能在不同时间关联不同的OSThread，但同一时刻最多只能有一个OSThread。</p>
<p>VM执行Dart代码有两种方式：JIT和AOT，不管哪一种都不会直接执行Dart源码，而是经过转化之后的Kernel Binary(also called <em>dill files</em>)which contain serialized <a href="https://github.com/dart-lang/sdk/blob/main/pkg/kernel/README.md">Kernel ASTs</a>。</p>
<p>一般来说，从Dart source code到Dart VM执行分为下面几步：</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/dart-to-kernel.png" alt="dart-to-kernel"></p>
<blockquote>
<p>VM expects to be given <em><strong>Kernel binaries</strong></em> (also called <em>dill files</em>) which contain serialized <a href="https://github.com/dart-lang/sdk/blob/main/pkg/kernel/README.md">Kernel ASTs</a>. The task of translating <strong>Dart source</strong> into <strong>Kernel AST</strong> is handled by the <a href="https://github.com/dart-lang/sdk/tree/master/pkg/front_end">common front-end (<strong>CFE</strong>)</a> written in Dart and shared between different Dart tools (e.g. VM, dart2js, Dart Dev Compiler).</p>
</blockquote>
<p>Dart VM has multiple ways to execute the code, for example:</p>
<ul>
<li>from source or Kernel binary using <strong>JIT</strong>;</li>
<li>from snapshots:<ul>
<li>from <strong>AOT</strong> snapshot;</li>
<li>from <strong>AppJIT</strong> snapshot.</li>
</ul>
</li>
</ul>
<h1 id="1-Running-from-source-via-JIT"><a href="#1-Running-from-source-via-JIT" class="headerlink" title="1. Running from source via JIT."></a>1. Running from source via JIT.</h1><h2 id="从Dart-Source加载到VM中"><a href="#从Dart-Source加载到VM中" class="headerlink" title="从Dart Source加载到VM中"></a>从Dart Source加载到VM中</h2><p>为了保证直接从源代码执行Dart的便利性，独立的dart可执行文件承载了一个称为内核服务（<em>kernel service）</em>的辅助isolate，它处理Dart源代码编译成内核的过程。然后，VM将运行产生的内核二进制文件（Kernel Binary）。</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-service.png" alt="kernel-service"></p>
<p>上图中，一个被称为<em>kernel service</em>的isolate使用CFE将Dart Source编译为为<em>Kernel Binary</em>然后交给main isolate执行。</p>
<p>这并不是安排CFE和VM执行Dart Source的唯一方式，比如Flutter就将CFE（封装之后的）和VM分别置于两个设备上：</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/flutter-cfe.png" alt="flutter-cfe"></p>
<p>当热更新触发时，Flutter使用封装过的CFE以及一个Flutter独有的Kernel-to-Kernel转换，将修改过的Dart Source编译为Kernel Binary，然后推送到设备上面（比如手机）执行。</p>
<h2 id="在VM中执行"><a href="#在VM中执行" class="headerlink" title="在VM中执行"></a>在VM中执行</h2><p>上面是Dart Source加载到VM的过程，下面是<strong>Dart代码在VM中执行的过程</strong>分析：</p>
<p>1）当<em>Kernel Binary</em>加载到VM中之后，只会解析加载的类和库的基本信息。</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-1.png" alt="kernel-loaded-1"></p>
<p>2）当runtime实际用到的时候才会去获取完整的信息用来创建对象分配内存等：</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-2.png" alt="kernel-loaded-2"></p>
<p>此时，从<em>Kernel Binary</em>中读取出了<em>class members</em>，此时已经有足够的信息让runtime用来调用方法（successfully resolve and invoke methods）了，比如调用main方法，但是<strong>具体的方法体此时依旧还没有被反序列</strong>（deserialized）。</p>
<p>3）在这个阶段，所有的function只是持有了一个真正要执行的方法体的<em>placeholder</em>指向<em>LazyCompileStub</em>，当runtime要执行的时候再创建并运行可执行代码。</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/raw-function-lazy-compile.png" alt="raw-function-lazy-compile"></p>
<p>这时候执行方法有两个阶段：</p>
<ol>
<li><strong>unoptimized</strong> 默认执行时直接从<em>Kernel Binary</em>创建<em>IL</em>然后转化为<em>machine code</em>并运行</li>
<li><strong>optimized</strong> 在a阶段的热点代码会被从普通<em>IL</em>优化为<em>SSA IL</em>，然后转化为<em>machine code</em>运行，如果遇到优化失效的，再回退到a阶段执行代码（后面是否需要再走b阶段，需要重新判断）</li>
</ol>
<h3 id="unoptimized-code"><a href="#unoptimized-code" class="headerlink" title="unoptimized code"></a>unoptimized code</h3><p>这个阶段，从<em>Kernel Binary</em>生成<em>Machine Code</em>主要分为2步：</p>
<p><strong>（1）<em>Kernel Binary</em> → <em>IL</em></strong></p>
<p>在这个阶段，从<em>Kernel Binary</em>中的<em>AST</em>中解析产生对应的<em>control flow graph</em>(<strong>CFG</strong>)。</p>
<blockquote>
<p>CFG由<em>intermediate language</em>(<strong>IL</strong>)组成，这个阶段使用的IL指令类似基于stack的虚拟机：他们从stack中读取操作数，执行操作，然后将结果push回这个stack中。</p>
</blockquote>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/unoptimized-compilation.png" alt="unoptimized-compilation"></p>
<p>但并不是所有的方法都有对应的<em>Dart&#x2F;Kernel AST bodies</em>（比如一些<em>native</em>方法或者<em>artificial tear-off functions</em> generated by Dart VM），这种情况下，他们凭空创建（<em>in these cases IL is just created from the thin air</em>）。</p>
<p><strong>(2) <em>IL</em> → <em>Machine Code</em></strong></p>
<p>由一条IL对应生成多行machine language instruction</p>
<p>在这个阶段不会进行优化，主要目的是快速创建出可执行代码（<em>produce executable code quickly</em>）</p>
<p><strong>内联缓存（inline caching）</strong></p>
<p>在这个阶段，编译器（<em>unoptimizing compiler</em>）不会尝试静态解析任何没有在Kernel Binary中解析的调用（<em>any calls that were not resolved in Kernel binary</em>），因此调用(<code>MethodInvocation</code> or <code>PropertyGet</code> AST nodes)被认为是完全动态的， VM使用内联缓存（inline caching）来实现动态调用。</p>
<p>内联缓存的实现主要有：</p>
<ul>
<li>一个<strong>call site specific cache</strong>，将调用的类与方法映射在一起，如果receiver和已有的缓存类对应，那么就应该调用对应的方法，还有个计数器（<em>invocation frequency counters</em>）标记这个方法被调用多少次（对应下文的RawICData）</li>
<li>一个共享的<strong>lookup stub</strong>，实现了方法调用的最快路径（<em>method invocation fast path</em>），在发生调用时通过lookup stub查询是否有entry与receiver的类匹配，有的话就用调用entry并增加frequency counter；否则就调用系统的runtime system helper兜底（如果成功运行了就更新上面的缓存，这样下次调用就不用再走runtime了）。</li>
</ul>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/inline-cache-1.png" alt="inline-cache-1"></p>
<aside>
💡 **Unoptimizing compiler** by itself is enough to execute any possible Dart code.</aside>



<h3 id="optimized-code"><a href="#optimized-code" class="headerlink" title="optimized code"></a>optimized code</h3><p>虽然<strong>Unoptimizing compiler</strong>可以执行任意Dart代码，但是太慢了，所以在以上述方式执行代码的同时会记录以下信息：</p>
<ul>
<li>Inline cache收集在调用点的<strong>receiver类型</strong>（<em>receiver types observed at callsites</em>）</li>
<li>和方法对应的execution counters以及basic blocks within functions追踪代码的<strong>热点区域</strong>（hot regions of the code）</li>
</ul>
<p>Optimized compilations 和Unoptimizing compiler开始的步骤类似：</p>
<p><strong>(1) <em>Kernel Binary</em> → <em>unoptimized IL</em></strong></p>
<p><strong>(2) <em>unoptimized IL</em> → <em>SSA based IL</em> → <em>optimized IL</em></strong></p>
<p>当上述代码执行的时候，如果程序调用计数器（<em>invocation frequency counters</em>）到达某个阈值，这个方法就会被交给一个后台优化编译器（<em>background optimizing compiler</em>）来优化，将unoptimized IL转化为<em>SSA（static single assignment）</em>形式的IL。</p>
<p>最后将SSA IL优化为optimized IL。</p>
<p><strong>(3) <em>optimized IL</em> → <em>machine code</em></strong></p>
<p>在优化完成后，编译器会要求mutator thread进入safepoint并将优化后的代码绑定到方法上（attaches optimized code to the function）。</p>
<blockquote>
<p>safepoint的含义是，thread关联的state（比如heap，stack frame等）是一致的，并且可以在不中断线程的情况下访问或修改。通常意味着thread被暂停，或者在当前环境外（比如执行native代码）。</p>
</blockquote>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/optimizing-compilation.png" alt="optimizing-compilation"></p>
<p>上述这种基于乐观假设的优化，可能没法处理部分情况，从而回退到未优化的代码（deoptimization），然后再执行未优化过程（通常会丢弃优化后的代码，再判断是否有热点代码需要优化），主要有2种方式：</p>
<ol>
<li><em><strong>eager deoptimization</strong></em> 在内联检查的时候，判断优化的条件是否满足，不满足的话就丢弃优化代码</li>
<li><em><strong>lazy deoptimization</strong></em> 全局分析指示在更改优化代码的内容时丢弃优化代码（之前优化的条件不满足了）。</li>
</ol>
<h1 id="2-Running-from-AOT-snapshot"><a href="#2-Running-from-AOT-snapshot" class="headerlink" title="2. Running from AOT snapshot"></a>2. Running from <strong>AOT</strong> snapshot</h1><p>Snapshot’s format is low level and optimized for fast startup，包含了要创建的object以及如何关联这些对象的说明信息（instructions）。</p>
<p>VM可以将Heap&#x2F;甚至是Heap中的object graph序列化成为snapshot，然后再从这个snapshot中重建对应的状态：</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot.png" alt="snapshot"></p>
<p>最初的snapshot并不包含machine code，直到AOT compiler的出现。</p>
<p>AOT compiler和snapshot-with-code使得VM可以在那些JIT受限的设备上运行：</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot-with-code.png" alt="snapshot-with-code"></p>
<p><strong>snapshot-with-code</strong>和普通的<strong>snapshot</strong>基本一致，<strong>唯一不同的是多出的machine code不需要deserizlization</strong>，事实上machine code在被分配到内存后可以立即成为heap的一部分（<em>directly become part of the heap after it was mapped into memory</em>）。</p>
<h1 id="3-Running-from-AppJIT-snapshot"><a href="#3-Running-from-AppJIT-snapshot" class="headerlink" title="3. Running from AppJIT snapshot"></a>3. Running from <strong>AppJIT</strong> snapshot</h1><p><strong>AppJIT</strong> snapshot主要用于减少大型Dart application的JIT热身时间。</p>
<p>AppJIT snapshots were introduced to <strong>reduce JIT warm up time for large Dart applications</strong> like <code>dartanalyzer</code>or <code>dart2js</code>. When these tools are used on small projects they spent as much time doing actual work as VM spends JIT compiling these apps.</p>
<p>他的主要实现是：先用模拟数据在VM上运行，然后将其生成的code以及VM内部的数据结构序列化为AppJIT snapshot加载到VM中运行，只在正式的数据和模拟训练的配置无法匹配的时候执行JIT（<em>execution profile on the real data does not match execution profile observed during training</em>）。</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot-appjit.png" alt="snapshot-appjit"></p>
<h1 id="4-Running-from-AppAOT-snapshot"><a href="#4-Running-from-AppAOT-snapshot" class="headerlink" title="4. Running from AppAOT snapshot"></a>4. Running from <strong>AppAOT</strong> snapshot</h1><p>AOT与JIT各有优劣：</p>
<ul>
<li>AOT启动时间更短</li>
<li>JIT峰值性能更优</li>
</ul>
<p>无法进行JIT意味着</p>
<ol>
<li>AOT snapshot <em>must</em> contain executable code for each and every function that could be invoked during application execution;</li>
<li>the executable code <em>must not</em> rely on any speculative assumptions that could be violated during execution;</li>
</ol>
<p>为了满足上述要求， AOT汇编过程会进行全局静态分析以确定程序的哪些部分是可以从已知的entry point触达的，分配哪些类的实例，以及类型在程序中是如何应用的（which parts of the application are reachable from known set of <em>entry points</em>, instances of which classes are allocated and how types flow through the program）。</p>
<p>AOT上述这些分析是保守的，可能在准确性上犯错，与之相比，JIT则在性能方面不行，因为JIT需要deoptimize兜底实现正确的行为。</p>
<p>所以AOT将所有潜在的可触达的功能编译为native code，而无需投机性优化（All potentially reachable functions are then compiled to native code without any speculative optimizations）。</p>
<p><img src="https://jixiaoyong.github.io/images/dart_vm/aot.png" alt="aot"></p>
<p>从上图可以看出，AOT中，Kernel Binary先经过TFA收集变量、方法等信息，以此来<strong>移除不可达的方法</strong>，并devirtuablize method（确定<a href="https://www.techopedia.com/definition/24299/virtual-method#:~:text=A%20virtual%20method%20is%20a,oriented%20language%2C%20such%20as%20C%23.">虚拟方法</a>的具体执行）。之后经过VM再移除一些不可达方法。</p>
<p>Resulting snapshot can then be run using <em>precompiled runtime</em>, a special variant of the Dart VM which excludes components like JIT and dynamic code loading facilities.</p>
<h2 id="Switchable-Calls"><a href="#Switchable-Calls" class="headerlink" title="Switchable Calls"></a>Switchable Calls</h2><p>即使有全局和局部分析，AOT编译依然可能包含一些无法被非虚拟化（<em>devirtualized</em>）的call sites，为了解决这个问题，AOT编译出的代码和runtime会使用JIT中用到的内联缓存（<em>Inline Caching</em>）技术的拓展——<em><strong>switchable calls</strong></em>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md">sdk&#x2F;index.md at main · dart-lang&#x2F;sdk</a></p>
<p><a href="https://www.jianshu.com/p/a5b1997a01ba">Dart VM 介绍</a></p>
]]></content>
      <tags>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title>之前发布的几个App</title>
    <url>/blog/posts/1a589649/</url>
    <content><![CDATA[<p>在之前学习android的过程中，跟着教程做了几个app，虽然随着使用的api的失效，大多数应用如今已经不能正常使用了，但是作为初入编程的一点点小纪念，还是为他们写一个索引文章，至少能够晚一些消寂于这广阔的数据海洋中。</p>
<h1 id="NiceNews"><a href="#NiceNews" class="headerlink" title="NiceNews"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/">NiceNews</a></h1><p>Posted on 2016-05-30</p>
<p>NieceNews我制作的第二款APP，一个实时新闻软件。</p>
<p><img src="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/images/icon.png" alt="NiceNews"></p>
<h1 id="IWeather"><a href="#IWeather" class="headerlink" title="IWeather"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/IWeather/">IWeather</a></h1><p>Posted on 2016-07-16</p>
<p>IWeather，我的第三个Android应用，一个天气预报APP。</p>
<p><img src="http://jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/IWeather/images/1.png" alt="IWeather"></p>
<h1 id="2048"><a href="#2048" class="headerlink" title="2048"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/2048/">2048</a></h1><p>Posted on 2016-07-21</p>
<p>2048，我的第四个Android应用，同时也是我的第一款游戏APP。</p>
<p><img src="http://jixiaoyong.github.io/blogbackup/blog_2016To2017/2016/07/2048/images/1.png" alt="2048"></p>
<h1 id="I看知乎"><a href="#I看知乎" class="headerlink" title="I看知乎"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/I%E7%9C%8B%E7%9F%A5%E4%B9%8E/">I看知乎</a></h1><p>Posted on 2016-07-24   | </p>
<p>i看知乎，我的第五个Android应用。</p>
<p><img src="http://jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/I%E7%9C%8B%E7%9F%A5%E4%B9%8E/images/1.png" alt="logo"></p>
<p>学习的过程需要不断的重复，更需要有条理的总结，我会把平时学习的心得体会，经验，以及无聊时瞎琢磨得出来的稀奇古怪的想法放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。</p>
]]></content>
  </entry>
  <entry>
    <title>从Sunflower开始学习优雅的Jetpack架构</title>
    <url>/blog/posts/27065732/</url>
    <content><![CDATA[<blockquote>
<p>Google大法NB！！！(破音)</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://developer.android.google.cn/jetpack/">Jetpack</a>是Google推出的一系列Android软件集合，*”使您可以更轻松地开发出色的 Android 应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上”*。</p>
<p><a href="https://github.com/googlesamples/android-sunflower">Sunflower</a>则是Google用来演示如何使用Jetpack进行Android开发的Demo，有着非常优雅的架构与十分简洁的代码，可以帮助我们很好地学习Jetpack以及MVVM思想。</p>
<p>本文主要是结合Sunflower中的示例代码，分析Jetpack架构中各部分的作用，以及他们如何巧妙的搭配使用，方便指导日后对Jetpack的使用。</p>
<blockquote>
<p>本文中的大部分代码、示意图除非特殊注明外，皆来自Google的<a href="https://github.com/googlesamples/android-sunflower">Sunflower工程</a>或其他互联网资源，根据篇幅需要做了部分精简，所有权益归原作者所有。</p>
</blockquote>
<p>下图是<a href="https://developer.android.google.cn/jetpack/">Google Jetpack官网</a>对Jetpack的介绍图：</p>
<center>     <img style="border-radius: 0.3125em;     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"      src="https://jixiaoyong.github.io/images/jetpack_donut.png">     <br>     <div style="color:orange; border-bottom: 1px solid #d9d9d9;     display: inline-block;     color: #999;     padding: 2px;">Jetpack示意图 <font style="color: #BEBEBE">来自GoogleJetpack官网</font></div> </center>
# 对Sunflower的整体分析

<p>下图是Sunflower架构的简单示意图：</p>
<p><img src="https://jixiaoyong.github.io/images/20190124212220.png"></p>
<p>可以看到，APP的界面有<code>我的花园</code>、<code>植物目录</code>和<code>植物介绍</code>三部分，这三者的切换逻辑通过<font color=#0288d1 size=4><strong><code>Navigation</code></strong></font>实现。</p>
<p>每个界面的**<code>XML</code><strong>中的布局信息（包括<code>数据、事件（clickListener等），RecycleView的LayoutManager，Adapter等等</code>）通过<font color=#0288d1 size=4></strong><code>DataBinding</code><strong></font>与<font color=#0288d1 size=4></strong><code>ViewModel</code><strong></font>中的可观察数据<font color=#0288d1 size=4></strong><code>LiveData</code><strong></font>绑定在一起，只要数据库中的<code>数据</code>有更新，就会通过<code>LiveData</code>主动通知布局更新界面；同时<code>DataBinding</code>还通过与<code>Adapter</code>（这些继承自</strong><code>ListAdapter</code><strong>的Adapter实现了<font color=#0288d1 size=4></strong><code>Paging</code>**</font>的作用）将<code>ItemView</code>的<code>ViewModel</code>与布局<code>XML</code>中绑定在一起，通过<code>BindingAdapter</code>对<code>XML</code>中的数据做预处理（加载imgUrl中的图片到ImageView等等）。</p>
<p>在<font color=black size=5><strong><code>View</code></strong></font>中指定这些<code>DataBinding</code>与<font color=black size=5><strong><code>ViewModel</code></strong></font>之间以及<code>ViewModel</code>与<font color=black size=5><strong><code>Model</code></strong></font><code>数据库</code>之间的逻辑关系，这些数据与操作都受着<font color=#0288d1 size=4><strong><code>Lifecycle</code></strong></font>的影响。</p>
<p><code>ViewModel</code>的数据来源——<code>Model</code>在这里的实现是一个<code>数据库</code>。每个<code>ViewModel</code>有一个<code>XXXViewModelFactory</code>类，用来使用数据类<code>XXXRepository</code>类的实例创建对应的<code>ViewModel</code>。<code>XXXViewModelFactory</code>向<code>Activity</code>等屏蔽了<code>ViewModel</code>的具体实现。</p>
<p><code>XXXRepository</code>类的出现时为了将<code>ViewModel</code>与数据的具体实现解耦合，这样<code>ViewModel</code>只需要关心他要的操作而不必关系数据来源的具体实现。在本例中，<code>XXXRepository</code>类对应封装了这数据库<code>AppDatabase</code>中对两个表的操作。</p>
<p>数据库使用<font color=#0288d1 size=4><strong><code>Room</code></strong></font>实现，从底层开始依次分为<code>表Entity</code>，<code>数据访问对象DAO</code>和<code>数据库DataBase</code>三个层次。每个DAO对应一个包装类<code>XXXRepository</code>类供<code>ViewModel</code>使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Entity    GardenPlanting    //表，定义了存储的数据项及其格式</span><br><span class="line">@Dao    GardenPlantingDao    //数据访问对象，定义了例如插入数据、查询数据等操作</span><br><span class="line"> GardenPlantingRepository    //对DAO的封装，将数据的的具体实现与ViewModel对数据的操作解耦</span><br><span class="line">@Database     AppDatabase    //数据库，包括表和对表的操作</span><br></pre></td></tr></table></figure>

<p><font color=#0288d1 size=4><strong><code>WorkManager</code></strong></font>则管理着一个从Json读取数据并加载到数据库中的后台任务<code>SeedDatabaseWorker</code>。</p>
<h1 id="具体实现分析"><a href="#具体实现分析" class="headerlink" title="具体实现分析"></a>具体实现分析</h1><p>首先看一下**<code>View</code>**部分，Sunflower只有简单的3个页面，全都是用<code>Fragment</code>实现，由<code>Activity</code>通过<code>Navigation</code>控制切换：</p>
<ul>
<li><code>GardenActivity</code> 主页面，唯一的一个Activity</li>
<li><code>GardenFragment</code> 我的花园 界面，会显示用户在植物目录中选择并种植的植物信息</li>
<li><code>PlantListFragment</code> 植物目录 界面，所有的植物信息列表</li>
<li><code>PlantDetailFragment</code> 植物介绍 界面，当在“我的花园”或“植物列表”选择了某个植物后，会进入该界面显示植物详细介绍</li>
</ul>
<h2 id="Navigation控制界面切换"><a href="#Navigation控制界面切换" class="headerlink" title="Navigation控制界面切换"></a>Navigation控制界面切换</h2><p>先看一下<a href="https://developer.android.google.cn/topic/libraries/architecture/navigation/">Navigation</a>的定义：</p>
<blockquote>
<p>Navigation是APP设计中的关键部分，可以用来定义用户从不同的界面切换、进入和推出的交互逻辑。</p>
</blockquote>
<p>和布局文件一样，我们可以在编译器的可视化界面中，直接预览、设计不同界面切换效果。他可以负责<code>Fragment</code>、<code>Activity</code>、<code>Navigation graphs</code> 与 <code>subgraphs</code> 以及<code>Custom destination types</code>，他们之间通过不同的<code>action</code>连接起来。</p>
<p>通过官方文档可知，<code>Navigation</code>可以和<code>AppBar</code>，<code>ToolBar</code>等组合起来控制Fragment显示，此外可以通过<code>ViewModel</code>在绑定到同一个<code>Activity</code>的<code>Fragment</code>之间共享数据，或者也可以通过<a href="https://developer.android.google.cn/topic/libraries/architecture/navigation/navigation-pass-data"><code>Bundle</code>或<code>Safe Args</code></a>在两个<code>Fragment</code>之间传递数据。</p>
<p>那么，在<code>Sunflower</code>中<code>Navigation</code>是怎么控制界面切换的呢？</p>
<p>首先，在<code>res/navigation/</code>目录下面新建一个<code>嵌套导航图(Nested navigation graphs)</code>,定义各个界面之前的切换关系：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">&quot;@+id/garden_fragment&quot;</span>&gt;</span></span><br><span class="line">//app:startDestination定义了在这个导航图中首次启动展示的界面</span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/garden_fragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.google.samples.apps.sunflower.GardenFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/my_garden_title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_garden&quot;</span>&gt;</span></span><br><span class="line">//action定义了在各个界面的切换关系</span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_garden_fragment_to_plant_detail_fragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/plant_detail_fragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:enterAnim</span>=<span class="string">&quot;@anim/slide_in_right&quot;</span>//<span class="attr">enterAnim</span>等指定执行<span class="attr">action</span>时的动画</span></span><br><span class="line"><span class="tag">          <span class="attr">...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">//argument定义了在切换界面时需要带的参数，需要androidx.navigation.safeargs的支持,具体见参考资料-Android Jetpack-Navigation 使用中参数的传递</span><br><span class="line">        <span class="tag">&lt;<span class="name">argument</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;plantId&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:argType</span>=<span class="string">&quot;string&quot;</span> /&gt;</span>//参数类型小写</span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在Activity对应的XML中插入该导航：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/garden_nav_fragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;androidx.navigation.fragment.NavHostFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:defaultNavHost</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:navGraph</span>=<span class="string">&quot;@navigation/nav_garden&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后就可以在Activity或者Fragment中获取该导航的实力，用来切换界面了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//activity</span></span><br><span class="line"><span class="keyword">val</span> navController = Navigation.findNavController(<span class="keyword">this</span>, R.id.garden_nav_fragment)</span><br><span class="line"><span class="comment">//fragment或其他地方</span></span><br><span class="line"><span class="keyword">val</span> direction = GardenFragmentDirections<span class="comment">//嵌套导航图中Fragment自动生成的类</span></span><br><span class="line">.ActionGardenFragmentToPlantDetailFragment(plantId)</span><br><span class="line">it.findNavController().navigate(direction)</span><br></pre></td></tr></table></figure>

<h2 id="DataBinding绑定布局和数据"><a href="#DataBinding绑定布局和数据" class="headerlink" title="DataBinding绑定布局和数据"></a>DataBinding绑定布局和数据</h2><p>Navigation解决了不同的布局间交互的逻辑，DataBinding则充当布局View和数据（ViewModel、LiveData）之间的桥梁，将二者联系起来。</p>
<p>从<a href="https://developer.android.google.cn/topic/libraries/data-binding/">官网</a>的表述中我们知道，DataBinding使用在XML中声明的方式（而非编程的方式），将布局中的组件捆绑到APP中使用到的数据上，这样当数据更新时，布局也会随之自动更新。</p>
<p>DataBinding在XML中的形式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;viewmodel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.myapp.data.ViewModel&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintLayout...</span> /&gt;</span> <span class="comment">&lt;!-- UI layout&#x27;s root element --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是原先的页面布局信息<code>&lt;ConstraintLayout... /&gt;</code>包裹在<code>&lt;layout... /&gt;</code>中，同时多了一个数据域<code>&lt;data... /&gt;</code>，我们可以在其中定义一些变量<code>&lt;variable... /&gt;</code>，并在布局中使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewmodel.userName&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了常见的<code>android:text</code>，<code>android:onClick</code>等通用的属性可以直接绑定外，我们还可以通过自定义<a href="https://developer.android.google.cn/topic/libraries/data-binding/binding-adapters.html"><strong>Binding adapters</strong></a>支持更多形式的属性绑定：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;app:goneUnless&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">goneUnless</span><span class="params">(view: <span class="type">View</span>, visible: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    view.visibility = <span class="keyword">if</span> (visible) View.VISIBLE <span class="keyword">else</span> View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就支持了<code>app:goneUnless</code>的解析，我们只要在XML中为组件加上这个属性就可以实现相应的效果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewmodel.userName&#125;&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">app:goneUnless</span>=<span class="string">&quot;@&#123;viewmodel.isGone&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，我们需要在对应的Activity或Fragment中，用如下代码将布局与页面绑定到一起：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setContentView(R.layout.activity_main)</span></span><br><span class="line"><span class="keyword">val</span> binding: ActivityMainBinding = DataBindingUtil.setContentView(</span><br><span class="line">            <span class="keyword">this</span>, R.layout.activity_main)</span><br><span class="line">binding.viewmodel = ...</span><br></pre></td></tr></table></figure>

<p>这里的<code>ActivityMainBinding</code>类是<code>DataBinding</code>根据XML文件的名字自动替我们生成的，规律是<code>XML文件名+Binding</code>的驼峰命名。</p>
<p>在Sunflower中有类似的应用有很多处：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Copyright 2018 Google LLC ...</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">                <span class="attr">name</span>=<span class="string">&quot;hasPlantings&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">type</span>=<span class="string">&quot;boolean&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">&quot;@+id/garden_list&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:isGone</span>=<span class="string">&quot;@&#123;!hasPlantings&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layoutManager</span>=<span class="string">&quot;androidx.recyclerview.widget.LinearLayoutManager&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">tools:listitem</span>=<span class="string">&quot;@layout/list_item_garden_planting&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ViewModel管理数据与页面的交互"><a href="#ViewModel管理数据与页面的交互" class="headerlink" title="ViewModel管理数据与页面的交互"></a>ViewModel管理数据与页面的交互</h2><p><code>DataBinding</code>通过标记的形式将数据和组件绑定，在这个过程中他使用的数据则是来自于<code>ViewModel</code>的。在页面<code>Activity</code>(或<code>Fragment</code>)中，我们可以处理这两者之间的关系。</p>
<p><code>ViewModel</code>是设计用来以一种可以感知生命周期（<code>lifecycle</code>）的方式存储和管理与UI相关的数据，它可以允许数据在诸如屏幕旋转的变化中存活下来，也就是说<code>VideModule</code>的数据生命周期可能要比他附着的<code>Activity</code>或<code>Fragment</code>的生命周期长。</p>
<p>同时，<code>UI controller</code>可以在<code>Activity</code>等不再需要数据时，自动调用<code>ViewModel</code>的<code>onCleared()</code>方法清除这些数据以避免内存泄漏。</p>
<p>下图是<code>ViewModel</code>和<code>Activity</code>的生命周期对比：</p>
<center>     <img style="border-radius: 0.3125em;     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"      src="https://jixiaoyong.github.io/images/20190202161443.png">     <br>     <div style="color:orange; border-bottom: 1px solid #d9d9d9;     display: inline-block;     color: #999;     padding: 2px;">ViewModel和Activity的生命周期对比图：左图Activity先经历了一次旋转，然后finish，右边是与此相关的ViewModel的生命周期<br/><font style="color: #BEBEBE">来自GoogleJetpack官网</font></div> </center>
此外，由于默认的获取ViewModel的方法只能调取无参构造函数，当需要向ViewModel传递参数时，就需要用到Factory工厂模式来创建ViewModel：

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> viewModel = ViewModelProviders.of(<span class="keyword">this</span>, factory).<span class="keyword">get</span>(GardenPlantingListViewModel::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlantDetailViewModelFactory</span></span>(args:Any) : ViewModelProvider.NewInstanceFactory() &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>还可以将<code>ViewModel</code>于<code>LiveData</code>结合，这样在<code>Activity</code>等地方对<code>LiveData</code>进行订阅后，当<code>LiveData</code>的值发生变化时<code>Activity</code>等可以及时得到通知，而做出相应变化。此外<code>ViewModel</code>与<code>lifecycle</code>的结合可以保证在<code>Activity</code>等生命周期结束后数据得到及时的清理。</p>
<h2 id="Room保存数据"><a href="#Room保存数据" class="headerlink" title="Room保存数据"></a>Room保存数据</h2><blockquote>
<p>Room持久性库在SQLite上提供了一个抽象层，以便在充分利用SQLite强大功能的同时，能够流畅的访问数据库。——Android Developers</p>
</blockquote>
<p><code>Room</code>需要3个元素：</p>
<ul>
<li><code>Database</code> 数据库，可以提供对表格的操作方法<code>@DAO</code>。是一个继承自<code>RoomDatabase</code>的抽象类。</li>
<li><code>Entity</code> 表格，规定了每个表格可以保存的数据格式。是一个普通类。</li>
<li><code>Dao</code> 数据访问结构（<code>Data Access Object</code>），定义了对表格<code>@Entity</code>中的数据的操作。是一个接口或者抽象类。</li>
</ul>
<p>此外，还可以对<code>@DAO</code>进行进一步的封装得到一个<code>XXXRepository</code>类，<code>ViewModel</code>通过这个<code>XXXRepository</code>类来操作数据，从而将其与数据的具体实现解耦。</p>
<h2 id="WorkManager管理任务"><a href="#WorkManager管理任务" class="headerlink" title="WorkManager管理任务"></a>WorkManager管理任务</h2><p><code>WorkManager</code>用来管理即时或定时任务，官方定义是在指定约束条件成熟时可靠的在后台执行对应的任务。</p>
<p>具体使用可以参考这个<a href="https://gist.github.com/jixiaoyong/041d8b0775e392302b4cd57a98b4f6fa">GIST</a>。</p>
<p>和他相关的有下面几个关键类：</p>
<ul>
<li><code>Worker</code> 定义要执行的任务内容</li>
<li><code>WorkRequest</code> 代表一项单独的任务，明确具体要执行的任务内容（Worker）、任务的类型（WorkRequest.Builder的子类，决定任务一次性还是重复的）以及任务执行的条件（Constraints，如联网、电池电量等等）</li>
<li>WorkManager 执行管理WorkRequest，安排执行Worker中的工作内容。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.android.google.cn/jetpack/">Android Jetpack官网</a></p>
<p><a href="https://blog.csdn.net/weixin_42215792/article/details/80395379">Android Jetpack-Navigation 使用中参数的传递</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>利用travis通过Hexo在Github上自动部署Markdown文档</title>
    <url>/blog/posts/b00ac86a/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文介绍了一个只需要更新Markdown文档到Github，即可实时更新博客内容的方法。</p>
<p>本文参考<a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a">这篇文章</a> 实现，并根据我的需求更改了部分内容，以实现<strong>部署多个hexo工程到同一Github项目不同目录下</strong>。</p>
</blockquote>
<p>Github为我们提供了<a href="https://pages.github.com/">Github Pages</a> 方便我们建立简单的网页来介绍项目，很多时候我们用他来搭建静态博客。</p>
<p>通过<a href="https://hexo.io/">Hexo</a>可以将我们写的<code>Markdown文档</code>格式化为<code>静态网页</code>，再将其部署到Github上面对应的<code>user_name.github.io</code>上面，就可以拥有一个在线的静态博客。</p>
<p>但是受Hexo的限制，每次更新博客内容都需要在更新完Markdown文档后，都需要再次重新创建对应的静态网页、将更新提交到Github。这样的步骤繁琐且没有意义，而且更换电脑后这些环境都需要重新设置一次。</p>
<p>通过<a href="https://www.travis-ci.org/">travis</a>提供的免费CI技术，可以让云服务器代替我们实现Hexo创建以及同步Github等步骤，每次更新博客时<strong>只需要将写好的Markdown文档推送到Github项目对应目录中，等待一会儿就可以看到更新后的博客了</strong>。</p>
<p>具体搭建过程可以参考<a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a">这篇文章</a> 本文只讲述实现<strong>部署多个hexo工程到同一Github项目不同目录下</strong>需要注意的地方：。</p>
<blockquote>
<p><strong>懒——是第一生产力</strong></p>
</blockquote>
<h1 id="具体差异"><a href="#具体差异" class="headerlink" title="具体差异"></a>具体差异</h1><h2 id="hexo分支的结构"><a href="#hexo分支的结构" class="headerlink" title="hexo分支的结构"></a>hexo分支的结构</h2><p>因为有多个hexo项目，所以在github项目的hexo分支下，对不同的hexo项目分别新建文件夹存放。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- your_name.github.io //github项目，切换到hexo分支</span><br><span class="line">  --hexo_project1 //本地hexo项目1的所有文件</span><br><span class="line">  --hexo_project2 //本地hexo项目2的所有文件</span><br></pre></td></tr></table></figure>

<h2 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h2><p>重点修改<code>script:</code>和<code>after_script:</code>两部分：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="comment"># 1. 创建对应的静态博客内容</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">blog</span> <span class="comment"># 第一个本地hexo项目</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">imissyou</span> <span class="comment"># 第二个本地hexo项目</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">&quot;jixiaoyong&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">&quot;jixiaoyong1995@gmail.com&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">publish</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">publish</span></span><br><span class="line">  <span class="comment"># 2. 在这里再拉取master分支的文件，并删除旧的博客内容</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://$&#123;GH_TOKEN&#125;@github.com/jixiaoyong/jixiaoyong.github.io.git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">./jixiaoyong.github.io/blog/*</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">./jixiaoyong.github.io/imissyou/*</span></span><br><span class="line">   <span class="comment"># 3. 将第1步生成的静态博客内容添加到master分支，并同步到github上面</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-rf</span> <span class="string">jixiaoyong.github.io/blog/public/*</span> <span class="string">publish/jixiaoyong.github.io/blog/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-rf</span> <span class="string">jixiaoyong.github.io/imissyou/public/*</span> <span class="string">publish/jixiaoyong.github.io/imissyou/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">publish/jixiaoyong.github.io/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;auto update by www.travis-ci.org&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure>

<p>文档链接：<a href="https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/.travis.yml">.travis.yml</a></p>
<h1 id="更新博客内容"><a href="#更新博客内容" class="headerlink" title="更新博客内容"></a>更新博客内容</h1><p>当以上内容都配置完成后，只要新建一个符合hexo要求的文档，并提交到Github对应项目的hexo分支中<code>source</code>目录，Travis便会自动帮我们创建并更新静态网页。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a">Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程</a> （完全在该文档指导下完成，部分步骤有差异，感谢作者<a href="https://juejin.im/user/56efe6461ea493005565dafd">MichaelX</a> ）</p>
]]></content>
      <tags>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github=Blog</title>
    <url>/blog/posts/f7965978/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World！</span><br></pre></td></tr></table></figure>

<p>一直以来，为了有一个合适的在线写字的地方，我尝试过许多种工具，从最初的 QQ 空间开始，到各种门户网站的博客，再到自己开始尝试搭建博客，一路奔忙，门户网站的限制太多，自己搭建的博客又时常由于空间提供商的各种问题而无法访问。许多时候一个平台只能使用一段时间，这样子颠颠撞撞大概也有五六年的时间了。</p>
<p>一直听说 github 这个平台的各种优点，尤其是可以作为稳定而免费的空间托管博客最令我心动，但是之前多次尝试不得其道，终以失败告终。最近在学习 Android 语言的时候，又再次用起了 github ，不过这次是用它来存储代码。不得不承认，使用 github 来控制程序版本真是一件令人愉悦的事件。</p>
<p>机缘巧合，因为需要将学习过程中的一些笔记，心得总结找个地方整理，显然单纯的使用 github 并不是一个好办法，而其他的平台的博客限制又太多，于是又尝试用 github 搭建一个博客，虽然对这些知识并不是很熟悉，但误打误撞竟然也成功的搭建好了博客。下面就把整个建站的过程大概梳理一下，以便以后查看。</p>
<h1 id="准备软件"><a href="#准备软件" class="headerlink" title="准备软件"></a>准备软件</h1><p>下载软件：</p>
<ul>
<li>node 客户端</li>
<li>git</li>
<li>github windows 客户端(可选)</li>
</ul>
<h1 id="装-git-和-github-windows-客户端"><a href="#装-git-和-github-windows-客户端" class="headerlink" title="装 git 和 github windows 客户端"></a>装 git 和 github windows 客户端</h1><ul>
<li><p>安装 git:</p>
<p>git 安装时按照默认的配置，一路点击确定就可以。</p>
</li>
<li><p><del>安装 github客户端（可选，如果熟悉git命令可以直接命令行操作）</del></p>
<p><del>github 安装分为两种：</del><br><del>一种是直接用官网的安装包，在安装的时候需要从网上下载资料，受网速限制，这种方法很慢，而且容易出错；<br>另一种直接找一份github离线安装包解压到本地即可使用，我就是使用后一种方法。</del></p>
</li>
</ul>
<h1 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h1><ul>
<li>安装 node 客户端<br>下载并安装 node ,我使用的版本是 node-v5.7.1-x64。</li>
</ul>
<p>在安装完 git, node 之后</p>
<ul>
<li>win 键 + R 输入cmd 打开 windows 自带命令行，<br>分别输入<code>git</code> 、 <code>npm</code><br>之后，如果显示出帮助信息而非<em>“不是内部或外部命令，也不是可运行的程序或批处理文件”</em>这样的提示，就说明 git 和 node 已经配置好了环境变量，否则就需要手动配置。</li>
</ul>
<h1 id="配置环境变量方法："><a href="#配置环境变量方法：" class="headerlink" title="配置环境变量方法："></a>配置环境变量方法：</h1><ul>
<li>此电脑 –&gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量</li>
<li>找到用户环境变量 –&gt; path ，如下图<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-23_17-41-1.png"><img src="http://upload-images.jianshu.io/upload_images/120748-8aae916f0dfa3dd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改用户环境变量前"></a></li>
</ul>
<p>如下图修改<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-23_17-41-44.png"><img src="http://upload-images.jianshu.io/upload_images/120748-aa40a7e6049eeecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改系统环境变量后"></a></p>
<p>这样子 node 应该就可以正常使用了。</p>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>打开命令行，全局安装 Hexo ,加 -g 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<p>查看 hexo 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Blockquotehexo-cli: 1.0.1os: Windows_NT 10.0.14316 win32 x64http_parser: 2.6.2node: 5.7.1v8: 4.6.85.31uv: 1.8.0zlib: 1.2.8ares: 1.10.1-DEVicu: 56.1modules: 47openssl: 1.0.2g</span><br></pre></td></tr></table></figure>

<p>到这里 hexo 就在电脑上面安装好了。</p>
<h1 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h1><ul>
<li>进入存放 hexo 文件的目录下，创建一个文件夹blog存储 hexo 的文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<p>然后进入这个文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure>

<p>启动 hexo 服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop</span><br></pre></td></tr></table></figure>

<p>打开本地地址：<a href="http://localhost:4000/">http://localhost:4000/</a> ，就可以看到本地搭建好的 hexo 博客了<br>这样子一个 hexo 博客就在本地搭建好了</p>
<h1 id="目录的解释："><a href="#目录的解释：" class="headerlink" title="目录的解释："></a>目录的解释：</h1><p>scaffolds 脚手架，也就是一个工具模板 scripts 写文件的js，扩展hexo的功能<br>source 存放博客正文内容<br>source&#x2F;_drafts 草稿箱<br>source&#x2F;_posts 文件箱<br>themes 存放皮肤的目录<br>themes&#x2F;landscape默认的皮肤<br>_config.yml 全局的配置文件<br>db.json 静态常量</p>
<h1 id="一些-hexo-语句解释"><a href="#一些-hexo-语句解释" class="headerlink" title="一些 hexo 语句解释"></a>一些 hexo 语句解释</h1><p>help 查看帮助信息<br>init 创建一个hexo项目<br>migrate 从其他系统向hexo迁移<br>version 查看hexo的版本<br>–config参数，指定配置文件，代替默认的_config.yml<br>–debug参数，调试模式，输出所有日志信息<br>–safe参数，安全模式，禁用所有的插件和脚本<br>–silent参数，无日志输出模式</p>
<h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p>命名为“新的文章”，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new 新的文章</span><br></pre></td></tr></table></figure>

<p>hexo 默认生成 md 文件，新生成的文章在目录：.\blog\source_posts\新的文章.md ，对其进行相应的编辑即可<br>文章格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 新的文章date: 2014-05-07 18:44:12updated : 2014-05-10 18:44:12permalink: abctags:- 开始- 我- 日记categories:- 日志- 第一天---</span><br></pre></td></tr></table></figure>

<h1 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h1><ul>
<li>注册并登录 github<br>进入 <a href="https://github.com/">https://github.com/</a> ，注册新账户，并且登录</li>
<li>新建 respositoy<br>在主页点击 New respositoy 新建一个名字为yourname.github.io<br> 的 respositoy；<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/1461473623662.jpg"><img src="http://upload-images.jianshu.io/upload_images/120748-fbb8934ceb25f0d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建 respositoy"></a></li>
<li>设置新建一个 github pages<br>进入仓库主页，选择settings –&gt; github pages –&gt; Launch automatic page generator ,按照默认的主题配置选择一个就好<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-24_12-59-58.png"><img src="http://upload-images.jianshu.io/upload_images/120748-c6e9742ee6120d8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Launch automatic page generator"></a></li>
<li>上传网站<br>对于 hexo 的相关配置：<br>打开_config.yml，修改以下部分：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sitetitle: Jixiaoyong&#x27;s Blog</span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">author: Jixiaoyong</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:# URL</span><br><span class="line">#If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; </span><br><span class="line">and root as &#x27;/child/&#x27;</span><br><span class="line">url: http://yoursite.github.io/</span><br><span class="line">root: http://yoursite.github.io/blog/</span><br></pre></td></tr></table></figure>

<p>此处由于我是将网站放在二级目录 .&#x2F;blog&#x2F; 下面，所以 root 目录设置如此，使用的是绝对路径，否则在网页上显示的时候，css 等由于路径不对，加载可能会有问题。</p>
<p><strong>部署方法1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy: type: git repo:https://github.com/yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure>

<p>这行语句是使用 hexo 自动 deploy 到 github 时的设置，<del>如果正常的话，当用 hexo 对网站静态化处理后，再执行 hexo deploy 就可以自动部署到 github 上面了，但是我的电脑 git 或者 node 由于是不同时间装的期间还重装了几次系统，可能导致某些设置有误，所以在执行 hexo deploy 的时候一直提示有问题，故而采用另一种办法手动同步网站，这句话也可以不修改。</del></p>
<p><strong>部署方法1</strong></p>
<ul>
<li><p>用 hexo 对文章进行静态化处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在<code>blog\public</code>目录下生成的 <code>public</code> 包含所有的静态化文件,此时，这个文件夹内所有的内容就是处理好的网站，将其发布到合适的空间就可以正常显示。<br>由于之前的 git 或者 node 配置有误，所以这时候采用手动同步网站:</p>
<ul>
<li>将上次在 github 上建立的项目yourname.github.io<br>同步到本地。<br>同步的方法很多，这里我选择的是使用 github 的 windows 客户端，比较方便：</li>
</ul>
<p>打开 github 客户端，找到项目，选择clone到本地即可。<br><img src="http://upload-images.jianshu.io/upload_images/120748-9100b83bb7ebf3b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步项目到本地"></p>
<p>之后打开同步的项目，确认当前的branch是master，否则同步之后网站不会显示。<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/1461461275758.jpg"><img src="http://upload-images.jianshu.io/upload_images/120748-620f9db488c0c384.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确认是 master"></a></p>
<p>在 github 同步的目录下找到上次建好的项目<code>yourname.github.io</code>,进入之后，将上文获得到的public内容放入目标文件夹，我选择的是将博客放在子目录，所以这里新建了一个blog文件夹用于放置博客，所以就是将public<br>全部内容 放入.&#x2F;yourname.github.io&#x2F;blog&#x2F; 目录下，这样子在网站上显示的时候，博客的网址就是<a href="http://yourname.github.io/blog/">http://yourname.github.io/blog/</a></p>
<p>这样一个简单的利用 github 托管的 hexo 博客就搭建好了。<br>注：本文内容是根据我建立博客时的做法整理而成，其中有部分内容是参考网上的教程，文中引用的文字全部来自<a href="http://blog.fens.me/hexo-bootstarp-github/">http://blog.fens.me/hexo-bootstarp-github/</a> ，此文对我帮助很大，感谢作者张丹(Conan)的分享。</p>
]]></content>
  </entry>
  <entry>
    <title>加载已安装应用、未安装apk中的资源</title>
    <url>/blog/posts/8d60b485/</url>
    <content><![CDATA[<p> 加载已安装应用、未安装apk中的资源，其思路主要是获取到对应的ClassLoader&#x2F;Context，通过ClassLoader加载R.java等类，再通过反射获取对应的资源id及资源。</p>
<h1 id="加载已安装应用资源"><a href="#加载已安装应用资源" class="headerlink" title="加载已安装应用资源"></a>加载已安装应用资源</h1><h2 id="sharedUserId"><a href="#sharedUserId" class="headerlink" title="sharedUserId"></a>sharedUserId</h2><p>在当前应用中加载已安装的其他应用资源，需要二者有相同的<code>sharedUserId</code>，这样Android系统为二者分配同一个Linux用户ID，两个App可以相互访问代码、资源等。</p>
<blockquote>
<p>通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样。</p>
<p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51316688">Android逆向之旅—Android中的sharedUserId属性详解 - CSDN博客</a></p>
</blockquote>
<p>具体设置方法如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;cf.android666.dynamicloadapk&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:sharedUserId</span>=<span class="string">&quot;cf.android666.dynamic&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="筛选所有已安装应用信息"><a href="#筛选所有已安装应用信息" class="headerlink" title="筛选所有已安装应用信息"></a>筛选所有已安装应用信息</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> packageBeanList: ArrayList&lt;PackageInfoBean&gt; = arrayListOf()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> packageInfoList: ArrayList&lt;PackageInfo&gt; = arrayListOf()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> packageInfoList = packageManager.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES) <span class="keyword">as</span> ArrayList&lt;PackageInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (packageInfoList.isNotEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> packageInfoList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.sharedUserId != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; x.sharedUserId.equals(sharedUid)</span><br><span class="line">            &amp;&amp; !x.packageName.equals(packageName)) &#123;</span><br><span class="line">            <span class="comment">//sharedUserId与当前App相同，且packageName和当前App不同的App信息，即插件App</span></span><br><span class="line">            packageBeanList.add(PackageInfoBean(packageManager</span><br><span class="line">                                                .getApplicationLabel(x.applicationInfo).toString(), x.packageName))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成插件App的Context"><a href="#生成插件App的Context" class="headerlink" title="生成插件App的Context"></a>生成插件App的Context</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">activity.createPackageContext(<span class="string">&quot;cf.android666.pluginapp&quot;</span>,</span><br><span class="line">        Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY)</span><br></pre></td></tr></table></figure>

<h2 id="通过Context反射获取插件App中的资源"><a href="#通过Context反射获取插件App中的资源" class="headerlink" title="通过Context反射获取插件App中的资源"></a>通过Context反射获取插件App中的资源</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取ClassLoader</span></span><br><span class="line"><span class="keyword">var</span> pClassLoader = PathClassLoader(pluginContext.packageResourcePath</span><br><span class="line">                , ClassLoader.getSystemClassLoader())</span><br><span class="line"><span class="comment">//反射获取该类及其资源</span></span><br><span class="line"><span class="keyword">var</span> clazz = pluginContext.classLoader</span><br><span class="line">        .loadClass(pluginContext.packageName + <span class="string">&quot;.R\$mipmap&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> abc = clazz.getField(s)</span><br><span class="line"><span class="keyword">var</span> id = abc.getInt(R.mipmap::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="comment">//调用插件App的Context获取其资源</span></span><br><span class="line"><span class="keyword">var</span> bg = pluginContext.resources.getDrawable(id)</span><br></pre></td></tr></table></figure>

<h1 id="加载未安装Apk内资源"><a href="#加载未安装Apk内资源" class="headerlink" title="加载未安装Apk内资源"></a>加载未安装Apk内资源</h1><h2 id="获取apk信息"><a href="#获取apk信息" class="headerlink" title="获取apk信息"></a>获取apk信息</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sdPath = Environment.getExternalStorageDirectory().absolutePath</span><br><span class="line"><span class="keyword">val</span> apkPath = <span class="string">&quot;<span class="variable">$sdPath</span>/plugin/plugin.apk&quot;</span></span><br><span class="line"><span class="keyword">var</span> info = packageManager.getPackageArchiveInfo(apkPath, PackageManager.GET_ACTIVITIES)<span class="comment">//获取未安装apk的packageInfo</span></span><br></pre></td></tr></table></figure>

<h2 id="获取ClassLoader"><a href="#获取ClassLoader" class="headerlink" title="获取ClassLoader"></a>获取ClassLoader</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> file = getDir(<span class="string">&quot;dex&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">var</span> dexClassLoader = DexClassLoader(apkPath, file.absolutePath, <span class="literal">null</span>, ClassLoader.getSystemClassLoader())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getDir()调用了Context的getDir()</p>
<p>Retrieve, creating if needed, a new directory in which the application can place its own custom data files.  You can use the returned File object to create and access files in this directory.  Note that files created through a File object will only be accessible by your own application; you can only set the mode of the entire directory, not of individual files.</p>
</blockquote>
<h2 id="通过反射加载类，获取资源"><a href="#通过反射加载类，获取资源" class="headerlink" title="通过反射加载类，获取资源"></a>通过反射加载类，获取资源</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> drawableClazz = dexClassLoader.loadClass(<span class="string">&quot;cf.android666.pluginapp.R\$drawable&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> onePng = drawableClazz.getDeclaredField(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> onId = onePng.getInt(R.id::<span class="keyword">class</span>.java)<span class="comment">//反射获取资源id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resources = getUninstallApkResource()<span class="comment">//resource也是通过反射获取到</span></span><br><span class="line"><span class="keyword">var</span> drawable = resources.getDrawable(onId)</span><br></pre></td></tr></table></figure>

<p><code>AssetManager.addAssetPath()</code>方法是用来将apk等中的资源添加到<code>AssetManager</code>中，再通过其获取到<code>Resources对象</code>，这样就获取到未安装apk中的资源了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUninstallApkResource</span><span class="params">()</span></span>: Resources &#123;</span><br><span class="line">    <span class="keyword">var</span> assetManager = AssetManager::<span class="keyword">class</span>.java.newInstance()</span><br><span class="line">    <span class="keyword">var</span> addAssetPath = assetManager.javaClass.getMethod(<span class="string">&quot;addAssetPath&quot;</span>,String::<span class="keyword">class</span>.java)</span><br><span class="line">    addAssetPath.invoke(assetManager, apkPath)<span class="comment">//设置了apkPath</span></span><br><span class="line">    <span class="keyword">return</span> Resources(assetManager, resources.displayMetrics, resources.configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a href="https://www.cnblogs.com/lee0oo0/p/3665066.html">Android之Android apk动态加载机制的研究（二）：资源加载和activity生命周期管理 - lee0oo0 - 博客园  </a></p>
<p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51316688">Android逆向之旅—Android中的sharedUserId属性详解 - CSDN博客</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_Hash表</title>
    <url>/blog/posts/1f6681a0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hash表是一种可以快速插入和查找的数据结构，将数据保存在通过hash函数计算得到的下标中。</p>
<p>插入和删除 所需时间为O(1)。在确定容量、无需遍历时效果最好。</p>
<p>当其大小接近容量时，效率会变得很差。</p>
<h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><p>Hash表有两种存储方式</p>
<ol>
<li><p>开放地址法</p>
<p>开放地址法，直接将数据存储在数组中。</p>
<p>当hash算出的地址已经被占用时，则走过一定的步长找到另外一个空位（在填充质数很大时就会很耗时）并保存数据。</p>
</li>
<li><p>链地址法</p>
<p>链地址法，创建保存数据的数组，该数组中不直接保存数据，而是保存一个用来存储这些数据的链表，将数据项直接存储的链表中。</p>
<p>当hash算法计算出的地址时，遍历数组中对应的链表找到空位并保存。</p>
</li>
</ol>
<p>其中，开放地址法又分为3种实现：</p>
<ul>
<li><p>线性探测</p>
<p>每次前进的步长为1</p>
<p>即查找的位置依次是<code>x + 1,2,3,4,5,……</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储达到容量2/3以上时候读写性能会很差</span><br></pre></td></tr></table></figure>
</li>
<li><p>二次探测</p>
<p>每次前进的步长为当前查找次数的平方</p>
<p>即查找的位置依次是<code>x + 1,4,9,……</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前几次找不到之后就会很恐慌，步长越来越大到后面无法继续下去</span><br></pre></td></tr></table></figure>
</li>
<li><p>再哈希法</p>
<p>每次前进的步长是根据另外一个hash算法计算出来的值</p>
<p>这个算法要求如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 与第一次hash输出不同  </span><br><span class="line"><span class="number">2.</span> 不能输出<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>已经有一个公认的比较好的二次hash算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stepSize = constant - (key % constant)</span><br><span class="line">如：stepSize = <span class="number">5</span> - (key % <span class="number">5</span>)</span><br><span class="line">* constant 是小于数组容量的质数</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p><strong>再哈希法 VS 二次探测法</strong></p>
<p>在小型哈希表中，再哈希法比二次探测好；</p>
<p>但如果容量充足，并且容量大小不再变化时，二次探测效果好，在装填因子小于0.5时几乎没有性能损失</p>
<p><strong>开放地址法 VS 链地址法</strong></p>
<p>hash表容器大小未知时，用链地址法比较好</p>
<p>当装填因子变得很大时，开放地址法性能下降很快，但链地址法只是线性下降。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/Hash.kt">👉点这里</a>查看源码</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_二叉树</title>
    <url>/blog/posts/101c73f/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍了二叉树，及其应用。</p>
<p>树，既能像链表那样快速插入和删除，又可以像数组那样快速查找。</p>
<p><img src="https://jixiaoyong.github.io/images/20190103200423.png" alt="树"></p>
<p>每棵树有且只有一个<strong>根</strong>，从根到任何一个节点<strong>有且只有一条路径</strong>；每个节点都可以有0个或者多个<strong>子节点</strong>，没有子节点的节点叫做<strong>叶子节点</strong>。</p>
<p><strong>层</strong>是指从根节点到该节点的“代”树，根节点的在<strong>0层</strong>。</p>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>一个节点只能有0~2个子节点的树叫做<strong>二叉树</strong>；</p>
<p>如果二叉树的左子节点的关键字小于该节点，右子节点的关键字大于该节点，则该二叉树称为<strong>二叉搜索树</strong>。</p>
<p>如下，是一个二叉树的节点：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span></span>(<span class="keyword">val</span> iId: <span class="built_in">Int</span>, <span class="keyword">val</span> dData: <span class="built_in">Double</span>, <span class="keyword">var</span> left: BinaryNode? = <span class="literal">null</span>, <span class="keyword">var</span> right: BinaryNode? = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;<span class="variable">$iId</span>,<span class="variable">$dData</span>&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历树指安装一定的顺序访问数的每个节点，按照访问节点的顺序不同，可以分为三种：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>以中序遍历为例，其访问节点的顺序如下：</p>
<ol>
<li>调用自身遍历该节点的左子树；</li>
<li>访问这个节点；</li>
<li>调用自身遍历该节点的右子树。</li>
</ol>
<p>实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历法</span></span><br><span class="line"><span class="comment"> * 使所有节点的关键值按照升序被访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inTraversing</span><span class="params">(node: <span class="type">BinaryNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    inTraversing(node.left)</span><br><span class="line">    print(<span class="string">&quot;<span class="variable">$node</span>,&quot;</span>)</span><br><span class="line">    inTraversing(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h2><p>二叉搜索树的最大值是右子树中最右端没有子节点的右子节点；</p>
<p>二叉搜索树的最小值是左子树中最左端没有子节点的左子节点。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>二叉搜索树因为节点要满足<code>左子节点 &lt; 节点 &lt; 右子节点</code>这个条件，所以删除需要分以下几种情况：</p>
<p>按照要删除的节点子节点数目的不同，分为3种情况</p>
<ul>
<li><p>要删除的节点是叶节点 将其父节点的指向设为null即可</p>
</li>
<li><p>要删除的节点有且只有一个节点 将其父节点指向其子节点</p>
</li>
<li><p>要删除的节点有两个子节点 这时候可以找该子节点的右子树中最小的（或者左子树中最大的）节点并替换掉要删除的节点，</p>
<p>与此同时如果这个节点有右子节点（或对应的左子节点）则按照2&#x2F;3的规则处理，这样就能保证这个树的结构不会出错</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(iId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//查找iId对应的节点</span></span><br><span class="line">        <span class="keyword">var</span> current = root</span><br><span class="line">        <span class="keyword">var</span> parent = root</span><br><span class="line">        <span class="keyword">while</span> (current?.iId != iId) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            parent = current</span><br><span class="line">            current = <span class="keyword">if</span> (iId &gt; current.iId) &#123;</span><br><span class="line">                current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 按照要删除的节点子节点数目的不同，分为3种情况</span></span><br><span class="line"><span class="comment">         * 1/3 要删除的节点是叶节点 将其父节点的指向设为null即可</span></span><br><span class="line"><span class="comment">         * 2/3 要删除的节点有且只有一个节点 将其父节点指向其子节点</span></span><br><span class="line"><span class="comment">         * 3/3 要删除的节点有两个子节点 这时候可以找该子节点的右子树中最小的（或者左子树中最大的）节点并替换掉要删除的节点，</span></span><br><span class="line"><span class="comment">         *     与此同时如果这个节点有右子节点（或对应的左子节点）则按照2/3的规则处理，这样就能保证这个树的结构不会出错</span></span><br><span class="line"><span class="comment">         *     下面采用的是找该节点的右子树最小值，即右子节点或者右子节点的最后一个左子节点</span></span><br><span class="line"><span class="comment">         *     找到后用该子节点的值替换掉要删除的节点值，如果该子节点还有右子节点，将该子节点的父节点指向其右子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span> &amp;&amp; current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//双子节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前点右子节点的左子节点为null</span></span><br><span class="line">            <span class="keyword">if</span> (current.right!!.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                    parent.right = current.right</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.left = current.right</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//TODO 是否需要将右节点的左子节点指向当前点的左子节点</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> cChildNode = current.right</span><br><span class="line">            <span class="keyword">var</span> cParentNode = current!!</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cChildNode?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                cParentNode = cChildNode</span><br><span class="line">                cChildNode = cChildNode.left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后继节点</span></span><br><span class="line">            cParentNode.left = cChildNode!!.right</span><br><span class="line">            cChildNode!!.right = current.right</span><br><span class="line">            cChildNode!!.left = current.left</span><br><span class="line">            <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                parent.right = cChildNode</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = cChildNode</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                parent.right = <span class="literal">null</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = current.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                parent.right = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = current.left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>哈夫曼编码用来对一段文本进行压缩，解压。</p>
<blockquote>
<p>压缩：用字符的编码替代字符</p>
<p>解压：用字符代替对应的编码</p>
</blockquote>
<p>实现思路如下：</p>
<ul>
<li><pre><code>         将字符按照出现的频次生成优先级队列；
</code></pre>
</li>
<li><pre><code>         依次**取出**两个最小的字符，为他们生成一个父节点（父节点频次为两个子节点之和）；
</code></pre>
</li>
<li><pre><code>         并将插入优先级队列中，依次循环直到优先级队列中只有一个节点——哈夫曼树的根节点；
</code></pre>
</li>
<li><pre><code>         从哈夫曼树的根开始，以向左为0，向右为1对其叶子节点上的字符赋予编码。
</code></pre>
</li>
</ul>
<p>其过程如下图所示：</p>
<p><img src="https://jixiaoyong.github.io/images/20190103203447.png" alt="哈夫曼编码示意图"></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/BinaryTree.kt">👉点这里</a> 查看<code>二叉树</code>源码</p>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/HuffmanCodeUtils.kt">👉点这里</a> 查看<code>哈夫曼编码</code>源码</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_图</title>
    <url>/blog/posts/a71f2ecc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>图</strong>，是由可以有多个边的顶点组成的结构。</p>
<p>两个顶点之间有边连接，则称这两个顶点是<strong>邻接</strong>的。</p>
<p>几个相互邻接的顶点组成的线叫做<strong>路径</strong>,至少有一条路径可以到达所有顶点的图叫做<strong>连通图</strong>。</p>
<p>如果图的顶点只能从A→B，不能从B→A，就称图是<strong>有向图</strong>。</p>
<p>如果边被赋予一定的权值（数字），就称图为<strong>带权图</strong></p>
<p><img width='30%' height='30%' src='https://jixiaoyong.github.io/images/20181227232301.png'></img></p>
<h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><p>图一般有两种存储方式：</p>
<ul>
<li><p>邻接矩阵 用N*N的数组保存图中所有的顶点,<code>Arr[m][n]</code>即表示m、n顶点是否邻接（Y:1,N:0）。</p>
<p>比较占地方。</p>
<p><img src="https://jixiaoyong.github.io/images/20181227233341.png" alt="邻接矩阵"></p>
</li>
<li><p>邻接表 用一个N大小的数组保存，数组元素是保存着顶点和他所有的邻接点的链表。</p>
<p><img src="https://jixiaoyong.github.io/images/20181227233435.png" alt="邻接表"></p>
</li>
</ul>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>图的操作有插入（顶点），搜索等等。</p>
<p>以下操作以邻接表方式为例。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入分为插入顶点和插入边。</p>
<p>插入边的时候需要注意，要同时更新start和end两个顶点对应的链表。</p>
<h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>原理同插入边。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>搜索要求从某个特定顶点开始，沿着边移动到其他顶点，移动完毕后要保证访问了每个顶点。</p>
<p>搜索又分为DFS（深度优先搜索）、BFS（广度优先搜索）。</p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS的思想是，依次沿着顶点某一个邻接点，纵深访问，将该邻接点当做新的顶点压入栈中，继续纵深访问，直到有顶点没有可以访问的邻接顶点，将其打印出来（从栈中推出）；然后再返回上一层的邻接顶点中还可以访问的顶点（查找当前栈顶元素未访问的邻接点），直到没有可以访问的顶点。</p>
<p>用栈实现，会先往深处遍历完一条路径，再遍历下一条。每个顶点只访问一次</p>
<p>规则：</p>
<ul>
<li><pre><code> 1/3 访问一个邻接的未访问顶点，访问并标记，将其压入栈中；
</code></pre>
</li>
<li><pre><code> 2/3 当规则1不能满足时，如果栈不为空，从栈中弹出一个顶点；
</code></pre>
</li>
<li><pre><code> 3/3 1,2都无法满足时，搜索结束。
</code></pre>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stacks = DfsStacks(hashMap.size)</span><br><span class="line">    <span class="keyword">var</span> keyArr = hashMap.keys.toIntArray()</span><br><span class="line">    stacks.push(keyArr[<span class="number">0</span>])</span><br><span class="line">    hashMap[keyArr[<span class="number">0</span>]]?.isVisited = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> index = hashMap[keyArr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> (stacks.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> availableKey = getAvailableNode(index!!.<span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (availableKey != -<span class="number">1</span>) &#123;</span><br><span class="line">            index = hashMap[availableKey]<span class="comment">//深度优先搜索，会先顺着一个邻接点一直走到头</span></span><br><span class="line">            index!!.isVisited = <span class="literal">true</span></span><br><span class="line">            stacks.push(availableKey)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pop = stacks.pop()</span><br><span class="line">            print(<span class="string">&quot;<span class="variable">$pop</span> &quot;</span>)</span><br><span class="line">            index = hashMap[stacks.peek()]<span class="comment">//如果一个邻接点再没有未访问的邻接点，那么去访问下一个未访问的邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS的思想是，向将当前顶点的所有可以访问的邻接点访问完毕；之后将该顶点打印（推出），再去访问其邻接点的所有可以访问邻接点（从队列头取出一个顶点，查找其未访问的邻接点）。</p>
<p>用队列实现，会先遍历完本层所有的顶点，然后再移向下一层</p>
<p>规则：</p>
<ul>
<li><pre><code> 1/3 先访问当前顶点的所有邻接顶点，标记，并插入到队列；
</code></pre>
</li>
<li><pre><code> 2/3 如果没有可以访问的邻接点，且队列不为空，从队列头取出一个顶点[此处又用到了一次该点]，使其成为当前顶点，重复1；
</code></pre>
</li>
<li><pre><code> 3/3 如果2不能满足，搜索结束。
</code></pre>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> queue = BfsQueue()</span><br><span class="line">    <span class="keyword">var</span> keyArr = hashMap.keys.toIntArray()</span><br><span class="line">    queue.push(keyArr[<span class="number">0</span>])</span><br><span class="line">    hashMap[keyArr[<span class="number">0</span>]]!!.isVisited = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> index = hashMap[keyArr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> (queue.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> availableKey = getAvailableNode(index!!.<span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (availableKey != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> current = hashMap[availableKey]!!<span class="comment">//广度优先搜索，优先将一个节点的所有邻接点依次访问</span></span><br><span class="line">            current.isVisited = <span class="literal">true</span></span><br><span class="line">            queue.push(current.<span class="keyword">data</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pop = queue.pop()</span><br><span class="line">            print(<span class="string">&quot;<span class="variable">$pop</span> &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (queue.peek() == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            index = hashMap[queue.peek()]<span class="comment">//如果该点没有未访问的邻接点，就选择去访问该点邻接点的邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小生成树MST"><a href="#最小生成树MST" class="headerlink" title="最小生成树MST"></a>最小生成树MST</h1><blockquote>
<p>生成树（Template:Lang-en-short）是具有图G的全部顶点，但边数最少的连通子图.</p>
<p>——维基百科</p>
</blockquote>
<p>带权图的生成树中，总权重最小的称为最小生成树。</p>
<p>最小生成树边比顶点数小1。</p>
<ul>
<li><p>当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。</p>
</li>
<li><p>如果图的每一条边的权值都互不相同，那么最小生成树将只有一个。</p>
</li>
</ul>
<p>无向不带权图中，只需要找出最小数量的边即可。用DFS比较好实现，因为他对每个顶点只访问一次。</p>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是指<strong>有向图</strong>的顶点排序，满足以下条件<a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">*</a>：</p>
<ol>
<li>每个顶点出现且只出现一次；</li>
<li>若A在序列中排在B的前面，则在图中不存在从B到A的<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84_(%E5%9B%BE%E8%AE%BA)">路径</a>。</li>
</ol>
<p>实现思路是：</p>
<ul>
<li><p>依次推出有向图中没有后继点的顶点作为排序的最后项，这是因为按照拓扑排序<code>条件2</code>没有后继点的顶点必然排在后面；</p>
</li>
<li><p>当去掉没有后继点的顶点后又会产生新的没有后继点的顶点，这样依次循环，当图中没有顶点的时候，就可以在有向无环图中完成拓扑排序。</p>
</li>
</ul>
<p>对于有环存在（即存在类似A→B，B→C，C→A的情况）的有向图，会出现找不到<code>没有后继点的顶点</code>，但同时<code>图中顶点数不为0</code>的情况，遇到这种情况退出循环，并说明有环存在即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拓扑排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">topologicalSort</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashMap.size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> displayList = ArrayList&lt;T?&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hashMap.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> successorKey = getSuccessorNode()</span><br><span class="line">        <span class="keyword">if</span> (successorKey == <span class="literal">null</span>) &#123;<span class="comment">//图中还有顶点，但却找不到“没有后继点的顶点”，说明有环</span></span><br><span class="line">            println(<span class="string">&quot;图中有环&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.remove(successorKey)<span class="comment">//如果找到满足条件的顶点，从图中删除并保存的排序结果中</span></span><br><span class="line">            displayList.add(successorKey)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;\n <span class="subst">$&#123;displayList.reversed()&#125;</span> \n&quot;</span>)<span class="comment">//以正确的顺序输出排序结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历图，查找没有后继点的顶点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> -1表示没有这样的点 否则返回该点key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSuccessorNode</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">val</span> result: T? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> ketSet = hashMap.keys</span><br><span class="line"></span><br><span class="line">    ketSet.map &#123;<span class="comment">//遍历图中每个顶点</span></span><br><span class="line">        <span class="comment">//如果顶点没有后继点(没有邻接点，或者邻接点已经被删除)就是满足条件</span></span><br><span class="line">        <span class="keyword">var</span> node: GraphicNode&lt;T&gt;? = hashMap[it]?.next ?: <span class="keyword">return</span> it</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> realNode = hashMap[node.<span class="keyword">data</span>]</span><br><span class="line">            <span class="keyword">if</span> (realNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@map</span><span class="comment">//有后继点，不满足条件，查找下一个顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next<span class="comment">//还有其他邻接点，依次遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result<span class="comment">//没有找到“没有后继点的顶点”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/GraphClazz.kt">👉点这里</a> 查看<code>DFS/BFS/MST</code>源码</p>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/Digraph.kt">👉点这里</a> 查看<code>拓扑排序</code>源码</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F">拓扑排序——维基百科</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_堆</title>
    <url>/blog/posts/b3af796a/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆是一种特殊的二叉树，用他实现的优先级队列插入和删除时间复杂度都是$O(LogN)$ 。</p>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ol>
<li>堆是完全二叉树<a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">*</a></li>
<li>常用数组实现</li>
<li>每个堆的节点都满足堆的条件，即堆的每个节点关键字都大于（或等于）子节点的关键字</li>
</ol>
<p><code>特征3</code>保证了根节点是堆中最大的值，以及顺着某一个节点一直到遇到叶节点的路径上的节点关键字是依次递减的，但是没法保证这个值是这个堆中的最小值，这是因为堆中每个节点的左右子节点的位置和大小无关，两条这样的路径之前的值的大小没有一定的关系。</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>堆可以进行插入、移除，遍历等操作，时间复杂度都是$O(LogN)$。初次之外，利用堆根节点关键值最大这个属性，还可以进行堆排序,时间复杂度为$O(N*LogN)$。</p>
<p>对于在数组中保存的堆，设元素下标为<code>x</code>，则各个相关元素下标如下：</p>
<ul>
<li>父节点<code> (x-1)/2</code></li>
<li>左子节点 <code>2*x+1</code></li>
<li>右子节点 <code>2*x+2</code></li>
</ul>
<p>在插入，移除的时候为了保证满足堆的条件，需要对堆进行向上或向下的遍历，将修改的值移动到对应的位置，在这过程中涉及到复制和交换。如果每次比较都需要交换数据的话会复制很多次，而如果将最终要移动值保存在临时变量中，用一个值专门记录要移动到的下标，在每次符合条件时只复制参与对比的值，在最后再将要临时保存的值复制到目的下标，就会减少复制的次数。</p>
<p>如下图就将复制次数从9次减少到了5次。</p>
<p><img src="https://jixiaoyong.github.io/images/20181225213813.png"></p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入操作思路是，将元素插入到数组最后一位，然后依次向元素父节点遍历，将不满足的元素下沉，直到找到满足<code>堆特征3</code>（父节点关键字大于该点，并且子节点关键字小于该点）的下标，或者指向了根目录，将该元素插入该处。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下向上遍历</span></span><br><span class="line"><span class="comment">    * 如果父节点比插入值小，就将父节点移动到插入值的位置，将toIndex指向空出的地方</span></span><br><span class="line"><span class="comment">    * 依次查找，直到查找到父节点比插入值大，子节点比插入值小的地方，或者指向了根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkUp</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">var</span> bottom = headArray[index]<span class="comment">//headArray是保存堆元素的数组</span></span><br><span class="line">       <span class="keyword">var</span> toIndex = index</span><br><span class="line">       <span class="keyword">var</span> father = (toIndex - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">       <span class="keyword">while</span> (toIndex &gt; <span class="number">0</span> &amp;&amp; bottom!!.key &gt; headArray[father]!!.key) &#123;</span><br><span class="line">           headArray[toIndex] = headArray[father]<span class="comment">//将父节点下沉</span></span><br><span class="line">           toIndex = father</span><br><span class="line">           father = (toIndex - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">       &#125;</span><br><span class="line">       headArray[toIndex] = bottom<span class="comment">//将该值插入到对应下标</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>移除指的是将根节点推出堆中。</p>
<p>基本思路是将根节点推出，再将数组最后一个节点（同时也是堆的最后一个节点）移动到根节点空出的位置，再依次向下遍历，直到将该节点放到符合堆条件的位置或者到达叶子节点。</p>
<p>和插入相比，移除时要移动的节点要比较的稍微多些。</p>
<ul>
<li>该节点是叶节点	直接插入✅</li>
<li>有两个子节点	    和两个叶子节点中最大的比较，如果小于则交换，并再和新的子节点比较</li>
<li>只有左节点    如果左节点大于本节点则交换，否则就是该位置</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从上向下遍历</span></span><br><span class="line"><span class="comment"> * 如果遇到比当前值top大的就将其复制到当前位置toIndex，并记录下空出的位置为toIndex</span></span><br><span class="line"><span class="comment"> * 再以toIndex为起点向下比较，直到遇到top比父节点小，比子节点大的位置，或者叶子节点</span></span><br><span class="line"><span class="comment"> * 将top移动到该位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkDown</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> toIndex = index</span><br><span class="line">    <span class="keyword">var</span> top = headArray[size - <span class="number">1</span>]!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (toIndex &lt; size / <span class="number">2</span>) &#123;<span class="comment">//非叶子节点</span></span><br><span class="line">        <span class="keyword">var</span> leftIndex = <span class="number">2</span> * toIndex + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> rightIndex = <span class="number">2</span> * toIndex + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (headArray[rightIndex] == <span class="literal">null</span>) &#123;<span class="comment">//只有左节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                headArray[toIndex] = headArray[leftIndex]</span><br><span class="line">                toIndex = leftIndex</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (headArray[leftIndex] != <span class="literal">null</span> &amp;&amp; headArray[rightIndex] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt;= headArray[rightIndex]!!.key) &#123;<span class="comment">//如果左节点比较大</span></span><br><span class="line">                <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                    headArray[toIndex] = headArray[leftIndex]</span><br><span class="line">                    toIndex = leftIndex</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果右节点比较大</span></span><br><span class="line">                <span class="keyword">if</span> (headArray[rightIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                    headArray[toIndex] = headArray[rightIndex]</span><br><span class="line">                    toIndex = rightIndex</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headArray[toIndex] = top<span class="comment">//将该节点移动到找到的下标处</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>利用堆<code>根节点关键值最大</code>这一特性，可以进行堆排序。</p>
<p>只需要将待排序的数组依次插入堆中，然后再依次移除即可。</p>
<p>这样需要有两倍与待排序数组大小的空间。如果每次插入时候只保存数据，不进行向上遍历，在每次移除数据时进行向下遍历，将当前剩余数据最大值选出来（其余数据仍然无序）从堆中移除根元素时都会在数组末尾空出一个位置，将该值存储在该位置即可，这样等完全插入、移除后就得到一个有序数组【从数组末尾开始依次减小】</p>
<p>堆排序和快速排序时间复杂度都是 <code>O(N*LogN)</code> ，但是由于向上、向下遍历耗时，实际上要比快速排序稍慢一些。但是堆排序堆数据初始分布不敏感一直都是 <code>O(N*LogN)</code> ，快速排序在某些情况下时间复杂度可达到 <code>O(N^2)</code> 。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>满二叉树指除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。</p>
<p>如果一个二叉树的层数为K，且节点总数是 $(2^k) -1$  ，则它就是满二叉树。</p>
<p><img src="https://jixiaoyong.github.io/images/20181225210750.png" alt="满二叉树"></p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树 如果将二叉树每层从左到右遍历，那么完全二叉树只有最后一层的右边会出现没有叶子节点的情况，即在前1~n之间没有“洞”。</p>
<p>如下图就是一个完全二叉树：</p>
<p><img src="https://jixiaoyong.github.io/images/20181225211304.png" alt="完全二叉树"></p>
<p>但下图不是完全二叉树：</p>
<p><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt="不是完全二叉树"></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/HeadClazz.kt">👉点这里</a> 查看源码</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91">满二叉树——百度百科</a></p>
<p><a href="https://blog.csdn.net/u013812939/article/details/46798743">完全二叉树与满二叉树的区别</a></p>
<p>《Java数据结构和算法 （第二版）》 Robert Lafore 陈维宁</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_总结</title>
    <url>/blog/posts/851be5ef/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文汇总了数据结构的优缺点及应用场景。</p>
<p>通用数据结构：数组、链表、树、哈希表</p>
<p>专用数据结构：栈、队列、优先级队列</p>
<p>排序：冒泡排序、选择排序、插入排序，希尔排序、快速排序、归并排序、堆排序</p>
<p>图：邻接矩阵、邻接表</p>
<h1 id="通用数据结构"><a href="#通用数据结构" class="headerlink" title="通用数据结构"></a>通用数据结构</h1><p>这些数据结构使用关键字的值存储、查找数据</p>
<p>其速度如下：</p>
<p><code>哈希表 &gt; 树 &gt; 链表 &gt; 数组</code></p>
<p>数组：数据量小，大小可以预测时使用</p>
<p>链表：数据大小不可预知，或需要频繁插入删除元素时使用</p>
<p>二叉搜索树：如果数组和链表都很慢时，优先考虑二叉树</p>
<p>平衡树：二叉搜索树很快，但是如果遇到数据是逆序的时候，就会很耗性能，而平衡树则不会</p>
<p>哈希表：在数据存储结构中最快，但是需要有额外的空间</p>
<p>下面是以上数据结构的速度：</p>
<p><img src="https://jixiaoyong.github.io/images/20190105140704.png" alt="通用数据结构速度统计"></p>
<h1 id="专用数据结构"><a href="#专用数据结构" class="headerlink" title="专用数据结构"></a>专用数据结构</h1><p>包括栈、队列、优先级队列（堆），都是抽象数据结构(ADT)，由更加基础的<code>通用数据结构</code>组成。</p>
<p>不能查找或者遍历，只能访问指定元素（头部，队列也可以访问尾部）。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出(FILO)，最后插入的数据在栈顶，每次只能访问栈顶元素。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出(FIFO)，最后插入的数据在队尾，最先插入的在队首，每次先弹出队首的元素。</p>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>是一种特殊的队列，不同的是优先级高的在队首，优先级低的在队尾，每次弹出优先级最高的元素（这意味着每次插入或弹出时要进行排序）。</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p><img src="https://jixiaoyong.github.io/images/20190105141727.png" alt="专用数据结构效率比较"></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序包括冒泡排序、选择排序、插入排序，希尔排序、快速排序、归并排序、堆排序。</p>
<p>一般使用排序优先级：</p>
<p><code>插入排序 &gt; 希尔排序 &gt; 快速排序 &gt; 归并排序 &gt; 堆排序</code></p>
<p>归并排序：需要辅助存储空间</p>
<p>堆排序：需要一个堆的数据结构，比快速排序更适于非随机数据</p>
<p>快速排序：处理非随机数据时会慢到$O(N^2)​$</p>
<p>下面是排序算法比较：</p>
<p><img src="https://jixiaoyong.github.io/images/20190105142406.png" alt="排序算法比较"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_数组，链表</title>
    <url>/blog/posts/9a784fe0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍了数组、链表等数据结构。</p>
<p>设定所有排序：小→大。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组（array）是一组具有相同类型元素的集合，用一段连续的内存来保存。使用下标来访问保存的元素，如<code>a[0]</code>。</p>
<p>数组是一种数据存储结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>数组大小固定，对指定下标元素读写快O(1)，但是查找慢O(N)，删除元素慢O(N)。</p>
<h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>在每次插入的时候对元素进行排序，就得到有序数组。</p>
<p>有序数组查找快O(LogN)，但插入慢O(N)，删除元素慢O(N)。</p>
<p><strong>有序数组插入</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertSort</span><span class="params">(key: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= sortArr.size) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        sortArr[size++] = key</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> insertIndex = ++size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (key &lt; sortArr[insertIndex - <span class="number">1</span>]) &#123;</span><br><span class="line">        sortArr[insertIndex] = sortArr[insertIndex - <span class="number">1</span>]</span><br><span class="line">        insertIndex--</span><br><span class="line">        <span class="keyword">if</span> (insertIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortArr[insertIndex] = key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在有序数组要找到某个元素t可以使用二分查找，其思想是：</p>
<ol>
<li>选取一个中间值n将当前数组一分为二。</li>
<li>如果<code>t==n</code>那么查找结束，如果<code>t&lt;n</code>,那么在右半部分数组查找，否则在左半部分数组查找。</li>
<li>重复步骤<code>1</code>,<code>2</code>，直到找到n或者数组已经不可再分（不存在n），结束查找。</li>
</ol>
<p><strong>二分法查找</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dichotomy</span><span class="params">(array: <span class="type">IntArray</span>, key: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> centerIndex = array.size / <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> centerKey = array[centerIndex]</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        key == centerKey -&gt; centerIndex</span><br><span class="line">        key &lt; centerKey -&gt; dichotomy(array.copyOfRange(<span class="number">0</span>, centerIndex), key)</span><br><span class="line">        <span class="keyword">else</span> -&gt; dichotomy(array.copyOfRange(centerIndex - <span class="number">1</span>, array.size), key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表的每个节点除了保存的数据外，还保存着下一个节点的引用<code>next</code>，最后一个元素中该引用为<code>null</code>。</p>
<p>链表的大小不固定，查找，删除，插入指定节点都需要O(N)</p>
<p>链表有以下分类：</p>
<ul>
<li><p>单链表 每个节点只有指向下一个节点的引用，链表只保留第一个链节点的引用<code>first</code></p>
<p><img src="https://jixiaoyong.github.io/images/20190101132535.png" alt="单链表"></p>
</li>
<li><p>双向链表 每个节点保存有父节点和子节点的引用。双向链表也可以是双端链表。</p>
<p><img src="https://jixiaoyong.github.io/images/20190101132614.png" alt="双向链表"></p>
</li>
</ul>
<p><strong>双端链表</strong> 双端链表保存第一个链节点<code>farst</code>和最后一个链节点<code>last</code>的引用。</p>
<p><img src="https://jixiaoyong.github.io/images/20190101132649.png" alt="双端链表"></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/tree/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/link">👉点这里</a> 查看<code>链表</code>源码</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">数组–维基百科</a></p>
<p><a href="https://book.douban.com/subject/1144007/">Java数据结构和算法（第二版）Robert Laforce 计晓云等译</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_栈和队列</title>
    <url>/blog/posts/8d059318/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍栈、队列两种抽象数据类型。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈<code>stack</code>，又称堆栈，是一种抽象数据类型，每次只能访问栈顶元素<code>top</code>，可以进行压入<code>push</code>和推出<code>pop</code>操作。其元素**先进后出(FILO)**。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列<code>queue</code>,是和栈相对的一种抽象数据类型，每次从后端<code>rear</code>插入，从前端<code>front</code>删除。其元素**先进先出(FIFO)**。</p>
<p>用链表实现的队列可以自由扩充，不存在伪溢出问题，但是插入和读取比较耗时；</p>
<p>用数组实现的队列大小固定，可以使用<strong>循环队列</strong>解决伪溢出问题，即当尾端（前端也类似）指针指向超出数组大小时，可以指向数组开始位置，因为此时大小不超过数组的队列前端已经指向0之后的位置了，所以不会冲突。</p>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>和队列定义一致，只是在每次插入的时候都进行排序，以满足排序规则（如<code>尾端→前端</code> <code>小→大</code>）。</p>
<h1 id="中缀表达式与后缀表达式"><a href="#中缀表达式与后缀表达式" class="headerlink" title="中缀表达式与后缀表达式"></a>中缀表达式与后缀表达式</h1><p>中缀表达式，指运算符在操作数中间的，如<code>1 + 2</code>。</p>
<p>后缀表达式，指运算符在操作数后面的，如<code>1 2 +</code>。</p>
<p>中缀表达式 ↔ 后缀表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">中缀表达式：<span class="number">1</span> + <span class="number">2</span> * ( <span class="number">3</span> + <span class="number">5</span> ) - <span class="number">2</span> * <span class="number">3</span> - <span class="number">9</span> / <span class="number">2</span></span><br><span class="line">后缀表达式：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> + * + <span class="number">2</span> <span class="number">3</span> * - <span class="number">9</span> <span class="number">2</span> / - </span><br></pre></td></tr></table></figure>

<p>转换规则：</p>
<p>设一个栈用于保存运算符，从左到右依次遍历中缀表达式，假设读取到的是<code>x</code></p>
<ol>
<li><p>如果是操作数，则直接打印</p>
</li>
<li><p>如果是运算符<code>(</code>，则压入栈中</p>
</li>
<li><p>如果是运算符<code>)</code>，则推出栈中的元素，直到遇到<code>(</code>,推出<code>(</code>，继续读取下一个</p>
</li>
<li><p>否则，读取栈顶元素<code>top</code>，如果是<code>(</code>，将<code>x</code>压入栈中；</p>
<p>如果<code>x</code>优先于<code>top</code>，将<code>x</code>压入栈中；</p>
<p>否则，将<code>top</code>推出，在此和新的<code>top</code>比较，直到遇到<code>top</code>是<code>(</code>或者优先级比<code>x</code>高，或者栈已经空了，将<code>x</code>插入栈中。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中缀表达式转化为后缀表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> infix 中缀表达式 1+2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 后缀表达式 1 2 +</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> static String[] covertInfixToPostfix(String <span class="keyword">infix</span>) &#123;</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    OperatorStack operatorStack = new OperatorStack();</span><br><span class="line">    <span class="keyword">for</span> (char item : <span class="keyword">infix</span>.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// 数字</span></span><br><span class="line">        <span class="keyword">if</span> (item &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; item &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            stringBuilder.append(item + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            operatorStack.insert(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            int size = operatorStack.size();</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    char pop = operatorStack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (pop == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        stringBuilder.append(pop + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                char peek = operatorStack.peek();</span><br><span class="line">                <span class="keyword">if</span> (peek == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    operatorStack.insert(item);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPre(item, peek) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    operatorStack.insert(item);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    int size = operatorStack.size();</span><br><span class="line">                    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            char pop = operatorStack.peek();</span><br><span class="line">                            <span class="keyword">if</span> (pop == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPre(item, peek) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                stringBuilder.append(pop + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                                operatorStack.pop();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    operatorStack.insert(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">                operatorStack.insert(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = operatorStack.size();</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stringBuilder.append(operatorStack.pop() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String result = stringBuilder.toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>👉<a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/InfixAndPostfix/CovertInfixToPostfix.java">点这里</a>查看<code>中缀表达式 → 后缀表达式</code>源码</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈——维基百科</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">队列——维基百科</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_简单排序</title>
    <url>/blog/posts/125c8a12/</url>
    <content><![CDATA[<h1 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h1><p>所有排序顺序为 <code>小 → 大</code>。</p>
<p>时间负责度都是O(N^2^)。</p>
<p>排序速度：<code>插入排序&gt;选择排序&gt;冒泡排序</code></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度：O(N^2^) </p>
<p>最慢的排序，但是简单</p>
<p>规则如下：</p>
<ol>
<li>从左到右，比较a和b，如果<code>a&gt;b</code>，就交换a和b的位置</li>
<li>再将a，b中较大的那个与c按照2的规则比较，直到最后一位</li>
<li>重复1，2直到没有待排序的项目</li>
</ol>
<p>其思想是：每次选出当前未排序的元素中最大的元素并放到队尾（每次比较最大元素都会“冒泡”到队尾），这样当连续遍历n次后，每个元素都会排好序。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     * 1. 每次比较前1~（n-i）个元素（i是排序次数），每次有大的就【移动】，</span></span><br><span class="line"><span class="comment">     * 这样子一轮比赛完毕最大的就在后面了</span></span><br><span class="line"><span class="comment">     * 2. 这样子比较n次就可以完成排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bubbleSort</span><span class="params">(intArray: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">var</span> result = intArray</span><br><span class="line">        <span class="keyword">var</span> size = result.size</span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">0</span> until size - index - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result[x] &gt; result[x + <span class="number">1</span>]) &#123;<span class="comment">//【注意】冒泡排序，每次比较满足条件就会交换</span></span><br><span class="line">                    <span class="keyword">var</span> temp = result[x]</span><br><span class="line">                    result[x] = result[x + <span class="number">1</span>]</span><br><span class="line">                    result[x + <span class="number">1</span>] = temp</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度：O(N^2^) </p>
<p>因为交换次数少，所以比冒泡快</p>
<p>规则如下：</p>
<ol>
<li>假设第一项值最大，设其坐标为<code>max</code>，从左到右依次比较<code>max</code>和其他元素，如果遇到比<code>max</code>大的，将max坐标指向该值</li>
<li>每轮结束后<code>max</code>就表示这轮比较最大的值坐标，将其与当前未排序的最后一项交换</li>
<li>这样重复步骤1，2， <code>n次</code>就可以排序完成</li>
</ol>
<p>其思想是：每次比较当前最大的值，记录下其坐标，等当前比较完成就和<code>未比较的最后一位</code>交换，（这样子避免每次比较都要交换）。同样这样子比较n次就可以完成排序。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 1. 每次比较前1~（n-i）个元素（i是排序次数），如果有大的就记录下位置，一轮比较完毕后交换他和最后一位的位置</span></span><br><span class="line"><span class="comment"> * 2. 这样子比较n次就可以完成排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">selectSort</span><span class="params">(intArray: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> result = intArray</span><br><span class="line">    <span class="keyword">var</span> size = result.size</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span><span class="comment">//假设arr[0]最大</span></span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">0</span> until size - index - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result[max] &lt; result[x + <span class="number">1</span>]) &#123;<span class="comment">//将max与每一项比较，注意这里参与比较的是max</span></span><br><span class="line">                max = x + <span class="number">1</span><span class="comment">//遇到比max大的则记录下其位置 【注意】这里并没有交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在每轮比较完毕后max就是这轮比较出来的最大值位置，将其放到对应位置</span></span><br><span class="line">        <span class="keyword">var</span> temp = result[size - index - <span class="number">1</span>]</span><br><span class="line">        result[size - index - <span class="number">1</span>] = result[max]</span><br><span class="line">        result[max] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度：O(N^2^) </p>
<p>比冒泡快一倍，比选择排序快一些</p>
<p>思想：假设一个标记元素的左边全部是有序数组，右边全是无序数组，那么只需要将右边的元素依次拿出来插入到左边的有序数组中即可。刚开始这个标记元素可以为0或者1（假设一个元素就是有序的）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 假设右端数组是有序的，依次从左端数组取出元素比较，插入到右边的有序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertSort</span><span class="params">(intArray: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = intArray</span><br><span class="line">    <span class="keyword">var</span> size = result.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (insertIndex <span class="keyword">in</span> <span class="number">1</span> until size ) &#123;<span class="comment">//假设arr[0]已经是有序的，所以从1开始</span></span><br><span class="line">        <span class="keyword">var</span> insertPoint = result[insertIndex]</span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> insertIndex - <span class="number">1</span> downTo  <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (insertPoint &lt; result[index]) &#123;</span><br><span class="line">                <span class="comment">//默认要插入的点是有序的，如果有比插入点大的，则将该点和插入点交换</span></span><br><span class="line">                result[index + <span class="number">1</span>] = result[index]</span><br><span class="line">                result[index] = insertPoint</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//因为左边的数组是有序的，只要有比插入点小的元素，则剩下的肯定都小于该元素，不用再比较了</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/sort/BasicSort.kt">👉点这里</a>查看源码</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_红黑树</title>
    <url>/blog/posts/11c01876/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为$O(log_2N)$。</p>
<p>红黑树必须满足以下条件：</p>
<ol>
<li><p>必须有颜色（黑&#x2F;红）</p>
</li>
<li><p>根节点颜色为黑</p>
</li>
<li><p>若节点是红色，则子节点必须是黑色（反之则不然）</p>
</li>
<li><p>到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色）</p>
</li>
</ol>
<p>如果不满足可以通过以下方式修正：</p>
<ul>
<li>改变节点颜色</li>
<li>旋转（左、右）</li>
</ul>
<h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>以某个支点旋转（右旋为例，旋转时注意更新各个节点的父节点）：</p>
<p>本质是将该<code>节点a</code>向下进一位插入到其<code>右节点b</code>原先的位置，将其<code>左节点c</code>向上进一位插入到该<code>节点a</code>原先的位置，并将<code>左节点c的右节点</code>赋值给该<code>节点a</code>。</p>
<p>步骤：</p>
<ol>
<li><p>将该<code>节点a</code>放到<code>右节点b</code>的位置，将该&#96;&#96;左节点c<code>放到</code>节点a&#96;原先的位置，依次类推</p>
</li>
<li><p>特殊的，将该<code>点a的内侧孙子</code>（<code>a的左子节点c</code>的<code>右子节点d</code>）断开与其<code>父节点c</code>的连接，转而连接到<code>a</code>上，成为<code>a的左子节点</code></p>
</li>
</ol>
<p>如图，依次插入<code>6,34,23</code>，<strong>以<code>34</code>为支点右旋</strong>：</p>
<img src="https://jixiaoyong.github.io/images/20181223175956.png" width='50%' height='50%'>

<p>对获得的结果，由于<font color="#ff0000">23</font>，<font color="#ff0000">34</font>都是红色违反了<code>规则3</code>，将<code>34的父节点23</code>设置黑，<code>祖父节点6</code>设为红，<strong>以<code>祖父节6</code>点为支点左旋</strong>：</p>
<p><img src="https://jixiaoyong.github.io/images/20181223180637.png" alt="最终结果"></p>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>每次插入红色节点，能够避免规则4。</p>
<p>一般先以二叉搜索树的规则将数据插入表中，然后再对照规则检查是否需要调整红黑树。</p>
<p>红黑树插入情况分类如下：</p>
<ol>
<li>插入位置为根节点，将节点颜色更改为黑色</li>
<li>插入位置的父节点为根节点或父节点颜色为黑色，直接插入</li>
<li>父节点为红色。</li>
</ol>
<p>只有父节点为红色这种情况需要进行修正，这时又可以细分为以下三种情况：</p>
<p><img src="https://jixiaoyong.github.io/images/20181223182532.jpg" alt="表格来自 http://www.cnblogs.com/skywang12345/p/3245399.html#a1"></p>
<p>【注意】对于<code>Case 3</code>当祖父节点没有<strong>左节点</strong>无法右旋时的特殊处理：</p>
<p>需要对先对当前节点的父节点进行右旋，再以父节点作为<strong>新插入的点N</strong>，将N的父节点设置为黑色，祖父节点设置为红色，以祖父节点为支点左旋。</p>
<p>如依次插入如下值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32,3,53,13,983,[137],237,83,483,43,183</span><br></pre></td></tr></table></figure>

<p>当插入<code>137</code>后红黑树如图：</p>
<p><img src="https://jixiaoyong.github.io/images/20181223210305.png" alt="插入137后的树"></p>
<p>本来按照<code>Case 3 父红 叔黑 是左节点 </code> 应该要以祖节点右旋，但是组节点53没有左子节点，无法右旋，所以先对父节点983进行右旋：</p>
<p><img src="https://jixiaoyong.github.io/images/20181223210800.png"></p>
<p>再以<code>983</code>为新节点，<code>父红 叔黑 是右节点</code>，将<code>父节点137</code>设置为黑色，<code>祖节点53</code>设置为红色，以<code>组节点53</code>为支点左旋：</p>
<p><img src="https://jixiaoyong.github.io/images/20181223211217.png"></p>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>删除比较复杂，可以有两种操作：</p>
<ol>
<li>在节点中保存一个标志位，标记该节点是否被删除，并不针真的删除该点。</li>
<li>在执行删除操作时真正删除该点。</li>
</ol>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/RedBlackTree.kt">👉点这里</a>查看源码</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://sandbox.runjs.cn/show/2nngvn8w">在线操作红黑树</a></p>
<p><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a1">红黑树(一)之 原理和算法详细介绍</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_递归和汉诺塔问题</title>
    <url>/blog/posts/466fbe25/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍了递归，归并排序，还有递归在汉诺塔问题上的应用。</p>
<p>排序顺序为 <code>小 → 大</code></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归是一种在函数内部调用自己的函数。在满足一定条件后可以退出递归。</p>
<p>比如三角数组就是一个简单的递归：</p>
<blockquote>
<p>有一组数据，满足这样的条件<code>第n项</code> &#x3D; <code>第n-1项</code> + <code>n</code>，就称为三角数组，如：</p>
<p><code>1,2,6,10,15,21...</code></p>
</blockquote>
<p>这里面，**<code>第n项</code> &#x3D; <code>第n-1项</code> + <code>n</code>**,就是一个递归，每一项的计算结构都依赖于前一项的计算，直到第1项的计算结果为确定的1，不再继续递归。</p>
<p>实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三角数</span></span><br><span class="line"><span class="comment"> * 第n个数 == 第n-1个数 + n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">triangleNum</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num + triangleNum(num - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h1><p>汉诺塔是一种游戏，有三个柱子，其中一棵柱子上面有若干个半径依次递减的空心圆盘，每次只能移动最顶端的圆盘，并且下面的圆盘要比上面的圆盘直径大。游戏的目的就是在满足这些条件的前提下，将所有圆盘依次转移到另外一个圆盘上面。</p>
<p><img src="https://jixiaoyong.github.io/images/20190102201005.png" alt="汉诺塔问题分析"></p>
<p>如图，实现的思路就是递归：</p>
<ol>
<li><p>将除最底部的圆盘<code>bottom</code>之外的所有圆盘当做一个整体<code>other</code>，那么问题就变成了如何将<code>bottom</code>和<code>other</code>这“两”个圆盘通过<code>柱子B</code>，移动到<code>柱子C</code>，这个问题显然很好解决，只需要将<code>other</code>移动到<code>柱子B</code>，再将<code>bottom</code>移动到<code>柱子C</code>即可。</p>
</li>
<li><p>那么剩下的问题就成了如何将<code>other</code>从<code>柱子A</code>移动到<code>柱子B</code>，很显然可以参照<code>步骤1</code>。</p>
</li>
<li><p>这样子这个问题就成了如何将一个<code>bottom</code>从一个柱子，移动到另外一个柱子的问题，而每个这样的问题的解决都依赖于<code>other</code>的解决，而这就是递归。</p>
</li>
</ol>
<p>具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汉诺塔问题</span></span><br><span class="line"><span class="comment"> * 将汉诺塔问题简化为3步：</span></span><br><span class="line"><span class="comment"> * 1/3 将最上层n-1项移动到过渡层</span></span><br><span class="line"><span class="comment"> * 2/3 将最底层n移动到目标层</span></span><br><span class="line"><span class="comment"> * 3/3 将n-1项移动到目标层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要移动的层数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> from 所在层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inter 过渡层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 目标层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hanioStepNum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hanioTower</span><span class="params">(num: <span class="type">Int</span>, from: <span class="type">String</span>, inter: <span class="type">String</span>, to: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;move 1 to <span class="variable">$to</span>&quot;</span>)</span><br><span class="line">        hanioStepNum++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hanioTower(num - <span class="number">1</span>, from, to, inter)<span class="comment">//把`other`移动到中间柱子</span></span><br><span class="line">        println(<span class="string">&quot;move <span class="variable">$num</span> to <span class="variable">$to</span>&quot;</span>)<span class="comment">//把`bottom`移动到目标柱子</span></span><br><span class="line">        hanioStepNum++</span><br><span class="line">        hanioTower(num - <span class="number">1</span>, inter, from, to)<span class="comment">//把`other`移动到目标柱子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序<code>merge</code>，将一个数组，分成两个子数组分别排序，之后再将拍好序的数组合并，这样就得到了一个有序数组。时间复杂度是$O(N*Log(N))$。</p>
<p>其思路是，将数组无限的分成两份分别进行排序，然后再将排好序的两个数组归并在一起得到有序数组。每个子数组的有序都依赖于其子数组的有序，直到每个子数组只有一个元素，这样的数组本身就是有序的。</p>
<p>原理如下（假设序列共有n个元素）：</p>
<ol>
<li>将序列每相邻两个数字进行<strong>归并操作</strong>，形成两个<code>n/2</code>序列，排序后每个序列包含1&#x2F;2元素</li>
<li>若此时序列数不是1个，则将上述序列再次归并，分别形成两个<code>n/4</code>序列，每个序列包含1&#x2F;4个元素</li>
<li>重复步骤2，直到所有元素排序完毕，即序列数为1</li>
</ol>
<p><img src="https://zh.wikipedia.org/wiki/File:Merge-sort-example-300px.gif" alt="归并排序动态演示"></p>
<p><strong>合并两个有序的数组(<code>a</code>,<code>b</code>)思想</strong>：</p>
<p>将<code>b</code>中比<code>a</code>中小的元素都复制到<code>a</code>中对应位置，然后将剩下的元素全部依次复制到<code>a</code>的末尾。</p>
<p>归并排序具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * 归并排序占空间（多占一个排序数组的大小），排序快（N*LogN）</span></span><br><span class="line"><span class="comment"> * 思想是:</span></span><br><span class="line"><span class="comment"> * 1/2 将数组无限分成两份，直到两份数组都是有序的（每个数组只有一个元素）</span></span><br><span class="line"><span class="comment"> * 2/2 再对其进行归并</span></span><br><span class="line"><span class="comment"> * 小 -&gt; 大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intArr 待排序的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(intArr: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> size = intArr.size</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> intArr</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> half = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (size % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            half = size / <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            half = (size + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr1 = intArr.copyOfRange(<span class="number">0</span>, half)</span><br><span class="line">        <span class="keyword">val</span> arr2 = intArr.copyOfRange(half, intArr.size)</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(arr1), mergeSort(arr2))<span class="comment">//将合并好的两个有序子数组合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并</span></span><br><span class="line"><span class="comment"> * 合并两个有序的数组为新的有序数组</span></span><br><span class="line"><span class="comment"> * 思想：</span></span><br><span class="line"><span class="comment"> * 1/2 相互比较两个数组每项大小，并将小的复制到新数组</span></span><br><span class="line"><span class="comment"> * 2/2 将剩余的数组全部复制到新数组</span></span><br><span class="line"><span class="comment"> * 小 -&gt; 大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intArrA 有序数组1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intArrB 有序数组2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intArrA: <span class="type">IntArray</span>, intArrB: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> resultArr = IntArray(intArrA.size + intArrB.size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indexA = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> indexB = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> indexC = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (indexA &lt; intArrA.size &amp;&amp; indexB &lt; intArrB.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intArrA[indexA] &lt; intArrB[indexB]) &#123;</span><br><span class="line">            resultArr[indexC++] = intArrA[indexA++]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultArr[indexC++] = intArrB[indexB++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (indexA &lt; intArrA.size) &#123;</span><br><span class="line">        resultArr[indexC++] = intArrA[indexA++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (indexB &lt; intArrB.size) &#123;</span><br><span class="line">        resultArr[indexC++] = intArrB[indexB++]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>👉<a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/link/Triangle.kt">点这里</a> 查看<code>汉诺塔</code>和<code>递归排序</code>源码</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序——维基百科</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_高级排序</title>
    <url>/blog/posts/2041f2cb/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍两种高级排序：希尔排序和快速排序。</p>
<p>希尔排序的时间复杂度是$O(N*(LogN)^2)$，简单易实现，在所有排序中可以优先使用。</p>
<p>快速排序的时间复杂度是$O(N*LogN)$，是所有通用排序中最快的。</p>
<p>排序方向：<code>小 → 大</code>。</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序基于插入排序（将左边无须的元素依次插入到右边有序数组中），不同的是希尔排序的增量逐渐减小到1，而插入排序的增量一直是1。</p>
<blockquote>
<p>增量 排序的时候进行比较的两个元素之间的间隔：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>对于数组<code>arr</code>中的元素来说，<code>1</code>和 <code>2</code>之间的增量是1，而 <code>1</code>和 <code>3</code>之间的增量是2，以此类推。</p>
</blockquote>
<p>由于插入排序在排序进行到后期，右边有序数组的大小变大，导致插入和移动的次数越来越多，而且如果数组恰好是反序的，会很耗时。</p>
<p>而希尔排序在刚开始排序时，先取一个适当的增量<code>n</code>，按照这个增量对数组<code>arr</code>进行插入排序，得到一个<em>基本有序</em>的数组，他内部有<code>n</code>个有序的子数组；再将增量<code>n</code>减一，在此进行插入排序；如此反复直到n为1，排序完毕的数据即为有序数组。</p>
<p><img src="https://jixiaoyong.github.io/images/20190103191850.png" alt="希尔排序——4增量排序示意图"></p>
<h2 id="增量的选择"><a href="#增量的选择" class="headerlink" title="增量的选择"></a>增量的选择</h2><p>可以想象，增量的计算对希尔排序效率有很大影响。</p>
<p>这些增量的集合称为<strong>间隔序列</strong>，一般要求这些增量之间互质，这样就不会对已经排序的数组再次排序。</p>
<p>一个常用的间隔序列计算公式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">h=3h+<span class="number">1</span></span><br><span class="line">计算的h值一般为：<span class="number">1</span>,<span class="number">13</span>,<span class="number">40</span>,<span class="number">21.</span>..</span><br></pre></td></tr></table></figure>

<p>增量<code>h</code>要小于数组大小。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 思路:</span></span><br><span class="line"><span class="comment"> * 1/3 将待排序数组分为h个间隔为h的小数组，</span></span><br><span class="line"><span class="comment"> * 2/3 对这些小数组进行插入排序,将排序结果写入原待排序数组</span></span><br><span class="line"><span class="comment"> * 3/3 按照 h=3*h+1 的算法减小h在此进行希尔排序，直至h为1</span></span><br><span class="line"><span class="comment"> * --将大数组分为较小的数组，拍完序后再对这些&quot;有序&quot;的小数组进行排序</span></span><br><span class="line"><span class="comment"> * 小 - &gt; 大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">shellSort</span><span class="params">(intArray: <span class="type">IntArray</span>, h: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> insertSort(intArray)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//间隔排序</span></span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">0</span> until h) &#123;<span class="comment">//依次遍历x,x+1,x+2 ... x+(h-1);形成h个有序子数组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> list = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">            intArray.forEachIndexed &#123; index, i -&gt;</span><br><span class="line">                <span class="keyword">if</span> ((index + x) % h == <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(i)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> partSortArr = insertSort(list.toIntArray())</span><br><span class="line">            <span class="keyword">var</span> listIndex = <span class="number">0</span></span><br><span class="line">            intArray.forEachIndexed &#123; index, i -&gt;</span><br><span class="line">                <span class="keyword">if</span> ((index + x) % h == <span class="number">0</span>) &#123;</span><br><span class="line">                    intArray[index] = partSortArr[listIndex++]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将增量减小，再次减小排序，直到h==1</span></span><br><span class="line">        <span class="keyword">return</span> shellSort(intArray, (h - <span class="number">1</span>) / <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取希尔排序间隔</span></span><br><span class="line"><span class="comment"> * 对排序速度影响较大，要求互质，计算方式不唯一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getShellSortH</span><span class="params">(range: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (range &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; range) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (h - <span class="number">1</span>) / <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1/2 先假设第一个数是已经排好序的</span></span><br><span class="line"><span class="comment"> * 2/2 将后面的数字依次与其比较，并插入到对应位置</span></span><br><span class="line"><span class="comment"> * small -&gt; big</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertSort</span><span class="params">(intArray: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intArray.size) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intArray[i] &lt; intArray[j]) &#123;</span><br><span class="line">                <span class="keyword">val</span> temp = intArray[i]</span><br><span class="line">                <span class="keyword">for</span> (x <span class="keyword">in</span> i downTo j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x - <span class="number">1</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    intArray[x] = intArray[x - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                intArray[j] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序在大多数情况下都是最快的。</p>
<h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p>划分指在一组数据中，指定一个值<code>C</code>,所有小于<code>C</code>的移动到左边，所有大于<code>C</code>的移动到右边。</p>
<p>选出来的这个值<code>C</code>，叫做<strong>枢纽</strong>。</p>
<h3 id="划分算法"><a href="#划分算法" class="headerlink" title="划分算法"></a>划分算法</h3><ul>
<li>在数据左右两端各有一个指针指向当前元素：<code>left</code>，<code>right</code>；</li>
<li><code>left</code>指针向右移动查找比<code>C</code>大的值，<code>right</code>指针向左移动查找比<code>C</code>小的值，当遇到满足条件的元素则退出；</li>
<li>当两个指针都退出时，将其指向的元素交换位置，然后再分别移动指针，直到两个指针相遇，划分结束。</li>
</ul>
<h2 id="快速排序的思路"><a href="#快速排序的思路" class="headerlink" title="快速排序的思路"></a>快速排序的思路</h2><p>快速排序，选取一个枢纽，将数组<strong>划分</strong>为两个子数组，这样在枢纽<code>C</code>两边的数组满足：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[左边子数组所有元素] &lt; n &lt; [右边子数组所有元素] </span><br></pre></td></tr></table></figure>

<p>这样将得到的每个子数组都划分为两个子数组，直到子数组只有一个元素（一个元素就是有序的），这样就完成了整个快速排序。</p>
<h2 id="枢纽的选择"><a href="#枢纽的选择" class="headerlink" title="枢纽的选择"></a>枢纽的选择</h2><p>枢纽选择影响着快速排序的效率：</p>
<ul>
<li>最简单的，可以选取数组第一个或者最后一个元素</li>
<li>“三数据项取中”法，在数组首、尾、中取数排序，选中间的数作为枢纽。这样排序数组大小要&gt;3。</li>
</ul>
<h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序所用的数组，使用前先初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> quickArray: IntArray</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序算法</span></span><br><span class="line"><span class="comment"> * #1 选择数组最右端元素作为枢纽</span></span><br><span class="line"><span class="comment"> * 思想是</span></span><br><span class="line"><span class="comment"> * 1/2 选出一个枢纽，先将其按大小划分为左右两部分</span></span><br><span class="line"><span class="comment"> * 2/2 在划分好的两个数组中，分别再找一个枢纽，重复步骤1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSort1</span><span class="params">(left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n 这个枢纽的取法很关键，决定了算法的速度</span></span><br><span class="line"><span class="comment">     * 除过这里用到的取法之外，还可以有&quot;三数据项取中&quot;法，在数组首、尾、中取数排序，选中间的数作为枢纽。这样排序数组要&gt;3</span></span><br><span class="line"><span class="comment">     * 对于这些小于3的数组可以用插入排序法进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> n = quickArray[right]</span><br><span class="line">    <span class="keyword">val</span> nIndex = devideArrayByN1(left, right, n)</span><br><span class="line">    <span class="keyword">if</span> (nIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        quickSort1(left, nIndex - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort1(nIndex + <span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 划分算法决定了排序的准确性</span></span><br><span class="line"><span class="comment"> * 提出一个阈值，并以此将数组划分为两部分</span></span><br><span class="line"><span class="comment"> * 左边都小于枢纽，右边都大于枢纽</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">devideArrayByN1</span><span class="params">(left: <span class="type">Int</span>, right: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> leftIndex = left - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> rightIndex = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; quickArray[++leftIndex] &lt; n) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; quickArray[--rightIndex] &gt; n) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> temp = quickArray[leftIndex]</span><br><span class="line">        quickArray[leftIndex] = quickArray[rightIndex]</span><br><span class="line">        quickArray[rightIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> right downTo rightIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        quickArray[i] = quickArray[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    quickArray[rightIndex] = n</span><br><span class="line">    <span class="keyword">return</span> rightIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希尔排序、快速排序的思路，都是将一个大的待排序数组，通过不同的方法拆分成小的子数组，这样比较、移动的次数要小很多。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/sort/SortUtils.kt">👉点这里</a> 查看源码</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化部署文章</title>
    <url>/blog/posts/af2aa19e/</url>
    <content><![CDATA[<p>这是一篇使用Python脚本发布的文章。</p>
<p>python脚本实现一键自动新建文章，编译，预览，发布github.</p>
<p>Just test</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
