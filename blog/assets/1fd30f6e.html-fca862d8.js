const t=JSON.parse('{"key":"v-2d248a9b","path":"/posts/1fd30f6e.html","title":"Java中三种常用的排序方法","lang":"zh-CN","frontmatter":{"permalink":"/posts/1fd30f6e.html","title":"Java中三种常用的排序方法","abbrlink":"1fd30f6e","date":"2016-12-20T23:25:05.000Z","description":"今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。 以下示例皆为从小到大的排序 1.冒泡排序 每一次比较都可能要交换元素。 冒泡排序的思想是： 每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。 在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。 依次类推，总共遍历n-1轮，即可完成排序。 具体代码如下： void bubble(int[] arr){ \\tint temp; \\tfor (int i = 0; i &lt; arr.length - 1; i++) { \\t\\tfor (int j = 0; j &lt; arr.length - i - 1; j++) { \\t\\t\\tif (arr[j] &gt; arr[j + 1]) { \\t\\t\\t\\ttemp = arr[j]; \\t\\t\\t\\tarr[j] = arr[j + 1]; \\t\\t\\t\\tarr[j + 1] = temp; \\t\\t\\t} \\t\\t} \\t} \\t \\tSystem.out.println(\\"\\\\n--bubble :\\"); \\tfor (int i = 0; i &lt; arr.length; i++) { \\t\\tSystem.out.print(arr[i] + \\" \\"); \\t} }","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/1fd30f6e.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"Java中三种常用的排序方法"}],["meta",{"property":"og:description","content":"今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。 以下示例皆为从小到大的排序 1.冒泡排序 每一次比较都可能要交换元素。 冒泡排序的思想是： 每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。 在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。 依次类推，总共遍历n-1轮，即可完成排序。 具体代码如下： void bubble(int[] arr){ \\tint temp; \\tfor (int i = 0; i &lt; arr.length - 1; i++) { \\t\\tfor (int j = 0; j &lt; arr.length - i - 1; j++) { \\t\\t\\tif (arr[j] &gt; arr[j + 1]) { \\t\\t\\t\\ttemp = arr[j]; \\t\\t\\t\\tarr[j] = arr[j + 1]; \\t\\t\\t\\tarr[j + 1] = temp; \\t\\t\\t} \\t\\t} \\t} \\t \\tSystem.out.println(\\"\\\\n--bubble :\\"); \\tfor (int i = 0; i &lt; arr.length; i++) { \\t\\tSystem.out.print(arr[i] + \\" \\"); \\t} }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-18T09:15:35.000Z"}],["meta",{"property":"article:author","content":"JI,XIAOYONG"}],["meta",{"property":"article:published_time","content":"2016-12-20T23:25:05.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-18T09:15:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java中三种常用的排序方法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2016-12-20T23:25:05.000Z\\",\\"dateModified\\":\\"2023-04-18T09:15:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1681809335000,"updatedTime":1681809335000,"contributors":[{"name":"Ji Xiaoyong","email":"jixiaoyong1995@gmail.com","commits":1}]},"readingTime":{"minutes":2.4,"words":719},"filePathRelative":"_posts/Java中三种常用的排序方法.md","localizedDate":"2016年12月21日","excerpt":"<p>今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。\\n以下示例皆为从小到大的排序</p>\\n<h1> 1.冒泡排序</h1>\\n<p>每一次比较都可能要交换元素。\\n冒泡排序的思想是：\\n每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。\\n在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。\\n依次类推，总共遍历n-1轮，即可完成排序。\\n具体代码如下：</p>\\n<pre><code> void bubble(int[] arr){\\n\\tint temp;\\n\\tfor (int i = 0; i &lt; arr.length - 1; i++) {\\n\\t\\tfor (int j = 0; j &lt; arr.length - i - 1; j++) {\\n\\t\\t\\tif (arr[j] &gt; arr[j + 1]) {\\n\\t\\t\\t\\ttemp = arr[j];\\n\\t\\t\\t\\tarr[j] = arr[j + 1];\\n\\t\\t\\t\\tarr[j + 1] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tSystem.out.println(\\"\\\\n--bubble :\\");\\n\\tfor (int i = 0; i &lt; arr.length; i++) {\\n\\t\\tSystem.out.print(arr[i] + \\" \\");\\n\\t}\\n}\\n</code></pre>","autoDesc":true}');export{t as data};
