const e=JSON.parse('{"key":"v-6eae82a2","path":"/posts/8d60b485.html","title":"加载已安装应用、未安装 apk 中的资源","lang":"zh-CN","frontmatter":{"permalink":"/posts/8d60b485.html","title":"加载已安装应用、未安装 apk 中的资源","abbrlink":"8d60b485","date":"2018-04-15T13:40:32.000Z","updated":"2023-12-30T08:17:02.000Z","tag":"android","description":"加载已安装应用、未安装 apk 中的资源，其思路主要是获取到对应的 ClassLoader/Context，通过 ClassLoader 加载 R.java 等类，再通过反射获取对应的资源 id 及资源。 加载已安装应用资源 sharedUserId 在当前应用中加载已安装的其他应用资源，需要二者有相同的sharedUserId，这样 Android 系统为二者分配同一个 Linux 用户 ID，两个 App 可以相互访问代码、资源等。 通过 Shared User id，拥有同一个 User id 的多个 APK 可以配置成运行在同一个进程中。所以默认就是可以互相访问任意数据。也可以配置成运行成不同的进程，同时可以访问其他 APK 的数据目录下的数据库和文件。就像访问本程序的数据一样。 Android 逆向之旅---Android 中的 sharedUserId 属性详解 - CSDN 博客","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/8d60b485.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"加载已安装应用、未安装 apk 中的资源"}],["meta",{"property":"og:description","content":"加载已安装应用、未安装 apk 中的资源，其思路主要是获取到对应的 ClassLoader/Context，通过 ClassLoader 加载 R.java 等类，再通过反射获取对应的资源 id 及资源。 加载已安装应用资源 sharedUserId 在当前应用中加载已安装的其他应用资源，需要二者有相同的sharedUserId，这样 Android 系统为二者分配同一个 Linux 用户 ID，两个 App 可以相互访问代码、资源等。 通过 Shared User id，拥有同一个 User id 的多个 APK 可以配置成运行在同一个进程中。所以默认就是可以互相访问任意数据。也可以配置成运行成不同的进程，同时可以访问其他 APK 的数据目录下的数据库和文件。就像访问本程序的数据一样。 Android 逆向之旅---Android 中的 sharedUserId 属性详解 - CSDN 博客"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-01T11:37:59.000Z"}],["meta",{"property":"article:author","content":"JI,XIAOYONG"}],["meta",{"property":"article:tag","content":"android"}],["meta",{"property":"article:published_time","content":"2018-04-15T13:40:32.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-01T11:37:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"加载已安装应用、未安装 apk 中的资源\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-04-15T13:40:32.000Z\\",\\"dateModified\\":\\"2024-01-01T11:37:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"sharedUserId","slug":"shareduserid","link":"#shareduserid","children":[]},{"level":2,"title":"筛选所有已安装应用信息","slug":"筛选所有已安装应用信息","link":"#筛选所有已安装应用信息","children":[]},{"level":2,"title":"生成插件 App 的 Context","slug":"生成插件-app-的-context","link":"#生成插件-app-的-context","children":[]},{"level":2,"title":"通过 Context 反射获取插件 App 中的资源","slug":"通过-context-反射获取插件-app-中的资源","link":"#通过-context-反射获取插件-app-中的资源","children":[]},{"level":2,"title":"获取 apk 信息","slug":"获取-apk-信息","link":"#获取-apk-信息","children":[]},{"level":2,"title":"获取 ClassLoader","slug":"获取-classloader","link":"#获取-classloader","children":[]},{"level":2,"title":"通过反射加载类，获取资源","slug":"通过反射加载类-获取资源","link":"#通过反射加载类-获取资源","children":[]}],"git":{"createdTime":1704109079000,"updatedTime":1704109079000,"contributors":[{"name":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":1}]},"readingTime":{"minutes":2.48,"words":745},"filePathRelative":"_posts/加载已安装应用、未安装apk中的资源.md","localizedDate":"2018年4月15日","excerpt":"<p>加载已安装应用、未安装 apk 中的资源，其思路主要是获取到对应的 ClassLoader/Context，通过 ClassLoader 加载 R.java 等类，再通过反射获取对应的资源 id 及资源。</p>\\n<h1> 加载已安装应用资源</h1>\\n<h2> sharedUserId</h2>\\n<p>在当前应用中加载已安装的其他应用资源，需要二者有相同的<code>sharedUserId</code>，这样 Android 系统为二者分配同一个 Linux 用户 ID，两个 App 可以相互访问代码、资源等。</p>\\n<blockquote>\\n<p>通过 Shared User id，拥有同一个 User id 的多个 APK 可以配置成运行在同一个进程中。所以默认就是可以互相访问任意数据。也可以配置成运行成不同的进程，同时可以访问其他 APK 的数据目录下的数据库和文件。就像访问本程序的数据一样。</p>\\n<p><a href=\\"https://blog.csdn.net/jiangwei0910410003/article/details/51316688\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Android 逆向之旅---Android 中的 sharedUserId 属性详解 - CSDN 博客</a></p>\\n</blockquote>","autoDesc":true}');export{e as data};
