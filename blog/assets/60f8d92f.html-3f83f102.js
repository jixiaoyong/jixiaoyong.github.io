import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as p,c as l,a as n,b as s,d as e,e as o}from"./app-979c3f18.js";const c={},r=n("p",null,"Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：",-1),u=n("ul",null,[n("li",null,[s("基于 RenderBox 的 "),n("em",null,"box protocol"),s(" 实现的，主要基于 Size 实现布局。常见的有 SingleChildScrollView。")]),n("li",null,[s("基于 RenderSliver 的 "),n("em",null,"sliver protocol"),s(" 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自 ScrollView 的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。")])],-1),d=n("p",null,"上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。",-1),k=n("br",null,null,-1),v={href:"https://xiaoyong.ml/blog/posts/d3bdcb53/",target:"_blank",rel:"noopener noreferrer"},m=n("em",null,"sliver protocol",-1),b=o(`<p>官方对 ScrollView 的定义是：“A widget that scrolls”。</p><p>其主要由三部分组成：</p><ul><li><p>一个<strong>ScrollWidget</strong>，监听用户手势，实现 scrolling 的交互设计</p></li><li><p>一个<strong>viewport widget</strong>，根据传入的 shrinkwrap 值的 true/false 分别会是 ShrinkWrappingViewport 或者 Viewport。通过根据传入的 ViewportOffset 不同而值展示 slivers 的一部分内容来实现滑动的视觉设计效果。</p></li><li><p>一个或多个<strong>slivers</strong>，可以被组合起来创建各种 scrolling effects（比如 list，grids，expanding header 等）的 widget，是真正显示在屏幕上的 widget。</p><p>由于默认的 ScrollView 创建的 viewport 的 slivers 属性只接受能创建 RenderSliver 的 Widget，所以 ScrollView 的<code>List&lt;Widget&gt; buildSlivers(BuildContext context)</code>方法只能返回 SliverXXX 之类（比如 SliverList）可以创建 RenderSliver 的 Widget。</p></li></ul><br><p>ScrollView 是一个抽象类，它主要的作用是将上面提到的三部分组合起来，为（遵从 sliver protocol 的）scrollable widget 封装屏蔽掉滑动底层细节，提供像<code>buildSlivers</code>之类的方法方便子类能够快速实现一个 scrollable widget。</p><h1 id="源码分析" tabindex="-1"><a class="header-anchor" href="#源码分析" aria-hidden="true">#</a> 源码分析</h1><p><code>abstract class ScrollView extends StatelessWidget{}</code></p><p>ScrollView 继承自 StatelessWidget，他的主要逻辑在 build 方法中：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code>  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里创建slivers</span>
    <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Widget</span><span class="token punctuation">&gt;</span></span> slivers <span class="token operator">=</span> <span class="token function">buildSlivers</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">AxisDirection</span> axisDirection <span class="token operator">=</span> <span class="token function">getDirection</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// scrollController要么使用最近的PrimaryScrollController，要么使用自己的controller</span>
    <span class="token keyword">final</span> <span class="token class-name">ScrollController</span><span class="token operator">?</span> scrollController <span class="token operator">=</span>
        primary <span class="token operator">?</span> <span class="token class-name">PrimaryScrollController</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">:</span> controller<span class="token punctuation">;</span>
    <span class="token comment">// 这里是主要创建Scrollable的地方</span>
    <span class="token keyword">final</span> <span class="token class-name">Scrollable</span> scrollable <span class="token operator">=</span> <span class="token class-name">Scrollable</span><span class="token punctuation">(</span>
      dragStartBehavior<span class="token punctuation">:</span> dragStartBehavior<span class="token punctuation">,</span>
      axisDirection<span class="token punctuation">:</span> axisDirection<span class="token punctuation">,</span>
      controller<span class="token punctuation">:</span> scrollController<span class="token punctuation">,</span>
      physics<span class="token punctuation">:</span> physics<span class="token punctuation">,</span>
      scrollBehavior<span class="token punctuation">:</span> scrollBehavior<span class="token punctuation">,</span>
      semanticChildCount<span class="token punctuation">:</span> semanticChildCount<span class="token punctuation">,</span>
      restorationId<span class="token punctuation">:</span> restorationId<span class="token punctuation">,</span>
      viewportBuilder<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">,</span> <span class="token class-name">ViewportOffset</span> offset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在这里创建viewport，使用我们创建好的slivers填充viewport</span>
        <span class="token comment">// 并传入Scrollable.ScrollPosition作为这里的入参offset，在viewport中</span>
        <span class="token comment">// 会监听offset的变化来重新绘制slivers从而实现滑动效果</span>
        <span class="token keyword">return</span> <span class="token function">buildViewport</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> axisDirection<span class="token punctuation">,</span> slivers<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Widget</span> scrollableResult <span class="token operator">=</span> primary <span class="token operator">&amp;&amp;</span> scrollController <span class="token operator">!=</span> <span class="token keyword">null</span>
        <span class="token operator">?</span> <span class="token class-name">PrimaryScrollController</span><span class="token punctuation">.</span><span class="token function">none</span><span class="token punctuation">(</span>child<span class="token punctuation">:</span> scrollable<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> scrollable<span class="token punctuation">;</span>

    <span class="token comment">// 这里是处理当scrollable view滑动时隐藏键盘的逻辑</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>keyboardDismissBehavior <span class="token operator">==</span> <span class="token class-name">ScrollViewKeyboardDismissBehavior</span><span class="token punctuation">.</span>onDrag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token class-name">NotificationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ScrollUpdateNotification</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>
        child<span class="token punctuation">:</span> scrollableResult<span class="token punctuation">,</span>
        onNotification<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token class-name">ScrollUpdateNotification</span> notification<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">final</span> <span class="token class-name">FocusScopeNode</span> focusScope <span class="token operator">=</span> <span class="token class-name">FocusScope</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>notification<span class="token punctuation">.</span>dragDetails <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> focusScope<span class="token punctuation">.</span>hasFocus<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            focusScope<span class="token punctuation">.</span><span class="token function">unfocus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> scrollableResult<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上述代码，我们可以验证之前的判断：ScrollView 本身是对 Scrollable、viewport、slivers 的封装。具体的处理滑动手势、更新 ScrollPosition、发送 ScrollNotification 等等都在 Scrollable 中处理了，ScrollView 的子类只需要按照要求提供 slivers（通过 buildSlivers 方法）和其他一些必须的信息即可。</p><p>上面的代码中还分别调用了 buildViewport 和 buildSlivers 方法，接下来我们逐一分析一下他们的源码。</p><h2 id="widget-buildviewport" tabindex="-1"><a class="header-anchor" href="#widget-buildviewport" aria-hidden="true">#</a> Widget buildViewport()</h2><p>buildViewport 方法顾名思义，是用来创建 viewport 的。在 ScrollView 中默认会按照 shrinkWrap 的不同创建两种 viewport，他的子类也可以根据需要重写此方法以返回自己的 viewport。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code>  <span class="token class-name">Widget</span> <span class="token function">buildViewport</span><span class="token punctuation">(</span>
    <span class="token class-name">BuildContext</span> context<span class="token punctuation">,</span>
    <span class="token class-name">ViewportOffset</span> offset<span class="token punctuation">,</span>
    <span class="token class-name">AxisDirection</span> axisDirection<span class="token punctuation">,</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Widget</span><span class="token punctuation">&gt;</span></span> slivers<span class="token punctuation">,</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>axisDirection<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">AxisDirection</span><span class="token punctuation">.</span>up<span class="token punctuation">:</span>
        <span class="token keyword">case</span> <span class="token class-name">AxisDirection</span><span class="token punctuation">.</span>down<span class="token punctuation">:</span>
          <span class="token comment">// 如果是上述两种AxisDirection说明Axis是Axis.vertical的，那么就</span>
          <span class="token comment">// 需要判断是否此widget是否有Directionality可以用来判断文本布局方向</span>
          <span class="token comment">// 如果没法判断则抛出FlutterError，否则返回true</span>
          <span class="token keyword">return</span> <span class="token function">debugCheckHasDirectionality</span><span class="token punctuation">(</span>
            context<span class="token punctuation">,</span>
            why<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&#39;to determine the cross-axis direction of the scroll view&#39;</span></span><span class="token punctuation">,</span>
            hint<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&#39;Vertical scroll views create Viewport widgets that try to determine their cross axis direction &#39;</span></span>
                  <span class="token string-literal"><span class="token string">&#39;from the ambient Directionality.&#39;</span></span><span class="token punctuation">,</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果getDirection()能得出下面两种AxisDirection说明Axis是</span>
        <span class="token comment">// Axis.horizontal的，并且已经得知文本方向，所以直接返回true</span>
        <span class="token keyword">case</span> <span class="token class-name">AxisDirection</span><span class="token punctuation">.</span>left<span class="token punctuation">:</span>
        <span class="token keyword">case</span> <span class="token class-name">AxisDirection</span><span class="token punctuation">.</span>right<span class="token punctuation">:</span>
          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 经过上述检查，到这里widget的文本方向（TextDirection）一定已经确定了</span>
    <span class="token comment">// 这里根据shrinkWrap的不同分别创建两种viewport</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shrinkWrap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token class-name">ShrinkWrappingViewport</span><span class="token punctuation">(</span>
        axisDirection<span class="token punctuation">:</span> axisDirection<span class="token punctuation">,</span>
        offset<span class="token punctuation">:</span> offset<span class="token punctuation">,</span>
        slivers<span class="token punctuation">:</span> slivers<span class="token punctuation">,</span>
        clipBehavior<span class="token punctuation">:</span> clipBehavior<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">Viewport</span><span class="token punctuation">(</span>
      axisDirection<span class="token punctuation">:</span> axisDirection<span class="token punctuation">,</span>
      offset<span class="token punctuation">:</span> offset<span class="token punctuation">,</span>
      slivers<span class="token punctuation">:</span> slivers<span class="token punctuation">,</span>
      cacheExtent<span class="token punctuation">:</span> cacheExtent<span class="token punctuation">,</span>
      center<span class="token punctuation">:</span> center<span class="token punctuation">,</span>
      anchor<span class="token punctuation">:</span> anchor<span class="token punctuation">,</span>
      clipBehavior<span class="token punctuation">:</span> clipBehavior<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在 buildViewport()方法中，显示在 debug 模式下检查确保 widget 已经确定了文本方向（TextDirection 是 rtl 还是 ltr）；然后根据 shrinkWrap 的不同分别创建 ShrinkWrappingViewport 或者 Viewport，他们会根据 offset 的变化展示不同部分的 slivers。</p><p>ShrinkWrappingViewport 和 Viewport 都是继承自 MultiChildRenderObjectWidget 的 widget，主要逻辑是分别创建对应的 RenderObject：RenderShrinkWrappingViewport 和 RenderViewport，而这两者又都继承自 RenderViewportBase。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">Viewport</span> <span class="token keyword">extends</span> <span class="token class-name">MultiChildRenderObjectWidget</span> <span class="token punctuation">{</span>

  <span class="token metadata function">@override</span>
  <span class="token class-name">RenderViewport</span> <span class="token function">createRenderObject</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">RenderViewport</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token metadata function">@override</span>
  <span class="token keyword">void</span> <span class="token function">updateRenderObject</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">,</span> <span class="token class-name">RenderViewport</span> renderObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    renderObject<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token metadata function">@override</span>
  <span class="token class-name">MultiChildRenderObjectElement</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">_ViewportElement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">ShrinkWrappingViewport</span> <span class="token keyword">extends</span> <span class="token class-name">MultiChildRenderObjectWidget</span> <span class="token punctuation">{</span>

  <span class="token metadata function">@override</span>
  <span class="token class-name">RenderShrinkWrappingViewport</span> <span class="token function">createRenderObject</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">RenderShrinkWrappingViewport</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token metadata function">@override</span>
  <span class="token keyword">void</span> <span class="token function">updateRenderObject</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">,</span> <span class="token class-name">RenderShrinkWrappingViewport</span> renderObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    renderObject<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="renderviewportbase" tabindex="-1"><a class="header-anchor" href="#renderviewportbase" aria-hidden="true">#</a> RenderViewportBase</h3><p><code>abstract class RenderViewportBase&lt;ParentDataClass extends ContainerParentDataMixin&lt;RenderSliver&gt;&gt; extends RenderBox with ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt; implements RenderAbstractViewport {}</code></p><p>RenderViewportBase 继承自 RenderBox，混入了 ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;类，本身不持有 children，但提供了在 RenderBox 中容纳 RenderSliver 的一些通用方法：</p><ul><li>自动添加监听_offset 的方法，在其变化时执行 markNeedsLayout()方法实现滑动效果</li><li>提供按照_offset 的值 layout、paint 持有的 children 的方法</li><li>通过 hitTestChildren 实现 children 的 hit test</li></ul><h4 id="校验-children-类型是否为-rendersliver" tabindex="-1"><a class="header-anchor" href="#校验-children-类型是否为-rendersliver" aria-hidden="true">#</a> 校验 children 类型是否为 RenderSliver</h4><p>在 RenderViewportBase 混入的 ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;的 debugValidateChild()方法中会<strong>检验 child 的类型是否为指定的 ChildType</strong>（在 RenderViewportBase 中 ChildType 为 RenderSliver），如果不是则会抛出 FlutterError，这也是 ScrollView 默认 Viewport 只支持可以创建 RenderSliver 的 Widget 的原因。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">mixin</span> <span class="token class-name">ContainerRenderObjectMixin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ChildType</span> <span class="token keyword">extends</span> <span class="token class-name">RenderObject</span><span class="token punctuation">,</span> <span class="token class-name">ParentDataType</span> <span class="token keyword">extends</span> <span class="token class-name">ContainerParentDataMixin</span><span class="token punctuation">&lt;</span><span class="token class-name">ChildType</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">on</span> <span class="token class-name">RenderObject</span> <span class="token punctuation">{</span>
  bool <span class="token function">debugValidateChild</span><span class="token punctuation">(</span><span class="token class-name">RenderObject</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">is!</span> <span class="token class-name">ChildType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 此处会校验child的类型</span>
        <span class="token keyword">throw</span> <span class="token class-name">FlutterError</span><span class="token punctuation">.</span><span class="token function">fromParts</span><span class="token punctuation">(</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DiagnosticsNode</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见 ContainerRenderObjectMixin 提供了检测 child 类型的方法，那么它是在什么时候被调用的呢？</p><p>无论是 Viewport 还是 ShrinkWrappingViewport 都继承自 MultiChildRenderObjectWidget，其会创建 MultiChildRenderObjectElement。</p><p>MultiChildRenderObjectElement.insertRenderObjectChild()添加 child 中的 RenderObject 时都会先检查一下 child 的类型：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">MultiChildRenderObjectElement</span> <span class="token keyword">extends</span> <span class="token class-name">RenderObjectElement</span> <span class="token punctuation">{</span>
  <span class="token metadata function">@override</span>
  <span class="token keyword">void</span> <span class="token function">insertRenderObjectChild</span><span class="token punctuation">(</span><span class="token class-name">RenderObject</span> child<span class="token punctuation">,</span> <span class="token class-name">IndexedSlot</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Element</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ContainerRenderObjectMixin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RenderObject</span><span class="token punctuation">,</span> <span class="token class-name">ContainerParentDataMixin</span><span class="token punctuation">&lt;</span><span class="token class-name">RenderObject</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> renderObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>renderObject<span class="token punctuation">;</span>
    <span class="token comment">// 注意这里调用MultiChildRenderObjectElement持有的RenderObject的</span>
    <span class="token comment">// debugValidateChild方法校验child类型</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span>renderObject<span class="token punctuation">.</span><span class="token function">debugValidateChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    renderObject<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> after<span class="token punctuation">:</span> slot<span class="token punctuation">.</span>value<span class="token operator">?</span><span class="token punctuation">.</span>renderObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span>renderObject <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>renderObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而因为不管是 RenderShrinkWrappingViewport 还是 RenderViewport 都是继承自 RenderViewportBase，也就会执行<code>ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;.debugValidateChild(child)</code>方法,校验 child 类型是否为 RenderSliver，所以会在其<code>slivers</code>中直接传入 box widget 则会报错“A RenderViewport expected a child of type <strong>RenderSliver</strong> but received a child of type RenderXXX.”</p><h3 id="renderviewport" tabindex="-1"><a class="header-anchor" href="#renderviewport" aria-hidden="true">#</a> RenderViewport</h3><p><code>class RenderViewport extends RenderViewportBase&lt;SliverPhysicalContainerParentData&gt; {}</code></p><p>RenderViewport 是 Flutter 滑动机制的主力，他通过监听<code>offset</code>的变化展示<code>children</code>的一部分来实现滑动的视觉效果,他会占据父级给的最大空间（<strong>大小由父级指定</strong>）。</p><p>其内部持有一个双向的 slivers 列表<code>children</code>，以在 zero scroll offset 的<code>center</code>为锚点：</p><ul><li>slivers 列表中在 center 之前的 Slivers 按照列表反方向，沿着 axisDirection 的反方向展示。</li><li>slivers 列表中在 center 之后的 Slivers 按照列表的方向，沿着 axisDirection 的方向展示。</li></ul><p>比如一个 axisDirection 为 AxisDirection.down，children 列表为[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;center&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;]，center 为“center”，那么默认会展示[&quot;center&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;]，当手指向下滑动的时候，会依次展示出“3”、“2”、“1”，等完全下拉之后，展示内容为：[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;center&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;]。</p><h3 id="rendershrinkwrappingviewport" tabindex="-1"><a class="header-anchor" href="#rendershrinkwrappingviewport" aria-hidden="true">#</a> RenderShrinkWrappingViewport</h3><p><code>class RenderShrinkWrappingViewport extends RenderViewportBase&lt;SliverLogicalContainerParentData&gt;{}</code></p><p>RenderShrinkWrappingViewport 通过监听<code>offset</code>的变化展示<code>children</code>的一部分来实现滑动的视觉效果,与 Viewport 不同的是，他会 shrinkWrap（收缩包装）自己以便在主轴上匹配 children 的 size（<strong>大小由 RenderShrinkWrappingViewport 根据 children 计算而来</strong>），<strong>比较耗费性能</strong>（特别是当 item 可能会通过折叠展开等方式改变尺寸时）。</p><h2 id="list-widget-buildslivers" tabindex="-1"><a class="header-anchor" href="#list-widget-buildslivers" aria-hidden="true">#</a> List&lt;Widget&gt; buildSlivers()</h2><p>ScrollView 的 buildSlivers 方法是抽象方法，由子类根据需要实现，<em>一般子类也只需要重写此方法即可</em>。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code>  <span class="token comment">/// Build the list of widgets to place inside the viewport.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// Subclasses should override this method to build the slivers for the inside</span>
  <span class="token comment">/// of the viewport.</span>
  <span class="token metadata function">@protected</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Widget</span><span class="token punctuation">&gt;</span></span> <span class="token function">buildSlivers</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="使用示例" tabindex="-1"><a class="header-anchor" href="#使用示例" aria-hidden="true">#</a> 使用示例</h1><p>CustomScrollView 就是继承自 ScrollView：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">CustomScrollView</span> <span class="token keyword">extends</span> <span class="token class-name">ScrollView</span> <span class="token punctuation">{</span>
  <span class="token comment">/// Creates a [ScrollView] that creates custom scroll effects using slivers.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// See the [ScrollView] constructor for more details on these arguments.</span>
  <span class="token keyword">const</span> <span class="token class-name">CustomScrollView</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/// The slivers to place inside the viewport.</span>
  <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Widget</span><span class="token punctuation">&gt;</span></span> slivers<span class="token punctuation">;</span>

  <span class="token metadata function">@override</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Widget</span><span class="token punctuation">&gt;</span></span> <span class="token function">buildSlivers</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> slivers<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 CustomScrollView 的实现比较简单，主要逻辑是将传入的参数<code>slivers</code>作为<code>List&lt;Widget&gt; buildSlivers(BuildContext context)</code>的返回值。这导致我们在使用 CustomScrollView 的时候，需要传入 SliverList、SliverAppBar 等这些继承自 SliverMultiBoxAdaptorWidget 能创建 RenderSliver 的 Widget，而不是普通的 box widget。</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><p>ScrollView 的子类借助 SliverMultiBoxAdaptorWidget 及其子类可以实现<strong>对 item 的懒加载</strong>从而避免创建无法通过 viewport 可见的 children（这种类型的传参一般都需传入 SliverChildDelegate 的子类），从而优化性能。</p><p>而根据 shrinkWrap 的不同，分别使用 Viewport 和 ShrinkWrappingViewport 创建 viewport，从而分别实现按照父级指定 size 或按照子级计算 size（比较耗性能）。</p><p>ScrollView 是 Flutter 中基于 sliver protocol 的 scrollable widget 的父类，因为 viewport 的限制只接受创建 RenderSliver 的 widget 作为其直接子类。其子类则通过 SliverMultiBoxAdaptorWidget 及其子类实现加载 box widget。</p><p>以下类都是基于 ScrollView 实现的 scrollable widget：</p>`,51),h={href:"https://api.flutter.dev/flutter/widgets/CustomScrollView-class.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://api.flutter.dev/flutter/widgets/BoxScrollView-class.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://api.flutter.dev/flutter/widgets/ListView-class.html",target:"_blank",rel:"noopener noreferrer"},f={href:"https://api.flutter.dev/flutter/widgets/GridView-class.html",target:"_blank",rel:"noopener noreferrer"},S=n("h1",{id:"参考资料",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),s(" 参考资料")],-1),x={href:"https://api.flutter.dev/flutter/widgets/ScrollView-class.html",target:"_blank",rel:"noopener noreferrer"};function V(y,R){const a=i("ExternalLinkIcon");return p(),l("div",null,[r,u,d,k,n("p",null,[s("上回我们对 SingleChildScrollView 的实现做了简单分析（见《"),n("a",v,[s("Flutter 滑动分析之 SingleChildScrollView"),e(a)]),s("》），本文将对另外一种遵循 "),m,s(" 的 ScrollView 做一分析。")]),b,n("ul",null,[n("li",null,[n("a",h,[s("CustomScrollView"),e(a)])]),n("li",null,[n("a",w,[s("BoxScrollView"),e(a)]),n("ul",null,[n("li",null,[n("a",g,[s("ListView"),e(a)])]),n("li",null,[n("a",f,[s("GridView"),e(a)])])])])]),S,n("p",null,[n("a",x,[s("ScrollView_api.flutter.dev"),e(a)])])])}const W=t(c,[["render",V],["__file","60f8d92f.html.vue"]]);export{W as default};
