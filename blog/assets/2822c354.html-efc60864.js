import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as d,c as r,a as n,b as s,d as e,f as i,w as c,e as o}from"./app-df744fe4.js";const u={},k=o(`<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h1><p><code>Dagger 2</code>是Google维护的一款可用于<code>Java</code>和<code>Android</code>的依赖注入框架。</p><p>本文主要是简单梳理<code>Dagger 2</code>中各个注解的作用，以及其简单用法，不涉及具体项目应用。</p><p>先解释几个概念：</p><ul><li><p><strong><code>依赖注入</code></strong>：是一个对象（或静态方法）给另一个对象提供依赖的技术。</p></li><li><p>**<code>依赖</code>**是可以使用的对象（<code>Service</code>），而把依赖提供给使用该依赖的对象（<code>Client</code>）的过程叫做<code>注入</code>。</p></li></ul><p>例如，下面这段代码中<code>Service</code>就是<code>Client</code>的依赖。：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> Service

<span class="token keyword">class</span> <span class="token function">Client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">init</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> service <span class="token operator">=</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是如果每个依赖都这样写的话，如果<code>Service</code>类的构造方法有变更，就需要同时也更改<code>Client</code>对应的方法，这样深耦合的代码显然不是我们需要的。</p><p><code>Dagger 2 </code>就是为了帮助我们解决这个问题，在使用它之后，<code>Client</code>类的代码只需要这样写成类似下面这样（示例代码）：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> Client<span class="token punctuation">{</span>

    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> service<span class="token operator">:</span> Service

    <span class="token keyword">init</span> <span class="token punctuation">{</span>
        <span class="token comment">//TODO 某个将Service依赖注入的方法 magicFun()</span>
        <span class="token keyword">val</span> newService <span class="token operator">=</span> service<span class="token comment">//使用Service的实例service</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，这时<code>Service</code>的实例化过程被移到了<code>Client</code>的外部某处，这样如果<code>Service</code>构造方法有更新时，我们只需要统一去修改<code>magicFun()</code>中对应的代码即可。</p><p>那么这一切<code>Dagger 2</code>到底是如何实现的呢？</p><h1 id="dagger-2-具体实现" tabindex="-1"><a class="header-anchor" href="#dagger-2-具体实现" aria-hidden="true">#</a> Dagger 2 具体实现</h1><h2 id="inject" tabindex="-1"><a class="header-anchor" href="#inject" aria-hidden="true">#</a> @Inject</h2><p>首先需要请出第一个主角——<strong><code>@Inject</code></strong>。</p><p>在<code>Dagger 2</code>中，<code>@Inject</code>主要做两件事❶标记依赖类的构造方法；❷标记需要框架自动实例化的对象：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> Service <span class="token annotation builtin">@Inject</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//❶标记依赖类的构造方法</span>

<span class="token keyword">class</span> Client<span class="token punctuation">{</span>

    <span class="token annotation builtin">@Inject</span>
    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> service<span class="token operator">:</span> Service<span class="token comment">//❷标记需要框架自动实例化的对象</span>
	<span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样<code>Dagger 2 </code>就知道了有个对象需要它来帮助我们注入，同时也知道了有一个构造方法来实例化<code>Service</code>对象。但这时如何将二者联系起来呢？</p><h2 id="component" tabindex="-1"><a class="header-anchor" href="#component" aria-hidden="true">#</a> @Component</h2><p>这就要提到第二个主角——<strong><code>@Component</code></strong>。</p><p><code>@Component</code>标记的类是将一个类和他的依赖联系在一起的桥梁，通常是一个<strong>抽象类或者接口</strong>：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token annotation builtin">@Component</span>
<span class="token keyword">interface</span> ClientComponent<span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">inject</span><span class="token punctuation">(</span>client<span class="token operator">:</span> Client<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，<code>Client</code>和<code>Service</code>通过<code>ClientComponent</code>联系在一起，在使用时只需要将<code>Client</code>的引用传入即可：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>    <span class="token keyword">init</span> <span class="token punctuation">{</span>
        <span class="token comment">//方式❶ DaggerClientComponent.create().inject(this)</span>
        <span class="token comment">//方式❷ DaggerClientComponent.builder().build().inject(this)</span>
        <span class="token keyword">val</span> newService <span class="token operator">=</span> service
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,24),v={href:"https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8#file-dagger2_basic_guide_line_part1-kt",target:"_blank",rel:"noopener noreferrer"},m=n("p",null,[s("到目前为止，对于我们自己定义的类，我们只需要使用"),n("code",null,"@Inject"),s("标记其构造方法，然后再在使用该类的时候使用"),n("code",null,"@Inject"),s("标记该对象，在需要使用该对象的地方通过"),n("code",null,"@Component"),s("类传入使用该依赖的类的引用即可。")],-1),b=n("img",{style:{"border-radius":"0.3125em","box-shadow":"0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08)"},src:"https://jixiaoyong.github.io/images/20190126184230.png"},null,-1),g=n("br",null,null,-1),h=n("div",{style:{color:"#999","border-bottom":"1px solid #d9d9d9",display:"inline-block",padding:"2px"}},"@Component自动实现依赖注入的示意图",-1),f=o(`<p>但是很显然实际开发中，不是所有的<code>Service</code>类都可以被我们随意修改，如果<code>Service</code>类是第三方提供的类，显然我们是无法用<code>@Inject</code>修饰其构造函数的。</p><h2 id="module和-provides" tabindex="-1"><a class="header-anchor" href="#module和-provides" aria-hidden="true">#</a> @Module和@Provides</h2><p>为了解决第三方依赖的问题，我们要引入另外两个主角——<strong><code>@Module</code><strong>和</strong><code>@Provides</code></strong>。</p><p><code>@Provides</code>用来提供一个方法，我们可以在其内部实例化并返回<code>Service</code>类，这样子当用到<code>Service</code>的时候，<code>@Component</code>类只需要找到<code>@Provides</code>提供的这个方法，并获取到他实例化好的<code>Service</code>对象注入到<code>Client</code>中就可以了。</p><p><code>@Module</code>则是提供一个<strong>类</strong>（注意是类，而非接口），像一个袋子一样把<code>@Provides</code>提供的方法“装”到一起，打包提供给<code>@Component</code>类。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token annotation builtin">@Module</span>
<span class="token keyword">class</span> ClientModule<span class="token punctuation">{</span>

    <span class="token annotation builtin">@Provides</span>
    <span class="token keyword">fun</span> <span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token annotation builtin">@Component</span><span class="token punctuation">(</span>modules <span class="token operator">=</span> <span class="token punctuation">[</span>ClientModule<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//Component可以有多个Module类</span>
<span class="token keyword">interface</span> ClientComponent<span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">inject</span><span class="token punctuation">(</span>client<span class="token operator">:</span> Client<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的<code>@Component(modules = [ClientModule::class])</code>将装有可以产生依赖的<code>@Provides</code>方法的“大袋子”<code>@Module</code>和“桥梁”<code>@Component</code>关联到了一起。</p><p><code>@Component</code>在产生依赖的时候会先到<code>@Module</code>类中的<code>@Provides</code>方法中查找；如果找不到才会再到<code>@Inject</code>中查找。（也就是说，此时<code>Service</code>类的<code>@Inject</code>构造方法其实是失效了的，完全可以没有<code>@Inject</code>注解——第三方类即是如此）。</p>`,8),_={href:"https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb",target:"_blank",rel:"noopener noreferrer"},y=o(`<p>解决了第三方依赖引用的问题，还有一个非常重要的问题——我们使用的绝大多数类肯定不止一个构造方法，那么假设依赖类<code>Service</code>现在有两个构造方法，我们需要分别这两个构造方法，这种情况又该怎么处理呢？</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> Service <span class="token annotation builtin">@Inject</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">var</span> string<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;default&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>很明显，这时候<code>@Inject</code>注解已经没用了，一个类只能有一个构造方法被<code>@Inject</code>修饰，否则会报错：<code>错误: Types may only contain one @Inject constructor</code>。</p><p>去掉<code>@Inject</code>后<code>Service</code>类变成如下：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token keyword">var</span> string<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;default&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>尝试在<code>@Module</code>中添加另外一个<code>@Provides</code>方法使用另外一个带参构造函数：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token annotation builtin">@Module</span>
<span class="token keyword">class</span> ClientModule<span class="token punctuation">{</span>

    <span class="token annotation builtin">@Provides</span>
    <span class="token keyword">fun</span> <span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token annotation builtin">@Provides</span> 
    <span class="token keyword">fun</span> <span class="token function">getServiceWithArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Args&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行时发现会出错，因为有两个方法都可以提供<code>Service</code>，<code>@Component</code>产生了迷失，不知道用哪一个好，导致错误。</p><h2 id="named和-qualifier" tabindex="-1"><a class="header-anchor" href="#named和-qualifier" aria-hidden="true">#</a> @Named和@Qualifier</h2><p>为了解决多个构造函数导致的问题，这时就需要第五个主角**<code>@Named</code><strong>以及幕后英雄</strong><code>@Qualifier</code>**</p><p>首先，上述问题的解决方案是在另外一个方法上加一个注解<code>@Named</code>，表示他是一个特殊的方法：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>    <span class="token annotation builtin">@Provides</span> <span class="token annotation builtin">@Named</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Args&quot;</span></span><span class="token punctuation">)</span>
    <span class="token keyword">fun</span> <span class="token function">getServiceWithArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Args&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当在<code>Client</code>中想使用这个方法的依赖时：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>    <span class="token comment">//@field:是kotlin中注解字段特别需要的，在Java中可以直接写成@Named(&quot;Args&quot;)</span>
    <span class="token annotation builtin">@Inject</span>
    <span class="token annotation builtin">@field:Named</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Args&quot;</span></span><span class="token punctuation">)</span>
    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> service<span class="token operator">:</span> Service
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看<code>@Named</code>源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Qualifier</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>

    <span class="token doc-comment comment">/** The name. */</span>
    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发现<code>@Qualifier</code>才是他实现标识限定符注解（Identifies qualifier annotations）的力量之源。查看<code>@Qualifier</code>注解可以知道，我们也可以自定义基于<code>@Qualifier</code>的注解来实现和<code>@Named</code>完全一致的功能。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token annotation builtin">@Qualifier</span>
<span class="token annotation builtin">@MustBeDocumented</span>
<span class="token label symbol">@kotlin</span><span class="token punctuation">.</span>annotation<span class="token punctuation">.</span><span class="token function">Retention</span><span class="token punctuation">(</span>AnnotationRetention<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token keyword">annotation</span> <span class="token keyword">class</span> <span class="token function">YourQualifierName</span><span class="token punctuation">(</span><span class="token comment">//YourQualifierName可以是任意你喜欢的名字</span>
    <span class="token comment">/** The name.  */</span>
    <span class="token keyword">val</span> value<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;&quot;</span></span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后我们就可以使用<code>@YourQualifierName</code>替代<code>@Named</code>实现标识不同注解的作用，从而支持有多个构造函数的<code>Service</code>类的初始化。</p>`,19),S={href:"https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a",target:"_blank",rel:"noopener noreferrer"},C=n("p",null,[n("code",null,"@Component"),s("可以有多个"),n("code",null,"@Module"),s("，他们之间的关系可以用下图表示：")],-1),w=n("img",{style:{"border-radius":"0.3125em","box-shadow":"0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08)"},src:"https://jixiaoyong.github.io/images/20190126201436.png"},null,-1),x=n("br",null,null,-1),j=n("div",{style:{color:"#999","border-bottom":"1px solid #d9d9d9",display:"inline-block",padding:"2px"}},"@Component 会先到他拥有的多个@Module中去查找Service类",-1),q=o(`<h2 id="singleton和-scope" tabindex="-1"><a class="header-anchor" href="#singleton和-scope" aria-hidden="true">#</a> @Singleton和@Scope</h2><p>在实际开发中，我们需要有的类只能有一个实例，从而在不同的地方共享一些数据——即单例，这种情况就需要另外一个角色<code>@Singleton</code>和他的幕后英雄<code>@Scope</code>。</p><p>@Singleton是用来标记类在其范围内只能被实例化一次。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token annotation builtin">@Scope</span>
<span class="token annotation builtin">@Documented</span>
<span class="token annotation builtin">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> Singleton <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过查看其源码可以知道其背后是<code>@Scope</code>在起作用，<code>@Scope</code>的作用是限定其修饰的类的范围，适用于有可注入的构造函数并且包含控制类型实例如何重用的类。没有<code>@Scope</code>修饰的实例在构造完毕后就会失去控制，不再关心后续的发展（<em>then forgets it</em>），而<code>@Scope</code>修饰的类会在实例构造完毕后，继续保留一遍下一次可能的复用，当有多个线程可以访问该实例时，他的实现应该是线程安全的（<em>it‘s implementation should be thread safe</em>）。</p><p>此外<code>@Component</code>应该和他所包含的<code>@Module</code>的<code>@Provides</code>的<code>@Scope</code>范围一致：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token annotation builtin">@Singleton</span>
<span class="token annotation builtin">@Component</span><span class="token punctuation">(</span>modules <span class="token operator">=</span> <span class="token punctuation">[</span>ClientModule<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">interface</span> ClientComponent<span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">inject</span><span class="token punctuation">(</span>client<span class="token operator">:</span> Client<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token annotation builtin">@Module</span>
<span class="token keyword">class</span> ClientModule<span class="token punctuation">{</span>

    <span class="token annotation builtin">@Provides</span>
    <span class="token keyword">fun</span> <span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token annotation builtin">@Singleton</span>
    <span class="token annotation builtin">@Provides</span> <span class="token annotation builtin">@Choose</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Args&quot;</span></span><span class="token punctuation">)</span>
    <span class="token keyword">fun</span> <span class="token function">getServiceWithArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Service</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Args&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外两个关系为**<code>dependencies</code>**的<code>@Component</code>可以分别拥有相同名称的<code>@Inject</code>、<code>@Module</code>、<code>@Provides</code>而不会被<em>merge</em>，两者可以相互访问。</p><p>而**<code>subcomponents</code>**则不能和<code>@Component</code>有以上相同的项。</p>`,9),I=n("p",null,[n("code",null,"Subcomponent"),s("从它的父类访问所有依赖")],-1),M=n("p",null,[n("code",null,"@Component"),s("只能访问在基类"),n("code",null,"@Component"),s("接口暴露的公共性的依赖")],-1),D={href:"https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/",target:"_blank",rel:"noopener noreferrer"},N=n("p",null,"他们之间的关系可以表示为下图：",-1),P=n("img",{style:{"border-radius":"0.3125em","box-shadow":"0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08)"},src:"https://jixiaoyong.github.io/images/20190127204658.png"},null,-1),A=n("br",null,null,-1),Q=n("div",{style:{color:"#999","border-bottom":"1px solid #d9d9d9",display:"inline-block",padding:"2px"}},"@Subcomponent,@Component之间的关系",-1),E=n("h1",{id:"参考资料",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),s(" 参考资料")],-1),T={href:"https://github.com/android-cn/blog/tree/master/java/dependency-injection",target:"_blank",rel:"noopener noreferrer"},R={href:"https://en.wikipedia.org/wiki/Dependency_injection",target:"_blank",rel:"noopener noreferrer"},B={href:"https://medium.com/@elye.project",target:"_blank",rel:"noopener noreferrer"},V={href:"https://google.github.io/dagger/users-guide",target:"_blank",rel:"noopener noreferrer"},U={href:"https://www.jianshu.com/p/2cd491f0da01",target:"_blank",rel:"noopener noreferrer"},W={href:"https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/",target:"_blank",rel:"noopener noreferrer"};function Y(F,G){const a=l("ExternalLinkIcon"),t=l("center");return d(),r("div",null,[k,n("p",null,[s("以上完整的代码可以参考这里,"),n("a",v,[s("若无法显示可点击这里查看"),e(a)]),s("：")]),i(' <script src="https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8.js"><\/script> '),m,e(t,null,{default:c(()=>[b,s(),g,s(),h]),_:1}),f,n("p",null,[s("上述完整代码如下,"),n("a",_,[s("若无法显示可点击这里查看"),e(a)]),s("：")]),i(' <script src="https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb.js"><\/script> '),y,n("p",null,[s("上述完整代码如下,"),n("a",S,[s("若无法显示可点击这里查看"),e(a)]),s("：：")]),i(' <script src="https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a.js"><\/script> '),C,e(t,null,{default:c(()=>[w,s(),x,s(),j]),_:1}),q,n("blockquote",null,[I,M,n("p",null,[s("——"),n("a",D,[s("Subcomponents和Component Dependencies——Sinyuk Blog"),e(a)])])]),N,e(t,null,{default:c(()=>[P,s(),A,s(),Q]),_:1}),E,n("p",null,[n("a",T,[s("android-cn：依赖注入—— Github"),e(a)])]),n("p",null,[n("a",R,[s("Dependency Injection ——wikipedia"),e(a)])]),n("p",null,[n("a",B,[s("Elye的Dagger 2 系列"),e(a)])]),n("p",null,[n("a",V,[s("Dagger 2 官方手册"),e(a)])]),n("p",null,[n("a",U,[s("Android - Dagger2使用详解——简书"),e(a)])]),n("p",null,[n("a",W,[s("Subcomponents和Component Dependencies——Sinyuk Blog"),e(a)])])])}const O=p(u,[["render",Y],["__file","2822c354.html.vue"]]);export{O as default};
