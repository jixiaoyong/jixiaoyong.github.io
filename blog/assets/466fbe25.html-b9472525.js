import{_ as p,r as o,o as i,c,a as n,b as s,d as e,e as t}from"./app-749dd491.js";const l={},r=t(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>本文介绍了递归，归并排序，还有递归在汉诺塔问题上的应用。</p><p>排序顺序为 <code>小 → 大</code></p><h2 id="递归" tabindex="-1"><a class="header-anchor" href="#递归" aria-hidden="true">#</a> 递归</h2><p>递归是一种在函数内部调用自己的函数。在满足一定条件后可以退出递归。</p><p>比如三角数组就是一个简单的递归：</p><blockquote><p>有一组数据，满足这样的条件<code>第n项</code> = <code>第n-1项</code> + <code>n</code>，就称为三角数组，如：</p><p><code>1,2,6,10,15,21...</code></p></blockquote><p>这里面，<strong><code>第n项</code> = <code>第n-1项</code> + <code>n</code></strong>,就是一个递归，每一项的计算结构都依赖于前一项的计算，直到第 1 项的计算结果为确定的 1，不再继续递归。</p><p>实现如下：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">/**
 * 三角数
 * 第 n 个数 == 第 n-1 个数 + n
 */</span>
<span class="token keyword">fun</span> <span class="token function">triangleNum</span><span class="token punctuation">(</span>num<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> num
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token function">triangleNum</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="汉诺塔问题" tabindex="-1"><a class="header-anchor" href="#汉诺塔问题" aria-hidden="true">#</a> 汉诺塔问题</h2><p>汉诺塔是一种游戏，有三个柱子，其中一棵柱子上面有若干个半径依次递减的空心圆盘，每次只能移动最顶端的圆盘，并且下面的圆盘要比上面的圆盘直径大。游戏的目的就是在满足这些条件的前提下，将所有圆盘依次转移到另外一个圆盘上面。</p><figure><img src="https://jixiaoyong.github.io/images/20190102201005.png" alt="汉诺塔问题分析" tabindex="0" loading="lazy"><figcaption>汉诺塔问题分析</figcaption></figure><p>如图，实现的思路就是递归：</p><ol><li><p>将除最底部的圆盘<code>bottom</code>之外的所有圆盘当做一个整体<code>other</code>，那么问题就变成了如何将<code>bottom</code>和<code>other</code>这“两”个圆盘通过<code>柱子B</code>，移动到<code>柱子C</code>，这个问题显然很好解决，只需要将<code>other</code>移动到<code>柱子B</code>，再将<code>bottom</code>移动到<code>柱子C</code>即可。</p></li><li><p>那么剩下的问题就成了如何将<code>other</code>从<code>柱子A</code>移动到<code>柱子B</code>，很显然可以参照<code>步骤1</code>。</p></li><li><p>这样子这个问题就成了如何将一个<code>bottom</code>从一个柱子，移动到另外一个柱子的问题，而每个这样的问题的解决都依赖于<code>other</code>的解决，而这就是递归。</p></li></ol><p>具体实现：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">/**
 * 汉诺塔问题
 * 将汉诺塔问题简化为 3 步：
 * 1/3 将最上层 n-1 项移动到过渡层
 * 2/3 将最底层 n 移动到目标层
 * 3/3 将 n-1 项移动到目标层
 * @param num 要移动的层数
 * @param from 所在层
 * @param inter 过渡层
 * @param to 目标层
 */</span>
<span class="token keyword">var</span> hanioStepNum <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">fun</span> <span class="token function">hanioTower</span><span class="token punctuation">(</span>num<span class="token operator">:</span> Int<span class="token punctuation">,</span> from<span class="token operator">:</span> String<span class="token punctuation">,</span> inter<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;move 1 to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression"><span class="token keyword">to</span></span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
        hanioStepNum<span class="token operator">++</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">hanioTower</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">,</span> inter<span class="token punctuation">)</span><span class="token comment">//把\`other\`移动到中间柱子</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;move </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">num</span></span><span class="token string"> to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression"><span class="token keyword">to</span></span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token comment">//把\`bottom\`移动到目标柱子</span>
        hanioStepNum<span class="token operator">++</span>
        <span class="token function">hanioTower</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> inter<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token comment">//把\`other\`移动到目标柱子</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h2>`,18),u=n("p",null,[s("归并排序"),n("code",null,"merge"),s("，将一个数组，分成两个子数组分别排序，之后再将拍好序的数组合并，这样就得到了一个有序数组。时间复杂度是"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"N"),n("mo",null,"∗"),n("mi",null,"L"),n("mi",null,"o"),n("mi",null,"g"),n("mo",{stretchy:"false"},"("),n("mi",null,"N"),n("mo",{stretchy:"false"},")"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(N*Log(N))")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"∗"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"L"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),n("span",{class:"mclose"},"))")])])]),s("。")],-1),d=t(`<p>其思路是，将数组无限的分成两份分别进行排序，然后再将排好序的两个数组归并在一起得到有序数组。每个子数组的有序都依赖于其子数组的有序，直到每个子数组只有一个元素，这样的数组本身就是有序的。</p><p>原理如下（假设序列共有 n 个元素）：</p><ol><li>将序列每相邻两个数字进行<strong>归并操作</strong>，形成两个<code>n/2</code>序列，排序后每个序列包含 1/2 元素</li><li>若此时序列数不是 1 个，则将上述序列再次归并，分别形成两个<code>n/4</code>序列，每个序列包含 1/4 个元素</li><li>重复步骤 2，直到所有元素排序完毕，即序列数为 1</li></ol><figure><img src="https://zh.wikipedia.org/wiki/File:Merge-sort-example-300px.gif" alt="归并排序动态演示" tabindex="0" loading="lazy"><figcaption>归并排序动态演示</figcaption></figure><p><strong>合并两个有序的数组 (<code>a</code>,<code>b</code>) 思想</strong>：</p><p>将<code>b</code>中比<code>a</code>中小的元素都复制到<code>a</code>中对应位置，然后将剩下的元素全部依次复制到<code>a</code>的末尾。</p><p>归并排序具体实现：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">/**
 * 归并排序
 * 归并排序占空间（多占一个排序数组的大小），排序快（N*LogN）
 * 思想是：
 * 1/2 将数组无限分成两份，直到两份数组都是有序的（每个数组只有一个元素）
 * 2/2 再对其进行归并
 * 小 -&gt; 大
 * @param intArr 待排序的数组
 */</span>
<span class="token keyword">fun</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>intArr<span class="token operator">:</span> IntArray<span class="token punctuation">)</span><span class="token operator">:</span> IntArray <span class="token punctuation">{</span>
    <span class="token keyword">var</span> size <span class="token operator">=</span> intArr<span class="token punctuation">.</span>size
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> intArr
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> half <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            half <span class="token operator">=</span> size <span class="token operator">/</span> <span class="token number">2</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            half <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">var</span> arr1 <span class="token operator">=</span> intArr<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> half<span class="token punctuation">)</span>
        <span class="token keyword">val</span> arr2 <span class="token operator">=</span> intArr<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>half<span class="token punctuation">,</span> intArr<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//将合并好的两个有序子数组合并</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 归并
 * 合并两个有序的数组为新的有序数组
 * 思想：
 * 1/2 相互比较两个数组每项大小，并将小的复制到新数组
 * 2/2 将剩余的数组全部复制到新数组
 * 小 -&gt; 大
 * @param intArrA 有序数组 1
 * @param intArrB 有序数组 2
 */</span>
<span class="token keyword">fun</span> <span class="token function">merge</span><span class="token punctuation">(</span>intArrA<span class="token operator">:</span> IntArray<span class="token punctuation">,</span> intArrB<span class="token operator">:</span> IntArray<span class="token punctuation">)</span><span class="token operator">:</span> IntArray <span class="token punctuation">{</span>
    <span class="token keyword">var</span> resultArr <span class="token operator">=</span> <span class="token function">IntArray</span><span class="token punctuation">(</span>intArrA<span class="token punctuation">.</span>size <span class="token operator">+</span> intArrB<span class="token punctuation">.</span>size<span class="token punctuation">)</span>

    <span class="token keyword">var</span> indexA <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> indexB <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> indexC <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>indexA <span class="token operator">&lt;</span> intArrA<span class="token punctuation">.</span>size <span class="token operator">&amp;&amp;</span> indexB <span class="token operator">&lt;</span> intArrB<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>intArrA<span class="token punctuation">[</span>indexA<span class="token punctuation">]</span> <span class="token operator">&lt;</span> intArrB<span class="token punctuation">[</span>indexB<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            resultArr<span class="token punctuation">[</span>indexC<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> intArrA<span class="token punctuation">[</span>indexA<span class="token operator">++</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            resultArr<span class="token punctuation">[</span>indexC<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> intArrB<span class="token punctuation">[</span>indexB<span class="token operator">++</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>indexA <span class="token operator">&lt;</span> intArrA<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resultArr<span class="token punctuation">[</span>indexC<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> intArrA<span class="token punctuation">[</span>indexA<span class="token operator">++</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>indexB <span class="token operator">&lt;</span> intArrB<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resultArr<span class="token punctuation">[</span>indexC<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> intArrB<span class="token punctuation">[</span>indexB<span class="token operator">++</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> resultArr
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="源码" tabindex="-1"><a class="header-anchor" href="#源码" aria-hidden="true">#</a> 源码</h2>`,9),k={href:"https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/link/Triangle.kt",target:"_blank",rel:"noopener noreferrer"},m=n("code",null,"汉诺塔",-1),v=n("code",null,"递归排序",-1),b=n("h2",{id:"参考资料",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),s(" 参考资料")],-1),h={href:"https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"};function g(f,y){const a=o("ExternalLinkIcon");return i(),c("div",null,[r,u,d,n("p",null,[s("👉"),n("a",k,[s("点这里"),e(a)]),s(" 查看"),m,s("和"),v,s("源码")]),b,n("p",null,[n("a",h,[s("归并排序——维基百科"),e(a)])])])}const w=p(l,[["render",g],["__file","466fbe25.html.vue"]]);export{w as default};
