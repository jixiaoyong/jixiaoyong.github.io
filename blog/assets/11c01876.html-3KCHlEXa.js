import{_ as p,c as l,a as n,d as t,e as s,b as i,w as o,r,o as m}from"./app-3cnvzyR2.js";const g={};function c(d,a){const e=r("font");return m(),l("div",null,[a[13]||(a[13]=n('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p><p>红黑树必须满足以下条件：</p><ol><li><p>必须有颜色（黑/红）</p></li><li><p>根节点颜色为黑</p></li><li><p>若节点是红色，则子节点必须是黑色（反之则不然）</p></li><li><p>到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色）</p></li></ol><p>如果不满足可以通过以下方式修正：</p><ul><li>改变节点颜色</li><li>旋转（左、右）</li></ul><h2 id="旋转" tabindex="-1"><a class="header-anchor" href="#旋转"><span>旋转</span></a></h2><p>以某个支点旋转（右旋为例，旋转时注意更新各个节点的父节点）：</p><p>本质是将该<code>节点a</code>向下进一位插入到其<code>右节点b</code>原先的位置，将其<code>左节点c</code>向上进一位插入到该<code>节点a</code>原先的位置，并将<code>左节点c的右节点</code>赋值给该<code>节点a</code>。</p><p>步骤：</p><ol><li><p>将该<code>节点a</code>放到<code>右节点b</code>的位置，将该``左节点 c<code>放到</code>节点 a`原先的位置，依次类推</p></li><li><p>特殊的，将该<code>点a的内侧孙子</code>（<code>a的左子节点c</code>的<code>右子节点d</code>）断开与其<code>父节点c</code>的连接，转而连接到<code>a</code>上，成为<code>a的左子节点</code></p></li></ol><p>如图，依次插入<code>6,34,23</code>，<strong>以<code>34</code>为支点右旋</strong>：</p><img src="https://jixiaoyong.github.io/images/20181223175956.png" width="50%" height="50%">',13)),t("p",null,[a[2]||(a[2]=s("对获得的结果，由于")),i(e,{color:"#ff0000"},{default:o(()=>a[0]||(a[0]=[s("23")])),_:1}),a[3]||(a[3]=s("，")),i(e,{color:"#ff0000"},{default:o(()=>a[1]||(a[1]=[s("34")])),_:1}),a[4]||(a[4]=s("都是红色违反了")),a[5]||(a[5]=t("code",null,"规则3",-1)),a[6]||(a[6]=s("，将")),a[7]||(a[7]=t("code",null,"34的父节点23",-1)),a[8]||(a[8]=s("设置黑，")),a[9]||(a[9]=t("code",null,"祖父节点6",-1)),a[10]||(a[10]=s("设为红，")),a[11]||(a[11]=t("strong",null,[s("以"),t("code",null,"祖父节6"),s("点为支点左旋")],-1)),a[12]||(a[12]=s("："))]),a[14]||(a[14]=n('<figure><img src="https://jixiaoyong.github.io/images/20181223180637.png" alt="最终结果" tabindex="0" loading="lazy"><figcaption>最终结果</figcaption></figure><h2 id="插入" tabindex="-1"><a class="header-anchor" href="#插入"><span>插入</span></a></h2><p>每次插入红色节点，能够避免规则 4。</p><p>一般先以二叉搜索树的规则将数据插入表中，然后再对照规则检查是否需要调整红黑树。</p><p>红黑树插入情况分类如下：</p><ol><li>插入位置为根节点，将节点颜色更改为黑色</li><li>插入位置的父节点为根节点或父节点颜色为黑色，直接插入</li><li>父节点为红色。</li></ol><p>只有父节点为红色这种情况需要进行修正，这时又可以细分为以下三种情况：</p><figure><img src="https://jixiaoyong.github.io/images/20181223182532.jpg" alt="表格来自 http://www.cnblogs.com/skywang12345/p/3245399.html#a1" tabindex="0" loading="lazy"><figcaption>表格来自 <a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a1" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/skywang12345/p/3245399.html#a1</a></figcaption></figure><p>【注意】对于<code>Case 3</code>当祖父节点没有<strong>左节点</strong>无法右旋时的特殊处理：</p><p>需要对先对当前节点的父节点进行右旋，再以父节点作为<strong>新插入的点 N</strong>，将 N 的父节点设置为黑色，祖父节点设置为红色，以祖父节点为支点左旋。</p><p>如依次插入如下值：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>32,3,53,13,983,[137],237,83,483,43,183</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当插入<code>137</code>后红黑树如图：</p><figure><img src="https://jixiaoyong.github.io/images/20181223210305.png" alt="插入 137 后的树" tabindex="0" loading="lazy"><figcaption>插入 137 后的树</figcaption></figure><p>本来按照<code>Case 3 父红 叔黑 是左节点 </code> 应该要以祖节点右旋，但是组节点 53 没有左子节点，无法右旋，所以先对父节点 983 进行右旋：</p><figure><img src="https://jixiaoyong.github.io/images/20181223210800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>再以<code>983</code>为新节点，<code>父红 叔黑 是右节点</code>，将<code>父节点137</code>设置为黑色，<code>祖节点53</code>设置为红色，以<code>组节点53</code>为支点左旋：</p><figure><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h2><p>删除比较复杂，可以有两种操作：</p><ol><li>在节点中保存一个标志位，标记该节点是否被删除，并不针真的删除该点。</li><li>在执行删除操作时真正删除该点。</li></ol><h2 id="源码" tabindex="-1"><a class="header-anchor" href="#源码"><span>源码</span></a></h2><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/RedBlackTree.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a>查看源码</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2><p><a href="https://sandbox.runjs.cn/show/2nngvn8w" target="_blank" rel="noopener noreferrer">在线操作红黑树</a></p><p><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a1" target="_blank" rel="noopener noreferrer">红黑树 (一) 之 原理和算法详细介绍</a></p>',26))])}const u=p(g,[["render",c]]),y=JSON.parse('{"path":"/posts/11c01876.html","title":"数据结构_红黑树","lang":"zh-CN","frontmatter":{"permalink":"/posts/11c01876.html","title":"数据结构_红黑树","tag":"数据结构","abbrlink":"11c01876","date":"2018-12-23T09:25:36.000Z","updated":"2023-12-30T08:17:02.000Z","isOriginal":true,"description":"前言 红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为O(log2​N)。 红黑树必须满足以下条件： 必须有颜色（黑/红） 根节点颜色为黑 若节点是红色，则子节点必须是黑色（反之则不然） 到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色） 如果不满足可以通过以下方式修正： 改变节点颜色...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/11c01876.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"数据结构_红黑树"}],["meta",{"property":"og:description","content":"前言 红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为O(log2​N)。 红黑树必须满足以下条件： 必须有颜色（黑/红） 根节点颜色为黑 若节点是红色，则子节点必须是黑色（反之则不然） 到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色） 如果不满足可以通过以下方式修正： 改变节点颜色..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jixiaoyong.github.io/images/20181223180637.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T16:00:22.000Z"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2018-12-23T09:25:36.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T16:00:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构_红黑树\\",\\"image\\":[\\"https://jixiaoyong.github.io/images/20181223180637.png\\",\\"https://jixiaoyong.github.io/images/20181223182532.jpg\\",\\"https://jixiaoyong.github.io/images/20181223210305.png\\",\\"https://jixiaoyong.github.io/images/20181223210800.png\\",\\"https://jixiaoyong.github.io/images/20181223211217.png\\"],\\"datePublished\\":\\"2018-12-23T09:25:36.000Z\\",\\"dateModified\\":\\"2024-05-31T16:00:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"git":{"createdTime":1653726847000,"updatedTime":1717171222000,"contributors":[{"name":"jixiaoyong","username":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":5,"url":"https://github.com/jixiaoyong"},{"name":"JI,XIAOYONG","username":"","email":"jixiaoyong1995@gmail.com","commits":1}]},"readingTime":{"minutes":3.21,"words":962},"filePathRelative":"_posts/数据结构_红黑树.md","localizedDate":"2018年12月23日","excerpt":"<h2>前言</h2>\\n<p>红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为<span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>O</mi><mo stretchy=\\"false\\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">O(log_2N)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.02778em;\\">O</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.01968em;\\">l</span><span class=\\"mord mathnormal\\">o</span><span class=\\"mord\\"><span class=\\"mord mathnormal\\" style=\\"margin-right:0.03588em;\\">g</span><span class=\\"msupsub\\"><span class=\\"vlist-t vlist-t2\\"><span class=\\"vlist-r\\"><span class=\\"vlist\\" style=\\"height:0.3011em;\\"><span style=\\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\\"><span class=\\"pstrut\\" style=\\"height:2.7em;\\"></span><span class=\\"sizing reset-size6 size3 mtight\\"><span class=\\"mord mtight\\">2</span></span></span></span><span class=\\"vlist-s\\">​</span></span><span class=\\"vlist-r\\"><span class=\\"vlist\\" style=\\"height:0.15em;\\"><span></span></span></span></span></span></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.10903em;\\">N</span><span class=\\"mclose\\">)</span></span></span></span>。</p>","autoDesc":true}');export{u as comp,y as data};
