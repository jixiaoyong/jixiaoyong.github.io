import{_ as i,c as e,o as t,a as s}from"./app-B34IKLrY.js";const a={},d=s(`<p><code>Xfermode</code>是 Android 中用来指示<code>Paint</code>绘制的内容与 View 中已有内容的混合计算方式，也就是用来确定图形绘制到目标图形的时候，如何处理两个图形重合部分的颜色变化。共 18 个，分为 Alpha 合成和混合两种。</p><p>设要绘制的图形为<code>src</code>，已经绘制好的图形为<code>dst</code>。</p><blockquote><p>需要注意的是，这些图片除了要绘制的图形有着色之外，其他部分要为透明，并且<strong>包括透明区域在内的图片大小（宽高）要能完全覆盖另外一张图片的图形区域</strong>，否则绘制出的图形可能与预设的效果不一致</p></blockquote><p>按照官方的定义，不同<code>Xfermode</code>绘制结果如下：</p><figure><img src="https://jixiaoyong.github.io/images/20200415211144.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h2><p>要实现如上效果，需要注意：</p><ul><li><p><code>src</code>和<code>dst</code>符合要求（要有合适的透明区域）</p><p>这是因为<code>xfermode</code>的效果，使用透明部分的像素与已有图形对应位置交叉作用，得出所需要的效果，如果透明区域过小，则无法作用到对应的图形。下面这个来自 <a href="http://Hencoder.com" target="_blank" rel="noopener noreferrer">Hencoder.com</a> 的图可以很形象的解释：</p><figure><img src="https://jixiaoyong.github.io/images/20200416213802.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>在新的图层绘制（在新的图层按照<code>xfermode</code>规则绘制，然后再将其绘制到原有图层）：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//新建图层</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> saveCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">saveLayer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0F</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0F</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,width.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(),height.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,Canvas.ALL_SAVE_FLAG)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//dst  已经绘制的图形  ;  src 我们要绘制的图形</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">drawBitmap</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(dst,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0F</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0F</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, dstPaint)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">srcPaint.xfermode </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> PorterDuffXfermode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(PorterDuff.Mode.SRC_OUT)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">drawBitmap</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(src,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0F</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0F</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, srcPaint)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">srcPaint.xfermode </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//将新图层绘制到原有图层上</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">restoreToCount</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(saveCount)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>关闭硬件加速（可选）</p><p>硬件加速的本质是把一部分 CPU 计算的工作量交给 GPU 完成，可以加速绘制速度。</p><p>但是由于硬件加速不支持<code>canvas.drawXXX()</code>的部分方法，为了避免在某些机型上面无法使用这些方法，可以关闭硬件加速：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setLayerType</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(LAYER_TYPE_SOFTWARE, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>关于硬件加速更详细的说明可以参考这里：<a href="https://hencoder.com/ui-1-8/" target="_blank" rel="noopener noreferrer">HenCoder Android 自定义 View 1-8 硬件加速</a></p></li></ul><h2 id="xfermode-分类" tabindex="-1"><a class="header-anchor" href="#xfermode-分类"><span>Xfermode 分类</span></a></h2><p><a href="https://hencoder.com/ui-1-2/" target="_blank" rel="noopener noreferrer">HenCoder.com</a>关于<code>PorterDuff.Mode.DST_IN</code>的动画解释：</p><figure><img src="https://jixiaoyong.github.io/images/20200416214402.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看出，<code>Xfermode</code>的本质是处理<code>dst</code>与<code>src</code><strong>重合与未重合部分</strong>的展示与否，以及颜色变化。</p><blockquote><p>这里的“重合部分”与“未重合部分”，其实也包括了各个图形的透明部分，将<code>dst</code>与<code>src</code>的透明与不透明颜色相互作用，才会出现下述效果。</p></blockquote><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td><code>CLEAR</code></td><td>清除所有内容</td></tr><tr><td><code>DST</code></td><td>只绘制<code>DST</code></td></tr><tr><td><code>DST_ATOP</code></td><td>先绘制<code>SRC</code>，再在顶部绘制<code>DST</code>与<code>SRC</code>重合的部分</td></tr><tr><td><code>DST_IN</code></td><td>只绘制<code>DST</code>与<code>SRC</code>重合部分</td></tr><tr><td><code>DST_OUT</code></td><td>只绘制<code>DST</code>与<code>SRC</code>未重合部分</td></tr><tr><td><code>DST_OVER</code></td><td>将<code>DST</code>绘制在<code>SRC</code>上面</td></tr><tr><td><code>SRC</code></td><td>只绘制<code>SRC</code></td></tr><tr><td><code>SRC_ATOP</code></td><td>先绘制<code>DST</code>，再在顶部绘制<code>SRC</code>与<code>DST</code>重合的部分</td></tr><tr><td><code>SRC_IN</code></td><td>只绘制<code>SRC</code>与<code>DST</code>重合部分</td></tr><tr><td><code>SRC_OUT</code></td><td>只绘制<code>SRC</code>与<code>DST</code>未重合部分</td></tr><tr><td><code>SRC_OVER</code></td><td>将<code>SRC</code>绘制在<code>DST</code>上面</td></tr><tr><td></td><td></td></tr><tr><td><code>XOR</code></td><td></td></tr><tr><td><code>ADD</code></td><td></td></tr><tr><td><code>DARKEN</code></td><td></td></tr><tr><td><code>LIGHTEN</code></td><td></td></tr><tr><td><code>MULTIPLY</code></td><td></td></tr><tr><td><code>OVERLAY</code></td><td></td></tr><tr><td><code>SCREEN</code></td><td></td></tr></tbody></table><p>各个效果如下 (源码及使用见<a href="https://github.com/jixiaoyong/library/commit/71864b6546460acfaae6299890a0cf76da76b7d7" target="_blank" rel="noopener noreferrer">github</a>)：</p><figure><img src="https://jixiaoyong.github.io/images/20200415211144.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h2><p><a href="https://hencoder.com/ui-1-2/" target="_blank" rel="noopener noreferrer">HenCoder Android 开发进阶：自定义 View 1-2 Paint 详解</a></p><p><a href="https://hencoder.com/ui-1-8/" target="_blank" rel="noopener noreferrer">HenCoder Android 自定义 View 1-8 硬件加速</a></p><p><a href="https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode.html" target="_blank" rel="noopener noreferrer">PorterDuff.Mode</a></p>`,20),n=[d];function o(r,l){return t(),e("div",null,n)}const c=i(a,[["render",o],["__file","104c9058.html.vue"]]),p=JSON.parse('{"path":"/posts/104c9058.html","title":"Android 笔记之 Xfermode","lang":"zh-CN","frontmatter":{"permalink":"/posts/104c9058.html","title":"Android 笔记之 Xfermode","tag":"android","abbrlink":"104c9058","date":"2020-04-15T06:05:03.000Z","updated":"2023-12-30T08:17:02.000Z","isOriginal":true,"description":"Xfermode是 Android 中用来指示Paint绘制的内容与 View 中已有内容的混合计算方式，也就是用来确定图形绘制到目标图形的时候，如何处理两个图形重合部分的颜色变化。共 18 个，分为 Alpha 合成和混合两种。 设要绘制的图形为src，已经绘制好的图形为dst。 需要注意的是，这些图片除了要绘制的图形有着色之外，其他部分要为透明，并...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/104c9058.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"Android 笔记之 Xfermode"}],["meta",{"property":"og:description","content":"Xfermode是 Android 中用来指示Paint绘制的内容与 View 中已有内容的混合计算方式，也就是用来确定图形绘制到目标图形的时候，如何处理两个图形重合部分的颜色变化。共 18 个，分为 Alpha 合成和混合两种。 设要绘制的图形为src，已经绘制好的图形为dst。 需要注意的是，这些图片除了要绘制的图形有着色之外，其他部分要为透明，并..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jixiaoyong.github.io/images/20200415211144.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T16:00:22.000Z"}],["meta",{"property":"article:author","content":"JI,XIAOYONG"}],["meta",{"property":"article:tag","content":"android"}],["meta",{"property":"article:published_time","content":"2020-04-15T06:05:03.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T16:00:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Android 笔记之 Xfermode\\",\\"image\\":[\\"https://jixiaoyong.github.io/images/20200415211144.png\\",\\"https://jixiaoyong.github.io/images/20200416213802.jpg\\",\\"https://jixiaoyong.github.io/images/20200416214402.gif\\",\\"https://jixiaoyong.github.io/images/20200415211144.png\\"],\\"datePublished\\":\\"2020-04-15T06:05:03.000Z\\",\\"dateModified\\":\\"2024-05-31T16:00:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]},{"level":2,"title":"Xfermode 分类","slug":"xfermode-分类","link":"#xfermode-分类","children":[]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"git":{"createdTime":1653726847000,"updatedTime":1717171222000,"contributors":[{"name":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":3},{"name":"JI,XIAOYONG","email":"jixiaoyong1995@gmail.com","commits":1}]},"readingTime":{"minutes":2.8,"words":841},"filePathRelative":"_posts/Android笔记之Xfermode.md","localizedDate":"2020年4月15日","excerpt":"<p><code>Xfermode</code>是 Android 中用来指示<code>Paint</code>绘制的内容与 View 中已有内容的混合计算方式，也就是用来确定图形绘制到目标图形的时候，如何处理两个图形重合部分的颜色变化。共 18 个，分为 Alpha 合成和混合两种。</p>\\n<p>设要绘制的图形为<code>src</code>，已经绘制好的图形为<code>dst</code>。</p>\\n<blockquote>\\n<p>需要注意的是，这些图片除了要绘制的图形有着色之外，其他部分要为透明，并且<strong>包括透明区域在内的图片大小（宽高）要能完全覆盖另外一张图片的图形区域</strong>，否则绘制出的图形可能与预设的效果不一致</p>\\n</blockquote>","autoDesc":true}');export{c as comp,p as data};
