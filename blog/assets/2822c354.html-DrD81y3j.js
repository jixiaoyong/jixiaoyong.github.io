import{_ as t,r as h,c as d,e as a,w as l,a as e,o as p,d as s,b as i}from"./app-D5kxjk1C.js";const k={},r=e(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p><code>Dagger 2</code>是 Google 维护的一款可用于<code>Java</code>和<code>Android</code>的依赖注入框架。</p><p>本文主要是简单梳理<code>Dagger 2</code>中各个注解的作用，以及其简单用法，不涉及具体项目应用。</p><p>先解释几个概念：</p><ul><li><p><strong><code>依赖注入</code></strong>：是一个对象（或静态方法）给另一个对象提供依赖的技术。</p></li><li><p>**<code>依赖</code>**是可以使用的对象（<code>Service</code>），而把依赖提供给使用该依赖的对象（<code>Client</code>）的过程叫做<code>注入</code>。</p></li></ul><p>例如，下面这段代码中<code>Service</code>就是<code>Client</code>的依赖。：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Service</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Client</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> service </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是如果每个依赖都这样写的话，如果<code>Service</code>类的构造方法有变更，就需要同时也更改<code>Client</code>对应的方法，这样深耦合的代码显然不是我们需要的。</p><p><code>Dagger 2 </code>就是为了帮助我们解决这个问题，在使用它之后，<code>Client</code>类的代码只需要这样写成类似下面这样（示例代码）：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Client</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    lateinit</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Service</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //TODO 某个将 Service 依赖注入的方法 magicFun()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> newService </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> service</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//使用 Service 的实例 service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，这时<code>Service</code>的实例化过程被移到了<code>Client</code>的外部某处，这样如果<code>Service</code>构造方法有更新时，我们只需要统一去修改<code>magicFun()</code>中对应的代码即可。</p><p>那么这一切<code>Dagger 2</code>到底是如何实现的呢？</p><h2 id="dagger-2-具体实现" tabindex="-1"><a class="header-anchor" href="#dagger-2-具体实现"><span>Dagger 2 具体实现</span></a></h2><h3 id="inject" tabindex="-1"><a class="header-anchor" href="#inject"><span>@Inject</span></a></h3><p>首先需要请出第一个主角——<strong><code>@Inject</code></strong>。</p><p>在<code>Dagger 2</code>中，<code>@Inject</code>主要做两件事 ❶ 标记依赖类的构造方法；❷ 标记需要框架自动实例化的对象：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> @Inject</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//❶标记依赖类的构造方法</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Client</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Inject</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    lateinit</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Service</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//❷标记需要框架自动实例化的对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">	..</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样<code>Dagger 2 </code>就知道了有个对象需要它来帮助我们注入，同时也知道了有一个构造方法来实例化<code>Service</code>对象。但这时如何将二者联系起来呢？</p><h3 id="component" tabindex="-1"><a class="header-anchor" href="#component"><span>@Component</span></a></h3><p>这就要提到第二个主角——<strong><code>@Component</code></strong>。</p><p><code>@Component</code>标记的类是将一个类和他的依赖联系在一起的桥梁，通常是一个<strong>抽象类或者接口</strong>：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Component</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClientComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(client: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Client</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，<code>Client</code>和<code>Service</code>通过<code>ClientComponent</code>联系在一起，在使用时只需要将<code>Client</code>的引用传入即可：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //方式❶ DaggerClientComponent.create().inject(this)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //方式❷ DaggerClientComponent.builder().build().inject(this)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> newService </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> service</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上完整的代码可以参考这里，<a href="https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8#file-dagger2_basic_guide_line_part1-kt" target="_blank" rel="noopener noreferrer">若无法显示可点击这里查看</a>：</p><p>到目前为止，对于我们自己定义的类，我们只需要使用<code>@Inject</code>标记其构造方法，然后再在使用该类的时候使用<code>@Inject</code>标记该对象，在需要使用该对象的地方通过<code>@Component</code>类传入使用该依赖的类的引用即可。</p>`,26),o=i("img",{style:{"border-radius":"0.3125em","box-shadow":"0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08)"},src:"https://jixiaoyong.github.io/images/20190126184230.png"},null,-1),c=i("br",null,null,-1),g=i("div",{style:{color:"#999","border-bottom":"1px solid #d9d9d9",display:"inline-block",padding:"2px"}},"@Component 自动实现依赖注入的示意图",-1),u=e(`<p>但是很显然实际开发中，不是所有的<code>Service</code>类都可以被我们随意修改，如果<code>Service</code>类是第三方提供的类，显然我们是无法用<code>@Inject</code>修饰其构造函数的。</p><h3 id="module-和-provides" tabindex="-1"><a class="header-anchor" href="#module-和-provides"><span>@Module 和@Provides</span></a></h3><p>为了解决第三方依赖的问题，我们要引入另外两个主角——<strong><code>@Module</code><strong>和</strong><code>@Provides</code></strong>。</p><p><code>@Provides</code>用来提供一个方法，我们可以在其内部实例化并返回<code>Service</code>类，这样子当用到<code>Service</code>的时候，<code>@Component</code>类只需要找到<code>@Provides</code>提供的这个方法，并获取到他实例化好的<code>Service</code>对象注入到<code>Client</code>中就可以了。</p><p><code>@Module</code>则是提供一个<strong>类</strong>（注意是类，而非接口），像一个袋子一样把<code>@Provides</code>提供的方法“装”到一起，打包提供给<code>@Component</code>类。</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Module</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClientModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Provides</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getService</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Component</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(modules </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [ClientModule::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">])</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//Component 可以有多个 Module 类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClientComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(client: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Client</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的<code>@Component(modules = [ClientModule::class])</code>将装有可以产生依赖的<code>@Provides</code>方法的“大袋子”<code>@Module</code>和“桥梁”<code>@Component</code>关联到了一起。</p><p><code>@Component</code>在产生依赖的时候会先到<code>@Module</code>类中的<code>@Provides</code>方法中查找；如果找不到才会再到<code>@Inject</code>中查找。（也就是说，此时<code>Service</code>类的<code>@Inject</code>构造方法其实是失效了的，完全可以没有<code>@Inject</code>注解——第三方类即是如此）。</p><p>上述完整代码如下，<a href="https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb" target="_blank" rel="noopener noreferrer">若无法显示可点击这里查看</a>：</p><p>解决了第三方依赖引用的问题，还有一个非常重要的问题——我们使用的绝大多数类肯定不止一个构造方法，那么假设依赖类<code>Service</code>现在有两个构造方法，我们需要分别这两个构造方法，这种情况又该怎么处理呢？</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> @Inject</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> string: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>很明显，这时候<code>@Inject</code>注解已经没用了，一个类只能有一个构造方法被<code>@Inject</code>修饰，否则会报错：<code>错误: Types may only contain one @Inject constructor</code>。</p><p>去掉<code>@Inject</code>后<code>Service</code>类变成如下：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> string: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;default&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>尝试在<code>@Module</code>中添加另外一个<code>@Provides</code>方法使用另外一个带参构造函数：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Module</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClientModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Provides</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getService</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Provides</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getServiceWithArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Args&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行时发现会出错，因为有两个方法都可以提供<code>Service</code>，<code>@Component</code>产生了迷失，不知道用哪一个好，导致错误。</p><h3 id="named-和-qualifier" tabindex="-1"><a class="header-anchor" href="#named-和-qualifier"><span>@Named 和@Qualifier</span></a></h3><p>为了解决多个构造函数导致的问题，这时就需要第五个主角**<code>@Named</code><strong>以及幕后英雄</strong><code>@Qualifier</code>**</p><p>首先，上述问题的解决方案是在另外一个方法上加一个注解<code>@Named</code>，表示他是一个特殊的方法：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Provides</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> @Named</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Args&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getServiceWithArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Args&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当在<code>Client</code>中想使用这个方法的依赖时：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //@field:是 kotlin 中注解字段特别需要的，在 Java 中可以直接写成@Named(&quot;Args&quot;)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Inject</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @field</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Named</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&quot;)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    lateinit</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> service: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Service</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看<code>@Named</code>源码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Qualifier</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Documented</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> Named</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    /** The name. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">default</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发现<code>@Qualifier</code>才是他实现标识限定符注解（Identifies qualifier annotations）的力量之源。查看<code>@Qualifier</code>注解可以知道，我们也可以自定义基于<code>@Qualifier</code>的注解来实现和<code>@Named</code>完全一致的功能。</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Qualifier</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@MustBeDocumented</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@kotlin.annotation.Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(AnnotationRetention.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">annotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> YourQualifierName</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//YourQualifierName 可以是任意你喜欢的名字</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    /** The name.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    val</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后我们就可以使用<code>@YourQualifierName</code>替代<code>@Named</code>实现标识不同注解的作用，从而支持有多个构造函数的<code>Service</code>类的初始化。</p><p>上述完整代码如下，<a href="https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a" target="_blank" rel="noopener noreferrer">若无法显示可点击这里查看</a>：：</p><p><code>@Component</code>可以有多个<code>@Module</code>，他们之间的关系可以用下图表示：</p>`,30),v=i("img",{style:{"border-radius":"0.3125em","box-shadow":"0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08)"},src:"https://jixiaoyong.github.io/images/20190126201436.png"},null,-1),y=i("br",null,null,-1),B=i("div",{style:{color:"#999","border-bottom":"1px solid #d9d9d9",display:"inline-block",padding:"2px"}},"@Component 会先到他拥有的多个@Module 中去查找 Service 类",-1),m=e(`<h3 id="singleton-和-scope" tabindex="-1"><a class="header-anchor" href="#singleton-和-scope"><span>@Singleton 和@Scope</span></a></h3><p>在实际开发中，我们需要有的类只能有一个实例，从而在不同的地方共享一些数据——即单例，这种情况就需要另外一个角色<code>@Singleton</code>和他的幕后英雄<code>@Scope</code>。</p><p>@Singleton 是用来标记类在其范围内只能被实例化一次。</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Scope</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Documented</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> @interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过查看其源码可以知道其背后是<code>@Scope</code>在起作用，<code>@Scope</code>的作用是限定其修饰的类的范围，适用于有可注入的构造函数并且包含控制类型实例如何重用的类。没有<code>@Scope</code>修饰的实例在构造完毕后就会失去控制，不再关心后续的发展（<em>then forgets it</em>），而<code>@Scope</code>修饰的类会在实例构造完毕后，继续保留一遍下一次可能的复用，当有多个线程可以访问该实例时，他的实现应该是线程安全的（<em>it‘s implementation should be thread safe</em>）。</p><p>此外<code>@Component</code>应该和他所包含的<code>@Module</code>的<code>@Provides</code>的<code>@Scope</code>范围一致：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Singleton</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Component</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(modules </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [ClientModule::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClientComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(client: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Client</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">@Module</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ClientModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Provides</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getService</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Singleton</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">    @Provides</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> @Choose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Args&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getServiceWithArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Args&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外两个关系为**<code>dependencies</code>**的<code>@Component</code>可以分别拥有相同名称的<code>@Inject</code>、<code>@Module</code>、<code>@Provides</code>而不会被<em>merge</em>，两者可以相互访问。</p><p>而**<code>subcomponents</code>**则不能和<code>@Component</code>有以上相同的项。</p><blockquote><p><code>Subcomponent</code>从它的父类访问所有依赖</p><p><code>@Component</code>只能访问在基类<code>@Component</code>接口暴露的公共性的依赖</p><p>——<a href="https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/" target="_blank" rel="noopener noreferrer">Subcomponents 和 Component Dependencies——Sinyuk Blog</a></p></blockquote><p>他们之间的关系可以表示为下图：</p>`,11),b=i("img",{style:{"border-radius":"0.3125em","box-shadow":"0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08)"},src:"https://jixiaoyong.github.io/images/20190127204658.png"},null,-1),C=i("br",null,null,-1),F=i("div",{style:{color:"#999","border-bottom":"1px solid #d9d9d9",display:"inline-block",padding:"2px"}},"@Subcomponent,@Component 之间的关系",-1),A=e('<h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://github.com/android-cn/blog/tree/master/java/dependency-injection" target="_blank" rel="noopener noreferrer">android-cn：依赖注入—— Github</a></p><p><a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener noreferrer">Dependency Injection ——wikipedia</a></p><p><a href="https://medium.com/@elye.project" target="_blank" rel="noopener noreferrer">Elye 的 Dagger 2 系列</a></p><p><a href="https://google.github.io/dagger/users-guide" target="_blank" rel="noopener noreferrer">Dagger 2 官方手册</a></p><p><a href="https://www.jianshu.com/p/2cd491f0da01" target="_blank" rel="noopener noreferrer">Android - Dagger2 使用详解——简书</a></p><p><a href="https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/" target="_blank" rel="noopener noreferrer">Subcomponents 和 Component Dependencies——Sinyuk Blog</a></p>',7);function E(D,f){const n=h("center");return p(),d("div",null,[r,a(n,null,{default:l(()=>[o,s(),c,s(),g]),_:1}),u,a(n,null,{default:l(()=>[v,s(),y,s(),B]),_:1}),m,a(n,null,{default:l(()=>[b,s(),C,s(),F]),_:1}),A])}const _=t(k,[["render",E],["__file","2822c354.html.vue"]]),x=JSON.parse('{"path":"/posts/2822c354.html","title":"Dagger 2 从 0 到 1 之旅","lang":"zh-CN","frontmatter":{"permalink":"/posts/2822c354.html","title":"Dagger 2 从 0 到 1 之旅","tag":"dagger2","abbrlink":"2822c354","date":"2019-01-26T07:16:17.000Z","updated":"2023-12-30T08:17:02.000Z","isOriginal":true,"description":"前言 Dagger 2是 Google 维护的一款可用于Java和Android的依赖注入框架。 本文主要是简单梳理Dagger 2中各个注解的作用，以及其简单用法，不涉及具体项目应用。 先解释几个概念： 依赖注入：是一个对象（或静态方法）给另一个对象提供依赖的技术。 **依赖**是可以使用的对象（Service），而把依赖提供给使用该依赖的对象（Cl...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/2822c354.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"Dagger 2 从 0 到 1 之旅"}],["meta",{"property":"og:description","content":"前言 Dagger 2是 Google 维护的一款可用于Java和Android的依赖注入框架。 本文主要是简单梳理Dagger 2中各个注解的作用，以及其简单用法，不涉及具体项目应用。 先解释几个概念： 依赖注入：是一个对象（或静态方法）给另一个对象提供依赖的技术。 **依赖**是可以使用的对象（Service），而把依赖提供给使用该依赖的对象（Cl..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T16:00:22.000Z"}],["meta",{"property":"article:author","content":"JI,XIAOYONG"}],["meta",{"property":"article:tag","content":"dagger2"}],["meta",{"property":"article:published_time","content":"2019-01-26T07:16:17.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T16:00:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dagger 2 从 0 到 1 之旅\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-01-26T07:16:17.000Z\\",\\"dateModified\\":\\"2024-05-31T16:00:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"Dagger 2 具体实现","slug":"dagger-2-具体实现","link":"#dagger-2-具体实现","children":[{"level":3,"title":"@Inject","slug":"inject","link":"#inject","children":[]},{"level":3,"title":"@Component","slug":"component","link":"#component","children":[]},{"level":3,"title":"@Module 和@Provides","slug":"module-和-provides","link":"#module-和-provides","children":[]},{"level":3,"title":"@Named 和@Qualifier","slug":"named-和-qualifier","link":"#named-和-qualifier","children":[]},{"level":3,"title":"@Singleton 和@Scope","slug":"singleton-和-scope","link":"#singleton-和-scope","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1653726847000,"updatedTime":1717171222000,"contributors":[{"name":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":3},{"name":"JI,XIAOYONG","email":"jixiaoyong1995@gmail.com","commits":1}]},"readingTime":{"minutes":7.7,"words":2310},"filePathRelative":"_posts/Dagger2从0到1之旅.md","localizedDate":"2019年1月26日","excerpt":"<h2>前言</h2>\\n<p><code>Dagger 2</code>是 Google 维护的一款可用于<code>Java</code>和<code>Android</code>的依赖注入框架。</p>\\n<p>本文主要是简单梳理<code>Dagger 2</code>中各个注解的作用，以及其简单用法，不涉及具体项目应用。</p>\\n<p>先解释几个概念：</p>\\n<ul>\\n<li>\\n<p><strong><code>依赖注入</code></strong>：是一个对象（或静态方法）给另一个对象提供依赖的技术。</p>\\n</li>\\n<li>\\n<p>**<code>依赖</code>**是可以使用的对象（<code>Service</code>），而把依赖提供给使用该依赖的对象（<code>Client</code>）的过程叫做<code>注入</code>。</p>\\n</li>\\n</ul>","autoDesc":true}');export{_ as comp,x as data};
