import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as i,a as n,b as s,d as p,e}from"./app-f2122104.js";const l={},u=e(`<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h1><p><strong>图</strong>，是由可以有多个边的顶点组成的结构。</p><p>两个顶点之间有边连接，则称这两个顶点是<strong>邻接</strong>的。</p><p>几个相互邻接的顶点组成的线叫做<strong>路径</strong>,至少有一条路径可以到达所有顶点的图叫做<strong>连通图</strong>。</p><p>如果图的顶点只能从 A→B，不能从 B→A，就称图是<strong>有向图</strong>。</p><p>如果边被赋予一定的权值（数字），就称图为<strong>带权图</strong></p><img width="30%" height="30%" src="https://jixiaoyong.github.io/images/20181227232301.png"><h1 id="存储方式" tabindex="-1"><a class="header-anchor" href="#存储方式" aria-hidden="true">#</a> 存储方式</h1><p>图一般有两种存储方式：</p><ul><li><p>邻接矩阵 用 N*N 的数组保存图中所有的顶点，<code>Arr[m][n]</code>即表示 m、n 顶点是否邻接（Y:1,N:0）。</p><p>比较占地方。</p><figure><img src="https://jixiaoyong.github.io/images/20181227233341.png" alt="邻接矩阵" tabindex="0" loading="lazy"><figcaption>邻接矩阵</figcaption></figure></li><li><p>邻接表 用一个 N 大小的数组保存，数组元素是保存着顶点和他所有的邻接点的链表。</p><figure><img src="https://jixiaoyong.github.io/images/20181227233435.png" alt="邻接表" tabindex="0" loading="lazy"><figcaption>邻接表</figcaption></figure></li></ul><h1 id="操作" tabindex="-1"><a class="header-anchor" href="#操作" aria-hidden="true">#</a> 操作</h1><p>图的操作有插入（顶点），搜索等等。</p><p>以下操作以邻接表方式为例。</p><h2 id="插入" tabindex="-1"><a class="header-anchor" href="#插入" aria-hidden="true">#</a> 插入</h2><p>插入分为插入顶点和插入边。</p><p>插入边的时候需要注意，要同时更新 start 和 end 两个顶点对应的链表。</p><h2 id="移除" tabindex="-1"><a class="header-anchor" href="#移除" aria-hidden="true">#</a> 移除</h2><p>原理同插入边。</p><h2 id="搜索" tabindex="-1"><a class="header-anchor" href="#搜索" aria-hidden="true">#</a> 搜索</h2><p>搜索要求从某个特定顶点开始，沿着边移动到其他顶点，移动完毕后要保证访问了每个顶点。</p><p>搜索又分为 DFS（深度优先搜索）、BFS（广度优先搜索）。</p><h3 id="dfs" tabindex="-1"><a class="header-anchor" href="#dfs" aria-hidden="true">#</a> DFS</h3><p>DFS 的思想是，依次沿着顶点某一个邻接点，纵深访问，将该邻接点当做新的顶点压入栈中，继续纵深访问，直到有顶点没有可以访问的邻接顶点，将其打印出来（从栈中推出）；然后再返回上一层的邻接顶点中还可以访问的顶点（查找当前栈顶元素未访问的邻接点），直到没有可以访问的顶点。</p><p>用栈实现，会先往深处遍历完一条路径，再遍历下一条。每个顶点只访问一次</p><p>规则：</p><ul><li><pre><code> 1/3 访问一个邻接的未访问顶点，访问并标记，将其压入栈中；
</code></pre></li><li><pre><code> 2/3 当规则 1 不能满足时，如果栈不为空，从栈中弹出一个顶点；
</code></pre></li><li><pre><code> 3/3 1,2 都无法满足时，搜索结束。
</code></pre></li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> stacks <span class="token operator">=</span> <span class="token function">DfsStacks</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
    <span class="token keyword">var</span> keyArr <span class="token operator">=</span> hashMap<span class="token punctuation">.</span>keys<span class="token punctuation">.</span><span class="token function">toIntArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    stacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    hashMap<span class="token punctuation">[</span>keyArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span>isVisited <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">var</span> index <span class="token operator">=</span> hashMap<span class="token punctuation">[</span>keyArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>stacks<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> availableKey <span class="token operator">=</span> <span class="token function">getAvailableNode</span><span class="token punctuation">(</span>index<span class="token operator">!!</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>availableKey <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            index <span class="token operator">=</span> hashMap<span class="token punctuation">[</span>availableKey<span class="token punctuation">]</span><span class="token comment">//深度优先搜索，会先顺着一个邻接点一直走到头</span>
            index<span class="token operator">!!</span><span class="token punctuation">.</span>isVisited <span class="token operator">=</span> <span class="token boolean">true</span>
            stacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>availableKey<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> pop <span class="token operator">=</span> stacks<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">pop</span></span><span class="token string"> &quot;</span></span><span class="token punctuation">)</span>
            index <span class="token operator">=</span> hashMap<span class="token punctuation">[</span>stacks<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment">//如果一个邻接点再没有未访问的邻接点，那么去访问下一个未访问的邻接点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="bfs" tabindex="-1"><a class="header-anchor" href="#bfs" aria-hidden="true">#</a> BFS</h3><p>BFS 的思想是，向将当前顶点的所有可以访问的邻接点访问完毕；之后将该顶点打印（推出），再去访问其邻接点的所有可以访问邻接点（从队列头取出一个顶点，查找其未访问的邻接点）。</p><p>用队列实现，会先遍历完本层所有的顶点，然后再移向下一层</p><p>规则：</p><ul><li><pre><code> 1/3 先访问当前顶点的所有邻接顶点，标记，并插入到队列；
</code></pre></li><li><pre><code> 2/3 如果没有可以访问的邻接点，且队列不为空，从队列头取出一个顶点[此处又用到了一次该点]，使其成为当前顶点，重复 1；
</code></pre></li><li><pre><code> 3/3 如果 2 不能满足，搜索结束。
</code></pre></li></ul><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> queue <span class="token operator">=</span> <span class="token function">BfsQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> keyArr <span class="token operator">=</span> hashMap<span class="token punctuation">.</span>keys<span class="token punctuation">.</span><span class="token function">toIntArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>keyArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    hashMap<span class="token punctuation">[</span>keyArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!!</span><span class="token punctuation">.</span>isVisited <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">var</span> index <span class="token operator">=</span> hashMap<span class="token punctuation">[</span>keyArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> availableKey <span class="token operator">=</span> <span class="token function">getAvailableNode</span><span class="token punctuation">(</span>index<span class="token operator">!!</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>availableKey <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> current <span class="token operator">=</span> hashMap<span class="token punctuation">[</span>availableKey<span class="token punctuation">]</span><span class="token operator">!!</span><span class="token comment">//广度优先搜索，优先将一个节点的所有邻接点依次访问</span>
            current<span class="token punctuation">.</span>isVisited <span class="token operator">=</span> <span class="token boolean">true</span>
            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> pop <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">pop</span></span><span class="token string"> &quot;</span></span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
            index <span class="token operator">=</span> hashMap<span class="token punctuation">[</span>queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment">//如果该点没有未访问的邻接点，就选择去访问该点邻接点的邻接点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="最小生成树-mst" tabindex="-1"><a class="header-anchor" href="#最小生成树-mst" aria-hidden="true">#</a> 最小生成树 MST</h1><blockquote><p>生成树（Template:Lang-en-short）是具有图 G 的全部顶点，但边数最少的连通子图。</p><p>——维基百科</p></blockquote><p>带权图的生成树中，总权重最小的称为最小生成树。</p><p>最小生成树边比顶点数小 1。</p><ul><li><p>当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。</p></li><li><p>如果图的每一条边的权值都互不相同，那么最小生成树将只有一个。</p></li></ul><p>无向不带权图中，只需要找出最小数量的边即可。用 DFS 比较好实现，因为他对每个顶点只访问一次。</p><h1 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序" aria-hidden="true">#</a> 拓扑排序</h1><p>拓扑排序是指<strong>有向图</strong>的顶点排序，满足以下条件<a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">*</a>：</p>`,41),r=n("li",null,"每个顶点出现且只出现一次；",-1),k={href:"https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84_(%E5%9B%BE%E8%AE%BA)",target:"_blank",rel:"noopener noreferrer"},d=e(`<p>实现思路是：</p><ul><li><p>依次推出有向图中没有后继点的顶点作为排序的最后项，这是因为按照拓扑排序<code>条件2</code>没有后继点的顶点必然排在后面；</p></li><li><p>当去掉没有后继点的顶点后又会产生新的没有后继点的顶点，这样依次循环，当图中没有顶点的时候，就可以在有向无环图中完成拓扑排序。</p></li></ul><p>对于有环存在（即存在类似 A→B，B→C，C→A 的情况）的有向图，会出现找不到<code>没有后继点的顶点</code>，但同时<code>图中顶点数不为0</code>的情况，遇到这种情况退出循环，并说明有环存在即可。</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">/**
 * 拓扑排序
 */</span>
<span class="token keyword">fun</span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> displayList <span class="token operator">=</span> ArrayList<span class="token operator">&lt;</span>T<span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>hashMap<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> successorKey <span class="token operator">=</span> <span class="token function">getSuccessorNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>successorKey <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//图中还有顶点，但却找不到“没有后继点的顶点”，说明有环</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;图中有环&quot;</span></span><span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            hashMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>successorKey<span class="token punctuation">)</span><span class="token comment">//如果找到满足条件的顶点，从图中删除并保存的排序结果中</span>
            displayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>successorKey<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;\\n </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token expression">displayList<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> \\n&quot;</span></span><span class="token punctuation">)</span><span class="token comment">//以正确的顺序输出排序结果</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 遍历图，查找没有后继点的顶点
 * @return -1 表示没有这样的点 否则返回该点 key
 */</span>
<span class="token keyword">fun</span> <span class="token function">getSuccessorNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T<span class="token operator">?</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> result<span class="token operator">:</span> T<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">var</span> ketSet <span class="token operator">=</span> hashMap<span class="token punctuation">.</span>keys

    ketSet<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span><span class="token comment">//遍历图中每个顶点</span>
        <span class="token comment">//如果顶点没有后继点 (没有邻接点，或者邻接点已经被删除) 就是满足条件</span>
        <span class="token keyword">var</span> node<span class="token operator">:</span> GraphicNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">?</span> <span class="token operator">=</span> hashMap<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">?:</span> <span class="token keyword">return</span> it
        <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> realNode <span class="token operator">=</span> hashMap<span class="token punctuation">[</span>node<span class="token punctuation">.</span>data<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>realNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span><span class="token label symbol">@map</span><span class="token comment">//有后继点，不满足条件，查找下一个顶点</span>
            <span class="token punctuation">}</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token comment">//还有其他邻接点，依次遍历</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> it
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token comment">//没有找到“没有后继点的顶点”</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="源码" tabindex="-1"><a class="header-anchor" href="#源码" aria-hidden="true">#</a> 源码</h1>`,5),v={href:"https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/GraphClazz.kt",target:"_blank",rel:"noopener noreferrer"},m=n("code",null,"DFS/BFS/MST",-1),h={href:"https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/Digraph.kt",target:"_blank",rel:"noopener noreferrer"},b=n("code",null,"拓扑排序",-1),g=n("h1",{id:"参考资料",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),s(" 参考资料")],-1),f={href:"https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"};function y(w,x){const a=o("ExternalLinkIcon");return c(),i("div",null,[u,n("ol",null,[r,n("li",null,[s("若 A 在序列中排在 B 的前面，则在图中不存在从 B 到 A 的"),n("a",k,[s("路径"),p(a)]),s("。")])]),d,n("p",null,[n("a",v,[s("👉 点这里"),p(a)]),s(" 查看"),m,s("源码")]),n("p",null,[n("a",h,[s("👉 点这里"),p(a)]),s(" 查看"),b,s("源码")]),g,n("p",null,[n("a",f,[s("拓扑排序——维基百科"),p(a)])])])}const A=t(l,[["render",y],["__file","a71f2ecc.html.vue"]]);export{A as default};
