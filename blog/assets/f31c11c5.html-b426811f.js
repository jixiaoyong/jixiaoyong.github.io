import{_ as a,o as e,c as n,e as r}from"./app-16aa99a6.js";const t={},i=r(`<blockquote><p>本笔记基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》及部分在线博客整理。</p></blockquote><p>JVM：java virtual machine，一个 java 程序（进程）拥有一个 jvm 实例</p><h2 id="内存" tabindex="-1"><a class="header-anchor" href="#内存" aria-hidden="true">#</a> 内存</h2><p>JVM 区域总体分两类，heap 区和非 heap 区：</p><p><strong>heap 区</strong>：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代 - 养老区）。<br><strong>非 heap 区</strong>：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(Java 虚拟机栈)、Local Method Statck(本地方 法栈)。</p><h2 id="内存划分" tabindex="-1"><a class="header-anchor" href="#内存划分" aria-hidden="true">#</a> 内存划分</h2><h3 id="_1-head" tabindex="-1"><a class="header-anchor" href="#_1-head" aria-hidden="true">#</a> 1.head</h3><p>堆，所有线程共享，存放所有对象实例、数组，GC 主要场所，会 OOM</p><p>分类</p><p><strong>1.新生代</strong></p><ul><li><p>eden 刚刚创建的对象优先</p></li><li><p>s1 经历几次 GC</p></li><li><p>s2 经历几次 GC</p></li></ul><p><strong>2.老年代</strong></p><ul><li><p>存活时间长的老年对象</p></li><li><p>大对象，如数组，大 String...</p></li></ul><h3 id="_2-stack" tabindex="-1"><a class="header-anchor" href="#_2-stack" aria-hidden="true">#</a> 2.stack</h3><p>栈，线程私有，存放基本数据和对象的引用，LIFO，会 OOM，StackOverflow</p><h4 id="java-virtual-machine-stack" tabindex="-1"><a class="header-anchor" href="#java-virtual-machine-stack" aria-hidden="true">#</a> java virtual machine stack</h4><p>线程请求的栈深度大于 JVM 允许的深度会导致 Stack Overflow<br> 在编译期完成内存分配，如果虚拟机栈可以动态扩展，但是当拓展时无法申请到足够内存时会导致 OutOfMemory</p><p><strong>stack  frame</strong></p><p>stack frame：栈帧，每执行一个方法就会产生一个栈帧并压入栈中</p><ul><li><p>局部变量表</p><ul><li>基本数据类型</li><li>对象引用</li><li>returnAddress 类型，指向了一条字节码指令的位置</li></ul></li><li><p>操作数栈</p></li><li><p>动态链接</p></li><li><p>方法出口等</p></li></ul><h4 id="native-method-stack" tabindex="-1"><a class="header-anchor" href="#native-method-stack" aria-hidden="true">#</a> native method stack</h4><p>与 java 虚拟机栈作用类似，不过 native method stack 是为 native 方法服务。<br> jvm 可以自由实现它，甚至在 sun HotSpot VM 中将他与虚拟机栈合并<br> 会 OOM，stackOverflow</p><h3 id="_3-method-area" tabindex="-1"><a class="header-anchor" href="#_3-method-area" aria-hidden="true">#</a> 3.method area</h3><p>方法区，线程共享，存放类信息，常量，静态变量，即时编译器编译后的代码，会 OOM</p><p><strong>运行时常量池</strong></p><p>类加载后，编译器生成的各种字面量和符号引用会放到方法区的运行时常量池中，会 OOM<br><code>String.intern()</code>，有该 string 对象则返回，无则创建并返回</p><blockquote><p><code>String.intern()</code>方法的注意事项：</p><p>JDK1.6 及以下：将首次出现的对象实例<strong>复制</strong>到永久代，返回其引用</p><p>JDK1.7 及以上：只会<strong>记录</strong>下首次出现的实例的引用，返回其引用</p><p>所以：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">&quot;java&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JDK1.6 及以下输出<code>false</code>，在 JDK1.7 及以上输出<code>true</code></p><p>此外，由于<code>String</code>类是<code>final</code>的，每次<code>new String(&quot;str&quot;)</code>会产生两个对象：一个是字符串<code>str</code>本身，一个是值为<code>str</code>的字符串。</p></blockquote><p>以<code>String s = &quot;Hello&quot;;</code>为例，解释几个概念：</p><p><strong>字面量</strong> 源码中表示具体的值，如<code>Hello</code></p><p><strong>符号引用</strong> 用来指代某种值得符号，如<code>s</code></p><p><strong>直接引用</strong> 可以定位到内存中的（类、对象、方法、变量）等的具体地址</p><h3 id="_4-program-count" tabindex="-1"><a class="header-anchor" href="#_4-program-count" aria-hidden="true">#</a> 4.program count</h3><p><strong>程序计数器</strong>，线程私有，占用内存小，当做当前线程执行字节码的行号指示器。</p><p>若执行 java 方法，计数器记录的是正在执行的虚拟机字节码指令的位置</p><p>若执行的是 native 方法，则计数器为空 undefined。</p><p>此内存区域是唯一一个在 java 虚拟机规范字没有规定任何 OOMError 的区域</p><h2 id="内存溢出" tabindex="-1"><a class="header-anchor" href="#内存溢出" aria-hidden="true">#</a> 内存溢出</h2><blockquote><p>以 Sun HotSpot VM 为例</p></blockquote><h3 id="_1-java-堆溢出" tabindex="-1"><a class="header-anchor" href="#_1-java-堆溢出" aria-hidden="true">#</a> 1.java 堆溢出</h3><p>对象过多导致 head 内存溢出</p><ol><li>是内存泄漏 memory leak，定位泄露对象</li><li>是内存溢出 memory overflow，检查虚拟机堆参数是否可以调大；去除非必须的生命周期长的对象</li></ol><h3 id="_2-虚拟机栈和本地方法栈溢出" tabindex="-1"><a class="header-anchor" href="#_2-虚拟机栈和本地方法栈溢出" aria-hidden="true">#</a> 2.虚拟机栈和本地方法栈溢出</h3><ol><li><p>单线程，Stack Overflow</p><p>单线程下，栈帧过大或者虚拟机栈容量太小，当内存无法分配时都会导致 Stack Overflow 异常</p></li><li><p>多线程，</p><p>多线程时，每个线程栈分配的内存越大，越容易尝试内存溢出 OOM</p><p>原因：虚拟机最大内存一定的情况下，去掉共享的 Head 和 MethodArea 占的内存，剩下的内存/单个线程最大栈内存=最大线程数量，当单个线程最大栈内存增加时，可以产生的线程数就会越少</p></li></ol><h3 id="_3-运行时常量池溢出" tabindex="-1"><a class="header-anchor" href="#_3-运行时常量池溢出" aria-hidden="true">#</a> 3.运行时常量池溢出</h3><p>运行时常量池属于方法区，当常量过多时会导致 OOM，可以用 String.intern() 方法尝试</p><h3 id="_4-方法区溢出" tabindex="-1"><a class="header-anchor" href="#_4-方法区溢出" aria-hidden="true">#</a> 4.方法区溢出</h3><p>经常动态生成大量 Class 的应用，如 Spring 等框架，需要注意 OOM</p><h3 id="_5-本地直接内存溢出" tabindex="-1"><a class="header-anchor" href="#_5-本地直接内存溢出" aria-hidden="true">#</a> 5.本地直接内存溢出</h3><p>原生方法直接操作物理内存时导致物理内存不够，产生 OOM</p><h2 id="gc-垃圾回收" tabindex="-1"><a class="header-anchor" href="#gc-垃圾回收" aria-hidden="true">#</a> GC 垃圾回收</h2><p>JVM 中 GC 会根据不同情况采取以下一系列算法组合进行内存回收</p><h3 id="回收算法" tabindex="-1"><a class="header-anchor" href="#回收算法" aria-hidden="true">#</a> 回收算法</h3><h4 id="_1-复制算法" tabindex="-1"><a class="header-anchor" href="#_1-复制算法" aria-hidden="true">#</a> 1.复制算法</h4><p><strong>原理</strong>：内存一分为二，只使用一半；GC 时将存活对象复制到另一半内存，剩下的则清空</p><p><strong>优缺点</strong>：1.无 STW，但不适合对象过多的情况；2.内存利用效率低</p><h4 id="_2-标记清除法" tabindex="-1"><a class="header-anchor" href="#_2-标记清除法" aria-hidden="true">#</a> 2.标记清除法</h4><p><strong>原理</strong>：从 GC Roots 开始遍历，可达标记存活，不可达则未标记</p><p>java 中，GC Roots 可以是以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI 引用的对象</li></ul><p><strong>优缺点</strong>：1.要 StopTheWorld 防止标记的时候新 new 的对象未被标记而出错；</p><p>2.清除对象后内存不连续，会有一定的浪费</p><h4 id="_3-标记压缩法" tabindex="-1"><a class="header-anchor" href="#_3-标记压缩法" aria-hidden="true">#</a> 3.标记压缩法</h4><p><strong>原理</strong>：类似【标记清除法】，但会对标记进行压缩，如 a-&gt;b-&gt;c，会被压缩为 a-&gt;c，具体试讲所有存活的对象都向一端移动，直接清理掉端边界外的内存</p><p><strong>优缺点</strong>：1.也要 StopTheWorld</p><h4 id="_4-引用计数算法" tabindex="-1"><a class="header-anchor" href="#_4-引用计数算法" aria-hidden="true">#</a> 4.引用计数算法</h4><p><strong>原理</strong>：引用 +1，不引用 -1，为 0 则删除，但是会有相互循环引用的问题，java 未使用</p><p><strong>优缺点</strong>：相互循环使用：<br> a = b<br> b = a<br> 除此之外再没有用到 a，b 的地方，但是由于 a，b 的引用不为 0 所以无法被回收，导致内存浪费</p><h3 id="回收过程" tabindex="-1"><a class="header-anchor" href="#回收过程" aria-hidden="true">#</a> 回收过程</h3><p>一个不可达对象在“死缓”到“执行死刑”前至少经历两个标记过程</p><ol><li><p>第一次标记，筛选：是否有必要执行 finalize() 方法，若是则放到 F-Queue 队列中【触发】该方法，但不保证执行完该方法。</p><p>可以在 finlize() 方法中<strong>自救一次</strong>：在该方法中将<em>自身 this</em>赋值给其他变量，这样在第二次标记时会被移出<em>即将回收</em>集合；但是由于 finlize() 方法只会被调用一次，所以只能自救一次。并<em>不推荐该方法</em>，该方法所有可以做的工作，可以用<strong>try...finally</strong>或者其他方法更好的实现</p></li><li><p>第二次标记，若 finalize() 方法以及调用过，或者为重写该方法，则“没必要执行”，可以回收</p></li></ol><h2 id="对象" tabindex="-1"><a class="header-anchor" href="#对象" aria-hidden="true">#</a> 对象</h2><h3 id="对象引用" tabindex="-1"><a class="header-anchor" href="#对象引用" aria-hidden="true">#</a> 对象引用</h3><h4 id="强引用-strongreference" tabindex="-1"><a class="header-anchor" href="#强引用-strongreference" aria-hidden="true">#</a> 强引用 StrongReference</h4><p>People p = new People();哪怕抛出 OOM 也不会被 GC 回收的对象</p><h4 id="软引用-softreference" tabindex="-1"><a class="header-anchor" href="#软引用-softreference" aria-hidden="true">#</a> 软引用 SoftReference</h4><p>SoftReference sf = new SoftReference(p);只要有足够内存就不会被 GC 回收，若内存不够则会被 GC 回收，常用作服务器缓存</p><h4 id="弱引用-weakreference" tabindex="-1"><a class="header-anchor" href="#弱引用-weakreference" aria-hidden="true">#</a> 弱引用 WeakReference</h4><p>在下次 GC 回收之前都存在，用作 android 等内存紧张的设备中的缓存</p><h4 id="虚引用-phantomreference" tabindex="-1"><a class="header-anchor" href="#虚引用-phantomreference" aria-hidden="true">#</a> 虚引用 PhantomReference</h4><p>无法影响其生存时间，也无法通过虚引用获取其实例，设置虚引用只是为了在对象被 GC 回收时获取系统通知</p><h2 id="脑图" tabindex="-1"><a class="header-anchor" href="#脑图" aria-hidden="true">#</a> 脑图</h2><figure><img src="https://jixiaoyong.github.io/images/blog/2018-02/JVMMemory.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,82),s=[i];function o(d,p){return e(),n("div",null,s)}const c=a(t,[["render",o],["__file","f31c11c5.html.vue"]]);export{c as default};
