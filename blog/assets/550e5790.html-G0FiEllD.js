import{_ as e,c as t,o as i,a as o}from"./app-Dzc-nq1p.js";const n={},a=o('<blockquote><p>本文是对 Dart 官方 VM 的介绍的总结摘要，推荐直接阅读<a href="https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md" target="_blank" rel="noopener noreferrer">官方原文</a>。</p></blockquote><p>Dart VM is a collection of components for executing Dart code natively. Notably, it includes the following:</p><ul><li><strong>Runtime System</strong><ul><li>Object Model</li><li>Garbage Collection</li><li>Snapshots</li></ul></li><li><strong>Core libraries’ native methods</strong></li><li><strong>Development Experience components</strong> accessible via <em>service protocol</em> * Debugging * Profiling * Hot-reload</li><li><strong>Just-in-Time (JIT) and Ahead-of-Time (AOT) compilation pipelines</strong></li><li><strong>Interpreter</strong></li><li><strong>ARM simulators</strong></li></ul><p>下图是 runtime 执行代码的示意图：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/isolates.png" alt="isolate" tabindex="0" loading="lazy"><figcaption>isolate</figcaption></figure><p>isolate 中有两种 Thread：</p><ul><li>一个 mutator thread 用来执行 dart 代码</li><li>多个 helper thread 用来执行 GC、JIT 等</li></ul><p>此外，一个 isolate 有一个 heap，用来存储所有的 dart object（GC 发生在这里）。</p><p>一个 OSThread 一次只能进入一个 isolate，当其进入之后，该 isolate 的 mutator thread 便和这个 OSThread 关联起来执行 dart 代码。当 OSThread 要进入一个 isolate 的时候，必须先退出当前关联的 isolate。</p><p>isolate 的 mutator thread 可能在不同时间关联不同的 OSThread，但同一时刻最多只能有一个 OSThread。</p><p>VM 执行 Dart 代码有两种方式：JIT 和 AOT，不管哪一种都不会直接执行 Dart 源码，而是经过转化之后的 Kernel Binary(also called <em>dill files</em>)which contain serialized <a href="https://github.com/dart-lang/sdk/blob/main/pkg/kernel/README.md" target="_blank" rel="noopener noreferrer">Kernel ASTs</a>。</p><p>一般来说，从 Dart source code 到 Dart VM 执行分为下面几步：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/dart-to-kernel.png" alt="dart-to-kernel" tabindex="0" loading="lazy"><figcaption>dart-to-kernel</figcaption></figure><blockquote><p>VM expects to be given <strong><em>Kernel binaries</em></strong> (also called <em>dill files</em>) which contain serialized <a href="https://github.com/dart-lang/sdk/blob/main/pkg/kernel/README.md" target="_blank" rel="noopener noreferrer">Kernel ASTs</a>. The task of translating <strong>Dart source</strong> into <strong>Kernel AST</strong> is handled by the <a href="https://github.com/dart-lang/sdk/tree/master/pkg/front_end" target="_blank" rel="noopener noreferrer">common front-end (<strong>CFE</strong>)</a> written in Dart and shared between different Dart tools (e.g. VM, dart2js, Dart Dev Compiler).</p></blockquote><p>Dart VM has multiple ways to execute the code, for example:</p><ul><li>from source or Kernel binary using <strong>JIT</strong>;</li><li>from snapshots: <ul><li>from <strong>AOT</strong> snapshot;</li><li>from <strong>AppJIT</strong> snapshot.</li></ul></li></ul><h2 id="_1-running-from-source-via-jit" tabindex="-1"><a class="header-anchor" href="#_1-running-from-source-via-jit"><span>1. Running from source via JIT.</span></a></h2><h3 id="从-dart-source-加载到-vm-中" tabindex="-1"><a class="header-anchor" href="#从-dart-source-加载到-vm-中"><span>从 Dart Source 加载到 VM 中</span></a></h3><p>为了保证直接从源代码执行 Dart 的便利性，独立的 dart 可执行文件承载了一个称为内核服务（*kernel service）*的辅助 isolate，它处理 Dart 源代码编译成内核的过程。然后，VM 将运行产生的内核二进制文件（Kernel Binary）。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-service.png" alt="kernel-service" tabindex="0" loading="lazy"><figcaption>kernel-service</figcaption></figure><p>上图中，一个被称为<em>kernel service</em>的 isolate 使用 CFE 将 Dart Source 编译为为<em>Kernel Binary</em>然后交给 main isolate 执行。</p><p>这并不是安排 CFE 和 VM 执行 Dart Source 的唯一方式，比如 Flutter 就将 CFE（封装之后的）和 VM 分别置于两个设备上：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/flutter-cfe.png" alt="flutter-cfe" tabindex="0" loading="lazy"><figcaption>flutter-cfe</figcaption></figure><p>当热更新触发时，Flutter 使用封装过的 CFE 以及一个 Flutter 独有的 Kernel-to-Kernel 转换，将修改过的 Dart Source 编译为 Kernel Binary，然后推送到设备上面（比如手机）执行。</p><h3 id="在-vm-中执行" tabindex="-1"><a class="header-anchor" href="#在-vm-中执行"><span>在 VM 中执行</span></a></h3><p>上面是 Dart Source 加载到 VM 的过程，下面是<strong>Dart 代码在 VM 中执行的过程</strong>分析：</p><p>1）当<em>Kernel Binary</em>加载到 VM 中之后，只会解析加载的类和库的基本信息。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-1.png" alt="kernel-loaded-1" tabindex="0" loading="lazy"><figcaption>kernel-loaded-1</figcaption></figure><p>2）当 runtime 实际用到的时候才会去获取完整的信息用来创建对象分配内存等：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-2.png" alt="kernel-loaded-2" tabindex="0" loading="lazy"><figcaption>kernel-loaded-2</figcaption></figure><p>此时，从<em>Kernel Binary</em>中读取出了<em>class members</em>，此时已经有足够的信息让 runtime 用来调用方法（successfully resolve and invoke methods）了，比如调用 main 方法，但是<strong>具体的方法体此时依旧还没有被反序列</strong>（deserialized）。</p><p>3）在这个阶段，所有的 function 只是持有了一个真正要执行的方法体的<em>placeholder</em>指向<em>LazyCompileStub</em>，当 runtime 要执行的时候再创建并运行可执行代码。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/raw-function-lazy-compile.png" alt="raw-function-lazy-compile" tabindex="0" loading="lazy"><figcaption>raw-function-lazy-compile</figcaption></figure><p>这时候执行方法有两个阶段：</p><ol><li><strong>unoptimized</strong> 默认执行时直接从<em>Kernel Binary</em>创建<em>IL</em>然后转化为<em>machine code</em>并运行</li><li><strong>optimized</strong> 在 a 阶段的热点代码会被从普通<em>IL</em>优化为<em>SSA IL</em>，然后转化为<em>machine code</em>运行，如果遇到优化失效的，再回退到 a 阶段执行代码（后面是否需要再走 b 阶段，需要重新判断）</li></ol><h4 id="unoptimized-code" tabindex="-1"><a class="header-anchor" href="#unoptimized-code"><span>unoptimized code</span></a></h4><p>这个阶段，从<em>Kernel Binary</em>生成<em>Machine Code</em>主要分为 2 步：</p><p><strong>（1）<em>Kernel Binary</em> → <em>IL</em></strong></p><p>在这个阶段，从<em>Kernel Binary</em>中的<em>AST</em>中解析产生对应的<em>control flow graph</em>(<strong>CFG</strong>)。</p><blockquote><p>CFG 由<em>intermediate language</em>(<strong>IL</strong>) 组成，这个阶段使用的 IL 指令类似基于 stack 的虚拟机：他们从 stack 中读取操作数，执行操作，然后将结果 push 回这个 stack 中。</p></blockquote><figure><img src="https://jixiaoyong.github.io/images/dart_vm/unoptimized-compilation.png" alt="unoptimized-compilation" tabindex="0" loading="lazy"><figcaption>unoptimized-compilation</figcaption></figure><p>但并不是所有的方法都有对应的<em>Dart/Kernel AST bodies</em>（比如一些<em>native</em>方法或者<em>artificial tear-off functions</em> generated by Dart VM），这种情况下，他们凭空创建（<em>in these cases IL is just created from the thin air</em>）。</p><p><strong>(2) <em>IL</em> → <em>Machine Code</em></strong></p><p>由一条 IL 对应生成多行 machine language instruction</p><p>在这个阶段不会进行优化，主要目的是快速创建出可执行代码（<em>produce executable code quickly</em>）</p><p><strong>内联缓存（inline caching）</strong></p><p>在这个阶段，编译器（<em>unoptimizing compiler</em>）不会尝试静态解析任何没有在 Kernel Binary 中解析的调用（<em>any calls that were not resolved in Kernel binary</em>），因此调用 (<code>MethodInvocation</code> or <code>PropertyGet</code> AST nodes) 被认为是完全动态的，VM 使用内联缓存（inline caching）来实现动态调用。</p><p>内联缓存的实现主要有：</p><ul><li>一个<strong>call site specific cache</strong>，将调用的类与方法映射在一起，如果 receiver 和已有的缓存类对应，那么就应该调用对应的方法，还有个计数器（<em>invocation frequency counters</em>）标记这个方法被调用多少次（对应下文的 RawICData）</li><li>一个共享的<strong>lookup stub</strong>，实现了方法调用的最快路径（<em>method invocation fast path</em>），在发生调用时通过 lookup stub 查询是否有 entry 与 receiver 的类匹配，有的话就用调用 entry 并增加 frequency counter；否则就调用系统的 runtime system helper 兜底（如果成功运行了就更新上面的缓存，这样下次调用就不用再走 runtime 了）。</li></ul><figure><img src="https://jixiaoyong.github.io/images/dart_vm/inline-cache-1.png" alt="inline-cache-1" tabindex="0" loading="lazy"><figcaption>inline-cache-1</figcaption></figure><aside> 💡 **Unoptimizing compiler** by itself is enough to execute any possible Dart code.</aside><h4 id="optimized-code" tabindex="-1"><a class="header-anchor" href="#optimized-code"><span>optimized code</span></a></h4><p>虽然<strong>Unoptimizing compiler</strong>可以执行任意 Dart 代码，但是太慢了，所以在以上述方式执行代码的同时会记录以下信息：</p><ul><li>Inline cache 收集在调用点的<strong>receiver 类型</strong>（<em>receiver types observed at callsites</em>）</li><li>和方法对应的 execution counters 以及 basic blocks within functions 追踪代码的<strong>热点区域</strong>（hot regions of the code）</li></ul><p>Optimized compilations 和 Unoptimizing compiler 开始的步骤类似：</p><p><strong>(1) <em>Kernel Binary</em> → <em>unoptimized IL</em></strong></p><p><strong>(2) <em>unoptimized IL</em> → <em>SSA based IL</em> → <em>optimized IL</em></strong></p><p>当上述代码执行的时候，如果程序调用计数器（<em>invocation frequency counters</em>）到达某个阈值，这个方法就会被交给一个后台优化编译器（<em>background optimizing compiler</em>）来优化，将 unoptimized IL 转化为*SSA（static single assignment）*形式的 IL。</p><p>最后将 SSA IL 优化为 optimized IL。</p><p><strong>(3) <em>optimized IL</em> → <em>machine code</em></strong></p><p>在优化完成后，编译器会要求 mutator thread 进入 safepoint 并将优化后的代码绑定到方法上（attaches optimized code to the function）。</p><blockquote><p>safepoint 的含义是，thread 关联的 state（比如 heap，stack frame 等）是一致的，并且可以在不中断线程的情况下访问或修改。通常意味着 thread 被暂停，或者在当前环境外（比如执行 native 代码）。</p></blockquote><figure><img src="https://jixiaoyong.github.io/images/dart_vm/optimizing-compilation.png" alt="optimizing-compilation" tabindex="0" loading="lazy"><figcaption>optimizing-compilation</figcaption></figure><p>上述这种基于乐观假设的优化，可能没法处理部分情况，从而回退到未优化的代码（deoptimization），然后再执行未优化过程（通常会丢弃优化后的代码，再判断是否有热点代码需要优化），主要有 2 种方式：</p><ol><li><strong><em>eager deoptimization</em></strong> 在内联检查的时候，判断优化的条件是否满足，不满足的话就丢弃优化代码</li><li><strong><em>lazy deoptimization</em></strong> 全局分析指示在更改优化代码的内容时丢弃优化代码（之前优化的条件不满足了）。</li></ol><h2 id="_2-running-from-aot-snapshot" tabindex="-1"><a class="header-anchor" href="#_2-running-from-aot-snapshot"><span>2. Running from <strong>AOT</strong> snapshot</span></a></h2><p>Snapshot&#39;s format is low level and optimized for fast startup，包含了要创建的 object 以及如何关联这些对象的说明信息（instructions）。</p><p>VM 可以将 Heap/甚至是 Heap 中的 object graph 序列化成为 snapshot，然后再从这个 snapshot 中重建对应的状态：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot.png" alt="snapshot" tabindex="0" loading="lazy"><figcaption>snapshot</figcaption></figure><p>最初的 snapshot 并不包含 machine code，直到 AOT compiler 的出现。</p><p>AOT compiler 和 snapshot-with-code 使得 VM 可以在那些 JIT 受限的设备上运行：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot-with-code.png" alt="snapshot-with-code" tabindex="0" loading="lazy"><figcaption>snapshot-with-code</figcaption></figure><p><strong>snapshot-with-code</strong>和普通的<strong>snapshot</strong>基本一致，<strong>唯一不同的是多出的 machine code 不需要 deserizlization</strong>，事实上 machine code 在被分配到内存后可以立即成为 heap 的一部分（<em>directly become part of the heap after it was mapped into memory</em>）。</p><h2 id="_3-running-from-appjit-snapshot" tabindex="-1"><a class="header-anchor" href="#_3-running-from-appjit-snapshot"><span>3. Running from <strong>AppJIT</strong> snapshot</span></a></h2><p><strong>AppJIT</strong> snapshot 主要用于减少大型 Dart application 的 JIT 热身时间。</p><p>AppJIT snapshots were introduced to <strong>reduce JIT warm up time for large Dart applications</strong> like <code>dartanalyzer</code>or <code>dart2js</code>. When these tools are used on small projects they spent as much time doing actual work as VM spends JIT compiling these apps.</p><p>他的主要实现是：先用模拟数据在 VM 上运行，然后将其生成的 code 以及 VM 内部的数据结构序列化为 AppJIT snapshot 加载到 VM 中运行，只在正式的数据和模拟训练的配置无法匹配的时候执行 JIT（<em>execution profile on the real data does not match execution profile observed during training</em>）。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot-appjit.png" alt="snapshot-appjit" tabindex="0" loading="lazy"><figcaption>snapshot-appjit</figcaption></figure><h2 id="_4-running-from-appaot-snapshot" tabindex="-1"><a class="header-anchor" href="#_4-running-from-appaot-snapshot"><span>4. Running from <strong>AppAOT</strong> snapshot</span></a></h2><p>AOT 与 JIT 各有优劣：</p><ul><li>AOT 启动时间更短</li><li>JIT 峰值性能更优</li></ul><p>无法进行 JIT 意味着</p><ol><li>AOT snapshot <em>must</em> contain executable code for each and every function that could be invoked during application execution;</li><li>the executable code <em>must not</em> rely on any speculative assumptions that could be violated during execution;</li></ol><p>为了满足上述要求，AOT 汇编过程会进行全局静态分析以确定程序的哪些部分是可以从已知的 entry point 触达的，分配哪些类的实例，以及类型在程序中是如何应用的（which parts of the application are reachable from known set of <em>entry points</em>, instances of which classes are allocated and how types flow through the program）。</p><p>AOT 上述这些分析是保守的，可能在准确性上犯错，与之相比，JIT 则在性能方面不行，因为 JIT 需要 deoptimize 兜底实现正确的行为。</p><p>所以 AOT 将所有潜在的可触达的功能编译为 native code，而无需投机性优化（All potentially reachable functions are then compiled to native code without any speculative optimizations）。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/aot.png" alt="aot" tabindex="0" loading="lazy"><figcaption>aot</figcaption></figure><p>从上图可以看出，AOT 中，Kernel Binary 先经过 TFA 收集变量、方法等信息，以此来<strong>移除不可达的方法</strong>，并 devirtuablize method（确定<a href="https://www.techopedia.com/definition/24299/virtual-method#:~:text=A%20virtual%20method%20is%20a,oriented%20language%2C%20such%20as%20C%23." target="_blank" rel="noopener noreferrer">虚拟方法</a>的具体执行）。之后经过 VM 再移除一些不可达方法。</p><p>Resulting snapshot can then be run using <em>precompiled runtime</em>, a special variant of the Dart VM which excludes components like JIT and dynamic code loading facilities.</p><h3 id="switchable-calls" tabindex="-1"><a class="header-anchor" href="#switchable-calls"><span>Switchable Calls</span></a></h3><p>即使有全局和局部分析，AOT 编译依然可能包含一些无法被非虚拟化（<em>devirtualized</em>）的 call sites，为了解决这个问题，AOT 编译出的代码和 runtime 会使用 JIT 中用到的内联缓存（<em>Inline Caching</em>）技术的拓展——<strong><em>switchable calls</em></strong>。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md" target="_blank" rel="noopener noreferrer">sdk/index.md at main · dart-lang/sdk</a></p><p><a href="https://www.jianshu.com/p/a5b1997a01ba" target="_blank" rel="noopener noreferrer">Dart VM 介绍</a></p>',94),r=[a];function s(l,p){return i(),t("div",null,r)}const g=e(n,[["render",s],["__file","550e5790.html.vue"]]),c=JSON.parse('{"path":"/posts/550e5790.html","title":"Dart VM","lang":"zh-CN","frontmatter":{"permalink":"/posts/550e5790.html","title":"Dart VM","date":"2022-06-02T07:18:57.000Z","updated":"2023-12-30T08:17:02.000Z","tag":"dart","abbrlink":"550e5790","isOriginal":true,"description":"本文是对 Dart 官方 VM 的介绍的总结摘要，推荐直接阅读官方原文。 Dart VM is a collection of components for executing Dart code natively. Notably, it includes the following: Runtime System Object Model Garb...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/550e5790.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"Dart VM"}],["meta",{"property":"og:description","content":"本文是对 Dart 官方 VM 的介绍的总结摘要，推荐直接阅读官方原文。 Dart VM is a collection of components for executing Dart code natively. Notably, it includes the following: Runtime System Object Model Garb..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jixiaoyong.github.io/images/dart_vm/isolates.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T16:00:22.000Z"}],["meta",{"property":"article:author","content":"JI,XIAOYONG"}],["meta",{"property":"article:tag","content":"dart"}],["meta",{"property":"article:published_time","content":"2022-06-02T07:18:57.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T16:00:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dart VM\\",\\"image\\":[\\"https://jixiaoyong.github.io/images/dart_vm/isolates.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/dart-to-kernel.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/kernel-service.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/flutter-cfe.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-1.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-2.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/raw-function-lazy-compile.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/unoptimized-compilation.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/inline-cache-1.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/optimizing-compilation.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/snapshot.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/snapshot-with-code.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/snapshot-appjit.png\\",\\"https://jixiaoyong.github.io/images/dart_vm/aot.png\\"],\\"datePublished\\":\\"2022-06-02T07:18:57.000Z\\",\\"dateModified\\":\\"2024-05-31T16:00:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. Running from source via JIT.","slug":"_1-running-from-source-via-jit","link":"#_1-running-from-source-via-jit","children":[{"level":3,"title":"从 Dart Source 加载到 VM 中","slug":"从-dart-source-加载到-vm-中","link":"#从-dart-source-加载到-vm-中","children":[]},{"level":3,"title":"在 VM 中执行","slug":"在-vm-中执行","link":"#在-vm-中执行","children":[{"level":4,"title":"unoptimized code","slug":"unoptimized-code","link":"#unoptimized-code","children":[]},{"level":4,"title":"optimized code","slug":"optimized-code","link":"#optimized-code","children":[]}]}]},{"level":2,"title":"2. Running from AOT snapshot","slug":"_2-running-from-aot-snapshot","link":"#_2-running-from-aot-snapshot","children":[]},{"level":2,"title":"3. Running from AppJIT snapshot","slug":"_3-running-from-appjit-snapshot","link":"#_3-running-from-appjit-snapshot","children":[]},{"level":2,"title":"4. Running from AppAOT snapshot","slug":"_4-running-from-appaot-snapshot","link":"#_4-running-from-appaot-snapshot","children":[{"level":3,"title":"Switchable Calls","slug":"switchable-calls","link":"#switchable-calls","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1654154266000,"updatedTime":1717171222000,"contributors":[{"name":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":4},{"name":"JI,XIAOYONG","email":"jixiaoyong1995@gmail.com","commits":1}]},"readingTime":{"minutes":9.03,"words":2708},"filePathRelative":"_posts/dart_vm_introduction.md","localizedDate":"2022年6月2日","excerpt":"<blockquote>\\n<p>本文是对 Dart 官方 VM 的介绍的总结摘要，推荐直接阅读<a href=\\"https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">官方原文</a>。</p>\\n</blockquote>\\n<p>Dart VM is a collection of components for executing Dart code natively. Notably, it includes the following:</p>","autoDesc":true}');export{g as comp,c as data};
