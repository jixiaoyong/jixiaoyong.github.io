import{_ as l,c as r,a,d as i,e as o,b as n,w as p,r as s,o as g}from"./app-DQAvLgyB.js";const d={};function c(m,e){const t=s("font");return g(),r("div",null,[e[13]||(e[13]=a('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为$O(log_2N)$。</p><p>红黑树必须满足以下条件：</p><ol><li><p>必须有颜色（黑/红）</p></li><li><p>根节点颜色为黑</p></li><li><p>若节点是红色，则子节点必须是黑色（反之则不然）</p></li><li><p>到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色）</p></li></ol><p>如果不满足可以通过以下方式修正：</p><ul><li>改变节点颜色</li><li>旋转（左、右）</li></ul><h2 id="旋转" tabindex="-1"><a class="header-anchor" href="#旋转"><span>旋转</span></a></h2><p>以某个支点旋转（右旋为例，旋转时注意更新各个节点的父节点）：</p><p>本质是将该<code>节点a</code>向下进一位插入到其<code>右节点b</code>原先的位置，将其<code>左节点c</code>向上进一位插入到该<code>节点a</code>原先的位置，并将<code>左节点c的右节点</code>赋值给该<code>节点a</code>。</p><p>步骤：</p><ol><li><p>将该<code>节点a</code>放到<code>右节点b</code>的位置，将该``左节点 c<code>放到</code>节点 a`原先的位置，依次类推</p></li><li><p>特殊的，将该<code>点a的内侧孙子</code>（<code>a的左子节点c</code>的<code>右子节点d</code>）断开与其<code>父节点c</code>的连接，转而连接到<code>a</code>上，成为<code>a的左子节点</code></p></li></ol><p>如图，依次插入<code>6,34,23</code>，<strong>以<code>34</code>为支点右旋</strong>：</p><img src="https://jixiaoyong.github.io/images/20181223175956.png" width="50%" height="50%">',13)),i("p",null,[e[2]||(e[2]=o("对获得的结果，由于")),n(t,{color:"#ff0000"},{default:p(()=>e[0]||(e[0]=[o("23")])),_:1}),e[3]||(e[3]=o("，")),n(t,{color:"#ff0000"},{default:p(()=>e[1]||(e[1]=[o("34")])),_:1}),e[4]||(e[4]=o("都是红色违反了")),e[5]||(e[5]=i("code",null,"规则3",-1)),e[6]||(e[6]=o("，将")),e[7]||(e[7]=i("code",null,"34的父节点23",-1)),e[8]||(e[8]=o("设置黑，")),e[9]||(e[9]=i("code",null,"祖父节点6",-1)),e[10]||(e[10]=o("设为红，")),e[11]||(e[11]=i("strong",null,[o("以"),i("code",null,"祖父节6"),o("点为支点左旋")],-1)),e[12]||(e[12]=o("："))]),e[14]||(e[14]=a('<figure><img src="https://jixiaoyong.github.io/images/20181223180637.png" alt="最终结果" tabindex="0" loading="lazy"><figcaption>最终结果</figcaption></figure><h2 id="插入" tabindex="-1"><a class="header-anchor" href="#插入"><span>插入</span></a></h2><p>每次插入红色节点，能够避免规则 4。</p><p>一般先以二叉搜索树的规则将数据插入表中，然后再对照规则检查是否需要调整红黑树。</p><p>红黑树插入情况分类如下：</p><ol><li>插入位置为根节点，将节点颜色更改为黑色</li><li>插入位置的父节点为根节点或父节点颜色为黑色，直接插入</li><li>父节点为红色。</li></ol><p>只有父节点为红色这种情况需要进行修正，这时又可以细分为以下三种情况：</p><figure><img src="https://jixiaoyong.github.io/images/20181223182532.jpg" alt="表格来自 http://www.cnblogs.com/skywang12345/p/3245399.html#a1" tabindex="0" loading="lazy"><figcaption>表格来自 <a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a1" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/skywang12345/p/3245399.html#a1</a></figcaption></figure><p>【注意】对于<code>Case 3</code>当祖父节点没有<strong>左节点</strong>无法右旋时的特殊处理：</p><p>需要对先对当前节点的父节点进行右旋，再以父节点作为<strong>新插入的点 N</strong>，将 N 的父节点设置为黑色，祖父节点设置为红色，以祖父节点为支点左旋。</p><p>如依次插入如下值：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>32,3,53,13,983,[137],237,83,483,43,183</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当插入<code>137</code>后红黑树如图：</p><figure><img src="https://jixiaoyong.github.io/images/20181223210305.png" alt="插入 137 后的树" tabindex="0" loading="lazy"><figcaption>插入 137 后的树</figcaption></figure><p>本来按照<code>Case 3 父红 叔黑 是左节点 </code> 应该要以祖节点右旋，但是组节点 53 没有左子节点，无法右旋，所以先对父节点 983 进行右旋：</p><figure><img src="https://jixiaoyong.github.io/images/20181223210800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>再以<code>983</code>为新节点，<code>父红 叔黑 是右节点</code>，将<code>父节点137</code>设置为黑色，<code>祖节点53</code>设置为红色，以<code>组节点53</code>为支点左旋：</p><figure><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h2><p>删除比较复杂，可以有两种操作：</p><ol><li>在节点中保存一个标志位，标记该节点是否被删除，并不针真的删除该点。</li><li>在执行删除操作时真正删除该点。</li></ol><h2 id="源码" tabindex="-1"><a class="header-anchor" href="#源码"><span>源码</span></a></h2><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/RedBlackTree.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a>查看源码</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2><p><a href="https://sandbox.runjs.cn/show/2nngvn8w" target="_blank" rel="noopener noreferrer">在线操作红黑树</a></p><p><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a1" target="_blank" rel="noopener noreferrer">红黑树 (一) 之 原理和算法详细介绍</a></p>',26))])}const u=l(d,[["render",c]]),b=JSON.parse('{"path":"/posts/11c01876.html","title":"数据结构_红黑树","lang":"zh-CN","frontmatter":{"permalink":"/posts/11c01876.html","title":"数据结构_红黑树","tag":"数据结构","abbrlink":"11c01876","date":"2018-12-23T09:25:36.000Z","updated":"2023-12-30T08:17:02.000Z","isOriginal":true,"description":"前言 红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为$O(log_2N)$。 红黑树必须满足以下条件： 必须有颜色（黑/红） 根节点颜色为黑 若节点是红色，则子节点必须是黑色（反之则不然） 到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色） 如果不满足可以通过以下方式修正： 改变节点...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/11c01876.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"数据结构_红黑树"}],["meta",{"property":"og:description","content":"前言 红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为$O(log_2N)$。 红黑树必须满足以下条件： 必须有颜色（黑/红） 根节点颜色为黑 若节点是红色，则子节点必须是黑色（反之则不然） 到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色） 如果不满足可以通过以下方式修正： 改变节点..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jixiaoyong.github.io/images/20181223180637.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T16:00:22.000Z"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2018-12-23T09:25:36.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T16:00:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构_红黑树\\",\\"image\\":[\\"https://jixiaoyong.github.io/images/20181223180637.png\\",\\"https://jixiaoyong.github.io/images/20181223182532.jpg\\",\\"https://jixiaoyong.github.io/images/20181223210305.png\\",\\"https://jixiaoyong.github.io/images/20181223210800.png\\",\\"https://jixiaoyong.github.io/images/20181223211217.png\\"],\\"datePublished\\":\\"2018-12-23T09:25:36.000Z\\",\\"dateModified\\":\\"2024-05-31T16:00:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"git":{"createdTime":1653726847000,"updatedTime":1717171222000,"contributors":[{"name":"jixiaoyong","username":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":5,"url":"https://github.com/jixiaoyong"},{"name":"JI,XIAOYONG","username":"","email":"jixiaoyong1995@gmail.com","commits":1}]},"readingTime":{"minutes":3.21,"words":962},"filePathRelative":"_posts/数据结构_红黑树.md","localizedDate":"2018年12月23日","excerpt":"<h2>前言</h2>\\n<p>红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为$O(log_2N)$。</p>\\n<p>红黑树必须满足以下条件：</p>\\n<ol>\\n<li>\\n<p>必须有颜色（黑/红）</p>\\n</li>\\n<li>\\n<p>根节点颜色为黑</p>\\n</li>\\n<li>\\n<p>若节点是红色，则子节点必须是黑色（反之则不然）</p>\\n</li>\\n<li>\\n<p>到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色）</p>\\n</li>\\n</ol>\\n<p>如果不满足可以通过以下方式修正：</p>\\n<ul>\\n<li>改变节点颜色</li>\\n<li>旋转（左、右）</li>\\n</ul>","autoDesc":true}');export{u as comp,b as data};
