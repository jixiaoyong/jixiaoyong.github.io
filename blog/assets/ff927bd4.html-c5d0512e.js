import{_ as o,r as p,o as c,c as l,a as n,b as a,d as e,e as t}from"./app-16aa99a6.js";const d={},i=n("img",{src:"https://images.pexels.com/photos/159644/art-supplies-brushes-rulers-scissors-159644.jpeg?cs=srgb&dl=art-supplies-arts-and-crafts-ballpens-159644.jpg&fm=jpg",class:"full-image"},null,-1),r={href:"https://www.pexels.com/@pixabay?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.pexels.com/photo/pencils-in-stainless-steel-bucket-159644/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels",target:"_blank",rel:"noopener noreferrer"},k=t(`<p><code>HashMap</code>使用由<code>Node&lt;K,V&gt;</code>（继承自<code>Map.Entry&lt;K,V&gt;</code>）组成的<strong>数组</strong><code>table</code>保存数据。</p><p>在<code>table</code>中保存数据时根据<code>key</code>的<code>hashCode</code>计算到一个<strong>随机保存位置（但都在<code>table</code>数组的大小范围内）</strong>，当存储的<strong>数据总量</strong>超过加载系数<code>loadFactor</code>规定的<strong>阈值</strong>时则对<code>table</code>进行<strong>扩容</strong>。</p><h2 id="hashmap-有以下全局变量" tabindex="-1"><a class="header-anchor" href="#hashmap-有以下全局变量" aria-hidden="true">#</a> HashMap 有以下全局变量</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment">//实际保存键值对的数组</span>
<span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrySet<span class="token punctuation">;</span><span class="token comment">//Holds cached entrySet().用来遍历 HashMap</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment">//本 HashMap 实际保存的键值对个数</span>
<span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token comment">//HashMap 修改的次数，每次修改 HashMap 都会叠加，</span>
<span class="token comment">//用来在遍历的过程中检查 HashMap 是否被改动过来，如果有则抛出异常 ConcurrentModificationException</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment">//是否扩容的阈值</span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token comment">//加载系数，默认 0.75f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),h=n("p",null,[n("code",null,"loadFactor"),a("：默认的负载因子"),n("strong",null,"0.75"),a("是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下：")],-1),m=n("p",null,"如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Load factor 的值；",-1),v=n("p",null,[a("相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子"),n("code",null,"loadFactor"),a("的值，这个值可以大于 1。")],-1),b={href:"https://tech.meituan.com/2016/06/24/java-hashmap.html",target:"_blank",rel:"noopener noreferrer"},g=t(`<p>每个<code>Node</code>包含了以下信息：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token class-name">V</span> value<span class="token punctuation">;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在执行<code>hashMap.put(&quot;k&quot;, &quot;v&quot;);</code>时，会先计算<code>key</code>的<code>hash</code>值</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//这里原始 hash 值 (32 位) 的高位和地位进行按位异或（不同为，相同为 0），</span>
  <span class="token comment">//增加了随机性，避免因为 hashCode 计算得到的 hash 值（低位相同概率高）</span>
  <span class="token comment">//计算索引时（见下文↓）一直取低位值而可能导致的索引一直的重复问题。</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="v-put-k-key-v-value" tabindex="-1"><a class="header-anchor" href="#v-put-k-key-v-value" aria-hidden="true">#</a> <code>V put(K key, V value)</code></h2><p>使用<code>HashMap</code>保存数据时：</p><ol><li><p>使用<code>hash(Object key)</code>计算<code>key</code>的<code>hash</code>值</p></li><li><p>通过<code>hash</code>值计算<code>value</code>应该保存的位置<code>i</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>i <span class="token operator">=</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash
<span class="token comment">//由于 table.length 限定为 2 的 n 次方，所以上面的等式相当于给 table.length 取余数</span>
<span class="token comment">//即 i 永远&lt;=table.length</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此时会判断是否需要扩容 (<strong>只有<code>table</code>为空，或者当前存储的数据总数<code>size</code>大于阈值<code>threshold</code>时才会扩容</strong><code>resize()</code>)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>threshold <span class="token operator">=</span> capacity <span class="token operator">*</span> loadFactor
阈值 <span class="token operator">=</span> 容量 <span class="token operator">*</span> 负载系数（默认为 <span class="token number">0.75</span>）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>接下来会插入数据</p><ul><li>指定位置为空（没有<em>hash 冲突</em>），或已有<code>key</code>相同的值：则直接插入<code>value</code></li><li>已经存在值并且数量大于 8：则将链表转化为红黑树（JDK1.8），否则以链表形式保存数据</li><li>在移除数据时，如果红黑树数量小于 6：则将红黑树转化为链表</li></ul></li></ol>`,7),_=n("p",null,"在 JDK1.7 中，数据以数组或链表形式保存，JDK1.8 中则新增了红黑树。",-1),f=n("p",null,"发生 hash 冲突时，JDK1.7 采用采用头插法，可能会产生逆序和环形链表；JDK1.8 采用尾插法，直接插入链表或红黑树尾部。",-1),y={href:"https://blog.csdn.net/qq_36520235/article/details/82417949",target:"_blank",rel:"noopener noreferrer"},j=t(`<h2 id="v-get-object-key" tabindex="-1"><a class="header-anchor" href="#v-get-object-key" aria-hidden="true">#</a> <code>V get(Object key)</code></h2><p>使用<code>HashMap</code>获取数据时：</p><ol><li><p>计算 key 的<code>hash值</code></p></li><li><p>查找对应位置的<code>node</code></p><ul><li><p><code>null</code>：返回<code>null</code></p></li><li><p><code>node</code>不为空且<code>key</code>一致：返回该<code>node</code></p></li><li><p><code>node</code>不为空且<code>key</code>不一致：</p><p>如果是<em>链表</em>：遍历链表查找是否存在与<code>key</code>一致的<code>node</code></p><p>如果是<em>树</em>：遍历树查找是否存在与<code>key</code>一致的<code>node</code></p></li></ul></li></ol><h2 id="v-remove-object-key" tabindex="-1"><a class="header-anchor" href="#v-remove-object-key" aria-hidden="true">#</a> <code>V remove(Object key)</code></h2><p>使用<code>HashMap</code>移除数据时：</p><p>其大体过程与<code>get(Object key)</code>类似，遍历找到对应的<code>node</code>并删除。</p><h2 id="计算索引" tabindex="-1"><a class="header-anchor" href="#计算索引" aria-hidden="true">#</a> 计算索引</h2><p>一个<code>key</code>对应的索引<code>index</code>是由这个<code>key</code>的<code>hash()</code>值对<code>HashMap</code>的数组长度<code>length</code>的余数：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>index <span class="token operator">=</span> hash <span class="token operator">%</span> length<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>又有**在<code>Length</code>为 2<sup>n</sup>**时：</p><p>hash % 2<sup>n</sup> = hash &amp; ( 2<sup>n</sup> - 1)</p><blockquote><p>hash % 2<sup>n</sup> = hash - (hash / 2<sup>n</sup>) * 2<sup>n</sup><br> = hash - (hash&gt;&gt;n) * 2<sup>n</sup><br> = hash &amp; ( 2<sup>n</sup> - 1)</p></blockquote><p>而<code>HashMap</code>的长度<code>Length</code>又只能是 2<sup>n</sup>，所以：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>index <span class="token operator">=</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="保存值" tabindex="-1"><a class="header-anchor" href="#保存值" aria-hidden="true">#</a> 保存值</h2><ul><li><p>当<code>table</code>为空或者长度超过加载因子<code>DEFAULT_LOAD_FACTOR</code>规定的容量 (默认容量为 16，加载因子为 0.75) 时会自动扩容。</p></li><li><p>当<code>table[index]</code>为空时，直接新建<code>Node</code>并保存到<code>table[index]</code>中。</p></li><li><p>当<code>table[index]</code>不为空时：</p><ul><li>如果是同一个<code>key</code>则覆盖旧的值</li><li>如果是不同的<code>key</code>则先尝试以链表保存数据</li><li>如果是不同的<code>key</code>，并且链表长度超过<code>MIN_TREEIFY_CAPACITY</code>规定的长度（默认 64），则将链表转化为红黑树 (JDK1.8 新增)</li></ul></li></ul><h2 id="序列化" tabindex="-1"><a class="header-anchor" href="#序列化" aria-hidden="true">#</a> 序列化</h2><p>在<a href="#HashMap%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">第一节</a>我们可以看到，<code>HashMap</code>的很多变量都被标记为<code>transient</code>，这表示在<code>Serializable</code>序列化时不主动去序列化这些值，那这样岂不是没法反序列化这些数据了？</p><p>其实在后面我们可以看到，<strong><code>HashMap</code>在<code>writeObject()</code>方法中主动保存了部分数据</strong>（原因是默认的<code>Serializable</code>由于不同 JVM 实现对同一对象如<code>String</code>的<code>HashCode</code>不一定一致，会导致严重的问题——<code>HashMap</code>基于<code>hash</code>值保存数据）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>ObjectOutputStream</span> s<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> buckets <span class="token operator">=</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//容量</span>
    <span class="token comment">// Write out the threshold, loadfactor, and any hidden stuff</span>
    s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>buckets<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//保存 size</span>
    <span class="token function">internalWriteEntries</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//保存 table 数据</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
* table 不为空则返回 table 长度
* 否则 threshold 不为空则返回 threshold
* 否则返回默认的 DEFAULT_INITIAL_CAPACITY
*/</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>table <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> table<span class="token punctuation">.</span>length <span class="token operator">:</span>
            <span class="token punctuation">(</span>threshold <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> threshold <span class="token operator">:</span>
            <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并在<code>readObject()</code>恢复了这些值。</p><h2 id="位运算" tabindex="-1"><a class="header-anchor" href="#位运算" aria-hidden="true">#</a> 位运算</h2><table><thead><tr><th>位运算</th><th>符号</th><th>计算</th></tr></thead><tbody><tr><td>按位与</td><td>&amp;</td><td>相同为 1，不同为 0</td></tr><tr><td>按位或</td><td>|</td><td>有 1 则 1</td></tr><tr><td>按位异或</td><td>^</td><td>相同为 0，不同位 1</td></tr><tr><td>按位取反</td><td>~</td><td></td></tr><tr><td>左移</td><td>&lt;&lt;</td><td>相当于乘以 2<sup>n</sup></td></tr><tr><td>右移</td><td><code>&gt;&gt;</code></td><td>相当于除以 2<sup>n</sup></td></tr><tr><td>无符号右移</td><td><code>&gt;&gt;&gt;</code></td><td></td></tr></tbody></table><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,24),w={href:"https://www.zhihu.com/question/28562088/answer/111668116",target:"_blank",rel:"noopener noreferrer"},x={href:"http://baijiahao.baidu.com/s?id=1646023968436883100&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"},M={href:"https://blog.csdn.net/changhangshi/article/details/82114727",target:"_blank",rel:"noopener noreferrer"},H={href:"https://blog.csdn.net/qq_36520235/article/details/82417949",target:"_blank",rel:"noopener noreferrer"},E={href:"https://tech.meituan.com/2016/06/24/java-hashmap.html",target:"_blank",rel:"noopener noreferrer"},C={href:"http://www.blogjava.net/killme2008/archive/2009/04/15/265721.html",target:"_blank",rel:"noopener noreferrer"},V={href:"https://coderanch.com/t/469720/java/HashMap-Entry-transient",target:"_blank",rel:"noopener noreferrer"},I={href:"https://segmentfault.com/q/1010000000630486",target:"_blank",rel:"noopener noreferrer"};function K(A,q){const s=p("ExternalLinkIcon");return c(),l("div",null,[i,n("p",null,[a("Photo by **"),n("a",r,[a("Pixabay "),e(s)]),a("**from "),n("strong",null,[n("a",u,[a("Pexels"),e(s)])])]),k,n("blockquote",null,[h,m,v,n("p",null,[n("a",b,[a("https://tech.meituan.com/2016/06/24/java-hashmap.html"),e(s)])])]),g,n("blockquote",null,[_,f,n("p",null,[a("具体 JDK1.7 与 1.8 对比查看"),n("a",y,[a("这里"),e(s)])])]),j,n("p",null,[n("a",w,[a("HashCode 计算扰动分析 - 关于 hashMap 的一些按位与计算的问题？ - 胖君的回答 - 知乎 "),e(s)])]),n("p",null,[n("a",x,[a("一文读懂 Java 之 HashMap 索引位置计算"),e(s)])]),n("p",null,[n("a",M,[a("hashMap 在 jdk1.7 与 jdk1.8 中的原理及不同"),e(s)])]),n("p",null,[n("a",H,[a("真实面试题之：Hashmap 的结构，1.7 和 1.8 有哪些区别"),e(s)])]),n("p",null,[n("a",E,[a("Java 8 系列之重新认识 HashMap"),e(s)])]),n("p",null,[n("a",C,[a("java.util.HashMap 源码要点浅析"),e(s)])]),n("p",null,[n("a",V,[a("Why HashMap.Entry is transient?"),e(s)])]),n("p",null,[n("a",I,[a("Java 中 HashMap 关键字 transient 的疑惑"),e(s)])])])}const N=o(d,[["render",K],["__file","ff927bd4.html.vue"]]);export{N as default};
