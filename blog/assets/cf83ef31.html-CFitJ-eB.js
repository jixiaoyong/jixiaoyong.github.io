import{_ as t,c as a,a as o,o as r}from"./app-3cnvzyR2.js";const n={};function i(s,e){return r(),a("div",null,e[0]||(e[0]=[o('<h2 id="简述" tabindex="-1"><a class="header-anchor" href="#简述"><span>简述</span></a></h2><p>本文介绍了 java 虚拟机类加载机制。</p><h2 id="类加载机制" tabindex="-1"><a class="header-anchor" href="#类加载机制"><span>类加载机制</span></a></h2><p>JVM 类加载一共 7 步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的 1,2,3 步，在实际中有可能从其中间某一步开始。</p><p>类加载机制一般分为三部分：<strong>加载 Loading -&gt; 连接 Linking -&gt; 初始化 Initializing</strong></p><figure><img src="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true" alt="JVM Class Loader" tabindex="0" loading="lazy"><figcaption>JVM Class Loader</figcaption></figure><p>其中<strong>加载、验证、准备和初始化</strong>发生的顺序是确定的，但<strong>解析</strong>可以在初始化之后开始（java 动态绑定）</p><blockquote><p>java 绑定分为静态绑定和动态绑定：</p><ul><li><strong>静态绑定</strong>：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对 java，简单的可以理解为程序编译期的绑定。java 当中的方法只有 final，static，private 和构造方法是前期绑定的。</li><li><strong>动态绑定</strong>：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在 java 中，几乎所有的方法都是后期绑定的。</li></ul><p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/ns_code/article/details/17881581</a></p></blockquote><h2 id="类加载机制具体过程" tabindex="-1"><a class="header-anchor" href="#类加载机制具体过程"><span>类加载机制具体过程</span></a></h2><h3 id="i-loading" tabindex="-1"><a class="header-anchor" href="#i-loading"><span>**I.Loading **</span></a></h3><p><strong>加载</strong>，JVM 将文件（class，jar，zip，网络等）中的二进制字节流保存到虚拟机方法区和堆中，并用该二进制表示形式创建类或者接口的过程。</p><blockquote><p>Loading is the process of finding the binary representation of a class or interface type with a particular name and <em>creating</em> a class or interface from that binary representation</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html</a> (<em>英文文档若无特殊说明都是引用官方文档，下同</em>)</p></blockquote><ol><li><p>用<strong>类全限定名</strong>获取类的二进制字节流</p></li><li><p>将字节流中<strong>静态存储结构</strong>转化为<strong>方法区</strong>的运行时数据结构</p></li><li><p><u><em>在<strong>堆</strong>中生成一个代表该类的 java.lang.Class 对象，作为方法区数据的访问入口。</em></u></p><p>（<s><strong>这句话存疑</strong> ，有人说<a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener noreferrer">在堆中</a> ,也有人说在<a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener noreferrer">方法区</a> ,官方文档未相关描述</s></p><p><code>2019/01/12 更新</code> Class 对象没有明确规定实在<strong>JAVA 堆</strong>中，对应 HotSpot 虚拟机来说，该对象在<strong>方法区</strong>中）</p></li></ol><p>类加载的地方是开发人员可控性最强的地方。除了可以使用系统的 ClassLoader 外还可以自定义 ClassLoader（后文详述）。</p><p>类加载根据加载的类不同分为两种：</p><ul><li>非数组类 使用系统/自定义的类加载器完成加载</li><li>数组类 数组类不通过类加载器创建，而是通过 JVM 直接创建，但是数组类的元素类型要通过类加载器创建</li></ul><p>数组类的元素加载，根据数组元素的类型不同，分为两类：</p><ul><li>引用类 通过普通类加载器加载，并将数组用该类加载器标识</li><li>非引用类 将数组与引导类加载器标识</li></ul><p>数组类的可见性与其元素类的可见性一致。</p><hr><h3 id="ii-linking" tabindex="-1"><a class="header-anchor" href="#ii-linking"><span>**II.Linking **</span></a></h3><p><strong>连接</strong>，是将类或者接口组合到 java 虚拟机运行状态的过程，这样他就可以被运行。</p><blockquote><p>Linking is the process of taking a class or interface and combining(组合) it into the run-time state of the Java Virtual Machine so that it can be executed(运行)</p></blockquote><p>连接一般分为 3 部分：验证 Verification、准备 Preparation、解析 Resolution。</p><blockquote><p>Linking a class or interface involves(包括) verifying and preparing(验证和准备) that class or interface, its direct(直接) superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.</p></blockquote><h4 id="verification" tabindex="-1"><a class="header-anchor" href="#verification"><span><strong>Verification</strong></span></a></h4><p><strong>验证</strong>，保证 class 文件中的字节流信息符合虚拟机的要求。</p><blockquote><p>Verification(<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.10" target="_blank" rel="noopener noreferrer">§4.10</a>) ensures that the binary representation(二进制格式) of a class or interface is structurally correct(结构正确) (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.9" target="_blank" rel="noopener noreferrer">§4.9</a>). Verification may cause additional classes and interfaces to be loaded (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener noreferrer">§5.3</a>) but need not cause them to be verified or prepared.</p></blockquote><p>验证内容包括：</p><ol><li>文件格式验证，验证字节流符合 class 文件格式规范；</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h4 id="preparation" tabindex="-1"><a class="header-anchor" href="#preparation"><span>**Preparation **</span></a></h4><p><strong>准备</strong>，在方法区对类变量分配内存，<strong>初始化为默认值</strong>（“零值”）。</p><p>比如：<code>static int i = 5；</code>在这一步只会进行到<code>i = 0</code> ，而<code>i = 5</code>要在初始化那一步才进行；</p><p>但是如果是 final 修饰的<strong>常量</strong>，则在此分配具体值。</p><blockquote><p><em>Preparation</em> involves creating the static fields for a class or interface and initializing such fields to their default values (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.3" target="_blank" rel="noopener noreferrer">§2.3</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.4" target="_blank" rel="noopener noreferrer">§2.4</a>). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener noreferrer">§5.5</a>), not preparation.</p></blockquote><p>准备工作可能在创建之后的任何时候发生，但是必须在初始化之前完成。</p><h4 id="resolution" tabindex="-1"><a class="header-anchor" href="#resolution"><span><strong>Resolution</strong></span></a></h4><p><strong>解析</strong>，是在运行时常量池中动态确定符号引用的具体值的过程。</p><p>每个栈帧 frame 都有一个<code>当前方法</code>到<code>运行时常量池</code> 的引用，用来支持方法代码 (method code) 的<strong>动态链接（dynamic linking）</strong>。</p><p>method code：要被执行的方法以及通过符号引用的变量。</p><blockquote><p>Each frame (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener noreferrer">§2.6</a>) contains a reference to the run-time constant pool (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener noreferrer">§2.5.5</a>) for the type of the current method to support <em>dynamic linking</em> of the method code.</p></blockquote><p>动态链接将符号引用（symbolic references）转化为具体方法的调用（concrete method references）即直接引用，根据需要加载类来解析未定义的符号，将变量访问转化为运行时内存（runtime location）。</p><blockquote><p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p><p><em>方法和变量的这种后期绑定，使得方法使用的其他类的更改不太可能破坏这个代码。</em></p><p>直接引用可以直接定位到内存中某一段地址；符号引用则与 JVM 内存无管</p></blockquote><p>解析分为：</p><ol><li>类，接口解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><hr><h3 id="iii-initialization" tabindex="-1"><a class="header-anchor" href="#iii-initialization"><span><strong>III.Initialization</strong></span></a></h3><p><strong>初始化</strong> ，<em>Initialization</em> of a class or interface consists of executing its class or interface initialization method（执行类，接口的构造方法<code>clinit()</code>）</p><p>类或接口在被初始化之前，必须先被连接 linked（verified, prepared, and optionally（可选）resolved.）。</p><p>初始化有且只有以下五种情况：</p><ul><li><code>new</code>、读取/设置类（只有直接定义其的类才会，子类等不受影响）的静态变量（final 修饰的常量除外）、执行静态方法</li><li><code>java.lang.reflect</code>反射调用类</li><li>初始化时，如果父类未初始化，先触发父类的初始化（接口类除外）</li><li>虚拟机等启动时执行主类的<code>main()</code>方法时，需要先初始化主类</li><li>JDK1.7 动态支持时，如果<code>java.lang.invoke.MethodHandle</code>实例最后解析结果<code>REF_get/put/invokeStatic的方法句柄对应的类未被初始化时，需要先初始化对应的类</code></li></ul><p>以上 5 种称为对一个类的<strong>主动引用</strong>，其余不会触发初始化，称为<strong>被动引用</strong></p><p><code>clinit()</code> ,有<strong>类变量赋值，静态语句块</strong>会由编译器合并为<code>clinit()</code>方法，分为两种：</p><ol><li>类 父类的<code>clinit()</code>方法会先于子类执行</li><li>接口 接口<code>clinit()</code>方法无需调用父类接口的<code>clinit()</code>方法；接口的实现类也无需执行接口的<code>clinit()</code>方法</li></ol><p><code>clinit()</code> 是线程安全的，在同一个类加载器中，多个线程的中只会有<strong>一个线程执行一次<code>clinit()</code></strong>，其余线程阻塞等待</p><p><code>clinit()</code>和<code>init()</code>不同如下：</p><blockquote><p><strong>init</strong>是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行 init 方法<u>（是在<strong>new 对象</strong>的时候<strong>初始化非静态变量</strong>）</u>；</p><p>而 clinit 是类构造器方法，也就是在 jvm 进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段 jvm 会调用 clinit 方法<u>（是在<strong>JVM 初始化类</strong>的时候<strong>初始化静态变量</strong>）</u>。</p><p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/u013309870/article/details/72975536</a></p></blockquote><p>如果类没有静态赋值、静态语句块等则不会有<code>clinit()</code>方法。</p><p><code>clinit()</code>先于<code>init()</code>执行。</p><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener noreferrer">Java Virtual Machine Specification Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.2" target="_blank" rel="noopener noreferrer">Chapter 2. The Structure of the Java Virtual Machine</a></p><p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener noreferrer">【深入 Java 虚拟机】之四：类加载机制</a></p><p><a href="http://blog.csdn.net/zhangliangzi/article/details/51319033" target="_blank" rel="noopener noreferrer">JVM 类加载机制详解（一）JVM 类加载过程</a></p><p><a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener noreferrer">Jvm 系列 3—类的加载 - Gityuan 博客 | 袁辉辉博客 </a></p><p><a href="http://wiki.jikexueyuan.com/project/java-vm/class-loading-mechanism.html" target="_blank" rel="noopener noreferrer">类加载机制 - 深入理解 Java 虚拟机 - 极客学院 Wiki </a></p><p><a href="http://blog.csdn.net/javazejian/article/details/70768369" target="_blank" rel="noopener noreferrer">深入理解 Java 类型信息 (Class 对象) 与反射机制 - CSDN 博客</a></p><p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener noreferrer">深入理解 jvm--Java 中 init 和 clinit 区别完全解析 - CSDN 博客</a></p>',68)]))}const c=t(n,[["render",i]]),p=JSON.parse('{"path":"/posts/cf83ef31.html","title":"JVM 类加载机制解析","lang":"zh-CN","frontmatter":{"permalink":"/posts/cf83ef31.html","title":"JVM 类加载机制解析","tag":"jvm","abbrlink":"cf83ef31","date":"2018-02-26T11:28:56.000Z","updated":"2023-12-30T08:17:02.000Z","isOriginal":true,"description":"简述 本文介绍了 java 虚拟机类加载机制。 类加载机制 JVM 类加载一共 7 步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的 1,2,3 步，在实际中有可能从其中间某一步开始。 类加载机制一般分为三部分：加载 Loading -> 连接 Linking -> 初始化 Initializing JVM Class LoaderJVM ...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/cf83ef31.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"JVM 类加载机制解析"}],["meta",{"property":"og:description","content":"简述 本文介绍了 java 虚拟机类加载机制。 类加载机制 JVM 类加载一共 7 步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的 1,2,3 步，在实际中有可能从其中间某一步开始。 类加载机制一般分为三部分：加载 Loading -> 连接 Linking -> 初始化 Initializing JVM Class LoaderJVM ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-04T03:36:59.000Z"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2018-02-26T11:28:56.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-04T03:36:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM 类加载机制解析\\",\\"image\\":[\\"https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true\\"],\\"datePublished\\":\\"2018-02-26T11:28:56.000Z\\",\\"dateModified\\":\\"2024-06-04T03:36:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"git":{"createdTime":1653726847000,"updatedTime":1717472219000,"contributors":[{"name":"jixiaoyong","username":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":4,"url":"https://github.com/jixiaoyong"},{"name":"JI,XIAOYONG","username":"","email":"jixiaoyong1995@gmail.com","commits":2}]},"readingTime":{"minutes":7.29,"words":2186},"filePathRelative":"_posts/JVM类加载机制解析.md","localizedDate":"2018年2月26日","excerpt":"<h2>简述</h2>\\n<p>本文介绍了 java 虚拟机类加载机制。</p>\\n<h2>类加载机制</h2>\\n<p>JVM 类加载一共 7 步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的 1,2,3 步，在实际中有可能从其中间某一步开始。</p>\\n<p>类加载机制一般分为三部分：<strong>加载 Loading -&gt; 连接 Linking -&gt; 初始化 Initializing</strong></p>\\n<figure><img src=\\"https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true\\" alt=\\"JVM Class Loader\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>JVM Class Loader</figcaption></figure>","autoDesc":true}');export{c as comp,p as data};
