import{_ as i,c as s,o as a,a as e}from"./app-BmPdx_eZ.js";const n={},l=e(`<p>Flutter 默认提供了<strong>Image</strong>用于从网络、文件等加载图片，并且使用<strong>ImageCache</strong>统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了<a href="https://github.com/Baseflow/flutter_cached_network_image" target="_blank" rel="noopener noreferrer">flutter_cached_network_image</a>、<a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">extended_image</a>等基于 Flutter 原生的解决方案，以及<a href="https://github.com/alibaba/power_image" target="_blank" rel="noopener noreferrer">power_image</a>等基于混合开发的解决方案。</p><p>本文对 Flutter 中的 Image 加载过程、原理做一简单分析。</p><h2 id="图片展示的流程" tabindex="-1"><a class="header-anchor" href="#图片展示的流程"><span>图片展示的流程</span></a></h2><p>首先，简单梳理一下图片从加载到展示的过程。</p><h3 id="image" tabindex="-1"><a class="header-anchor" href="#image"><span>Image</span></a></h3><p><em><code>A widget that displays an image.</code></em></p><p>在查看 Image 具体实现之前，先了解几个基础方法：</p><ul><li><code>ImageConfiguration createLocalImageConfiguration(BuildContext context, { Size? size })</code> ：创建 <strong>ImageConfiguration</strong>，一般用于 <code>state.didChangeDependencies</code> 等依赖变化时会调用的地方，其创建的 ImageConfiguration 对象会传入 <code>BoxPainter.paint</code> 或者 <code>ImageProvider.resolver</code> 方法中以用来获取 <strong>ImageStream</strong>。</li><li><code>Future&lt;void&gt; precacheImage(...)</code> 预先加载 image 到 <strong>ImageCache</strong> 中，以便 Image、BoxDecoration、FadeInImage 等能够更快地加载 image。</li></ul><p>Image 是 Flutter 中用于展示图片的 Widget，主要有如下用法：</p><ul><li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.html" target="_blank" rel="noopener noreferrer">Image.new</a>, for obtaining an image from an <a href="https://api.flutter.dev/flutter/painting/ImageProvider-class.html" target="_blank" rel="noopener noreferrer">ImageProvider</a>.</li><li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.asset.html" target="_blank" rel="noopener noreferrer">Image.asset</a>, for obtaining an image from an <a href="https://api.flutter.dev/flutter/services/AssetBundle-class.html" target="_blank" rel="noopener noreferrer">AssetBundle</a> using a key.</li><li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.network.html" target="_blank" rel="noopener noreferrer">Image.network</a>, for obtaining an image from a URL.</li><li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.file.html" target="_blank" rel="noopener noreferrer">Image.file</a>, for obtaining an image from a <a href="https://api.flutter.dev/flutter/dart-io/File-class.html" target="_blank" rel="noopener noreferrer">File</a>.</li><li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.memory.html" target="_blank" rel="noopener noreferrer">Image.memory</a>, for obtaining an image from a <a href="https://api.flutter.dev/flutter/dart-typed_data/Uint8List-class.html" target="_blank" rel="noopener noreferrer">Uint8List</a>.</li></ul><p>支持的格式有：JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP，以及依赖于特定设备的格式（Flutter 会尝试使用平台 API 解析未知格式）。</p><p>通过指定<code>cacheWidth</code>和<code>cacheHeight</code>可以让引擎按照指定大小解码图片，可以降低 ImageCache 占用的内存。</p><p><code>Image(...)</code>构造函数中只有一个必传项<code>ImageProvider image</code>用于获取图片，其余四种构造方法也都是在此方法的基础上分别指定了各自的 <strong>ImageProvider</strong>，以<code>Image.network</code>为例：</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Image</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">network</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> src, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    Key</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> key,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    double</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> scale </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ...,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    int</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> cacheWidth,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    int</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> cacheHeight,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> ResizeImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">resizeIfNeeded</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(cacheWidth, cacheHeight, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(src, scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> scale, headers</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> headers)),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">       ...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">       super</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> key);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的 ResizeImage，NetworkImage 等都继承自 <strong>ImageProvider</strong>，<code>ImageProvider.resolve</code>方法创建并返回 <strong>ImageStream</strong> 供 <strong>Image</strong> 使用，内部通过<code>ImageProvider.resolveStreamForKey</code>方法从 <strong>ImageCache</strong> 或者子类指定的途径（比如 NetworkImage 会从网络）加载图片（并保存到 ImageCache）。</p><h3 id="imagestate" tabindex="-1"><a class="header-anchor" href="#imagestate"><span>_ImageState</span></a></h3><p><strong>Image</strong>是 <em>StatefulWidget</em>，处理 image 的主要逻辑在 <strong>_ImageState</strong> 中：其混入了<strong>WidgetsBindingObserver</strong>以便监听系统生命周期；在内部通过监听<strong>ImageStream</strong>获得<strong>ImageInfo</strong>并最终在<code>_ImageState.build</code>方法中创建<strong>RawImage</strong>；RawImage 是一个<em>LeafRenderObjectWidget</em>，会创建<strong>RenderImage</strong>并在<code>RenderImage.paint</code>根据之前获取的信息调用<code>DecorationImagePainter.paintImage</code>方法通过<code>canvas.drawImageRect</code>绘制图片。</p><h4 id="resolveimage" tabindex="-1"><a class="header-anchor" href="#resolveimage"><span>_resolveImage</span></a></h4><p>当依赖变化（<code>didChangeDependencies()</code>）、Widget 变化（<code>didUpdateWidget(Image oldWidget)</code>）、以及热更新（<code>reassemble()</code>）时，_ImageState 会执行<code>_resolveImage()</code>方法通过 ImageProvider 获取 ImageStream：</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _resolveImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // ScrollAwareImageProvider 用于防止在快速滑动的时候加载图片</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> ScrollAwareImageProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> provider </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> ScrollAwareImageProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      context</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _scrollAwareContext,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      imageProvider</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.image,</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 用户/构造方法指定的 ImageProvider</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    );</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 通过 ImageProvider 获取 ImageStream</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> ImageStream</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> newStream </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      provider.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createLocalImageConfiguration</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        context,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        size</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ?</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> Size</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(widget.width</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, widget.height</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      ));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    assert</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(newStream </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    _updateSourceStream</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(newStream);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还可以注意到，当在<code>_resolveImage()</code>中获取到 ImageStream 之后，会通过<code>_updateSourceStream()</code>更新 ImageStream。</p><h4 id="updatesourcestream" tabindex="-1"><a class="header-anchor" href="#updatesourcestream"><span>_updateSourceStream</span></a></h4><p>在此方法中，先是更新了<code>ImageStream? _imageStream</code> 对象，然后根据<code>_isListeningToStream</code>的值执行<code>_imageStream!.addListener(_getListener())</code>更新 ImageStream 的 Listener：</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageStreamListener</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _getListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> recreateListener </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(_imageStreamListener </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> recreateListener) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _lastException </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _lastStack </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _imageStreamListener </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> ImageStreamListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        _handleImageFrame,</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 图片加载成功，使用获得的 imageInfo 更新 RawImage</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        onChunk</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.loadingBuilder </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ?</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _handleImageChunk,</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 展示 loading 动画</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        onError</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.errorBuilder </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> kDebugMode</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            ?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> error, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">StackTrace</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> stackTrace) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">               ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">              }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            :</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 展示加载失败</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _imageStreamListener</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在 <strong>ImageStreamListener</strong> 中，根据 ImageStream 的不同状态分别更新 Image 的显示。</p><h4 id="handleimageframe" tabindex="-1"><a class="header-anchor" href="#handleimageframe"><span>_handleImageFrame</span></a></h4><p><code>_handleImageFrame()</code>方法使用 ImageStream 中返回的<strong>ImageInfo</strong>，调用<code>setState</code>方法更新_ImageState 中的<code>ImageInfo? **_imageInfo**</code>属性，从而刷新 Image 展示。</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _handleImageFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> imageInfo, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> synchronousCall) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    setState</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      _replaceImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(info</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> imageInfo);</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 在这里刷新 imageInfo，触发重建</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _loadingProgress </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _lastException </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _lastStack </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _frameNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _frameNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ?</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _frameNumber</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _wasSynchronouslyLoaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _wasSynchronouslyLoaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> synchronousCall;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _replaceImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">required</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> ImageInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> info}) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    _imageInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    _imageInfo </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> info;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ImageInfo</strong>类内部持有<strong>ui.Image</strong>和其对应的<code>scale</code>，以及一个获取图片像素大小的<code>sizeBytes</code>方法。</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// ImageInfo: a [dart:ui.Image] object with its corresponding scale.</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">required</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.image, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.scale </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.debugLabel })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> sizeBytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="build" tabindex="-1"><a class="header-anchor" href="#build"><span>build</span></a></h4><p>上面分析了_ImageState 如何监听使用 ImageProvider 获取到的 ImageStream，从中获取 ImageInfo 更新自己的 <code>ImageInfo? _imageInfo</code> 属性，那么这个属性是如何影响到我们的 Image 展示图片的呢，关键就在 <code>build</code> 方法中：</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Widget</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> build</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">BuildContext</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> context) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (_lastException </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (widget.errorBuilder </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">errorBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">!(context, _lastException</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, _lastStack);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (kDebugMode)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _debugBuildErrorWidget</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(context, _lastException</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 注意_ImageState 内部其实是使用 ui.Image _imageInfo?.image 创建了 RawImage 来展示图片</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    Widget</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> RawImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // Do not clone the image, because RawImage is a stateless wrapper.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // The image will be disposed by this state object when it is not needed</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // anymore, such as when it is unmounted or when the image stream pushes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // a new image.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      image</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _imageInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.image,</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这里会在 ImageStream 获取到 ImageInfo 之后更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      debugImageLabel</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _imageInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.debugLabel,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      width</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.width,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      height</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.height,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _imageInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.scale </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      color</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.color,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      opacity</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.opacity,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      colorBlendMode</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.colorBlendMode,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      fit</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.fit,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      alignment</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.alignment,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      repeat</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.repeat,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      centerSlice</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.centerSlice,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      matchTextDirection</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.matchTextDirection,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      invertColors</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _invertColors,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      isAntiAlias</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.isAntiAlias,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      filterQuality</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.filterQuality,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">widget.excludeFromSemantics) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      result </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> Semantics</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        container</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.semanticLabel </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        image</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        label</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.semanticLabel </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">??</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        child</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> result,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (widget.frameBuilder </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      result </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">frameBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">!(context, result, _frameNumber, _wasSynchronouslyLoaded);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (widget.loadingBuilder </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">   // 如果有 loadingBuilder 就包裹 result，所以注意进度为 100% 时要切换回图片，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">   // 否则会一直显示进度，而非加载的图片</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      result </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> widget.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">loadingBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">!(context, result, _loadingProgress);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ImageInfo.image</code> 是<strong>ui.Image</strong>对象，是原始的 image 像素，通过<strong>RawImage</strong>传入到<code>Canvas.drawImageRect</code>或者<code>Canvas.drawImageNine</code>绘制图片。</p><h3 id="rawimage" tabindex="-1"><a class="header-anchor" href="#rawimage"><span>RawImage</span></a></h3><p><em>A widget that displays a <code>[dart:ui.Image]</code> directly.</em></p><p>RawImage 继承自 <em>LeafRenderWidget</em>，可以直接展示<code>ui.Image</code>的内容，后者是解码的图片数据的不透明句柄（<em>Opaque handle to raw decoded image data (pixels)</em>）、是对<code>_Image</code>类的封装、对外提供宽高以及<code>Image.toByteData</code>（将<code>ui.Image</code>对象转化为<code>ByteData</code>，ByteData 可以直接传入<code>Canvas.drawImageRect</code>方法第一个参数）。</p><p>RawImage 主要逻辑就是创建/更新 RenderImage 的时候将从<code>_ImageState.build</code>方法获得的<code>ui.Image? image</code> 的 clone 传入（其实就是使用<code>ui.Image? image</code>对应的<code>_Image _image</code> 新建了一个 ui.Image，每一个 ui.Image 都是_image 的一个句柄，只有当没有 ui.Image 指向_image 时后者才会真正的 dispose）。</p><h3 id="renderimage" tabindex="-1"><a class="header-anchor" href="#renderimage"><span>RenderImage</span></a></h3><p><em>An image in the render tree.</em></p><p>RenderImage 作为一个 RenderBox，在从 RawImage 那里拿到<code>ui.Image? _image</code>之后，然后在其<code>RenderImage.paint</code>方法中，会调用<code>paintImage</code>方法绘制<code>_image</code>代表的图片。</p><blockquote><p>ui.Image 实际是 ui._Image 的包装类，它的 width、height、toByteData 等方法最终都是调用 ui._Image 对应的实现。</p></blockquote><p><code>paintImage</code> 方法是位于 <em>lib\\src\\painting\\decoration_image.dart</em> 的全局方法，在其内部调用 canvas 绘制_image 对应的图片。</p><br><p>至此，我们可以看到，在<strong>Image</strong>中，根据构造方法的不同创建了不同的<strong>ImageProvider</strong>对象作为<code>Image.image</code>参数；</p><p>然后在 <strong>_ImageState</strong> 中，使用<code>ImageProvider.resolve</code>方法创建并更新<code>ImageStream? _imageStream</code>，并且监听<strong>ImageStream</strong>以便在图片加载成功之后获取<code>ImageInfo? _imageInfo</code>；</p><p>这个<strong>ImageInfo</strong>是对<strong>ui.Image</strong>的封装类，在<code>_ImageState.build</code>方法中被传入<strong>RawImage</strong>，后者则创建了<strong>RenderImage</strong>并最终将 ui.Image 的内容绘制在屏幕上面。</p><br><h2 id="图片获取与缓存" tabindex="-1"><a class="header-anchor" href="#图片获取与缓存"><span>图片获取与缓存</span></a></h2><p>到目前为止，我们大体梳理了图片展示的这部分流程，此外，还有一部分同样重要的流程——图片的获取与缓存。</p><h3 id="imageprovider" tabindex="-1"><a class="header-anchor" href="#imageprovider"><span>ImageProvider</span></a></h3><p><strong>ImageProvider</strong> 是获取图片资源的基类，其他类可以调用<code>ImageProvider.resolve</code>方法获取 <strong>ImageStream</strong> ，此方法会调用<code>ImageCache.putIfAbsent</code>优先从 <strong>ImageCache</strong> 中获取，如果没有则调用<code>ImageProvider.load</code>方法获取并缓存到 ImageCache 中。</p><p>其子类一般只需要重写<code>ImageProvider</code>的<code>ImageStreamCompleter load(T key, DecoderCallback decode)</code>和<code>Future&lt;T&gt; obtainKey(ImageConfiguration configuration)</code>方法即可。</p><p>以<code>NetworkImage</code>加载网络图片的过程为例：</p><blockquote><p>我们通过<code>NetworkImage()</code>方法获取的实际是<code>network_image.NetworkImage</code>对象。</p></blockquote><p>当<code>_ImageState._resolveImage()</code>方法调用<code>ImageProvider.resolve</code>方法时，内部会调用<code>ImageProvider.resolveStreamForKey</code>方法，在其内部会执行：</p><ul><li>通过<code>ImageProvider.obtainKey</code>获取图片对应的 key</li><li>执行<code>PaintingBinding.*instance*!.imageCache!.putIfAbsent(key,() =&gt;</code> <code>load(key, PaintingBinding.*instance*!.instantiateImageCodec),onError: handleError,)</code>方法，优先从 imageCache 中获取缓存的图片，没有的话执行<code>ImageProvider.load</code>方法获取图片。</li></ul><p>对于<code>network_image.NetworkImage</code>对象，他的<code>obtainKey()</code>和<code>load()</code>方法实现如下：</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> NetworkImage</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image_provider.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;image_provider.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">implements</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image_provider.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.url, { </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.scale </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.headers })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> @override</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">  Future</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">obtainKey</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(image_provider.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageConfiguration</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> configuration) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 注意这里的 key 是 NetworkImage 对象，也就是说网络图片加载的 url，scale，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // header 等一致的话才会被认为命中缓存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> SynchronousFuture</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> @override</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">  ImageStreamCompleter</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> load</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(image_provider.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> key, image_provider.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">DecoderCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> decode) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // Ownership of this controller is handed off to [_loadAsync]; it is that</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // method&#39;s responsibility to close the controller&#39;s stream when the image</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // has been loaded or an error is thrown.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> StreamController</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageChunkEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; chunkEvents </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> StreamController</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageChunkEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> MultiFrameImageStreamCompleter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      codec</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> _loadAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, chunkEvents, decode),</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 真正从网络加载图片的方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      chunkEvents</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> chunkEvents.stream,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> key.scale,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      debugLabel</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> key.url,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      informationCollector</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">DiagnosticsNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">        DiagnosticsProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;image_provider.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;Image provider&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">        DiagnosticsProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;image_provider.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">NetworkImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;Image key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, key),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这其中，<code>network_image.NetworkImage._loadAsync()</code>方法才是真正使用<code>HttpClient</code>从网上获取图片资源的方法（实际上 AssetBundleImageProvider、FileImage 和 MemoryImage 等一众 ImageProvider 等都约定俗成在<code>_loadAsync</code> 中执行真正获取图片的逻辑），返回值 Future&lt;ui.Codec&gt;和 ui.Image 的关系如下：</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Future</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;ui.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Image</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">decodeImageFromList</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Uint8List</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> bytes) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  final</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> ui.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Codec</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> codec </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> await</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> PaintingBinding</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">instantiateImageCodec</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(bytes);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  final</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> ui.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">FrameInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> frameInfo </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> codec.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getNextFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> frameInfo.image;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="imagecache" tabindex="-1"><a class="header-anchor" href="#imagecache"><span>ImageCache</span></a></h3><p><em>Class for caching images.</em></p><p>在上面方分析 ImageProvider 的时候，我们注意到，每次通过<code>ImageProvider.resolveStreamForKey</code>方法获取 ImageStream 时，都会调用<code>PaintingBinding.instance!.imageCache.putIfAbsent</code>方法优先获取<strong>Image 对象的缓存</strong>，这就涉及到和 Image 缓存有关的类——<strong>ImageCache</strong>。</p><p>ImageCache 对象全局唯一，使用 LRU 算法最多缓存<strong>1000 张或者最大 100MB 图片</strong>，可以分别使用<code>maximumSize</code>和<code>maximumSizeBytes</code>修改配置。</p><p>其内部维持有三个 Map：</p><ul><li><code>Map&lt;Object, PendingImage&gt; _pendingImages</code> 正在加载中的图片，可能可能同时也是<code>_liveImage</code>（对应的 ImageStream 已经被监听了）。</li><li><code>Map&lt;Object, _CachedImage&gt; _cache</code> 缓存的图片，maximumSize 和 maximumSizeBytes 限制针对的是<code>_cache</code>。</li><li><code>Map&lt;Object, _LiveImage&gt; _liveImages</code> 正在使用的图片，他的 ImageStreamCompleters 至少有一个 listener，可能同时在<code>_pendingImages</code>（所以这里的_LiveImage 的<code>sizeBytes</code>可能为 null）或者<code>_liveImages</code>中。</li></ul><p><code>_CachedImage</code>和<code>_LiveImage</code>都继承自<code>_CachedImageBase</code>，其内部持有<code>ImageStreamCompleter</code>，图片的 handler<code>ImageStreamCompleterHandle</code>，以及图片大小<code>sizeBytes</code>。</p><p><code>ImageCacheStatus</code>处理 ImageCache 缓存的图片状态：</p><ul><li><code>pending</code>，还没有加载完成的 image，如果被监听的话，还会是<code>live</code>的</li><li><code>keepAlive</code>，图片会被<code>ImageCache._cache</code>保存。可能是 live 的，但不会 pending 的。</li><li><code>live</code>，图片会一直被持有，除非<code>ImageStreamCompleter</code>没有 listener 了。可能是 pending 的，也可能是 keepAlive 的</li><li><code>untracked</code>，不会被缓存的图片（上述三值都为 false）。</li></ul><p>可以使用<code>ImageCache.statusForKey</code>或者<code>ImageProvider.obtainCacheStatus</code>获取图片状态<code>ImageCacheStatus</code>。</p><p>此外，ImageCache 还提供<code>ImageCache.evict</code>方法从缓存中清除指定图片。</p><h4 id="putifabsent" tabindex="-1"><a class="header-anchor" href="#putifabsent"><span>putIfAbsent</span></a></h4><p>当 ImageProvider 调用<code>ImageCache.putIfAbsent</code>方法获取 ImageStreamCompleter 时，会依次尝试从<code>_pendingImages</code> 、<code>_cache</code> 、<code>_liveImages</code> 中读取，如果都没有则会尝试执行传入的 loader 方法获取。</p><div class="language-dart line-numbers-mode" data-highlighter="shiki" data-ext="dart" data-title="dart" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">  ImageStreamCompleter</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> putIfAbsent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> key, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageStreamCompleter</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> Function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() loader, { </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageErrorListener</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> onError }) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    ImageStreamCompleter</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _pendingImages[key]</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.completer;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // Nothing needs to be done because the image hasn&#39;t loaded yet.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 1. 如果图片还在加载中，就直接返回</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (result </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // Remove the provider from the list so that we can move it to the</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // recently used position below.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // Don&#39;t use _touch here, which would trigger a check on cache size that is</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // not needed since this is just moving an existing cache entry to the head.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> _CachedImage</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (image </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // The image might have been keptAlive but had no listeners (so not live).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // Make sure the cache starts tracking it as live again.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // 2. 如果_cache 中已经有了，就将其加入_liveImages 并返回</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      _trackLiveImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        key,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        image.completer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        image.sizeBytes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _cache[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image.completer;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 3. 如果_liveImages 中已经有了，而 cache 中没有，就加入_cache，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 此时会检测大小和数量（这种属于图片刚下载完，或者已有缓存被清理）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> _LiveImage</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> liveImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _liveImages[key];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (liveImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      _touch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        key,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">        _CachedImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">          liveImage.completer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">          sizeBytes</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> liveImage.sizeBytes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        ),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        timelineTask,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      );</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">kReleaseMode) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        timelineTask</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">finish</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">dynamic</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;result&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;keepAlive&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> liveImage.completer;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 4.1 如果_pendingImages、_cacheImages、_liveImages 中都没有，就去下载</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 并加入到_liveImages 中，此时_LiveImage.sizeBytes 为 null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 注意这里只是加入到_liveImages 中追踪，并未使用_cache，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 故而也【不受其最大数量和最大总大小约束】</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      result </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> loader</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      _trackLiveImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key, result, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (error, stackTrace) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // If we&#39;re doing tracing, we need to make sure that we don&#39;t try to finish</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // the trace entry multiple times if we get re-entrant calls from a multi-</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // frame provider here.</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    bool</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> listenedOnce </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // We shouldn&#39;t use the _pendingImages map if the cache is disabled, but we</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // will have to listen to the image at least once so we don&#39;t leak it in</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // the live image tracking.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // If the cache is disabled, this variable will be set.</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">    _PendingImage</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> untrackedPendingImage;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 图片加载过程中的回调</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> listener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">ImageInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> info, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> syncCall) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">      int</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> sizeBytes;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (info </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        sizeBytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> info.sizeBytes;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        info.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      final</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> _CachedImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> image </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> _CachedImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        result</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        sizeBytes</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> sizeBytes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      _trackLiveImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key, result, sizeBytes);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // Only touch if the cache was enabled when resolve was initially called.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // 4.2 图片加载成功，如果有缓存，就将此图片加入_cache 中，此时会检测大小和数量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // 并且这里的 sizeBytes 是图片实际大小</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (untrackedPendingImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        _touch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key, image, listenerTask);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        image.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      final</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> _PendingImage</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> pendingImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> untrackedPendingImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">??</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> _pendingImages.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (pendingImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        pendingImage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">removeListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      listenedOnce </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    final</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> ImageStreamListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> streamListener </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> ImageStreamListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(listener);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (maximumSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> maximumSizeBytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      _pendingImages[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> _PendingImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(result, streamListener);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      untrackedPendingImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> _PendingImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(result, streamListener);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // Listener is removed in [_PendingImage.removeListener].</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    result.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">addListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(streamListener);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过上述分析可以知道，当_cache、_liveImages、_pendingImages 中都没有指定图片时，会从网络下载（或者磁盘、asset 等），而在图片完全加载完成之前，_pendingImages 中下载图片所占大小是没有被 ImageCache 追踪的，也就是说<strong>ImageCache._cache 的最大个数和总大小限制都不会管理这部分图片</strong>；故而面对大量高清大图加载的场景（比如，五列 1:1 网格加载平均大小几 Mb 的网络图片），如果<strong>快速滑动</strong>会导致_pendingImages 急速增大，这样下载中且还未完全下载的图片所占用的内存会逐渐累计，从而导致 Flutter APP<strong>内存暴增，页面卡顿</strong>等（本地资源不容易出现是因为从 load 到图片加载完成间隔比较短，而网络图片由于网速等导致_pendingImages 中会累计很多正在下载中的图片，会比较明显）。</p><p>那些在 Flutter 中加载图片并且完全采用 ImageCache 管理图片内存的图片加载框架比如 Image/ExtendedImage/CachedNetworkImage 等都存在此问题；阿里的 PowerImage 由于将图片下载这个过程交给了原生成熟的图片加载库处理，使得 ImageCache 只管理已经加载完成的图片，从而避免了上述情况。</p><br><p>可以看到，以从网络加载图片为例，Flutter 原生提供的 Image 只有内存中的 ImageCache 一级缓存，如果 ImageCache 没有指定的图片（首次加载或者缓存被清空）则会再次从网络加载，这会导致多图列表的时候图片被频繁的回收/重新下载，从而影响用户体验。</p><p>为了解决上述问题，涌现了很多第三方图片加载控件：</p><ul><li><a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">extended_image</a> 对官方 Image 的二次开发，增加了磁盘缓存。</li><li><a href="https://github.com/Baseflow/flutter_cached_network_image" target="_blank" rel="noopener noreferrer">flutter_cached_network_image</a> 使用<em>sqflite 数据库</em>管理缓存的<strong>网络图片加载</strong>库，增加了磁盘缓存。</li><li><a href="https://github.com/alibaba/power_image" target="_blank" rel="noopener noreferrer">power_image</a> 使用于<strong>混合项目</strong>的图片加载库，提供<em>ffi</em>和<em>texture</em>两种图片展示方式，依赖于原生图片加载库（比如<em>Glide</em>）加载图片、管理缓存。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>简单总结一下 Flutter 原生 Image 组件加载图片的流程：</p><figure><img src="https://jixiaoyong.github.io/images/flutter_image_class_structure.png" alt="flutter_image_class_structure.png" tabindex="0" loading="lazy"><figcaption>flutter_image_class_structure.png</figcaption></figure><p>简单来说如下：</p><ul><li>用户通过 Image Widget 的各个构造方法创建指定的 ImageProvider；</li><li>在_ImageState 中使用<code>ImageProvider.resolve(ImageConfiguration)</code>获取并监听 ImageStream（listener 为 ImageStreamListener）；</li><li>ImageProvider 会按照传入的 ImageConfiguration 生成的 key 在 ImageCache 中查找对应的缓存，没有的话则先加载再缓存；</li><li>当 ImageProvider 成功加载图片时，ImageStreamListener 获得 ImageInfo 时，并触发<code>_ImageState.build()</code>方法将<code>ui.Image _imageInfo?.image</code>传入 RawImage 中；</li><li>作为一个 LeafRenderObjectWidget，RawImage 创建 RenderImage 并传入<code>ui.Image? image?.clone()</code>作为<code>RenderImage.image</code>，此后再在<code>RenderImage.paint</code>方法中调用系统的<code>paintImage()</code>方法通过<code>canvas.drawImageRect</code>绘制图片内容。</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://api.flutter.dev/flutter/widgets/Image-class.html" target="_blank" rel="noopener noreferrer">Image_api.flutter.dev</a><br><a href="https://mp.weixin.qq.com/s/alglGvnNKIzr7f8SwRZucA" target="_blank" rel="noopener noreferrer">京东在 Flutter 加载大量图片导致的内存溢出的优化实践</a></p>`,88),t=[l];function h(k,p){return a(),s("div",null,t)}const d=i(n,[["render",h],["__file","1912667a.html.vue"]]),g=JSON.parse('{"path":"/posts/1912667a.html","title":"Flutter 图片加载方案分析之 Image","lang":"zh-CN","frontmatter":{"permalink":"/posts/1912667a.html","title":"Flutter 图片加载方案分析之 Image","tag":"flutter","date":"2022-07-27T07:31:03.000Z","updated":"2023-12-30T08:17:02.000Z","abbrlink":"1912667a","isOriginal":true,"description":"Flutter 默认提供了Image用于从网络、文件等加载图片，并且使用ImageCache统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了flutter_cached_network_image、extended_image等基于 Flutter 原生的...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/1912667a.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"Flutter 图片加载方案分析之 Image"}],["meta",{"property":"og:description","content":"Flutter 默认提供了Image用于从网络、文件等加载图片，并且使用ImageCache统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了flutter_cached_network_image、extended_image等基于 Flutter 原生的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jixiaoyong.github.io/images/flutter_image_class_structure.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-04T03:36:59.000Z"}],["meta",{"property":"article:author","content":"JI,XIAOYONG"}],["meta",{"property":"article:tag","content":"flutter"}],["meta",{"property":"article:published_time","content":"2022-07-27T07:31:03.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-04T03:36:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Flutter 图片加载方案分析之 Image\\",\\"image\\":[\\"https://jixiaoyong.github.io/images/flutter_image_class_structure.png\\"],\\"datePublished\\":\\"2022-07-27T07:31:03.000Z\\",\\"dateModified\\":\\"2024-06-04T03:36:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"图片展示的流程","slug":"图片展示的流程","link":"#图片展示的流程","children":[{"level":3,"title":"Image","slug":"image","link":"#image","children":[]},{"level":3,"title":"_ImageState","slug":"imagestate","link":"#imagestate","children":[{"level":4,"title":"_resolveImage","slug":"resolveimage","link":"#resolveimage","children":[]},{"level":4,"title":"_updateSourceStream","slug":"updatesourcestream","link":"#updatesourcestream","children":[]},{"level":4,"title":"_handleImageFrame","slug":"handleimageframe","link":"#handleimageframe","children":[]},{"level":4,"title":"build","slug":"build","link":"#build","children":[]}]},{"level":3,"title":"RawImage","slug":"rawimage","link":"#rawimage","children":[]},{"level":3,"title":"RenderImage","slug":"renderimage","link":"#renderimage","children":[]}]},{"level":2,"title":"图片获取与缓存","slug":"图片获取与缓存","link":"#图片获取与缓存","children":[{"level":3,"title":"ImageProvider","slug":"imageprovider","link":"#imageprovider","children":[]},{"level":3,"title":"ImageCache","slug":"imagecache","link":"#imagecache","children":[{"level":4,"title":"putIfAbsent","slug":"putifabsent","link":"#putifabsent","children":[]}]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1659256602000,"updatedTime":1717472219000,"contributors":[{"name":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":3},{"name":"JI,XIAOYONG","email":"jixiaoyong1995@gmail.com","commits":2}]},"readingTime":{"minutes":13.19,"words":3957},"filePathRelative":"_posts/Flutter图片加载方案分析之Image.md","localizedDate":"2022年7月27日","excerpt":"<p>Flutter 默认提供了<strong>Image</strong>用于从网络、文件等加载图片，并且使用<strong>ImageCache</strong>统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了<a href=\\"https://github.com/Baseflow/flutter_cached_network_image\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">flutter_cached_network_image</a>、<a href=\\"https://github.com/fluttercandies/extended_image\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">extended_image</a>等基于 Flutter 原生的解决方案，以及<a href=\\"https://github.com/alibaba/power_image\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">power_image</a>等基于混合开发的解决方案。</p>","autoDesc":true}');export{d as comp,g as data};
