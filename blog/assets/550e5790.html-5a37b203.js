import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as s,c as l,a as e,b as t,d as n,e as o}from"./app-b04f94c7.js";const p={},c={href:"https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md",target:"_blank",rel:"noopener noreferrer"},m=o('<p>Dart VM is a collection of components for executing Dart code natively. Notably, it includes the following:</p><ul><li><strong>Runtime System</strong><ul><li>Object Model</li><li>Garbage Collection</li><li>Snapshots</li></ul></li><li><strong>Core libraries’ native methods</strong></li><li><strong>Development Experience components</strong> accessible via <em>service protocol</em> * Debugging * Profiling * Hot-reload</li><li><strong>Just-in-Time (JIT) and Ahead-of-Time (AOT) compilation pipelines</strong></li><li><strong>Interpreter</strong></li><li><strong>ARM simulators</strong></li></ul><p>下图是runtime执行代码的示意图：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/isolates.png" alt="isolate" tabindex="0" loading="lazy"><figcaption>isolate</figcaption></figure><p>isolate中有两种Thread：</p><ul><li>一个mutator thread用来执行dart 代码</li><li>多个helper thread 用来执行GC、JIT等</li></ul><p>此外，一个isolate有一个heap，用来存储所有的dart object（GC发生在这里）。</p><p>一个OSThread一次只能进入一个isolate，当其进入之后，该isolate的mutator thread便和这个OSThread关联起来执行dart代码。当OSThread要进入一个isolate的时候，必须先退出当前关联的isolate。</p><p>isolate的mutator thread可能在不同时间关联不同的OSThread，但同一时刻最多只能有一个OSThread。</p>',9),d=e("em",null,"dill files",-1),g={href:"https://github.com/dart-lang/sdk/blob/main/pkg/kernel/README.md",target:"_blank",rel:"noopener noreferrer"},h=e("p",null,"一般来说，从Dart source code到Dart VM执行分为下面几步：",-1),u=e("figure",null,[e("img",{src:"https://jixiaoyong.github.io/images/dart_vm/dart-to-kernel.png",alt:"dart-to-kernel",tabindex:"0",loading:"lazy"}),e("figcaption",null,"dart-to-kernel")],-1),f=e("em",null,[e("strong",null,"Kernel binaries")],-1),b=e("em",null,"dill files",-1),_={href:"https://github.com/dart-lang/sdk/blob/main/pkg/kernel/README.md",target:"_blank",rel:"noopener noreferrer"},y=e("strong",null,"Dart source",-1),v=e("strong",null,"Kernel AST",-1),x={href:"https://github.com/dart-lang/sdk/tree/master/pkg/front_end",target:"_blank",rel:"noopener noreferrer"},z=e("strong",null,"CFE",-1),k=o('<p>Dart VM has multiple ways to execute the code, for example:</p><ul><li>from source or Kernel binary using <strong>JIT</strong>;</li><li>from snapshots: <ul><li>from <strong>AOT</strong> snapshot;</li><li>from <strong>AppJIT</strong> snapshot.</li></ul></li></ul><h1 id="_1-running-from-source-via-jit" tabindex="-1"><a class="header-anchor" href="#_1-running-from-source-via-jit" aria-hidden="true">#</a> 1. Running from source via JIT.</h1><h2 id="从dart-source加载到vm中" tabindex="-1"><a class="header-anchor" href="#从dart-source加载到vm中" aria-hidden="true">#</a> 从Dart Source加载到VM中</h2><p>为了保证直接从源代码执行Dart的便利性，独立的dart可执行文件承载了一个称为内核服务（*kernel service）*的辅助isolate，它处理Dart源代码编译成内核的过程。然后，VM将运行产生的内核二进制文件（Kernel Binary）。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-service.png" alt="kernel-service" tabindex="0" loading="lazy"><figcaption>kernel-service</figcaption></figure><p>上图中，一个被称为<em>kernel service</em>的isolate使用CFE将Dart Source编译为为<em>Kernel Binary</em>然后交给main isolate执行。</p><p>这并不是安排CFE和VM执行Dart Source的唯一方式，比如Flutter就将CFE（封装之后的）和VM分别置于两个设备上：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/flutter-cfe.png" alt="flutter-cfe" tabindex="0" loading="lazy"><figcaption>flutter-cfe</figcaption></figure><p>当热更新触发时，Flutter使用封装过的CFE以及一个Flutter独有的Kernel-to-Kernel转换，将修改过的Dart Source编译为Kernel Binary，然后推送到设备上面（比如手机）执行。</p><h2 id="在vm中执行" tabindex="-1"><a class="header-anchor" href="#在vm中执行" aria-hidden="true">#</a> 在VM中执行</h2><p>上面是Dart Source加载到VM的过程，下面是<strong>Dart代码在VM中执行的过程</strong>分析：</p><p>1）当<em>Kernel Binary</em>加载到VM中之后，只会解析加载的类和库的基本信息。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-1.png" alt="kernel-loaded-1" tabindex="0" loading="lazy"><figcaption>kernel-loaded-1</figcaption></figure><p>2）当runtime实际用到的时候才会去获取完整的信息用来创建对象分配内存等：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-2.png" alt="kernel-loaded-2" tabindex="0" loading="lazy"><figcaption>kernel-loaded-2</figcaption></figure><p>此时，从<em>Kernel Binary</em>中读取出了<em>class members</em>，此时已经有足够的信息让runtime用来调用方法（successfully resolve and invoke methods）了，比如调用main方法，但是<strong>具体的方法体此时依旧还没有被反序列</strong>（deserialized）。</p><p>3）在这个阶段，所有的function只是持有了一个真正要执行的方法体的<em>placeholder</em>指向<em>LazyCompileStub</em>，当runtime要执行的时候再创建并运行可执行代码。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/raw-function-lazy-compile.png" alt="raw-function-lazy-compile" tabindex="0" loading="lazy"><figcaption>raw-function-lazy-compile</figcaption></figure><p>这时候执行方法有两个阶段：</p><ol><li><strong>unoptimized</strong> 默认执行时直接从<em>Kernel Binary</em>创建<em>IL</em>然后转化为<em>machine code</em>并运行</li><li><strong>optimized</strong> 在a阶段的热点代码会被从普通<em>IL</em>优化为<em>SSA IL</em>，然后转化为<em>machine code</em>运行，如果遇到优化失效的，再回退到a阶段执行代码（后面是否需要再走b阶段，需要重新判断）</li></ol><h3 id="unoptimized-code" tabindex="-1"><a class="header-anchor" href="#unoptimized-code" aria-hidden="true">#</a> unoptimized code</h3><p>这个阶段，从<em>Kernel Binary</em>生成<em>Machine Code</em>主要分为2步：</p><p><strong>（1）<em>Kernel Binary</em> → <em>IL</em></strong></p><p>在这个阶段，从<em>Kernel Binary</em>中的<em>AST</em>中解析产生对应的<em>control flow graph</em>(<strong>CFG</strong>)。</p><blockquote><p>CFG由<em>intermediate language</em>(<strong>IL</strong>)组成，这个阶段使用的IL指令类似基于stack的虚拟机：他们从stack中读取操作数，执行操作，然后将结果push回这个stack中。</p></blockquote><figure><img src="https://jixiaoyong.github.io/images/dart_vm/unoptimized-compilation.png" alt="unoptimized-compilation" tabindex="0" loading="lazy"><figcaption>unoptimized-compilation</figcaption></figure><p>但并不是所有的方法都有对应的<em>Dart/Kernel AST bodies</em>（比如一些<em>native</em>方法或者<em>artificial tear-off functions</em> generated by Dart VM），这种情况下，他们凭空创建（<em>in these cases IL is just created from the thin air</em>）。</p><p><strong>(2) <em>IL</em> → <em>Machine Code</em></strong></p><p>由一条IL对应生成多行machine language instruction</p><p>在这个阶段不会进行优化，主要目的是快速创建出可执行代码（<em>produce executable code quickly</em>）</p><p><strong>内联缓存（inline caching）</strong></p><p>在这个阶段，编译器（<em>unoptimizing compiler</em>）不会尝试静态解析任何没有在Kernel Binary中解析的调用（<em>any calls that were not resolved in Kernel binary</em>），因此调用(<code>MethodInvocation</code> or <code>PropertyGet</code> AST nodes)被认为是完全动态的， VM使用内联缓存（inline caching）来实现动态调用。</p><p>内联缓存的实现主要有：</p><ul><li>一个<strong>call site specific cache</strong>，将调用的类与方法映射在一起，如果receiver和已有的缓存类对应，那么就应该调用对应的方法，还有个计数器（<em>invocation frequency counters</em>）标记这个方法被调用多少次（对应下文的RawICData）</li><li>一个共享的<strong>lookup stub</strong>，实现了方法调用的最快路径（<em>method invocation fast path</em>），在发生调用时通过lookup stub查询是否有entry与receiver的类匹配，有的话就用调用entry并增加frequency counter；否则就调用系统的runtime system helper兜底（如果成功运行了就更新上面的缓存，这样下次调用就不用再走runtime了）。</li></ul><figure><img src="https://jixiaoyong.github.io/images/dart_vm/inline-cache-1.png" alt="inline-cache-1" tabindex="0" loading="lazy"><figcaption>inline-cache-1</figcaption></figure><aside> 💡 **Unoptimizing compiler** by itself is enough to execute any possible Dart code.</aside><h3 id="optimized-code" tabindex="-1"><a class="header-anchor" href="#optimized-code" aria-hidden="true">#</a> optimized code</h3><p>虽然<strong>Unoptimizing compiler</strong>可以执行任意Dart代码，但是太慢了，所以在以上述方式执行代码的同时会记录以下信息：</p><ul><li>Inline cache收集在调用点的<strong>receiver类型</strong>（<em>receiver types observed at callsites</em>）</li><li>和方法对应的execution counters以及basic blocks within functions追踪代码的<strong>热点区域</strong>（hot regions of the code）</li></ul><p>Optimized compilations 和Unoptimizing compiler开始的步骤类似：</p><p><strong>(1) <em>Kernel Binary</em> → <em>unoptimized IL</em></strong></p><p><strong>(2) <em>unoptimized IL</em> → <em>SSA based IL</em> → <em>optimized IL</em></strong></p><p>当上述代码执行的时候，如果程序调用计数器（<em>invocation frequency counters</em>）到达某个阈值，这个方法就会被交给一个后台优化编译器（<em>background optimizing compiler</em>）来优化，将unoptimized IL转化为*SSA（static single assignment）*形式的IL。</p><p>最后将SSA IL优化为optimized IL。</p><p><strong>(3) <em>optimized IL</em> → <em>machine code</em></strong></p><p>在优化完成后，编译器会要求mutator thread进入safepoint并将优化后的代码绑定到方法上（attaches optimized code to the function）。</p><blockquote><p>safepoint的含义是，thread关联的state（比如heap，stack frame等）是一致的，并且可以在不中断线程的情况下访问或修改。通常意味着thread被暂停，或者在当前环境外（比如执行native代码）。</p></blockquote><figure><img src="https://jixiaoyong.github.io/images/dart_vm/optimizing-compilation.png" alt="optimizing-compilation" tabindex="0" loading="lazy"><figcaption>optimizing-compilation</figcaption></figure><p>上述这种基于乐观假设的优化，可能没法处理部分情况，从而回退到未优化的代码（deoptimization），然后再执行未优化过程（通常会丢弃优化后的代码，再判断是否有热点代码需要优化），主要有2种方式：</p><ol><li><em><strong>eager deoptimization</strong></em> 在内联检查的时候，判断优化的条件是否满足，不满足的话就丢弃优化代码</li><li><em><strong>lazy deoptimization</strong></em> 全局分析指示在更改优化代码的内容时丢弃优化代码（之前优化的条件不满足了）。</li></ol><h1 id="_2-running-from-aot-snapshot" tabindex="-1"><a class="header-anchor" href="#_2-running-from-aot-snapshot" aria-hidden="true">#</a> 2. Running from <strong>AOT</strong> snapshot</h1><p>Snapshot&#39;s format is low level and optimized for fast startup，包含了要创建的object以及如何关联这些对象的说明信息（instructions）。</p><p>VM可以将Heap/甚至是Heap中的object graph序列化成为snapshot，然后再从这个snapshot中重建对应的状态：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot.png" alt="snapshot" tabindex="0" loading="lazy"><figcaption>snapshot</figcaption></figure><p>最初的snapshot并不包含machine code，直到AOT compiler的出现。</p><p>AOT compiler和snapshot-with-code使得VM可以在那些JIT受限的设备上运行：</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot-with-code.png" alt="snapshot-with-code" tabindex="0" loading="lazy"><figcaption>snapshot-with-code</figcaption></figure><p><strong>snapshot-with-code</strong>和普通的<strong>snapshot</strong>基本一致，<strong>唯一不同的是多出的machine code不需要deserizlization</strong>，事实上machine code在被分配到内存后可以立即成为heap的一部分（<em>directly become part of the heap after it was mapped into memory</em>）。</p><h1 id="_3-running-from-appjit-snapshot" tabindex="-1"><a class="header-anchor" href="#_3-running-from-appjit-snapshot" aria-hidden="true">#</a> 3. Running from <strong>AppJIT</strong> snapshot</h1><p><strong>AppJIT</strong> snapshot主要用于减少大型Dart application的JIT热身时间。</p><p>AppJIT snapshots were introduced to <strong>reduce JIT warm up time for large Dart applications</strong> like <code>dartanalyzer</code>or <code>dart2js</code>. When these tools are used on small projects they spent as much time doing actual work as VM spends JIT compiling these apps.</p><p>他的主要实现是：先用模拟数据在VM上运行，然后将其生成的code以及VM内部的数据结构序列化为AppJIT snapshot加载到VM中运行，只在正式的数据和模拟训练的配置无法匹配的时候执行JIT（<em>execution profile on the real data does not match execution profile observed during training</em>）。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot-appjit.png" alt="snapshot-appjit" tabindex="0" loading="lazy"><figcaption>snapshot-appjit</figcaption></figure><h1 id="_4-running-from-appaot-snapshot" tabindex="-1"><a class="header-anchor" href="#_4-running-from-appaot-snapshot" aria-hidden="true">#</a> 4. Running from <strong>AppAOT</strong> snapshot</h1><p>AOT与JIT各有优劣：</p><ul><li>AOT启动时间更短</li><li>JIT峰值性能更优</li></ul><p>无法进行JIT意味着</p><ol><li>AOT snapshot <em>must</em> contain executable code for each and every function that could be invoked during application execution;</li><li>the executable code <em>must not</em> rely on any speculative assumptions that could be violated during execution;</li></ol><p>为了满足上述要求， AOT汇编过程会进行全局静态分析以确定程序的哪些部分是可以从已知的entry point触达的，分配哪些类的实例，以及类型在程序中是如何应用的（which parts of the application are reachable from known set of <em>entry points</em>, instances of which classes are allocated and how types flow through the program）。</p><p>AOT上述这些分析是保守的，可能在准确性上犯错，与之相比，JIT则在性能方面不行，因为JIT需要deoptimize兜底实现正确的行为。</p><p>所以AOT将所有潜在的可触达的功能编译为native code，而无需投机性优化（All potentially reachable functions are then compiled to native code without any speculative optimizations）。</p><figure><img src="https://jixiaoyong.github.io/images/dart_vm/aot.png" alt="aot" tabindex="0" loading="lazy"><figcaption>aot</figcaption></figure>',73),T=e("strong",null,"移除不可达的方法",-1),I={href:"https://www.techopedia.com/definition/24299/virtual-method#:~:text=A%20virtual%20method%20is%20a,oriented%20language%2C%20such%20as%20C%23.",target:"_blank",rel:"noopener noreferrer"},w=o('<p>Resulting snapshot can then be run using <em>precompiled runtime</em>, a special variant of the Dart VM which excludes components like JIT and dynamic code loading facilities.</p><h2 id="switchable-calls" tabindex="-1"><a class="header-anchor" href="#switchable-calls" aria-hidden="true">#</a> Switchable Calls</h2><p>即使有全局和局部分析，AOT编译依然可能包含一些无法被非虚拟化（<em>devirtualized</em>）的call sites，为了解决这个问题，AOT编译出的代码和runtime会使用JIT中用到的内联缓存（<em>Inline Caching</em>）技术的拓展——<em><strong>switchable calls</strong></em>。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h1>',4),A={href:"https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md",target:"_blank",rel:"noopener noreferrer"},D={href:"https://www.jianshu.com/p/a5b1997a01ba",target:"_blank",rel:"noopener noreferrer"};function M(j,S){const i=r("ExternalLinkIcon");return s(),l("div",null,[e("blockquote",null,[e("p",null,[t("本文是对Dart官方VM的介绍的总结摘要，推荐直接阅读"),e("a",c,[t("官方原文"),n(i)]),t("。")])]),m,e("p",null,[t("VM执行Dart代码有两种方式：JIT和AOT，不管哪一种都不会直接执行Dart源码，而是经过转化之后的Kernel Binary(also called "),d,t(")which contain serialized "),e("a",g,[t("Kernel ASTs"),n(i)]),t("。")]),h,u,e("blockquote",null,[e("p",null,[t("VM expects to be given "),f,t(" (also called "),b,t(") which contain serialized "),e("a",_,[t("Kernel ASTs"),n(i)]),t(". The task of translating "),y,t(" into "),v,t(" is handled by the "),e("a",x,[t("common front-end ("),z,t(")"),n(i)]),t(" written in Dart and shared between different Dart tools (e.g. VM, dart2js, Dart Dev Compiler).")])]),k,e("p",null,[t("从上图可以看出，AOT中，Kernel Binary先经过TFA收集变量、方法等信息，以此来"),T,t("，并devirtuablize method（确定"),e("a",I,[t("虚拟方法"),n(i)]),t("的具体执行）。之后经过VM再移除一些不可达方法。")]),w,e("p",null,[e("a",A,[t("sdk/index.md at main · dart-lang/sdk"),n(i)])]),e("p",null,[e("a",D,[t("Dart VM 介绍"),n(i)])])])}const O=a(p,[["render",M],["__file","550e5790.html.vue"]]);export{O as default};
