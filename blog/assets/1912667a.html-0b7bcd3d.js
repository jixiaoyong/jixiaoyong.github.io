import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as c,c as i,a,b as n,d as e,e as t}from"./app-979c3f18.js";const l={},u=a("strong",null,"Image",-1),r=a("strong",null,"ImageCache",-1),d={href:"https://github.com/Baseflow/flutter_cached_network_image",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/fluttercandies/extended_image",target:"_blank",rel:"noopener noreferrer"},k={href:"https://github.com/alibaba/power_image",target:"_blank",rel:"noopener noreferrer"},g=t('<p>本文对 Flutter 中的 Image 加载过程、原理做一简单分析。</p><h1 id="图片展示的流程" tabindex="-1"><a class="header-anchor" href="#图片展示的流程" aria-hidden="true">#</a> 图片展示的流程</h1><p>首先，简单梳理一下图片从加载到展示的过程。</p><h2 id="image" tabindex="-1"><a class="header-anchor" href="#image" aria-hidden="true">#</a> Image</h2><p><em><code>A widget that displays an image.</code></em></p><p>在查看 Image 具体实现之前，先了解几个基础方法：</p><ul><li><code>ImageConfiguration createLocalImageConfiguration(BuildContext context, { Size? size })</code> ：创建 <strong>ImageConfiguration</strong>，一般用于 <code>state.didChangeDependencies</code> 等依赖变化时会调用的地方，其创建的 ImageConfiguration 对象会传入 <code>BoxPainter.paint</code> 或者 <code>ImageProvider.resolver</code> 方法中以用来获取 <strong>ImageStream</strong>。</li><li><code>Future&lt;void&gt; precacheImage(...)</code> 预先加载 image 到 <strong>ImageCache</strong> 中，以便 Image、BoxDecoration、FadeInImage 等能够更快地加载 image。</li></ul><p>Image 是 Flutter 中用于展示图片的 Widget，主要有如下用法：</p>',8),v={href:"https://api.flutter.dev/flutter/widgets/Image/Image.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://api.flutter.dev/flutter/painting/ImageProvider-class.html",target:"_blank",rel:"noopener noreferrer"},I={href:"https://api.flutter.dev/flutter/widgets/Image/Image.asset.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://api.flutter.dev/flutter/services/AssetBundle-class.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://api.flutter.dev/flutter/widgets/Image/Image.network.html",target:"_blank",rel:"noopener noreferrer"},f={href:"https://api.flutter.dev/flutter/widgets/Image/Image.file.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://api.flutter.dev/flutter/dart-io/File-class.html",target:"_blank",rel:"noopener noreferrer"},y={href:"https://api.flutter.dev/flutter/widgets/Image/Image.memory.html",target:"_blank",rel:"noopener noreferrer"},S={href:"https://api.flutter.dev/flutter/dart-typed_data/Uint8List-class.html",target:"_blank",rel:"noopener noreferrer"},C=t(`<p>支持的格式有：JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP，以及依赖于特定设备的格式（Flutter 会尝试使用平台 API 解析未知格式）。</p><p>通过指定<code>cacheWidth</code>和<code>cacheHeight</code>可以让引擎按照指定大小解码图片，可以降低 ImageCache 占用的内存。</p><p><code>Image(...)</code>构造函数中只有一个必传项<code>ImageProvider image</code>用于获取图片，其余四种构造方法也都是在此方法的基础上分别指定了各自的 <strong>ImageProvider</strong>，以<code>Image.network</code>为例：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token class-name">Image</span><span class="token punctuation">.</span><span class="token function">network</span><span class="token punctuation">(</span>
    <span class="token class-name">String</span> src<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token class-name">Key</span><span class="token operator">?</span> key<span class="token punctuation">,</span>
    double scale <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>
    int<span class="token operator">?</span> cacheWidth<span class="token punctuation">,</span>
    int<span class="token operator">?</span> cacheHeight<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> image <span class="token operator">=</span> <span class="token class-name">ResizeImage</span><span class="token punctuation">.</span><span class="token function">resizeIfNeeded</span><span class="token punctuation">(</span>cacheWidth<span class="token punctuation">,</span> cacheHeight<span class="token punctuation">,</span> <span class="token class-name">NetworkImage</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> scale<span class="token punctuation">:</span> scale<span class="token punctuation">,</span> headers<span class="token punctuation">:</span> headers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
       <span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的 ResizeImage，NetworkImage 等都继承自 <strong>ImageProvider</strong>，<code>ImageProvider.resolve</code>方法创建并返回 <strong>ImageStream</strong> 供 <strong>Image</strong> 使用，内部通过<code>ImageProvider.resolveStreamForKey</code>方法从 <strong>ImageCache</strong> 或者子类指定的途径（比如 NetworkImage 会从网络）加载图片（并保存到 ImageCache）。</p><h2 id="imagestate" tabindex="-1"><a class="header-anchor" href="#imagestate" aria-hidden="true">#</a> _ImageState</h2><p><strong>Image</strong>是 <em>StatefulWidget</em> ，处理 image 的主要逻辑在 <strong>_ImageState</strong> 中：其混入了<strong>WidgetsBindingObserver</strong>以便监听系统生命周期；在内部通过监听<strong>ImageStream</strong>获得<strong>ImageInfo</strong>并最终在<code>_ImageState.build</code>方法中创建<strong>RawImage</strong>；RawImage 是一个<em>LeafRenderObjectWidget</em>，会创建<strong>RenderImage</strong>并在<code>RenderImage.paint</code>根据之前获取的信息调用<code>DecorationImagePainter.paintImage</code>方法通过<code>canvas.drawImageRect</code>绘制图片。</p><h3 id="resolveimage" tabindex="-1"><a class="header-anchor" href="#resolveimage" aria-hidden="true">#</a> _resolveImage</h3><p>当依赖变化（<code>didChangeDependencies()</code>）、Widget 变化（<code>didUpdateWidget(Image oldWidget)</code>）、以及热更新（<code>reassemble()</code>）时，_ImageState 会执行<code>_resolveImage()</code>方法通过 ImageProvider 获取 ImageStream：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">void</span> <span class="token function">_resolveImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ScrollAwareImageProvider用于防止在快速滑动的时候加载图片</span>
    <span class="token keyword">final</span> <span class="token class-name">ScrollAwareImageProvider</span> provider <span class="token operator">=</span> <span class="token class-name">ScrollAwareImageProvider</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>
      context<span class="token punctuation">:</span> _scrollAwareContext<span class="token punctuation">,</span>
      imageProvider<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>image<span class="token punctuation">,</span><span class="token comment">// 用户/构造方法指定的ImageProvider</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 通过ImageProvider获取ImageStream</span>
    <span class="token keyword">final</span> <span class="token class-name">ImageStream</span> newStream <span class="token operator">=</span>
      provider<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">createLocalImageConfiguration</span><span class="token punctuation">(</span>
        context<span class="token punctuation">,</span>
        size<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>width <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> widget<span class="token punctuation">.</span>height <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token class-name">Size</span><span class="token punctuation">(</span>widget<span class="token punctuation">.</span>width<span class="token operator">!</span><span class="token punctuation">,</span> widget<span class="token punctuation">.</span>height<span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span>newStream <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_updateSourceStream</span><span class="token punctuation">(</span>newStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还可以注意到，当在<code>_resolveImage()</code>中获取到 ImageStream 之后，会通过<code>_updateSourceStream()</code>更新 ImageStream。</p><h3 id="updatesourcestream" tabindex="-1"><a class="header-anchor" href="#updatesourcestream" aria-hidden="true">#</a> _updateSourceStream</h3><p>在此方法中，先是更新了<code>ImageStream? _imageStream</code> 对象，然后根据<code>_isListeningToStream</code>的值执行<code>_imageStream!.addListener(_getListener())</code>更新 ImageStream 的 Listener：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token class-name">ImageStreamListener</span> <span class="token function">_getListener</span><span class="token punctuation">(</span><span class="token punctuation">{</span>bool recreateListener <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>_imageStreamListener <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> recreateListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _lastException <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      _lastStack <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      _imageStreamListener <span class="token operator">=</span> <span class="token class-name">ImageStreamListener</span><span class="token punctuation">(</span>
        _handleImageFrame<span class="token punctuation">,</span><span class="token comment">// 图片加载成功，使用获得的imageInfo更新RawImage</span>
        onChunk<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>loadingBuilder <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> _handleImageChunk<span class="token punctuation">,</span><span class="token comment">// 展示loading动画</span>
        onError<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>errorBuilder <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> kDebugMode
            <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> error<span class="token punctuation">,</span> <span class="token class-name">StackTrace</span><span class="token operator">?</span> stackTrace<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token comment">// 展示加载失败</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> _imageStreamListener<span class="token operator">!</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在 <strong>ImageStreamListener</strong> 中，根据 ImageStream 的不同状态分别更新 Image 的显示。</p><h3 id="handleimageframe" tabindex="-1"><a class="header-anchor" href="#handleimageframe" aria-hidden="true">#</a> _handleImageFrame</h3><p><code>_handleImageFrame()</code>方法使用 ImageStream 中返回的<strong>ImageInfo</strong>，调用<code>setState</code>方法更新_ImageState 中的<code>ImageInfo? **_imageInfo**</code>属性，从而刷新 Image 展示。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">void</span> <span class="token function">_handleImageFrame</span><span class="token punctuation">(</span><span class="token class-name">ImageInfo</span> imageInfo<span class="token punctuation">,</span> bool synchronousCall<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">_replaceImage</span><span class="token punctuation">(</span>info<span class="token punctuation">:</span> imageInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在这里刷新imageInfo，触发重建</span>
      _loadingProgress <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      _lastException <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      _lastStack <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      _frameNumber <span class="token operator">=</span> _frameNumber <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> _frameNumber<span class="token operator">!</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      _wasSynchronouslyLoaded <span class="token operator">=</span> _wasSynchronouslyLoaded <span class="token operator">|</span> synchronousCall<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">_replaceImage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>required <span class="token class-name">ImageInfo</span><span class="token operator">?</span> info<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _imageInfo<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _imageInfo <span class="token operator">=</span> info<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ImageInfo</strong>类内部持有<strong>ui.Image</strong>和其对应的<code>scale</code>，以及一个获取图片像素大小的<code>sizeBytes</code>方法。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token comment">// ImageInfo: a [dart:ui.Image] object with its corresponding scale.</span>
<span class="token class-name">ImageInfo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> required <span class="token keyword">this</span><span class="token punctuation">.</span>image<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scale <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>debugLabel <span class="token punctuation">}</span><span class="token punctuation">)</span>

int <span class="token keyword">get</span> sizeBytes <span class="token operator">=</span><span class="token operator">&gt;</span> image<span class="token punctuation">.</span>height <span class="token operator">*</span> image<span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="build" tabindex="-1"><a class="header-anchor" href="#build" aria-hidden="true">#</a> build</h3><p>上面分析了_ImageState 如何监听使用 ImageProvider 获取到的 ImageStream，从中获取 ImageInfo 更新自己的 <code>ImageInfo? _imageInfo</code> 属性，那么这个属性是如何影响到我们的 Image 展示图片的呢，关键就在 <code>build</code> 方法中：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_lastException <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>widget<span class="token punctuation">.</span>errorBuilder <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> widget<span class="token punctuation">.</span>errorBuilder<span class="token operator">!</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> _lastException<span class="token operator">!</span><span class="token punctuation">,</span> _lastStack<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>kDebugMode<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">_debugBuildErrorWidget</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> _lastException<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token comment">// 注意_ImageState内部其实是使用ui.Image _imageInfo?.image创建了RawImage来展示图片</span>
    <span class="token class-name">Widget</span> result <span class="token operator">=</span> <span class="token class-name">RawImage</span><span class="token punctuation">(</span>
      <span class="token comment">// Do not clone the image, because RawImage is a stateless wrapper.</span>
      <span class="token comment">// The image will be disposed by this state object when it is not needed</span>
      <span class="token comment">// anymore, such as when it is unmounted or when the image stream pushes</span>
      <span class="token comment">// a new image.</span>
      image<span class="token punctuation">:</span> _imageInfo<span class="token operator">?</span><span class="token punctuation">.</span>image<span class="token punctuation">,</span><span class="token comment">// 这里会在ImageStream获取到ImageInfo之后更新</span>
      debugImageLabel<span class="token punctuation">:</span> _imageInfo<span class="token operator">?</span><span class="token punctuation">.</span>debugLabel<span class="token punctuation">,</span>
      width<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>width<span class="token punctuation">,</span>
      height<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>height<span class="token punctuation">,</span>
      scale<span class="token punctuation">:</span> _imageInfo<span class="token operator">?</span><span class="token punctuation">.</span>scale <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">1.0</span><span class="token punctuation">,</span>
      color<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>color<span class="token punctuation">,</span>
      opacity<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>opacity<span class="token punctuation">,</span>
      colorBlendMode<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>colorBlendMode<span class="token punctuation">,</span>
      fit<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>fit<span class="token punctuation">,</span>
      alignment<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>alignment<span class="token punctuation">,</span>
      repeat<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>repeat<span class="token punctuation">,</span>
      centerSlice<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>centerSlice<span class="token punctuation">,</span>
      matchTextDirection<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>matchTextDirection<span class="token punctuation">,</span>
      invertColors<span class="token punctuation">:</span> _invertColors<span class="token punctuation">,</span>
      isAntiAlias<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>isAntiAlias<span class="token punctuation">,</span>
      filterQuality<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>filterQuality<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>widget<span class="token punctuation">.</span>excludeFromSemantics<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">=</span> <span class="token class-name">Semantics</span><span class="token punctuation">(</span>
        container<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>semanticLabel <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        image<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        label<span class="token punctuation">:</span> widget<span class="token punctuation">.</span>semanticLabel <span class="token operator">?</span><span class="token operator">?</span> <span class="token string-literal"><span class="token string">&#39;&#39;</span></span><span class="token punctuation">,</span>
        child<span class="token punctuation">:</span> result<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>widget<span class="token punctuation">.</span>frameBuilder <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      result <span class="token operator">=</span> widget<span class="token punctuation">.</span>frameBuilder<span class="token operator">!</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> result<span class="token punctuation">,</span> _frameNumber<span class="token punctuation">,</span> _wasSynchronouslyLoaded<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>widget<span class="token punctuation">.</span>loadingBuilder <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
   <span class="token comment">// 如果有loadingBuilder就包裹result，所以注意进度为100%时要切换回图片，</span>
   <span class="token comment">// 否则会一直显示进度，而非加载的图片</span>
      result <span class="token operator">=</span> widget<span class="token punctuation">.</span>loadingBuilder<span class="token operator">!</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> result<span class="token punctuation">,</span> _loadingProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ImageInfo.image</code> 是<strong>ui.Image</strong>对象，是原始的 image 像素，通过<strong>RawImage</strong>传入到<code>Canvas.drawImageRect</code>或者<code>Canvas.drawImageNine</code>绘制图片。</p><h2 id="rawimage" tabindex="-1"><a class="header-anchor" href="#rawimage" aria-hidden="true">#</a> RawImage</h2><p><em>A widget that displays a <code>[dart:ui.Image]</code> directly.</em></p><p>RawImage 继承自 <em>LeafRenderWidget</em>，可以直接展示<code>ui.Image</code>的内容，后者是解码的图片数据的不透明句柄（<em>Opaque handle to raw decoded image data (pixels)</em>）、是对<code>_Image</code>类的封装、对外提供宽高以及<code>Image.toByteData</code>（将<code>ui.Image</code>对象转化为<code>ByteData</code>，ByteData 可以直接传入<code>Canvas.drawImageRect</code>方法第一个参数）。</p><p>RawImage 主要逻辑就是创建/更新 RenderImage 的时候将从<code>_ImageState.build</code>方法获得的<code>ui.Image? image</code> 的 clone 传入（其实就是使用<code>ui.Image? image</code>对应的<code>_Image _image</code> 新建了一个 ui.Image，每一个 ui.Image 都是_image 的一个句柄，只有当没有 ui.Image 指向_image 时后者才会真正的 dispose）。</p><h2 id="renderimage" tabindex="-1"><a class="header-anchor" href="#renderimage" aria-hidden="true">#</a> RenderImage</h2><p><em>An image in the render tree.</em></p><p>RenderImage 作为一个 RenderBox，在从 RawImage 那里拿到<code>ui.Image? _image</code>之后，然后在其<code>RenderImage.paint</code>方法中，会调用<code>paintImage</code>方法绘制<code>_image</code>代表的图片。</p><blockquote><p>ui.Image实际是ui._Image的包装类，它的width、height、toByteData等方法最终都是调用ui._Image对应的实现。</p></blockquote><p><code>paintImage</code> 方法是位于 <em>lib\\src\\painting\\decoration_image.dart</em> 的全局方法，在其内部调用 canvas 绘制_image 对应的图片。</p><br><p>至此，我们可以看到，在<strong>Image</strong>中，根据构造方法的不同创建了不同的<strong>ImageProvider</strong>对象作为<code>Image.image</code>参数；</p><p>然后在 <strong>_ImageState</strong> 中，使用<code>ImageProvider.resolve</code>方法创建并更新<code>ImageStream? _imageStream</code>，并且监听<strong>ImageStream</strong>以便在图片加载成功之后获取<code>ImageInfo? _imageInfo</code>；</p><p>这个<strong>ImageInfo</strong>是对<strong>ui.Image</strong>的封装类，在<code>_ImageState.build</code>方法中被传入<strong>RawImage</strong>，后者则创建了<strong>RenderImage</strong>并最终将 ui.Image 的内容绘制在屏幕上面。</p><br><h1 id="图片获取与缓存" tabindex="-1"><a class="header-anchor" href="#图片获取与缓存" aria-hidden="true">#</a> 图片获取与缓存</h1><p>到目前为止，我们大体梳理了图片展示的这部分流程，此外，还有一部分同样重要的流程——图片的获取与缓存。</p><h2 id="imageprovider" tabindex="-1"><a class="header-anchor" href="#imageprovider" aria-hidden="true">#</a> ImageProvider</h2><p><strong>ImageProvider</strong> 是获取图片资源的基类，其他类可以调用<code>ImageProvider.resolve</code>方法获取 <strong>ImageStream</strong> ，此方法会调用<code>ImageCache.putIfAbsent</code>优先从 <strong>ImageCache</strong> 中获取，如果没有则调用<code>ImageProvider.load</code>方法获取并缓存到 ImageCache 中。</p><p>其子类一般只需要重写<code>ImageProvider</code>的<code>ImageStreamCompleter load(T key, DecoderCallback decode)</code>和<code>Future&lt;T&gt; obtainKey(ImageConfiguration configuration)</code>方法即可。</p><p>以<code>NetworkImage</code>加载网络图片的过程为例：</p><blockquote><p>我们通过<code>NetworkImage()</code>方法获取的实际是<code>network_image.NetworkImage</code>对象。</p></blockquote><p>当<code>_ImageState._resolveImage()</code>方法调用<code>ImageProvider.resolve</code>方法时，内部会调用<code>ImageProvider.resolveStreamForKey</code>方法，在其内部会执行：</p><ul><li>通过<code>ImageProvider.obtainKey</code>获取图片对应的 key</li><li>执行<code>PaintingBinding.*instance*!.imageCache!.putIfAbsent(key,() =&gt;</code> <code>load(key, PaintingBinding.*instance*!.instantiateImageCodec),onError: handleError,)</code>方法，优先从 imageCache 中获取缓存的图片，没有的话执行<code>ImageProvider.load</code>方法获取图片。</li></ul><p>对于<code>network_image.NetworkImage</code>对象，他的<code>obtainKey()</code>和<code>load()</code>方法实现如下：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">NetworkImage</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token namespace">image_provider<span class="token punctuation">.</span></span>ImageProvider</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">image_provider<span class="token punctuation">.</span></span>NetworkImage</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">image_provider<span class="token punctuation">.</span></span>NetworkImage</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> <span class="token class-name">NetworkImage</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scale <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>headers <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token metadata function">@override</span>
  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NetworkImage</span><span class="token punctuation">&gt;</span></span> <span class="token function">obtainKey</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">image_provider<span class="token punctuation">.</span></span>ImageConfiguration</span> configuration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 注意这里的key是NetworkImage对象，也就是说网络图片加载的url，scale，</span>
    <span class="token comment">// header等一致的话才会被认为命中缓存</span>
    <span class="token keyword">return</span> <span class="token class-name">SynchronousFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NetworkImage</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token metadata function">@override</span>
  <span class="token class-name">ImageStreamCompleter</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">image_provider<span class="token punctuation">.</span></span>NetworkImage</span> key<span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">image_provider<span class="token punctuation">.</span></span>DecoderCallback</span> decode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Ownership of this controller is handed off to [_loadAsync]; it is that</span>
    <span class="token comment">// method&#39;s responsibility to close the controller&#39;s stream when the image</span>
    <span class="token comment">// has been loaded or an error is thrown.</span>
    <span class="token keyword">final</span> <span class="token class-name">StreamController</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ImageChunkEvent</span><span class="token punctuation">&gt;</span></span> chunkEvents <span class="token operator">=</span> <span class="token class-name">StreamController</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ImageChunkEvent</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token class-name">MultiFrameImageStreamCompleter</span><span class="token punctuation">(</span>
      codec<span class="token punctuation">:</span> <span class="token function">_loadAsync</span><span class="token punctuation">(</span>key <span class="token operator">as</span> <span class="token class-name">NetworkImage</span><span class="token punctuation">,</span> chunkEvents<span class="token punctuation">,</span> decode<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 真正从网络加载图片的方法</span>
      chunkEvents<span class="token punctuation">:</span> chunkEvents<span class="token punctuation">.</span>stream<span class="token punctuation">,</span>
      scale<span class="token punctuation">:</span> key<span class="token punctuation">.</span>scale<span class="token punctuation">,</span>
      debugLabel<span class="token punctuation">:</span> key<span class="token punctuation">.</span>url<span class="token punctuation">,</span>
      informationCollector<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DiagnosticsNode</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>
        <span class="token class-name">DiagnosticsProperty</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">image_provider<span class="token punctuation">.</span></span>ImageProvider</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;Image provider&#39;</span></span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">DiagnosticsProperty</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">image_provider<span class="token punctuation">.</span></span>NetworkImage</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;Image key&#39;</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这其中，<code>network_image.NetworkImage._loadAsync()</code>方法才是真正使用<code>HttpClient</code>从网上获取图片资源的方法（实际上 AssetBundleImageProvider、FileImage 和 MemoryImage 等一众 ImageProvider 等都约定俗成在<code>_loadAsync</code> 中执行真正获取图片的逻辑），返回值 Future&lt;ui.Codec&gt;和 ui.Image 的关系如下：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">ui<span class="token punctuation">.</span></span>Image</span><span class="token punctuation">&gt;</span></span> <span class="token function">decodeImageFromList</span><span class="token punctuation">(</span><span class="token class-name">Uint8List</span> bytes<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">ui<span class="token punctuation">.</span></span>Codec</span> codec <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token class-name">PaintingBinding</span><span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">instantiateImageCodec</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">ui<span class="token punctuation">.</span></span>FrameInfo</span> frameInfo <span class="token operator">=</span> <span class="token keyword">await</span> codec<span class="token punctuation">.</span><span class="token function">getNextFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> frameInfo<span class="token punctuation">.</span>image<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="imagecache" tabindex="-1"><a class="header-anchor" href="#imagecache" aria-hidden="true">#</a> ImageCache</h2><p><em>Class for caching images.</em></p><p>在上面方分析 ImageProvider 的时候，我们注意到，每次通过<code>ImageProvider.resolveStreamForKey</code>方法获取 ImageStream 时，都会调用<code>PaintingBinding.instance!.imageCache.putIfAbsent</code>方法优先获取<strong>Image 对象的缓存</strong>，这就涉及到和 Image 缓存有关的类——<strong>ImageCache</strong>。</p><p>ImageCache 对象全局唯一，使用 LRU 算法最多缓存<strong>1000 张或者最大 100MB 图片</strong>，可以分别使用<code>maximumSize</code>和<code>maximumSizeBytes</code>修改配置。</p><p>其内部维持有三个 Map：</p><ul><li><code>Map&lt;Object, PendingImage&gt; _pendingImages</code> 正在加载中的图片，可能可能同时也是<code>_liveImage</code>（对应的 ImageStream 已经被监听了）。</li><li><code>Map&lt;Object, _CachedImage&gt; _cache</code> 缓存的图片，maximumSize 和 maximumSizeBytes 限制针对的是<code>_cache</code>。</li><li><code>Map&lt;Object, _LiveImage&gt; _liveImages</code> 正在使用的图片，他的 ImageStreamCompleters 至少有一个 listener，可能同时在<code>_pendingImages</code>（所以这里的_LiveImage 的<code>sizeBytes</code>可能为 null）或者<code>_liveImages</code>中。</li></ul><p><code>_CachedImage</code>和<code>_LiveImage</code>都继承自<code>_CachedImageBase</code>，其内部持有<code>ImageStreamCompleter</code>，图片的 handler<code>ImageStreamCompleterHandle</code>，以及图片大小<code>sizeBytes</code>。</p><p><code>ImageCacheStatus</code>处理 ImageCache 缓存的图片状态：</p><ul><li><code>pending</code>，还没有加载完成的 image，如果被监听的话，还会是<code>live</code>的</li><li><code>keepAlive</code>，图片会被<code>ImageCache._cache</code>保存。可能是 live 的，但不会 pending 的。</li><li><code>live</code>，图片会一直被持有，除非<code>ImageStreamCompleter</code>没有 listener 了。可能是 pending 的，也可能是 keepAlive 的</li><li><code>untracked</code>，不会被缓存的图片（上述三值都为 false）。</li></ul><p>可以使用<code>ImageCache.statusForKey</code>或者<code>ImageProvider.obtainCacheStatus</code>获取图片状态<code>ImageCacheStatus</code>。</p><p>此外，ImageCache还提供<code>ImageCache.evict</code>方法从缓存中清除指定图片。</p><h3 id="putifabsent" tabindex="-1"><a class="header-anchor" href="#putifabsent" aria-hidden="true">#</a> putIfAbsent</h3><p>当 ImageProvider 调用<code>ImageCache.putIfAbsent</code>方法获取 ImageStreamCompleter 时，会依次尝试从<code>_pendingImages</code> 、<code>_cache</code> 、<code>_liveImages</code> 中读取，如果都没有则会尝试执行传入的 loader 方法获取。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code>  <span class="token class-name">ImageStreamCompleter</span><span class="token operator">?</span> <span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">ImageStreamCompleter</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> loader<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token class-name">ImageErrorListener</span><span class="token operator">?</span> onError <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token class-name">ImageStreamCompleter</span><span class="token operator">?</span> result <span class="token operator">=</span> _pendingImages<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span>completer<span class="token punctuation">;</span>
    <span class="token comment">// Nothing needs to be done because the image hasn&#39;t loaded yet.</span>
    <span class="token comment">// 1. 如果图片还在加载中，就直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Remove the provider from the list so that we can move it to the</span>
    <span class="token comment">// recently used position below.</span>
    <span class="token comment">// Don&#39;t use _touch here, which would trigger a check on cache size that is</span>
    <span class="token comment">// not needed since this is just moving an existing cache entry to the head.</span>
    <span class="token keyword">final</span> _CachedImage<span class="token operator">?</span> image <span class="token operator">=</span> _cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>image <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// The image might have been keptAlive but had no listeners (so not live).</span>
      <span class="token comment">// Make sure the cache starts tracking it as live again.</span>
      <span class="token comment">// 2. 如果_cache中已经有了，就将其加入_liveImages并返回</span>
      <span class="token function">_trackLiveImage</span><span class="token punctuation">(</span>
        key<span class="token punctuation">,</span>
        image<span class="token punctuation">.</span>completer<span class="token punctuation">,</span>
        image<span class="token punctuation">.</span>sizeBytes<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
      _cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> image<span class="token punctuation">;</span>
      <span class="token keyword">return</span> image<span class="token punctuation">.</span>completer<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3. 如果_liveImages中已经有了，而cache中没有，就加入_cache，</span>
    <span class="token comment">// 此时会检测大小和数量（这种属于图片刚下载完，或者已有缓存被清理）</span>
    <span class="token keyword">final</span> _LiveImage<span class="token operator">?</span> liveImage <span class="token operator">=</span> _liveImages<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>liveImage <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">_touch</span><span class="token punctuation">(</span>
        key<span class="token punctuation">,</span>
        <span class="token function">_CachedImage</span><span class="token punctuation">(</span>
          liveImage<span class="token punctuation">.</span>completer<span class="token punctuation">,</span>
          sizeBytes<span class="token punctuation">:</span> liveImage<span class="token punctuation">.</span>sizeBytes<span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">,</span>
        timelineTask<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>kReleaseMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        timelineTask<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span>arguments<span class="token punctuation">:</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token string-literal"><span class="token string">&#39;result&#39;</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&#39;keepAlive&#39;</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> liveImage<span class="token punctuation">.</span>completer<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 4.1 如果_pendingImages、_cacheImages、_liveImages中都没有，就去下载</span>
    <span class="token comment">// 并加入到_liveImages中，此时_LiveImage.sizeBytes为null</span>
    <span class="token comment">// 注意这里只是加入到_liveImages中追踪，并未使用_cache，</span>
    <span class="token comment">// 故而也【不受其最大数量和最大总大小约束】</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      result <span class="token operator">=</span> <span class="token function">loader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">_trackLiveImage</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> result<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">,</span> stackTrace<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// If we&#39;re doing tracing, we need to make sure that we don&#39;t try to finish</span>
    <span class="token comment">// the trace entry multiple times if we get re-entrant calls from a multi-</span>
    <span class="token comment">// frame provider here.</span>
    bool listenedOnce <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// We shouldn&#39;t use the _pendingImages map if the cache is disabled, but we</span>
    <span class="token comment">// will have to listen to the image at least once so we don&#39;t leak it in</span>
    <span class="token comment">// the live image tracking.</span>
    <span class="token comment">// If the cache is disabled, this variable will be set.</span>
    _PendingImage<span class="token operator">?</span> untrackedPendingImage<span class="token punctuation">;</span>
    <span class="token comment">// 图片加载过程中的回调</span>
    <span class="token keyword">void</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token class-name">ImageInfo</span><span class="token operator">?</span> info<span class="token punctuation">,</span> bool syncCall<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      int<span class="token operator">?</span> sizeBytes<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>info <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sizeBytes <span class="token operator">=</span> info<span class="token punctuation">.</span>sizeBytes<span class="token punctuation">;</span>
        info<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">final</span> _CachedImage image <span class="token operator">=</span> <span class="token function">_CachedImage</span><span class="token punctuation">(</span>
        result<span class="token operator">!</span><span class="token punctuation">,</span>
        sizeBytes<span class="token punctuation">:</span> sizeBytes<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">_trackLiveImage</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> result<span class="token punctuation">,</span> sizeBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Only touch if the cache was enabled when resolve was initially called.</span>
      <span class="token comment">// 4.2 图片加载成功，如果有缓存，就将此图片加入_cache中，此时会检测大小和数量</span>
      <span class="token comment">// 并且这里的sizeBytes是图片实际大小</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>untrackedPendingImage <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">_touch</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> image<span class="token punctuation">,</span> listenerTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        image<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">final</span> _PendingImage<span class="token operator">?</span> pendingImage <span class="token operator">=</span> untrackedPendingImage <span class="token operator">?</span><span class="token operator">?</span> _pendingImages<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingImage <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pendingImage<span class="token punctuation">.</span><span class="token function">removeListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      
      listenedOnce <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">final</span> <span class="token class-name">ImageStreamListener</span> streamListener <span class="token operator">=</span> <span class="token class-name">ImageStreamListener</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>maximumSize <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> maximumSizeBytes <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _pendingImages<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">_PendingImage</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> streamListener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      untrackedPendingImage <span class="token operator">=</span> <span class="token function">_PendingImage</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> streamListener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Listener is removed in [_PendingImage.removeListener].</span>
    result<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span>streamListener<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过上述分析可以知道，当_cache、_liveImages、_pendingImages中都没有指定图片时，会从网络下载（或者磁盘、asset等），而在图片完全加载完成之前，_pendingImages中下载图片所占大小是没有被ImageCache追踪的，也就是说<strong>ImageCache._cache的最大个数和总大小限制都不会管理这部分图片</strong>；故而面对大量高清大图加载的场景（比如，五列1:1网格加载平均大小几Mb的网络图片），如果<strong>快速滑动</strong>会导致_pendingImages急速增大，这样下载中且还未完全下载的图片所占用的内存会逐渐累计，从而导致Flutter APP<strong>内存暴增，页面卡顿</strong>等（本地资源不容易出现是因为从load到图片加载完成间隔比较短，而网络图片由于网速等导致_pendingImages中会累计很多正在下载中的图片，会比较明显）。</p><p>那些在Flutter中加载图片并且完全采用ImageCache管理图片内存的图片加载框架比如Image/ExtendedImage/CachedNetworkImage等都存在此问题；阿里的PowerImage由于将图片下载这个过程交给了原生成熟的图片加载库处理，使得ImageCache只管理已经加载完成的图片，从而避免了上述情况。</p><br><p>可以看到，以从网络加载图片为例，Flutter 原生提供的 Image 只有内存中的 ImageCache 一级缓存，如果 ImageCache 没有指定的图片（首次加载或者缓存被清空）则会再次从网络加载，这会导致多图列表的时候图片被频繁的回收/重新下载，从而影响用户体验。</p><p>为了解决上述问题，涌现了很多第三方图片加载控件：</p>`,70),x={href:"https://github.com/fluttercandies/extended_image",target:"_blank",rel:"noopener noreferrer"},P={href:"https://github.com/Baseflow/flutter_cached_network_image",target:"_blank",rel:"noopener noreferrer"},B=a("em",null,"sqflite 数据库",-1),L=a("strong",null,"网络图片加载",-1),R={href:"https://github.com/alibaba/power_image",target:"_blank",rel:"noopener noreferrer"},F=a("strong",null,"混合项目",-1),N=a("em",null,"ffi",-1),A=a("em",null,"texture",-1),z=a("em",null,"Glide",-1),E=t('<h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><p>简单总结一下 Flutter 原生 Image 组件加载图片的流程：</p><figure><img src="https://jixiaoyong.github.io/images/flutter_image_class_structure.png" alt="flutter_image_class_structure.png" tabindex="0" loading="lazy"><figcaption>flutter_image_class_structure.png</figcaption></figure><p>简单来说如下：</p><ul><li>用户通过 Image Widget 的各个构造方法创建指定的 ImageProvider；</li><li>在_ImageState 中使用<code>ImageProvider.resolve(ImageConfiguration)</code>获取并监听 ImageStream（listener 为 ImageStreamListener）；</li><li>ImageProvider 会按照传入的 ImageConfiguration 生成的 key 在 ImageCache 中查找对应的缓存，没有的话则先加载再缓存；</li><li>当 ImageProvider 成功加载图片时，ImageStreamListener 获得 ImageInfo 时，并触发<code>_ImageState.build()</code>方法将<code>ui.Image _imageInfo?.image</code>传入 RawImage 中；</li><li>作为一个 LeafRenderObjectWidget，RawImage 创建 RenderImage 并传入<code>ui.Image? image?.clone()</code>作为<code>RenderImage.image</code>，此后再在<code>RenderImage.paint</code>方法中调用系统的<code>paintImage()</code>方法通过<code>canvas.drawImageRect</code>绘制图片内容。</li></ul><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h1>',6),W={href:"https://api.flutter.dev/flutter/widgets/Image-class.html",target:"_blank",rel:"noopener noreferrer"},D=a("br",null,null,-1),M={href:"https://mp.weixin.qq.com/s/alglGvnNKIzr7f8SwRZucA",target:"_blank",rel:"noopener noreferrer"};function O(T,j){const s=p("ExternalLinkIcon");return c(),i("div",null,[a("p",null,[n("Flutter 默认提供了"),u,n("用于从网络、文件等加载图片，并且使用"),r,n("统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了"),a("a",d,[n("flutter_cached_network_image"),e(s)]),n("、"),a("a",m,[n("extended_image"),e(s)]),n("等基于 Flutter 原生的解决方案，以及"),a("a",k,[n("power_image"),e(s)]),n("等基于混合开发的解决方案。")]),g,a("ul",null,[a("li",null,[a("a",v,[n("Image.new"),e(s)]),n(", for obtaining an image from an "),a("a",b,[n("ImageProvider"),e(s)]),n(".")]),a("li",null,[a("a",I,[n("Image.asset"),e(s)]),n(", for obtaining an image from an "),a("a",h,[n("AssetBundle"),e(s)]),n(" using a key.")]),a("li",null,[a("a",_,[n("Image.network"),e(s)]),n(", for obtaining an image from a URL.")]),a("li",null,[a("a",f,[n("Image.file"),e(s)]),n(", for obtaining an image from a "),a("a",w,[n("File"),e(s)]),n(".")]),a("li",null,[a("a",y,[n("Image.memory"),e(s)]),n(", for obtaining an image from a "),a("a",S,[n("Uint8List"),e(s)]),n(".")])]),C,a("ul",null,[a("li",null,[a("a",x,[n("extended_image"),e(s)]),n(" 对官方 Image 的二次开发，增加了磁盘缓存。")]),a("li",null,[a("a",P,[n("flutter_cached_network_image"),e(s)]),n(" 使用"),B,n("管理缓存的"),L,n("库，增加了磁盘缓存。")]),a("li",null,[a("a",R,[n("power_image"),e(s)]),n(" 使用于"),F,n("的图片加载库，提供"),N,n("和"),A,n("两种图片展示方式，依赖于原生图片加载库（比如"),z,n("）加载图片、管理缓存。")])]),E,a("p",null,[a("a",W,[n("Image_api.flutter.dev"),e(s)]),D,a("a",M,[n("京东在Flutter加载大量图片导致的内存溢出的优化实践"),e(s)])])])}const G=o(l,[["render",O],["__file","1912667a.html.vue"]]);export{G as default};
