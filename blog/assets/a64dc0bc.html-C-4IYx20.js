import{_ as i,c as s,o as a,a as n}from"./app-DOr8-Kjq.js";const e={},l=n(`<p>二叉树的遍历根据根节点与左右子节点的遍历顺序的不同分为三种：</p><ul><li><p>前序遍历</p><p>根左右：先遍历根节点，再左子树，再右子树（先从根节点开始，记录左节点直到没有）</p><p>第一个为根节点</p></li><li><p>中序遍历</p><p>左根右：先左子树，再根子树，再右子树（从树的最左边的节点开始遍历）</p></li><li><p>后序遍历</p><p>左右根：先左子树，后右子树，再根节点</p><p>最后一个为根节点</p></li></ul><p>在遍历的时候，当父节点只有一个子节点时，依然要遵循以上三种遍历的先后顺序（没有该子节点则不写内容），以保证某一侧的子树（“左边的子树”或“右边的子树”）所有节点都被完全遍历，之后才可以根据遍历的规则切换到下一子树。</p><p>如如下子树：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>      G</span></span>
<span class="line"><span>   /     \\</span></span>
<span class="line"><span>  D       M</span></span>
<span class="line"><span> / \\     / \\</span></span>
<span class="line"><span>A   F   H   Z</span></span>
<span class="line"><span>   /</span></span>
<span class="line"><span>  E</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前序遍历：GDAFEMHZ</p><p>中序遍历：ADEFGHMZ</p><p>后续遍历：AEFDHZMG</p><h2 id="常见应用" tabindex="-1"><a class="header-anchor" href="#常见应用"><span>常见应用</span></a></h2><p>一般都是给定中序排序，再加上一个前序排序、后续排序来逆向生成二叉树。</p><p>根据之前的知识，此类题的解答思路一般为：</p><p>先根据前序排序、后续排序的特点，找到根节点，之后再根据找到的根节点将中序排序分为左、右子树两个部分。这样循环直到整个树的每个节点都被遍历完毕，完整的二叉树也会被建立起来。</p><p>我们以下面这个二叉树为例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>    1</span></span>
<span class="line"><span>   / \\</span></span>
<span class="line"><span>  2   3</span></span>
<span class="line"><span>     / \\</span></span>
<span class="line"><span>    4   5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用代码表示如下：</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> preorder </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//前序遍历</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> inorder  </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> intArrayOf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//中序遍历</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> buildTree</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(preorder, inorder)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(tree)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> buildTree</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(preorder: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">IntArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, inorder: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">IntArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">? {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> tree : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (preorder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">isNotEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> root </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> preorder[</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//获取根节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> indexOfRoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> inorder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(root)</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//获取中序排序中根节点的坐标</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        tree </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(root)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //根据根节点坐标，将二叉树分为左、右两个子树</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> leftTree </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> inorder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">copyOfRange</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, indexOfRoot)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> rightTree </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> inorder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">copyOfRange</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(indexOfRoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, inorder.size)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //将前序排序也分为左右两个子树的前序排序</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> leftPreOrder </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> preorder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">copyOfRange</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, preorder.size).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { leftTree.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(it) }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toIntArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> rightPreOrder </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> preorder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">copyOfRange</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, preorder.size).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { rightTree.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(it) }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toIntArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //再次分别循环分析左右两个子树的结构</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        tree.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> buildTree</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(leftPreOrder, leftTree)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        tree.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> buildTree</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(rightPreOrder, rightTree)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> tree</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> \`</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">\`: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> left: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> right: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">? </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://www.jianshu.com/p/9e8922486154" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/9e8922486154</a></p><p><a href="https://charlesliuyx.github.io/2018/10/22/%5B%E7%9B%B4%E8%A7%82%E7%AE%97%E6%B3%95%5D%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener noreferrer">【直观算法】二叉树遍历算法总结</a></p><p><a href="https://jingyan.baidu.com/album/cdddd41cb8d79753ca00e144.html?picindex=1" target="_blank" rel="noopener noreferrer">知道中序和后序遍历，画二叉树和写出前序遍历 </a></p><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener noreferrer">leetcode-重建二叉树</a></p>`,21),t=[l];function h(p,k){return a(),s("div",null,t)}const d=i(e,[["render",h],["__file","a64dc0bc.html.vue"]]),B=JSON.parse('{"path":"/posts/a64dc0bc.html","title":"LeetCode 笔记--重建二叉树","lang":"zh-CN","frontmatter":{"permalink":"/posts/a64dc0bc.html","title":"LeetCode 笔记--重建二叉树","tag":"数据结构与算法","abbrlink":"a64dc0bc","date":"2020-02-20T03:14:24.000Z","updated":"2023-12-30T08:17:02.000Z","isOriginal":true,"description":"二叉树的遍历根据根节点与左右子节点的遍历顺序的不同分为三种： 前序遍历 根左右：先遍历根节点，再左子树，再右子树（先从根节点开始，记录左节点直到没有） 第一个为根节点 中序遍历 左根右：先左子树，再根子树，再右子树（从树的最左边的节点开始遍历） 后序遍历 左右根：先左子树，后右子树，再根节点 最后一个为根节点 在遍历的时候，当父节点只有一个子节点时，依...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/a64dc0bc.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"LeetCode 笔记--重建二叉树"}],["meta",{"property":"og:description","content":"二叉树的遍历根据根节点与左右子节点的遍历顺序的不同分为三种： 前序遍历 根左右：先遍历根节点，再左子树，再右子树（先从根节点开始，记录左节点直到没有） 第一个为根节点 中序遍历 左根右：先左子树，再根子树，再右子树（从树的最左边的节点开始遍历） 后序遍历 左右根：先左子树，后右子树，再根节点 最后一个为根节点 在遍历的时候，当父节点只有一个子节点时，依..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-04T03:36:59.000Z"}],["meta",{"property":"article:author","content":"JI,XIAOYONG"}],["meta",{"property":"article:tag","content":"数据结构与算法"}],["meta",{"property":"article:published_time","content":"2020-02-20T03:14:24.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-04T03:36:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LeetCode 笔记--重建二叉树\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-02-20T03:14:24.000Z\\",\\"dateModified\\":\\"2024-06-04T03:36:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"常见应用","slug":"常见应用","link":"#常见应用","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1653726847000,"updatedTime":1717472219000,"contributors":[{"name":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":3},{"name":"JI,XIAOYONG","email":"jixiaoyong1995@gmail.com","commits":2}]},"readingTime":{"minutes":2.38,"words":713},"filePathRelative":"_posts/LeetCode笔记--重建二叉树.md","localizedDate":"2020年2月20日","excerpt":"<p>二叉树的遍历根据根节点与左右子节点的遍历顺序的不同分为三种：</p>\\n<ul>\\n<li>\\n<p>前序遍历</p>\\n<p>根左右：先遍历根节点，再左子树，再右子树（先从根节点开始，记录左节点直到没有）</p>\\n<p>第一个为根节点</p>\\n</li>\\n<li>\\n<p>中序遍历</p>\\n<p>左根右：先左子树，再根子树，再右子树（从树的最左边的节点开始遍历）</p>\\n</li>\\n<li>\\n<p>后序遍历</p>\\n<p>左右根：先左子树，后右子树，再根节点</p>\\n<p>最后一个为根节点</p>\\n</li>\\n</ul>\\n<p>在遍历的时候，当父节点只有一个子节点时，依然要遵循以上三种遍历的先后顺序（没有该子节点则不写内容），以保证某一侧的子树（“左边的子树”或“右边的子树”）所有节点都被完全遍历，之后才可以根据遍历的规则切换到下一子树。</p>","autoDesc":true}');export{d as comp,B as data};
