import{_ as c,r as i,o as r,c as d,a as e,b as a,d as o,w as l,e as s}from"./app-16aa99a6.js";const p={},h=e("h2",{id:"前言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),a(" 前言")],-1),g=e("p",null,[a("红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为"),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"O"),e("mo",{stretchy:"false"},"("),e("mi",null,"l"),e("mi",null,"o"),e("msub",null,[e("mi",null,"g"),e("mn",null,"2")]),e("mi",null,"N"),e("mo",{stretchy:"false"},")")]),e("annotation",{encoding:"application/x-tex"},"O(log_2N)")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),e("span",{class:"mopen"},"("),e("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),e("span",{class:"mord mathnormal"},"o"),e("span",{class:"mord"},[e("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),e("span",{class:"msupsub"},[e("span",{class:"vlist-t vlist-t2"},[e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.3011em"}},[e("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[e("span",{class:"pstrut",style:{height:"2.7em"}}),e("span",{class:"sizing reset-size6 size3 mtight"},[e("span",{class:"mord mtight"},"2")])])]),e("span",{class:"vlist-s"},"​")]),e("span",{class:"vlist-r"},[e("span",{class:"vlist",style:{height:"0.15em"}},[e("span")])])])])]),e("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),e("span",{class:"mclose"},")")])])]),a("。")],-1),m=s('<p>红黑树必须满足以下条件：</p><ol><li><p>必须有颜色（黑/红）</p></li><li><p>根节点颜色为黑</p></li><li><p>若节点是红色，则子节点必须是黑色（反之则不然）</p></li><li><p>到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色）</p></li></ol><p>如果不满足可以通过以下方式修正：</p><ul><li>改变节点颜色</li><li>旋转（左、右）</li></ul><h2 id="旋转" tabindex="-1"><a class="header-anchor" href="#旋转" aria-hidden="true">#</a> 旋转</h2><p>以某个支点旋转（右旋为例，旋转时注意更新各个节点的父节点）：</p><p>本质是将该<code>节点a</code>向下进一位插入到其<code>右节点b</code>原先的位置，将其<code>左节点c</code>向上进一位插入到该<code>节点a</code>原先的位置，并将<code>左节点c的右节点</code>赋值给该<code>节点a</code>。</p><p>步骤：</p><ol><li><p>将该<code>节点a</code>放到<code>右节点b</code>的位置，将该``左节点 c<code>放到</code>节点 a`原先的位置，依次类推</p></li><li><p>特殊的，将该<code>点a的内侧孙子</code>（<code>a的左子节点c</code>的<code>右子节点d</code>）断开与其<code>父节点c</code>的连接，转而连接到<code>a</code>上，成为<code>a的左子节点</code></p></li></ol><p>如图，依次插入<code>6,34,23</code>，<strong>以<code>34</code>为支点右旋</strong>：</p><img src="https://jixiaoyong.github.io/images/20181223175956.png" width="50%" height="50%">',11),u=e("code",null,"规则3",-1),_=e("code",null,"34的父节点23",-1),f=e("code",null,"祖父节点6",-1),b=e("strong",null,[a("以"),e("code",null,"祖父节6"),a("点为支点左旋")],-1),x=s('<figure><img src="https://jixiaoyong.github.io/images/20181223180637.png" alt="最终结果" tabindex="0" loading="lazy"><figcaption>最终结果</figcaption></figure><h2 id="插入" tabindex="-1"><a class="header-anchor" href="#插入" aria-hidden="true">#</a> 插入</h2><p>每次插入红色节点，能够避免规则 4。</p><p>一般先以二叉搜索树的规则将数据插入表中，然后再对照规则检查是否需要调整红黑树。</p><p>红黑树插入情况分类如下：</p><ol><li>插入位置为根节点，将节点颜色更改为黑色</li><li>插入位置的父节点为根节点或父节点颜色为黑色，直接插入</li><li>父节点为红色。</li></ol><p>只有父节点为红色这种情况需要进行修正，这时又可以细分为以下三种情况：</p>',7),y=e("img",{src:"https://jixiaoyong.github.io/images/20181223182532.jpg",alt:"表格来自 http://www.cnblogs.com/skywang12345/p/3245399.html#a1",tabindex:"0",loading:"lazy"},null,-1),w={href:"http://www.cnblogs.com/skywang12345/p/3245399.html#a1",target:"_blank",rel:"noopener noreferrer"},v=s(`<p>【注意】对于<code>Case 3</code>当祖父节点没有<strong>左节点</strong>无法右旋时的特殊处理：</p><p>需要对先对当前节点的父节点进行右旋，再以父节点作为<strong>新插入的点 N</strong>，将 N 的父节点设置为黑色，祖父节点设置为红色，以祖父节点为支点左旋。</p><p>如依次插入如下值：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>32,3,53,13,983,[137],237,83,483,43,183
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当插入<code>137</code>后红黑树如图：</p><figure><img src="https://jixiaoyong.github.io/images/20181223210305.png" alt="插入 137 后的树" tabindex="0" loading="lazy"><figcaption>插入 137 后的树</figcaption></figure><p>本来按照<code>Case 3 父红 叔黑 是左节点 </code> 应该要以祖节点右旋，但是组节点 53 没有左子节点，无法右旋，所以先对父节点 983 进行右旋：</p><figure><img src="https://jixiaoyong.github.io/images/20181223210800.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>再以<code>983</code>为新节点，<code>父红 叔黑 是右节点</code>，将<code>父节点137</code>设置为黑色，<code>祖节点53</code>设置为红色，以<code>组节点53</code>为支点左旋：</p><figure><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h2><p>删除比较复杂，可以有两种操作：</p><ol><li>在节点中保存一个标志位，标记该节点是否被删除，并不针真的删除该点。</li><li>在执行删除操作时真正删除该点。</li></ol><h2 id="源码" tabindex="-1"><a class="header-anchor" href="#源码" aria-hidden="true">#</a> 源码</h2>`,14),k={href:"https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/RedBlackTree.kt",target:"_blank",rel:"noopener noreferrer"},E=e("h2",{id:"参考文档",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考文档","aria-hidden":"true"},"#"),a(" 参考文档")],-1),j={href:"https://sandbox.runjs.cn/show/2nngvn8w",target:"_blank",rel:"noopener noreferrer"},N={href:"http://www.cnblogs.com/skywang12345/p/3245399.html#a1",target:"_blank",rel:"noopener noreferrer"};function z(B,A){const n=i("font"),t=i("ExternalLinkIcon");return r(),d("div",null,[h,g,m,e("p",null,[a("对获得的结果，由于"),o(n,{color:"#ff0000"},{default:l(()=>[a("23")]),_:1}),a("，"),o(n,{color:"#ff0000"},{default:l(()=>[a("34")]),_:1}),a("都是红色违反了"),u,a("，将"),_,a("设置黑，"),f,a("设为红，"),b,a("：")]),x,e("figure",null,[y,e("figcaption",null,[a("表格来自 "),e("a",w,[a("http://www.cnblogs.com/skywang12345/p/3245399.html#a1"),o(t)])])]),v,e("p",null,[e("a",k,[a("👉 点这里"),o(t)]),a("查看源码")]),E,e("p",null,[e("a",j,[a("在线操作红黑树"),o(t)])]),e("p",null,[e("a",N,[a("红黑树 (一) 之 原理和算法详细介绍"),o(t)])])])}const L=c(p,[["render",z],["__file","11c01876.html.vue"]]);export{L as default};
