import{_ as s,r as p,o as t,c as r,a,b as e,d as i,e as o}from"./app-77b42b64.js";const l={},d=o(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>Hash 表是一种可以快速插入和查找的数据结构，将数据保存在通过 hash 函数计算得到的下标中。</p><p>插入和删除 所需时间为 O(1)。在确定容量、无需遍历时效果最好。</p><p>当其大小接近容量时，效率会变得很差。</p><h2 id="存储方式" tabindex="-1"><a class="header-anchor" href="#存储方式" aria-hidden="true">#</a> 存储方式</h2><p>Hash 表有两种存储方式</p><ol><li><p>开放地址法</p><p>开放地址法，直接将数据存储在数组中。</p><p>当 hash 算出的地址已经被占用时，则走过一定的步长找到另外一个空位（在填充质数很大时就会很耗时）并保存数据。</p></li><li><p>链地址法</p><p>链地址法，创建保存数据的数组，该数组中不直接保存数据，而是保存一个用来存储这些数据的链表，将数据项直接存储的链表中。</p><p>当 hash 算法计算出的地址时，遍历数组中对应的链表找到空位并保存。</p></li></ol><p>其中，开放地址法又分为 3 种实现：</p><ul><li><p>线性探测</p><p>每次前进的步长为 1</p><p>即查找的位置依次是<code>x + 1,2,3,4,5,……</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>存储达到容量 2/3 以上时候读写性能会很差
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>二次探测</p><p>每次前进的步长为当前查找次数的平方</p><p>即查找的位置依次是<code>x + 1,4,9,……</code></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>当前几次找不到之后就会很恐慌，步长越来越大到后面无法继续下去
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>再哈希法</p><p>每次前进的步长是根据另外一个 hash 算法计算出来的值</p><p>这个算法要求如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token number">1.</span> 与第一次 hash 输出不同
<span class="token number">2.</span> 不能输出 <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>已经有一个公认的比较好的二次 hash 算法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>stepSize <span class="token operator">=</span> constant <span class="token operator">-</span> <span class="token punctuation">(</span>key <span class="token operator">%</span> constant<span class="token punctuation">)</span>
如：stepSize <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">-</span> <span class="token punctuation">(</span>key <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">*</span> constant 是小于数组容量的质数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="比较" tabindex="-1"><a class="header-anchor" href="#比较" aria-hidden="true">#</a> 比较</h2><p><strong>再哈希法 VS 二次探测法</strong></p><p>在小型哈希表中，再哈希法比二次探测好；</p><p>但如果容量充足，并且容量大小不再变化时，二次探测效果好，在装填因子小于 0.5 时几乎没有性能损失</p><p><strong>开放地址法 VS 链地址法</strong></p><p>hash 表容器大小未知时，用链地址法比较好</p><p>当装填因子变得很大时，开放地址法性能下降很快，但链地址法只是线性下降。</p><h2 id="源码" tabindex="-1"><a class="header-anchor" href="#源码" aria-hidden="true">#</a> 源码</h2>`,17),c={href:"https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/Hash.kt",target:"_blank",rel:"noopener noreferrer"};function u(h,v){const n=p("ExternalLinkIcon");return t(),r("div",null,[d,a("p",null,[a("a",c,[e("👉 点这里"),i(n)]),e("查看源码")])])}const b=s(l,[["render",u],["__file","1f6681a0.html.vue"]]);export{b as default};
