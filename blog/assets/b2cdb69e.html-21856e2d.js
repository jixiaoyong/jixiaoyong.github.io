import{_ as p,r as c,o,c as l,a as n,b as s,d as e,e as t}from"./app-111ffeba.js";const i={},u=t(`<p>Java 中的泛型实现了<strong>参数类型化</strong>的概念。</p><p>主要有以下形式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">OneClazz</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token class-name">T</span> t<span class="token punctuation">;</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Y</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文主要记录 Java 泛型一些比较特殊的知识点。</p><h2 id="泛型特性" tabindex="-1"><a class="header-anchor" href="#泛型特性" aria-hidden="true">#</a> 泛型特性</h2><p>泛型在 Java SE5 被引入，可以在类和方法中，将类型作为类型参数传入。</p><p>泛型类型参数会在实际运行时被<strong>擦除</strong>到他的第一个边界。如<code>&lt;T&gt;</code>会被擦除为<code>Objet</code>，而<code>&lt;T extends ClazzA&gt;</code>则会被擦除为<code>ClazzA</code>。</p><h2 id="需要注意的地方" tabindex="-1"><a class="header-anchor" href="#需要注意的地方" aria-hidden="true">#</a> 需要注意的地方</h2><h3 id="不能有泛型数组" tabindex="-1"><a class="header-anchor" href="#不能有泛型数组" aria-hidden="true">#</a> 不能有泛型数组</h3><p>这是因为 Java 中 Object[]默认为所有数组的父类，如下代码虽然在编译期不会报错，但是在运行时会被检查出 objArr 指向的数组实际类型（String）和要赋予的类型（Integer）不一致而报错。</p><p>也就是说，数组只能存放<strong>定义的实际类型</strong>以及他们的<strong>子类型</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
objArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果支持泛型数组：由于泛型类型参数会在运行时被擦除，导致即使到了运行时也无法发现这个错误，从而会导致错误。</p><p>如下，加入支持泛型参数，则 objArr1 中实际保存的类型（Map&lt;String,Integer&gt;），在编译的时候由于 objArr1 和 objArr2 都是 Object 类型的数组，编译通过；在运行的时候，由于 Map 中的泛型参数类型已经被擦除，也无法区分 objArr1 和 objArr2 中实际指向的两个 Map&lt;K,V&gt;数组，也是合法的，这样原本定义的是 Map&lt;String,Integer&gt;数组，却可以保存任何类似的 Map，而这本来是不允许的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objArr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objArr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
objArr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> objArr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,15),r=t(`<p>Collections 类通过一种别扭的方法绕过了这个问题，在 Collections 类编译时会产生类型未检查转换的警告。</p><p><code>ArrayList</code>具体实现的构造函数如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">V</span><span class="token punctuation">[</span><span class="token punctuation">]</span> backingArray<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        backingArray <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">V</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token constant">DEFAULT_SIZE</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为何这些代码在访问 <code>backingArray</code>时没有产生 <code>ArrayStoreException</code>呢？无论如何，都不能将 <code>Object</code>数组赋给 <code>String</code>数组。因为泛型是通过擦除实现的，<code>backingArray</code>的类型实际上就是 <code>Object[]</code>，因为 <code>Object</code>代替了 <code>V</code>。</p><p><strong>这意味着：实际上这个类期望 <code>backingArray</code>是一个 <code>Object</code>数组，但是编译器要进行额外的类型检查，以确保它包含 <code>V</code>类型的对象。</strong></p>`,5),d={href:"https://www.ibm.com/developerworks/cn/java/j-jtp01255.html",target:"_blank",rel:"noopener noreferrer"},k=t(`<h2 id="泛型容器" tabindex="-1"><a class="header-anchor" href="#泛型容器" aria-hidden="true">#</a> 泛型容器</h2><p>由于泛型的类型在运行时会被擦除，所以将类型检查放到了编译期。</p><p><code>List&lt;Clazz&gt;</code> 泛型列表只能保存指定泛型类型<code>T</code>的数据，而不能保存其子类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Fruit</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Jonathan</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">//编译时报错，类型不兼容</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Fruit</span><span class="token punctuation">&gt;</span></span> fruits <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是能保存 Fruit 的容器应该也要能安全的保存 Apple，为了实现这一点，类似于数组中<code>Object[] arr = Apple[]</code>的向上转型，可以使用<code>?</code>引入协变。</p><h3 id="协变" tabindex="-1"><a class="header-anchor" href="#协变" aria-hidden="true">#</a> 协变</h3><p><code>List&lt;? extends T&gt;</code> 可以<strong>合法的指向一个<code>List&lt; SubT&gt;</code></strong>，这个过程会完成自动<strong>向上转型</strong>，成为可以持有<strong>某个诸如 T 或者 T 的子类</strong>的 List，但是编译器不知道这个<strong>类</strong>具体是什么，所以拒绝向其中传递任何类型对象，即使 Object 也不行。</p><p>可以这么想，<code>&lt;? extends T&gt;</code>表示的是 T 的子类，那么<code>List&lt;? extends T&gt;</code> 保存的便是<strong>T 的某个子类</strong>，所以不能保存 Object 或者 T 等类型，又由于列表不能保存不同的类型，所以也不能保存任何 T 的子类，即容器将数组在运行时才会有的类型检查放到了编译期（原因是运行时类型会被擦除）。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token punctuation">&gt;</span></span> fruits <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以安全的应用</span>
fruits2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译时报错，类型转化错误</span>
fruits2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fruit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译时报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="逆变" tabindex="-1"><a class="header-anchor" href="#逆变" aria-hidden="true">#</a> 逆变</h3><p><code>List&lt;? super T&gt;</code> <strong>主动声明</strong>通配符<code>?</code>的超类型为<code>T</code>,即 List 保存的是<strong>T 的某个父类</strong>，那么 List 也可以安全的保存<strong>T 或者 T 的子类</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Apple</span><span class="token punctuation">&gt;</span></span> apples<span class="token punctuation">)</span><span class="token punctuation">{</span>
    apples<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    apples<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Jonathan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    apples<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fruit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//error 类型错误</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,13),m={href:"https://www.zhihu.com/question/20928981/answer/39234969",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.ibm.com/developerworks/cn/java/j-jtp01255.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.jianshu.com/p/2bf15c5265c5",target:"_blank",rel:"noopener noreferrer"},h=n("p",null,"《Java 编程思想 第 4 版》",-1);function j(w,f){const a=c("ExternalLinkIcon");return o(),l("div",null,[u,n("blockquote",null,[r,n("p",null,[s("来源："),n("a",d,[s("https://www.ibm.com/developerworks/cn/java/j-jtp01255.html"),e(a)])])]),k,n("p",null,[n("a",m,[s("java 为什么不支持泛型数组？ - ylxfc 的回答 - 知乎"),e(a)])]),n("p",null,[n("a",v,[s("Oracle Java 泛型原理"),e(a)])]),n("p",null,[n("a",g,[s("Java 理论和实践 - 了解泛型 - 识别和避免学习使用泛型过程中的陷阱"),e(a)])]),n("p",null,[n("a",b,[s("Java 泛型（二）协变与逆变"),e(a)])]),h])}const y=p(i,[["render",j],["__file","b2cdb69e.html.vue"]]);export{y as default};
