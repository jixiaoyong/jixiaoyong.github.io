import{_ as s,c as e,a,o as n}from"./app-DQAvLgyB.js";const t={};function l(r,i){return n(),e("div",null,i[0]||(i[0]=[a(`<p>本文为笔记性质，尚未成文。</p><h2 id="view-的坐标" tabindex="-1"><a class="header-anchor" href="#view-的坐标"><span>View 的坐标</span></a></h2><p>Android 中的坐标，以屏幕左上角顶点为原点 (0,0)，以横轴为 x 轴，竖轴为 y 轴，数值依次递增。</p><p>View 的坐标信息有以下几种，其坐标都是以父 View 的左上角顶点为原点：</p><ul><li><p>x，y 是 View 的左上角坐标。</p></li><li><p>translationX，translationY 是 View 左上角顶点与父容器左上角顶点的偏移量，默认为 0。</p></li><li><p>left，top 是分别是 View 左上角顶点的 x 轴，y 轴坐标。</p><p>right，bottom 分别是 View 右下角顶点的 x 轴，y 轴坐标。</p></li></ul><blockquote><p>注意</p></blockquote><p>x = translationX + left；</p><p>y = translationY + top；</p><p>改变 translationX/Y 的值便可以更改<strong>View 的位置</strong>。当 View 平移的时候，代表原始位置信息的 left，right，top，bottom 的值并不会变化。</p><p>在 OnTouch 事件中，我们可以从 event 得到两种值：</p><p>event.rawX,event.rawY 代表 相对于手机屏幕原点的坐标</p><p>event.X,event.Y 代表 相对于当前 View 左上角的坐标</p><p>TouchSlop 则代表认为滑动开始的最小距离</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ViewConfiguration.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).scaledTouchSlop</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="滑动" tabindex="-1"><a class="header-anchor" href="#滑动"><span>滑动</span></a></h2><p>mScroller.startScroll() 方法可以实现平滑的滑动</p><p>scrollX,scrollY 表示的是<em>view 的 X，Y 坐标减去 view 内容的 X，Y 坐标</em>。</p><p>所以 scrollX&gt;0，则表示 view 内容向左移动，scrollX&lt;0 表示 view 内容向右移动。类似于窗户 (view) 位置不变，景色 (view 内容) 的 scrollX&gt;0 即景色向右移动，则在窗户中看到的效果是景色向窗户左边移动。</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mScroller </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Scroller</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(context)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fun</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> smoothScrollBy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(destX: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, destY: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    mScroller.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">startScroll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(scrollX, scrollY, destX, destY, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//destX, destY 的值如果是正的话，会向左，上方移动</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    invalidate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">override</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fun</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> computeScroll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (mScroller.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">computeScrollOffset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        scrollTo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(mScroller.currX, mScroller.currY)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        postInvalidate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Scroller 不能使 View 滑动，而只能配合 View 的 computeScroll() 方法实现是<strong>View 的内容滑动</strong>的效果。</p><ul><li>mScroller.startScroll() 记录下要滑动的数据，而 invalidate() 通知 View 重绘；</li><li>每次重绘都会调用 computeScroll() 方法，利用 mScroller 计算出接下来要 scrollTo() 的具体值并执行，再次 postInvalidate() 通知 View 重绘；</li><li>如此反复直到绘制滑动完毕。</li></ul><p>上述无论是 translationX 还是 scrollX 等引起的 view 变化，都不能改变 View 的定位（left，right，top，bottom 值），而如果<strong>更改 margin 的值，则可以更改 View 的定位</strong>。</p><h2 id="window-和-windowmanager" tabindex="-1"><a class="header-anchor" href="#window-和-windowmanager"><span>Window 和 WindowManager</span></a></h2><p>WindowManager.LayoutParams.flags 有三个常用选项：</p><ul><li>WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL // 只处理 Window 区域内的点击事件，之外的交给其他 Window 处理</li><li>WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE // 不接受输入事件，不获取焦点，同时会开启 FLAG_NOT_TOUCH_MODAL，最终事件会传递给下层具有焦点的 Window</li><li>WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED // 让 Window 显示在锁屏界面上</li></ul><p>WindowManager.LayoutParams.type 代表 Window 的类型 (三个)：</p><ul><li>应用 Window 对应一个 Activity。<code>z-ordered</code>:1~99</li><li>子 Window 不能单独存在，附属在特定的父 Window 中，如 Dialog。<code>z-ordered</code>:1000~1999</li><li>系统 Window 需要系统权限，如 Toast，状态栏等。<code>z-ordered</code>:2000~2999</li></ul><p><code>z-ordered</code>值大的 Window 会覆盖掉低值的 Window。</p><h2 id="todo" tabindex="-1"><a class="header-anchor" href="#todo"><span>TODO</span></a></h2><p>recycleview 滑动<br> ItemTouchHelper 源码分析 <a href="https://www.jianshu.com/p/130fdd755471" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/130fdd755471</a><br> 嵌套滑动 <a href="https://blog.csdn.net/qq_15807167/article/details/51637678" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_15807167/article/details/51637678</a><br><a href="https://www.cnblogs.com/dasusu/p/9159904.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/dasusu/p/9159904.html</a><br><s>滑动展示删除按钮</s> <a href="https://www.jianshu.com/p/9bfed6e127cc" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/9bfed6e127cc</a> &gt;&gt; 对应的 demo：<a href="https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt" target="_blank" rel="noopener noreferrer">https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt</a></p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://blog.csdn.net/Holmofy/article/details/53959511" target="_blank" rel="noopener noreferrer">View 滑动效果常用属性详解：scroll、translation、LayoutParams</a></p>`,32)]))}const p=s(t,[["render",l]]),d=JSON.parse('{"path":"/posts/1b0362b.html","title":"Android 中 View 相关知识","lang":"zh-CN","frontmatter":{"permalink":"/posts/1b0362b.html","title":"Android 中 View 相关知识","abbrlink":"1b0362b","date":"2019-03-24T04:43:21.000Z","updated":"2023-12-30T08:17:02.000Z","isOriginal":true,"description":"本文为笔记性质，尚未成文。 View 的坐标 Android 中的坐标，以屏幕左上角顶点为原点 (0,0)，以横轴为 x 轴，竖轴为 y 轴，数值依次递增。 View 的坐标信息有以下几种，其坐标都是以父 View 的左上角顶点为原点： x，y 是 View 的左上角坐标。 translationX，translationY 是 View 左上角顶点与...","head":[["meta",{"property":"og:url","content":"https://jixiaoyong.github.io/blog/posts/1b0362b.html"}],["meta",{"property":"og:site_name","content":"JI,XIAOYONG"}],["meta",{"property":"og:title","content":"Android 中 View 相关知识"}],["meta",{"property":"og:description","content":"本文为笔记性质，尚未成文。 View 的坐标 Android 中的坐标，以屏幕左上角顶点为原点 (0,0)，以横轴为 x 轴，竖轴为 y 轴，数值依次递增。 View 的坐标信息有以下几种，其坐标都是以父 View 的左上角顶点为原点： x，y 是 View 的左上角坐标。 translationX，translationY 是 View 左上角顶点与..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T16:00:22.000Z"}],["meta",{"property":"article:published_time","content":"2019-03-24T04:43:21.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T16:00:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Android 中 View 相关知识\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-03-24T04:43:21.000Z\\",\\"dateModified\\":\\"2024-05-31T16:00:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JI,XIAOYONG\\",\\"url\\":\\"https://jixiaoyong.github.io\\"}]}"]]},"git":{"createdTime":1653726847000,"updatedTime":1717171222000,"contributors":[{"name":"jixiaoyong","username":"jixiaoyong","email":"jixiaoyong1995@gmail.com","commits":5,"url":"https://github.com/jixiaoyong"},{"name":"JI,XIAOYONG","username":"","email":"jixiaoyong1995@gmail.com","commits":2}]},"readingTime":{"minutes":2.68,"words":804},"filePathRelative":"_posts/Android中View相关知识.md","localizedDate":"2019年3月24日","excerpt":"<p>本文为笔记性质，尚未成文。</p>\\n<h2>View 的坐标</h2>\\n<p>Android 中的坐标，以屏幕左上角顶点为原点 (0,0)，以横轴为 x 轴，竖轴为 y 轴，数值依次递增。</p>\\n<p>View 的坐标信息有以下几种，其坐标都是以父 View 的左上角顶点为原点：</p>\\n<ul>\\n<li>\\n<p>x，y 是 View 的左上角坐标。</p>\\n</li>\\n<li>\\n<p>translationX，translationY 是 View 左上角顶点与父容器左上角顶点的偏移量，默认为 0。</p>\\n</li>\\n<li>\\n<p>left，top 是分别是 View 左上角顶点的 x 轴，y 轴坐标。</p>\\n<p>right，bottom 分别是 View 右下角顶点的 x 轴，y 轴坐标。</p>\\n</li>\\n</ul>","autoDesc":true}');export{p as comp,d as data};
