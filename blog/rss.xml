<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://jixiaoyong.github.io/blog/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://jixiaoyong.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
    <title>JI,XIAOYONG</title>
    <link>https://jixiaoyong.github.io/blog/</link>
    <description>Let&amp;apos;s make something different!</description>
    <language>zh-CN</language>
    <pubDate>Thu, 02 May 2024 13:21:22 GMT</pubDate>
    <lastBuildDate>Thu, 02 May 2024 13:21:22 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>©CC BY-NC-SA 许可协议授权，署名-非商业性使用-相同方式共享</copyright>
    <item>
      <title>Android 架构模式一览</title>
      <link>https://jixiaoyong.github.io/blog/posts/6f46f598.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/6f46f598.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 架构模式一览</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 15 Dec 2023 09:10:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Android 的架构依次有：</p>
<ul>
<li>MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>MVI</li>
<li>Clean Architecture</li>
</ul>
<p>上述架构循序渐进，当前主流设计模式是 MVVM，MVI 和 Clean Architecture，这三者的着重点各有不同，可以根据项目规模大小递进选择。</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_0.png" alt="https://github.com/skydoves/android-developer-roadmap/blob/main/README_CN.md" tabindex="0" loading="lazy"><figcaption><a href="https://github.com/skydoves/android-developer-roadmap/blob/main/README_CN.md" target="_blank" rel="noopener noreferrer">https://github.com/skydoves/android-developer-roadmap/blob/main/README_CN.md</a></figcaption></figure>
<h2> MVC</h2>
<p><strong>MVC</strong>，<strong>M</strong>odel-<strong>V</strong>iew-<strong>C</strong>ontroller，是 Android 最原始的开发方式，通过 Controller（一般为 Activity，Fragment 等）来根据用户输入处理 Model（数据/业务逻辑，比如网络请求/数据读写），并将结果更新到 View（用户界面，包括 XML，Activity，Fragment 等）上面。</p>
<p>在 Android 开发中，MVC 通常被用于实现应用程序的 UI 层。例如，在一个简单的应用程序中，<strong>View</strong> 可以是 Activity 或 Fragment，<strong>Controller</strong> 可以是 Activity 或 Fragment 的内部类，<strong>Model</strong> 可以是 POJO 类（类似 data class）。</p>
<p>但是实际开发时，<strong>View 通常会持有 Controller 和 Model 的引用产生耦合，并且几乎所有的逻辑都写在 Controller（比如 Activity/Fragment）</strong>，随着项目的进行，经常在 Activity 中即负责 View 的展示，又负责业务逻辑及数据更新，导致其臃肿难以维护。</p>
<h2> MVP</h2>
<p>因而，<strong>MVP</strong>应运而生，<strong>M</strong>odel-<strong>V</strong>iew-<strong>P</strong>resenter：</p>
<ul>
<li>Presenter 持有 View 的<strong>抽象接口</strong>和 Model，负责二者之间的通信，处理用户的输入，将 Model 的数据处理为 View 可使用的状态；</li>
<li>View 只需持有 Presenter 并实现抽象接口对应的方法即可；</li>
<li>Model 则负责存储数据，暴露访问数据的接口，请求数据等。</li>
</ul>
<p>这样将 View 和 Model 隔离，V 和 P 一一对应，复杂的视图可以组合复用多个 P。并且此时的 Presenter 不再和 Android API 关联，更容易单元测试和维护。</p>
<p>二者的区别如下图，MVP 相对于 MVC，<strong>将 V 和 M 解耦</strong>，使得 V 可以比较专注于 View 的逻辑：</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_1.png" alt="https://medium.com/cr8resume/make-you-hand-dirty-with-mvp-model-view-presenter-eab5b5c16e42" tabindex="0" loading="lazy"><figcaption><a href="https://medium.com/cr8resume/make-you-hand-dirty-with-mvp-model-view-presenter-eab5b5c16e42" target="_blank" rel="noopener noreferrer">https://medium.com/cr8resume/make-you-hand-dirty-with-mvp-model-view-presenter-eab5b5c16e42</a></figcaption></figure>
<p>关于 MVP 的代码实现，可以参考这个<a href="https://github.com/antoniolg/androidmvp" target="_blank" rel="noopener noreferrer">项目</a>。下面是一个简单的示例代码，参考了这个<a href="http://antonioleiva.com/mvp-android/" target="_blank" rel="noopener noreferrer">文章</a>：</p>
<p><strong>Model</strong>，这里是请求后台提供登录相关数据：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>View</strong>，这一层一般使用 Activity/Fragment/View 实现，会持有 Presenter 的引用来操作数据，同时为了让 Presenter 可以不直接和 View 关联，需要有一个<strong>抽象接口</strong>将二者隔离：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在 View 中除了正常的逻辑之外，还需要实现这个<code>LoginView</code>接口以便 Presenter 调用：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并且，View 中还会初始化并持有 Presenter，以通过他来响应用户的交互：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Presenter</strong>，负责 View 和 Model 的交互，将从 Model 中检索到的<strong>数据</strong>转化为 View 使用的<strong>状态</strong>。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是 MVP 对于简单的项目来说，增加了没必要的复杂性（View 抽象类，Presenter 单独出来等），代码量增加，<strong>Presenter 持有 View 在执行耗时任务时可能导致内存泄露，Activity destroy 之后如果 Presenter 访问 View 可能会导致崩溃</strong>，并且 View 和 Presenter 存在一定的耦合（当 View 中出现诸如 view 类变化等时需要同步修改 Presenter）。</p>
<h2> MVVM</h2>
<p>由此，进化出 MVVM，<strong>M</strong>odel-<strong>V</strong>iew-<strong>V</strong>iewModel，使用 ViewModel 将 View 和 Model 关联起来，同时<strong>ViewModel 不持有 View 的引用</strong>，而是 View 通过 ViewModel 操作 Model，View 监听 ViewModel 暴露出来的数据并更新 UI。</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_2.png" alt="https://medium.com/@husayn.hakeem/android-by-example-mvvm-data-binding-introduction-part-1-6a7a5f388bf7d" tabindex="0" loading="lazy"><figcaption><a href="https://medium.com/@husayn.hakeem/android-by-example-mvvm-data-binding-introduction-part-1-6a7a5f388bf7d" target="_blank" rel="noopener noreferrer">https://medium.com/@husayn.hakeem/android-by-example-mvvm-data-binding-introduction-part-1-6a7a5f388bf7d</a></figcaption></figure>
<p>在 MVVM 中<strong>ViewModel 只负责处理和提供数据，不再关心 View</strong>，便于测试，避免内存泄露；</p>
<p>页面的更新和用户事件处理都由 <strong>View</strong> 自己处理（比如用户<code>点击页面event</code>之后，View 调用 <strong>ViewModel</strong> 请求通过<strong>Model</strong>请求网络/数据库，得到并更新<code>数据state</code>后，View 监听到数据并刷新<code>页面ui</code>），<strong>二者的耦合很低</strong>。而且 Jetpack 官方提供了 LiveData/StateFlow 等可以监听 Activity 等的生命周期，降低了内存泄露风险（参考：<a href="https://blog.csdn.net/u011033906/article/details/118113466" target="_blank" rel="noopener noreferrer">探究 Android MVC、MVP、MVVM 的区别以及优缺点</a>）。</p>
<p>ViewModel 提供数据的读写方法之后，通过使用 DataBinding，可以实现 View 和 ViewMode<strong>l<a href="https://developer.android.com/topic/libraries/data-binding/two-way?hl=zh-cn" target="_blank" rel="noopener noreferrer">双向数据绑定</a></strong>（具体的代码实现可以参考<a href="https://github.com/husaynhakeem/TicTacToe-MVVM" target="_blank" rel="noopener noreferrer">TicTacToe-MVVM</a>）。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> MVI</h2>
<p>而为了<strong>进一步降低 MVVM 中 ViewModel 和 View 的耦合</strong>问题（MVVM 中 View 要调用 ViewModel 方法触发数据处理，数据可以双向绑定），简化数据流的管理，进一步演化出了 MVI（<strong>M</strong>odel-<strong>V</strong>iew-<strong>I</strong>ntent）：</p>
<p>将用户操作通过 <strong>Intent</strong> 传递给 <strong>ViewModel</strong>，ViewModel 据此更新数据，并将数据传递给 <strong>View</strong> 展示，在这个过程中<strong>事件和数据是单向</strong>的。</p>
<blockquote>
<p>⚠️ 注意，这里的 Intent 表示意图、事件，并非 Android 中 Activity 之间传递的<code>Intent</code>类</p>
</blockquote>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_3.png" alt="https://proandroiddev.com/best-architecture-for-android-mvi-livedata-viewmodel-71a3a5ac7ee3" tabindex="0" loading="lazy"><figcaption><a href="https://proandroiddev.com/best-architecture-for-android-mvi-livedata-viewmodel-71a3a5ac7ee3" target="_blank" rel="noopener noreferrer">https://proandroiddev.com/best-architecture-for-android-mvi-livedata-viewmodel-71a3a5ac7ee3</a></figcaption></figure>
<p>MVI 和 MVVM 的最大区别在于，UI 层不再直接调用 VM 的各个方法执行业务逻辑（比如下载数据）而是通过<strong>V 给 VM 发送 Intent（比如 viewModel.setEvent），<strong>由 VM 内部根据不同的 Intent 执行不同的逻辑，从而使得</strong>V 和 VM 的耦合降低，<strong>此外</strong>MVI 强调单一数据源，数据是单向流动的</strong>。</p>
<p>代码实现如下（参考自：<a href="https://github.com/myofficework000/MVI-JetpackCompose-Github" target="_blank" rel="noopener noreferrer">MVI-JetpackCompose-Github</a>）：</p>
<p><strong>UI</strong> 给 VM 发送 <strong>Intent</strong>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>VM</strong> 内部根据不同的 Intent 处理逻辑，并暴露<strong>单一数据</strong> State 给 View：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述 ViewModel 暴露出来的数据，在 View 中使用如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析上述代码的逻辑，可以看出，在 MVI 中，<strong>V</strong>iew 发送将用户操作使用<strong>I</strong>ntent 给<strong>V</strong>iewModel 处理，并从 ViewModel 获取到处理后的状态更新界面，此外 ViewModel 还负责使用 Repository 实际处理 Data，大体的逻辑示意如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_4.png" alt="https://www.scaler.com/topics/mvi-architecture-android/" tabindex="0" loading="lazy"><figcaption><a href="https://www.scaler.com/topics/mvi-architecture-android/" target="_blank" rel="noopener noreferrer">https://www.scaler.com/topics/mvi-architecture-android/</a></figcaption></figure>
<h2> Clean Architecture</h2>
<p>通过观察上述分析，我们不难发现，无论是 MVVM 还是 MVI 中，随着业务发展，VM 处理的逻辑会日益增长，繁重。在 MVVM/MVI 的基础之上，通过对业务逻辑的进一步抽象，可以实现<strong>Clean Architecture</strong>模式：</p>
<p>这也是 Android 官方如今力推的模式，将 Android APP 分为三部分：</p>
<ul>
<li><strong>UI Layer</strong>，应用层，用于和用户交互，由 View（下图的 UI elements）和 ViewModel/单纯类（下图中的 State holders）等组成，和 Android API 强关联，发起 event，展示新的 state。</li>
<li><strong>Domain Layer</strong>（复杂项目可选），业务逻辑层，对于复杂项目，可以将一些重要的业务抽象出来（比如登录逻辑：检验密码，请求登录，更新登录状态等流程），也包括一些之前使用工具类实现的方法（比如格式化日期等）。这部分的代码与 Android API 没有任何关联，是平台无关的抽象逻辑，<strong>与 Data Layer 通过抽象接口解耦</strong>（Domain Layer 只通过 repository 的抽象类与 Data 交互，而 Data Layer 则负责实现具体逻辑，比如请求数据库，网络等）。不依赖于具体的技术或框架，方便移植。</li>
<li><strong>Data Layer</strong>，数据层，这一层负责实现上一层调用的抽象接口，真正实现对数据的增删改查。</li>
</ul>
<p>上述三者中，<strong>UI Layer 依赖于 Domain Layer 处理业务逻辑，Data Layer 依赖于基础框架（网络，数据库等）来访问数据，而 Domain Layer 则不依赖上述二者方便调试和复用</strong>。</p>
<blockquote>
<p>💡 注意 Clean Architecture 是一种架构思想，本文只介绍基于 MVVM/MVI 的实现，基于 MVP 的实现可参考 <a href="https://github.com/SmartDengg/android-clean-architecture-boilerplate" target="_blank" rel="noopener noreferrer">android-clean-architecture-boilerplate</a>。</p>
</blockquote>
<p><strong>Domain layer</strong>相当于将一些常用，复杂的逻辑单独提取出来（比如过滤新闻列表，提供日期格式化工具），避免 UI 过于繁重。这个层<strong>单纯处理业务逻辑，主线程安全，无生命周期，可以复用</strong>。一定程度上减轻了 ViewModel 的负担。</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_5.png" alt="Android Clean Arhictecture https://developer.android.com/topic/architecture?hl=zh-cn" tabindex="0" loading="lazy"><figcaption>Android Clean Arhictecture <a href="https://developer.android.com/topic/architecture?hl=zh-cn" target="_blank" rel="noopener noreferrer">https://developer.android.com/topic/architecture?hl=zh-cn</a></figcaption></figure>
<p>在上图中，UI elements 用来向用户展示 UI，State holder 则使用 ViewModel/普通类等类管理数据，对 UI 暴露 data，并处理逻辑。这二者组合实现了在屏幕上展示应用数据，并在用户交互等情况下导致数据变化时，将最新数据展示到 UI 上。</p>
<p>在 Clean Architecture 中<strong>Presentation/UI Layer</strong>，<strong>Domain Layer</strong>和<strong>Data Layer</strong>这三者的层级关系，可以看下图：</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_6.png" alt="https://proandroiddev.com/clean-architecture-data-flow-dependency-rule-615ffdd79e29" tabindex="0" loading="lazy"><figcaption><a href="https://proandroiddev.com/clean-architecture-data-flow-dependency-rule-615ffdd79e29" target="_blank" rel="noopener noreferrer">https://proandroiddev.com/clean-architecture-data-flow-dependency-rule-615ffdd79e29</a></figcaption></figure>
<p>一个重要的原则就是，高层模块（圆圈内部）不应该依赖底层模块（圆圈外部），两者应该依赖于抽象。</p>
<p>这个架构满足了以下常见架构原则：</p>
<ul>
<li>关注点分离</li>
<li>数据驱动 UI（更新）</li>
<li>单一数据来源</li>
<li>单向数据流</li>
</ul>
<blockquote>
<p>Keep in mind that you don't own implementations of Activity and Fragment; rather, these are just glue classes that represent the contract between the Android OS and your app. The OS can destroy them at any time based on user interactions or because of system conditions like low memory.</p>
<p>开发者并不实际拥有/控制 Activity 和 Fragment，系统可以在必要时候回收他们，因此要尽量减少对其的依赖，只在这里处理和 UI、操作系统相关的逻辑，将<strong>关注点分离</strong>。</p>
</blockquote>
<p><strong>从数据驱动 UI</strong>：应该使用数据模型 data models（最好是持久模型）驱动 UI，这些数据模型独立于 UI 和其他组件，实现在操作系统销毁 APP 进程时他们也被销毁后，用户不会丢失数据（可以从本地，网络恢复）。</p>
<p><strong>单一事实来源</strong> Single source of truth：应用中定义的数据类型，应该分配一个单一事实来源（SSOT），这种情况下 SSOT 唯一持有/修改数据，对外暴露无可修改数据，在接受函数或事件时更新数据，比如数据库，ViewModel 等。这样将对数据修改集中到一个地方，方便定位问题。</p>
<p><strong>单向数据流</strong> Unidirectional Data Flow：在 UDF 中，数据 state 只会沿一个方向流动，而 event 沿着相反方向修改数据。这样保证数据一致性，不容易出错，便于调试。比如 jetpack compose 中，每个 composable 函数从上一级接受数据，并将事件暴露给上一级（数据向下，事件向上）</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_7.png" alt="https://developer.android.com/topic/architecture/ui-layer" tabindex="0" loading="lazy"><figcaption><a href="https://developer.android.com/topic/architecture/ui-layer" target="_blank" rel="noopener noreferrer">https://developer.android.com/topic/architecture/ui-layer</a></figcaption></figure>
<blockquote>
<p>⚠️ <a href="https://developer.android.com/topic/architecture/ui-layer/state-production?hl=zh-cn#initializing-state-production" target="_blank" rel="noopener noreferrer"><strong>警告：请避免在 ViewModel 的 init 块或构造函数中启动异步操作</strong></a>。异步操作不应是创建对象时的附带效应，因为异步代码在对象完全初始化之前可能会对该对象执行读写操作。这也称为对象泄露，可能会导致细微且难以诊断的错误。使用 Compose 状态时，这一点尤为重要。当 ViewModel 存储了 Compose 状态字段时，请勿在更新 Compose 状态字段的 ViewModel 的 init 块中启动协程，否则可能会出现 IllegalStateException。</p>
</blockquote>
<p>看一个 Clean Architecture 在 Andorid 中代码实现（<a href="https://github.com/android10/Android-CleanArchitecture-Kotlin" target="_blank" rel="noopener noreferrer">Android-CleanArchitecture-Kotlin</a>）：</p>
<p>下面代码的整体架构如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_8.png" alt="https://fernandocejas.com/2018/05/07/architecting-android-reloaded/" tabindex="0" loading="lazy"><figcaption><a href="https://fernandocejas.com/2018/05/07/architecting-android-reloaded/" target="_blank" rel="noopener noreferrer">https://fernandocejas.com/2018/05/07/architecting-android-reloaded/</a></figcaption></figure>
<p>在<strong>UI Layer</strong>中，使用 Activity/Fragment 等与 ViewModel 交互：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<strong>Domain Layer</strong>，使用 <code>XXXUseCase</code> 提取<strong>通用的业务逻辑</strong>传递给 ViewModel，将 ViewModel 和 DataLayer 隔离解耦：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看一下 UseCase 的代码：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<strong>Data Layer</strong>，暴露给 Domain Layer 的也是一个<strong>抽象类</strong>（重要，这样对 Domain Layer 屏蔽了底层的实现：网络、数据库、本地缓存），具体的实例则通过 DI 插入：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的详细分析可以参考作者的文章<a href="https://fernandocejas.com/2018/05/07/architecting-android-reloaded/" target="_blank" rel="noopener noreferrer">《构建 Android...重装上阵》</a>，这里简要分析一下：</p>
<p>通过使用 Clean Architecture，我们将 Android APP 分为 UI Layer，Domain Layer，Data Layer 三部分，其中 Domain Layer 是 APP 的主要业务逻辑，不依赖于其他部分，和 Android API 无关，可移植，是 APP 的中心，而 UI Layer 专注处理与用户的交互，而 Data Layer 则实际负责数据读写，这部分的实现可以自由切换。</p>
<h2> 总结</h2>
<p>从 MVC、MVP，到 MVVM、MVI，再到结合 Clean Architecture，随着 Android 开发架构的演进，代码层级越多，抽象越深，带来的是不同层级之间耦合降低，各个层级的关注点分离，更容易测试和维护。</p>
<h2> 参考资料</h2>
<p>《Android 架构指南》<a href="https://developer.android.com/topic/architecture" target="_blank" rel="noopener noreferrer">https://developer.android.com/topic/architecture</a></p>
<p>《The Clean Architectur uncle-bob》<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener noreferrer">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></p>
<p>《How to architect Android apps: a deep dive into principles, not rules 如何构建 Android 应用程序：深入探讨原则，而不是规则》<a href="https://proandroiddev.com/how-to-architect-android-apps-a-deep-dive-into-principles-not-rules-2f1eb7f26402" target="_blank" rel="noopener noreferrer">https://proandroiddev.com/how-to-architect-android-apps-a-deep-dive-into-principles-not-rules-2f1eb7f26402</a></p>
<p>《干净的架构初学者指南》<a href="https://betterprogramming.pub/the-clean-architecture-beginners-guide-e4b7058c1165" target="_blank" rel="noopener noreferrer">https://betterprogramming.pub/the-clean-architecture-beginners-guide-e4b7058c1165</a></p>
<p>《Architecting Android...The clean way?》<a href="https://fernandocejas.com/blog/engineering/2014-09-03-architecting-android-the-clean-way/" target="_blank" rel="noopener noreferrer">https://fernandocejas.com/blog/engineering/2014-09-03-architecting-android-the-clean-way/</a></p>
<p>《Android Clean Architecture Kotlin》<a href="https://github.com/android10/Android-CleanArchitecture-Kotlin" target="_blank" rel="noopener noreferrer">https://github.com/android10/Android-CleanArchitecture-Kotlin</a></p>
<p>《构建 Android 重装上阵》<a href="https://fernandocejas.com/2018/05/07/architecting-android-reloaded/" target="_blank" rel="noopener noreferrer">https://fernandocejas.com/2018/05/07/architecting-android-reloaded/</a></p>
<p>《Google 推荐使用 MVI 架构？卷起来了~》<a href="https://juejin.cn/post/7048980213811642382" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7048980213811642382</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/blog/android_architecture/android_architecture_0.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 动画分析之 CustomPaint</title>
      <link>https://jixiaoyong.github.io/blog/posts/adf541c0.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/adf541c0.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 动画分析之 CustomPaint</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 29 Aug 2022 12:57:16 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文讨论的 Flutter 动画主要限定在：<em>随着每一帧的变化，修改 Flutter Widget 的大小、颜色、位置等属性，使之看起来从一种状态渐变为另外一种状态</em> 这一范围。</p>
</blockquote>
<p>根据之前的分析，关于 Flutter 中的 Widget 动画，大体可以分为三大类：</p>
<ul>
<li>
<p><strong>隐式动画</strong>，以 ImplicitlyAnimatedWidget 及其子类为代表。特点是当涉及到的属性变化后，这些 Widget 会 <em>自动渐变到新的属性</em>，使用者只能设置动画的 Duration、Tween、Curve 等，而无法主动终止、反向执行动画。</p>
<p>涉及到的类主要有 TweenAnimationBuilder 以及一系列以 AnimatedFoo 命名的类。</p>
</li>
<li>
<p><strong>显式动画</strong>，以 AnimatedWidget 及其子类为代表，需要配合 AnimationController 使用。特点是 <em>当 AnimationController 的值变化时，Widget 中对应的属性也会随之变化</em>。</p>
<p>涉及到的类主要有 AnimationBuilder/AnimatedWidget 以及一系列 FooTransition 命名的类。</p>
</li>
<li>
<p><strong>自定义动画</strong>，如果上述两种方式还无法满足需求，则可以使用 CustomPaint + CustomPainter + Listenable（比如 AnimationController）实现动画，特点是实现方式灵活，但同时也比上述两者难度高一些。</p>
</li>
</ul>
<p>Flutter 中这些与动画有关的类如何选择，Flutter 官方给了一张图以供参考：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_select.png" alt="如何实现 Flutter 中的动画" tabindex="0" loading="lazy"><figcaption>如何实现 Flutter 中的动画</figcaption></figure>
<br>
<p>本文将着重分析<strong>使用 CustomPaint 实现自定义动画</strong>，涉及到的类以及他们的关系图如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/paint/flutter_paint_class_struct.png" alt="CustomPaint 自定义动画" tabindex="0" loading="lazy"><figcaption>CustomPaint 自定义动画</figcaption></figure>
<h2> 源码分析</h2>
<p>先来看一个使用 CustomPaint 实现的动画（动画的内容是一个反复变大又缩小的蓝色小球）：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码是我们使用 CustomPaint 实现自定义动画的常见用法，接下来我们逐一分析上述涉及到的类的作用。</p>
<h3> CustomPaint</h3>
<blockquote>
<p>A widget that provides a canvas on which to draw during the paint phase.</p>
</blockquote>
<p>CustomPaint 继承自 SingleChildRenderObjectWidget，其内部持有 CustomPainter 并将其传入创建 RenderCustomPaint 以获取 Canvas 用于绘制内容。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 CustomPaint 内部并没有太多逻辑，控制 CustomPainter 绘制的主要逻辑都在 RenderCustomPaint 中。</p>
<h3> RenderCustomPaint</h3>
<blockquote>
<p>Provides a canvas on which to draw during the paint phase.</p>
</blockquote>
<p>作为 RenderObject 的 RenderCustomPaint，负责实际计算 size、在 Flutter 框架 paint 阶段安排 painter、foregroundPainter 以及 child 的绘制。</p>
<p>以 CustomPaint 传入的 CustomPainter? painter 为例，在 RenderCustomPaint 的构造方法中它被赋值给_painter，随后当 attach 到 RenderObject Tree 时，对 CustomPainter 添加了监听：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码可以看出，RenderCustomPaint 对 CustomPainter 添加监听，只要值变化就执行 markNeedsPaint；</p>
<p>而如果是更新了 CustomPainter，则会执行 RenderCustomPainter.painter 方法，最终在_didUpdatePainter 方法中重写对新的 CustomPainter 添加监听以触发 markNeedsPaint：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述两种方法最终都会直接触发 paint 阶段（跳过了 build 和 layout 阶段），最终由 Flutter Framework 调用 RenderCustomPainter.paint 方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 RenderCustomPaint 使用 CustomPainter 实现绘制的过程，大体分为 3 部分：</p>
<ul>
<li>在 attach 方法中监听从 CustomPaint 传入的 CustomPainter，一旦其有变化就执行 markNeedsPaint 方法，引导 Flutter 框架重新绘制内容。</li>
<li>如果中间通过 RenderCustomPainter.painter/foregroundPaint 更改 CustomPainter，则会重新监听以触发 markNeedsPaint。</li>
<li>当 Flutter 框架执行重绘时，会通过 RenderCustomPaint.paint 方法最终调用 CustomPainter.paint 方法绘制内容。</li>
</ul>
<p>除此之外，RenderCustomPainter 还通过 computeMinIntrinsicWidth/computeMaxIntrinsicHeight 等方法计算合适的 Size，以及使用 hitTestChildren/hitTestSelf 等处理点击事件等等。</p>
<h3> CustomPainter</h3>
<blockquote>
<p>The interface used by <em>CustomPaint</em> (in the widgets library) and <em>RenderCustomPaint</em> (in the rendering library).</p>
</blockquote>
<p>CustomPainter 提供 paint 方法让使用者使用 Canvas 绘制内容；继承自 Listenable，所以可以通过 addListener/removeListener 方法监听。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CustomPainter 有两种使用方式：</p>
<ul>
<li>
<p><strong>继承自 CustomPainter</strong>（推荐），可以传入 Listenable，这样 RenderCustomPaint 监听的便是这个 Listenable 对象。</p>
</li>
<li>
<p><strong>继承 Listenable 或其子类，并实现 CustomPainter 接口</strong>（<em>Dart 语言特性，会要求实现其所有方法属性</em>），这样监听的便是这个实现类对象本身。</p>
</li>
</ul>
<p>当通知 listener 时会通过 RenderCustomPaint 执行 markNeedsPaint，触发 Flutter Framework 重新安排绘制，最终执行 CustomPainter.paint 方法重新绘制内容。</p>
<p>无论哪种实现方式，都必须实现 shouldRepaint 和 paint 两个方法。</p>
<ul>
<li>
<p><code>bool shouldRepaint(covariant CustomPainter oldDelegate)</code> 每当新的 CustomPainter 提供给 RenderCustomPaint 时都会调用此方法，再判断是否调用 paint 方法。</p>
<p>如果前后 CustomPainter 的信息不同影响到绘制，则应该返回 true；否则返回 false 则可能导致 paint 方法被省略。</p>
<p>即使此方法返回 false，paint 也可能会被回调（Listenable 调用 listener 触发）；如果 size 变化等情况下会直接调用 paint 方法。</p>
</li>
<li>
<p><code>void paint(Canvas canvas, Size size)</code> 每当对象需要 paint 的时候都会调用。</p>
<p>传入的 Canvas 的坐标系以左上角为原点，范围无限大，但 box 的大小为 size，绘制的内容应当在 size 范围内，否则可能有性能问题，可以在最开始使用 Canvas.clipRect 限制绘制范围。</p>
</li>
</ul>
<h3> Canvas</h3>
<blockquote>
<p>An interface for recording graphical operations.</p>
</blockquote>
<p>当使用 PaintingContext.canvas 方法获取 Canvas 时，（如果 canvas 为 null）会创建 ui.PictureRecorder() 并以此创建 Canvas。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>PictureRecorder 使用 Canvas 记录图形操作的接口，在<code>PictureRecorder.endRecording</code>方法中使用其创建 Picture，后者被 SceneBuilder 用来在<code>SceneBuilder.build()</code>方法中创建 Scene。<br>
最终在<code>FlutterView.render</code>方法中，Scene 被 GPU 绘制在屏幕上。</p>
</blockquote>
<p>Canvas 有常用的方法：</p>
<ul>
<li>
<p><code>save()</code> 将当前的 transform 和 clip 等的复制保存在 save stack 上面，必须使用 <code>restore()</code>方法恢复</p>
</li>
<li>
<p><code>saveLayer()</code>，与 <code>save()</code>方法类似，但是执行以后，后续操作都是在一个新的 layer 上面进行，相当于一个独立的图层。</p>
<p>可以通过 Paint.colorFilter、Paint.blendMode 等属性配置其与之前图层的叠加方式。<br>
<strong>比较耗性能</strong>，好处是可以对后续操作绘制的内容统一处理（<em>比如，单独画两个圆，然后抗锯齿会分别执行两次，可能会出现毛刺，而使用 saveLayer 后这两个圆相当于一个整体，使用抗锯齿效果会很好</em>）。</p>
</li>
<li>
<p><code>restore()</code>，pop 掉当前的 save stack，save 和 saveLayer 方法与此方法一一对应。saveLayer 创建的 layer 会和之前的 layer 合并。</p>
</li>
<li>
<p><code>translate/scale/rotate</code> 对画布进行平移、缩放、旋转操作</p>
</li>
<li>
<p><code>clipRect/clipRRect/clipPath</code> 裁剪画布的绘制范围</p>
</li>
<li>
<p><code>drawColor/drawLine/drawRRect/drawRect...</code> 等等绘制各种形状</p>
<p>绘制文字应该使用 TextPainter，不推荐使用 drawParagraph</p>
</li>
<li>
<p><code>skew/transform</code> 倾斜/变换画布</p>
</li>
</ul>
<h3> 小结</h3>
<p>到这里我们差不过分析了刚开始的 demo 涉及到的类，总结一下他们各自的角色：</p>
<ul>
<li>
<p>AnimationController 对象（也即 Listenable 对象），用来监听 Flutter Framework 的帧刷新，根据设定的时长、曲线等通知 listener，以达到控制动画的效果。</p>
</li>
<li>
<p>CustomPaint，作为 SingleChildRenderObjectWidget，主要作用是将 CustomPainter、Widget child 等各类参数传递给 RenderCustomPaint。</p>
</li>
<li>
<p>RenderCustomPainter，作为 RenderProxyBox，优先以 Widget child 的大小为准，会监听传入的 CustomPainter 对象，并在其变化时触发 Flutter Framework 安排重新绘制（跳过 build 和 layout 阶段，直接进入 paint 阶段）；</p>
<p>当需要绘制时，会依次安排背景、child、前景的绘制。而这里的背景和前景都由传入的 CustomPainter 负责实际绘制。</p>
</li>
<li>
<p>CustomPainter，本身是 Listenable 的子类，可以被 RenderCustomPaint 监听，其 paint 方法实际负责绘制内容。</p>
<p>使用是可以继承此类（推荐），也可以当做接口实现所有方法。</p>
</li>
<li>
<p>Canvas，Paint 则是负责实际绘制。</p>
</li>
</ul>
<h2> 总结</h2>
<p>到本文为止，我们分析了 Flutter 动画实现的各种方式及其原理：</p>
<p>Flutter Widget 动画，是<a href="https://jixiaoyong.github.io/blog/posts/6ec43bd8.html" target="_blank" rel="noopener noreferrer">AnimationController</a>通过 Ticker 监听 Flutter 屏幕刷新，然后根据<a href="https://jixiaoyong.github.io/blog/posts/820d6240.html" target="_blank" rel="noopener noreferrer">Tween/Curve</a>/Duration 等一系列参数计算出实时的值，Flutter 的 Widget 则根据这些值计算、修改对应属性从而实现动画效果。</p>
<p>Flutter 内置的动画分为<a href="https://jixiaoyong.github.io/blog/posts/47c43abe.html" target="_blank" rel="noopener noreferrer">隐式动画和显式动画</a>两种，如果这些动画还无法满足需求，可以使用 CustomPaint 实现自定义动画（本文内容）。</p>
<blockquote>
<p>Flutter 中的<a href="https://jixiaoyong.github.io/blog/posts/62beedda.html" target="_blank" rel="noopener noreferrer">Hero 动画</a>便是使用显式动画中的 AnimationBuilder、Tween 等实现的。</p>
</blockquote>
<h2> 参考资料</h2>
<p><a href="https://api.flutter.dev/flutter/widgets/CustomPaint-class.html" target="_blank" rel="noopener noreferrer">CustomPaint api.flutter.dev</a></p>
<p><a href="https://api.flutter.dev/flutter/dart-ui/Canvas-class.html" target="_blank" rel="noopener noreferrer">Canvas api.flutter.dev</a></p>
<p><a href="https://stackoverflow.com/a/59650400/8389461" target="_blank" rel="noopener noreferrer">What is Canvas.save and Canvas.restore? stackoverflow.com</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_select.png" type="image/png"/>
    </item>
    <item>
      <title>关于</title>
      <link>https://jixiaoyong.github.io/blog/about.html</link>
      <guid>https://jixiaoyong.github.io/blog/about.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">关于</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 06 Jun 2016 06:06:06 GMT</pubDate>
      <content:encoded><![CDATA[<img src="https://jixiaoyong.github.io/images/20191026161934.png" class="full-image">
<h1 align="center">Hi 👋, I'm JI,XIAOYONG <img src="https://img.shields.io/github/followers/jixiaoyong?style=social"></h1>
<h3 align="center">A developer. <br>A man who love the world.</h3>
<h3 align="left">Keep touch with me:</h3>
<p align="left">
<a href="mailto:jixiaoyong1995@gmail.com" target="_blank" rel="noopener noreferrer">
<img src="https://img.shields.io/badge/gamil-jixiaoyong1995-31aa52?logo=Gmail"></a>
&nbsp;<a href="https://jixiaoyong.github.io/" target="_blank" rel="noopener noreferrer"><img src="https://badgen.net/badge/🌐/jixiaoyong.github.io/cyan"></a>
&nbsp;<a href="https://leetcode.com/jixiaoyong/" target="_blank" rel="noopener noreferrer">
&nbsp;<img src="https://img.shields.io/badge/LeetCode-jixiaoyong-ffa725?logo=LeetCode"></a>
&nbsp;<img src="https://komarev.com/ghpvc/?username=jixiaoyong&amp;label=Profile views&amp;color=0e75b6&amp;style=flat" alt="jixiaoyong">
</p>
<h3 align="left">Languages and Tools:</h3>
<p><img src="https://s3.bmp.ovh/imgs/2022/04/23/145404445e75d358.webp" alt="flutter" width="auto" height="75">&nbsp;<img src="https://s3.bmp.ovh/imgs/2022/04/23/97ce58509314acd3.webp" alt="android" width="auto" height="70">&nbsp;<img src="https://s3.bmp.ovh/imgs/2022/04/23/d26f3568e7f51be1.webp" alt="dart" width="auto" height="75">&nbsp;<img src="https://s3.bmp.ovh/imgs/2022/04/23/00f2c6fdf1695763.webp" alt="java" width="auto" height="75">&nbsp;<img src="https://s3.bmp.ovh/imgs/2022/04/23/5f6b77b74970f139.webp" alt="kotlin" width="auto" height="75"></p>
<br>
<p>学习的过程需要不断的探索、累积，更需要有条理的总结，我会把平时学习的心得体会、经验总结放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。</p>
<p>我的邮箱是：aml4aWFveW9uZzE5OTVAZ21haWwuY29tCg==</p>
<h1> 2018-02-27 update</h1>
<p>在我学习的过程中，互联网给了我莫大的支持与帮助。但不可否认的是，中文互联网存在着很多“相互借鉴”的资料，其中不可避免有很多未经查实的资料，其危害不小。</p>
<p>今天就因为这种问题，白白耽搁了一晚上的时间。而这还是我已经发现的有明显谬论的地方，其他没有发现的更是不知几多。</p>
<p>很遗憾在此之前，我自己也写过不少这样欠缺思考，直接“拿来主义”的文章，真是惭愧。今日起，技术类文章务必自己理解了，理顺了才写，务必每个观点都有对应的参考依据。宁可少写，也不能乱写瞎写。之前的文章，也要慢慢的修正。</p>
<p>哎呀，一不小心立了个 Flag，千万不要打脸 (￣ ε(#￣)☆╰╮(￣ ▽ ￣///)。</p>
<h1> 2019-03-25 update</h1>
<p>今后写博客，尽量避免写一些口水文，基础教程之类的文章，这类文章在我的学习过程中对我有很大的帮助，但网络上已经有很多步骤更加具体，内容更加完善的文章，实在没有必要再花费时间在这里了。日后逐渐深入源码，探究平常用法背后的实现原理，希望以此记录自己提升技术能力的过程。</p>
<h1> 2023-04-06</h1>
<p>如你所见，这是一个托管在 <a href="https://github.com" target="_blank" rel="noopener noreferrer">GitHub</a> 上面的博客，基于<a href="https://v2.vuepress.vuejs.org/" target="_blank" rel="noopener noreferrer">vuepress 2.0</a>的<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">hope</a>主题，感谢所有为以上提到的项目有过付出的人，没有他们的话这个小站不会存在。</p>
<p>在此之前，本博客使用了大约五六年的主题是基于<a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener noreferrer">NexT</a>主题，在我对编程尚且懵懂之际，为我提供了一个尚且不错的博客，感谢以上各位朋友。</p>
<h1> TODO List</h1>
<ul>
<li>选好方向</li>
<li>广泛阅读</li>
<li>深入思考</li>
<li>及时总结</li>
<li>定时输出</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Android 开发常用设置</title>
      <link>https://jixiaoyong.github.io/blog/posts/1c56d6b9.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/1c56d6b9.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 开发常用设置</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 27 Aug 2017 15:25:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Android Studio</h2>
<ul>
<li>
<p>国内较快的仓库：</p>
<p>maven {url'<a href="http://maven.aliyun.com/nexus/content/groups/public/" target="_blank" rel="noopener noreferrer">http://maven.aliyun.com/nexus/content/groups/public/</a>'}</p>
</li>
<li>
<p>RecyclerView 添加依赖<br>
注意 RecyclerView 的版本号要和当前工程中其他 android.support 包版本保持一致，否则虽然导入了对应的包，但是仍然无法正常使用。</p>
<p>compile 'com.android.support:recyclerview-v7:26+'</p>
</li>
<li>
<p>设置：<br>
自动添加依赖：insert imports on paste: None<br>
自动删除无用依赖：Optimize imports on the fly</p>
</li>
</ul>
<h2> Linux</h2>
<ul>
<li>
<p>设置 ndk 环境变量 /etc/profile</p>
<p>#set ndk env<br>
NDKROOT=/home/jixiaoyong/AndroidDev/Sdk/ndk-bundle<br>
export PATH=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>D</mi><mi>K</mi><mi>R</mi><mi>O</mi><mi>O</mi><mi>T</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">NDKROOT:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.07153em;">DK</span><span class="mord mathnormal" style="margin-right:0.13889em;">ROOT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span></span></span></span>PATH</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Android11 文件分区存储在图片读写的适配</title>
      <link>https://jixiaoyong.github.io/blog/posts/12cb887a.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/12cb887a.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android11 文件分区存储在图片读写的适配</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 01 Jun 2021 06:34:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 说明</h2>
<p>当 APP 目标版本是 Android 10（API 29）及以后时，由于 Android 引入了分区存储，APP 不能直接通过路径访问文件，访问外部存储空间中的媒体文件除了需要<code>READ_EXTERNAL_STORAGE</code> 或 <code>WRITE_EXTERNAL_STORAGE</code> 权限之外，需要通过其他 APP 分享的<code>Uri</code>读写文件，同理要给其余 APP 分享文件也许要通过<code>FileProvider</code>生成<code>Uri</code>并赋予对应的权限。</p>
<p>本文以从相册中获取图片、请求系统裁剪并返回图片为例展示对应的适配方法。</p>
<h2> 实际操作</h2>
<p>1.<strong>从相册中获取图片</strong></p>
<p>从相册中获取到的图片<code>Uri</code>一般如：<code>content://raw//storage/emulated/0/DCIM/Camera/IMG_20210531_183008.HEIC</code></p>
<p>app 内部要读取其内容的话，可以通过<code>context.getContentResolver().openInputStream(imageUri)</code></p>
<p>或者</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等方式读取，操作该图片。</p>
<p>2.<strong>将外部文件保存到本地并获取 Uri</strong></p>
<p>由于上述方式获取到的<code>Uri</code>只对本 APP 赋予了权限，要是希望将此图片分享给第三方 APP 进一步加工处理，则可能出现第三方 APP 没有读写权限而导致操作失败的情况，为了避免这种情况，可以将获取到的图片缓存到 APP 私有目录，并且重新生成<code>Uri</code>并赋予将要处理该图的第三方 APP 对应权限。</p>
<p>将外部文件缓存本地的步骤参考第一步操作即可自行完成，主要讲解一下如何将对外分享的<code>Uri</code>赋予读写权限。</p>
<p>下面这个方法在不同系统分别采用不同方式获取文件对应的<code>Uri</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>com.your.app.packagename.fileprovider</code>是<a href="https://developer.android.google.cn/reference/androidx/core/content/FileProvider" target="_blank" rel="noopener noreferrer"><code>FileProvider</code></a>的<code>authorities</code>。</p>
<p>要使用<code>FileProvider</code>可以参考<a href="https://developer.android.google.cn/reference/androidx/core/content/FileProvider#ProviderDefinition" target="_blank" rel="noopener noreferrer">定义 FileProvider</a>操作，一般只需要修改<code>authorities</code>即可，同时如果是开发 Android 库，为了避免与主工程已有的<code>FileProvider</code>冲突，可以继承<code>FileProvider</code>类并修改下文中<code>name</code>字段。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时，为了定义此<code>FileProvider</code>可以使用的文件目录范围，可以在<code>res/xml</code>文件夹中新建<code>file_paths.xml</code>并做如下配置，也可参考官方文档或者<a href="https://www.jianshu.com/p/6192f04eca11" target="_blank" rel="noopener noreferrer">Android N 7.0 FileProvider 兼容适配 原理解析</a>：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.<strong>对外分享有权限的 Uri</strong></p>
<p>对于上述步骤获取到的图片 Uri 赋予权限有两种方式：</p>
<p>第一种，通过<code>Intent</code>传递出去的<code>imgUri</code>，可以使用以下方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这种只适用于主动分享出去的文件，在调用第三方 APP 裁剪的场景中，一般还需要一个<code>outPutUri</code>用于保存裁剪之后的图片，对于这种场景，可以查询可能会调用的 APP 并赋予其访问权限：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样不管是分享出去的原图，还是裁剪之后保存的图片都给第三方 APP 赋予了权限，保证其可以正常访问。</p>
<h2> 参考文献</h2>
<p><a href="https://developer.android.google.cn/reference/androidx/core/content/FileProvider" target="_blank" rel="noopener noreferrer">https://developer.android.google.cn/reference/androidx/core/content/FileProvider</a></p>
<p><a href="https://www.jianshu.com/p/6192f04eca11" target="_blank" rel="noopener noreferrer">Android N 7.0 FileProvider 兼容适配 原理解析</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android AlarmManager 设置重复任务</title>
      <link>https://jixiaoyong.github.io/blog/posts/5754fcd2.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/5754fcd2.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android AlarmManager 设置重复任务</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 06 Dec 2019 10:18:18 GMT</pubDate>
      <content:encoded><![CDATA[<p>近期有一个实现定时启动 APP 提醒用户的需求，一番比较之后觉得用闹钟<code>AlarmManager</code>实现比较合适，本文是对此过程的梳理，属于比较基础性的内容。</p>
<h2> 需求</h2>
<p>需求需要实现</p>
<blockquote>
<p>"每天在指定时间范围内，循环提示用户直到满足指定的条件"</p>
</blockquote>
<p>拆分需求：</p>
<ol>
<li>每天都要提醒</li>
<li>在时间范围内一直循环</li>
<li>满足条件后结束当天循环</li>
</ol>
<h2> 方案选择</h2>
<p>Android 中可以用到的循环任务实现有<code>Handler</code>、<code>Timer</code>、<code>ScheduledExecutorService</code>（这三个可以看<a href="https://blog.csdn.net/qq_27489007/article/details/79220609" target="_blank" rel="noopener noreferrer">这里</a>），还有最近的<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager" target="_blank" rel="noopener noreferrer"><code>WorkManager</code></a>和我们要用到的<a href="https://developer.android.google.cn/training/scheduling/alarms" target="_blank" rel="noopener noreferrer"><code>AlarmManager</code></a>。</p>
<blockquote>
<p>WorkManager offers a backwards compatible (API level 14+) API leveraging <a href="https://developer.android.google.cn/reference/android/app/job/JobScheduler" target="_blank" rel="noopener noreferrer"><code>JobScheduler</code></a> API (API level 23+) and above to help optimize battery life and batch jobs and a combination of <a href="https://developer.android.google.cn/reference/android/app/AlarmManager" target="_blank" rel="noopener noreferrer"><code>AlarmManager</code></a> &amp; <a href="https://developer.android.google.cn/reference/android/app/BroadcastReceiver" target="_blank" rel="noopener noreferrer"><code>BroadcastReceiver</code></a> on lower devices.</p>
</blockquote>
<p>这几个方案中，前三者都需要 APP 在前台运行，<code>WorkManager</code>和<code>AlarmManager</code>则在 APP 退出之后也可以使用，甚至在低版本上<code>WorkManager</code>底层也是通过<code>AlarmManager</code>实现的。</p>
<p><code>WorkManager</code>主要倾向于保证任务在 APP 退出，甚至设备关机重启等情况下也会被执行，虽然也提供循环任务的，但是无法确保在精确的时间得到执行，且最小间隔 15min。</p>
<p>相比之下，<code>AlarmManager</code>可以确保任务在指定时间（精确的时间）得到执行，并且对于循环的间隔也更加灵活。</p>
<figure><img src="https://developer.android.google.cn/images/guide/background/bg-job-choose.svg" alt="Android 推荐选择方案" tabindex="0" loading="lazy"><figcaption>Android 推荐选择方案</figcaption></figure>
<h2> 分析</h2>
<p>据 Android 官网介绍，闹钟主要用于在应用程序生命周期之外进行定时操作。</p>
<p>闹钟具有以下特征：</p>
<blockquote>
<ul>
<li>它们可让您按设定的时间和/或间隔触发 intent。</li>
<li>您可以将它们与广播接收器结合使用，以启动服务以及执行其他操作。</li>
<li>它们在应用外部运行，因此即使应用未运行，或设备本身处于休眠状态，您也可以使用它们来触发事件或操作。</li>
<li>它们可以帮助您最大限度地降低应用的资源要求。您可以安排定期执行操作，而无需依赖定时器或持续运行后台服务。</li>
</ul>
</blockquote>
<p>需要注意的是，Android 为了避免重复闹钟可能带来的性能消耗，推荐使用不是很精确的<code>setInexactRepeating()</code>，而不是精确的<code>setRepeating()</code>，并且在<code>API19+</code>之后的所有的重复闹钟都不是精确的，如果需要精确闹钟需要使用 <code>setWindow(int, long, long, android.app.PendingIntent)</code> 或<code>setExact(int, long, android.app.PendingIntent)</code>。重复闹钟具有以下特征：</p>
<blockquote>
<ul>
<li>闹钟类型。要了解详情，请参阅<a href="https://developer.android.google.cn/training/scheduling/alarms#type" target="_blank" rel="noopener noreferrer">选择闹钟类型</a>。</li>
<li>触发时间。如果您指定的触发时间为过去的时间，则闹钟会立即触发。</li>
<li>闹钟的间隔。例如，每天一次、每小时一次、每 5 分钟一次，等等。</li>
<li>闹钟触发的待定 intent。当您设置了使用同一待定 intent 的第二个闹钟时，它会替换原始闹钟。</li>
</ul>
</blockquote>
<h3> 闹钟类型</h3>
<p>闹钟有两个类型：</p>
<ol>
<li>
<p>距离系统启动后的时间，主要用于“间隔多久重复一次”这样的需求</p>
<p><code>ELAPSED_REALTIME</code> 距离开机时间多久后启用闹钟，如果系统在休眠中则不会唤醒</p>
<p><code>ELAPSED_REALTIME_WAKEUP</code> 在系统休眠时也会唤醒系统</p>
</li>
<li>
<p>精确的时间 UTC，主要用于“在当天下午 8 点整开始”等这样的需求</p>
<p><code>RTC</code> 在指定的时间触发闹钟，不会唤醒机器</p>
<p><code>RTC_WAKEUP</code> 在指定时间触发闹钟，并且唤醒设备</p>
</li>
</ol>
<h3> 触发时间</h3>
<p>闹钟触发的时间，分为从设备上次启动时间和精准时间两种。</p>
<p>如果触发的时间早于当前系统时间的话，系统会根据过去的时间和重复间隔选择一个合适的时间来触发（有几分钟内的误差）。</p>
<p>从实际运行来看，使用<code>ELAPSED_*</code>的基本上会立即（几秒钟）触发该闹钟，并且每次循环间隔有几毫秒的误差。</p>
<p>使用<code>RTC_*</code>则会在刚开始的两三次出现间隔时间小于指定时间的情况，后期稳定：</p>
<p>设置的闹钟间隔为 10 分钟，闹钟开始时间早于当前时间，唤醒结果如下</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 间隔时间</h3>
<p>间隔时间有两种：</p>
<ol>
<li><code>AlarmManager interval</code> 如果设置的是<code>setInexactRepeating()</code>，则需要设置<code>AlarmManager </code>指定的几种间隔时间。</li>
<li>任意时间 <code>setRepeating()</code>方法可以使用任意时间</li>
</ol>
<h3> 待定的 intent</h3>
<blockquote>
<p>当您设置了使用同一待定 intent 的第二个闹钟时，它会替换原始闹钟</p>
</blockquote>
<p>待定的<code>Intent</code>是一个<code>PendingIntent</code>，可以用来打开<code>Service</code>，<code>Activity</code>，<code>Broadcast</code>等等。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里的<code>requestCode</code>，当不需要该闹钟时可以根据这个来取消。</p>
<h3> 取消闹钟</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 在重启时恢复闹钟</h3>
<p>由于闹钟会在设备关机的时候被取消，所以需要监听设备开机广播（<code>android.intent.action.BOOT_COMPLETED</code>），并且恢复闹钟。</p>
<h2> 具体实现</h2>
<h3> 设置一个每天指定时间循环的闹钟</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在每天指定时间到了之后，开始设置一个间隔 10 分钟唤醒一次的闹钟，直到超时或者满足指定的条件后取消该闹钟。</p>
<h3> 监听每日循环的闹钟</h3>
<p>监听其发送的广播<code>BROADCAST_ACTION_REPEAT</code>。</p>
<p>启用当日循环闹钟：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在广播接收器中收听到<code>BROADCAST_ACTION_START</code>后去开启任务</p>
<h3> 条件满足后关闭当日循环闹钟</h3>
<p>在收到<code>BROADCAST_ACTION_START</code>后检测到已经超时或其他满足取消条件的情况，则取消任务。</p>
<p>或者可以再订一个结束时间的闹钟，到时间后取消当日循环闹钟。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里的<code>pIntent</code>需要与设置闹钟时的<code>PendingIntent</code>一致 (满足<code>Intent.filterEquals()</code>的条件)。</p>
<h2> 参考资料</h2>
<p><a href="https://blog.csdn.net/qq_27489007/article/details/79220609" target="_blank" rel="noopener noreferrer">Android 定时任务及循环任务基础大集合</a></p>
<p><a href="https://developer.android.google.cn/training/scheduling/alarms" target="_blank" rel="noopener noreferrer">安排重复闹钟 Android 官网</a></p>
]]></content:encoded>
      <enclosure url="https://developer.android.google.cn/images/guide/background/bg-job-choose.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>Android 事件分发</title>
      <link>https://jixiaoyong.github.io/blog/posts/c0fefed0.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/c0fefed0.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 事件分发</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 24 Apr 2018 12:25:33 GMT</pubDate>
      <content:encoded><![CDATA[<p>Android 事件分发，指手指点击屏幕后，从 Activity、ViewGroup 到 View 的一系列过程。</p>
<h2> 简介</h2>
<p>Android 系统的窗口机制如下图：</p>
<p>Activity 内有一个 Window 对象，其实现类是 PhoneWindow；</p>
<p>DecorView 为顶层 View，DecorView 是一个 FrameLayout，其中有 TitleView 和 ContentView；</p>
<figure><img src="https://jixiaoyong.github.io/images/blog/2018-04/AndroidDispatchTouchEvent.png" alt="Android 系统窗口管理机制" tabindex="0" loading="lazy"><figcaption>Android 系统窗口管理机制</figcaption></figure>
<p>TitleView 为标题栏，ContentView 就是平时在 Activity 的 onCreate() 方法中设置的视图，TitleView 可以用<code>this.requestWindowFeature(Window.FEATURE_NO_TITLE);</code>隐藏掉，但是必须注意要在 setContentView() 之前，原因如下所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 点击事件 Activity --&gt; ViewGroup</h2>
<p>点击事件发生后，首先被调用的是<code>Activity.dispatchTouchEvent()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，其内部先调用了<code>getWindow().superDispatchTouchEvent(ev)</code>这个方法，getWindow() 返回的 mWindow 是 PhoneWindow 的对象。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再看看 PhoneWindow.superDispatchTouchEvent() 方法，显然又调用了 DecorView 的 superDispatchTouchEvent() 方法，在该方法中，调用了 FrameLayout.dispatchKeyEvent(event)，此时<strong>点击事件从 Activity 转到了 ViewGroup 中</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 点击事件 ViewGroup --&gt; View</h2>
<p>ViewGroup 与事件分发的方法有三个：</p>
<ul>
<li><code>dispatchTouchEvent()</code> 分发事件，每次都会被调用</li>
<li><code>onInterceptTouchEvent()</code> 拦截事件，如果当前 ViewGroup 已经决定拦截事件，那么不会再调用</li>
<li><code>onTouchEvent()</code> 处理点击事件，如果设置了<code>mOnTouchListener</code>的话，则不会回调本方法</li>
</ul>
<p>这三个主要方法关系如下（伪代码，来自《Android 开发艺术探索》）：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 ViewGroup.dispatchTouchEvent() 被调用后，会通过一系列条件判断是由 ViewGroup 拦截该事件，还是由子 View 消耗该事件。</p>
<p>主要流程分为两部分</p>
<p><strong>1.检查是否需要拦截</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>每次 ACTION_DOWN 事件都需要调用<code>onInterceptTouchEvent()</code>方法判断是否需要拦截</li>
<li>其他 MotionEvent 事件，如果有能处理点击事件的子 View（<code>mFirstTouchTarget != null</code>）且<code>disallowIntercept</code>为 false 也需要调用<code>onInterceptTouchEvent()</code>方法判断是否需要拦截，否则不需要拦截</li>
<li>其余情况都需要拦截（没有可以处理点击事件的子 View，并且不是 ACTION_DOWN 事件）</li>
</ul>
<p>如果 ViewGroup 判断要拦截该事件，则会调用<code>dispatchTransformedTouchEvent()</code>（后面会再讲到）通过他调用继承自 View 的<code>dispatchTouchEvent(MotionEvent event)</code>方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>否则就需要遍历其子 View</p>
<p><strong>2.遍历 ViewGroup 的所有子 View，寻找一个可以处理点击事件的子 View</strong></p>
<ul>
<li><code>dispatchTransformedTouchEvent()</code> 调用了子 View 的<code>dispatchTouchEvent()</code></li>
<li><code>addTouchTarget()</code> 对<code>mFirstTouchTarget </code>进行更新</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>dispatchTransformedTouchEvent() 方法如下，由于<code>child != null</code>其内部调用<code>child.dispatchTouchEvent(event)</code>方法，如此循环直到子 View 是一个 View（单就 ViewGroup 和 View 而论）即<strong>将点击事件从 ViewGroup 分发到了 View</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有子 View 可以处理点击事件，在<code>addTouchTarget()</code>方法内部对<code>mFirstTouchTarget</code>进行更新</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 点击事件 View 内部</h2>
<p>View 的点击事件分发主要涉及到两个方法：</p>
<ul>
<li><code>dispatchTouchEvent()</code></li>
<li><code>onTouchEvent()</code></li>
</ul>
<p>其点击事件分发用伪代码表示如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见 View 的 dispatchTouchEvent() 方法中，如果 View 注册了 OnTouchListener 则会先执行<code>mOnTouchListener.onTouch()</code>方法，如果该方法返回 false 才会执行<code>onTouchEvent()</code>。</p>
<p>在看 onTouchEvent() 方法：</p>
<ul>
<li>如果 View 处于<strong>不可用状态</strong>下，也会消耗点击事件，只不过没有反应</li>
<li>如果注册了 OnClickListener 会在 ACTION_UP 的时候调用<code>mOnClickListener.onClick(this)</code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p>整个 Android 的时间分发始于 Activity，经过 PhoneWindow、DecorView 到达 ViewGroup，再逐层分发到 View 中。</p>
<p>如果底层没有处理点击事件，则又一层层向上返回，直到最顶层消耗掉点击事件。</p>
<h2> 参考资料</h2>
<p>《Android 开发艺术探索》</p>
<p><a href="http://androidxref.com" target="_blank" rel="noopener noreferrer">Android 源代码</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/blog/2018-04/AndroidDispatchTouchEvent.png" type="image/png"/>
    </item>
    <item>
      <title>Android 5.x 以下加载 MultiDex 白屏的处理优化</title>
      <link>https://jixiaoyong.github.io/blog/posts/caa169b7.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/caa169b7.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 5.x 以下加载 MultiDex 白屏的处理优化</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 10 Aug 2019 03:39:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>当 APP 的 minSdkVersion 低于 Android 5 时，在方法数大于 65536 时，需要将 APP 打包为多个 DEX 文件，此时需要添加 MultiDex 依赖。</p>
<p>官方方法如下：</p>
<p>1.<code>build.gradle</code></p>
<div class="language-groovy line-numbers-mode" data-ext="groovy"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.<code>MyApplication</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，为了避免一些启动期间需要的任何类未在主 DEX 文件中提供而导致<code>java.lang.NoClassDefFoundError</code>，还需要告诉 AS 将这些类添加到主 DEX 文件中：</p>
<p>3.<code>build.gradle</code></p>
<div class="language-groovy line-numbers-mode" data-ext="groovy"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是在实际运行中，Android 4.x 的系统会在 APP 安装后第一次启动时，在<code>MultiDex.install(this)</code>方法中进行 DEX 文件合并优化等耗时操作（主线程），往往会持续数十秒以上，从而导致 APP 第一次启动时长时间白屏，十分影响体验。</p>
<p>查阅相应的资料后大体有以下几种方案</p>
<ol>
<li>
<p>设置主 Activity 的背景为透明色</p>
<p>这样当用户点击 APP 图标启动 APP 时，在主 Activity 启动之前看到的一直是桌面的样子而非白屏，但这只是一种障眼法，用户可能会以为系统卡顿，体验并不好。</p>
</li>
<li>
<p>在 Application 中检测到是第一次启动的话，新开一个进程并在其中进行<code>MultiDex.install(this)</code></p>
<p>这种方法在主进程启动时，检测到尚未进行 MultidexOpt，则阻塞当前进程，新开一个进程，在其中加载一个 Activity，并在后台进程运行<code>MultiDex.install(this)</code>，当 MultidexOpt 完成后再关闭当前进程，返回主进程继续正常开启 APP。</p>
<p>由于主进程被阻塞的同时成为了后台进程，所以也不会触发 ANR，此外子进程中的过渡 Activity 也只用到了基本的类，所以基本不用担心会触发<code>java.lang.NoClassDefFoundError</code>，而且过渡 Activity 可以展示进度、提示等用户友好的页面，相对来说体验也好了很多。</p>
</li>
</ol>
<p>但是这种方法从子进程返回主进程涉及到进程间通信，以及主进程的主 Activity 启动时生命周期会出现异常 (异常 (<code>onCreate()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code> -&gt; <code>onPause()</code>-&gt;<code>onResume()</code>)，仍然不是很好的解决方法。</p>
<p>结合上述的分析后，可以看到这种问题的优化思路主要在于如何在避免<code>java.lang.NoClassDefFoundError</code>的同时，在后台可靠的通过<code>MultiDex.install(this)</code>执行 MultidexOpt 操作。</p>
<p>通过以上方案 1 和 2 的结合，可以有一个比较完美的解决方案：</p>
<ol>
<li>方案 2 中在过渡 Activity 的后台线程进行 MultidexOpt 操作思路是正确的，但是不需要再单独开一个进程，我们完全可以将其当做主进程的第一个 Activity，等待 MultidexOpt 操作完成后再跳转到主 Activity 并 finish 掉本 Activity，这样主 Activity 的生命周期也不会受影响。</li>
<li>这种情况下在部分低端机上，过渡 Activity 到主 Activity 跳转时会出现短暂黑屏，我们可以在过渡页面将 Activity 切换动画设置为渐变效果，并将主 Activity 背景设置为透明，待主 Activity 完全加载好后再将背景切换为普通模式。</li>
</ol>
<p>综上处理，我们的 Application 无需改动，甚至主 Activity 也可以不做改动，只需要添加一个过渡页面为启动 Activity，在其中后台进行 MultidexOpt，等 DEX 文件处理完毕后再加载主 Activity。对项目改动少并且逻辑较为简单。</p>
<p>注：</p>
<ol>
<li>MultiDexOpt 即执行<code>MultiDex.install(getApplication());</code>方法；</li>
<li>需要注意过渡 Activity 尽量少的使用类，并且要确保过渡 Activity 可能会调用到的类加载到了主 dex 文件中。</li>
</ol>
<h2> 参考文档</h2>
<p><a href="https://developer.android.google.cn/studio/build/multidex.html?hl=zh-CN" target="_blank" rel="noopener noreferrer">配置方法数超过 64K 的应用</a></p>
<p><a href="https://www.jianshu.com/p/c2d7b76ff063" target="_blank" rel="noopener noreferrer">Android MultiDex 初次启动 APP 优化方案优雅的实现</a></p>
<p><a href="https://www.zybuluo.com/946898963/note/1219741" target="_blank" rel="noopener noreferrer">MultiDex 深入学习</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android paint 绘制 text</title>
      <link>https://jixiaoyong.github.io/blog/posts/e5860bb5.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/e5860bb5.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android paint 绘制 text</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 07 Apr 2020 14:05:20 GMT</pubDate>
      <content:encoded><![CDATA[<p>Android 中绘制文字的方法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>y</code>是<strong>文字 baseline 的 y 坐标</strong>。</p>
<p>下图表示<code>Paint.FontMetrics</code>中存储的文字的各种信息（来源：<a href="https://www.jianshu.com/p/c1575636741e" target="_blank" rel="noopener noreferrer">简书</a>）：<br>
<img src="https://jixiaoyong.github.io/images/20200407220410.png" alt="" loading="lazy"></p>
<p>我们没法直接获取到<code>baseline的坐标</code>，所以只能从另外一个角度考虑：<br>
因为在绘制文字时，文字的上下中心（即上图中的<code>center</code>）是确定的，我们只要计算出<code>center</code>到<code>baseline</code>之间的偏移量，就可以计算出<code>baseline的y坐标</code>。</p>
<p>又根据这个<a href="http://www.imooc.com/article/277490?block_id=tuijian_wz" target="_blank" rel="noopener noreferrer">文章</a>：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p><code>(descent + ascent) / 2</code>是中线 center 的值，而根据上图可知<code>(descent + ascent) / 2 - descent</code>的值就是 baseline 到 center 的距离。</p>
</blockquote>
<p>所以</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这个<code>center.y</code>根据场景不同可以是一行的行中心（文字在一行居中显示），或者控件的上下中心（文字在控件上下居中）</p>
</blockquote>
<p>得出结论：</p>
<p>由于 android 绘制文字时，<strong>并不是从文字高度的中间开始绘制，而是从 baseline 开始绘制</strong>。所以在绘制文字时，为了使文字高度居中（在所指定的空间内居中，比如某一行，就在该行限定的高度内居中显示；某一控件，则整个控件的上下中间显示），需要在计算出来的<strong>文字上下中心的 y 坐标基础上加上 baseline 到文字中线的偏移量</strong>。</p>
<p>除此之外，也可以类比得到：<code>baseline.y = center.y + (bottom.y - top.y) / 2 - bottom.y</code></p>
<blockquote>
<p>基线（baeseline），坡顶（ascenter）,坡底（descenter）</p>
<p>上坡度（ascent），下坡度（descent）</p>
<p>行间距（leading）：坡底到下一行坡顶的距离</p>
<p>字体的高度＝上坡度＋下坡度＋行间距</p>
<p><a href="https://blog.csdn.net/hanyongbai/article/details/84418369" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/hanyongbai/article/details/84418369</a></p>
</blockquote>
<p>参考文章：<br>
<a href="https://www.jianshu.com/p/c1575636741e" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/c1575636741e</a><br>
<a href="https://blog.csdn.net/hanyongbai/article/details/84418369" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/hanyongbai/article/details/84418369</a><br>
<a href="http://www.imooc.com/article/277490?block_id=tuijian_wz" target="_blank" rel="noopener noreferrer">http://www.imooc.com/article/277490?block_id=tuijian_wz</a><br>
<a href="https://blog.csdn.net/xuxingxing002/article/details/50971606" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/xuxingxing002/article/details/50971606</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20200407220410.png" type="image/png"/>
    </item>
    <item>
      <title>AndroidService 相关知识</title>
      <link>https://jixiaoyong.github.io/blog/posts/ad4c562c.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/ad4c562c.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">AndroidService 相关知识</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 13 Jan 2018 17:10:01 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 启动一个 Service</h3>
<ul>
<li>
<p>MyServices.java</p>
<p>必须继承自 Service，或者如 IntentService 本身就是等其子类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>AndroidManifest.xml</p>
<p>注册 MyServices</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>MainActivity.java</p>
<p>在 java 中调用 Service，需要<code>ServiceConnection</code>类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bindService()</code>和<code>startService()</code>的区别在于：</p>
<p>** <code>bindService()</code>将 service 和当前的 activity 绑定在一起，activity 销毁时，service 也会被销毁；</p>
<p>** <code>startService()</code>则只是“启动”service，在此后 service 的活动和 activity 无关，并一直存活。</p>
</li>
</ul>
<h2> Service 具体分析</h2>
<p>Service 在 AndroidManifest.xml 中的属性：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Service 默认运行在创建他的线程中，要是进行耗时操作，最好在 service 中单独创建一个线程，这样子可以在子线程工作，在主线程中更新工作进度。</p>
<p>Service 中的方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>onStartCommand()</code>方法的返回值意义如下：</p>
<p><code>START_STICKY </code>:service 在内存不足被杀死后，内存空闲时系统会重新创建 service，一旦成功创建会回调<code>onStartCommand()</code>方法，此时 intent 是 null，除非是挂起的 intent 如 pendingintent，无限期运行</p>
<p><code>START_NOT_STICKY</code>：service 因内存不足被杀死，内存再次空闲系统也不会再重新创建服务，最安全</p>
<p><code>START_REDELIVER_INTENT</code>：service 因内存不足被杀死，会重建服务并传递给最后一个 intent（最后一次调用<code>startService()</code> 时的 intent），用于连续作业，如下载等</p>
<h3> Service 绑定服务的三种方式</h3>
<h4> 1.拓展 Binder 类</h4>
<p><strong>要求客户端和服务在同一应用的同一进程内</strong>。客户端通过其访问 service 中的公共方法。</p>
<p>步骤如下：</p>
<ol>
<li>创建 BindService 服务端，在类中创建一个实现了 IBinder 接口的实力对象并提供公共方法给客户端使用</li>
<li>在 onBind() 回调方法返回此 Binder 实例</li>
<li>在客户端的 onServiceConnected() 方法接收 Binder，使用提供的方法绑定服务</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.Messenger</h4>
<p><strong>service 与不同进程通信（IPC）</strong> 。</p>
<p>步骤如下：</p>
<ol>
<li>Service 实现一个 Handler，接收客户端每个调用的回调</li>
<li>用 Handler 创建 Messenger 对象</li>
<li>用 Messenger 创建 IBinder 对象，并通过 onBind() 返回客户端</li>
<li>客户端使用 IBinder 实例化 Messenger，用其将 Message 对象发送给 Service</li>
<li>Service 在 Handler 接收并处理 Message</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意 service 要在不同的进程中：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>服务与客户端双向通信</strong></p>
<p>服务端，修改 IncomingHandler，回复客户端消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端，增加 Messenger 和 Handler 处理服务端回复</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，在发送消息是需要将接收服务端回复的 Messenger 通过 Message 的 replyTo 传递给服务端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.AIDL</h4>
<p>一般不会使用，具体使用可以参考<a href="https://jixiaoyong.github.io/blog/posts/f931e8ae/" target="_blank" rel="noopener noreferrer">这篇文章</a></p>
<h2> 绑定服务时的注意事项</h2>
<ul>
<li>多个客户端可连接一个服务端，只有第一个客户端绑定时才会调用服务<code>onBind()</code>方法来检索 IBinder，此后无需调用就可将同一个 IBinder 传递给其他客户端</li>
<li><code>bindService()</code> 绑定服务是异步进行的</li>
<li>一般在 activity 可见生命周期内绑定 - 取消服务，不要在<code>onResume()</code>、<code>onPause()</code>期间执行绑定/解绑</li>
</ul>
<h2> Service 绑定和启动转换</h2>
<table>
<thead>
<tr>
<th>顺序</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>先绑定后启动 service</td>
<td>启动 service</td>
</tr>
<tr>
<td>先启动后绑定 service</td>
<td>会绑定宿主，但是宿主死后仍按照启动 service 方式存活</td>
</tr>
</tbody>
</table>
<h2> 前台服务和通知</h2>
<blockquote>
<ul>
<li><strong>startForeground(int id, Notification notification)</strong><br>
该方法的作用是把当前服务设置为前台服务，其中 id 参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而 notification 是一个状态栏的通知。</li>
<li><strong>stopForeground(boolean removeNotification)</strong><br>
该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true 为删除。注意该方法并不会停止服务。但是，如果在服务正在前台运行时将其停止，则通知也会被删除。</li>
</ul>
</blockquote>
<p>文章参考：</p>
<p><a href="http://blog.csdn.net/javazejian/article/details/52709857#t3" target="_blank" rel="noopener noreferrer">关于 Android Service 真正的完全详解，你需要知道的一切 - CSDN 博客</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 异步消息机制 Handler、Message、Looper</title>
      <link>https://jixiaoyong.github.io/blog/posts/5962504e.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/5962504e.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 异步消息机制 Handler、Message、Looper</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 01 Apr 2018 12:08:08 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>此文为鸿洋博客阅读笔记，配合原文食用口味更佳。</p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="noopener noreferrer">Android 异步消息处理机制 让你深入理解 Looper、Handler、Message 三者关系 - CSDN 博客</a></p>
</blockquote>
<h2> 导图</h2>
<figure><img src="https://jixiaoyong.github.io/images/20200429160005.png" alt="20200429160005" tabindex="0" loading="lazy"><figcaption>20200429160005</figcaption></figure>
<h2> 过程分析</h2>
<h3> Looper</h3>
<h4> <strong>Looper.perpare()</strong></h4>
<p><code>Looper.perpare()</code>方法创建<code>Looper对象</code>（同时创建<code>MessageQueue对象</code>），并与当前线程关联保存在<code>sThreadLocal</code>中。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>Looper.loop()</strong></h4>
<p><code>Looper.loop()</code>方法获取保存的<code>Looper对象</code>并由此获取到<code>MessageQueue对象</code>。</p>
<p>通过<code>for循环</code>，不停的通过<code>mQueue</code>获取到<code>msg</code>，并调用<code>msg.target.dispatchMessage(msg)</code>执行 msg 对应的处理方法。</p>
<p>最后通过<code>msg.recycle()</code>回收使用完的 msg。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <strong>Looper.myLooper()</strong></h4>
<p><code>myLooper()</code>内部调用<code>sThreadLocal</code>获取已有的<code>Looper对象</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Android 的 Activity 默认在 UI 线程调用了 Looper 的<code>prepare()</code>和<code>loop()</code>方法</strong></p>
<h3> Handler</h3>
<h4> handler.sendMessage()</h4>
<p>Handler 构造方法会获取到<code>mLooper</code>和<code>mQueue</code>以及<code>mCallback</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>sendMessage()</code>方法最终会调用<code>sendMessageAtTime()</code>方法，在其内部调用<code>enqueueMessage()</code>方法，将 handler 赋予 msg.target，并将 msg 压入 mQueue 中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> handler.dispatchMessage()</h4>
<p>Handler 的<code>dispatchMessage()</code>方法会在<code>Looper.loop()</code>中被调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中执行顺序是：<code>msg.callback</code> &gt; <code>mCallback</code> &gt; <code>handleMessage()</code></p>
<h4> handler.post()</h4>
<p><code>handler.post(new Runnable())</code>调用了<code>getPostMessage(r)</code>方法将 r 赋予 msg.callback</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后也是在<code>sendMessageDelayed方法</code>中调用<code>sendMessageAtTime()方法</code>将 msg 压入 MessageQueue 中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> msg 的获取</h3>
<ul>
<li><code>Message.obtain();</code> 复用 MessageMessage 池中已有的对象，避免出现分配内存 <strong>推荐</strong></li>
<li><code>new Message();</code></li>
</ul>
<h2> 总结</h2>
<p><strong>Looper</strong>在**<code>perfare()</code>**方法中创建<code>Looper及MessageQueue对象</code>并保存在<code>sThreadLocal</code>中，</p>
<p>在**<code>loop()</code>**方法中通过<code>myLooper()</code>从<code>sThreadLocal</code>中取出<code>mLooper</code>，并由此获得<code>mQueue</code>，在 for 循环中通过<code>mQueue.next()</code>获取<code>msg</code>，用<code>msg.target.dispatchMessage()</code>方法回调<code>handler中的msg处理方法</code>。</p>
<p><strong>Handler</strong>在**<code>构造函数</code>**中通过<code>Looper.myLooper()</code>获取到<code>当前线程的Looper和MessageQueue</code>；</p>
<p>**<code>sendMessage()</code>**方法最终通过<code>sendMessageAtTime()</code>调用<code>enqueueMessage()</code>方法<code>将msg压入到MessageQueue</code>中。</p>
<p>至此将<em>Looper 和 Handler 通过 MessageQueue 联系在一起</em>，并共同参与处理 Message。</p>
<p>此外**<code>handler.post(runnable)</code><strong>也是通过在</strong><code>post()</code>**内部调用<code>getPostMessage()</code>方法将<code>runnable赋予msg.callback</code>，并在<code>post()</code>中通过<code>sendMessageDelayed()</code>方法调用<code>sendMessageAtTime()方法</code>将<code>msg压入MessageQueue</code>中</p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20200429160005.png" type="image/png"/>
    </item>
    <item>
      <title>Android 中 AIDL 的使用</title>
      <link>https://jixiaoyong.github.io/blog/posts/f931e8ae.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/f931e8ae.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 中 AIDL 的使用</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 07 Aug 2018 13:15:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>AIDL（Android Interface Definition Language，Android 接口定义语言）用于 Android IPC，适用于<strong>大量并发</strong>请求。</p>
<p>主要分为两部分：</p>
<ol>
<li>服务端 创建 Service 监听 Client 的请求，通过创建 AIDL 将接口暴露给客户端</li>
<li>客户端 绑定到服务端获取 BInder 对象，将其转化为对应 AIDL，并调用接口对应方法。</li>
</ol>
<p>两者的连线就是 AIDL，因此两个 APP 的 AIDL 必须一致，可以将 AIDL 文件放到一个 Android Library 中，或者打成 aar 文件供二者依赖。</p>
<p>也可以将 AIDL 涉及到的 AIDL 文件、java 都放到 AIDL 文件夹下，然后在 build.gradle 的<code>android{...}</code>中添加</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即添加一个 java 路径</p>
<h2> AIDL 文件特点</h2>
<h3> 支持的数据格式</h3>
<p>基本数据类型、List（ArrayList）、Map（HashMap）以及实现了 Parcelable 接口的对象、AIDL 接口。</p>
<h3> 注意事项</h3>
<ul>
<li>自定义的 Parcelable 对象、AIDL 对象必须显示 import。</li>
<li>AIDL 中用到的 Parcelable 对象必须新建一个同名 AIDL 接口，声明其为 Parcelable 类型。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>AIDL 中除了基本数据类型，其他的参数必须标记方向（in,out,inout）。</li>
<li>AIDL 不支持方法重载，也就是说不能有两个同名的方法（即使参数类型、个数不同也不行）。</li>
<li>AIDL 中只支持方法，不支持静态变量。</li>
</ul>
<h2> AIDL 用法</h2>
<h3> AIDL</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 服务端</h3>
<p>注意 MService 在 AndroidManife.xml 中配置：</p>
<p><code>android:exported="true"android:enabled="true"android:process=":people"</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：</p>
<ol>
<li>
<p>这里用来注册监听的类是 RemoteCallbackList</p>
<p>我们知道跨进程的两个 listener 是两个不同的对象，那他是怎么保证跨进程注册、注销的是指定的 listener 呢？</p>
<p>这是因为虽然两个 listener 对象不同，但是他们底层的 Binder 对象是同一个，在 RemoteCallbackList 中有一个以 Binder 对象为 KEY 的 map 来存放这些 listener 对象，当要注销时，只需要按当前待注销的 listener 的 Binder 对象找到已经注册了的 listener 并删除掉即可。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，RemoteCallbackList 可以在客户端死亡的时候自动注销掉对应的 listener，这是因为他在注册的同时也对 Binder 的死亡就行了监听。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>方法运行的线程</p>
<p><strong>如果客户端和服务端运行在同一进程</strong>：客户端调用服务端和服务端回调客户端方法（RemoteCallbackList，下同）都会运行在同一线程，即客户端调用服务端时所在的线程，默认为主线程</p>
<p><strong>如果客户端和服务端运行在不同进程</strong>：客户端调用服务端方法，客户端会被挂起，直到服务端方法在 Binder 线程池中运行完毕，这种情况下服务端可以执行耗时操作而无需另建线程；服务端回调客户端方法运行在客户端主线程 (与客户端调用服务端方法在同一线程)</p>
<p>通过上述分析，可以注意到一个细节：<strong>虽然在服务端中回调客户端的方法是在服务端的 Binder 线程，但是在客户端中被回调的方法却是和客户端中主动调用服务端方法的线程一致</strong>。</p>
</li>
</ol>
<h3> 客户端</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 监听并处理 Binder 死亡事件</h3>
<p>当服务端进程意外死亡时，我们可以选择重新连接服务，一般有两种方式：</p>
<ol>
<li>binderDied 在客户端的 Binder 线程池中</li>
<li>onServiceDisconnected 在客户端 UI 线程</li>
</ol>
<h3> AIDL 的权限验证</h3>
<p>可以在服务的 onBind(Intent intent) 或者 onTransact() 方法中做验证</p>
<p>做验证的手段有：1.permission 验证；2.Uid，Pid 等做验证</p>
<h2> 参考资料</h2>
<p>《Android 开发艺术探索》</p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 中 AIDL 相关知识</title>
      <link>https://jixiaoyong.github.io/blog/posts/2270057c.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/2270057c.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 中 AIDL 相关知识</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 20 Mar 2019 11:37:40 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p><code>AIDL</code>是 Android 中用于 IPC 的语言，具体使用可以参见<a href="https://jixiaoyong.github.io/blog/posts/f931e8ae/" target="_blank" rel="noopener noreferrer">这篇文章</a>，这篇文章主要想总结一下<code>AIDL</code>具体为我们做了什么工作，主要参考书目《Android 开发艺术探索》。</p>
<p>在 Android 中，除了<code>Socket</code>、<code>Intent</code>中使用<code>Bundle</code>、本地文件共享，<code>ContentProvider</code>等等之外，还有一个独有的 IPC 方式即<code>Binder</code>。在日常编程中使用<code>Binder</code>的主要有<code>AIDL</code>和<code>Messenger</code>两种方式，而<code>Messenger</code>也是用<code>AIDL</code>来实现的。</p>
<h2> 准备</h2>
<ol>
<li>新建一个 AIDL 文件</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>用 AndroidStudio 自动生成一个 Binder 类</li>
</ol>
<p>使用<code>Build</code>-&gt;<code>Make Project</code>，会在<code>app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out</code>目录下生成<code>IBookManager.java</code>。</p>
<h2> 分析</h2>
<p>AIDL 从客户端 (Client) 发起请求至服务端 (Server) 相应的工作流程概览，图片来源 (<a href="https://blog.csdn.net/qian520ao/article/details/78074983" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qian520ao/article/details/78074983</a>)</p>
<figure><img src="https://jixiaoyong.github.io/images/20190320205619.png" alt="AIDL 从客户端 (Client) 发起请求至服务端 (Server) 的流程" tabindex="0" loading="lazy"><figcaption>AIDL 从客户端 (Client) 发起请求至服务端 (Server) 的流程</figcaption></figure>
<p>下面我们对<code>IBookManager.java</code>这个文件简单分析一下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78074983" target="_blank" rel="noopener noreferrer">Android 深入浅出 AIDL（二）</a></p>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78089877" target="_blank" rel="noopener noreferrer">Android Binder 之应用层总结与分析</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20190320205619.png" type="image/png"/>
    </item>
    <item>
      <title>Android 中 View 相关知识</title>
      <link>https://jixiaoyong.github.io/blog/posts/1b0362b.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/1b0362b.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 中 View 相关知识</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 24 Mar 2019 04:43:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文为笔记性质，尚未成文。</p>
<h2> View 的坐标</h2>
<p>Android 中的坐标，以屏幕左上角顶点为原点 (0,0)，以横轴为 x 轴，竖轴为 y 轴，数值依次递增。</p>
<p>View 的坐标信息有以下几种，其坐标都是以父 View 的左上角顶点为原点：</p>
<ul>
<li>
<p>x，y 是 View 的左上角坐标。</p>
</li>
<li>
<p>translationX，translationY 是 View 左上角顶点与父容器左上角顶点的偏移量，默认为 0。</p>
</li>
<li>
<p>left，top 是分别是 View 左上角顶点的 x 轴，y 轴坐标。</p>
<p>right，bottom 分别是 View 右下角顶点的 x 轴，y 轴坐标。</p>
</li>
</ul>
<blockquote>
<p>注意</p>
</blockquote>
<p>x = translationX + left；</p>
<p>y = translationY + top；</p>
<p>改变 translationX/Y 的值便可以更改<strong>View 的位置</strong>。当 View 平移的时候，代表原始位置信息的 left，right，top，bottom 的值并不会变化。</p>
<p>在 OnTouch 事件中，我们可以从 event 得到两种值：</p>
<p>event.rawX,event.rawY 代表 相对于手机屏幕原点的坐标</p>
<p>event.X,event.Y 代表 相对于当前 View 左上角的坐标</p>
<p>TouchSlop 则代表认为滑动开始的最小距离</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 滑动</h2>
<p>mScroller.startScroll() 方法可以实现平滑的滑动</p>
<p>scrollX,scrollY 表示的是<em>view 的 X，Y 坐标减去 view 内容的 X，Y 坐标</em>。</p>
<p>所以 scrollX&gt;0，则表示 view 内容向左移动，scrollX&lt;0 表示 view 内容向右移动。类似于窗户 (view) 位置不变，景色 (view 内容) 的 scrollX&gt;0 即景色向右移动，则在窗户中看到的效果是景色向窗户左边移动。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Scroller 不能使 View 滑动，而只能配合 View 的 computeScroll() 方法实现是<strong>View 的内容滑动</strong>的效果。</p>
<ul>
<li>mScroller.startScroll() 记录下要滑动的数据，而 invalidate() 通知 View 重绘；</li>
<li>每次重绘都会调用 computeScroll() 方法，利用 mScroller 计算出接下来要 scrollTo() 的具体值并执行，再次 postInvalidate() 通知 View 重绘；</li>
<li>如此反复直到绘制滑动完毕。</li>
</ul>
<p>上述无论是 translationX 还是 scrollX 等引起的 view 变化，都不能改变 View 的定位（left，right，top，bottom 值），而如果<strong>更改 margin 的值，则可以更改 View 的定位</strong>。</p>
<h2> Window 和 WindowManager</h2>
<p>WindowManager.LayoutParams.flags 有三个常用选项：</p>
<ul>
<li>WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL // 只处理 Window 区域内的点击事件，之外的交给其他 Window 处理</li>
<li>WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE // 不接受输入事件，不获取焦点，同时会开启 FLAG_NOT_TOUCH_MODAL，最终事件会传递给下层具有焦点的 Window</li>
<li>WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED // 让 Window 显示在锁屏界面上</li>
</ul>
<p>WindowManager.LayoutParams.type 代表 Window 的类型 (三个)：</p>
<ul>
<li>应用 Window 对应一个 Activity。<code>z-ordered</code>:1~99</li>
<li>子 Window 不能单独存在，附属在特定的父 Window 中，如 Dialog。<code>z-ordered</code>:1000~1999</li>
<li>系统 Window 需要系统权限，如 Toast，状态栏等。<code>z-ordered</code>:2000~2999</li>
</ul>
<p><code>z-ordered</code>值大的 Window 会覆盖掉低值的 Window。</p>
<h2> TODO</h2>
<p>recycleview 滑动<br>
ItemTouchHelper 源码分析 <a href="https://www.jianshu.com/p/130fdd755471" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/130fdd755471</a><br>
嵌套滑动 <a href="https://blog.csdn.net/qq_15807167/article/details/51637678" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_15807167/article/details/51637678</a><br>
<a href="https://www.cnblogs.com/dasusu/p/9159904.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/dasusu/p/9159904.html</a><br>
<s>滑动展示删除按钮</s> <a href="https://www.jianshu.com/p/9bfed6e127cc" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/9bfed6e127cc</a> &gt;&gt; 对应的 demo：<a href="https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt" target="_blank" rel="noopener noreferrer">https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt</a></p>
<h2> 参考资料</h2>
<p><a href="https://blog.csdn.net/Holmofy/article/details/53959511" target="_blank" rel="noopener noreferrer">View 滑动效果常用属性详解：scroll、translation、LayoutParams</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 中 WebView 使用的一些问题</title>
      <link>https://jixiaoyong.github.io/blog/posts/b35fe0f7.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b35fe0f7.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 中 WebView 使用的一些问题</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 07 Feb 2018 16:11:13 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 问题描述：WebView 在 fragment 中不显示</h2>
<p>解决代码如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此代码同样强制在 webview 中打开对应的网页</p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 中的 Messenger 源码详解</title>
      <link>https://jixiaoyong.github.io/blog/posts/b0dc2559.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b0dc2559.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 中的 Messenger 源码详解</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 21 Mar 2019 02:26:32 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>Messenger 是 Android 中用于 IPC 的方式之一，使用 Handler 发送有序消息队列，底层是通过 AIDL 调用 Binder 实现。</p>
<p>Messenger 只用于服务端和客户端串行的传递消息，如果大量并发或者跨进程调用服务端的方法，就需要考虑 AIDL 而非 Messenger。</p>
<p>Messenger 的使用可以参考<a href="https://jixiaoyong.github.io/blog/posts/ad4c562c/" target="_blank" rel="noopener noreferrer">这篇文章</a>,本文主要探索一下 Messenger 源码实现。</p>
<p>主要使用到的文件：</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/IMessenger.aidl" target="_blank" rel="noopener noreferrer">IMessenger.aidl</a></p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Messenger.java" target="_blank" rel="noopener noreferrer">Messenger.java</a></p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Handler.java" target="_blank" rel="noopener noreferrer">Handler.java</a></p>
<h2> 解析</h2>
<p>一个典型的 Messenger 服务如下所示：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到使用 Handler 创建一个 Messenger，进入到源码看一下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到，在这里创建了一个新的与给定的 Handler 绑定在一起的 Messenger，再看看<code>getIMessenger()</code>方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们可以看到<code>getIMessenger()</code>方法会创建一个 MessengerImpl 对象，而这个对象</p>
<p>实现了<code>send()</code>方法，也证实了我们之前的一个观点——Messenger 底层是使用 Handler 发送消息。</p>
<p>同时，看到 MessengerImpl 继承的 IMessenger.Stub 类我们可以联想到这里应该有一个 AIDL 实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><code>oneway</code> 关键字用于修改远程调用的行为。使用该关键字时，远程调用不会阻塞；它只是发送事务数据并立即返回。接口的实现最终接收此调用时，是以正常远程调用形式将其作为来自 <code>Binder</code> 线程池的常规调用进行接收。如果 <code>oneway</code> 用于本地调用，则不会有任何影响，调用仍是同步调用</p>
<p><a href="https://developer.android.google.cn/guide/components/aidl?hl=zh-cn" target="_blank" rel="noopener noreferrer">https://developer.android.google.cn/guide/components/aidl?hl=zh-cn</a></p>
</blockquote>
<p>这也就解释了在服务的<code>onBind(intent: Intent?)</code>方法中，我们可以直接使用<code>messenger.binder</code>获取到 Binder 对象的原因。</p>
<p>再看看 Messenger 客户端的实现：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以注意到在客户端通过<code>Messenger(IBinder target)</code>取得服务端的 Messenger，而这里的 IBinder 对象则是通过服务端的 Messenger 的<code>getBinder()</code>获取的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Stub.asInterface()</code>方法我们在<a href="http://jixiaoyong.github.io/blog/posts/88d0bcd1/" target="_blank" rel="noopener noreferrer">之前的文章</a>中介绍过，他会根据客户端和服务端是否在同一进程而决定返回 Stub 实例还是 Proxy 类实例以实现跨进程通信。</p>
<p>而通过比较 <code>Messenger(IBinder target)</code>和<code>Messenger(Handler target)</code>两个构造方法我们也可以知道，两个方法都只是用来初始化了<code>IMessenger mTarget</code>对象，这也就解释了在服务端和客户端可以通过两个不同的构造方法获取到有同样功能的 Messenger。</p>
<h2> 参考资料</h2>
<p>《Android 开发艺术探索》</p>
<p><a href="https://developer.android.google.cn/guide/components/aidl?hl=zh-cn" target="_blank" rel="noopener noreferrer">Android 接口定义语言 (AIDL)</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 中的 SpareArray 和 ArrayMap 实现分析</title>
      <link>https://jixiaoyong.github.io/blog/posts/c2f123c.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/c2f123c.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 中的 SpareArray 和 ArrayMap 实现分析</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 22 Dec 2019 01:35:37 GMT</pubDate>
      <content:encoded><![CDATA[<p>日常开发中，常用的存储键值对的数据结构是<code>HashMap</code>，根据<a href="https://jixiaoyong.github.io/blog/posts/ff927bd4.html" target="_blank" rel="noopener noreferrer">Java 笔记之 HashMap 保存数据</a>和<a href="https://jixiaoyong.github.io/blog/posts/b0793c74.html" target="_blank" rel="noopener noreferrer">Java 笔记之计算 Java 对象的大小及其应用</a>可以知道，<code>HashMap</code>存储<strong>键值对</strong>会占用比较多的内存控件，而对于内存限制较大的 Android 平台来说，为了避免这种浪费，官方推荐我们使用<code>SpareArray</code>和<code>ArrayMap</code>，本文对这两个类的实现进行分析比较。</p>
<p><strong><code>SpareArray</code>以及他的衍生类</strong>都是以<strong>基本类型</strong>为<code>key</code>，因为避免了<em>自动装箱</em>，并且<strong>用数组直接保存 key、value</strong>（而非像<code>HashMap</code>那样将其封装为<code>Node</code>对象后再保存），因而节省了内存。</p>
<p><strong><code>ArrayMap</code><strong>则支持</strong>所有类型的 key</strong>，他是<strong>将<code>key</code>和<code>value</code>全部保存在一个数组中</strong>（<code>n</code>位为<code>key</code>，<code>n+1</code>位为<code>value</code>），避免了将其封装为<code>Node</code>对象带来的内存消耗。</p>
<p><strong>当要保存的数据量比较小（小于几千个）的时候，如果 KEY 是基本类型，推荐使用<code>SparseArray</code>及其衍生类以节省内存，如果 KEY 是其他类型则使用<code>ArrayMap</code>;否则使用<code>HashMap</code>更加高效</strong>。</p>
<h2> SpareArray</h2>
<p><code>SpareArray</code>以及他的衍生类主要用于<strong>以<code>基本类型</code>为<code>key</code>保存非大量数据的场景</strong>。</p>
<p>相比<code>HashMap</code>而言，他的优点主要在于<strong>没有对保存的数据二次封装</strong>，没有对基本类型的数据<strong>自动装箱</strong>，存储单个数据的成本小，也没有<code>hash</code>计算。</p>
<p>但他在添加数据时需要扩展数组 (涉及到新建、复制数组，<code>gc()</code>等)，<s>在删除数据时需要缩减数组</s> (查看<code>gc()</code>等源码发现他的数组只会增加，不会缩减)，以及通过二分法查找索引都会消耗性能。</p>
<blockquote>
<p>为了避免每次删除时都需要缩减数组，<code>SpareArray</code>在删除数组时只会将其赋值为<code>DELETED</code>，在下次调用其<code>private void gc()</code>方法时丢弃掉这些数据</p>
</blockquote>
<p>先看一下<code>SpareArray</code>的结构：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> void put(int key, E value)</h3>
<p>添加方法先用<strong>二分法</strong>查找<code>key</code>对应的位置：</p>
<ul>
<li>如果有，则直接覆盖</li>
<li>如果没有，则<strong>取反</strong>得到应该<code>插入的位置</code>，并分别插入<code>key</code>和<code>value</code></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> E get(int key)</h3>
<p>获取数据，先用<strong>二分法</strong>查找，如果找到就返回<code>对应的值</code>，否则返回<code>null</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> void remove(int key)</h3>
<p>删除<code>key</code>以及<code>对应的数据</code>。</p>
<p>同样先用<strong>二分法</strong>查找<code>对应位置</code>，有的话则标记为<code>DELETED</code>，<strong>等待下次<code>gc()</code>时丢弃</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> gc()</h3>
<p>在上文中我们看到，删除数据时，<code>mGarbage</code>被标记为<code>true</code>，这样当下一次进行<code>put/valueAt/append/size</code>等涉及到数组大小查询、改动等时，就出触发<code>gc()</code>以便整理数组结构。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> HashMap 与 SpareArray 及其衍生类对应关系</h3>
<p>参考<a href="https://android.jlelse.eu/app-optimization-with-arraymap-sparsearray-in-android-c0b7de22541a" target="_blank" rel="noopener noreferrer">下图</a></p>
<figure><img src="https://jixiaoyong.github.io/images/20191222131219.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> ArrayMap</h2>
<p><code>ArrayMap</code>实现了<code>Map&lt;K, V&gt;</code>接口，他的 API 和<code>HashMap</code>相差无几，但是由于<strong>没有对数据再包装</strong>，<strong>动态调整数组的大小</strong>，一定范围内他比<code>HashMap</code>内存效率高。</p>
<p>但是如果保存大量数据（超过千位）时，由于他需要<strong>二分法查找</strong>的影响会比<code>HashMap</code>慢很多。</p>
<blockquote>
<p><strong><code>ArrayMap</code>特殊之处在于将<code>key</code>，<code>value</code>保存到了同一个数组 mArray 中（n 位保存 key，n+1 位保存 value</strong>）。</p>
</blockquote>
<p>先看一下<code>ArrayMap</code>的结构：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用时：</p>
<ol>
<li>
<p>计算<code>key</code>的<code>hash值</code>，</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>然后使用<code>indexOf()</code>在<code>mHashes</code>中进行二分法查找对应的<code>index</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>indexOf()</code>方法会先用<strong>二分法</strong>查找<code>hash</code>对应的<code>index</code>,如果<code>index&lt;0</code>则返回<code>index</code>；否则在对比<code>mArray</code>中对应位置<code>mArray[index&lt;&lt;1]</code>的<code>key</code>与要<code>查询的key</code>：</p>
<ul>
<li>两者一致：返回<code>index</code></li>
<li>两者不一致：从<code>index</code>开始，<strong>先向后，再向前</strong>查询是否有相同的<code>key</code>,如果有返回<code>对应index</code></li>
<li>以上都没有找到：<strong>对<code>mHashes</code>中<code>最后一个与key的hash一致的后一位index</code>取反</strong>，并返回</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h3> V put(K key, V value)</h3>
<p>当添加<code>item</code>时，按照前述规则，先在<code>mArray</code>中查找<code>key</code>对应的<code>索引index</code>：</p>
<ul>
<li>
<p><code>index &gt;= 0</code> ：已经有键为<code>key</code>的数据，直接覆盖旧值并返回</p>
</li>
<li>
<p><code>index &lt; 0 </code>：没有键为<code>key</code>的数据，对数组进行扩容，并保存对应数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> V get(Object key)</h3>
<p><code>get()</code>方法就比较简单了，先查找<code>key</code>的索引，然后取出<code>对应的数据value</code>并返回即可：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> V remove(Object key)</h3>
<p><code>remove()</code>方法也会先使用<code>indexOfKey()</code>计算<code>key的index</code>，然后删除<code>对应位置的数据</code>。</p>
<p>此外，如果<code>mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3</code>的话，还会缩减<code>数组的大小</code>为<code>osize &gt; (BASE_SIZE*2) ? (osize + (osize&gt;&gt;1)) : (BASE_SIZE*2)</code>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p><a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/core/java/com/android/internal/util/GrowingArrayUtils.java" target="_blank" rel="noopener noreferrer">GrowingArrayUtils.java 源码</a></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/SparseArray.java" target="_blank" rel="noopener noreferrer">SparseArray.java 源码</a></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/ArrayMap.java" target="_blank" rel="noopener noreferrer">ArrayMap.java 源码</a></p>
<p><a href="https://android.jlelse.eu/app-optimization-with-arraymap-sparsearray-in-android-c0b7de22541a" target="_blank" rel="noopener noreferrer">App optimization with ArrayMap &amp; SparseArray in Android</a></p>
<p><a href="https://jixiaoyong.github.io/blog/posts/ff927bd4.html" target="_blank" rel="noopener noreferrer">Java 笔记之 HashMap 保存数据</a></p>
<p><a href="https://jixiaoyong.github.io/blog/posts/b0793c74.html" target="_blank" rel="noopener noreferrer">Java 笔记之计算 Java 对象的大小及其应用</a></p>
<p><a href="https://extremej.itscoder.com/sparsearray_source_analyse/" target="_blank" rel="noopener noreferrer">SparseArray 的使用及实现原理</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20191222131219.png" type="image/png"/>
    </item>
    <item>
      <title>Android 今日头条屏幕适配方案的原理梳理</title>
      <link>https://jixiaoyong.github.io/blog/posts/76d69fc6.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/76d69fc6.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 今日头条屏幕适配方案的原理梳理</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 13 Oct 2020 03:13:18 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>最近在项目里面遇到了屏幕适配的问题，UI 要求 APP 在不同手机上展示效果和设计稿保持“像素级”同步，在对比了几种屏幕适配方案之后，选择了基于今日头条的<a href="https://github.com/JessYanCoding/AndroidAutoSize" target="_blank" rel="noopener noreferrer">AndroidAutoSize</a>适配方案。</p>
<p>本文主要简单分析其适配原理，以及在实际使用中遇到的一个问题，需要更深入了解原理可以阅读文末参考文献。</p>
<h2> 正文</h2>
<p>UI 给的设计稿一般都是以像素 px 为单位，而在 Android 开发中官方推荐的使用的单位是 dp。</p>
<blockquote>
<p>dp 是一个虚拟像素单位，1 dp 约等于中密度屏幕（160dpi；“基准”密度）上的 1 像素。对于其他每个密度，Android 会将此值转换为相应的实际像素数。</p>
<p>—— Android Developer</p>
</blockquote>
<p>根据 Android 官方的定义，dp 在屏幕上实际对应的像素 px 计算方式如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中 dpi 表示：<strong>屏幕每平方英寸有多少像素</strong>，可以通过屏幕对角线的像素数 px/屏幕尺寸 inch 计算。</p>
<p>而<code>DisplayMetrics.density</code> 字段表示根据当前像素密度指定将 <code>dp</code> 单位转换为像素时所必须使用的缩放系数，即上述方程等价于：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，在 dpi 为 160 的屏幕上 1dp 占 1px，在 dpi 为 320 的屏幕上占 2px，那么就能保证同一 dp 的在不同 dpi 上占得像素是等比例变化的。</p>
<p>但是，在现实生活中面对千变万化的 Android 屏幕，根据 Jessyan 的文章可知由于每种屏幕宽/高对应的总 dp 数不一定都是相同的，所以即使使用了 dp 作为单位，还是会出现同一 dp 在有些屏幕上刚好占满全屏，在有的屏幕上会无法占满全屏或超出屏幕范围。</p>
<blockquote>
<p><strong>density</strong> 在每个设备上都是固定的，<strong>DPI / 160 = density</strong>，<strong>屏幕的总 px 宽度 / density = 屏幕的总 dp 宽度</strong></p>
<ul>
<li>设备 1，屏幕宽度为 <strong>1080px</strong>，<strong>480DPI</strong>，屏幕总 <strong>dp</strong> 宽度为 <strong>1080 / (480 / 160) = 360dp</strong></li>
<li>设备 2，屏幕宽度为 <strong>1440px</strong>，<strong>560DPI</strong>，屏幕总 <strong>dp</strong> 宽度为 <strong>1440 / (560 / 160) = 411dp</strong></li>
</ul>
<p>——Jessyan</p>
</blockquote>
<p>那么该怎么适配呢，再看一眼上述的公式：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以适配<strong>屏幕宽度</strong>为例，要使得 dp 在不同屏幕上对应的像素等比例变化，就要<strong>保证屏幕的总 dp 宽度一致</strong>，而屏幕的总 px 宽度是物理条件无法更改，那么就只能<strong>更改 density</strong>。</p>
<p>以我们使用的设计稿宽度为 375dp 为例：</p>
<p>在分辨率为 2160*1080、尺寸为 5.99 英寸的屏幕上：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>而在分辨率为 2400*1176、尺寸为 6.53 英寸的屏幕上：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样就保证了，不管在什么样的屏幕上，375dp 始终都能够占满屏幕宽度，保证了布局在不同大小的屏幕上，在屏幕宽度上的比例一致性，也就解决屏幕适配的问题。</p>
<h2> 获取状态栏高度的问题</h2>
<p>上述的屏幕适配方案使用简单，且侵入小，在使用到项目中之后，除了部分字体等显示需要微调外，其余内容基本上都完美还原了设计稿的内容。</p>
<p>但是在后续使用到状态栏相关代码的时候发现<strong>获取到的状态栏高度和实际高度不一致</strong>，导致显示异常，而使用<a href="http://blankj.com" target="_blank" rel="noopener noreferrer">Blankj</a>的工具类 <code>BarUtils.getStatusBarHeight()</code>却可以获取到正确的高度。</p>
<p>对比两种代码发现获取状态栏高度的代码逻辑几乎一样：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不同的是，两种方法使用到的 resources 一个是 APP 的，一个是系统的</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过分别打印这两种 resources 可以发现，二者的 density 值不一样（以 2160*1080、尺寸为 5.99 英寸的屏幕为例）：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是由于使用了<a href="https://github.com/JessYanCoding/AndroidAutoSize" target="_blank" rel="noopener noreferrer">AndroidAutoSize</a>适配方案后，APP 内部的 density 已经被改成了 2.88，而系统实际的 density 是 2.7。</p>
<p>又知道 android 中将像素和 dp 等单位转化的方法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析可知，通过 getStatusBarHeight() 获取到的状态栏是系统的状态栏 69px（即 25dp），但当使用 APP 内部的 density=2.88 计算时就会只有 24dp，和实际的状态栏高度不一致，所以使用状态栏高度来控制布局的时候就会展示异常。</p>
<h2> 参考资料</h2>
<p><a href="http://jessyan.me/autosize-introduce/" target="_blank" rel="noopener noreferrer">骚年你的屏幕适配方式该升级了!-今日头条适配方案——jessyan</a></p>
<p><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA" target="_blank" rel="noopener noreferrer">一种极低成本的 Android 屏幕适配方式——字节跳动</a></p>
<p><a href="https://developer.android.google.cn/training/multiscreen/screendensities#top_of_page" target="_blank" rel="noopener noreferrer">支持不同的像素密度——Android Developers</a></p>
<p><a href="https://mp.weixin.qq.com/s/X-aL2vb4uEhqnLzU5wjc4Q" target="_blank" rel="noopener noreferrer">Android 目前稳定高效的 UI 适配方案——拉丁吴</a></p>
<p><a href="https://github.com/JessYanCoding/AndroidAutoSize" target="_blank" rel="noopener noreferrer">AndroidAutoSize</a></p>
<p><a href="https://github.com/gyf-dev/ImmersionBar/issues/298" target="_blank" rel="noopener noreferrer">请问两种获取屏幕密度的方式有什么区别，望解答多谢</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 多渠道打包知识</title>
      <link>https://jixiaoyong.github.io/blog/posts/a3a3dc4c.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/a3a3dc4c.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 多渠道打包知识</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 25 Mar 2018 14:17:57 GMT</pubDate>
      <content:encoded><![CDATA[<p>国内 Android 应用常常要分发到多个应用商店，使用 Android Studio 正确配置 build.gradle 与 AndroidManifest.xml 文件可以<strong>一步打包多个渠道</strong>。</p>
<p>本文实现的多渠道打包可实现不同渠道：</p>
<ul>
<li>有不同的项目 id（applicationId）</li>
<li>不同 App 名称（android:label）</li>
<li>不同 App 图标（android:icon）</li>
<li>等等</li>
</ul>
<h2> 1.友盟配置</h2>
<p>*具体配置请参考 UMeng 官方文档。</p>
<p>作为第三方统计平台，国内很多软件都使用的是 Umeng 的产品，故而大多数软件多渠道打包配置如下：</p>
<ul>
<li>添加依赖</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>修改 AndroidManifest.xml</li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>修改 build.gradle</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样编译完之后，通过通过 build&gt;Generate Signed APK...便可以打包不同渠道的 apk，在友盟统计平台上统计各个渠道的 App 信息了。</p>
<h2> 2.Android Studio 实现多渠道打包</h2>
<p>方法 1 要求依赖 umeng 模块，使用场景难免有些受限，其实我们也可以自己实现多渠道打包，方法 1 使用的应该也是此原理。</p>
<ul>
<li>AndroidManifest.xml</li>
</ul>
<p>在需要根据渠道不同而变化的地方使用<code>${KEY}</code>形式替换掉原先的值。</p>
<p>例如：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>app/build.gradle</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在 java 中获取<code>meta-data</code>（非必须）</li>
</ul>
<blockquote>
<p>《Android 获取 Manifest 中&lt;meta-data&gt;元素的值》 - CSDN 博客 <a href="https://blog.csdn.net/zhang31jian/article/details/29868235" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/zhang31jian/article/details/29868235</a></p>
</blockquote>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.生成多个渠道文件夹</h2>
<p>还有一种方法，通过在项目中生成多个渠道的文件夹，在里面替换对应的资源文件，从而实现多渠道打包不同项目名，不同 icon 等等</p>
<ul>
<li>
<p>在../app/src/目录下新建对应渠道文件夹，和 main 同级</p>
</li>
<li>
<p>在该渠道目录下新建对应的资源目录，在打包时自动替换对应资源</p>
<p>​</p>
<p>目录树如下</p>
</li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4.More</h2>
<p>此外还有美团的多渠道打包技术等</p>
<p>具体可参考文章：<a href="https://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="noopener noreferrer">美团 Android 自动化之旅—生成渠道包</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 实现可折叠 toolbar</title>
      <link>https://jixiaoyong.github.io/blog/posts/b4832cd1.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b4832cd1.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 实现可折叠 toolbar</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 22 Feb 2018 07:01:10 GMT</pubDate>
      <content:encoded><![CDATA[<p>使用到的类有：</p>
<ul>
<li>android.support.design.widget.CoordinatorLayout</li>
<li>android.support.design.widget.AppBarLayout</li>
<li>android.support.design.widget.CollapsingToolbarLayout</li>
<li>android.support.v7.widget.Toolbar</li>
</ul>
<h2> 效果预览</h2>
<p>如图：</p>
<figure><img src="http://jixiaoyong.github.io/blog/images/default/2018-02-22/coordinatorlayout.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 简要说明</h2>
<p>CoordinatorLayout 类，协调者布局，通过 Behavior 将一个子 view（<code>child</code>）的行为和另一个子 view（<code>dependency</code>）的活动联结起来，从而实现子 view 之间的联动。</p>
<p>AppBarLayout 类，是一个实现了材料设计的默认垂直布局的 ViewGroup，当其是 CoordinatorLayout 类的直接子 view 时，另外一个 CoordinatorLayout 的子 view 指定了 behavior 为 AppBarLayout.ScrollingViewBehavior 的实例（<code>app:layout_behavior="@string/appbar_scrolling_view_behavior"</code>）,且该子 view 需要是 NestedScrollingChild 的实现类。</p>
<p>CollapsingToolbarLayout 类，提供一个可以折叠的 toolbar 布局，可以在这个布局里面，设置 toolbar 以及和 toolbar 一起联动的子 view，本案例中是一张图片。</p>
<p>Toolbar 类，实现 toolbar 的效果。</p>
<h2> 具体实现</h2>
<p>源码：<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-02-22" target="_blank" rel="noopener noreferrer">github</a></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>CoordinatorLayout 在最外层，注意其直接子 view 必须就是要实现联动的 view，否则联动失效。</li>
<li>CollapsingToolbarLayout 必须设置 layout_scrollFlags，其余属性可选。</li>
</ol>
<blockquote>
<p>layout_scrollFlags 说明如下：</p>
<p><strong>scroll</strong>：所有想滚动出屏幕的 view 都需要设置这个 flag，没有设置这个 flag 的 view 将被固定在屏幕顶部。</p>
<p><strong>enterAlways</strong>：这个 flag 让任意向下的滚动都会导致该 view 变为可见，启用快速“返回模式”。</p>
<p><strong>enterAlwaysCollapsed</strong>：假设你定义了一个最小高度（minHeight）同时 enterAlways 也定义了，那么 view 将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。</p>
<p><strong>exitUntilCollapsed</strong>：当你定义了一个 minHeight，此布局将在滚动到达这个最小高度的时候折叠。</p>
<p><strong>snap</strong>：当一个滚动事件结束，如果视图是部分可见的，那么它将被滚动到收缩或展开。例如，如果视图只有底部 25% 显示，它将折叠。相反，如果它的底部 75% 可见，那么它将完全展开。</p>
<p>作者：尹 star</p>
<p>链接：<a href="https://www.jianshu.com/p/5287d090e777" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/5287d090e777</a></p>
</blockquote>
<ol>
<li>CollapsingToolbarLayout 的子 view 需要指定 layout_collapseMode，还有一点需注意：<strong>和 toolbar 联动的子 view 高度需大于 toolbar 高度，否则无效果。</strong></li>
<li>ViewPager 就是本案例中触发子 view 联动效果的<code>dependency</code>，需要指定其 behavior：</li>
</ol>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其实际对应于 android.support.design.widget.AppBarLayout$ScrollingViewBehavior，这个是系统实现的一个 behavior，用于和嵌套滑动事件绑定，<strong>指定该 behavior 的子 view 需要是 NestedScrollingChild 的实现类</strong>（系统提供了 4 个实现类：NavigationMenuView、NestedScrollView、RecyclerView、SwipleRefreshLayout），所以 viewPager 中页面有上述 4 个类或其子类时，才能实现绑定效果。</p>
<h2> 延伸</h2>
<p><strong>自定义 Behavior</strong></p>
<p>自定义 Behavior 有两个目的：</p>
<ol>
<li>将两个或多个子 view 绑定；</li>
<li>将一个子 view 与另一个子 view 的滑动事件绑定在一起</li>
</ol>
<p>两者的差异在于在实现<code>CoordinatorLayout.Behavior&lt;T&gt;</code> 类时候具体重写的方法不一样。</p>
<p><strong>目的 1</strong>：需要重写的方法有：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>目的 2</strong>：需要重写的方法有：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<h1> 自定义 Behavior 的总结</h1>
<ol>
<li>确定 CoordinatorLayout 中 View 与 View 之间的依赖关系，通过 layoutDependsOn() 方法，返回值为 true 则依赖，否则不依赖。</li>
<li>当一个被依赖项 dependency 尺寸或者位置发生变化时，依赖方会通过 Byhavior 获取到，然后在 onDependentViewChanged 中处理。如果在这个方法中 child 尺寸或者位置发生了变化，则需要 return true。</li>
<li>当 Behavior 中的 View 准备响应嵌套滑动时，它不需要通过 layoutDependsOn() 来进行依赖绑定。只需要在 onStartNestedScroll() 方法中通过返回值告知 ViewParent，它是否对嵌套滑动感兴趣。返回值为 true 时，后续的滑动事件才能被响应。</li>
<li>嵌套滑动包括滑动 (scroll) 和 快速滑动 (fling) 两种情况。开发者根据实际情况运用就好了。</li>
<li>Behavior 通过 3 种方式绑定：1. xml 布局文件。2. 代码设置 layoutparam。3. 自定义 View 的注解。</li>
</ol>
<p>来源：<a href="http://blog.csdn.net/briblue/article/details/73076458" target="_blank" rel="noopener noreferrer">针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN 博客</a></p>
</blockquote>
<h2> 参考文献</h2>
<ul>
<li><a href="http://blog.csdn.net/briblue/article/details/73076458" target="_blank" rel="noopener noreferrer">针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN 博客</a></li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0824/6565.html" target="_blank" rel="noopener noreferrer">CoordinatorLayout 自定义 Behavior 并不难，由简到难手把手带你撸三款！ - 泡在网上的日子</a></li>
<li><a href="https://www.jianshu.com/p/8c92d0a1e591" target="_blank" rel="noopener noreferrer">一步一步深入理解 CoordinatorLayout - 简书</a></li>
<li><a href="https://www.jianshu.com/p/5287d090e777" target="_blank" rel="noopener noreferrer">使用 CoordinatorLayout 打造一个炫酷的详情页 - 简书</a></li>
</ul>
]]></content:encoded>
      <enclosure url="http://jixiaoyong.github.io/blog/images/default/2018-02-22/coordinatorlayout.gif" type="image/gif"/>
    </item>
    <item>
      <title>Android 控件组</title>
      <link>https://jixiaoyong.github.io/blog/posts/3b69424a.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/3b69424a.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 控件组</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 20 Sep 2017 15:25:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>这几天的工作中用到了控件组来实现复杂布局，效果不错，记录下来备用。</p>
<h2> 1. 定义控件组布局 xxx_layout.xml</h2>
<p>在这里定义要使用的控件组布局，这里的布局决定了布局显示的样子。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2.新建自定义属性文件 attr.xml（可选）</h2>
<ul>
<li>
<p>在<code>values/attr.xml</code>下新建对应文件，并添加对于自定义属性，以便可以在 activity 布局文件里面使用到该件组时自定义控一些属性。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>在该自定义控件的类 xxx.java 中，通过如下语句获取从用户使用时赋给这些属性的值：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>​</p>
</li>
<li>
<p>用户动态给这些属性赋值：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，这里写的是<code>app:</code>而非<code>android:</code>。</p>
<p>​</p>
</li>
</ul>
<h2> 3. 新建组合控件的类 XXX.java</h2>
<ul>
<li>
<p>新建 XXX.java，继承自布局文件的父布局 LinearLayout</p>
</li>
<li>
<p>更改参数少的构造方法的<code>super(a1,a2,a3)</code>为<code>this(a1,a2,a3)</code>，其中<code>this()</code>中的参数个数为参数最多的构造方法的参数数。</p>
<p><strong>注意</strong> ：一定要做这一步，否则在使用该自定义控件组时，新建该类的对象会提示出错</p>
</li>
<li>
<p>在最终会被调用的构造方法里面将 xml 里面定义的布局加载进来：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>使用自定义属性：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>给控件组内部控件添加点击事件监听：</p>
<ul>
<li>
<p>xxx.java 要实现点击事件监听接口：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>自定义接口，供使用 xxx.java 类时实现对监听事件的处理：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>对要监听点击事件的控件设置监听，并调用<code>listener.onClick()</code>方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<h2> 4. 使用自定义控件组 xxx.java</h2>
<ul>
<li>
<p>在布局文件 main_activity.xml 中添加该控件</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​</p>
</li>
<li>
<p>在 java 中使用该控件，设置监听事件</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5.效果预览</h2>
<figure><img src="http://upload-images.jianshu.io/upload_images/120748-48d0cbbf03ded7f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="效果预览" tabindex="0" loading="lazy"><figcaption>效果预览</figcaption></figure>
<h2> 6.源码</h2>
<p>demo 的 github 链接：<a href="https://github.com/jixiaoyong/my_application_on_deepin/tree/master/weightgroup" target="_blank" rel="noopener noreferrer">github</a></p>
]]></content:encoded>
      <enclosure url="http://upload-images.jianshu.io/upload_images/120748-48d0cbbf03ded7f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" type="image/"/>
    </item>
    <item>
      <title>Android 笔记之 Xfermode</title>
      <link>https://jixiaoyong.github.io/blog/posts/104c9058.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/104c9058.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 笔记之 Xfermode</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 15 Apr 2020 06:05:03 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>Xfermode</code>是 Android 中用来指示<code>Paint</code>绘制的内容与 View 中已有内容的混合计算方式，也就是用来确定图形绘制到目标图形的时候，如何处理两个图形重合部分的颜色变化。共 18 个，分为 Alpha 合成和混合两种。</p>
<p>设要绘制的图形为<code>src</code>，已经绘制好的图形为<code>dst</code>。</p>
<blockquote>
<p>需要注意的是，这些图片除了要绘制的图形有着色之外，其他部分要为透明，并且<strong>包括透明区域在内的图片大小（宽高）要能完全覆盖另外一张图片的图形区域</strong>，否则绘制出的图形可能与预设的效果不一致</p>
</blockquote>
<p>按照官方的定义，不同<code>Xfermode</code>绘制结果如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/20200415211144.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 注意事项</h2>
<p>要实现如上效果，需要注意：</p>
<ul>
<li>
<p><code>src</code>和<code>dst</code>符合要求（要有合适的透明区域）</p>
<p>这是因为<code>xfermode</code>的效果，使用透明部分的像素与已有图形对应位置交叉作用，得出所需要的效果，如果透明区域过小，则无法作用到对应的图形。下面这个来自 <a href="http://Hencoder.com" target="_blank" rel="noopener noreferrer">Hencoder.com</a> 的图可以很形象的解释：</p>
<figure><img src="https://jixiaoyong.github.io/images/20200416213802.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>在新的图层绘制（在新的图层按照<code>xfermode</code>规则绘制，然后再将其绘制到原有图层）：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>关闭硬件加速（可选）</p>
<p>硬件加速的本质是把一部分 CPU 计算的工作量交给 GPU 完成，可以加速绘制速度。</p>
<p>但是由于硬件加速不支持<code>canvas.drawXXX()</code>的部分方法，为了避免在某些机型上面无法使用这些方法，可以关闭硬件加速：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>关于硬件加速更详细的说明可以参考这里：<a href="https://hencoder.com/ui-1-8/" target="_blank" rel="noopener noreferrer">HenCoder Android 自定义 View 1-8 硬件加速</a></p>
</li>
</ul>
<h2> Xfermode 分类</h2>
<p><a href="https://hencoder.com/ui-1-2/" target="_blank" rel="noopener noreferrer">HenCoder.com</a>关于<code>PorterDuff.Mode.DST_IN</code>的动画解释：</p>
<figure><img src="https://jixiaoyong.github.io/images/20200416214402.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看出，<code>Xfermode</code>的本质是处理<code>dst</code>与<code>src</code><strong>重合与未重合部分</strong>的展示与否，以及颜色变化。</p>
<blockquote>
<p>这里的“重合部分”与“未重合部分”，其实也包括了各个图形的透明部分，将<code>dst</code>与<code>src</code>的透明与不透明颜色相互作用，才会出现下述效果。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CLEAR</code></td>
<td>清除所有内容</td>
</tr>
<tr>
<td><code>DST</code></td>
<td>只绘制<code>DST</code></td>
</tr>
<tr>
<td><code>DST_ATOP</code></td>
<td>先绘制<code>SRC</code>，再在顶部绘制<code>DST</code>与<code>SRC</code>重合的部分</td>
</tr>
<tr>
<td><code>DST_IN</code></td>
<td>只绘制<code>DST</code>与<code>SRC</code>重合部分</td>
</tr>
<tr>
<td><code>DST_OUT</code></td>
<td>只绘制<code>DST</code>与<code>SRC</code>未重合部分</td>
</tr>
<tr>
<td><code>DST_OVER</code></td>
<td>将<code>DST</code>绘制在<code>SRC</code>上面</td>
</tr>
<tr>
<td><code>SRC</code></td>
<td>只绘制<code>SRC</code></td>
</tr>
<tr>
<td><code>SRC_ATOP</code></td>
<td>先绘制<code>DST</code>，再在顶部绘制<code>SRC</code>与<code>DST</code>重合的部分</td>
</tr>
<tr>
<td><code>SRC_IN</code></td>
<td>只绘制<code>SRC</code>与<code>DST</code>重合部分</td>
</tr>
<tr>
<td><code>SRC_OUT</code></td>
<td>只绘制<code>SRC</code>与<code>DST</code>未重合部分</td>
</tr>
<tr>
<td><code>SRC_OVER</code></td>
<td>将<code>SRC</code>绘制在<code>DST</code>上面</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>XOR</code></td>
<td></td>
</tr>
<tr>
<td><code>ADD</code></td>
<td></td>
</tr>
<tr>
<td><code>DARKEN</code></td>
<td></td>
</tr>
<tr>
<td><code>LIGHTEN</code></td>
<td></td>
</tr>
<tr>
<td><code>MULTIPLY</code></td>
<td></td>
</tr>
<tr>
<td><code>OVERLAY</code></td>
<td></td>
</tr>
<tr>
<td><code>SCREEN</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>各个效果如下 (源码及使用见<a href="https://github.com/jixiaoyong/library/commit/71864b6546460acfaae6299890a0cf76da76b7d7" target="_blank" rel="noopener noreferrer">github</a>)：</p>
<figure><img src="https://jixiaoyong.github.io/images/20200415211144.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 参考文献</h2>
<p><a href="https://hencoder.com/ui-1-2/" target="_blank" rel="noopener noreferrer">HenCoder Android 开发进阶：自定义 View 1-2 Paint 详解</a></p>
<p><a href="https://hencoder.com/ui-1-8/" target="_blank" rel="noopener noreferrer">HenCoder Android 自定义 View 1-8 硬件加速</a></p>
<p><a href="https://developer.android.google.cn/reference/android/graphics/PorterDuff.Mode.html" target="_blank" rel="noopener noreferrer">PorterDuff.Mode</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20200415211144.png" type="image/png"/>
    </item>
    <item>
      <title>Android 笔记之跨进程通信</title>
      <link>https://jixiaoyong.github.io/blog/posts/7e97a976.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/7e97a976.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 笔记之跨进程通信</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 26 Dec 2019 10:52:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>Android 中的跨进程通信 IPC 主要有以下几种方式：</p>
<ul>
<li>BroadcastReceiver</li>
<li>ContentProvider</li>
<li>AIDL</li>
<li>Messenger</li>
<li>Socket</li>
<li>文件</li>
</ul>
<p>Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制</p>
<p><strong>进程是资源分配的基本单位，线程是调度的基本单位。</strong></p>
<h2> 一些基础知识</h2>
<p>以下内容来自：</p>
<p>作者：SylvanasSun<br>
链接：<a href="https://juejin.im/post/59f8691b51882534af254317" target="_blank" rel="noopener noreferrer">https://juejin.im/post/59f8691b51882534af254317</a><br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>Linux 为每个进程维护了一个单独的虚拟地址空间。<strong>虚拟地址空间分为内核空间与用户空间</strong>，用户空间包括代码、数据、堆、共享库以及栈，内核空间包括内核中的代码和数据结构，内核空间的某些区域被映射到所有进程共享的物理页面。Linux 也将一组连续的虚拟页面（大小等于内存总量）映射到相应的一组连续的物理页面，这种做法为内核提供了一种便利的方法来访问物理内存中任何特定的位置。</p>
<figure><img src="https://jixiaoyong.github.io/images/20200422114446.png" alt="示意图来自 https://juejin.im/post/59f8691b51882534af254317" tabindex="0" loading="lazy"><figcaption>示意图来自 <a href="https://juejin.im/post/59f8691b51882534af254317" target="_blank" rel="noopener noreferrer">https://juejin.im/post/59f8691b51882534af254317</a></figcaption></figure>
<p>Linux 通过将一个虚拟内存区域与一个硬盘上的文件关联起来，以初始化这个虚拟内存区域的内容，这个过程称为<strong>内存映射</strong>（memory mapping）。这种将虚拟内存系统集成到文件系统的方法可以简单而高效地把程序和数据加载到内存中。</p>
<p><strong>普通文件映射就是将一个文件与一块内存建立起映射关系，对该文件进行 IO 操作可以绕过内核直接在用户态完成（用户态在该虚拟地址区域读写就相当于读写这个文件）</strong>。匿名文件映射一般在用户空间需要分配一段内存来存放数据时，由内核创建匿名文件并与内存进行映射，之后用户态就可以通过操作这段虚拟地址来操作内存了。匿名文件映射最熟悉的应用场景就是动态内存分配（malloc() 函数）。</p>
<p><strong>内存映射提供了共享对象的机制，来避免内存资源的浪费。一个对象被映射到虚拟内存的一个区域，要么是作为共享对象，要么是作为私有对象的。</strong> 进程对共享对象的写操作对于其他也使用到该共享对象的进程是可见的。</p>
<p>CPU 获取到虚拟地址，然后通过 MMU（内存管理单元）将其翻译为物理地址。</p>
<h2> linux IPC</h2>
<p>优缺点参考：</p>
<blockquote>
<ol>
<li>管道：在创建时分配一个 page 大小的内存，缓存区大小比较有限；</li>
<li>消息队列：信息复制两次，额外的 CPU 消耗；不合适频繁或信息量大的通信；</li>
<li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li>套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li>
<li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>信号：不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ol>
<p>作者：Gityuan<br>
链接：<a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/39440766/answer/89210950</a></p>
</blockquote>
<ul>
<li>管道 Pipe</li>
</ul>
<p><a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)" target="_blank" rel="noopener noreferrer">管道</a> 是将标准输入输出连接起来的进程。 <strong>数据复制 2 次，有长度限制</strong></p>
<figure><img src="https://jixiaoyong.github.io/images/20200422114721.jpg" alt="示意图来自 https://pic002.cnblogs.com/images/2012/426620/2012110216160766.jpg" tabindex="0" loading="lazy"><figcaption>示意图来自 <a href="https://pic002.cnblogs.com/images/2012/426620/2012110216160766.jpg" target="_blank" rel="noopener noreferrer">https://pic002.cnblogs.com/images/2012/426620/2012110216160766.jpg</a></figcaption></figure>
<p>如图，进程 1 将数据<strong>写入</strong>到管道（内存缓存区），进程 2 从管道中<strong>读取</strong>数据。数据从写端流入管道，从读端流出，这样就实现了进程间通信</p>
<p>每个进程的输出被当做下一个进程的输入。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html" target="_blank" rel="noopener noreferrer">Linux 进程间通信之管道 (pipe)、命名管道 (FIFO) 与信号 (Signal)</a><br>
<a href="https://blog.csdn.net/skyroben/article/details/71513385" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/skyroben/article/details/71513385</a></p>
<ul>
<li>消息队列 Message</li>
</ul>
<p>是一串可以有不同类型的消息块的链表，可以避免阻塞。<strong>数据复制 2 次，有长度限制</strong>，缓冲小。</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html</a></p>
<ul>
<li>共享内存</li>
</ul>
<p>多个进程可以访问一个公用的内存空间。效率最高的 IPC。<strong>数据内存复制 0 次，但是没有同步互斥机制</strong></p>
<ul>
<li>套接字 Socket</li>
</ul>
<p>传输效率低，<strong>数据复制 2 次</strong></p>
<ul>
<li>信号量 semaphore</li>
</ul>
<p>与管道不同，信号量是为了保护进程共享资源在同一时刻只能被一个进程访问。解决同步和互斥问题。</p>
<p>sv：信号变量</p>
<p>对信号量的操作只有一下 P(sv) 和 V(sv) 两个原子操作：</p>
<ol>
<li>进程 1 访问资源时对信号量进行等待操作 P(sv)（如果 sv&gt;0 则操作资源并将信号量 -1，否则挂起进程等待）；</li>
<li>当该进程 1 对资源执行完操作后，对信号量进行发送操作 V(sv)（此时如果有进程 2 等待 sv 而挂起，则恢复进程 2，否则就给 sv+1）</li>
</ol>
<p><a href="https://blog.csdn.net/skyroben/article/details/72513985" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/skyroben/article/details/72513985</a></p>
<ul>
<li>信号 Signal</li>
</ul>
<p>信号是进程间通信中唯一的异步通信机制，通知接收信号的进程发生了什么事情。而进程接受到信号后可以忽略，捕获处理，或者使用系统默认操作。</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html</a></p>
<p>只能承载很小的信息量，主要用在进程的中断控制</p>
<h2> Binder</h2>
<p>数据拷贝 1 次，有权限校验（为发送方添加了 UID/PID 身份）</p>
<figure><img src="https://jixiaoyong.github.io/images/20200422115508.gif" alt="参与 Binder 通信的所有角色 图片来自 https://blog.csdn.net/universus/article/details/6211589" tabindex="0" loading="lazy"><figcaption>参与 Binder 通信的所有角色 图片来自 <a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/universus/article/details/6211589</a></figcaption></figure>
<p>时序图：</p>
<figure><img src="https://jixiaoyong.github.io/images/20200422115253.png" alt="20200422115253" tabindex="0" loading="lazy"><figcaption>20200422115253</figcaption></figure>
<p>理论上的 Binder 逻辑：</p>
<blockquote>
<p>SMgr 提供的 Binder 比较特殊，它没有名字也不需要注册，当一个进程使用 BINDER_SET_CONTEXT_MGR 命令将自己注册成 SMgr 时 Binder 驱动会自动为它创建 Binder 实体（这就是那只预先造好的鸡）。其次这个 Binder 的引用在所有 Client 中都固定为 0 而无须通过其它手段获得。</p>
<p>在数据从发送方向接收方拷贝时，驱动会根据发送数据包的大小，使用最佳匹配算法从缓存池中找到一块大小合适的空间，<strong>将数据从发送缓存区复制过来</strong>。</p>
<p>为了实现用户空间到用户空间的拷贝，Binder 驱动的 mmap() 分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用 copy_from_user() 将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是 Binder 只需一次拷贝的‘秘密’。</p>
<p>版权声明：本文为 CSDN 博主「universus」的原创文章，遵循 CC 4.0 BY-SA</p>
<p>版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/universus/article/details/6211589</a></p>
</blockquote>
<p>主要参考文章：<a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/universus/article/details/6211589</a></p>
<p><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/freekiteyu/article/details/70082302</a></p>
<p>Binder 通信主要涉及一下对象：</p>
<ul>
<li>Server</li>
<li>Client</li>
<li>ServerManager</li>
<li>Binder 驱动</li>
</ul>
<p>首先要知道，Server，Client 以及 ServerManager 一般都在不同的进程之中，那么 Server，Client 如何与 ServerManager 通信并注册/查询所需的服务呢？这里就需要用到<strong>0 号引用 Binder</strong>。</p>
<p><strong>0 号引用 Binder</strong> 是 ServerManager 内部创建匿名 Binder，所有的 Client（相对于 ServerManager 来说其他和他交互的都是 Client）都默认持有这个 Binder 的引用。</p>
<p>所以一个完整的 AIDL 通信过程如下：</p>
<ol>
<li>Server 创建一个 Binder 和对应名字</li>
<li>Server 通过持有的 0 号引用 Binder 和 ServerManager 通信。<br>
将生成的 Binder 和对应名字发送到 Binder 驱动，Binder 驱动会为这个 Binder 在内核空间创建对应实体节点及其引用（<strong>复制了一次</strong>），并通过 0 号引用将其发给 ServerManager。</li>
<li>ServerManager 收到内核中的 Binder 对象引用及名字后将其保存到查找表中。</li>
<li>Client 通过 0 号引用 Binder 和 ServerManager 通信。<br>
Client 将需要的 Binder 的名字发给 ServerManager，ServerManager 查询到已经注册的内核 Binder 引用并将其发给 Client。</li>
<li>Client 获取到内核 Binder 的引用进行操作。</li>
</ol>
<p>再来看看一个完整的流程：</p>
<p>在 Service 中，我们会先创建一个 mIBinder 对象并且在<code>public IBinder onBind(Intent intent)</code>方法返回。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>追踪 onBind 方法，我们会发现<code>mIBinder</code>的对象会在 ActivityThread 中的<code>private void handleBindService(BindServiceData data)</code>方法中被传入到 IActivityManager 的 publishService 方法中。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ActivityManager.getService() 方法是通过 IPC 获取到 ActivityManager 的引用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而根据<a href="https://www.jianshu.com/p/91c97710976a" target="_blank" rel="noopener noreferrer">这篇文章</a>，这个 binder 最终会被传输到绑定这个服务时所用的 ServiceConnection 对象的<code>onServiceConnected</code>方法中（<strong>即 mIBinder 通过 ServerManager 从 Service 传递到了 Client</strong>）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据<a href="https://blog.csdn.net/zhangyongfeiyong/article/details/51953300" target="_blank" rel="noopener noreferrer">Android 服务之 bindService 源码分析</a>mConnection 会通过<code>context.bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</code>最终在 ActivityManagerService 通过 Binder 驱动程序调用 ActivityThread 类中的 scheduleBindService 方法传递到 Service 所在进程中，并根据 Service 的状态不同而被调用对应方法（<strong>即 mConnection 通过 ServerManager 从 Client 传递到了 Service</strong>）。</p>
<figure><img src="https://jixiaoyong.github.io/images/20200422115031.jpg" alt="图片来自 https://img-blog.csdn.net/20160719100800917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" tabindex="0" loading="lazy"><figcaption>图片来自 <a href="https://img-blog.csdn.net/20160719100800917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener noreferrer">https://img-blog.csdn.net/20160719100800917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center</a></figcaption></figure>
<p>在这其中我们用到了两个涉及到 AIDL 文件：</p>
<ul>
<li>private IBinder mIBinder = new AidlBinderInterface.Stub() {}</li>
<li>mServiceInterface = AidlBinderInterface.Stub.asInterface(service);</li>
</ul>
<p>再来看看我们写的对应的 AIDL 文件：</p>
<div class="language-aidl line-numbers-mode" data-ext="aidl"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个文件中都是我们自己定义的方法，系统自动帮我们实现了更详细的内容：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可知<code>mRemote</code>便是指向 AMS 服务的<code>BinderProxy</code>对象 <a href="https://www.diycode.cc/topics/384" target="_blank" rel="noopener noreferrer">https://www.diycode.cc/topics/384</a></p>
<p><a href="https://www.cnblogs.com/a284628487/p/3187320.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/a284628487/p/3187320.html</a></p>
<figure><img src="https://jixiaoyong.github.io/images/20200422114923.jpg" alt="图片来自 https://images0.cnblogs.com/blog/391137/201307/12211553-49c477a875e84b2aae764c67f38f26b2.jpg" tabindex="0" loading="lazy"><figcaption>图片来自 <a href="https://images0.cnblogs.com/blog/391137/201307/12211553-49c477a875e84b2aae764c67f38f26b2.jpg" target="_blank" rel="noopener noreferrer">https://images0.cnblogs.com/blog/391137/201307/12211553-49c477a875e84b2aae764c67f38f26b2.jpg</a></figcaption></figure>
<h3> others</h3>
<p>如果在 BroadcastReceiver 的 onReceive 方法中创建一个线程，那么当该方法返回时，Android 系统就会认为该 BroadcastReceiver 已经完成任务了，从而会在需要回收内存时杀死进程以及其中的 Thread。创建一个<a href="https://developer.android.google.cn/reference/android/app/job/JobService.html?hl=zh-cn" target="_blank" rel="noopener noreferrer">JobService</a>可以避免这个情况。</p>
<blockquote>
<p>So, the system may kill the process at any time to reclaim memory, and in doing so, it terminates the spawned thread running in the process.</p>
<p><a href="https://developer.android.google.cn/guide/components/activities/process-lifecycle?hl=zh-cn" target="_blank" rel="noopener noreferrer">https://developer.android.google.cn/guide/components/activities/process-lifecycle?hl=zh-cn</a></p>
</blockquote>
<p><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/universus/article/details/6211589</a></p>
<p><a href="https://www.jianshu.com/p/429a1ff3560c" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/429a1ff3560c</a></p>
<p><a href="https://www.cnblogs.com/a284628487/p/3187320.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/a284628487/p/3187320.html</a></p>
<p><a href="http://hoyouly.fun/2019/07/17/Android-AIDL/" target="_blank" rel="noopener noreferrer">http://hoyouly.fun/2019/07/17/Android-AIDL/</a></p>
<p><a href="https://juejin.im/entry/59c9cd59f265da065754e6f1" target="_blank" rel="noopener noreferrer">https://juejin.im/entry/59c9cd59f265da065754e6f1</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20200422114446.png" type="image/png"/>
    </item>
    <item>
      <title>Android 系统架构简介</title>
      <link>https://jixiaoyong.github.io/blog/posts/e3bb9a54.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/e3bb9a54.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 系统架构简介</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 23 Feb 2018 14:35:14 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>说明：本文基于<a href="http://gityuan.com/android/" target="_blank" rel="noopener noreferrer">Android 系统开篇 - Gityuan 博客 | 袁辉辉博客</a> 的学习笔记整理</p>
</blockquote>
<p>Android 系统大体分为 4 个模块，从底层开始依次是 1.linux 内核、2.系统库+Android 运行时、3.框架层、4.应用层。</p>
<figure><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidSystemArchitecture.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下图描述了 Android 系统从开机到 Apk 运行的整个流程。</p>
<figure><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/androidBoot.jpg" alt="系统启动框架图，来自 gityuan.com" tabindex="0" loading="lazy"><figcaption>系统启动框架图，来自 <a href="http://gityuan.com" target="_blank" rel="noopener noreferrer">gityuan.com</a></figcaption></figure>
<p>流程如下：<code>Loader</code> -&gt; <code>Kernel</code> -&gt; <code>Native</code>-&gt; <code>Framework</code> -&gt; <code>App</code></p>
<p><strong>Loader 层</strong></p>
<ol>
<li>Boot ROM：开机时，引导芯片从 ROM 读取读取初始化代码，加载引导程序到 RAM 中。</li>
<li>Boot Loader：是启动 Android 系统之前的引导程序，检查 RAM、初始化硬件参数等。</li>
</ol>
<p><strong>Kernel 层</strong>（即 Android 内核层，进入 Android 系统）</p>
<ol>
<li>swapper 进程（pid=0）：Boot Loader 启动 swapper（idle）进程，是由内核创建的第一个进程，用来初始化进程管理、内存管理、驱动等等。</li>
<li>kthreadd 进程（pid=2）：是 Linux 系统的内核进程，<strong>是所有内核进程的鼻祖</strong>。</li>
</ol>
<hr>
<p><strong>Syscall</strong>，在 Native 和 Kernel 之间的系统调用层。</p>
<hr>
<p><strong>Native 层</strong></p>
<ol>
<li>init 进程（pid=1）：由 swapper 进程创建，<strong>是所有用户进程鼻祖</strong></li>
<li>init 进程孵化出用户守护进程、启动 ServiceManager 管理系统服务，启动开机动画 Bootnaim。</li>
</ol>
<hr>
<p><strong>JNI</strong>，Java 层和 Native（C/C++）层之间。</p>
<hr>
<p><strong>Framework 层</strong></p>
<ol>
<li>Zygote 进程：由 init 进程 fork 生成，是<strong>Android 系统第一个 java 进程，是所有 java 进程的父进程</strong></li>
<li>SystemServer 进程：由 Zygote 进程 fork 而来，<strong>是 Zygote 孵化的第一个进程</strong>，负责启动和管理整个<strong>java framework</strong>，如 ActivityManager、PowerManager...</li>
<li>MediaServer 进程：由 init 进程 fork 而来，负责启动和管理整个<strong>C++ framework</strong></li>
</ol>
<p><strong>APP 层</strong></p>
<ol>
<li>Launcher：<strong>Zygote 进程孵化的第一个 App 进程</strong>，桌面 App。</li>
<li>其他由 Zygote 进程孵化的系统进程（Browser、Phone...）和非系统 app 进程。</li>
</ol>
<p>扼要内容如图：</p>
<figure><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidBootImg.png" alt="系统启动示意图" tabindex="0" loading="lazy"><figcaption>系统启动示意图</figcaption></figure>
<p>Android 常用的通信方式</p>
<ol>
<li>Binder</li>
<li>Socket</li>
<li>Handler</li>
</ol>
<p><strong>Binder/Socket 用于进程间（都具有独立的地址空间）通信，而 Handler 消息机制用于同进程的线程间（共享内存空间）通信</strong></p>
<p>在 Android 系统中：</p>
<ul>
<li>Zygote 进程 --&gt; Socket 机制</li>
<li>SystemServer、MediaServer、App 之间 --&gt; Binder IPC</li>
<li>同一进程不同线程间 --&gt; Handler</li>
</ul>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidSystemArchitecture.png" type="image/png"/>
    </item>
    <item>
      <title>Android 笔记之贝塞尔曲线的应用</title>
      <link>https://jixiaoyong.github.io/blog/posts/5c023044.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/5c023044.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 笔记之贝塞尔曲线的应用</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 10 Apr 2020 01:49:03 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF" target="_blank" rel="noopener noreferrer">贝塞尔曲线</a>是用节点和控制点绘制的高精度曲线，Android 中常用的有二阶、三阶贝塞尔曲线。本文介绍使用贝塞尔曲线绘制折线图，并实现动画效果。</p>
<figure><img src="https://jixiaoyong.github.io/images/20200413215502.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本文代码链接：<a href="https://github.com/jixiaoyong/library/blob/master/library/src/main/java/cf/android666/applibrary/view/BezierViewAnim.kt" target="_blank" rel="noopener noreferrer">https://github.com/jixiaoyong/library/blob/master/library/src/main/java/cf/android666/applibrary/view/BezierViewAnim.kt</a></p>
<h2> 贝塞尔曲线介绍</h2>
<p>下图是二阶贝塞尔曲线绘制方法介绍，只要各个点满足条件：AD/AB = BE/BC = DF/DE，那么当沿着当前线段移动 D、E 点时，F 点的运动轨迹就是一个贝塞尔曲线：</p>
<figure><img src="https://jixiaoyong.github.io/images/20200413215622.png" alt="图片来自：https://www.cnblogs.com/wjtaigwh/p/6647114.html" tabindex="0" loading="lazy"><figcaption>图片来自：<a href="https://www.cnblogs.com/wjtaigwh/p/6647114.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/wjtaigwh/p/6647114.html</a></figcaption></figure>
<p>动图示意如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/20200413222352.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以在下面的两个网站在线体验贝塞尔曲线：</p>
<p><a href="https://aaaaaaaty.github.io/bezierMaker.js/playground/playground.html" target="_blank" rel="noopener noreferrer">https://aaaaaaaty.github.io/bezierMaker.js/playground/playground.html</a></p>
<p><a href="https://bezier.method.ac/" target="_blank" rel="noopener noreferrer">https://bezier.method.ac/</a></p>
<h2> 计算控制点坐标</h2>
<p>在绘制折线图时，我们获取的数据可以当做贝塞尔曲线的端点，Android 为我们提供了绘制二阶和三阶贝塞尔曲线的方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以<code>Path.cubicTo()</code>方法为例，在绘制三阶贝塞尔曲线时，起点和终点已知，剩下工作就是计算两个控制点的坐标。</p>
<h3> 方法 1</h3>
<p>按照贝塞尔曲线的定义，计算各个点对应控制点的坐标，具体的计算原理我们可以参考<a href="https://wenku.baidu.com/view/c790f8d46bec0975f565e211.html" target="_blank" rel="noopener noreferrer">这篇文章</a></p>
<p>假设起点、终点分别为<code>startPoint</code>，<code>endPoint</code>，起点前一个点为<code>beforePointF</code>，终点后一个点为<code>afterPoint</code>，那么终止点 1、2（<code>controlPoint1</code>、<code>controlPoint2</code>）的坐标满足（其中 a,b 为任意正数，比如 1/6）：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这里要处理特殊情况：第一个点 P<sub>0</sub>的前一个仍然为 P<sub>0</sub>，最后一个点 P<sub>n</sub>的后一个点仍为 P<sub>n</sub></p>
</blockquote>
<p>但这种情况绘制出来的贝塞尔曲线如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/20200413220840.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到除了 P<sub>0</sub>和 P<sub>n</sub>外，其他点的曲线坐标和对应的点坐标不一致。</p>
<h3> 方法 2</h3>
<p>为了解决方法 1 存在的问题，我们人为的在两个点之间加入两个控制点，这样在<code>startPoint</code>，<code>endPoint</code>之间的贝塞尔曲线首尾点的坐标必定落在起点和终点上（思路来自<a href="https://blog.csdn.net/laizuling/article/details/51162011" target="_blank" rel="noopener noreferrer">这里</a>）。</p>
<p>所以，两个控制点的坐标为：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样绘制出来的曲线比较符合我们的要求。</p>
<p>所以，最终贝塞尔曲线 path 计算方法如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 给 Path 添加渐变背景</h2>
<p>我们可以使用<code>Paint.setShader(Shader shader)</code>方法，在绘制 Path 的时候绘制渐变背景。</p>
<p>渐变背景使用 Shader 实现。</p>
<p>为了确保绘制效果，我们需要在 Path 计算完成后，将其闭合，以确保绘制的背景在我们需要的范围内：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 给 Path 添加动画</h2>
<p>为了让 Path 看起来是从起点慢慢绘制到终点去的，我们可以先计算 path 的总长度，然后结合<code>ValueAnimator</code>实时获得对应长度的 path 并绘制：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在<code>onDraw()</code>方法中绘制对应的 path：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://jixiaoyong.github.io/images/20200413222302.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 注意事项</h2>
<ul>
<li>
<p>使用 canvas 绘制坐标时，需要注意 android 的坐标原点位于屏幕左上角。所以在绘制曲线图时可以先将坐标原点向下平移一段距离，再绘制对应坐标（可以绘制实际的 y 坐标负值）</p>
</li>
<li>
<p>在拼接贝塞尔曲线的 path 时候注意，<code>path.moveTo()</code>方法会将 path 切断</p>
</li>
</ul>
<h2> 参考资料</h2>
<p><a href="https://wenku.baidu.com/view/c790f8d46bec0975f565e211.html" target="_blank" rel="noopener noreferrer">https://wenku.baidu.com/view/c790f8d46bec0975f565e211.html</a><br>
<a href="https://blog.csdn.net/laizuling/article/details/51162011" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/laizuling/article/details/51162011</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20200413215502.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Android 自定义 View 实现联系人列表</title>
      <link>https://jixiaoyong.github.io/blog/posts/a2c96aac.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/a2c96aac.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 自定义 View 实现联系人列表</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 03 Sep 2017 15:25:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 自定义的 view</h2>
<ul>
<li>LetterIndex.java extends View</li>
<li>ContactsListView.java extends RecyclerView #分析</li>
<li>联系人列表有两个要点
<ul>
<li>字母导航栏<br>
通过自定义 View 画出 26 个字母，设置滑动监听事件，根据上下滑动的距离判断当前选中的字母，并相应更新界面。</li>
<li>列表中的字母标题<br>
针对 item 中的联系人姓名首字母对应的 tag 作比较，若与前一个相同则不显示 title，否则显示。</li>
</ul>
</li>
<li>事件联动
<ul>
<li>当滑动字母导航栏时，除了处理本身的变化外，还要留出接口，以便其他控件获取当前选中的字母。</li>
<li>联系人列表滑动时，除了处理本身变化外，同样要留出接口以便获取当前置顶的 item 对应的字母</li>
<li>字母导航栏要留出方法，以便其他控件指定选中的字母，并更新界面</li>
</ul>
</li>
</ul>
<h2> 具体代码</h2>
<p><strong>ContactsListView.java</strong><br>
重写该类主要是为了实现 ItemDecoration 根据不同的 item 变化，同时可以从 xml 布局文件中获取 ItemDecoration 的自定义属性。<br>
主要代码：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>故而在其内部自定义了一个继承自 ItemDecoratio 得静态内部类 Decorationn 类：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>LetterIndex.java</strong><br>
该类用来画出字母导航栏，并且提供方法获取/设置当前选中的字母</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后重写<code>onTouchEvent(MotionEvent event)</code>方法，在 ACTION_DOWN、ACTION_MOVE、ACTION_UP 时调用对应的方法即可。</p>
<p>重写 onDraw() 方法，画出对应的界面</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 源码</h2>
<p>源代码在我的 Github，<a href="https://github.com/jixiaoyong/my_application_on_deepin/tree/master/contactsdemo/src/main" target="_blank" rel="noopener noreferrer">点这里</a>可以找到。</p>
<h2> 预览如下</h2>
<figure><img src="http://upload-images.jianshu.io/upload_images/120748-183eea3cad2b42ac.gif?imageMogr2/auto-orient/strip" alt="预览.gif" tabindex="0" loading="lazy"><figcaption>预览.gif</figcaption></figure>
]]></content:encoded>
      <enclosure url="http://upload-images.jianshu.io/upload_images/120748-183eea3cad2b42ac.gif?imageMogr2/auto-orient/strip" type="image/"/>
    </item>
    <item>
      <title>Android 自定义 view 的一些知识点</title>
      <link>https://jixiaoyong.github.io/blog/posts/e41787ec.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/e41787ec.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 自定义 view 的一些知识点</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 19 Feb 2018 13:59:28 GMT</pubDate>
      <content:encoded><![CDATA[<h2> View 的绘制</h2>
<p>View 的绘制分为 3 部分：</p>
<ol>
<li>
<p>measure</p>
<p>测量，决定了 View 的测量宽、高。几乎所有情况下都等同于 View 的最终宽、高（如果 View 需要多次 measure 才能确定大小，或者重写了<code>layout()</code>方法，并修改了传入的值的话则不会相等）。</p>
</li>
<li>
<p>layout</p>
<p>布局，决定 View 的四个顶点坐标和实际的宽、高。</p>
</li>
<li>
<p>draw</p>
<p>绘制，决定了 View 的具体显示内容。</p>
</li>
</ol>
<p>其中通过 ViewRootImpl 类的<code>performTraversals()</code>依次调用<code>performXXX()</code>方法。</p>
<h2> MeasureSpec</h2>
<p>MeasureSpec 是一个 32 位 int 值，高 2 位表示 SpecMode，低 30 位表示 SpecSize。</p>
<p>SpecMode 有 3 种可能值：</p>
<ul>
<li>UNSPECIFIED 父容器没有限定 View 大小，可以是任意需要的大小</li>
<li>EXACTLY 父类指定了 View 的具体大小，View 的最终大小就是这个值 (match_parent 或者具体数值)</li>
<li>AT_MOST View 可以是这个值以内的任意大小 (wrap_content)</li>
</ul>
<p>我们指定的 View 的 LayoutParams 和父容器（DecorView 则是窗口的尺寸，普通 View 是父容器的 MeasureSpec）一起决定了 View 的 MeasureSpec，进而决定了 View 的宽高。</p>
<p>SpecSize 决定于父容器的尺寸、以及 View 的 margin 和 padding。</p>
<h2> View 绘制流程</h2>
<p>final 类型的<code>measure()</code>方法调用<code>onMeasure()</code>方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>onMeasure()</code>调用了<code>setMeasuredDimension()</code>方法设置了 View 宽、高的测量值。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>getSuggestedMinimumXXX()</code>的值：</p>
<p>如果 View 没有背景，则返回的是 View 的<code>android:miniWidth</code>指定的值；</p>
<p>如果 View 有背景，则返回的是背景的<code>minimumWidth</code>的值和<code>android:miniWidth</code>指定的值中最大的一个值。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由此，我们知道，如果直接继承自 View 的控件必须重写<code>onMeasure()</code>方法，设置 wrap_content 时候控件的大小。这是因为：</p>
<p>wrap_content 对应的 specMode 是 AT_MOST 模式，其宽高等于<code>specSize</code>。</p>
<p>根据 ViewGroup 的<code>getChildMeasureSpec()</code>方法，我们知道此时的<code>specSize</code>是父容器目前可以用的大小，即这种情况下 wrap_content 的效果和 match_parent 的效果是一样的。</p>
<p>要避免这种情况，就需要重写<code>onMeasure()</code>方法，在里面专门指定 wrap_content 时 View 对应的大小。</p>
<h2> 获取 View 的宽高</h2>
<p>由于 View 的绘制和 Activity 的生命周期不同步，所以在<code>onCreate()/onStart()/onResume()</code>中都无法有效获取 View 的宽高。使用以下方式则可以正常获取 View 的宽高：</p>
<ol>
<li>
<p>Activity/View#onWindowFocusChanged()</p>
<p>当前的 Window 获取或失去焦点的时候调用，此时 View 已经初始化完毕，可以获取宽、高。</p>
<p>Activity 窗口焦点变化 (onPause/onResume) 时会被调用多次。</p>
</li>
<li>
<p>View#post(runnable)</p>
<p>该 runnable 在 view 的消息队列尾部，被执行时 View 已经初始化好了，可以在这里获取宽高。</p>
</li>
<li>
<p>ViewTreeObserver</p>
<p>注册 onGlobalLayoutListener，当 View 树的状态变更，或者 View 树内部 View 可见性发生变化就会被回调。</p>
<p>当 View 树的状态变更可能被调用多次。</p>
</li>
<li>
<p>View#measure()</p>
<p>手动调用<code>measure()</code>方法获取宽高。</p>
</li>
</ol>
<h2> draw 过程</h2>
<p>绘制过程分为以下几步：</p>
<ol>
<li>绘制背景 <code>background.draw(canvas);</code></li>
<li>绘制自身 <code>onDraw(canvas);</code></li>
<li>绘制 children <code>dispatchDraw(canvas);</code></li>
<li>绘制装饰 <code>onDrawForeground(canvas);</code></li>
</ol>
<p><code>setWillNotDraw()</code>表示当前的 ViewGroup 不需要绘制任何内容，系统会对此进行优化（默认启用）。如果 ViewGroup 需要绘制内容时，则需要手动关闭这个标志。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 绘制两个图形重叠部分</h2>
<p>android 自定义 view 时两个图形重叠部分的绘制方式，一定要调用<code>canvas.saveLayer()</code> ，否则不生效。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>paint.setXfermode()</code>可以设置的值参考下图：</p>
<figure><img src="http://jixiaoyong.github.io/images/20190408175100.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>参考自<a href="https://www.cnblogs.com/DarkMaster/p/4618872.html" target="_blank" rel="noopener noreferrer">【原】使用 Xfermode 正确的绘制出遮罩效果 - sky0014 - 博客园 </a></p>
<h2> 适配自定义 view 宽高，设置默认值</h2>
<p>以其宽度为例，在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p>《Android 开发艺术探索》</p>
]]></content:encoded>
      <enclosure url="http://jixiaoyong.github.io/images/20190408175100.png" type="image/png"/>
    </item>
    <item>
      <title>Android 自定义透明背景的 Dialog</title>
      <link>https://jixiaoyong.github.io/blog/posts/f20627c9.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/f20627c9.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 自定义透明背景的 Dialog</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 26 Jan 2018 07:09:40 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>通过自定义 Dialog 类，使用 Style、AnimationDrawable 等实现一个透明背景的、带进度更新的弹窗。</p>
<p>主要涉及 Style 自定义以及 AnimationDrawable 的使用。</p>
<h2> 代码</h2>
<ul>
<li><strong>布局文件</strong></li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>资源文件</strong></li>
</ul>
<p>1）下载对应进度条的图片资源，放到 drawable 目录下</p>
<p>2）在 drawable 下新建 dialog_progress.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）dialog 圆角背景（非必须）</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4）自定义 dialog 的 style</p>
<p><code>windowBackground</code>使背景透明</p>
<p><code>backgroundDimEnabled</code>则可以去除半透明遮罩效果</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>DIYDialog.java</strong></li>
</ul>
<p>继承自<code>Dialog.java</code> ，并用构造函数调用<code>initView()</code>方法初始化 dialog 样式，有其他需求可以再自己实现。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 源码</h2>
<p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/DIY_Dialog" target="_blank" rel="noopener noreferrer">github 源码路径</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 运行时权限</title>
      <link>https://jixiaoyong.github.io/blog/posts/a2863875.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/a2863875.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 运行时权限</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 25 Nov 2018 05:10:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>本文介绍了 Android 运行时权限的一些处理流程。</p>
<p>Android 运行时权限是 Android6 之后出现的处理权限的新方式，此前开发者只需要应用需要的权限在 AndroidManifest.xml 文件中声明即可，现在则需要在使用到对应权限时检测是否有该权限并作出相应处理。</p>
<h2> 正文</h2>
<h3> 一般流程</h3>
<ol>
<li>
<p>在<code>AndroidManifest.xml</code>中声明所需权限</p>
</li>
<li>
<p>在使用之前检查是否有该权限<code>checkSelfPermission()</code>,如果有则继续相应操作</p>
</li>
<li>
<p>如果没有权限则检测是否需要向用户解释为什么需要该权限<code>ActivityCompat.shouldShowRequestPermissionRationale()</code>，再决定如何申请权限<code>requestPermissions()</code></p>
</li>
</ol>
<blockquote>
<p>需要说明的是，shouldShowRequestPermissionRationale() 在第一次申请该权限时会返回 false，第二次申请时返回 true；ue；</p>
<p>但是如果用户选择了<em>不再提醒</em> 则会一直返回 false。所以如果判断当前并非第一次申请该权限，并且返回结果为 false，就说明用户选择了不再提示，一般就需要提示用户到设置中开启对应权限。</p>
</blockquote>
<ol start="4">
<li>申请权限的结果在<code>onRequestPermissionsResult()</code>方法中返回，根据用户对权限的处理结果决定接下来的操作</li>
</ol>
<h3> 代码</h3>
<p><code>onCreate()</code>方法中调用对应方法</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>checkCameraDeviceAndPremissions()</code>具体内容</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对申请结果进行处理：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>safeRequestCameraPermission()</code>的内容，这里才是处理申请权限的相关代码</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 附录</h2>
<p>样例代码： <a href="https://github.com/jixiaoyong/Notes-Files/commit/f41afa99c24cde1dab619462754435f2a2afc64e#diff-67ccb5e5c6c34760486a1071b23338a2" target="_blank" rel="noopener noreferrer">Github</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 通过 Hook 启动未注册 Activity</title>
      <link>https://jixiaoyong.github.io/blog/posts/26eab50a.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/26eab50a.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 通过 Hook 启动未注册 Activity</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 15 Jan 2018 16:10:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>hook 是钩子的意思，hook 的过程是通过反射、代理等改变系统原有的行为以达到自己的目的。</p>
<p>本文主要是通过 hook android 中的 ActivityManagerService 和 Handler.CallBack，欺骗系统调起 activity 的过程，在调用 startActivity 时将 targetIntent 通过 proxy 伪装为 proxyIntent，等到通过系统验证，正式启动 activity 时，再讲 proxyIntent 恢复为 targetIntent，从而实现调用未在 AndroidManifest.xml 中注册的 activity。</p>
<blockquote>
<p>需要注意，本方法只在 Api&lt;26 下有效。具体原因见后面。</p>
</blockquote>
<h2> 具体实现</h2>
<h3> 1.新建 Activity 等</h3>
<p><code>IndexActivity.java</code>用于启动<code>targetIntent</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>TargetActivity.java</code> 和<code>ProxyActivity.java</code> 分别设置对应页面布局<code>setContentView(R.layout.activity_xxx);</code></p>
<p><code>HookApplication.java</code> 用于调用 hook 方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>AndroidManifest.xml</code>中注册<code>IndexActivity</code>和<code>ProxyActivity</code>，Application 使用<code>HookApplication</code>。</p>
<h3> 2.Utils.java 实现 hook 具体逻辑</h3>
<p><code>Utils.hookAms()</code> 实现拦截 targetIntent 并发起 proxyIntent，欺骗系统对 activity 是否已注册的验证，其中 proxyIntent 通过<code>proxyIntent.putExtra(TARGET_KEY, targetIntent);</code> 方法携带 targetIntent。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>MAmsInvocationHandler</code> 里面实现 targetIntent 和 proxy 的转换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，已经对 activity.startActivity 做了拦截，所有的 targetIntent 都会被拦截，存储在 proxyIntent 中，以通过系统的检查。</p>
<p>接下来，通过系统检查后，<code>hookHandle()</code>通过重写 Handler.CallBack，对启动 proxyIntent 事件做拦截，使之启动 targetIntent 对应的 Activity。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>ActivityThreadHandlerCallBack</code> 将返回我们自定义的 CallBack 以替换系统的，实现启动 targetIntent 而非 proxyIntent。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，就实现了启动通过已经注册了的 ProxyActivity 启动未注册 TargetActivity 的全过程。</p>
<p>主要思想是找到系统实现该过程的逻辑，在对应地方通过反射获取到对应变量，插入自己的逻辑，从而达到目的。</p>
<h2> 附录</h2>
<p>上面涉及到的代码路径：</p>
<p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/AndroidHook/20180116" target="_blank" rel="noopener noreferrer">github 源代码路径</a></p>
<p>参考了几篇文章，其中较为完整的一篇如下：</p>
<p><a href="https://www.jianshu.com/p/69bfbda302df" target="_blank" rel="noopener noreferrer">Android 插件化系列第（一）篇---Hook 技术之 Activity 的启动过程拦截</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Android 阅读笔记</title>
      <link>https://jixiaoyong.github.io/blog/posts/aacd75ab.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/aacd75ab.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Android 阅读笔记</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 22 Feb 2018 11:29:48 GMT</pubDate>
      <content:encoded><![CDATA[<h3> layout_weight</h3>
<p>layout_weight 重要性，默认的是 0,0 等级最高，要显示，数字越大重要性越低。</p>
<p>例：a，b 的宽度为 0，layout_weight 分别为 1、2，则 a，b 宽度分别为父容器的 2/3、1/3。</p>
<h3> PendingIntent</h3>
<p>PendingIntent 是封装后的 intent，有 intent 执行所需的 context，所以即使要执行 intent 的 activity 已经消失或者还没生成，其他 activity 依然可以通过 PendingIntent 执行 intent。</p>
<blockquote>
<p>PendingIntent is a description of an Intent and target action to perform with it. Instances of this class are created with <code>getActivity(Context, int, Intent, int)</code>, <code>getActivities(Context, int, Intent[], int)</code>, <code>getBroadcast(Context, int, Intent, int)</code>, and <code>getService(Context, int, Intent, int)</code>; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.</p>
</blockquote>
<p>也就是把自己要执行的 intent 和执行所需的 context 封装后给别人，请别人在适当的时候执行。</p>
<h3> android 模拟器访问电脑 localhost</h3>
<p>电脑<code>localhost</code>或者<code>127.0.0.1</code>访问本地网址。</p>
<p>模拟器访问<code>localhost</code>会默认访问手机的本地网址，要访问电脑的本地网址则需要访问<code>10.0.2.2:8080</code>，记得加上对应的端口。</p>
<h3> 获取屏幕画面</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 获取网络信息，请求网络</h3>
<p>需要请求权限</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>java 代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> LiveData</h2>
<p><code>LiveData</code>可以在数据有变化的时候调用订阅者并执行指定方法。</p>
<p><code>Transformations</code>有两个转化<code>LiveData</code>的方法：<code>map()</code>和<code>switchMap()</code>。</p>
<p><code>map()</code>可以将一个<code>LiveData</code>经过处理转化为另外一个<code>LiveData</code>。</p>
<p>而<code>switchMap()</code>则可以根据不同的需要切换不同的<code>LiveData</code>。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，<code>LiveData</code>的子类<code>MediatorLiveData</code>可以添加多个监听项，每个项目改变都会回调对应的<code>onChange()</code>方法。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p><a href="https://www.jianshu.com/p/dab2ee97d680" target="_blank" rel="noopener noreferrer">【译】LiveData 使用详解</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>AppWidget 的使用之 PendingIntent</title>
      <link>https://jixiaoyong.github.io/blog/posts/fcfc830b.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/fcfc830b.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">AppWidget 的使用之 PendingIntent</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 24 Apr 2016 22:06:06 GMT</pubDate>
      <content:encoded><![CDATA[<p>这几天学习 AppWidget，很简单的组件却花费了不少功夫，今天对 PendingIntent 的用法做了一些简单的整理。</p>
<p><strong>PendingIntent</strong></p>
<blockquote>
<p>PandingIntent 就像是一个设计好的处理预案，当达到某个特定条件时，便会调用该 Intent 所指定动作（打开服务，Activity 或者发送广播）。</p>
<p>这里使用该方法在 AppWidget 里面为按钮添加监听事件，当按钮被点击的时候触发相应的动作</p>
</blockquote>
<p>AppWidget 和应用程序不再同一个进程当中，而是在 HomeScreen 上面执行，所以不能直接为 AppWidget 中的 Button 添加监听事件，需要用 <code>remoteViews.setPendingIntent(R.id.widget_button,pendingIntent);</code>意思是当按下按钮的时候 pendingIntent 中的 Intent 就会执行</p>
<p>PendingIntent 当某个事件出现之后才会执行</p>
<p>RemoteViews 对象 代表了一系列的 View 对象，和主程序不在同一个进程为 AppWidget 控件绑定处理器</p>
<p><strong>流程概述：</strong></p>
<ul>
<li>
<p>添加 appwidget_provider_info.xml 在 res/xml 下新建 appwidget_provider_info.xml</p>
<ul>
<li>描述 AppWidget 的基本信息如最小高度、宽度等，还有就是该挂件的布局文件</li>
</ul>
</li>
<li>
<p>在 res/layout 下面为该挂件设置具体的布局样式</p>
<ul>
<li>向 AppWidget 的布局文件中添加一个 Button</li>
<li>向 AppWidget 的布局文件中添加一个 TextView</li>
</ul>
</li>
<li>
<p>新建 MyAppWidget.java 继承自 AppWidgetProvider</p>
<p>在该类的 onUpdate() 方法中为 Button 设置、添加监听事件</p>
<ul>
<li>建立一个 Intent 对象</li>
<li>用该 Intent 对象创建一个 PendingIntent 对象</li>
<li>创建一个 RemoteViews 对象</li>
<li>用该 RemoveViews 对象为 按钮绑定事件处理器</li>
<li>更新按钮</li>
</ul>
</li>
<li>
<p>注册事件</p>
</li>
<li>
<p>备注：要是为 AppWidget 中的 Button 设置的事件是打开一个 TargetActivity，还需要添加一个 TargetActivity 类和对应的布局文件</p>
</li>
</ul>
<p><strong>以下是代码</strong></p>
<ul>
<li>appwidget_provider_info.xml</li>
</ul>
<p>这个布局文件是 AppWidget 的信息</p>
<p>描述了 AppWidget 的最小高，最小宽以及它的布局文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>app_widget.xml</li>
</ul>
<p>这个布局文件是 Widget 在桌面上显示的样式</p>
<p>定义了 AppWidget 中各个组件及其样式</p>
<p>其中 Button 用来响应点击事件，加入 TargetActivity</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>target_activity.xml</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>MyAppWidget.java</li>
</ul>
<p>主要是修改了 update() 方法：</p>
<p>定义了一个预先设定的动作—- Intent 对象；</p>
<p>利用该 Intent 读写，创建一个 PendingIntent 对象；</p>
<p>创建一个 RemoteView 对象，并为按钮绑定监听事件</p>
<p>刷新 AppWidget。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>TargetActivity.java</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>AndroidManifest.xml</li>
</ul>
<p>在 AndroidManifest.xml 中注册 TargetActivity 和 MyAppWidget</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>AsyncTask 源码解析</title>
      <link>https://jixiaoyong.github.io/blog/posts/7ee9086b.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/7ee9086b.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">AsyncTask 源码解析</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 19 Apr 2018 14:04:28 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这是 AsyncTask 源码的简单分析，主要基于《Android 开发艺术探索》一书的内容。</p>
</blockquote>
<p>AsyncTask 是 Android 中多线程处理方式之一（其余为 1.HandlerThread、2.IntentService 以及普通的线程 Thread）。</p>
<p>AsyncTask 本质是线程池和 Handler 的包装类，适合实时更新后台任务进度的工作，特别耗时的工作应当交给线程池处理。</p>
<p>AsyncTask 常用方法：</p>
<ul>
<li>onPreExecute()</li>
<li>doInBackground()</li>
<li>onProgressUpdate()</li>
<li>onPostExecute()</li>
</ul>
<p>AsyncTask 有一下限制：</p>
<ol>
<li>AsyncTask 对象必须在主线程（UI 线程，下同）创建</li>
<li>AsyncTask 的 execute() 必须在主线程调用，且只能被调用一次</li>
<li>不能<strong>直接调用</strong>其 4 种常用方法（见上）</li>
</ol>
<h2> 使用</h2>
<ul>
<li>继承自 AsyncTask，重写对应方法。（注意如果需要更新进度，要在 doInBackground() 方法中调用 publishProgress() 方法）</li>
<li>在<strong>UI 线程</strong>实例化 AsyncTask 对象，并调用其 execute() 方法，传入参数开始执行。。</li>
</ul>
<h2> 概述</h2>
<p><strong>在 execute(params) 执行后，将参数 params 传入 mWorker.call() 方法</strong></p>
<p 调用="" doinbackground(params)="" 后台执行任务，同时通过="" postresult()="" 方法发送执行结果，由="" internalhandler.handlemessage()="" 判断该执行="" finish()="" 还是="" onprogressupdate()=""></p>
<p 将="" mworker="" 传入="" mfuture="" 中作为其="" callable="" 在="" runandreset()="" 方法中执行="" c.call()="" 方法。=""></p>
<p><strong>通过 exec.execute(mFuture) 将其压入 SerialExecutor 线程池中排队，并在 THREAD_POOL_EXECUTOR.execute(mActive) 真正执行。</strong></p>
<h2> 代码分析</h2>
<p>创建对象（代码有节略，下同）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看 FutureTask</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在主线程调用 execute() 方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里调用方法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里调用了常用方法之一 onPreExecute();</p>
<p>mWorker 和 mFuture 的关系前文已经描述了，在看一下 exec.execute(mFuture) 执行了什么：</p>
<p>exec 是 execute() 传入的，对应于 sDefaultExecutor，再查下去</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看看 SerialExecutor 这个线程池</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再仔细看一下 THREAD_POOL_EXECUTOR</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上介绍了线程和线程池部分的内容，接下来看一下在主线程和后台线程之间是如何依靠 handler 机制来传递消息的。</p>
<p>关于构造函数，由于我们开发者只能接触到 AsyncTask() 这个构造函数，所以<code>mHandler=getMainHandler()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看一下 InternalHandler 类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如，在 doInBackground() 方法中可以使用 publishProgress() 在后台更新进度，即是使用了 handler 发送消息。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，AsyncTask 的 finish()</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Compose 屏幕适配</title>
      <link>https://jixiaoyong.github.io/blog/posts/e15dda2e.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/e15dda2e.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Compose 屏幕适配</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 03 Aug 2021 03:51:32 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Compose 屏幕适配</h2>
<p>一种<strong>Compose</strong>中屏幕适配的解决方案，灵感参考<em>头条屏幕适配</em>、<em>AndroidAutoSize</em>等，以设计稿宽度和屏幕水平方法大小为准，等比拉伸控件大小。</p>
<p>后文附有本方案的 Kotlin 语言实现，使用只需要两个步骤即可：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 主要的设计思想</h2>
<p>假设如下变量：设计稿总宽度<code>dpx</code>，控件在设计稿中的大小<code>n</code>，屏幕的实际水平 dp 大小<code>rdp</code>，以及我们需要求得的控件在设备中的 dp 值<code>m</code>。</p>
<p>那么我们不难得到以下方程：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也就可以推导出：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述值中，只有屏幕水平 dp 值<code>rdp</code>还是未知的，又根据**（<code>density</code> 在每个设备上都是固定的，<code>DPI</code> / 160 = <code>density</code>，屏幕的总 px 宽度<code>wpx</code> / <code>density</code> = 屏幕的总 dp 宽度<code>rdp</code>）**可知：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以，我们可以推导出：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，等式后面的所有数据都为已知或者在 app 运行时可知，由此我们可以计算出设计稿中的控件在 Compose 中对应的 dp 大小。</p>
<p>下面是以上思路的 kotlin 实现：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考文章</h2>
<p><a href="https://github.com/JessYanCoding/AndroidAutoSize" target="_blank" rel="noopener noreferrer">AndroidAutoSize</a></p>
<p><a href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA" target="_blank" rel="noopener noreferrer">一种极低成本的 Android 屏幕适配方式</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Dagger 2 从 0 到 1 之旅</title>
      <link>https://jixiaoyong.github.io/blog/posts/2822c354.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/2822c354.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Dagger 2 从 0 到 1 之旅</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 26 Jan 2019 07:16:17 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p><code>Dagger 2</code>是 Google 维护的一款可用于<code>Java</code>和<code>Android</code>的依赖注入框架。</p>
<p>本文主要是简单梳理<code>Dagger 2</code>中各个注解的作用，以及其简单用法，不涉及具体项目应用。</p>
<p>先解释几个概念：</p>
<ul>
<li>
<p><strong><code>依赖注入</code></strong>：是一个对象（或静态方法）给另一个对象提供依赖的技术。</p>
</li>
<li>
<p>**<code>依赖</code>**是可以使用的对象（<code>Service</code>），而把依赖提供给使用该依赖的对象（<code>Client</code>）的过程叫做<code>注入</code>。</p>
</li>
</ul>
<p>例如，下面这段代码中<code>Service</code>就是<code>Client</code>的依赖。：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是如果每个依赖都这样写的话，如果<code>Service</code>类的构造方法有变更，就需要同时也更改<code>Client</code>对应的方法，这样深耦合的代码显然不是我们需要的。</p>
<p><code>Dagger 2 </code>就是为了帮助我们解决这个问题，在使用它之后，<code>Client</code>类的代码只需要这样写成类似下面这样（示例代码）：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，这时<code>Service</code>的实例化过程被移到了<code>Client</code>的外部某处，这样如果<code>Service</code>构造方法有更新时，我们只需要统一去修改<code>magicFun()</code>中对应的代码即可。</p>
<p>那么这一切<code>Dagger 2</code>到底是如何实现的呢？</p>
<h2> Dagger 2 具体实现</h2>
<h3> @Inject</h3>
<p>首先需要请出第一个主角——<strong><code>@Inject</code></strong>。</p>
<p>在<code>Dagger 2</code>中，<code>@Inject</code>主要做两件事 ❶ 标记依赖类的构造方法；❷ 标记需要框架自动实例化的对象：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样<code>Dagger 2 </code>就知道了有个对象需要它来帮助我们注入，同时也知道了有一个构造方法来实例化<code>Service</code>对象。但这时如何将二者联系起来呢？</p>
<h3> @Component</h3>
<p>这就要提到第二个主角——<strong><code>@Component</code></strong>。</p>
<p><code>@Component</code>标记的类是将一个类和他的依赖联系在一起的桥梁，通常是一个<strong>抽象类或者接口</strong>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，<code>Client</code>和<code>Service</code>通过<code>ClientComponent</code>联系在一起，在使用时只需要将<code>Client</code>的引用传入即可：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上完整的代码可以参考这里，<a href="https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8#file-dagger2_basic_guide_line_part1-kt" target="_blank" rel="noopener noreferrer">若无法显示可点击这里查看</a>：</p>
<!-- <script src="https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8.js"></script> -->
<p>到目前为止，对于我们自己定义的类，我们只需要使用<code>@Inject</code>标记其构造方法，然后再在使用该类的时候使用<code>@Inject</code>标记该对象，在需要使用该对象的地方通过<code>@Component</code>类传入使用该依赖的类的引用即可。</p>

<p>但是很显然实际开发中，不是所有的<code>Service</code>类都可以被我们随意修改，如果<code>Service</code>类是第三方提供的类，显然我们是无法用<code>@Inject</code>修饰其构造函数的。</p>
<h3> @Module 和@Provides</h3>
<p>为了解决第三方依赖的问题，我们要引入另外两个主角——<strong><code>@Module</code><strong>和</strong><code>@Provides</code></strong>。</p>
<p><code>@Provides</code>用来提供一个方法，我们可以在其内部实例化并返回<code>Service</code>类，这样子当用到<code>Service</code>的时候，<code>@Component</code>类只需要找到<code>@Provides</code>提供的这个方法，并获取到他实例化好的<code>Service</code>对象注入到<code>Client</code>中就可以了。</p>
<p><code>@Module</code>则是提供一个<strong>类</strong>（注意是类，而非接口），像一个袋子一样把<code>@Provides</code>提供的方法“装”到一起，打包提供给<code>@Component</code>类。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的<code>@Component(modules = [ClientModule::class])</code>将装有可以产生依赖的<code>@Provides</code>方法的“大袋子”<code>@Module</code>和“桥梁”<code>@Component</code>关联到了一起。</p>
<p><code>@Component</code>在产生依赖的时候会先到<code>@Module</code>类中的<code>@Provides</code>方法中查找；如果找不到才会再到<code>@Inject</code>中查找。（也就是说，此时<code>Service</code>类的<code>@Inject</code>构造方法其实是失效了的，完全可以没有<code>@Inject</code>注解——第三方类即是如此）。</p>
<p>上述完整代码如下，<a href="https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb" target="_blank" rel="noopener noreferrer">若无法显示可点击这里查看</a>：</p>
<!-- <script src="https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb.js"></script> -->
<p>解决了第三方依赖引用的问题，还有一个非常重要的问题——我们使用的绝大多数类肯定不止一个构造方法，那么假设依赖类<code>Service</code>现在有两个构造方法，我们需要分别这两个构造方法，这种情况又该怎么处理呢？</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>很明显，这时候<code>@Inject</code>注解已经没用了，一个类只能有一个构造方法被<code>@Inject</code>修饰，否则会报错：<code>错误: Types may only contain one @Inject constructor</code>。</p>
<p>去掉<code>@Inject</code>后<code>Service</code>类变成如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>尝试在<code>@Module</code>中添加另外一个<code>@Provides</code>方法使用另外一个带参构造函数：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行时发现会出错，因为有两个方法都可以提供<code>Service</code>，<code>@Component</code>产生了迷失，不知道用哪一个好，导致错误。</p>
<h3> @Named 和@Qualifier</h3>
<p>为了解决多个构造函数导致的问题，这时就需要第五个主角**<code>@Named</code><strong>以及幕后英雄</strong><code>@Qualifier</code>**</p>
<p>首先，上述问题的解决方案是在另外一个方法上加一个注解<code>@Named</code>，表示他是一个特殊的方法：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当在<code>Client</code>中想使用这个方法的依赖时：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看<code>@Named</code>源码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发现<code>@Qualifier</code>才是他实现标识限定符注解（Identifies qualifier annotations）的力量之源。查看<code>@Qualifier</code>注解可以知道，我们也可以自定义基于<code>@Qualifier</code>的注解来实现和<code>@Named</code>完全一致的功能。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后我们就可以使用<code>@YourQualifierName</code>替代<code>@Named</code>实现标识不同注解的作用，从而支持有多个构造函数的<code>Service</code>类的初始化。</p>
<p>上述完整代码如下，<a href="https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a" target="_blank" rel="noopener noreferrer">若无法显示可点击这里查看</a>：：</p>
<!-- <script src="https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a.js"></script> -->
<p><code>@Component</code>可以有多个<code>@Module</code>，他们之间的关系可以用下图表示：</p>

<h3> @Singleton 和@Scope</h3>
<p>在实际开发中，我们需要有的类只能有一个实例，从而在不同的地方共享一些数据——即单例，这种情况就需要另外一个角色<code>@Singleton</code>和他的幕后英雄<code>@Scope</code>。</p>
<p>@Singleton 是用来标记类在其范围内只能被实例化一次。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过查看其源码可以知道其背后是<code>@Scope</code>在起作用，<code>@Scope</code>的作用是限定其修饰的类的范围，适用于有可注入的构造函数并且包含控制类型实例如何重用的类。没有<code>@Scope</code>修饰的实例在构造完毕后就会失去控制，不再关心后续的发展（<em>then forgets it</em>），而<code>@Scope</code>修饰的类会在实例构造完毕后，继续保留一遍下一次可能的复用，当有多个线程可以访问该实例时，他的实现应该是线程安全的（<em>it‘s implementation should be thread safe</em>）。</p>
<p>此外<code>@Component</code>应该和他所包含的<code>@Module</code>的<code>@Provides</code>的<code>@Scope</code>范围一致：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外两个关系为**<code>dependencies</code>**的<code>@Component</code>可以分别拥有相同名称的<code>@Inject</code>、<code>@Module</code>、<code>@Provides</code>而不会被<em>merge</em>，两者可以相互访问。</p>
<p>而**<code>subcomponents</code>**则不能和<code>@Component</code>有以上相同的项。</p>
<blockquote>
<p><code>Subcomponent</code>从它的父类访问所有依赖</p>
<p><code>@Component</code>只能访问在基类<code>@Component</code>接口暴露的公共性的依赖</p>
<p>——<a href="https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/" target="_blank" rel="noopener noreferrer">Subcomponents 和 Component Dependencies——Sinyuk Blog</a></p>
</blockquote>
<p>他们之间的关系可以表示为下图：</p>

<h2> 参考资料</h2>
<p><a href="https://github.com/android-cn/blog/tree/master/java/dependency-injection" target="_blank" rel="noopener noreferrer">android-cn：依赖注入—— Github</a></p>
<p><a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener noreferrer">Dependency Injection ——wikipedia</a></p>
<p><a href="https://medium.com/@elye.project" target="_blank" rel="noopener noreferrer">Elye 的 Dagger 2 系列</a></p>
<p><a href="https://google.github.io/dagger/users-guide" target="_blank" rel="noopener noreferrer">Dagger 2 官方手册</a></p>
<p><a href="https://www.jianshu.com/p/2cd491f0da01" target="_blank" rel="noopener noreferrer">Android - Dagger2 使用详解——简书</a></p>
<p><a href="https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/" target="_blank" rel="noopener noreferrer">Subcomponents 和 Component Dependencies——Sinyuk Blog</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Dagger 2 ❤️ Android</title>
      <link>https://jixiaoyong.github.io/blog/posts/c04fdc6c.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/c04fdc6c.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Dagger 2 ❤️ Android</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 27 Jan 2019 13:23:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p><a href="http://jixiaoyong.github.io/blog/posts/2822c354/" target="_blank" rel="noopener noreferrer">上篇文章</a>介绍了<code>Dagger 2</code> 的基本使用，本文跟随<a href="https://google.github.io/dagger/android" target="_blank" rel="noopener noreferrer">官方文档</a>实践一下<code>Dagger 2 </code>在<code>Android</code>中的使用，可以看做是官方文档的不完全翻译。</p>
<p>本文有关<code>Dagger 2</code>的使用分为<code>Activity</code>和<code>Fragment</code>两部分，二者的使用几乎没有差别，最后介绍一下在 Google 官方 Demo 中学到的一个小技巧，可以将几乎所有的和<code>Dagger 2</code>的逻辑放到一份代码里面，对<code>Android</code>工程的影响极小。</p>
<p>首先要添加相关依赖（Kotlin 环境）：</p>
<div class="language-gradle line-numbers-mode" data-ext="gradle"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 在 Activity 中的使用</h2>
<h3> Application 范围内的@Component</h3>
<p>首先创建整个应用程序使用的<code>@Component</code>，并将<code>AndroidInjectionModule</code>加入其中，实现<code>Inject</code>注入入口：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>AppComponent</code>的范围是整个应用程序都有效。</p>
<h3> 创建单个 Activity 的@Subcomponent</h3>
<p>创建某个<code>Activity</code>专属的<code>@Subcomponent</code>，用于提供<code>AndroidInjector.Builder</code>。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 创建单个 Activity 的@Module</h3>
<p>创建属于整个<code>Activity</code>的<code>@Module</code>，注意这里要指明<code>@subcomponents</code>为刚刚创建的<code>MainActivitySubComponent</code>。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到在<code>MainActivityModule</code>中提供了一个方法利用刚刚<code>MainActivitySubComponent</code>中提供的<code>MainActivitySubComponent.Builder</code>实例生成了一个<code>AndroidInjector.Factory</code>，而这个<code>Factory</code>就是我们后面要将<code>MainActivityModule</code>中的依赖实例通过<code>AppComponent</code>传递给<code>MainActivity</code>实例的关键。</p>
<blockquote>
<p>此外还可以看到提供该 Factory 的方法是放到了另外一个抽象类里面然后再导入 MainActivityModule 中的，这是因为该方法的注解@Binds 要求方法是抽象的，而 MainActivityModule 要是需要给 Activity 提供依赖实例所必须的@Provides 又要求类不能是抽象的，否则就要求该方法是静态的。权衡之下我觉得这种方式是比较能接受的，当然也不排除有其他更优雅的解决方案，欢迎提<a href="https://github.com/jixiaoyong/jixiaoyong.github.io/issues" target="_blank" rel="noopener noreferrer">Issue</a>告知。</p>
</blockquote>
<p>然后，将<code>MainActivityModule</code>加入到应用程序的<code>@Component</code>——<code>AppComponent</code>中。</p>
<h3> 使 Application 继承自 <a href="https://google.github.io/dagger/api/latest/dagger/android/HasActivityInjector.html" target="_blank" rel="noopener noreferrer"><code>HasActivityInjector</code></a></h3>
<p>使当前<code>MainApplication</code>继承自<code>HasActivityInjector</code>，该接口只有一个方法：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个类是用来为相应的<code>Activity</code>提供一个<code>AndroidInjector</code>。由于我们已经在<code>AppComponent</code>中包括了<code>AndroidInjectionModule</code>，所以<code>Dagger 2</code>已经可以自动为我们注入<code>DispatchingAndroidInjector</code>依赖，所以接下来的代码如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>onCreate()</code>方法中传入当前<code>Application</code>的依赖。</p>
<h3> 在 Activity 中使用自动注入依赖</h3>
<p>做完了以上所有内容，我们只需要在<code>Activity</code>中添加如下代码就可以实现自动注入：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上所有代码如下，或者也可以<a href="https://gist.github.com/jixiaoyong/db7e5f18b7106ce9cb36b61bf7134340" target="_blank" rel="noopener noreferrer">在这里找到</a>：</p>
<!-- <script src="https://gist.github.com/jixiaoyong/db7e5f18b7106ce9cb36b61bf7134340.js"></script> -->
<h3> 这一切是怎么实现的呢？</h3>
<p>在<code>Android</code>程序运行时，<code>AndroidInjection.inject()</code>从<code>Application</code>中的<code>activityInjector()</code>方法获取到 <code>DispatchingAndroidInjector&lt;Activity&gt;</code> ，然后将<code>Activity</code>传入<code>inject(Activity)</code>。</p>
<p><code>DispatchingAndroidInjector</code> 通过<code>AppComponent</code>找到我们在<code>MainActivityModule</code>提供的对应的<code>AndroidInjector.Factory</code>，然后创建了 <code>AndroidInjector</code> ——这就是我们当前<code>Activity</code>对应的<code>MainActivitySubComponent</code>。</p>
<p>接下来便按照之前的逻辑，从<code>MainActivitySubComponent</code>中查找提供<code>waitForInjectClass</code>的实例方法完成注入。</p>
<h2> 在 Fragment 中的使用</h2>
<p><code>Dagger 2</code>在<code>Fragment</code>的使用和在<code>Activity</code>中的使用十分相似。</p>
<p>通过之前的代码我们可以知道，其基本的原理依旧是利用<code>@Component</code>和<code>@subcomponent</code>，<code>@Module</code>之间的关联关系将<code>Application</code>和<code>Activity</code>等的依赖注入通过<code>AndroidInjector</code>关联起来的：</p>
<p><code>MainActivitySubComponent</code>通过将<code>MainActivityModule</code>加入到<code>AppComponent</code>之中，然后当<code>MainActivity</code>之中需要使用到<code>MainActivitySubComponent</code>时，又通过<code>AndroidInjector</code>从<code>AppComponent</code>中拿到<code>MainActivityModule</code>中的<code>AndroidInjector.Factory</code>，通过该<code>Factory</code>和<code>MainActivitySubComponent</code>中的<code>Builder</code>产生关联，从而获取到了<code>MainActivitySubComponent</code>的实例供<code>Activity</code>使用。</p>
<p>在<code>Fragment</code>中我们也可以这样处理，只不过由于<code>Fragment</code>的特性，他的<code>@Module</code>不仅可以交给<code>Application</code>的<code>@Component</code>，也可以交给其他<code>Fragment</code>或者<code>Activity</code>的<code>@Component</code>，让其实现<code>HasFragmentInjector</code>即可，这取决于我们想要给<code>Fragment</code>绑定的依赖。</p>
<p>具体的实现一般分为下面几步：</p>
<ul>
<li>
<p>创建<code>Application</code>的<code>@Component</code>并添加<code>AndroidInjectionModule</code></p>
</li>
<li>
<p>创建实现了<code>AndroidInjector&lt;MainFragment&gt;</code>的<code>MainFragmentSubComponent</code>，其内部有方法提供<code>AndroidInjector.Builder&lt;MainFragment&gt;</code></p>
</li>
<li>
<p>创建包含了提供<code>AndroidInjector.Factory&lt;*&gt;</code>的抽象方法的<code>MainFragmentModule</code>，指定其<code>subcomponents</code>为<code>MainFragmentSubComponent</code>；</p>
</li>
<li>
<p>将<code>MainFragmentSubComponent</code>加入到想要加入的类的<code>@Component</code>中，比如<code>AppComponent</code>类</p>
</li>
<li>
<p>在<code>Application</code>（如果上一步是<code>Activity</code>，则本步也是<code>Activity</code>等）中参照在<code>Activity</code>实现的步骤实现<code>HasFragmentInjector</code></p>
<p>上述完整的代码如下，或者也可以<a href="https://gist.github.com/jixiaoyong/a24e76ca29f4c8062bf5c6a98529d252" target="_blank" rel="noopener noreferrer">在这里找到</a>：</p>
<!-- <script src="https://gist.github.com/jixiaoyong/a24e76ca29f4c8062bf5c6a98529d252.js"></script> -->
</li>
</ul>
<p>关于<code>Fragment</code>加入到<code>Activity</code>的 Demo 在官方文档有，这里就不再赘述了，其实只要掌握原理，其他用法的完全可以触类旁通。</p>
<h2> 一个小技巧</h2>
<p>通过观察上面的两份代码，我们发现虽然这<code>Dagger 2</code>已经替我们做了好多事情，我们只需要在需要使用依赖注入的类中使用诸如<code>AndroidInjection.inject(this)</code>这样的代码就可以了，但是如果<code>Activity</code>、<code>Fragment</code>类过多的时候，这样的重复性工作仍然是个不小的工作量，万一有某处遗忘了便会导致出错。</p>
<p>这时就可以用到我在<a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener noreferrer">Google 官方示例代码</a>中学到的一个小技巧了 (针对本文中的例子做了一些修改)，或者你也可以<a href="https://gist.github.com/jixiaoyong/9260c3ae2a70555e14f40c4b95364715" target="_blank" rel="noopener noreferrer">到这里查看源码</a>：</p>
<!-- <script src="https://gist.github.com/jixiaoyong/9260c3ae2a70555e14f40c4b95364715.js"></script> -->
<h2> 参考资料</h2>
<p><a href="https://google.github.io/dagger/android" target="_blank" rel="noopener noreferrer">Dagger 2 官方文档 Android 篇</a></p>
<p><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener noreferrer">Google 官方示例代码——GithubBrowserSample</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Dart event loop</title>
      <link>https://jixiaoyong.github.io/blog/posts/db62c118.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/db62c118.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Dart event loop</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 11 Jun 2022 10:25:29 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文基于 Dart 2.17</p>
</blockquote>
<br>
<p>Dart App 中所有的代码都在一个 isolate 中运行（各个 isolate 之间的代码运行时是隔离的），一个 isolate 有自己的 heap，维持有一个消息队列 event_loop，处理两种消息：</p>
<ol>
<li><code>event queue</code> 执行用户点击、屏幕刷新、绘制，一般的 Future、IO、Stream 流等，每次执行完毕都会先检查执行 micro task queue 中的任务，直到其为空再执行下一个 event queue</li>
<li><code>microTask queue</code> 优先执行，一般执行跑完即弃的小任务，如 Dart 内部的微任务</li>
</ol>
<p>上述两种 event 会在普通的 Dart 同步方法执行完毕后执行，无论是 microTask 还是普通的 event，他们都是<strong>concurrency 并行</strong>执行（也就是说实际上还是<strong>上一个执行完毕，再执行另外一个</strong>），所以如果这些 event 中存在耗时长的方法，<strong>依旧会阻塞其他方法的执行</strong>，可能导致 UI 卡顿等情况。</p>
<br>
<p>在代码执行的过程中，各种事件（如用户点击、屏幕刷新、future、microtask 等）都会被当做一个个 event 放入到 event queue 中，然后不停的从 event loop 取出事件并执行：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop.png" alt="dart_event_loop" tabindex="0" loading="lazy"><figcaption>dart_event_loop</figcaption></figure>
<p>他们的执行顺序如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop_sequeue.png" alt="dart_event_loop_sequeue" tabindex="0" loading="lazy"><figcaption>dart_event_loop_sequeue</figcaption></figure>
<p>可以从下述例子详细看一下代码执行的时候各个方法执行过程：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_test_queue_code.png" alt="dart_test_queue_code" tabindex="0" loading="lazy"><figcaption>dart_test_queue_code</figcaption></figure>
<figure><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_test_queue_output.png" alt="dart_test_queue_output" tabindex="0" loading="lazy"><figcaption>dart_test_queue_output</figcaption></figure>
<br>
<p>本文根据 Dart SDK 源码分析一下 event loop 的实现。</p>
<p>代码参考：<a href="https://gist.github.com/jixiaoyong/ac811902db42a51cf97e3290788ade4a" target="_blank" rel="noopener noreferrer">https://gist.github.com/jixiaoyong/ac811902db42a51cf97e3290788ade4a</a></p>
<h2> 1. 同步方法</h2>
<p>同步方法包括普通的方法，以及一下几种会按照同步方法立即执行的方式：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. micro task</h2>
<p>microtask 会在同步方法执行完毕之后立即被执行，一般用来执行“即抛型”的方法，不应当执行耗时方法。microtask 列表会一直执行，直到 event loop 中没有 micro task 了，才会去执行 Future 等普通的 event。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><code>Future.value([FutureOr&lt;T&gt;? value])</code> 比较特殊，如果<code>value</code> 是 future，那么他会在 value 执行完毕后返回他的值，如果<code>value</code>不是 future，他就会立即执行属于 microtask</p>
</blockquote>
<h3> 代码分析</h3>
<p>让我们看一下上述方法的具体实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，<code>Future.microtask</code>本质还是调用<code>scheduleMicrotask</code>实现的，其实现如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Zone.scheduleMicrotask()</code>最后调用的是<code>_RootZone</code>的同名方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> _RootZone._scheduleAsyncCallback</h4>
<p>这里调用了<code>_RootZone._scheduleAsyncCallback</code>方法，将传入的 callback 当做 microtask 执行。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> _RootZone._startMicrotaskLoop</h4>
<p>这里面的<code>_startMicrotaskLoop</code>方法是实际上处理 microtask 的地方：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而<code>_AsyncRun._scheduleImmediate</code>方法则是触发处理 microtask 的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> _AsyncRun._scheduleImmediate</h4>
<p><code>_AsyncRun._scheduleImmediate</code>方法的实现在<code>schedule_microtask_patch.dart</code>中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> _ScheduleImmediateClosure</h4>
<p>可以看到，microtask 实际上是使用<code>_ScheduleImmediateClosure</code>调用的，关于他主要有两个方法：</p>
<ol>
<li><code>_setScheduleImmediateClosure</code></li>
<li><code>_ensureScheduleImmediate</code></li>
</ol>
<p>让我们先看一下第一个方法<code>_setScheduleImmediateClosure</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里主要调用了 Dart 中的<code>_getIsolateScheduleImmediateClosure</code>方法创建了<code>schedule_immediate_closure</code>，然后通过<code>_setScheduleImmediateClosure</code>返回：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，这个方法会将传递进来的<code>callback</code>赋值给<code>_pendingImmediateCallback</code>。</p>
<p>而结合上面的代码，<code>_ensureScheduleImmediate</code> 方法主要也是用来触发<code>_ScheduleImmediateClosure</code>执行回调事件。</p>
<br>
<p>到目前为止，我们能确定的是：</p>
<ul>
<li>在 Dart VM 启动的时候，会创建一个<code>_ScheduleImmediateClosure</code>并保存在<code>_pendingImmediateCallback</code>;</li>
<li>当有新的 microtask 加入的时候，会触发<code>_startMicrotaskLoop</code>方法在<code>_microtaskLoop()</code>中实际处理一个 microtask（这里的<code>_startMicrotaskLoop</code>触发的实际是通过<code>_AsyncRun._scheduleImmediate(_startMicrotaskLoop)</code>将其使用<code>_pendingImmediateCallback</code> 包裹之后执行的）。</li>
</ul>
<h4> _pendingImmediateCallback</h4>
<p>现在的问题是，这个<code>_pendingImmediateCallback</code> 什么时候会被安排执行呢？</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里的关键代码，在<code>_handleMessage</code>方法中，会先执行<code>RawReceivePort</code>原本的 handler 内容，然后，执行<code>_runPendingImmediateCallback()</code>。</p>
<p>在<code>_runPendingImmediateCallback</code>则会执行<code>_pendingImmediateCallback</code>的内容，也就是前面的<code>_startMicrotaskLoop</code>，处理 event loop 中的 micro task。</p>
<br>
<p>这也就证明了我们之前说的“<strong>microtask 会在同步方法之后立即执行，并在每次普通的 event loop 执行完毕之后，都会检查并执行 event loop 中的 microtask，之后才继续执行普通 event</strong>”。</p>
<p>在下面的分析中，我们也还可以看到，在 event 每次处理 Timer 事件之后，都会检查执行 micro task。</p>
<h2> 3. event</h2>
<blockquote>
<p>除了下面列出来的使用 Future 或者 Timer 等创建的方法外，屏幕点击、刷新等事件也在此类 event 中。</p>
</blockquote>
<p>当前 event loop 中没有 micro task 之后，就会执行一次此类普通 event，然后再检查一次 event loop，如果有 micro task 就执行 micro task 直到清空 micro task，否则继续执行下一个普通 event，直到 event loop 列表为空，退出 app。</p>
<p>先看几种会触发此类事件的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以及 Timer</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 代码分析</h3>
<p>我们依次看一下上述几个方法的具体实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，除了<code>Future.wait</code>和<code>Future.any</code> <strong>这两个处理 Future 集合的方法外，<code>Future.delayed</code> 这个方法内部是实际上是</strong>通过 Timer 实现**的。</p>
<h4> Future.then</h4>
<p>在看 Timer 实现之前，先看一下<code>Futrue.then</code>的实现，他对应的实现是<code>_Future.then</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>_Futrue.then</code>只是对传入的回调的进行了包装，实际上是通过<code>_Future._addListener()</code>实现具体的逻辑：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>_Future._addListener(_FutureListener listener)</code>中基本上做了如下判断：</p>
<ul>
<li>如果 Future 是延迟完成的，就添加监听。</li>
<li>如果 Future 已经完成了，就加入到 micro task 中，安排执行 listener 回调（<code>_propagateToListeners(this, listener)</code>）。</li>
</ul>
<p>具体可以参考<a href="https://juejin.cn/post/6844904196819402759" target="_blank" rel="noopener noreferrer">Flutter 之 Future 原理解析</a>。</p>
<br>
<h3> Timer</h3>
<p>我们再看一下 Timer 的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 创建 Timer</h4>
<p>可以看到，Timer 的创建实际上是 Zone 通过两种方式创建的：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Zone 是抽象类，他的实现是<code>_RootZone</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这里实际上是调用了 Timer 中对应的私有方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>他们的具体实现在<code>timer_patch.dart</code>中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，无论是单次的还是循环的 Timer 都是使用<code>VMLibraryHooks.timerFactory</code>创建的：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终都是调用的<code>_Timer._createTimer</code>方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在创建 timer 的时候，先获取了当前的时间戳，然后计算出 timer 的唤醒时间<code>wakeupTime</code> ，最后调用<code>_Timer._internal</code>创建 timer。</p>
<p><code>_Timer._internal</code>只是简单创建了 Timer:</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在创建根据需要创建好 Timer 之后，使用<code>_Timer._enqueue</code>方法把 Timer 放入到相应的队列中。</p>
<h4> timer._enqueue</h4>
<p>主要看一下<code>timer._enqueue()</code>方法的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到无论是单次还是循环的 Timer 最后都是使用<code>_Timer._internal</code>创建的，然后再使用<code>_Timer._enqueue()</code>方法将 timer 添加到<code>heap</code>或者<code>timer list</code>中：</p>
<ul>
<li>如果 Timer 的<code>_milliSeconds</code>为 0，则会被添加到<code>_lastZeroTimer</code>中（并将上一个 timer 的_indexOrNext 指向自己），并在<code>_notifyZeroHandler()</code>方法发送_ZERO_EVENT 事件（最终会触发<code>_Timer._handleMessage</code> ）；</li>
<li>否则则将其加入到<code>_heap</code>中，如果他是第一个 timer，就通过<code>_notifyEventHandler()</code>启动处理 Timer 的 event handler（这个线程会在合适的时间唤起 Timer 执行<code>_Timer._handleMessage</code>方法）。</li>
</ul>
<p>在具体分析整个过程之前，我们先看一下几个属性的创建过程：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面代码我们可以看到：</p>
<ul>
<li><code>_sendPort</code>是<code>_receivePort</code>对应的 sendPort，后者的 handler 是<code>_handleMessage()</code>方法</li>
<li>无论是<code>_notifyEventHandler()</code>还是 <code>_notifyZeroHandler()</code>都会保证<code>_createTimerHandler()</code>被<strong>调用过</strong>。</li>
</ul>
<h5> _milliSeconds == 0</h5>
<p>先看一下<code>_milliSeconds</code>为 0 的情况：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照上面的分析，<code>_sendPort!.send(_ZERO_EVENT)</code>发送的消息，通过<code>MessageHandler::PostMessage</code>处理，最后调用<code>_receivePort</code>的 handler 也就是在<code>_handleMessage(msg)</code>方法中执行。</p>
<h5> _milliSeconds ≠ 0</h5>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见，当_milliSeconds ≠ 0 的时候，会将其加入到<code>_heap</code>中，如果当前的 timer 是<code>_heap</code>中第一个，则调用<code>_notifyEventHandler()</code>告诉 event handler<strong>在指定的时间唤起 isolate</strong>。</p>
<p>这里主要的实现是<code>VMLibraryHooks.eventHandlerSendData</code>，他的实现如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>他的实现在 native 层的<code>EventHander</code>中名为<code>event handler</code>的子线程中<strong>通过异步 IO 执行任务</strong>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不同的系统实现不同，对于 Android 来说：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后系统会在时间到了之后，会调用<code>EventHandlerImplementation::HandleEvents</code>通过<code>_send_port</code>发送消息，并触发<code>_receivePort</code>的 hander 也就是<code>_handleMessage</code>方法处理消息。</p>
<h5> _handleMessage</h5>
<p>无论是_milliSeconds == 0 的时候<code>_sendPort!.send(_ZERO_EVENT);</code>，还是_milliSeconds != 0 通过<code>EventHandler</code>发送_TIMEOUT_EVENT 消息，最终都会使用<code>_handleMessage</code>处理消息：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>_handleMessage</code>中按照 msg 的类型取出对应的<code>pendingTimers</code>然后再<code>_runTimers</code>中执行，在执行完毕或者遇到错误时，调用<code>_notifyEventHandler()</code>通知<code>event handler</code>或者关闭<code>TimerHandler</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里可以看到，这里依次遍历传入的 pendingTimers，并在每次执行完 event 后，去检查执行一下 micro task。</p>
<br>
<p>根据创建 Timer 的时候_milliSeconds 是否等于 0：会分别使用<code>MessageHandler</code><strong>执行</strong>或者在<strong>名为 event handler 的 IO 线程</strong>通过<code>isolate</code>中的<code>MessageHandler</code>来执行任务；最后都会触发 Timer 的<code>_handleMessage</code>方法在<code>_runTimers</code>方法中执行 callback。</p>
<h2> 结论</h2>
<p>综上，dart 中的方法总共有 3 种，按照优先级从前到后依次是：</p>
<ol>
<li>普通的同步方法</li>
<li>micro task</li>
<li>其他 event：部分 Future、Timer、点击事件、屏幕刷新等</li>
</ol>
<p>在方法执行的时候：</p>
<ol>
<li>先执行完毕所有的同步方法；</li>
<li>然后判断是否有 micro task，有的话就立即执行；</li>
<li>否则，就执行普通的 event，每次执行完一个 event 就执行一次步骤 2；</li>
<li>直到当前 app 中既没有 micro task 也没有普通的 event，退出 app。</li>
</ol>
<h2> 参考资料</h2>
<p><a href="https://github.com/dart-lang/sdk" target="_blank" rel="noopener noreferrer">dart sdk</a></p>
<p><a href="https://web.archive.org/web/20170704074724/https://webdev.dartlang.org/articles/performance/event-loop" target="_blank" rel="noopener noreferrer">The Event Loop and Dart</a></p>
<p><a href="https://juejin.cn/post/6844904196819402759#heading-0" target="_blank" rel="noopener noreferrer">Flutter 之 Future 原理解析 - 掘金</a></p>
<p><a href="https://juejin.cn/post/6844904196819386375" target="_blank" rel="noopener noreferrer">Flutter 之 Timer 原理解析 - 掘金</a></p>
<p><a href="https://dart.dev/" target="_blank" rel="noopener noreferrer">Dart 官网</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop.png" type="image/png"/>
    </item>
    <item>
      <title>Dart 读取文件过程分析</title>
      <link>https://jixiaoyong.github.io/blog/posts/3db5282.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/3db5282.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Dart 读取文件过程分析</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 02 Jun 2022 08:25:23 GMT</pubDate>
      <content:encoded><![CDATA[<p>Dart 读取文件时，先在 Dart 代码创建 File 引用，通过与<code>IOService</code>跨<code>Isolate</code>通信（先通过 IO Service 而发送请求到 native 端，等到 native 执行完操作之后再回调结果）从而实现对文件的读写。</p>
<p>实现一个简单的读取文件的代码如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整个过程如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/202206041125613.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 过程分析</h2>
<h3> Dart 端发起文件读写请求</h3>
<p>其中<code>file.readAsBytes()</code> 是具体执行读取文件的地方，他的定义如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们创建<code>File</code>时，实际上创建的是<code>_File</code> （<code>class _File extends FileSystemEntity implements File</code>）对象：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>_File</code> 是<code>File</code> 的实现类，所以<code>file.readAsBytes()</code>实际调用的是<code>_File</code> 实现的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，无论是普通的文件格式，还是 character device，最后都是调用了<code>_RandomAccessFile</code>的<code>open()</code>和<code>read(int bytes)</code>方法异步读取文件。</p>
<blockquote>
<p>设备文件分为 Block Device Driver 和 Character Device Drive 两类。<br>
Character Device Driver 又被称为字符设备或裸设备 raw devices; Block Device Driver 通常成为块设备。<br>
而 Block Device Driver 是以固定大小长度来传送转移资料；Character Device Driver 是以不定长度的字元传送资料。 <a href="https://www.cnblogs.com/qlee/archive/2011/07/27/2118406.html#:~:text=Character" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/qlee/archive/2011/07/27/2118406.html#:~:text=Character</a></p>
</blockquote>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>_RandomAccessFile</code>中，除了同步读写文件是对返回的文件引用直接操作外，很多操作都能看到通过<code>_dispatch()</code>方法与<code>IO Service</code>通信，让我们看一下这个方法的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查阅<a href="https://github.com/dart-lang/sdk/blob/main/sdk/lib/io/io_service.dart" target="_blank" rel="noopener noreferrer">_IOService</a>的源码后发现这是个<code>external</code> 方法。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>An <code>external</code> function is connected to its body by an implementation-specific mechanism. Attempting to invoke an external function that has not been connected to its body will throw a NoSuchMethodError or some subclass thereof.<br>
****<a href="https://github.com/dart-lang/sdk/issues/4300" target="_blank" rel="noopener noreferrer">https://github.com/dart-lang/sdk/issues/4300</a></p>
</blockquote>
<p>根据<code>external</code>的定义，<code>_dispatch</code>方法在不同的机器上面实现不同。我们只看和 app 相关的实现（在<code>sdk\lib\_internal\vm</code>目录下，vm 同级目录还有 js 等实现），具体的实现如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，最后是通过<code>RawReceivePort</code>/<code>SendPort</code>进行<strong>跨 Isolate 通信</strong>。</p>
<p><code>_IOService</code>使用<code>_servicePorts</code>对 native 层发送消息触发 IO 操作，然后使用<code>_receivePort</code>监听，当 IO 操作完成时会通过<code>_replyToPort</code> 回调结果，会在 <code>_receivePort!.handler</code>方法中根据当时请求的<code>id</code>找到<code>Completer</code>将结果传递回去。</p>
<p>这样当时我们在 <code>file.readAsBytes()</code>时获取到的<code>Future</code>便会收到回调，从而完成文件操作的流程。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是到目前为止涉及到的类关系示意图：</p>
<figure><img src="https://jixiaoyong.github.io/images//202206041127617.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> IO Service 中转</h3>
<p>那么，这个 IO Service 是做什么的，他又是如何实现与 dart 中的调用方双向通信，以及执行调用方需要的功能呢？</p>
<p>位于<code>sdk\lib\_internal\vm\bin\io_service_patch.dart</code>的_IOService 是一个中转站，<strong>向上承接</strong>来自 Dart 代码的 IO 请求指令（先行返回 Future），<strong>向下将这些指令转发</strong>至 Native 层的 IO Service，并<strong>监听回调</strong>，当 native 层处理完这些 IO 指令之后，将结果通过 Future 返回给 Dart 调用方。</p>
<p>让我们再看一下他的具体实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到：</p>
<ul>
<li><code>_IOService</code>持有<code>_IOServicePorts _servicePorts</code>以便获取<code>SendPort servicePort</code>和 native 层通信，</li>
<li>在之前的代码分析中，我们已经知道<code>_IOService</code>还在<code>_ensureInitialize()</code>中监听着<code>RawReceivePort? _receivePort</code>的回调，</li>
<li>这样当<code>_IOService</code>在<code>_dispatch()</code>方法中将<code>_replyToPort</code>（<code>_receivePort</code>的 SendPort）传递给<code>servicePort</code>后，一旦 native 通过<code>_replyToPort</code>发送处理结果，<code>_IOService</code>立马可以收到并通过<code>Completer.complete</code>返回给<strong>Dart 中的调用方</strong>。</li>
</ul>
<aside>
💡 注意这里的`SendPort **servicePort`** ，他是从 native 层的`_IOService` 获取到的：
1. 在 native 层通过`PortMap::CreatePort(MessageHandler* handler)`创建好此`Dart_Port port` 
2. `MessageHandler` 在创建`Dart_Port port`的时候就与之关联
3. 在 Dart 层的`_IOService` 这里监听
这样，当 native 层的`MessageHandler`执行指令之后，会将`Dart_Port port`传递给`IOServiceCallback`，后者将他和自身执行结果一并打包为 native 层的 Message 压入`MessageHandler`的`消息 queue`中，然后由消息分发系统按照发送到 Dart 这里，按照`SendPort **servicePort`** 找到要执行的代码。
</aside>
<p>上述这些步骤能够实施的关键，在于<strong>Dart</strong>层的<code>_IOService</code>如何与<strong>native</strong>层的<code>_IOService</code>关联起来呢？</p>
<p>让我们来分析一下<code>SendPort servicePort</code>的获取过程：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这里最后的关键方法是<code>SendPort _newServicePort()</code>，这是一个<code>external</code>方法，在 native 实现。</p>
<h3> Native 处理 Dart 的指令</h3>
<h4> IOService_NewServicePort</h4>
<p><code>SendPort</code>是由<code>_newServicePort()</code>方法创建的，这是一个<code>external</code>方法，他的 native 层实现名称是<code>IOService_NewServicePort</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，在 Dart 层的<code>_IOService</code>的<code>SendPort _newServicePort()</code> 方法最后再这里调用了<code>IOService_NewServicePort</code>。</p>
<p>这里主要有 3 个步骤：</p>
<ol>
<li>使用<code>Dart_NewNativePort("IOService", IOServiceCallback, true);</code>创建<code>Dart_Port</code></li>
<li>使用<code>Dart_NewSendPort</code>将<code>Dart_Port</code>转化为<code>Dart_Handle</code>（也就是 Dart 中的<code>SendPort</code>）</li>
<li>返回上面创建好的<code>Dart_Handle</code>，Dart 代码拿到返回的 Dart_Handle 也就是<code>SendPort servicePort</code>之后，就可以和 native 层的 IO Service 同通信。</li>
</ol>
<p>接下来我们看一下前 2 步分别是怎么实现的：</p>
<h4> Dart_NewNativePort</h4>
<p>再看一下<code>Dart_NewNativePort</code>的调用参数：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>IOServiceCallback</strong></p>
<p><code>Dart_NewNativePort</code>总共有 3 个参数，<code>Dart_NativeMessageHandler handler</code>是当这个<code>Dart_Port</code>收到消息的时候，会被回调的方法，也就是我们通过 Dart 端的<code>_IOService.dispatch</code>方法的**<code>servicePort**.send(&lt;dynamic&gt;[id, **_replyToPort**, request, data]);</code>语句执行向 native 发送 IO 指令时，在 native 这里真正负责执行的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>IOService 具体的执行是在<code>IO_SERVICE_REQUEST_LIST</code>根据解析到的参数执行对应的方法：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上述代码，可以得知，IOService 主要处理的方法有四类：</p>
<ul>
<li><code>File</code></li>
<li><code>Directory</code></li>
<li><code>Socket</code></li>
<li><code>SSLFilter</code></li>
</ul>
<p>在<code>IOServiceCallback</code>方法中，我们注意到，程序最后执行的结果是通过<code>Dart_PostCObject</code>返回的，来看一下他是怎么实现的：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码最后将结果包装成了 Message 打包进<code>MessageHandler</code>的<strong>消息队列</strong>中，这样便可以在 Dart 端通过消息分发接收到结果。</p>
<p><strong>Dart_NewNativePort</strong></p>
<p>再来看一下<code>Dart_NewNativePort</code>的实现如下：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要的流程有：</p>
<ol>
<li>切换退出当前 isolate</li>
<li>创建<code>NativeMessageHandler nmh</code>包裹要处理的回调</li>
<li>根据上面创建的<code>nmh</code>创建<code>Dart_Port port_id</code></li>
<li>执行**<code>nmh-&gt;Run()</code>**方法将<code>nmh</code>放到线程池中运行</li>
<li>当<code>nmh</code>执行完毕回调后，关闭<code>Dart_Port port_id</code></li>
</ol>
<p>也就是说，在 Dart 中向 Native 发送指令时，通过 Dart 的<code>_IOService._dispatch()</code>方法中执行<code>_servicePorts._getPort(id);</code>向 Native 层的 IOService 获取用于通信的<code>SendPort servicePort</code>时，会先通过 Dart_NewNativePort 创建一个<strong>NativeMessageHandler</strong>（会压入消息栈中），然后创建一个对应的<code>Dart_Port port_id</code>并返回给 Dart 用来触发消息。</p>
<p>让我们挨个分析一下：</p>
<p>1.退出当前 isolate</p>
<p>见 <a href="https://www.notion.so/IsolateLeaveScope-d62547a99c6d464bbd1bbf5baa45de18" target="_blank" rel="noopener noreferrer">IsolateLeaveScope</a></p>
<p>2.创建<code>NativeMessageHandler nmh</code>包裹要处理的回调</p>
<p>3.根据上面创建的<code>nmh</code>创建<code>Dart_Port port_id</code></p>
<p>看一下<code>PortMap::CreatePort</code>的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.执行**<code>nmh-&gt;Run()</code>**方法将<code>nmh</code>放到线程池中运行</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在创建了新的系统线程后，会执行下面的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Dart_NewSendPort</h4>
<p>看一下<code>Dart_NewSendPort</code>如何将创建好的<code>Dart_Port service_port</code>转变为 Dart 的<code>SendPort</code>的：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里我们发现，<code>Dart_NewNativePort</code>将要处理的事件<code>handler</code>封装起来，最后在<strong>非当前 isolate</strong>的线程中执行。</p>
<h2> 结论</h2>
<p>从上面的分析中，我们可以知道，在 Dart 中通过 File 进行文件操作，其实是通过 Dart 中的_IOService 进行消息中转，将用户的 IO 指令发送到 Native 层的 IOService 中；</p>
<p>IOService 通过一些列操作，得到一个<code>SendPort servicePort</code>，与此同时对应的 IO 操作已经压入消息栈中等待触发在单独的线程中执行；</p>
<p>之后在_IOService 中<code>servicePort</code>将用户需要的 IO 操作和与自己通信的<code>_replyToPort = _receivePort!.sendPort;</code> 通过<code>send</code>方法触发<code>IOServiceCallback</code>执行对应的 IO 操作，并且在最后调用<code>Dart_PostCObject</code>方法将结果压入消息栈中，这会触发 Dart 层_IOService 的_receivePort!.handler 回调事件，然后根据事件失败或者成功，使用 Completer 通过 Event loop 一步步将事件上报，最终回调用户需要的命令。</p>
<h2> 参考资料</h2>
<p><a href="https://blog.csdn.net/eieihihi/article/details/119601010" target="_blank" rel="noopener noreferrer">09、Flutter FFI Dart Native API_又吹风_Bassy 的博客-CSDN 博客</a></p>
<p><a href="http://w4lle.com/2021/04/12/kidea-flutter/index.html" target="_blank" rel="noopener noreferrer">快手 - 开眼快创 Flutter 实践 | w4lle's Notes</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/202206041125613.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter APP 绘制过程简析</title>
      <link>https://jixiaoyong.github.io/blog/posts/4cbcfe72.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/4cbcfe72.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter APP 绘制过程简析</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 25 Jun 2022 01:03:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文基于 Flutter 3.0</p>
</blockquote>
<p>Flutter App 基于 Dart 语言编写，提供了一套简单易用的 API，可以让开发者在 Flutter 中快速开发出一个精美的 APP。那么在 Flutter 中是如何绘制一个 APP 呢，runApp 是怎么将我们编写的 Widget 等添加到手机上的呢？本文简单从 Widget,Element,RenderObjet 三者的关系来梳理一下 Flutter 的绘制过程。</p>
<p>让我们运行一个“最”简单的 Flutter App，分析一下在这个过程中涉及到的 Widget、Element、RenderObject 这三个 tree 的关系。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的效果如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_hello_center_text.png" alt="flutter_run_app_hello_center_text" tabindex="0" loading="lazy"><figcaption>flutter_run_app_hello_center_text</figcaption></figure>
<p>让我们使用 Flutter DevTools 看一下实际生成的 Widget Details Tree</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，除了我们在代码里面添加的 Center 和 Text 这两个 Widget 之外，还多出来好几个 Widget/RenderObject，当我们仔细查看具体的 Widget，可以看到其内部还有 XXXElement，BuildOwner 之类的字段：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述涉及到的几个类彼此之间到底是什么关系，我们的“<code>Hello center text!</code>”又是怎样才显示到屏幕上的，让我们接下来一个一个分析一下：</p>
<h2> runApp</h2>
<p>在执行 runApp 的时候主要执行了三步</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> WidgetsFlutterBinding.ensureInitialized()</h3>
<p>创建 RenderView 具体的逻辑在<code>WidgetsFlutterBinding.ensureInitialized</code>方法中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>ensureInitialized</code>方法中，如果<code>WidgetsBinding._instance</code>为 null 则会先用构造方法创建，因为<code>WidgetsFlutterBinding</code>继承自 BindingBase，所以实际上执行下方的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里主要做了 2 件事，我们关注<code>initInstances()</code>方法，这个方法的主要逻辑都在他的子类中，也就是之前<code>WidgetsFlutterBinding</code>混合的几个 BindingBase 子类中，我们关注和屏幕渲染有关的 RendererBinding：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们主要关注两件事：</p>
<ul>
<li>
<p>创建了用于管理渲染管道的 PipelineOwner <code>_pipelineOwner</code></p>
<p>Pipeline 是用来管理 rendering tree，其内部持有我们的 renderView 作为 rootNode，同时维护了_nodesNeedingLayout，_nodesNeedingCompositingBitsUpdate，_nodesNeedingPaint，_nodesNeedingSemantics 四个列表，当 flutter framework 每次需要往屏幕上绘制内容时会依次遍历这四个列表，将 RenderObject 绘制到屏幕上面。</p>
</li>
<li>
<p>创建了 rendering tree 的根节点<code>renderView</code> ，并将其设置为<code>_pipelineOwner</code>的根节点</p>
</li>
</ul>
<h3> ..scheduleAttachRootWidget(app)</h3>
<p>此方法是<code>WidgetsFlutterBinding</code>的另外一个混合类<code>WidgetsBinding</code>负责具体实现：</p>
<p><code>WidgetsBinding</code>的<code>scheduleAttachRootWidget</code> 方法最后调用了<code>attachRootWidget(Widget rootWidget)</code> ：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里主要有 3 步：</p>
<ul>
<li>创建 RenderObjectToWidgetAdapter 包装 RenderView</li>
<li>在<code>attachToRenderTree</code>方法中创建 RenderObjectToWidgetElement 并<code>mount</code>到 element tree 中（widget tree 实际上并不存在，而是通过 element tree 管理）</li>
<li>需要的话安排一次 frame（刷新页面）</li>
</ul>
<p>还需要注意一个新的角色<code>buildOwner</code>，这个对象全局唯一（一般由 parent 传给 child），在<code>WidgetsBinding.initInstances</code>方法创建，用来管理与 Widget tree 相关的类，实际上就是通过管理 Element 的插入，移除，更新来间接管理 Widget tree（对应我们在之前遇到的用来管理 rendering tree 的<code>pipelineOwner</code> ，这两个 Owner 管理着我们所说的 Flutter 的 Widget/Element/RenderObject“三”个 tree）。</p>
<h4> RenderObjectToWidgetAdapter</h4>
<p>前面我们知道<code>renderView</code>其实是一个 RenderObject，所以这里为他创建了一个对应的 Widget——<code>RenderObjectToWidgetAdapter</code>，其主要作用是将<code>rootWidget</code>（也就是我们最开始写的 Center Widget 及其 child）绑定到之前生成的<code>renderView</code>上面，并将<code>renderView</code>作为自己对应的 RenderObject。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>RenderObjectToWidgetAdapter.createRenderObject</code> 返回的就是<code>container</code> 也就是我们的 RenderView。</p>
<h4> attachToRenderTree</h4>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>RenderObjectToWidgetAdapter</code>在<code>attachToRenderTree</code> 方法中，创建对应的<code>RenderObjectToWidgetElement</code> 与自己绑定，并且同时也将<code>rootWidget</code>和之前创建的 rendering tree 的根节点<code>renderView</code>绑定。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们再来看一下<code>RenderObjectToWidgetElement</code>调用的父类<code>RenderObjectElement.mount</code>方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，还会调用的<code>Element.mount</code>方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，这里将<code>RenderObjectToWidgetElement</code> 注册到了 BuildOwner 中</p>
<p>在<code>RenderObjectToWidgetElement</code>的<code>mount</code>方法执行时，除了调用父类的<code>mount</code>方法外，还会触发<code>_rebuild()</code> 方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>_rebuild</code>方法中，我们可以看到，在<code>WidgetsBinding.attachRootWidget</code>方法中给 RenderObjectToWidgetAdapter 作为<code>child</code>参数传入的<code>rootWidget</code>（也即我们示例中的<code>Center</code>Widget），在这里被传入了 RenderView 对应的 RenderObjectToWidgetElement 的<code>child</code>中（这里的过程我们下面 Center 一节再分析），从而将其插入到 Flutter 的渲染树中。</p>
<p>这样 RenderView（<code>RenderObject</code>）就有了对应的<code>Widget</code>和<code>Element</code>，并且有了自己的<code>child</code>。</p>
<h3> ..scheduleWarmUpFrame()</h3>
<p>这个方法则是尽快安排一个 frame 以便在屏幕下次刷新的时候显示 app 的内容（在 app 启动之后的第一次！！！），这样我们的 app 启动了，我们写的内容也能正常显示到屏幕上。</p>
<p>通过上述分析，我们可以得知，runApp 方法执行之后，创建了<code>RenderView</code>对象，并将其作为整个 Flutter APP 的 RenderObject rendering tree 的根节点（后续所有的 Widget 创建的 RenderObject 都是在 RenderView 的下层），并且初始化它以便在下一帧的时候对其进行渲染。</p>
<br>
<p>分析完了<code>runApp</code>，我们再来看一下刚刚提到的几个类，以及他们是如何添加到我们的 flutter app 中的。</p>
<h2> RenderView</h2>
<p>先看一下在最顶层的<a href="https://github.com/flutter/flutter/blob/a0248ebdf20d2befe29cdf325dc7331826151dab/packages/flutter/lib/src/rendering/view.dart#L63" target="_blank" rel="noopener noreferrer">RenderView</a>：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查阅源码可知，RenderView 是 RenderObject，一般情况下是 Flutter 的根 View，表示整个 rendering tree 的 output surface，处理引导着 render pipeline。</p>
<p>RenderView 有且仅有一个 RenderBox 类型的<code>child</code>，他会强制将<code>child</code>的<code>size</code>改为 RenderView 初始化时候的入参<code>configuration</code>的值（一般是当前<code>window</code>也就是<strong>手机屏幕</strong>的逻辑像素<code>size</code>）。</p>
<h2> Center</h2>
<p>上节我们说道，Center Widget 通过<code>RenderObjectToWidgetElement.updateChild</code>（最终调用 Element 同名方法）方法插入到渲染树中，下面我们详细分析一下这个过程：</p>
<p>在<code>updateChild</code>中，因为<code>child==null</code>，而<code>newWidget</code>也就是 Center 不为<code>null</code>，所以直接使用<code>inflateWidget(newWidget, newSlot)</code>创建新的 Element 并作为 RenderObjectToWidgetElement 的<code>_child</code>，而作为第一次创建的 Center，在<code>Element.inflateWidget</code>方法中大概会执行下面几步：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是这里先执行了<code>Center.createElement</code>方法创建 Element，然后调用此<code>Element.mount</code>方法将 Element 添加到 Element tree。</p>
<p>让我们再看一下 Center 的 Widget Details Tree：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 Center 的<code>_parent</code>和<code>_ancestorRenderObjectElement</code>是 RenderObjectToWidgetElement，<code>_depth</code>是 2，这个和我们最初的分析一致，因为 Center（其实严格来说，是 Center Widget 的（或子级的）RenderObject）是 RenderView 的<code>child</code>。</p>
<p>我们接下来主要关注一下几个属性：</p>
<ul>
<li><code>alignment</code>: Alignment.center</li>
<li><code>renderObject</code>: RenderPositionedBox</li>
<li><code>_widget</code>: Center</li>
<li><code>_child</code>: StatelessElement</li>
</ul>
<p>先看一下 Center 的源码：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Center 代码十分简单，主要的逻辑在他的父类 Align 中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Align 其实是一个<code>SingleChildRenderObjectWidget</code> ,对应的 Element 是<code>SingleChildRenderObjectElement</code>，他创建的 RenderObject 是<code>RenderPositionedBox</code> 。</p>
<p><code>SingleChildRenderObjectElement</code> 是一个<code>RenderObjectElement</code> 也就意味着他在 rendering tree 有一个关联的 RenderObject 负责 layout，painting 以及 hit-test。</p>
<p>回到我们的 Center Widget 中：</p>
<h3> <strong>alignment: Alignment.center</strong></h3>
<p><strong>Alignment.center</strong>是在创建 Center 的时候默认设置的对齐方式</p>
<h3> <strong>renderObject: RenderPositionedBox</strong></h3>
<p><strong>RenderPositionedBox</strong>是 Center Widget 对应的 RenderObject，在<code>SingleChildRenderObjectWidget.mount</code> 的时候创建。其本身并不在屏幕上绘制肉眼可见的内容，而是将 child 按照指定的对齐方式进行定位。</p>
<p><code>RenderPositionedBox</code> 的继承关系：<code>RenderPositionedBox</code> → <code>RenderAligningShiftedBox</code> → <code>RenderShiftedBox</code> → <code>RenderBox</code> → <code>RenderObject</code></p>
<p><strong>RenderPositionedBox</strong>可以按照给定的<code>AlignmentGeometry</code>定位 child。在本例中，他的几个属性如下：</p>
<ul>
<li><code>alignment</code>: Alignment.center</li>
<li><code>_owner</code>: PipelineOwner</li>
<li><code>_parent</code>: RenderView</li>
<li><code>_child</code>: RenderParagraph</li>
</ul>
<p>前三个属性含义很明显，这里我们注意到他的<code>_child</code>并不是我们预期的<code>Text</code>，这个原因我们后面再分析。</p>
<h3> <strong>_widget: Center</strong></h3>
<p>其实通过上述的分析，我们应该已经知道，我们在 Widget Details Tree 中看到的 Center 其实是 Center Widget 对应的 Element，也就是<code>SingleChildRenderObjectElement</code> 。</p>
<p>其继承关系：<code>SingleChildRenderObjectElement</code> → <code>RenderObjectElement</code> → <code>Element</code></p>
<p>根据 Element 的定义，这里的 Widget 是在 Widget 创建<code>SingleChildRenderObjectElement</code>的时候传入的：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后这个 Element 在上述<code>WidgetsBinding.attachRootWidget</code>步骤中通过一系列操作，最终在 RenderObjectToWidgetElement 的<code>updateChild</code>方法被创建并被<code>BuildOwner</code> 插入到 tree 中。</p>
<p>这里的<code>_widget</code>才真正对应着我们在<code>runApp</code>里面传入的 Center Widget，他的<code>child</code>也正是我们的 Text。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <strong>_child: StatelessElement</strong></h3>
<p>Center 对应的 Element 的<code>_child</code>是一个 StatelessElement，按照我们上一步的分析，StatelessElement 应该是 Text Widget 创建，事实也确实如此：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们分析一下这个<code>_child</code>的赋值过程：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Center 对应的 Element——<code>SingleChildRenderObjectElement</code> 在<code>mount</code>的时候，同时也会更新<code>child</code>（本例中 Center 的<code>child</code>是 Text），这里调用的是 Element 的<code>updateChild</code>方法，他的逻辑如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>updateChild</code>的逻辑分为 4 种情况：其余情况都比较简单，只有<code>newWidget != null</code>或者<code>child != null</code>的时候需要判断一下，如果可以更新就更新否则就创建新的 Element，可以分为下面这几种情况：</p>
<ul>
<li><code>child.widget == newWidget</code>：两个是同一个对象，就只更新<code>child</code>的<code>slot</code></li>
<li><code>Widget.canUpdate(child.widget, newWidget)</code>：二者的<code>runtimeType</code>和<code>key</code>一样，就调用<code>child.update(newWidget)</code>更新<code>child._widget</code>，必要时更新<code>child</code>的<code>slot</code></li>
<li>否则创建新的<code>element</code>并替代</li>
</ul>
<p>到这里跟 Center 插入到 render tree 的步骤一样，将 Text 插入到了 tree 中。</p>
<h2> Text</h2>
<p>接下来我们分析一下 Text 是如何被加入 Widget Details Tree 的。</p>
<p>其继承关系：<code>Text</code> → <code>StatelessWidget</code> → <code>Widget</code></p>
<p>Text 是 StatelessWidget，他的内容比较简单，主要的逻辑都在<code>build</code>方法中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样，作为 StatelessWidget，他也创建了一个<code>StatelessElement</code> ：</p>
<p>其继承关系：<code>StatelessElement</code> → <code>ComponentElement</code> → <code>Element</code></p>
<p>按照之前的分析，Text 插入到 tree 中执行的方法分别是<code>Text.createElement</code>和 Text 对应的 Element——<code>StatelessElement.mount</code>方法：</p>
<p>Text 是 StatelessWidget 的子类，他的主要逻辑都在 StatelessWidget：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到其<code>createElement</code>创建的是 StatelessElement，也就是说 Text 插入到 Center 过程主要在 StatelessElement 中。</p>
<p><code>StatelessElement.mount</code>方法主要逻辑在 ComponentElement 中，这个方法除了调用 Element 同名方法外，还调用了<code>ComponentElement._firstBuild()</code> → <code>Element.rebuild()</code> → <code>ComponentElement.performRebuild()</code> ：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的主要有两个步骤：</p>
<ul>
<li>调用<code>ComponentElement.build</code>方法，生产 Widget（本例中，间接调用了 Text 的<code>build</code>方法）</li>
<li>调用<code>ComponentElement.updateChild</code>方法，更新<code>child</code>（最终执行的是 Element 同名方法逻辑）</li>
</ul>
<p>到目前为止，我们的 Widget/Element/RenderObject tree 如下（第四级 RichText 下面再分析）：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不难看出，在从定往下数第三层也就是 Text 对应的这一级中，RenderObject tree 这里并没有对应的对象，在上面的分析中，我们也看到了 StatelessWidget 本身并没有创建 RenderObject 的方法。实际上，Widget 分为多个种类，只有 RenderObject 类及其子类才会创建 RenderObject：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter_run_app/heritance_of_widget.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure>
<h3> RichText</h3>
<p>终于到了我们这个 app 真正在屏幕上显示的内容这里了，上面我们分析到，Text 作为 StatelessWidget，本身并不会产生可以在屏幕上绘制的 RenderObject，而是通过他的<code>build</code>方法返回一个可以产生 RenderObject 的 Widget，在本例中，这个 Widget 就是 RichText：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RichText 继承自<code>MultiChildRenderObjectWidget</code> ，如上节分析的，是一种<code>RenderObjectWidget</code>，它创建了真正在屏幕上渲染的 RenderObject——<code>RenderParagraph</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面说道，Text 本身作为 StatelessWidget 并不产生 RenderObject，那么这里的 RenderParagraph 是如何找到并插入到 rendering tree 中的呢？</p>
<p>带着这个疑问，我们看一下<code>MultiChildRenderObjectWidget</code> 创建的<code>MultiChildRenderObjectElement</code> ：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里可以看到，在 MultiChildRenderObjectElement 的<code>mount</code>方法中：</p>
<ul>
<li>调用父类<code>mount</code>方法</li>
<li>遍历了所有的<code>children</code>将其插入到 MultiChildRenderObjectElement 中。</li>
</ul>
<p>在前面的 Text 源码中，我们注意到给只给<code>RichText.text</code>赋值了，RichText 的<code>textSpan</code>和<code>children</code>都是<code>null</code>，所以后面对<code>children</code>的处理在本例中不涉及，让我们看一下<code>super.mount(parent, newSlot)</code>方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里主要有 2 步：</p>
<ul>
<li>通过<code>widget.createRenderObject</code> 创建<code>_renderObject</code>，本例中就是用 RichText 创建了 RenderParagraph</li>
<li>调用<code>RenderObjectElement.attachRenderObject</code>方法将<code>_renderObject</code>插入到 rendering tree</li>
</ul>
<p>让我们看一下 attachRenderObject 的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在<code>attachRenderObject</code>方法中插入的方式很简单：先在当前 tree 中向上找到父级中离得最近的 RenderObjectElement，在本例中是 Center 这个 Widget 对应的 SingleChildRenderObjectElement（注意不是创建 RichText 的 Text），然后调用其<code>insertRenderObjectChild</code>方法将当前的 RenderParagraph 插入到 rendering tree 中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 SingleChildRenderObjectElement 的<code>insertRenderObjectChild</code>方法中先是查找当前 Element 持有的<code>renderObject</code>,然后将我们传入的 RichText 的 RenderObject——RenderParagraph 赋值给<code>renderObject.child</code>。</p>
<p>到这里，我们的所有 Widget 在 Element 的组织下，将对于的 RenderObject 添加到 Rendering Tree 中，他们的关系如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，当屏幕刷新的时候，这些内容便绘制在屏幕上面。</p>
<h2> 总结</h2>
<p>在<code>runApp</code>方法中，WidgetsFlutterBinding 作为将 flutter framework 绑定到 flutter engine 的粘合剂：</p>
<ul>
<li>
<p>在<code>ensureInitialized</code>方法中创建了<code>_pipelineOwner</code>（管理 rendering tree）、<code>renderView</code>和<code>buildOwner</code>（通过管理 Element tree 间接管理 widget tree），并将<code>renderView</code>设置为<code>_pipelineOwner</code>的根节点。</p>
</li>
<li>
<p>在<code>scheduleAttachRootWidget</code>方法中，为<code>renderView</code>创建并绑定了对应的 Widget（RenderObjectToWidgetAdapter）和 Element（RenderObjectToWidgetElement）。然后通过<code>RenderObjectToWidgetElement.mount</code>方法，将之前创建的<code>buildOwner</code>与自己绑定。</p>
<p>并且将我们在<code>runApp</code>传入的 Widget<code>rootWidget</code>（也就是本例中的 Center Widget）对应的 Element 添加为 RenderObjectToWidgetElement 的子节点。并依此将 Text、Text 内部的 RichText 等对应的 Element 都加入到 Element tree 中，直到遍历完整个 Widget tree。</p>
</li>
<li>
<p>在<code>scheduleWarmUpFrame</code>方法中安排在下一次屏幕刷新的时候将我们的内容展示在屏幕上面。</p>
</li>
</ul>
<p>下面是我们这个“最”简单的 Flutter App 的结构示意：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_widget_elelemt_renderobject_tree.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 参考资料</h2>
<p><a href="https://api.flutter.dev/" target="_blank" rel="noopener noreferrer">Flutter - Dart API docs</a></p>
<p><a href="https://www.youtube.com/watch?v=PnWxW21vDak" target="_blank" rel="noopener noreferrer">Flutter, what are Widgets, RenderObjects and Elements? - Norbert Kozsir | Flutter Europe</a></p>
<p><a href="https://www.youtube.com/watch?v=FU2Eeizo95o&amp;ab_channel=RetroPortalStudio" target="_blank" rel="noopener noreferrer">Flutter Widgets Explained | Understand How Flutter Works!</a></p>
<p><a href="http://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/" target="_blank" rel="noopener noreferrer">深入浅出 Flutter Framework 之 PipelineOwner</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_hello_center_text.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter UI 绘制与 InheritedWidget 解析</title>
      <link>https://jixiaoyong.github.io/blog/posts/4c220635.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/4c220635.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter UI 绘制与 InheritedWidget 解析</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 15 May 2022 11:02:13 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Flutter UI 绘制与 InheritedWidget 解析</h2>
<p>Flutter 的<code>Widget</code>分为<code>StatefulWidget</code>和<code>StatelessWidget</code> ，二者都继承自<code>Widget</code>。</p>
<p>此外还有一种用来传输数据的<code>Widget</code>——<code>InheritedWidget</code>，与上述两者不太一样的是，他的继承关系是：<code>InheritedWidget</code>→<code>ProxyWidget</code> →<code>Widget</code> 。</p>
<p>Flutter 的渲染流程如图：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter_widget_element_renderobject_relationship.png" alt="flutter_widget_element_renderobject_relationship" tabindex="0" loading="lazy"><figcaption>flutter_widget_element_renderobject_relationship</figcaption></figure>
<p>可以简单理解为， <code>Widget</code>是配置信息，<code>Element</code>代表在树中详细的位置，而<code>RenderObject</code>则是实际渲染的对象。</p>
<p><code>StatelessWidget</code>和<code>StatefulWidget</code>在创建之后就不会再变化，而<code>StatefulWidget</code>因为有<code>State</code>，所以可以在<code>State</code>调用<code>setState()</code>方法之后，重新执行<code>State</code>的<code>build()</code>方法，从而更新界面。</p>
<p>如果<code>Widget</code>是<code>const</code>的，那么他就不会被<code>rebuild</code>。</p>
<h2> Widget Rebuild 的过程</h2>
<p>以 StatefulWidget 为例：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter_render_flow_chart.png" alt="flutter_render_flow_chart" tabindex="0" loading="lazy"><figcaption>flutter_render_flow_chart</figcaption></figure>
<ol>
<li>
<p>调用<code>setState()</code>方法，会调用对应的<code>Element</code>的<code>markNeedsBuild()</code> 方法，通过<code>BuildOwner</code>的<code>scheduleBuildFor(Element element)</code> 方法将当前<code>Element</code>标记为<code>dirty</code>，以便在下次屏幕刷新时安排<code>rebuilt</code> 。</p>
</li>
<li>
<p>下一帧屏幕刷新，调用<code>BuildOwner</code>的<code>buildScope(Element context, [ VoidCallback? callback ])</code> 方法。这个方法会遍历<code>_dirtyElements</code> 中所有<code>dirty</code>的<code>element</code>执行<code>element.rebuild();</code> 方法，在其内部调用了<code>Element</code>的<code>performRebuild()</code> 方法。</p>
</li>
<li>
<p><code>Element</code>的<code>performRebuild()</code> 方法因各个<code>Element</code>的实现而异：</p>
<ol>
<li>
<p><code>StatelessElement</code> 、<code>InheritedElement</code>：与父类<code>ComponentElement</code> 保持一致</p>
</li>
<li>
<p><code>StatefulElement</code> ：判断有需要时调用<code>state.didChangeDependencies();</code> ，其余与父类<code>ComponentElement</code> 保持一致</p>
</li>
</ol>
</li>
</ol>
<p>而<code>ComponentElement</code> 的<code>performRebuild()</code> 主要做了 2 件事：<br>
（1）<code>built = build();</code> ；（2）<code>_child = updateChild(_child, built, slot);</code></p>
<p>在这其中<code>build()</code>：</p>
<ol>
<li><code>StatelessElement</code>:<code>build() =&gt; widget.build(this);</code></li>
<li><code>StatefulElement</code> : <code>build() =&gt; state.build(this);</code></li>
<li><code>InheritedElement</code> :<code>build() =&gt; widget.child;</code></li>
</ol>
<p><code>updateChild</code> 会判断以下几种情况：</p>
<table>
<thead>
<tr>
<th></th>
<th>newWidget == null</th>
<th>newWidget != null</th>
</tr>
</thead>
<tbody>
<tr>
<td>child == null</td>
<td>return null</td>
<td>return new Element</td>
</tr>
<tr>
<td>child != null</td>
<td>remove old child, return null</td>
<td>Old child updated if possible, returns child or new Element</td>
</tr>
</tbody>
</table>
<p>其中，<code>old child updated</code> 的时候调用的是<code>child.update(newWidget);</code> 方法会触发<code>Widget</code>的<code>rebuild()</code> 。</p>
<p>这样就完成了一次 Rebuild。</p>
<h2> InheritedWidget 的 Rebuild 过程</h2>
<p><code>InheritedWidget</code>是持有状态的<code>Widget</code>，他的子<code>Widget</code>可以通过他来获取这些状态。</p>
<p>一般来说，<code>InheritedWidget</code>持有的状态是<code>final</code>的，如果要更新状态，就需要在其外部包裹一个<code>StatefulWidget</code>，通过<code>StatefulWidget</code>的<code>State.setState()</code>来触发<code>InheritedWidget</code>重建（实际上<code>InheritedElement</code>没有重新创建），从而更新那些依赖了<code>InheritedWidget</code>的子<code>Widget</code>。</p>
<p>下图是一个被<code>StatefulWidget</code>包裹的<code>InheritedWidget</code>在<code>setSate(){}</code>方法执行后的流程图：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter_render_flow_chart_with_inheritedwidget.png" alt="flutter_render_flow_chart_with_inheritedwidget" tabindex="0" loading="lazy"><figcaption>flutter_render_flow_chart_with_inheritedwidget</figcaption></figure>
<p>当外层<code>StatefulWidget</code>的<code>Element</code>执行到<code>updateChild(child,build,solt);</code>会调用<code>InheritedElement</code>的<code>update()</code> 方法。</p>
<p>这个方法内部会调用<code>updated(oldWidget)</code> 方法，在内部通过<code>notifyClients(oldWidget);</code> 方法，通知原先的<code>InheritedElement</code>的<code>_dependents</code> ，将其标记为<code>dirty</code>，准备<code>rebuild</code>。</p>
<p>在此之后，<code>update()</code>方法还会将当前<code>Element</code>标记为<code>dirty</code>，通过调用<code>rebuild();</code> 执行<code>performRebuild();</code></p>
<p>在<code>performRebuild()</code>方法中：</p>
<ul>
<li><code>built = build();</code> 中的<code>build</code>方法：<code>build() =&gt; widget.child;</code> 实际上取了<code>widget</code>的<code>child</code>。</li>
<li>然后执行<code>_child = updateChild(_child, built, slot);</code> 这个过程与普通<code>Widget</code>一致。</li>
</ul>
<p>需要注意的是，<code>updateChild</code> 中，如果子<code>Widget</code>不是<code>const</code> （或者被<code>InheritedWidget</code>外层的<code>widget</code>/<code>state</code>之类的持有）就会被认为<code>built!=_child</code> 从而导致<code>InheritedWidget</code>的子<code>Widget</code>重建。导致的结果就是：虽然<code>InheritedWidget</code>的确只标记了那些依赖了他的<code>Widget</code>，但是由于直接子<code>Widget</code>要重建，所以还是所有的<code>非const Widget</code>都重建了。</p>
<h3> InheritedWidget 的获取方式</h3>
<ul>
<li><code>T? dependOnInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;({ Object? aspect });</code> 获取指定类型的<code>InheritedWidget</code>，并且将自己注册到此<code>Widget</code>，以便当该<code>Widget</code>变化的时候，自己也能<code>rebuilt</code> 。复杂度<code>O(1)</code> 。</li>
<li><code>T? findAncestorWidgetOfExactType&lt;T extends Widget&gt;();</code> 只获取指定类型的<code>Widget</code> ，包括<code>InheritedWidget</code> ，仅获取该<code>Widget</code>执行一些操作，通常用在<code>interaction event handlers</code> 之类中。复杂度<code>(O(N)</code> 。</li>
</ul>
<h3> 代码示例</h3>
<p>根据上述理论，创建一个<code>InheritedWidget</code>来传递数据：</p>
<p>1、<code>AppColor.dart</code> 一个持有<code>color</code> 的<code>InheritedWidget</code>。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、定义一些类，使用或未使用到<code>InheritedWidget</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、接下来实现一种基础的使用<code>InheritedWidget</code>的方法，这种方法会在<code>InheritedWidget</code>更新的时候，rebuilt <code>InheritedWidget</code>下面的所有子类，无论他们是否使用到了<code>InheritedWidget</code>（原因是上面说到的 Flutter rebuild 的机制导致的，实际上<code>InheritedWidget</code>本身只标记了<code>ColorfulContainer</code>为<code>dirty</code>）。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、接下来实现一种使用<code>InheritedWidget</code>的方法，当<code>InheritedWidget</code>更新的时候，只会更新那些在<code>InheritedWidget</code>这里注册依赖了的<code>Widget</code>。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p><a href="https://petercoding.com/flutter/2021/07/04/using-inherited-widget-in-flutter/" target="_blank" rel="noopener noreferrer">Using Inherited Widget In Flutter</a></p>
<p><a href="https://www.cnblogs.com/lxlx1798/p/11190230.html?share_token=1bd95081-524b-4a3b-af65-686ab5c88ce4" target="_blank" rel="noopener noreferrer">【Flutter 学习】之 Widget 数据共享之 InheritedWidget 梁飞宇</a></p>
<p><a href="https://stackoverflow.com/questions/54494398/inheritedwidget-confusion" target="_blank" rel="noopener noreferrer">InheritedWidget confusion</a></p>
<p><a href="https://medium.com/flutter/managing-flutter-application-state-with-inheritedwidgets-1140452befe1" target="_blank" rel="noopener noreferrer">Managing Flutter Application State With InheritedWidgets</a></p>
<p><a href="https://stackoverflow.com/questions/53492705/does-using-const-in-the-widget-tree-improve-performance" target="_blank" rel="noopener noreferrer">Does using const in the widget tree improve performance?</a></p>
<p><a href="https://api.flutter-io.cn/flutter/widgets/StatefulWidget-class.html" target="_blank" rel="noopener noreferrer">StatefulWidget</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter_widget_element_renderobject_relationship.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter Expanded VS Flexible</title>
      <link>https://jixiaoyong.github.io/blog/posts/767a594.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/767a594.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter Expanded VS Flexible</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 11 May 2022 03:49:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>在 Flutter 中，当需要填充容器（<code>Row</code>, <code>Column</code>, or <code>Flex</code>）剩余空间的时候，可以使用<code>Expanded</code>或<code>Flexible</code>，本文对这二者的差异做一分析。</p>
<h2> 分析</h2>
<p><code>Expanded</code> 比较容易理解，他会强制 child 改变大小，占据容器的剩余空间，如果有多个<code>Expanded</code>的话，会按照他们的 flex 占比来分配每个 child 可以占据的空间大小。</p>
<p><code>Flexible</code> 稍微特殊一些，有时候看起来似乎他的 child 占据的大小既不全是父布局的剩余空间，也不全是刚刚包裹 child 内容的大小。</p>
<p>让我们看一下<code>Flexible</code>的源码：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，默认情况下他使用的<code>fit</code>模式是<code>FlexFit.loose</code>，查阅文档定义可知：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，默认情况下，<code>Flexible</code>的 child 最大可以是父容器分配给<code>Flexible</code>的大小（假设为<code>MaxSzie</code>）。</p>
<p>但是，如果 child 的大小比这个<code>MaxSzie</code>要小的话，那么允许 child 按照自己的大小来显示。</p>
<p>而如果<code>Flexible</code>的<code>fit</code>是<code>FlexFit.tight</code>的话，就会强制 child 大小为<code>MaxSzie</code>，效果和<code>Expanded</code>一致，实际上<code>Expanded</code>就是<code>FlexFit.tight</code>模式的<code>Flexible</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于上述的结论，我们可以从下面的代码中得到证实：</p>
<figure><img src="https://s3.bmp.ovh/imgs/2022/05/11/8559625d0d49ae28.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p><code>Expanded</code>和<code>Flexible</code>默认情况下都会按照<code>flex</code>占据父容器剩余的可用空间，但是不同的是，<code>Expanded</code>会强制 child 改变大小为父容器分配的大小，而<code>Flexible</code>则会告诉 child，<strong>最大只能是父容器分配的大小，要是 child 想要小一些的话，也可以按照 child 的大小显示</strong>。</p>
<p>如果改变<code>Flexible</code>的<code>fit</code>为<code>FlexFit.tight</code>的话，<code>Expanded</code>和<code>Flexible</code>没有差别。</p>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2022/05/11/8559625d0d49ae28.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter Widget 简单入门</title>
      <link>https://jixiaoyong.github.io/blog/posts/e35c106d.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/e35c106d.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter Widget 简单入门</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 21 Oct 2018 14:26:41 GMT</pubDate>
      <content:encoded><![CDATA[<p>Flutter 是 Google 提出的跨平台开发框架，使用 Dart 语言，支持 Android，IOS 系统。Flutter 一个重要的概念即是——<em>“万物皆控件（Widget）”</em>，像<code>Padding</code>,<code>Center</code>等都是 Widget。</p>
<p>Widget 和 Android 中的 View 很相似但又有不同，Widget 一旦生成便“一成不变”，直到下一次因为 Widget 更改或者 state 更新而被重新创建（Flutter’s framework creates a new tree of widget instances.），而 View 则只会被<code>drawn</code>一次，直到<code>invalidate</code>方法被调用。</p>
<p>本文主要记录一下 Flutter 中两个重要的控件：StatelessWidget 和 StatefulWidget，以及 Flutter 开发的一些基础知识。</p>
<h2> Flutter 基础知识</h2>
<p>Flutter 以 Dart 开发，其工程基本的结构如下：</p>
<ul>
<li>android</li>
<li>ios</li>
<li>lib
<ul>
<li>main.dart</li>
</ul>
</li>
<li>pubspec.yaml //Flutter 工程的配置信息</li>
</ul>
<p>Flutter 项目启动后会首先加载<code>/lib/main.dart</code>中的<code>main()</code>方法。<br>
一个标准的 material app 的 main.dart 内容如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> StatelessWidget &amp; StatefulWidget</h2>
<p>StatelessWidget 和 StateFulWidget 区别在于：前者一旦创建，状态便不会再更改，而后者则可以动态改变 State 从而使 flutter 改变其状态。但是两者都会在每一帧被 rebuild。</p>
<h3> StatelessWidget</h3>
<blockquote>
<p>A <code>StatelessWidget</code> is just what it sounds like—a widget with no state information.</p>
</blockquote>
<p>StatelessWidget 一旦创建便不会更改，其状态只和构造函数中的参数有关。下面是一个 StatelessWidget 示例，一般只需要重写其 build() 方法，返回要展示的控件即可：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> StatefulWidget</h3>
<blockquote>
<p><code>StatefulWidget</code> has a <code>State</code> object that stores state data across frames and restores it.</p>
</blockquote>
<p>StatefulWidget 可以通过动态更改其包含的 State，从而使 flutter 在下一次更新界面时依据 state 更新 StateWidget，<em>本质上还是更新了一个可以在多帧之间存活的 State，在下一帧更新控件</em>。</p>
<p>下面是一个 StatefulWidget 的示例：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以注意到 StatefulWidget 重写了<code>createState()</code>，而该方法返回了自定义的<code>ProductManagerState</code>类对象，在该类中<code>build()</code>方法实现和 StatelessWidget 中的方法类似，返回要展示的页面控件。</p>
<p>两者的不同之处在于，StatefulWidget 中可以调用<code>setState()</code>，更改其相应的<code>state</code>，以便告诉 flutter 在下一次 rebuild 的时候更新 UI。</p>
<p>StatelessWidget 要想实现动态更新其内容，可以在其外部包裹一层 StatefulWidget，通过 StatefulWidget 更改状态 state，将更改后的 state 传给 StatelessWidget，从而间接更新了 StatelessWidget 的状态。</p>
<p>可以通过对该方法就行包装，使得在 StatelessWidget 控件中调用 StatefulWidget 控件的<code>setState()</code>方法，达到刷新页面的效果：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 与 Android 的对比</h2>
<h3> Intent</h3>
<p>Android 的 Intent 有两个主要作用：</p>
<ul>
<li>Activity 间跳转</li>
<li>组件间传递数据</li>
</ul>
<p>Flutter 对此相应：</p>
<ul>
<li>使用 Navigator 和<code>Route</code>s 实现在同一个“Activity”中不同的界面间（ “screen”or“page”）跳转（push，pop），Navigator 类似于 Android 中的 Activity 栈。</li>
<li>通过 Android 原生 Intent 组件获取到其他 App 传来的数据，然后中通过下面的方法实现 Android 和 Flutter 交互：</li>
</ul>
<p>示例代码：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 线程</h3>
<p>Flutter 是单线程的，他的线程和 Android 的 UI 线程绑定，在进行网络请求，IO 操作等时，可以使用<code>sync/await</code> 在执行完耗时操作后，再去更新 state 刷新 UI。</p>
<blockquote>
<p>Since Flutter is single threaded and runs an event loop (like Node.js), you don’t have to worry about thread management or spawning background threads. If you’re doing I/O-bound work, such as disk access or a network call, then you can safely use async/await and you’re all set.</p>
</blockquote>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而如果有特别频繁的 cpu 计算以至于能导致 UI 挂起，可以考虑使用<code>Isolate</code>s 利用 CPU 多核心处理任务，但是这样就不能和主线程共享数据，通过<code>ReceivePort</code>，<code>SendPort</code>等传递数据。</p>
<blockquote>
<p>Isolates(隔离) are separate execution threads that do not share any memory with the main execution memory heap. This means you can’t access variables from the main thread, or update your UI by calling <code>setState()</code>. Unlike Android threads, Isolates are true to their name, and cannot share memory (in the form of static fields, for example).</p>
</blockquote>
<h3> 本地资源</h3>
<p>截止 Flutter beta 2 仍然不能直接访问 Android assets 或者其他本地资源，但是 Android 可以访问 flutter 的 assets 资源：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过 Channel，flutter 可以间接访问 Android 资源，反之亦然。</p>
<blockquote>
<p>主要是通过 Channel 完成，可以称之为隧道。主要是 MethodChannel 和 MessageChannel 两种，第一种是调用方法，第二种是传递信息。首先通信的双方是 Flutter 和本地操作系统或者应用，而且方法的调用和消息的方法可以从任何一方发起，类似 RPC（远程过程调用）。</p>
<p>作者：黄马</p>
<p>链接：掘金 <a href="https://juejin.im/post/5b35a75e51882574ea3a25e3" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5b35a75e51882574ea3a25e3</a></p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3> 生命周期</h3>
<p>Flutter 生命周期没有 Android 中那么“重要”，可以重写 <code>didChangeAppLifecycleState()</code> 监听。</p>
<ul>
<li><code>inactive</code> — 应用处于非活动状态，不接受输入。iOS</li>
<li><code>paused</code> — 应用在后台运行，不可见，不接受输入。类似 Android 的<code>onPause()</code></li>
<li><code>resumed</code> — 应用可见，并接受输入。类似 Android 的<code>onPostResume()</code></li>
<li><code>suspending</code> — 应用请求暂停。类似 Android 的<code>onStop()</code></li>
</ul>
<h3> 布局</h3>
<p>Flutter 有布局 Widget 如：</p>
<ul>
<li>Column 列</li>
<li>Row 行</li>
<li>Stack 左上角堆积，类似 FrameLayout</li>
</ul>
<h3> 点击事件</h3>
<p>FLutter 中的“<code>onClick()</code>”: <code>onPressed</code>,<code>onTap</code>等等。</p>
<p>添加点击事件，在 Widget 外面添加一个<code>GestureDetector</code>Widget：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考链接</h2>
<p><a href="https://www.youtube.com/watch?v=GLSG_Wh_YWc" target="_blank" rel="noopener noreferrer">Flutter Tutorial for Beginners - Build iOS and Android Apps with Google's Flutter &amp; Dart</a></p>
<p><a href="https://flutter.io/flutter-for-android/" target="_blank" rel="noopener noreferrer">Flutter for android</a></p>
<p><a href="https://juejin.im/post/5b35a75e51882574ea3a25e3" target="_blank" rel="noopener noreferrer">Flutter 访问本地资源</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Flutter 中的异常处理</title>
      <link>https://jixiaoyong.github.io/blog/posts/9e235953.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/9e235953.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 中的异常处理</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 29 Jul 2021 07:41:47 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 说明</h2>
<p><code>FLutter</code>中的错误不会导致应用程序奔溃，只会终止执行出错代码之后的逻辑，在导致<code>Widget.build()</code>返回为<code>null</code>的错误会导致<code>Widget</code>构建失败，并返回<em>红底黄字</em>的错误原因<code>Widget</code>（在 Release 模式则会显示为<em>灰底区域</em>）；一般来说，Flutter 中的错误都会被<code>FlutterError.onError</code>捕获并处理；对于异步方法产生异常等<code>Flutter框架</code>没有捕获的情况，会交由当前代码所在的<code>Zone</code>处理（这些异常可以使用<code>runZonedGuarded</code>捕获并处理）。</p>
<blockquote>
<p><strong>为什么 flutter 触发异常的时候不会崩溃？</strong><br>
这个和 <code>flutter</code> 的消息循环机制有关，任务分两种，一个是微任务 <code>microtask</code>，一个是事件 <code>event</code>，他们有自己的队列，每个任务是相互独立的，一旦某个任务触发异常，也就是导致这个任务后续代码无法执行，并不会影响其他任务执行</p>
</blockquote>
<p><em>本文基于 Flutter (Channel stable, 2.2.3)</em></p>
<h2> 详细说明</h2>
<p>Flutter 中的错误处理分为以下几种：</p>
<h3> <code>try...catch</code></h3>
<p>对于普通的错误，可以通过<code>try...catch</code>来捕获：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于，异步异常，可以使用<code>await</code>等待其执行完毕，将其变为同步任务，否则无法则捕获。</p>
<h3> <code>ErrorWidget.builder</code></h3>
<p>当在<code>Widget</code>构建过程中出现错误，导致<code>build()</code>方法返回<code>null</code>，<code>Flutter框架</code>会调用<code>ErrorWidget.builder</code>返回一个<code>Widget</code>替代<code>出错的Widget</code>。</p>
<p>默认情况下，<code>debug</code>模式返回的是红底黄字的错误提示，而<code>release</code>模式返回的是<code>灰色Widget</code>。</p>
<p>可以在<code>RunApp</code>方法中替换这个默认的错误界面：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的<code>MainErrorWidget</code>是一个自定义的展示错误信息的页面。</p>
<ul>
<li>
<p><code>MainErrorWidget</code>的一种实现方式</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>需要注意的是，错误<code>Widget</code>在<code>Debug</code>和<code>Release</code>模式下有一些区别：</p>
<ul>
<li><code>Debug</code>模式下<code>ErrorWidget.builder</code>会返回错误详细信息<code>FlutterErrorDetails</code> ，<code>Release</code>下则不会；</li>
<li><code>Debug</code>模式下，<code>Widget</code>等出错会打印<code>Exception caught by widgets library ...</code> 等提示并输出错误堆栈信息，但是<code>Release</code>模式下不会；</li>
<li><code>Debug</code>模式下，出错不会调用<code>FlutterError.onError</code>，<code>Release</code>模式下会。</li>
</ul>
<h3> <code>FlutterError.onError</code></h3>
<p>上述几种情况都没有处理的，被 Flutter 框架引起的异常，会在这里被处理。</p>
<p>在<code>Flutter 2.2.3</code>中，<code>Debug</code>模式下如<code>onPressed</code>中的未捕获错误等都会被 Widget 等捕获，而不会走到这里来，在<code>Release</code>模式下则会调用<code>FlutterError.onError</code>。</p>
<p>在这里可以对错误进行处理，比如输出到控制台、交给 Zone 统一处理、直接结束掉 APP 等：</p>
<ul>
<li><code>FlutterError.dumpErrorToConsole(details);</code> 输出到控制台</li>
<li><code>exit(1);</code> 退出 APP</li>
<li><code>Zone.current.handleUncaughtError(details.exception, details.stack);</code> 交给 Zone 统一处理</li>
<li><code>defaultOnError?.call(details);</code> 自己处理完异常后，也要把异常向上抛【推荐】，其中<code>defaultOnError</code> 可以预先缓存<code>final defaultOnError = FlutterError.onError;</code></li>
</ul>
<h3> <code>runZonedGuarded(onError)</code></h3>
<p>上述几种情况都没有处理的异常，会被发送到这里处理，可以类比为<code>Android</code>中的<code>Thread.UncaughtExceptionHandler</code>。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Zone 可以理解为一个沙盒，其中的代码出错，包括异步的都可以捕获到。但是如果是另外一个沙盒中的错误则无法处理。</p>
<h2> 参考文章</h2>
<p><a href="https://flutter.cn/docs/testing/errors#define-a-custom-error-widget-for-build-phase-errors" target="_blank" rel="noopener noreferrer">Flutter 官网异常处理</a></p>
<p><a href="https://www.fnzblog.site/Flutter%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" target="_blank" rel="noopener noreferrer">Flutter 异常处理</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Flutter 动画分析之 AnimatedWidget&amp;ImplicitlyAnimatedWidget</title>
      <link>https://jixiaoyong.github.io/blog/posts/47c43abe.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/47c43abe.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 动画分析之 AnimatedWidget&amp;ImplicitlyAnimatedWidget</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 22 Aug 2022 00:58:45 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文讨论的 Flutter 动画主要限定在：<em>随着每一帧的变化，修改 Flutter Widget 的大小、颜色、位置等属性，使之看起来从一种状态渐变为另外一种状态</em> 这一范围。</p>
</blockquote>
<p>在之前的文章中，我们将 Flutter 中动画的实现分为 <em>底层实现</em> 和 <em>封装好的 Widget</em> 两大部分，目前已经分析了底层实现的部分：</p>
<ul>
<li><a href="https://jixiaoyong.github.io/blog/posts/6ec43bd8.html" target="_blank" rel="noopener noreferrer">AnimationController</a></li>
<li><a href="https://jixiaoyong.github.io/blog/posts/820d6240.html" target="_blank" rel="noopener noreferrer">Tween&amp;Curve</a></li>
</ul>
<p>而 Flutter 封装好的动画 Widget 主要分为两大类：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_widget.png" alt="Flutter 中与动画有关的 Widget" tabindex="0" loading="lazy"><figcaption>Flutter 中与动画有关的 Widget</figcaption></figure>
<ul>
<li>
<p><strong>ImplicitlyAnimatedWidget</strong> 隐式动画，关于动画的开始、停止等都封装在 Widget 内部，只要 Widget <em>前后传入的值不同</em> 便可以自动从 old 渐变到 new，内置的这些类主要以 <em>AnimatedFoo</em> 命名。</p>
</li>
<li>
<p><strong>AnimatedWidget</strong>，显式动画，需要使用者自己创建 Animation（一般是 AnimationController）并通过其 <em>主动管理动画</em>，此类 Widget 主要是监听 AnimationController 的值并刷新 Widget 的内容。</p>
<p>此类 Widget 主要有三种使用方式：</p>
<ul>
<li>继承 AnimatedWidget</li>
<li>使用 AnimatedBuilder</li>
<li>使用各种内置的 AnimatedWidget 子类，一般以 FooTransition 命名。</li>
</ul>
</li>
</ul>
<p>对于 Flutter 中这些与动画有关的类如何选择，Flutter 官方给了一张图：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_select.png" alt="如何实现 Flutter 中的动画" tabindex="0" loading="lazy"><figcaption>如何实现 Flutter 中的动画</figcaption></figure>
<p>简单来说，Flutter 有一些内置的动画，在要写动画的时候，可以依次考虑（实现程度由易到难）：</p>
<ul>
<li>AnimatedFoo 参考<a href="https://medium.com/flutter/flutter-animation-basics-with-implicit-animations-95db481c5916" target="_blank" rel="noopener noreferrer">文章</a>，设置新的状态，这些控件会自动从之前的状态切换到新状态</li>
<li>TweenAnimationBuilder 参考<a href="https://medium.com/flutter/custom-implicit-animations-in-flutter-with-tweenanimationbuilder-c76540b47185" target="_blank" rel="noopener noreferrer">文章</a>，将任意属性在 Tween 指定的范围变化，和上面的 AnimatedFoo 都是属于<a href="https://api.flutter.dev/flutter/widgets/ImplicitlyAnimatedWidget-class.html" target="_blank" rel="noopener noreferrer">Implicitly animated widgets</a>（隐式动画，由系统控件控制动画）。</li>
<li>FooTranslation</li>
<li>AnimatedBuilder / AnimatedWidget</li>
<li>CustomPainter</li>
</ul>
<br>
<p>本文将对 Flutter 内置封装好的动画相关的 Widget 的实现和用法进行简单分析。</p>
<h2> 源码分析</h2>
<p>按照上述分析，Flutter 中的动画 Widget 可以大体分为 <em>隐式动画</em> 和 <em>显式动画</em> 两种。</p>
<h3> ImplicitlyAnimatedWidget</h3>
<blockquote>
<p>ImplicitlyAnimatedWidgets (and their subclasses) automatically animate changes in their properties whenever they change.</p>
</blockquote>
<p>隐式动画内部持有 AnimationController 以管理动画，默认没有动画，当使用不同的值重新构建 Widget 的时候，会执行动画，使用者只能设置 Duration 和 Curve，如果想要更深入的控制动画（比如暂停动画）则应该使用 AnimatedWidget。</p>
<p>ImplicitlyAnimatedWidget 主要分为 2 大类：</p>
<ul>
<li>TweenAnimationBuilder, which animates any property expressed by a Tween to a specified target value.</li>
<li>AnimatedFoo
<ul>
<li>AnimatedAlign, which is an implicitly animated version of Align.</li>
<li>AnimatedContainer, which is an implicitly animated version of Container.</li>
<li>AnimatedDefaultTextStyle, which is an implicitly animated version of DefaultTextStyle.</li>
<li>AnimatedScale, which is an implicitly animated version of Transform.scale.</li>
<li>AnimatedRotation, which is an implicitly animated version of Transform.rotate.</li>
<li>AnimatedSlide, which implicitly animates the position of a widget relative to its normal position.</li>
<li>AnimatedOpacity, which is an implicitly animated version of Opacity.</li>
<li>AnimatedPadding, which is an implicitly animated version of Padding.</li>
<li>AnimatedPhysicalModel, which is an implicitly animated version of PhysicalModel.</li>
<li>AnimatedPositioned, which is an implicitly animated version of Positioned.</li>
<li>AnimatedPositionedDirectional, which is an implicitly animated version of PositionedDirectional.</li>
<li>AnimatedTheme, which is an implicitly animated version of Theme.</li>
<li>AnimatedCrossFade, which cross-fades between two given children and animates itself between their sizes.</li>
<li>AnimatedSize, which automatically transitions its size over a given duration.</li>
<li>AnimatedSwitcher, which fades from one widget to another.</li>
</ul>
</li>
</ul>
<p>我们简单分析一下 ImplicitlyAnimatedWidget 和 TweenAnimationBuilder：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><code>ImplicitlyAnimatedWidget.createState()</code>必须返回 ImplicitlyAnimatedWidgetState 或者 AnimatedWidgetBaseState 及其子类。</p>
</blockquote>
<p>ImplicitlyAnimatedWidget 作为 StatefulWidget，它的主要逻辑在 ImplicitlyAnimatedWidgetState 中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ImplicitlyAnimatedWidgetState 中，根据传入的 <em>Duration</em> 和 <em>Curve</em>，创建并持有了 <em>AnimationController</em> 和 <em>Animation&lt;double&gt;</em> 用于驱动隐式动画。</p>
<h4> initState</h4>
<p>在<code>ImplicitlyAnimatedWidgetState.initState</code>方法中：</p>
<ul>
<li>监听<code>_controller</code>的状态，当<code>AnimationStatus.completed</code>时回调<code>ImplicitlyAnimatedWidget.onEnd</code>方法；</li>
<li>此外还调用了<code>_constructTweens()</code>遍历 Tween，并调用由子类实现的<code>forEachTween()</code>方法（子类在此方法内部，获取到对应的 Tween，比如 Padding，从而在监听到<code>_controller</code>变化并触发 rebuilt 时使用<code>Animatable.evaluate()</code>方法获取并显示最新的属性，实现动画效果）；</li>
<li>最后还调用了<code>didUpdateTweens()</code>方法通知子类 Tweens 发生变化了。</li>
</ul>
<h4> _constructTweens</h4>
<p><code>_constructTweens()</code>方法会创建一个 TweenVisitor&lt;dynamic&gt;并传给子类 <code>forEachTween()</code>方法，子类可以使用其获取对应的 Tween 对象。</p>
<p><code>_constructTweens()</code>则在此过程中，使用<code>_shouldAnimateTween()</code>得知了子类中是否有 Tween 可以开始动画——<code>shouldStartAnimation</code>。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> didUpdateWidget</h4>
<p>当 ImplicitlyAnimatedWidget 被重新创建时，会调用 ImplicitlyAnimatedWidgetState.didUpdateWidget 方法。</p>
<p>在此方法中，除了检查并更新 Curve、Duration、Tween 之外，最重要的是使用 AnimationController.forward() 开启了动画。也就是说——“<strong>ImplicitlyAnimatedWidget 第一次插入 Widget Tree 时没有动画，当再次被更新时会触发动画</strong>”。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> forEachTween</h4>
<p>子类必须实现此方法，使用传入的 TweenVisitor 创建自己对应的 Tween。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> didUpdateTweens</h4>
<p>当 Tween 变化时会调用此方法通知子类，子类（可选）可以实现此方法。</p>
<br>
<p>到目前为止，我们的 AnimationController 已经控制动画开始执行，但是因为<strong>没有监听 AnimationController.value 的变化</strong>，所以还不能自动触发 ImplicitlyAnimatedWidgetState.build() 方法。</p>
<p>为了实现动画效果，子类可以选择<strong>自己主动监听 AnimationController</strong>；或者，<strong>继承 AnimatedWidgetBaseState</strong>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ImplicitlyAnimatedWidget 的子类主要实现 AnimatedWidgetBaseState/ImplicitlyAnimatedWidgetState 的<code>forEachTween()</code>和<code>build()</code>方法即可。前者用于生成 Widget 所需的 Tween；后者则使用生成的 Tween&lt;T&gt;的<code>evaluate(animation)</code>方法计算对应的属性并展示。</p>
<p>以 AnimatedPadding 为例，它继承自 ImplicitlyAnimatedWidget，创建的_AnimatedPaddingState 继承自 AnimatedWidgetBaseState&lt;AnimatedPadding&gt;：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br>
<p>上述分析是继承 ImplicitlyAnimatedWidget 实现隐式动画的常用流程，Flutter 中内置的 AnimatedFoo 动画都是类似实现。</p>
<h4> TweenAnimationBuilder</h4>
<p>ImplicitlyAnimatedWidget 的子类（以 AnimatedFoo 命名的一众子类）提供了常见的动画效果，但是如果有特殊的动画效果需要实现，除了直接继承 ImplicitlyAnimatedWidget 之外，还可以使用 TweenAnimationBuilder 并传入 Tween 来实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 Widget <strong>首次 build 的时候就会触发动画</strong>从 Tween.begin 过渡到 Tween.end；当再次提供一个有<strong>新 end 的 Tween 也可以随时触发新动画</strong>（新动画从动画当前值开始）。</p>
<p>需要注意：</p>
<ul>
<li>传入到 TweenAnimationBuilder 中的 Tween 被其持有（可能修改）,所以不应当再操作它；</li>
<li>当动画执行完毕会调用 TweenAnimationBuilder.onEnd 方法；</li>
<li>为了性能，应当将不需要每次更新的 subtree 传入到 TweenAnimationBuilder.child 中避免重绘。</li>
</ul>
<p>和其他 ImplicitlyAnimatedWidget 的子类一样，TweenAnimationBuilder 的主要逻辑也在继承自 AnimatedWidgetBaseState 的_TweenAnimationBuilderState 中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用时需要注意，只有传入 TweenAnimationBuilder 的 Tween 是一个新的、并且 end 值和之前不一样的才会触发动画。如果 end 值一样则无动画、如果不是新的则 builder 的内容只会突然变化为 end 值对应状态而无动画。</p>
<h3> AnimatedWidget</h3>
<p>之前分析的 TweenAnimationBuilder 以及 ImplicitlyAnimatedWidget 的其他子类，基本上都只能定义动画的 Tween、Duration、Curve 等，动画的开始结束动都由这些 Widget 内部控制。</p>
<p>如果需要手动主动控制动画，可以选择使用 <strong>显式动画</strong> —— AnimatedWidget 及其子类：</p>
<p>其同样也分为 2 大类：</p>
<ul>
<li>AnimatedBuilder, which is useful for complex animation use cases and a notable exception to the naming scheme of AnimatedWidget subclasses.</li>
<li>FooTransition 子类
<ul>
<li>AlignTransition, which is an animated version of Align.</li>
<li>DecoratedBoxTransition, which is an animated version of DecoratedBox.</li>
<li>DefaultTextStyleTransition, which is an animated version of DefaultTextStyle.</li>
<li>PositionedTransition, which is an animated version of Positioned.</li>
<li>RelativePositionedTransition, which is an animated version of Positioned.</li>
<li>RotationTransition, which animates the rotation of a widget.</li>
<li>ScaleTransition, which animates the scale of a widget.</li>
<li>SizeTransition, which animates its own size.</li>
<li>SlideTransition, which animates the position of a widget relative to its normal position.</li>
<li>FadeTransition, which is an animated version of Opacity.</li>
<li>AnimatedModalBarrier, which is an animated version of ModalBarrier.</li>
</ul>
</li>
</ul>
<p>AnimatedWidget 比 ImplicitlyAnimatedWidget 简单许多，其接受一个 Listenable 对象，在_AnimatedState 中监听其并触发 rebuilt。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>AnimatedWidget.listenable</code>通常是 AnimationController，当然也可以是其他实现 Listenable 的类（including ChangeNotifier and ValueNotifier）。</p>
<h4> _AnimatedState</h4>
<p>AnimatedWidget 的主要逻辑在对应的_AnimatedState 中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，相对于隐式动画 ImplicitlyAnimatedWidget，显示动画 AnimatedWidget 的逻辑要简单的多，只是监听传入的 Listenable 并触发 rebuilt 即可。对于动画的控制则由 Listenable（通常是 AnimationController）处理。</p>
<p>也就是说，显示动画 AnimatedWidget 只是<strong>替子类做了监听/移除监听 Listenable 的值变化，并触发 rebuilt 的工作</strong>，如何获取变化的值，以及展示对应的 Widget 则需要子类自己处理。</p>
<p>他的子类 FooTransition 实现逻辑也比较简单，只需要在在 Widget.build 根据不同的状态创建创建不同属性的 Widget 即可：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> AnimatedBuilder</h4>
<p>一般来说，Flutter 内置的以 FooTransition 命名的 AnimatedWidget 的子类可以满足基本的需求，但是如果想要实现更复杂的效果，除了直接继承 AnimatedWidget 之外，还可以使用 AnimatedBuilder 实现丰富的动画：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而 AnimatedBuilder 的实现也比较简单：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p><strong>ImplicitlyAnimatedWidget 隐式动画</strong>，内部创建并监听 AnimationController 以维护动画，控制动画的开始和结束，用户可以通过传入 Duration、Curve、Tween 等决定动画的时长、曲线、开始和结束值等，当动画相关的属性变化时，隐式动画会自动播放，使用者不可以直接控制动画。<br>
Flutter 内置的隐式动画为 TweenAnimationBuilder 和 AnimatedFoo。</p>
<p><strong>AnimatedWidget 显式动画</strong>，接受 Listenable（通常是 AnimationController）并监听其值变化，以触发 Widget 重新 build，其子类中一般会监听 Listenable 的值并计算设置 Widget 对应的属性。使用者需要负责创建、控制 Listenable 从而控制动画播放。Flutter 内置的显式动画为 AnimatedBuilder 和 FooTransition。</p>
<p>在使用 Flutter 实现<strong>Widget 动画</strong>时，可以按照以下顺序选择实现方式：</p>
<ol>
<li>AnimatedFoo，选择内置的隐式动画，以实现当 Padding、Alignment 等属性变化时自动渐变到新值的动画效果。</li>
<li>TweenAnimationBuilder/继承 ImplicitlyAnimatedWidget，当上一步无法满足需求时，可以考虑进一步自定义实现隐式动画。</li>
<li>FooTransition，如果不止要展示动画，还希望能够控制动画开始、结束，就使用内置的显式动画结合自己创建的 AnimationController 实现动画。</li>
<li>AnimationBuilder/AnimatedWidget，如果没有满足条件的内置显式动画，可以使用自定义实现显式动画。</li>
<li>CustomPainter，如果上述方法仍然无法满足动画需求，可以考虑使用 CustomPainter 自己绘制动画。</li>
</ol>
<h2> 参考资料</h2>
<p><a href="https://flutter.cn/docs/development/ui/animations" target="_blank" rel="noopener noreferrer">动画效果介绍 flutter.cn</a></p>
<p><a href="https://api.flutter.dev/flutter/widgets/ImplicitlyAnimatedWidget-class.html" target="_blank" rel="noopener noreferrer">ImplicitlyAnimatedWidget</a></p>
<p><a href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html" target="_blank" rel="noopener noreferrer">AnimatedWidget</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_widget.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 动画分析之 AnimationController</title>
      <link>https://jixiaoyong.github.io/blog/posts/6ec43bd8.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/6ec43bd8.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 动画分析之 AnimationController</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 21 Aug 2022 02:43:24 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文讨论的 Flutter 动画主要限定在：<em>随着每一帧的变化，修改 Flutter Widget 的大小、颜色、位置等属性，使之看起来从一种状态渐变为另外一种状态</em> 这一范围。</p>
</blockquote>
<p>Flutter 中关于动画的类有很多，为了便于分析，将其分为两大类：</p>
<ul>
<li>Flutter 框架底层实现动画的各个类，比如 AnimationController、Ticker、Tween、Curve 等</li>
<li>基于底层实现，提供进一步封装的 Flutter 动画相关的 Widget 类，比如 AnimatedWidget、ImplicitlyAnimatedWidget 和他们的子类。</li>
</ul>
<p>他们的关系如下：</p>
<p>AnimationController 通过 Ticker 监听 Flutter 屏幕帧刷新：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_struct2.png" alt="Flutter 中 AnimationController 与 Ticker 关系" tabindex="0" loading="lazy"><figcaption>Flutter 中 AnimationController 与 Ticker 关系</figcaption></figure>
<p>每一帧刷新后，AnimationController 监听并根据 Duration 等计算出当前的 Animation.value；<br>
此外也可以通过 Tween 将 double 类型转化为其他的类型比如 Offset 等；<br>
上述两种方式中 value 都是随着时间线性变化，而 Curve 可以与 CurveTween、AnimationController 等结合使 value 实现非线性的变化。</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_struct1.png" alt="Flutter 各种动画底层类关系" tabindex="0" loading="lazy"><figcaption>Flutter 各种动画底层类关系</figcaption></figure>
<p>当随着时间变化，计算出当前的 Animation.value 时，便可以根据此值修改 Flutter Widget 的各个属性，从而实现动画的视觉效果。</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_widget.png" alt="Flutter 中与动画有关的 Widget" tabindex="0" loading="lazy"><figcaption>Flutter 中与动画有关的 Widget</figcaption></figure>
<p>从上图可以看到，Flutter 提供的动画 Widget 主要分为两大类：</p>
<ul>
<li>
<p>ImplicitlyAnimatedWidget 隐式动画，关于动画的开始、停止等都封装在 Widget 内部，只要 Widget 前后传入的值不同便可以自动从 old 渐变到 new，内置的这些类主要以 AnimatedFoo 命名。</p>
</li>
<li>
<p>AnimatedWidget，显式动画，需要使用者自己创建 Animation（一般是 AnimationController）并通过其管理动画，此类 Widget 主要是监听 AnimationController 的值并刷新 Widget 的内容。</p>
<p>此类 Widget 主要有三种使用方式：</p>
<ul>
<li>继承 AnimatedWidget</li>
<li>使用 AnimatedBuilder</li>
<li>使用各种内置的 AnimatedWidget 子类，一般以 FooTransition 命名。</li>
</ul>
</li>
</ul>
<p>对于 Flutter 中这些与动画有关的类如何选择，Flutter 官方给了一张图：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_select.png" alt="如何实现 Flutter 中的动画" tabindex="0" loading="lazy"><figcaption>如何实现 Flutter 中的动画</figcaption></figure>
<p>简单来说，Flutter 有一些内置的动画，在要写动画的时候，可以依次考虑（实现程度由易到难）：</p>
<ul>
<li>AnimatedFoo 参考<a href="https://medium.com/flutter/flutter-animation-basics-with-implicit-animations-95db481c5916" target="_blank" rel="noopener noreferrer">文章</a>，设置新的状态，这些控件会自动从之前的状态切换到新状态</li>
<li>TweenAnimationBuilder 参考<a href="https://medium.com/flutter/custom-implicit-animations-in-flutter-with-tweenanimationbuilder-c76540b47185" target="_blank" rel="noopener noreferrer">文章</a>，将任意属性在 Tween 指定的范围变化，和上面的 AnimatedFoo 都是属于<a href="https://api.flutter.dev/flutter/widgets/ImplicitlyAnimatedWidget-class.html" target="_blank" rel="noopener noreferrer">Implicitly animated widgets</a>（隐式动画，由系统控件控制动画）。</li>
<li>FooTranslation</li>
<li>AnimatedBuilder / AnimatedWidget</li>
<li>CustomPainter</li>
</ul>
<br>
<p>本文主要分析 AnimationController 及其相关类。</p>
<h2> 源码分析</h2>
<p>AnimationController 是 Flutter 中动画的基石，它继承自 Animation，根据不同的方法调用创建对应的 Simulation 并开始监听传入的 Ticker；</p>
<p>每当 Flutter 中帧刷新时，从_simulation 中获取当前 Animation._value 并对 listener 发出通知；</p>
<p>这样需要使用 Animation.value 的各个 Widget 便可以根据其值修改自身属性，实现动画视觉效果。</p>
<h3> Animation</h3>
<p>根据上述分析，我们首先来看一下 Animation 类：</p>
<blockquote>
<p>An animation with a value of type&nbsp;T</p>
</blockquote>
<p>Animation 主要的作用是持有 value 和 status，并允许其他对象监听二者的变化。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Animation 继承自 Listenable，实现 ValueListenable 接口，其他类可以通过 addListener/removeListener 或者 addStatusListener/removeStatusListener 监听 Animation 的 value 或者 status 变化。</p>
<p>Animation 共有 4 种状态：dismissed、forward、reverse、completed。</p>
<p>除此之外，Animation.drive 方法可以创建一个新的将传入的 Animatable 应用到自身的 Animation。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，提供了将 <code>Animation&lt;double&gt;</code> 转化为 <code>Animation&lt;U&gt;</code> 类型的方法。</p>
<h4> 其他子类</h4>
<p>除了后面要详细分析的 AnimationController 之外，Animation 还有如下子类：</p>
<table>
<thead>
<tr>
<th>class</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AlwaysStoppedAnimation</td>
<td>永远停留在指定值的 animation</td>
</tr>
<tr>
<td><strong>ProxyAnimation</strong></td>
<td>代理 Animation，适用于动画可能会变化的情况，先使用 ProxyAnimation 应用一个 Animation，然后再修改为其他 Animation（不用手动添加移除 listener）</td>
</tr>
<tr>
<td>ReverseAnimation</td>
<td>返回和当前 animation 反方向的 Animation</td>
</tr>
<tr>
<td><strong>CurvedAnimation</strong></td>
<td>可以为传入的 animation 使用 Curve 的 animation，适用于将原先线性变化的 Animation 改为非线性的</td>
</tr>
<tr>
<td>TrainHoppingAnimation</td>
<td>监听传入的两个 Animation&lt;double&gt;，当第二个 Animation 的值超过第一个 Animation 的值时自动切换到第二个并回调 onSwitchedTrain。如果一开始两个 Animation 就在同一个值，则切换到第二个并不会调用 onSwitchedTrain。</td>
</tr>
<tr>
<td>CompoundAnimation</td>
<td>可以组合多个 Animation&lt;T&gt;的接口，当 Animation&lt;T&gt; next 处于运动状态时返回 next 的状态，否则返回 Animation&lt;T&gt; first 的状态。</td>
</tr>
</tbody>
</table>
<p>对于上述的 CompoundAnimation，子类只需重写 <code>double get value</code> 方法即可，其有三个子类：</p>
<ul>
<li><code>AnimationMean</code> 返回 first 和 next 值和的二分之一，值为 double</li>
<li><code>AnimationMax&lt;T extends num&gt;</code> 返回 first 和 next 中最大值</li>
<li><code>AnimationMin&lt;T extends num&gt;</code> 返回 first 和 next 中最小值</li>
</ul>
<h3> AnimationController</h3>
<blockquote>
<p>A controller for an animation.</p>
</blockquote>
<p>尽管有各种子类，但 Animation 最常用的子类是 AnimationController，使用者可以用它来控制、监听动画、创建其他动画。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 构造方法</h4>
<p>AnimationController 有两种构造方法，这两种构造方法主要会初始化以下变量：</p>
<ul>
<li>double value 当前值</li>
<li>Duration? duration,reverseDuration 动画正向、反向运行的时长，初始化时可以为 null，但在实际开始动画之前，至少保证 duration 不为 null</li>
<li>double lowerBound,double upperBound 当 value 触达此值时，animation 分别被认为是 dismissed、completed</li>
<li>Ticker? _ticker 由构造方法中必传的 TickerProvider vsync 创建</li>
</ul>
<p>他的两个构造方法分别是：</p>
<ul>
<li>
<p>AnimationController()</p>
<p>默认构造方法，double lowerBound,double upperBound 默认分别为 0.0，1.0</p>
</li>
<li>
<p>AnimationController.unbounded()</p>
<p>不限制 value 值的构造方法，double lowerBound,double upperBound 默认分别为 double.negativeInfinity，double.infinity。适用于没有预设编辑的物理模拟动画。</p>
</li>
</ul>
<p>在这两个构造方法内部，都会通过<code>_ticker = vsync.createTicker(_tick)</code>创建_ticker，并保证当_ticker 回调时执行<code>AnimationController._tick()</code>方法。</p>
<blockquote>
<p>这里的 TickerProvider 主要有 2 种：</p>
<ul>
<li>SingleTickerProviderStateMixin 适用于 State 中只有一个 AnimationController 的情况，性能更好</li>
<li>TickerProviderStateMixin 适用于 State 生命周期内有多个 AnimationController 的情况</li>
</ul>
</blockquote>
<br>
<p>除了从 Animation 继承的方法外，AnimationController 还提供了如下方法，用于操纵动画：</p>
<p><strong>操纵从<code>double? from</code>正向/反向开始动画</strong>：</p>
<ul>
<li>TickerFuture forward({ double? from })</li>
<li>TickerFuture reverse({ double? from })</li>
</ul>
<p><strong>操纵正向/反向开始朝向<code>double target</code>开始动画</strong>，此类动画还可以改变<em>Duration</em>和<em>Curve</em>：</p>
<ul>
<li>TickerFuture animateTo(double target, { Duration? duration, Curve curve = Curves.linear })</li>
<li>TickerFuture animateBack(double target, { Duration? duration, Curve curve = Curves.linear })</li>
</ul>
<p>上述四种方法，内部都是通过 <code>AnimationController._animateToInternal()</code>方法实现，而此方法内部又是执行 <code>AnimationController._startSimulation()</code>，除此之外，还有以下几类方法内部也是基于_startSimulation() 方法实现，主要区别在于不同方法方法创建了不同的 Simulation：</p>
<ul>
<li>TickerFuture repeat({ double? min, double? max, bool reverse = false, Duration? period })</li>
<li>TickerFuture fling({ double velocity = 1.0, SpringDescription? springDescription, AnimationBehavior? animationBehavior })</li>
<li>TickerFuture animateWith(Simulation simulation)</li>
</ul>
<h4> _startSimulation</h4>
<p><code>AnimationController._startSimulation()</code>方法是其实现动画的基石，其内部主要是开启了_ticker 并发出通知：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>_ticker.start()</code>方法最终通过<code>SchedulerBinding.instance.scheduleFrameCallback()</code>方法监听 Flutter Framework 的帧刷新，并回调 <code>AnimationController._tick</code> 方法</p>
<h4> _tick</h4>
<p>在此方法内部根据当前时间和_simulation 获取_value 并发出通知。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 其他方法</h4>
<ul>
<li>void resync(TickerProvider vsync) 使用 vsync 重新创建新的_ticker</li>
<li>void stop({ bool canceled = true }) 停止动画，不会触发通知，默认标记动画为 canceled</li>
<li>void dispose() 释放资源，动画被标记为 canceled</li>
</ul>
<h3> Simulation</h3>
<p>从上面的分析中，我们看到 Simulation 在 AnimationController 动画中也起到很重要的作用：Simulation 主要是在一维空间对物理进行位置、速度等建模。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 AnimationController 中常用的子类有以下两种：</p>
<h4> _InterpolationSimulation</h4>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其 x() 方法中除了 t 为 0.0 或 1.0 的情况外，其余时候依靠 Curve（默认为 Curves.linear）计算值。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> _RepeatingSimulation</h4>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>没有 Curve，其 double x(double timeInSeconds) 方法可以自动判断是否需要反向并修改方向（会触发 status 改变通知）：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外比较特殊的是他的 isDone 方法一致返回 false，表示不会主动结束动画。</p>
<h4> SpringSimulation</h4>
<p>用于 fling 方法，创建弹性的模拟</p>
<h2> 总结</h2>
<p>经过上述分析，应该能了解 Flutter 动画中 AnimationController 的作用：</p>
<ul>
<li>
<p><strong>AnimationController</strong> 通过传入的 <strong>TickerProvider</strong> 创建并监听 <strong>Ticker</strong>，确保 Ticker 收到系统帧回调时触发 AnimationController._tick 方法；</p>
</li>
<li>
<p>提供 forward，reverse，animateTo，animateBack，repeat，fling，animateWith 等方法创建不同的 <strong>Simulation</strong> 并开启 Ticker，从而可以通过 <strong>SchedulerBinding</strong>.instance.scheduleFrameCallback 监听 Flutter 每一帧刷新。</p>
<p>并且在 animateTo，animateBack 方法中可以使用 <strong>Curve</strong> 实现非线性变化。</p>
</li>
<li>
<p>当 Flutter 帧刷新时，_tick 方法中通过_simulation 结合时间，lowerBound 和 upperBound 等获取当前值_value 和状态_status 并发出通知。</p>
</li>
<li>
<p>使用者可以通过 AnimationController 继承自父类 <strong>Animation</strong> 的 addListener/removeListener、addStatusListener/removeStatusListener 监听动画的值和状态</p>
</li>
<li>
<p>使用者可以从父类 <code>Animation&lt;double&gt;</code>继承的<code>Animation&lt;U&gt; drive&lt;U&gt;(Animatable&lt;U&gt; child)</code>方法使用 <code>Animatable&lt;U&gt;</code>从 <code>Animation&lt;double&gt;</code>的 animation 创建一个新的<code>Animation&lt;U&gt;</code>，从而可以得到可以随时间变化过渡的 Offset、Size 等动画。</p>
</li>
<li>
<p>stop 方法可以停止动画</p>
</li>
</ul>
<h2> 参考资料</h2>
<p><a href="https://flutter.cn/docs/development/ui/animations" target="_blank" rel="noopener noreferrer">动画效果介绍 flutter.cn</a></p>
<p><a href="https://api.flutter.dev/flutter/animation/Animation-class.html" target="_blank" rel="noopener noreferrer">Animation api.flutter.dev</a></p>
<p><a href="https://api.flutter.dev/flutter/animation/AnimationController-class.html" target="_blank" rel="noopener noreferrer">AnimationController api.flutter.dev</a></p>
<p><a href="https://api.flutter.dev/flutter/scheduler/TickerProvider-class.html" target="_blank" rel="noopener noreferrer">TickerProvider api.flutter.dev</a></p>
<p><a href="https://api.flutter.dev/flutter/scheduler/SingleTickerProviderStateMixin-class.html" target="_blank" rel="noopener noreferrer">SingleTickerProviderStateMixin api.flutter.dev</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_struct2.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 动画分析之 Hero</title>
      <link>https://jixiaoyong.github.io/blog/posts/62beedda.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/62beedda.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 动画分析之 Hero</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 14 Aug 2022 11:14:01 GMT</pubDate>
      <content:encoded><![CDATA[<p>Flutter 中的 Hero 动画是指可以在切换页面时自动跨页面实现 Widget 放大缩小、位移的动画，在用户看起来好像是当前页面的 Widget“飞”入到另外一个页面，底层基于 Overlay 实现。</p>
<p>本文对其原理和应用做一简单分析，主要是对<a href="https://flutter.cn/docs/development/ui/animations/hero-animations" target="_blank" rel="noopener noreferrer">官方介绍</a>的理解与分析，感兴趣的可以直接阅读官方文档。</p>
<h2> 使用</h2>
<h3> 简单使用 Standard hero animations</h3>
<blockquote>
<p>详细的代码可以从<a href="https://gist.github.com/jixiaoyong/8b6584e73abe430d3c1ae926b80a86bd#file-simple_hero_animation-dart" target="_blank" rel="noopener noreferrer">simple_hero_animation.dart</a>获取。</p>
</blockquote>
<p>Hero 动画的使用比较简单：</p>
<ul>
<li>分别在两个 Flutter 页面将需要实现 Hero 动画的 Widget（一般是图片）作为 Hero 控件的 child</li>
<li>为这两个 Hero 指定同一个 tag</li>
<li>Hero 底层基于 Overlay 实现，所有 Hero.child 可以使用 Position 等适用于 Stack.child 的属性</li>
</ul>
<p>这里要注意：</p>
<ul>
<li>这两个 Page 要是<strong>相邻</strong>的页面，否则 Hero 动画不会生效</li>
<li>同一个页面，<strong>不能有多个</strong> Hero.tag 相同的 Hero 控件</li>
<li>Hero 动画<strong>默认只支持大小（size）和位置（location）变化</strong>，所以 Hero.child 不建议有其他变化（Don't rotate your heroes）</li>
</ul>
<p>按照上述的要求，我们再 FirstHeroPage 中添加第一个 Hero Widget：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在要跳转到的第二个页面 SecondHeroPage 添加目标 Hero：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，当从 FirstHeroPage 跳转到 SecondHeroPage 的时候，Hero 动画作用于 Hero.child，看起来好像是前一个页面的 HeroChildWidget 逐渐从 Alignment.bottomLeft 移动到 Alignment.topCenter，并且大小也从 100 逐渐变为 200。</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/hero/simple_hero.gif" alt="Simple Hero Animation" tabindex="0" loading="lazy"><figcaption>Simple Hero Animation</figcaption></figure>
<h4> 原理分析</h4>
<p>那么 Hero 动画是如何实现这个效果的呢？</p>
<p>Flutter 中 Page 之间的跳转由 Navigator 管理，在 Navigator 管理的所有 Flutter Page 的上层有一个叠加层 Overlay，在 Z 轴方向上处于所有 Page 上层，其内部的 widget 可以被独立管理。</p>
<p>以当前 Page 为 A，要跳转的 Page 为 B：</p>
<ul>
<li>
<p>那么当从 A 跳转到 B 时，Hero 动画框架会先隐藏 A 中的 Hero.child 并用相同大小的（不可见）组件占位；</p>
</li>
<li>
<p>与此同时，Hero 动画框架读取要跳转去的 B 中的 Hero.child 并据此创建 Widget，将其大小和位置与为 A 中 Hero.child 对齐，放入到 Overlay 中。同时计算器过渡到 B 中的 Hero.child 位置和大小的路径动画，并执行；</p>
<p>这也是为什么在上一步我们简单的 Hero 动画中，A 向 B 页面切换时过渡的 Widget 中文字虽然是<em>Second</em>，但是样式看起来和页面中的文字样式不一样，这是因为<a href="https://api.flutter-io.cn/flutter/widgets/Overlay-class.html" target="_blank" rel="noopener noreferrer">Overlay（可视为一个特殊的 Stack）</a>上的组件是单独管理的，没有使用我们的 Material 样式。<br>
要解决这个问题也很简单，在 Hero.child 中添加<code>Material</code>组件使其应用样式即可。</p>
</li>
<li>
<p>当 B 创建好之后，Hero 动画正在运行中，所以 B 中的 Hero.child 也会被相同大小的（不可见）组件占位；</p>
</li>
<li>
<p>当 Hero 动画播放完毕之后，位于 Overlay 中的 Widget 被移除，A 和 B 中的 Hero.child 也正常显示。</p>
</li>
<li>
<p>如果又从 B 返回 A 则上述步骤又会反向（A、B 中 Hero.child 换位）执行一次。</p>
</li>
</ul>
<p>下图是 Flutter 官方对 Hero 动画执行的解释，刚好处于由 A 到 B 过渡的过程，可以看到 A、B 页面中的 Widget 都被移除，只有根据目标 Page——B 中的 Hero.child 创建的位于 Overlay 的 Destination hero 控件在从 A 中对应的位置和大小过渡到 B 中对应的位置和大小：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/hero/hero-transition-2.webp" alt="Hero 动画进行中的图解" tabindex="0" loading="lazy"><figcaption>Hero 动画进行中的图解</figcaption></figure>
<h3> 进阶使用 Radial hero animations</h3>
<p>默认实现的 Hero 动画只支持大小和位移变化，通过使用 Radial Transformation（径向转化）可以实现由圆变为正方形的过渡动画。</p>
<blockquote>
<p>径向过渡 是由圆形变成正方形的过渡动画。<br>
—— <a href="https://flutter.cn/docs/development/ui/animations/hero-animations#:~:text=%E5%BE%84%E5%90%91%E8%BF%87%E6%B8%A1%20%E6%98%AF%E7%94%B1%E5%9C%86%E5%BD%A2%E5%8F%98%E6%88%90%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E3%80%82" target="_blank" rel="noopener noreferrer">flutter.cn 官网</a></p>
</blockquote>
<p>径向动画的<em>本质还是 Hero 动画</em>，只不过在 Hero 动画之上做了一层由 ClipOval 和 ClipRect 组成的裁剪遮罩，通过二者的配合，导致其重叠部分的内容看起来好像在 Hero 动画播放的时候在<em>圆</em>和<em>正方形</em>之间切换。</p>
<p>官方的实现为<a href="https://github.com/cfug/flutter.cn/blob/master/examples/_animation/radial_hero_animation_animate_rectclip/main.dart" target="_blank" rel="noopener noreferrer">radial_hero_animation_animate_rectclip</a>，但是为了便于理解径向动画的原理，我们在之前的 Hero 动画的简单使用<a href="https://gist.github.com/jixiaoyong/8b6584e73abe430d3c1ae926b80a86bd" target="_blank" rel="noopener noreferrer">代码</a>基础上进行修改。</p>
<blockquote>
<p>详细的代码可以从<a href="https://gist.github.com/jixiaoyong/8b6584e73abe430d3c1ae926b80a86bd#file-advanced_hero_animation-dart" target="_blank" rel="noopener noreferrer">advanced_hero_animation.dart</a>获取。</p>
</blockquote>
<p>相对于之前的，我们主要将 HeroChildWidget 类修改为 HeroClippedChildWidget 类：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，FirstHeroPage 的 HeroClippedChildWidget.minClipOvalDiameter，SecondHeroPage 中则为 maxClipOvalDiameter。</p>
<p>其效果如图：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/hero/advanced_hero.gif" alt="advanced_hero" tabindex="0" loading="lazy"><figcaption>advanced_hero</figcaption></figure>
<blockquote>
<p>实际上根据此方式，我们也可以监听 Hero.child 的大小、位置变化从而推测出 Hero 动画的进度和方向（是从 from 到 to，还是相反），从而实现更丰富的动画效果。</p>
<p>比如监听进度从而实现旋转：<a href="https://github.com/jixiaoyong/flutter_custom_widget/blob/master/lib/widgets/animation_hero_child.dart" target="_blank" rel="noopener noreferrer">https://github.com/jixiaoyong/flutter_custom_widget/blob/master/lib/widgets/animation_hero_child.dart</a></p>
</blockquote>
<h4> 原理分析</h4>
<p>此类能够实现切换的同时修改 Hero.child 的样式，主要在于 ClipOval 和 ClipRect 的组合效果：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/hero/radial-hero-animation.webp" alt="Radial hero animations 的示意图" tabindex="0" loading="lazy"><figcaption>Radial hero animations 的示意图</figcaption></figure>
<p>ClipRect 的大小固定为<code>var clipRectSize = maxClipOvalDiameter.width * math.sqrt2 / 2</code>，而 ClipOval 的大小则随着 Hero 动画的变化而变化，始终与 HeroClippedChildWidget 保持一致。</p>
<p>假设从页面 A 到 B 切换时 Hero.child 会从小变大，那么：</p>
<ul>
<li>刚刚从页面 A 切换时，位于 Overlay 的 HeroClippedChildWidget/ClipOval 大小为 minClipOvalDiameter（也就是 100*100），此时 ClipRect 的大小 clipRectSize（也就是 200/2*根号 2 约等于 141）大于 ClipOval 的大小，所以他们的相交处为 ClipOval，故而 HeroClippedChildWidget 显示为直径为 100 的圆。</li>
<li>当刚刚完整切换到页面 B，Hero 动画将要结束时，位于 Overlay 的 HeroClippedChildWidget/ClipOval 大小为 maxClipOvalDiameter（也就是 200*200），此时 ClipRect 的大小 clipRectSize（依旧是 141）小于 ClipOval 的大小，所以他们的相交处为 ClipRect，故而 HeroClippedChildWidget 显示为边长约为 141 的正方形。</li>
<li>在二者的过渡阶段，就是 ClipOval 注解从小于 ClipRect 变化为大于 ClipRect 的过程，他们相交的区域也从圆变为圆角，再变为正方形。</li>
</ul>
<h4> 其他属性</h4>
<p>此外，Hero 还有几个属性可以供我们自定义：</p>
<ul>
<li><code>flightShuttleBuilder</code> 替换页面切换时的默认过渡 Widget。比如从页面 A 切换到 B 时，默认是使用 B 中的 Hero.child，如果此值不为 null 则会展示 flightShuttleBuilder 返回的 Widget。</li>
<li><code>placeholderBuilder</code> 当 Hero 动画开始，页面 A、B 中 Hero.child 隐藏时，会展示 placeholderBuilder 返回的内容或者为空（默认）</li>
<li><code>createRectTween</code> 定义 Hero 动画的过渡组件动画渐变的方式，MaterialApp 默认使用 MaterialRectArcTween()，此外还有 MaterialRectCenterArcTween()（可以等比例缩放）、MaterialPointArcTween()。</li>
</ul>
<p>示意图如下：</p>
<figure><img src="https://flutter.github.io/assets-for-api-docs/assets/interaction/heroes.png" alt="flutter.cn 官网 Hero 示意图" tabindex="0" loading="lazy"><figcaption><a href="http://flutter.cn" target="_blank" rel="noopener noreferrer">flutter.cn</a> 官网 Hero 示意图</figcaption></figure>
<h2> 底层实现</h2>
<h3> Hero</h3>
<p>Hero 是一个 StatefulWidget，除了之前提到的各个属性之外，还提供了<code>_allHeroesFor()</code>方法供 HeroController 调用，用于查找指定 Context 下所有的 Hero Widget，并在检测到有重复 Hero.tag 时报错。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> _HeroState</h3>
<p>_HeroState 主要是提供 startFlight/endFlight 供 HeroController-&gt;_HeroFlight-&gt;_HeroFlightManifest 调用；以及根据初始化以及开始/技术 Flight 动画后状态的变化而更改 Hero.child 在屏幕上面（对应页面上原先 Hero Widget 所处位置的区域）的显示效果。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，startFlight/endFlight 方法主要影响的是_placeholderSize 的值，并引发 rebuild：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，Hero 和_HeroState 主要是提供了操纵、统计当前 Page 的 Hero Widget 以及控制其 Hero.child 及占位 Widget 的显示与否，那么在哪里发起和结束 Hero 动画，以及绘制过渡 Widget 的呢？</p>
<h3> _HeroFlightManifest</h3>
<blockquote>
<p>“_HeroFlightManifest：Everything known about a hero flight that's to be started or diverted.”</p>
</blockquote>
<p>_HeroFlightManifest 是一个数据类，主要封装了<code>fromHero</code>/<code>toHero</code>两个_HeroState，并提供 Hero Widget 的位置信息 Rect；此外还封装了过渡动画相关的<code>get animation</code>和<code>createHeroRectTween</code>方法。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> HeroController</h3>
<p>HeroController 真正在路由切换时操作 Hero 动画。</p>
<p>无论是 CupertinoApp 还是 MaterialApp 都提供了创建 HeroController 的静态方法，在他们对应的 State.initState 方法中创建。</p>
<blockquote>
<p>CupertinoTabView 也创建有自己的 HeroController。</p>
</blockquote>
<p>以 MaterialApp 为例：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在_MaterialAppState 中创建并持有 HeroController：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HeroControllerScope 是一个 InheritedWidget，经过上述代码，MaterialApp 内部可以通过<code>HeroControllerScope.of()</code>方法获取到 HeroController。</p>
<p>而在 WidgetsApp 中创建的 Navigator 对应的<code>NavigatorState._updateHeroController</code>方法中会使用其获取 HeroController，并通过<code>HeroController._navigator = this</code>及<code>NavigatorState._updateEffectiveObservers()</code>方法与之绑定。</p>
<p>这样当 Navigator 切换页面时，各个时间都会通知到 HeroController，执行其 didPush/didPop/didRemove/didReplace/didStartUserGesture/didStopUserGesture 等方法，从而触发/终止 Hero 动画。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> _maybeStartHeroTransition</h4>
<p>HeroController 从 NavigatorObserver 继承到的方法中，除了 didStopUserGesture 都会执行 HeroController._maybeStartHeroTransition 方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> _startHeroTransition</h4>
<p>当上述条件满足之后，便可以开始执行 Hero 动画。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> _HeroFlight</h3>
<p>经过上面的分析，最终是在_HeroFlight 方法中真正执行 Hero 动画：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Hero 动画实际播放的过渡动画内容，由_HeroFlight._buildOverlay 根据动画进度创建：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p>Flutter 中 Hero 动画是基于 Overlay 实现的，监听 Navigator 路由变化，从而在不同 Flutter 页面切换时触发的、表现为 Hero.child 从当前页面“飞”到目标页面对应位置，并伴随着位置、大小、透明度等变化的动画。</p>
<p>MaterialApp 或者 CupertinoApp 对应的<code>State.initState</code>方法中创建 HeroController，并通过 HeroControllerScope 提供给前面创建的 WidgetsApp 内部创建的 Navigator 并绑定；这样当路由变化时 HeroController 收到通知并在<code>HeroState._startHeroTransition</code>方法中通过<code>Hero._allHeroesFor</code>方法获取到当前页和目标页面的 Hero 动画组件，将其 Animation、Tween、Rect、_HeroState 等封装到_HeroFlightManifest 中，传递给<code>_HeroFlight.start</code>执行动画，并在<code>_HeroFlight.onTick</code>方法监听处理动画进度，从而导致<code>_HeroFlight._buildOverlay</code>创建的过渡 Widget 位置、大小、透明度等变化，产生 Hero Widget“飞入”的视觉效果。</p>
<h2> 参考资料</h2>
<p><a href="https://flutter.cn/docs/development/ui/animations/hero-animations" target="_blank" rel="noopener noreferrer">主动画 (Hero animations)</a></p>
<p><a href="https://api.flutter-io.cn/flutter/widgets/Hero-class.html" target="_blank" rel="noopener noreferrer">Hero class</a></p>
<p><a href="https://api.flutter-io.cn/flutter/widgets/Overlay-class.html" target="_blank" rel="noopener noreferrer">Overlay class</a></p>
<p><a href="https://github.com/cfug/flutter.cn/blob/master/examples/_animation/radial_hero_animation_animate_rectclip/main.dart" target="_blank" rel="noopener noreferrer">radial_hero_animation_animate_rectclip</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter/hero/simple_hero.gif" type="image/gif"/>
    </item>
    <item>
      <title>Flutter 动画分析之 Tween&amp;Curve</title>
      <link>https://jixiaoyong.github.io/blog/posts/820d6240.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/820d6240.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 动画分析之 Tween&amp;Curve</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 21 Aug 2022 08:28:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>在上篇文章中，我们分析了 Flutter 中主要由<a href="https://jixiaoyong.github.io/blog/posts/6ec43bd8/" target="_blank" rel="noopener noreferrer">AnimationController</a>控制动画的开始、结束，但是默认情况下其只能产生<strong>线性变化的 double 类型的 value</strong>，如果想随时间变化，让 Widget 产生 Size、Offset 等属性的变化，亦或者控制这些值变化的速度快慢，这时候就需要用到 Tween 和 Curve 了。</p>
<p>下图是 Tween/Curve/AnimationController 等类的关系简单示意：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_struct1.png" alt="Flutter 各种动画底层类关系" tabindex="0" loading="lazy"><figcaption>Flutter 各种动画底层类关系</figcaption></figure>
<p>如上图所示：</p>
<ul>
<li><strong>Tween</strong> 和 <strong>CurveTween</strong> 都继承自 <strong>Animatable</strong>，可以按照给定的 Animation&lt;double&gt;生产 T 类型的值，从而可以<em>从 AnimationController 中衍生出其他类型的 Animation</em>；</li>
<li>而 <strong>Curve</strong> 继承自 <em>ParametricCurve</em>，除了之前文章中分析的传入 <code>AnimationController.animateTo</code> 和 <code>AnimationController.animateBack</code> 中从而作用于其创建的<code>_InterpolationSimulation.x()</code>方法之外，也可以被传入 CurveTween 或 CurvedAnimation 中，将 Curve 应用于 AnimationController。</li>
</ul>
<p>上述关于 Tween 和 CurveTween 和 AnimationController 作用的方式，其实现都是依赖于 <code>Animation&lt;T&gt; Animatable.animate(Animation&lt;double&gt; parent)</code> 方法，根据传入的 Animation&lt;double&gt;（一般会是 AnimationController 对象）创建新的 Animation&lt;T&gt;（实际上是继承自 Animation 的_AnimatedEvaluation，其 Animation.value 取自 <code>Animatable.evaluate(Animation&lt;double&gt;)</code>）。</p>
<h2> 源码分析</h2>
<h3> Animatable</h3>
<blockquote>
<p>An object that can produce a value of type <code>T</code> given an <code>Animation&lt;double&gt;</code> as input.</p>
</blockquote>
<p>Animatable 根据传入的<code>Animation&lt;double&gt;</code>对象创建 T 类型的对象，也就是说其<em>将 Animation 产生的 double 类型“转化”为 T 类型</em>，从而使得 Flutter 支持更加丰富的动画。</p>
<blockquote>
<p>一般情况下这个<code>Animation&lt;double&gt;</code>的值范围是[0.0,1.0]，但是也可能超出此范围。</p>
</blockquote>
<p>而这一切都通过他的<code>animate</code>方法实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此方法中，将接收 Animation&lt;double&gt;对象作为<code>parent</code>，将自身作为<code>_evaluatable</code>属性创建了 Animation 的子类_AnimatedEvaluation 并返回：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看一下 Animatable 的源码：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其<code>evaluate</code>方法内部通过其唯一的抽象方法<code>transform</code>方法实现，Animatable 的各个子类也只需要实现<code>transform</code>方法即可。</p>
<p>除了上述与 Animation 有关的三个方法外，Animatable 还有一个链接两个 Animatable 的方法——<code>Animatable.chain()</code>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与 Animatable.animate 方法类似，不同的是此方法返回的是 Animatable&lt;T&gt;的子类——_ChainedEvaluation</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以此方法作用是结合两个 Animatable 的效果。</p>
<br>
<p>Animatable 的主要作用是根据传入的 Animation 创建对应的 T 类型的值；其主要的子类有 Tween、CurveTween、TweenSequence。</p>
<p>TweenSequence 的作用于_chainedEvaluation 类似，只不过它可以将多个 Animatable 按照所占比重 weight 在 Animatable.transform 中应用。</p>
<h3> Tween</h3>
<blockquote>
<p>A linear interpolation (插值) between a beginning and ending value.</p>
</blockquote>
<p>Tween 是 Animatable 的主要子类之一，作用根据传入的 Animation（通常是 AnimationController）是在传入的<strong>begin 和 end 值之间创建线性的插值</strong>。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 Tween 的源码可以看到，它实现了父类 Animatable.transform 方法，并在 t 在 (0.0,1.0) 之间时调用 Tween.lerp 方法获取对应的值，默认线性的在 T 上应用加减乘运算，并返回结果。Tween 的子类只需要重写 Tween.lerp 方法而非 Animatable.transform 方法。</p>
<p>这也就要求：</p>
<ul>
<li>
<p>支持 <code>lerp</code> 静态方法的类通常有对应的 Tween 子类，一般以 <em>FooTween</em> 命名，比如 ColorTween 就是借助 Color.lerp 方法实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><em>Tween&lt;T&gt;</em> 的类型 T 必须支持<code>+-*</code>三种运算，并且返回值还是 T；</p>
</li>
<li>
<p>对于 int 来说，因为 int*double=num 而非 int，有对应的特殊类：</p>
<ul>
<li>IntTween，使用 double.round 实现近似线性插值</li>
<li>StepTween，使用 double.floor 确保结果永远不会大于使用 Tween&lt;double&gt;的值</li>
</ul>
</li>
</ul>
<p>在使用时，如果 Tween 确定不会变化，就可以将其保存在<code>static final</code>对象中以便在需要的地方共享同一个对象，而非在 State.build 方法中实时创建。</p>
<h3> CurveTween</h3>
<p>CurveTween 继承自 Animatable&lt;double&gt;，常见的用法是传入<code>AnimationController.drive</code>方法中获取一个新的 Animation&lt;double&gt;:</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Tween 和 CurveTween 的主要区别在于，Tween 需要 T？类型的 begin 和 end 来创建线性插值，而 CurveTween 则需要 Curve 以便为 Animation&lt;double&gt;创建（非）线性插值。</p>
<h3> Curve</h3>
<p>ParametricCurve&lt;T&gt;是 Curve 的父类，其提供 ParametricCurve.transform 方法将 double t（在[0.0,1.0]之间）转化为曲线在 t 处对应的值 T t：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从其源码可以看出，ParametricCurve.transform 主要是检查入参是否合规，其主要逻辑在 ParametricCurve.transformInternal 中，一般子类只需要实现后者即可。</p>
<p>Curve 继承自 ParametricCurve&lt;double&gt;，也就是说它只能产生 double 类型的插值：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Curve 重写了父类的 transform 方法以规范对 double t 的处理，但还是建议子类只需要实现 <code>ParametricCurve.transformInternal</code> 方法。</p>
<p>我们以 Curve 的子类_Linear 为例，查看实现 Curve 的过程：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总的来说，Curve 及其子类定义了一个曲线（可能是线性变化，也可能不是），并提供了<code>double Curve.transform(double t)</code>供使用者获取指定时间 double t 时曲线上对应的值 double。</p>
<p>Flutter 为我们预置了很多丰富的 Curve，可以在这里预览：<br>
<a href="https://api.flutter.dev/flutter/animation/Curves-class.html" target="_blank" rel="noopener noreferrer">Curves</a>。</p>
<h2> 总结</h2>
<p>经过上述分析，我们可以知道，无论是 Tween 还是 CurveTween，作为 Animatable，他们提供了<code>Animation&lt;T&gt; Animatable.animatee(Animation&lt;double&gt; parent)</code>方法，可以返回一个新的，相当于使用<code>Animatable&lt;T&gt;.transform(double parent.value)</code>计算<code>Animation&lt;T&gt;.value</code>的，Animation&lt;T&gt;。</p>
<p>而 Curve，只能通过<code>double transform(double t)</code>计算曲线在 t 位置的值的类，一般可以在 CurveTween、CurveAnimation 的构造方法或者 AnimationController 的 animateTo/animateBack 方法中，以便产生非线性的动画。</p>
<h2> 参考资料</h2>
<p><a href="https://api.flutter.dev/flutter/animation/Animatable-class.html" target="_blank" rel="noopener noreferrer">Animatable api.flutter.dev</a></p>
<p><a href="https://api.flutter.dev/flutter/animation/Tween-class.html" target="_blank" rel="noopener noreferrer">Tween api.flutter.dev</a></p>
<p><a href="https://api.flutter.dev/flutter/animation/CurveTween-class.html" target="_blank" rel="noopener noreferrer">CurveTween api.flutter.dev</a></p>
<p><a href="https://api.flutter.dev/flutter/animation/Curve-class.html" target="_blank" rel="noopener noreferrer">Curve api.flutter.dev</a></p>
<p><a href="https://api.flutter.dev/flutter/animation/Curves-class.html" target="_blank" rel="noopener noreferrer">Curves api.flutter.dev</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_struct1.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 图片加载方案分析之 Image</title>
      <link>https://jixiaoyong.github.io/blog/posts/1912667a.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/1912667a.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 图片加载方案分析之 Image</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 27 Jul 2022 07:31:03 GMT</pubDate>
      <content:encoded><![CDATA[<p>Flutter 默认提供了<strong>Image</strong>用于从网络、文件等加载图片，并且使用<strong>ImageCache</strong>统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了<a href="https://github.com/Baseflow/flutter_cached_network_image" target="_blank" rel="noopener noreferrer">flutter_cached_network_image</a>、<a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">extended_image</a>等基于 Flutter 原生的解决方案，以及<a href="https://github.com/alibaba/power_image" target="_blank" rel="noopener noreferrer">power_image</a>等基于混合开发的解决方案。</p>
<p>本文对 Flutter 中的 Image 加载过程、原理做一简单分析。</p>
<h2> 图片展示的流程</h2>
<p>首先，简单梳理一下图片从加载到展示的过程。</p>
<h3> Image</h3>
<p><em><code>A widget that displays an image.</code></em></p>
<p>在查看 Image 具体实现之前，先了解几个基础方法：</p>
<ul>
<li><code>ImageConfiguration createLocalImageConfiguration(BuildContext context, { Size? size })</code> ：创建 <strong>ImageConfiguration</strong>，一般用于 <code>state.didChangeDependencies</code> 等依赖变化时会调用的地方，其创建的 ImageConfiguration 对象会传入 <code>BoxPainter.paint</code> 或者 <code>ImageProvider.resolver</code> 方法中以用来获取 <strong>ImageStream</strong>。</li>
<li><code>Future&lt;void&gt; precacheImage(...)</code> 预先加载 image 到 <strong>ImageCache</strong> 中，以便 Image、BoxDecoration、FadeInImage 等能够更快地加载 image。</li>
</ul>
<p>Image 是 Flutter 中用于展示图片的 Widget，主要有如下用法：</p>
<ul>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.html" target="_blank" rel="noopener noreferrer">Image.new</a>, for obtaining an image from an&nbsp;<a href="https://api.flutter.dev/flutter/painting/ImageProvider-class.html" target="_blank" rel="noopener noreferrer">ImageProvider</a>.</li>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.asset.html" target="_blank" rel="noopener noreferrer">Image.asset</a>, for obtaining an image from an&nbsp;<a href="https://api.flutter.dev/flutter/services/AssetBundle-class.html" target="_blank" rel="noopener noreferrer">AssetBundle</a>&nbsp;using a key.</li>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.network.html" target="_blank" rel="noopener noreferrer">Image.network</a>, for obtaining an image from a URL.</li>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.file.html" target="_blank" rel="noopener noreferrer">Image.file</a>, for obtaining an image from a&nbsp;<a href="https://api.flutter.dev/flutter/dart-io/File-class.html" target="_blank" rel="noopener noreferrer">File</a>.</li>
<li><a href="https://api.flutter.dev/flutter/widgets/Image/Image.memory.html" target="_blank" rel="noopener noreferrer">Image.memory</a>, for obtaining an image from a&nbsp;<a href="https://api.flutter.dev/flutter/dart-typed_data/Uint8List-class.html" target="_blank" rel="noopener noreferrer">Uint8List</a>.</li>
</ul>
<p>支持的格式有：JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP，以及依赖于特定设备的格式（Flutter 会尝试使用平台 API 解析未知格式）。</p>
<p>通过指定<code>cacheWidth</code>和<code>cacheHeight</code>可以让引擎按照指定大小解码图片，可以降低 ImageCache 占用的内存。</p>
<p><code>Image(...)</code>构造函数中只有一个必传项<code>ImageProvider image</code>用于获取图片，其余四种构造方法也都是在此方法的基础上分别指定了各自的 <strong>ImageProvider</strong>，以<code>Image.network</code>为例：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的 ResizeImage，NetworkImage 等都继承自 <strong>ImageProvider</strong>，<code>ImageProvider.resolve</code>方法创建并返回 <strong>ImageStream</strong> 供 <strong>Image</strong> 使用，内部通过<code>ImageProvider.resolveStreamForKey</code>方法从 <strong>ImageCache</strong> 或者子类指定的途径（比如 NetworkImage 会从网络）加载图片（并保存到 ImageCache）。</p>
<h3> _ImageState</h3>
<p><strong>Image</strong>是 <em>StatefulWidget</em>，处理 image 的主要逻辑在 <strong>_ImageState</strong> 中：其混入了<strong>WidgetsBindingObserver</strong>以便监听系统生命周期；在内部通过监听<strong>ImageStream</strong>获得<strong>ImageInfo</strong>并最终在<code>_ImageState.build</code>方法中创建<strong>RawImage</strong>；RawImage 是一个<em>LeafRenderObjectWidget</em>，会创建<strong>RenderImage</strong>并在<code>RenderImage.paint</code>根据之前获取的信息调用<code>DecorationImagePainter.paintImage</code>方法通过<code>canvas.drawImageRect</code>绘制图片。</p>
<h4> _resolveImage</h4>
<p>当依赖变化（<code>didChangeDependencies()</code>）、Widget 变化（<code>didUpdateWidget(Image oldWidget)</code>）、以及热更新（<code>reassemble()</code>）时，_ImageState 会执行<code>_resolveImage()</code>方法通过 ImageProvider 获取 ImageStream：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还可以注意到，当在<code>_resolveImage()</code>中获取到 ImageStream 之后，会通过<code>_updateSourceStream()</code>更新 ImageStream。</p>
<h4> _updateSourceStream</h4>
<p>在此方法中，先是更新了<code>ImageStream? _imageStream</code> 对象，然后根据<code>_isListeningToStream</code>的值执行<code>_imageStream!.addListener(_getListener())</code>更新 ImageStream 的 Listener：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在 <strong>ImageStreamListener</strong> 中，根据 ImageStream 的不同状态分别更新 Image 的显示。</p>
<h4> _handleImageFrame</h4>
<p><code>_handleImageFrame()</code>方法使用 ImageStream 中返回的<strong>ImageInfo</strong>，调用<code>setState</code>方法更新_ImageState 中的<code>ImageInfo? **_imageInfo**</code>属性，从而刷新 Image 展示。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ImageInfo</strong>类内部持有<strong>ui.Image</strong>和其对应的<code>scale</code>，以及一个获取图片像素大小的<code>sizeBytes</code>方法。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> build</h4>
<p>上面分析了_ImageState 如何监听使用 ImageProvider 获取到的 ImageStream，从中获取 ImageInfo 更新自己的 <code>ImageInfo? _imageInfo</code> 属性，那么这个属性是如何影响到我们的 Image 展示图片的呢，关键就在 <code>build</code> 方法中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ImageInfo.image</code> 是<strong>ui.Image</strong>对象，是原始的 image 像素，通过<strong>RawImage</strong>传入到<code>Canvas.drawImageRect</code>或者<code>Canvas.drawImageNine</code>绘制图片。</p>
<h3> RawImage</h3>
<p><em>A widget that displays a <code>[dart:ui.Image]</code> directly.</em></p>
<p>RawImage 继承自 <em>LeafRenderWidget</em>，可以直接展示<code>ui.Image</code>的内容，后者是解码的图片数据的不透明句柄（<em>Opaque handle to raw decoded image data (pixels)</em>）、是对<code>_Image</code>类的封装、对外提供宽高以及<code>Image.toByteData</code>（将<code>ui.Image</code>对象转化为<code>ByteData</code>，ByteData 可以直接传入<code>Canvas.drawImageRect</code>方法第一个参数）。</p>
<p>RawImage 主要逻辑就是创建/更新 RenderImage 的时候将从<code>_ImageState.build</code>方法获得的<code>ui.Image? image</code> 的 clone 传入（其实就是使用<code>ui.Image? image</code>对应的<code>_Image _image</code> 新建了一个 ui.Image，每一个 ui.Image 都是_image 的一个句柄，只有当没有 ui.Image 指向_image 时后者才会真正的 dispose）。</p>
<h3> RenderImage</h3>
<p><em>An image in the render tree.</em></p>
<p>RenderImage 作为一个 RenderBox，在从 RawImage 那里拿到<code>ui.Image? _image</code>之后，然后在其<code>RenderImage.paint</code>方法中，会调用<code>paintImage</code>方法绘制<code>_image</code>代表的图片。</p>
<blockquote>
<p>ui.Image 实际是 ui._Image 的包装类，它的 width、height、toByteData 等方法最终都是调用 ui._Image 对应的实现。</p>
</blockquote>
<p><code>paintImage</code> 方法是位于 <em>lib\src\painting\decoration_image.dart</em> 的全局方法，在其内部调用 canvas 绘制_image 对应的图片。</p>
<br>
<p>至此，我们可以看到，在<strong>Image</strong>中，根据构造方法的不同创建了不同的<strong>ImageProvider</strong>对象作为<code>Image.image</code>参数；</p>
<p>然后在 <strong>_ImageState</strong> 中，使用<code>ImageProvider.resolve</code>方法创建并更新<code>ImageStream? _imageStream</code>，并且监听<strong>ImageStream</strong>以便在图片加载成功之后获取<code>ImageInfo? _imageInfo</code>；</p>
<p>这个<strong>ImageInfo</strong>是对<strong>ui.Image</strong>的封装类，在<code>_ImageState.build</code>方法中被传入<strong>RawImage</strong>，后者则创建了<strong>RenderImage</strong>并最终将 ui.Image 的内容绘制在屏幕上面。</p>
<br>
<h2> 图片获取与缓存</h2>
<p>到目前为止，我们大体梳理了图片展示的这部分流程，此外，还有一部分同样重要的流程——图片的获取与缓存。</p>
<h3> ImageProvider</h3>
<p><strong>ImageProvider</strong> 是获取图片资源的基类，其他类可以调用<code>ImageProvider.resolve</code>方法获取 <strong>ImageStream</strong> ，此方法会调用<code>ImageCache.putIfAbsent</code>优先从 <strong>ImageCache</strong> 中获取，如果没有则调用<code>ImageProvider.load</code>方法获取并缓存到 ImageCache 中。</p>
<p>其子类一般只需要重写<code>ImageProvider</code>的<code>ImageStreamCompleter load(T key, DecoderCallback decode)</code>和<code>Future&lt;T&gt; obtainKey(ImageConfiguration configuration)</code>方法即可。</p>
<p>以<code>NetworkImage</code>加载网络图片的过程为例：</p>
<blockquote>
<p>我们通过<code>NetworkImage()</code>方法获取的实际是<code>network_image.NetworkImage</code>对象。</p>
</blockquote>
<p>当<code>_ImageState._resolveImage()</code>方法调用<code>ImageProvider.resolve</code>方法时，内部会调用<code>ImageProvider.resolveStreamForKey</code>方法，在其内部会执行：</p>
<ul>
<li>通过<code>ImageProvider.obtainKey</code>获取图片对应的 key</li>
<li>执行<code>PaintingBinding.*instance*!.imageCache!.putIfAbsent(key,() =&gt;</code> <code>load(key, PaintingBinding.*instance*!.instantiateImageCodec),onError: handleError,)</code>方法，优先从 imageCache 中获取缓存的图片，没有的话执行<code>ImageProvider.load</code>方法获取图片。</li>
</ul>
<p>对于<code>network_image.NetworkImage</code>对象，他的<code>obtainKey()</code>和<code>load()</code>方法实现如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这其中，<code>network_image.NetworkImage._loadAsync()</code>方法才是真正使用<code>HttpClient</code>从网上获取图片资源的方法（实际上 AssetBundleImageProvider、FileImage 和 MemoryImage 等一众 ImageProvider 等都约定俗成在<code>_loadAsync</code> 中执行真正获取图片的逻辑），返回值 Future&lt;ui.Codec&gt;和 ui.Image 的关系如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> ImageCache</h3>
<p><em>Class for caching images.</em></p>
<p>在上面方分析 ImageProvider 的时候，我们注意到，每次通过<code>ImageProvider.resolveStreamForKey</code>方法获取 ImageStream 时，都会调用<code>PaintingBinding.instance!.imageCache.putIfAbsent</code>方法优先获取<strong>Image 对象的缓存</strong>，这就涉及到和 Image 缓存有关的类——<strong>ImageCache</strong>。</p>
<p>ImageCache 对象全局唯一，使用 LRU 算法最多缓存<strong>1000 张或者最大 100MB 图片</strong>，可以分别使用<code>maximumSize</code>和<code>maximumSizeBytes</code>修改配置。</p>
<p>其内部维持有三个 Map：</p>
<ul>
<li><code>Map&lt;Object, PendingImage&gt; _pendingImages</code> 正在加载中的图片，可能可能同时也是<code>_liveImage</code>（对应的 ImageStream 已经被监听了）。</li>
<li><code>Map&lt;Object, _CachedImage&gt; _cache</code> 缓存的图片，maximumSize 和 maximumSizeBytes 限制针对的是<code>_cache</code>。</li>
<li><code>Map&lt;Object, _LiveImage&gt; _liveImages</code> 正在使用的图片，他的 ImageStreamCompleters 至少有一个 listener，可能同时在<code>_pendingImages</code>（所以这里的_LiveImage 的<code>sizeBytes</code>可能为 null）或者<code>_liveImages</code>中。</li>
</ul>
<p><code>_CachedImage</code>和<code>_LiveImage</code>都继承自<code>_CachedImageBase</code>，其内部持有<code>ImageStreamCompleter</code>，图片的 handler<code>ImageStreamCompleterHandle</code>，以及图片大小<code>sizeBytes</code>。</p>
<p><code>ImageCacheStatus</code>处理 ImageCache 缓存的图片状态：</p>
<ul>
<li><code>pending</code>，还没有加载完成的 image，如果被监听的话，还会是<code>live</code>的</li>
<li><code>keepAlive</code>，图片会被<code>ImageCache._cache</code>保存。可能是 live 的，但不会 pending 的。</li>
<li><code>live</code>，图片会一直被持有，除非<code>ImageStreamCompleter</code>没有 listener 了。可能是 pending 的，也可能是 keepAlive 的</li>
<li><code>untracked</code>，不会被缓存的图片（上述三值都为 false）。</li>
</ul>
<p>可以使用<code>ImageCache.statusForKey</code>或者<code>ImageProvider.obtainCacheStatus</code>获取图片状态<code>ImageCacheStatus</code>。</p>
<p>此外，ImageCache 还提供<code>ImageCache.evict</code>方法从缓存中清除指定图片。</p>
<h4> putIfAbsent</h4>
<p>当 ImageProvider 调用<code>ImageCache.putIfAbsent</code>方法获取 ImageStreamCompleter 时，会依次尝试从<code>_pendingImages</code> 、<code>_cache</code> 、<code>_liveImages</code> 中读取，如果都没有则会尝试执行传入的 loader 方法获取。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过上述分析可以知道，当_cache、_liveImages、_pendingImages 中都没有指定图片时，会从网络下载（或者磁盘、asset 等），而在图片完全加载完成之前，_pendingImages 中下载图片所占大小是没有被 ImageCache 追踪的，也就是说<strong>ImageCache._cache 的最大个数和总大小限制都不会管理这部分图片</strong>；故而面对大量高清大图加载的场景（比如，五列 1:1 网格加载平均大小几 Mb 的网络图片），如果<strong>快速滑动</strong>会导致_pendingImages 急速增大，这样下载中且还未完全下载的图片所占用的内存会逐渐累计，从而导致 Flutter APP<strong>内存暴增，页面卡顿</strong>等（本地资源不容易出现是因为从 load 到图片加载完成间隔比较短，而网络图片由于网速等导致_pendingImages 中会累计很多正在下载中的图片，会比较明显）。</p>
<p>那些在 Flutter 中加载图片并且完全采用 ImageCache 管理图片内存的图片加载框架比如 Image/ExtendedImage/CachedNetworkImage 等都存在此问题；阿里的 PowerImage 由于将图片下载这个过程交给了原生成熟的图片加载库处理，使得 ImageCache 只管理已经加载完成的图片，从而避免了上述情况。</p>
<br>
<p>可以看到，以从网络加载图片为例，Flutter 原生提供的 Image 只有内存中的 ImageCache 一级缓存，如果 ImageCache 没有指定的图片（首次加载或者缓存被清空）则会再次从网络加载，这会导致多图列表的时候图片被频繁的回收/重新下载，从而影响用户体验。</p>
<p>为了解决上述问题，涌现了很多第三方图片加载控件：</p>
<ul>
<li><a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">extended_image</a> 对官方 Image 的二次开发，增加了磁盘缓存。</li>
<li><a href="https://github.com/Baseflow/flutter_cached_network_image" target="_blank" rel="noopener noreferrer">flutter_cached_network_image</a> 使用<em>sqflite 数据库</em>管理缓存的<strong>网络图片加载</strong>库，增加了磁盘缓存。</li>
<li><a href="https://github.com/alibaba/power_image" target="_blank" rel="noopener noreferrer">power_image</a> 使用于<strong>混合项目</strong>的图片加载库，提供<em>ffi</em>和<em>texture</em>两种图片展示方式，依赖于原生图片加载库（比如<em>Glide</em>）加载图片、管理缓存。</li>
</ul>
<h2> 总结</h2>
<p>简单总结一下 Flutter 原生 Image 组件加载图片的流程：</p>
<figure><img src="https://jixiaoyong.github.io/images/flutter_image_class_structure.png" alt="flutter_image_class_structure.png" tabindex="0" loading="lazy"><figcaption>flutter_image_class_structure.png</figcaption></figure>
<p>简单来说如下：</p>
<ul>
<li>用户通过 Image Widget 的各个构造方法创建指定的 ImageProvider；</li>
<li>在_ImageState 中使用<code>ImageProvider.resolve(ImageConfiguration)</code>获取并监听 ImageStream（listener 为 ImageStreamListener）；</li>
<li>ImageProvider 会按照传入的 ImageConfiguration 生成的 key 在 ImageCache 中查找对应的缓存，没有的话则先加载再缓存；</li>
<li>当 ImageProvider 成功加载图片时，ImageStreamListener 获得 ImageInfo 时，并触发<code>_ImageState.build()</code>方法将<code>ui.Image _imageInfo?.image</code>传入 RawImage 中；</li>
<li>作为一个 LeafRenderObjectWidget，RawImage 创建 RenderImage 并传入<code>ui.Image? image?.clone()</code>作为<code>RenderImage.image</code>，此后再在<code>RenderImage.paint</code>方法中调用系统的<code>paintImage()</code>方法通过<code>canvas.drawImageRect</code>绘制图片内容。</li>
</ul>
<h2> 参考资料</h2>
<p><a href="https://api.flutter.dev/flutter/widgets/Image-class.html" target="_blank" rel="noopener noreferrer">Image_api.flutter.dev</a><br>
<a href="https://mp.weixin.qq.com/s/alglGvnNKIzr7f8SwRZucA" target="_blank" rel="noopener noreferrer">京东在 Flutter 加载大量图片导致的内存溢出的优化实践</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter_image_class_structure.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 图片加载方案分析之 extended_image</title>
      <link>https://jixiaoyong.github.io/blog/posts/23ac516a.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/23ac516a.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 图片加载方案分析之 extended_image</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 01 Aug 2022 09:42:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>Flutter 默认提供了<strong>Image</strong>用于从网络、文件等加载图片，并且使用<strong>ImageCache</strong>统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了<a href="https://github.com/Baseflow/flutter_cached_network_image" target="_blank" rel="noopener noreferrer">flutter_cached_network_image</a>、<a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">extended_image</a>等基于 Flutter 原生的解决方案，以及<a href="https://github.com/alibaba/power_image" target="_blank" rel="noopener noreferrer">power_image</a>等基于混合开发的解决方案。</p>
<p>本文对 extended_image 加载过程、原理做一简单分析。</p>
<h2> extended_image</h2>
<p><a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">extended_image</a>是基于官方 Image 的拓展组件，支持加载以及失败显示，缓存网络图片，缩放拖拽图片，图片浏览 (微信掘金效果)，滑动退出页面 (微信掘金效果)，编辑图片 (裁剪旋转翻转)，保存，绘制自定义效果等功能。</p>
<p>本文主要对其<strong>加载缓存网络图片</strong>的流程做一分析，因为这个库是官方 Image 的拓展，所以我们会在之前<a href="https://jixiaoyong.github.io/blog/posts/1912667a.html" target="_blank" rel="noopener noreferrer">对 Image 的分析</a>基础上进行对比分析。</p>
<p>extended_image 的架构图如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/extended_image_class_structure.png" alt="extended_image_class_structure" tabindex="0" loading="lazy"><figcaption>extended_image_class_structure</figcaption></figure>
<h2> 分析</h2>
<p>因为 extended_image 的定位是官方 Image 的拓展版，所以大部分使用方式和官方类似。</p>
<h3> ExtendedImage</h3>
<p>他的构造函数分别是：</p>
<ul>
<li>ExtendedImage</li>
<li>ExtendedImage.asset</li>
<li>ExtendedImage.file</li>
<li>ExtendedImage.memory</li>
<li>ExtendedImage.network</li>
</ul>
<p>同样是在构造函数中指定并创建 ImageProvider，不过 extented_image 库的 ImageProvider 都是继承自官方 ImageProvider 并且混入了<strong>ExtendedImageProvider</strong>的子类。以<code>ExtendedImage.network</code>为例，创建的 ImageProvider 类型是<strong>ExtendedNetworkImageProvider</strong>。</p>
<p>其余的步骤和我们之前分析的官方 Image 组件类似，在 <strong>_ExtendedImageState</strong> 中使用 <strong>ImageProvider</strong> 获取并监听 <strong>ImageStream</strong>，当成功加载图片之后获得<code>ImageInfo? _imageInfo</code>并刷新页面，在<code>_ExtendedImageState.build</code>方法中，虽然 extended_image 增加了一些特有的加载中、加载失败、手势等封装，但最后还是使用<code>ImageInfo.image</code>创建<strong>ExtendedRawImage</strong>以展示图片内容。</p>
<p>如此可见，在从网络加载图片这部分内容来看，ExtendedImage 和 Image 的主要不同在于<strong>ExtendedNetworkImageProvider</strong>的实现：</p>
<h3> ExtendedNetworkImageProvider</h3>
<blockquote>
<p>这部分内容的代码在<a href="https://github.com/fluttercandies/extended_image_library" target="_blank" rel="noopener noreferrer">extended_image_library</a>中。</p>
</blockquote>
<p>ExtendedNetworkImageProvider 继承自<strong>ImageProvider</strong>，混入了<strong>ExtendedImageProvider</strong>，后者提供了<code>get imageCache</code>/<code>instantiateImageCodec</code>/<code>resolveStreamForKey</code>等一系列通用方法。</p>
<p>下面是 ExtendedNetworkImageProvider 的源码：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ExtendedNetworkImageProvider 是个抽象类，他的逻辑在<code>network_image.ExtendedNetworkImageProvider</code>中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码可以看到，如果需要缓存时，除了 ImageCache 本身的缓存外，ExtendedNetworkImageProvider 还会执行<code>_loadCache</code>尝试从本地文件中读取缓存：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中执行到的<code>ExtendedNetworkImageProvider._loadNetwork()</code>方法只会使用<code>HttpClient</code>从网络中下载图片并返回。</p>
<h3> ExtendedImageProvider</h3>
<p>此外，之前提到的<code>ExtendedImageProvider</code>为 extended_image 库中的 ImageProvider 提供了一些通用的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，还改动了<code>ExtendedImageProvider.resolveStreamForKey</code>方法以使用指定的 ImageCache。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>综上所见，ExtendedImageProvider 的主要作用是借助<code>rawImageDataMap</code>提供了缓存图片原始数据的功能，此外还提供了一个 ImageCache 分组的方法，以便对一部分图片缓存统一处理。</p>
<h2> 总结</h2>
<p>仅就从网络加载图片而言，extended_image 和 Flutter 官方 Image 组件的主要区别在于：在 ImageCache 之外，<strong>多了一层本地磁盘缓存</strong>，如果这二者都未命中缓存则从网络下载图片。</p>
<p>除此之外，extended_image 本身还提供了诸如图片缩放拖拽、滑动退出等图片操作常用的“大而全”的功能。这部分见仁见智，如果 APP 需求刚好需要用到这些功能的话，extended_image 是个不错的选择，但是如果只是想解决图片缓存问题的话，可能会显得有些臃肿。</p>
<p>另外一个常用的图片库<a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">flutter_cached_network_image</a>则是借助<a href="https://github.com/Baseflow/flutter_cache_manager" target="_blank" rel="noopener noreferrer">flutter_cache_manager</a>实现缓存网络图片的功能，相对比较轻量。</p>
<p>上述两种库都是基于 Flutter Image 组件实现图片加载、缓存，阿里巴巴出品的<a href="https://github.com/alibaba/power_image" target="_blank" rel="noopener noreferrer">power_image</a>则是一款为 Flutter-Native 混合项目开发的图片加载库，借助 Texture 和 ffi 通过 Native 端已有的图片加载库完成图片加载、缓存的功能，Flutter 端只负责展示（以及 ImageCache 缓存）。</p>
<h2> 参考资料</h2>
<p><a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">extended_image</a></p>
<p><a href="https://github.com/fluttercandies/extended_image_library" target="_blank" rel="noopener noreferrer">extended_image_library</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/extended_image_class_structure.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 图片加载方案分析之 power_image</title>
      <link>https://jixiaoyong.github.io/blog/posts/727d7800.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/727d7800.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 图片加载方案分析之 power_image</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 02 Aug 2022 07:54:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>Flutter 默认提供了<strong>Image</strong>用于从网络、文件等加载图片，并且使用<strong>ImageCache</strong>统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了<a href="https://github.com/Baseflow/flutter_cached_network_image" target="_blank" rel="noopener noreferrer">flutter_cached_network_image</a>、<a href="https://github.com/fluttercandies/extended_image" target="_blank" rel="noopener noreferrer">extended_image</a>等基于 Flutter 原生的解决方案，以及<a href="https://github.com/alibaba/power_image" target="_blank" rel="noopener noreferrer">power_image</a>等基于混合开发的解决方案。</p>
<p>本文对 Alibaba 中的 power_image 加载过程、原理做一简单分析。</p>
<h2> power_image</h2>
<p><em>power_image</em>是阿里巴巴出品的 Flutter 混合开发图片加载库，通过<em>texture</em>和<em>ffi</em>技术借助原生图片加载库加载图片、Flutter 端展示图片。</p>
<p>无论是 Flutter <a href="https://jixiaoyong.github.io/blog/posts/1912667a/" target="_blank" rel="noopener noreferrer">Image</a> 组件，还是第三方的<a href="https://jixiaoyong.github.io/blog/posts/23ac516a/" target="_blank" rel="noopener noreferrer"><em>extende_image</em></a>、<em>flutter_cached_nework_image</em>都是在 Flutter 端加载解析图片，这些方案对一般纯 Flutter 开发的 APP 来说基本可以满足要求，但是对于大多数混合开发的 APP 来说，这些方案会在 Flutter 和 Native 同时存在两份图片资源造成内存浪费，此外根据<a href="https://mp.weixin.qq.com/s/yUm4UFggYLgDbj4_JCjEdg#at" target="_blank" rel="noopener noreferrer">贝壳的分析</a>，Flutter 端解决方案存在图片内存释放时机（Flutter 引擎持有的 SkImage 释放时机）以及超大图内存峰值等问题。</p>
<p>而<em>power_image</em>能够较好的解决上述问题，其整体架构如下：</p>
<p>类结构图：<br>
<img src="https://jixiaoyong.github.io/images/flutter/power_image_class_structure.png" alt="类结构图" loading="lazy"></p>
<p>架构图：<br>
<img src="https://jixiaoyong.github.io/images/flutter/power_image_structure.png" alt="架构图" loading="lazy"></p>
<p><em>power_image</em>可以大体划分为<strong>Flutter 端图片展示</strong>和<strong>Native 图片加载</strong>两部分，下面分别分析。</p>
<h2> Flutter 端图片展示</h2>
<h3> PowerImage</h3>
<p><code>PowerImage</code>继承自<em>StatefulWidget</em>，提供多种创建方式：既可以使用预设的<code>PowerImage.network</code>、<code>PowerImage.file</code>等构造函数从网络、文件等获取图片；也可以使用<code>PowerImage.type</code>、<code>PowerImage.options</code>等自定义通道获取图片并展示；或者使用<code>PowerImage()</code>完全自定义。</p>
<p>除了<code>PowerImage()</code>构造函数之外，上述其余构造函数都根据传入的<code>String? renderingType</code>指定了 PowerImage 特定的<code>PowerImageProvider image</code>属性（是<em>ffi</em>还是<em>texture</em>）用于获取图片。</p>
<h3> PowerImageState</h3>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 PowerImageState 的<code>build()</code>方法中，根据不同的<code>PowerImageProvider image</code>类型会返回不同的 Widget：</p>
<ul>
<li><code>image</code>是 <strong><em>PowerTextureImageProvider</em></strong> 类型：采用 <em>texture</em> 模式展示图片，返回**<em>PowerTextureImage</em><strong>，最终会返回经过封装的</strong><em>Texture</em>**对象。</li>
<li><code>image</code>是**<em>PowerExternalImageProvider</em><strong>类型：采用 <em>ffi</em> 模式展示图片，返回</strong><em>PowerExternalImage</em><strong>，最终返回的是</strong><em>RawImage</em>**对象，和使用 Flutter Image 展示图片的流程一致。</li>
<li>其他类型，按照自定义的规则展示。</li>
</ul>
<p>让我们来分别看一下**<em>PowerTextureImage</em><strong>和</strong><em>PowerExternalImage</em>**的实现：</p>
<h3> PowerTextureImage</h3>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> PowerExternalImage</h3>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过对比**<em>PowerTextureImage</em><strong>和</strong><em>PowerExternalImage</em>**的源码可以发现，二者最终还是创建了 ImageExt 对象，只不过 PowerTextureImage 中 ImageExt.imageBuilder 返回了 Texture，而 PowerExternalImage 中 ImageExt.imageBuilder 为 null。</p>
<p>再根据下面的<code>_ImageExtState.build</code>源码可以确定，当使用 PowerTextureImage 时 PowerImage 创建的是封装了的 <strong>Texture</strong>，而 PowerExternalImage 时则会使用 PowerExternalImageProvider 创建的 ImageInfo 创建 <strong>RawImage</strong>，这实际上与 Flutter 原有的 Image 组件一致。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的分析，可以知道，<strong><em>PowerImage</em><strong>使用从</strong><em>PowerImageProvider</em></strong> 获取的 <strong><em>ImageInfo</em></strong> 来展示图片，采用**<em>texture</em>**方案时，使用 ImageInfo 中的 textureId 并返回 Texture 对象展示图片；而使用 <strong><em>ffi</em></strong> 方案时，会使用 ImageInfo 中的<code>ui.Image image</code>对象传入 RawIamge 展示图片（这部分与 Flutter Image 组件逻辑一致）。</p>
<br>
<h3> PowerImageProvider</h3>
<p>PowerImageProvider 继承自<em>ImageProviderExt</em> -&gt; <em>ImageProvider</em>，是<em>power_image</em>的关键类之一，主要实现通过 Flutter/Native 跨端通信从 Native 获取/释放图片资源等，创建供 ImageExt 使用的 ImageInfo。</p>
<p>相对于 Flutter 官方的 ImageProvider，除了修改部分类为 power_image 对应的类之外，PowerImageProvider 主要有以下几点改变：</p>
<ul>
<li>工厂方法<code>PowerImageProvider.options</code>生产 PowerImageProvider：根据传入的 PowerImageRequestOptions 中<code>PowerImageRequestOptions.renderingType</code>的值，分别创建对应的**<em>PowerExternalImageProvider</em><strong>或者</strong><em>PowerTextureImageProvider</em>**。</li>
<li>重写<code>_loadAsync</code>方法，调用 Native 图片库加载图片，并根据返回值调用子类 <code>createImageInfo</code> 方法创建 PowerImageInfo。</li>
</ul>
<h4> _loadAsync</h4>
<p>通过重写<code>_loadAsync</code>方法，PowerImageProvider 实现了不同的子类分别创建 PowerImageInfo 展示图片、统一让 ImageCache 管理图片。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的分析中，我们得知，<em>texture</em>和<em>ffi</em>方案分别使用 ImageProvider 提供的 PowerImageInfo 中的<code>int? textureId</code>和<code>ui.Image image</code>展示图片，让我们分别看一下他们是如何获取的：</p>
<h4> PowerTextureImageProvider</h4>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> PowerExternalImageProvider</h4>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码可以看到：</p>
<ul>
<li><em>texture</em> 方案采用的 PowerTextureImageProvider 创建的 ImageInfo 对应的 <code>ui.Image image</code> 一个共享的占位符，并不能真正真正绘制内容，实际上图片信息在对应的<code>PowerTextureImageInfo.textureId</code>中；</li>
<li><em>ffi</em> 方案创建的 ImageInfo 则根据 native 内存中的图片数据创建了对应的 ui.Image，与 Flutter 默认的 ImageProvider 提供的 ImageInfo 一样可以被 RawImage 正常使用。</li>
</ul>
<p>这里需要注意，虽然 <em>texture</em> 和 <em>ffi</em> 都采用了 ImageCache 来管理图片缓存，甚至 <em>ffi</em> 的内存也在 Flutter 侧管理，但是 PowerImage 本身不会出现我们之前在<a href="https://jixiaoyong.github.io/blog/posts/1912667a.html" target="_blank" rel="noopener noreferrer">Flutter Image</a>中分析的加载大量高清网图会出现的<strong>内存爆炸</strong>，这是因为虽然在 ImageCache.putIfAbsent 方法中_pendingImages 同样保存了加载中的图片，但是实际这些<strong>图片加载过程中的内存由 Native 端图片加载库管理</strong>，而非 Flutter，所以只要 Native 端图片加载库比较成熟，就可以避免这个问题。</p>
<p>到目前为止，我们分析了 PowerImage 根据 PowerImageProvider 获取的 ImageInfo 分别采用 ffi 和 texture 两种方案展示图片的过程。</p>
<br>
<p>接下来分析一下之前提到的 <code>PowerImageProvider._loadAsync</code> 方法中使用 PowerImageLoader 获取图片的过程。整个过程可以分为 <strong>flutter 端发起请求/处理回调</strong>、<strong>native 端接收请求/返回结果</strong>两部分，在这过程中 Flutter 和 Native 使用 MethodChannel（发送获取释放图片指令）和 EventChannel（接收图片成功加载的事件）进行通信。</p>
<h2> Flutter/Native 通信</h2>
<p>在上面分析<code>PowerImageProvider._loadAsync</code>方法时，我们注意到其中使用了**<em>PowerImageLoader</em>**获取图片信息 PowerImageCompleter：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里是使用 PowerImageLoader 的单例加载图片，看一下具体的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先创建了 PowerImageRequest 对象：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中：</p>
<ul>
<li><code>imageType</code>表示获取图片的方式（比如<code>network</code>，<code>nativeAsset</code>，<code>file</code>，<code>asset</code>等）；</li>
<li><code>renderingType</code>表示图片渲染方式，比如<code>external</code>（即 ffi 方案）、<code>texture</code>。</li>
</ul>
<p>然后通过<code>PowerImageChannel</code>发送请求（实际的执行的类是<code>PowerImagePlatformChannel</code>）：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小结一下：</p>
<ul>
<li>使用<code>PowerImageLoader.setup</code>注册 MethodChannel 和 EventChannel</li>
<li>使用<code>PowerImageLoader.loadImage</code>向 Native 发起请求加载图片，将请求保存到<code>PowerImageLoader.completers</code>中并返回给调用者</li>
<li>当 Native 端处理完请求之后会回调 PowerImagePlatformChannel 中注册的 EventChannel，然后会执行<code>PowerImageLoader.instance.onImageComplete(event)</code>方法，使用返回的图片信息，从<code>PowerImageLoader.completers</code>找出并完成之前的请求</li>
</ul>
<br>
<p>以上分析为 Flutter 端向 Native 端发起请求的过程，下面以 Android 端为例分析一下 Native 端的处理过程：</p>
<p>首先是在 PowerImagePlugin 中向 Flutter 引擎注册对应的方法。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 Flutter 端向 Native 发送消息时，Flutter 引擎会调用<code>PowerImagePlugin.onMethodCall</code>方法：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于不同的调用请求：</p>
<ul>
<li><code>startImageRequests</code>：先根据请求参数创建好请求并返回给 Flutter 调用方；然后通过 PowerImageRequestManager 真正执行请求（最终会通过<code>PowerImagePlugin.PowerImageEventSink.getInstance().sendImageStateEvent</code>向 Flutter 通知结果）。</li>
<li><code>releaseImageRequests</code>：立即从<code>PowerImageRequestManager.requests</code>中去除对应的请求并尝试终止任务，并向 Flutter 返回结果。</li>
</ul>
<p>下面着重分析一下执行图片请求的逻辑（<code>startImageRequests</code>的情况）：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见对于<em>ffi</em>和<em>texture</em>方案，分别涉及到**<em>PowerImageExternalRequest</em><strong>和</strong><em>PowerImageTextureRequest</em><strong>两个类。他们都继承自</strong><em>PowerImageBaseRequest</em>**类，其<code>startLoading</code>方法会调用<code>performLoadImage</code>方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>PowerImageBaseRequest.performLoadImage</code>方法中：</p>
<ul>
<li>会先通过<code>PowerImageLoader.getInstance().handleRequest</code>方法获取图片；</li>
<li>然后调用<code>PowerImageBaseRequest.this.onLoadResult</code>方法也就是<em>PowerImageExternalRequest</em>和<em>PowerImageTextureRequest</em>的<code>onLoadResult()</code>方法。</li>
</ul>
<p>在他们的<code>onLoadResult(final PowerImageResult result)</code>方法中，入参 PowerImageResult 持有 FlutterImage 对象，后者持有加载的图片的 Drawable，他们根据各自的特点对图片进行处理后（<em>ffi</em>获取 Drawable 的 bitmap 对象，&lt;&gt;如果图片不是<code>ARGB_8888</code>则<em>会</em>发生一次 Bitmap 拷贝&gt;；<em>texture</em>使用 Bitmap 绘制到 Canvas 上面），通过<code>PowerImageBaseRequest.onLoadSuccess()</code>方法或者<code>PowerImageBaseRequest.onLoadFailed</code>返回结果。</p>
<p>其中：</p>
<ul>
<li>PowerImageExternalRequest 从获取到的图片生成 Bitmap 并返回其指针、宽高、大小等属性返回；</li>
<li>PowerImageTextureRequest 则将图片绘制到<code>Surface</code>中并返回<code>textureId</code>等信息。</li>
</ul>
<p>而对于<code>PowerImageLoader.getInstance().handleRequest()</code>，这里面的各个 PowerImageLoaderProtocol 由 Native 端通过<code>PowerImageLoader.getInstance().registerImageLoader</code><strong>注册具体的实现</strong>，<code>handleRequest()</code>方法正是调用他们获取图片。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Native 端图片获取</h2>
<p>上面提到，<em>power_image</em>默认的**<em>PowerImageLoaderProtocol</em>**有以下几种类："<code>network</code>"、"<code>nativeAsset</code>"、"<code>asset</code>"、"<code>file</code>"，这些都需要使用者在 Native 端注册才能正常使用。</p>
<p>以"<code>network</code>"为例，在<code>MainActivity.onCreate</code>方法中：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><em>PowerImageNetworkLoader</em><strong>继承自</strong><em>PowerImageLoaderProtocol</em></strong>，图片的加载逻辑在其<code>handleRequest</code>方法中：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，当 Flutter 端向 Native 发送消息时：</p>
<ul>
<li>Flutter 引擎会调用<code>PowerImagePlugin.onMethodCall</code>方法，先<strong>创建</strong>对应的请求**<em>PowerImageBaseRequest</em>**；</li>
<li>然后<code>PowerImageRequestManager.getInstance().startLoadingWithArguments</code><strong>执行</strong>刚刚上一步创建的请求，此方法内部执行<code>PowerImageBaseRequest.startLoading()</code>方法；</li>
<li>在**<em>PowerImageBaseRequest</em><strong>类内部，其<code>startLoading</code>方法会调用<code>performLoadImage</code>方法，后者又会调用<code>PowerImageLoader.getInstance().handleRequest()</code>方法</strong>请求加载图片**，并指定回调方法为<code>PowerImageBaseRequest.onLoadResult(result)</code>；</li>
<li><code>PowerImageLoader.handleRequest</code>方法内部通过请求的<code>imageType</code>找到 Native 端（比如 Android 在<code>MainActivity.onCreate</code>中注册的）<code>PowerImageLoaderProtocol imageLoader</code>，并执行其<code>handleRequest</code>方法<strong>处理加载图片</strong>请求；</li>
<li><code>PowerImageLoaderProtocol.handleRequest()</code>方法中<strong>调用原生的图片加载库</strong>获取 Drawable 并生成 PowerImageResult 回调<code>PowerImageResponse.onResult</code>方法，此方法会回调<code>PowerImageBaseRequest.this.onLoadResult(result)</code> ；</li>
<li>在**<em>PowerImageTextureRequest</em><strong>或者</strong><em>PowerImageExternalRequest</em>**的<code>onLoadResult</code>方法中对获取到的<code>PowerImageResult</code>进行处理之后回调<code>PowerImageBaseRequest</code>的<code>onLoadSuccess()</code>或者<code>onLoadFailed(final String errMsg)</code>方法返回图片请求结果。</li>
</ul>
<h2> 总结</h2>
<p><strong><em>power_image</em></strong> 是一个利用原生库加载/管理图片的比较适用于 Flutter/Native 混合开发的图片加载库，提供了 <strong><em>texture</em></strong> 和 <strong><em>ffi</em></strong> 两种加载图片的方式。</p>
<p>其中，texture 方案实际使用 Texture 组件展示图片；而 ffi 方案则只有图片获取在 Native 端，当使用<code>ui.decodeImageFromPixels</code>方法从 Bitmap 内存指针创建<em>ui.Image</em>之后（根据<a href="https://mp.weixin.qq.com/s/TdTGK21S-Yd3aD-yZDoYyQ#:~:text=decodeImageFromPixels%C2%A0%E4%BC%9A%E6%9C%89%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%9C%A8%E6%8B%B7%E8%B4%9D%E8%A7%A3%E7%A0%81%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E5%86%85%E5%AD%98%E5%B3%B0%E5%80%BC%E4%BC%9A%E6%9B%B4%E5%8A%A0%E4%B8%A5%E9%87%8D" target="_blank" rel="noopener noreferrer">阿里的描述</a>，这里会发生一次内存拷贝，实际代码可以参考<a href="https://www.notion.so/ui-decodeImageFromPixels-a401c6cf1c92428bb3c3a37da1078a6b" target="_blank" rel="noopener noreferrer">这里</a>），剩下按照和 Flutter Image 类似的步骤展示图片。</p>
<p>根据官方的说法：</p>
<ol>
<li>Texture 适用于日常场景，优先选择；</li>
<li>FFI 更适用于
<ol>
<li>flutter &lt;= 1.23.0-18.1.pre 版本中，在模拟器上显示图片</li>
<li>获取 ui.Image 图片数据</li>
<li>flutter 侧解码，解码前的数据拷贝影响较小。</li>
</ol>
</li>
</ol>
<p>此外，根据官方<a href="https://github.com/alibaba/power_image/issues/17" target="_blank" rel="noopener noreferrer">power_image/issues/17</a>的说法，“在 2.5.3 上 ffi 性能已经跟 &nbsp;<code>texture</code>不相上下了”，而且 textrue 方案在 Android 上较大尺寸可能会 crash（<a href="https://github.com/flutter/flutter/issues/92397" target="_blank" rel="noopener noreferrer">flutter/flutter#92397</a>），所以<strong>更推荐使用 ffi 方案</strong>。</p>
<h2> 参考资料</h2>
<p><a href="https://github.com/alibaba/power_image" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/power_image</a></p>
<p><a href="https://mp.weixin.qq.com/s/TdTGK21S-Yd3aD-yZDoYyQ" target="_blank" rel="noopener noreferrer">Flutter 图片库高燃新登场</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4MDUxOTI5NA==&amp;mid=2247485142&amp;idx=1&amp;sn=b416f1d0c8f3fd2077075441154df090&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">闲鱼 Flutter 图片框架架构演进（超详细）</a></p>
<p><a href="https://mp.weixin.qq.com/s/yUm4UFggYLgDbj4_JCjEdg#at" target="_blank" rel="noopener noreferrer">Flutter 图片内存优化实践</a></p>
<p><a href="https://github.com/alibaba/power_image/issues/17" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/power_image/issues/17</a></p>
<p><a href="https://www.notion.so/ui-decodeImageFromPixels-a401c6cf1c92428bb3c3a37da1078a6b" target="_blank" rel="noopener noreferrer"><code>ui.decodeImageFromPixels分析</code></a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/flutter/power_image_class_structure.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 滑动分析之 NestedScrollView</title>
      <link>https://jixiaoyong.github.io/blog/posts/ae8e53be.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/ae8e53be.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 滑动分析之 NestedScrollView</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 19 Jul 2022 09:48:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：</p>
<ul>
<li>基于 RenderBox 的 box protocol 实现的，主要基于 Size 实现布局。常见的有<a href="https://jixiaoyong.github.io/blog/posts/d3bdcb53.html" target="_blank" rel="noopener noreferrer">SingleChildScrollView</a>。</li>
<li>基于 RenderSliver 的 sliver protocol 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自<a href="https://jixiaoyong.github.io/blog/posts/60f8d92f.html" target="_blank" rel="noopener noreferrer">ScrollView</a>的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。</li>
</ul>
<p>上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。</p>
<p>本文只对 NestedScrollView 的源码实现做一简单分析：它是如何实现联动滚动效果，有什么优势和限制。</p>
<p>官方对其定义是：“A scrolling view inside of which can be nested other scrolling views, with their scroll positions being intrinsically linked.”。</p>
<p>顾名思义，NestedScrollView 是一个可以在<strong>内部嵌套其他 scrolling views 的滑动 View</strong>，按照所处位置的不同，使用<code>headerSliverBuilder</code>提供 header 部分的 scrolling views（限制只能是可以产生 RenderSliver 的 widget），而使用<code>body</code>提供在填充 header 之下所有区域的 widget（限制只能是产生 RenderBox 的 widget）。</p>
<h2> 用例</h2>
<p>下面是一个 NestedScrollView 经典的使用方式：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，NestedScrollView 包括了 headerSliverBuilder 创建的 header 部分，以及 header 下面的 body 部分，二者的滑动效果联动在一起，好像是同一个 scrolling view。比如，当向上滑动 TabBarView 中列表时，会先向上滑动 header 内容，等到 header 无需再滑动才会向上滑动列表。而如果没有 NestedScrollView 的话，ListView 和 header 的滑动是独立的两个事件。</p>
<h2> 源码分析</h2>
<p>NestedScrollView 本质上还是对 CustomScrollView（的子类_NestedScrollViewCustomScrollView）的进一步封装。</p>
<p>它借助于_NestedScrollCoordinator 的<code>_outerController</code> 和<code>_innerController</code> 这两个分别传入_NestedScrollViewCustomScrollView（header 和 body 其实是他的 <code>slivers</code>，其最大滑动范围为 header 的 scrollExtent）和 body 中的 scrolling view（其最大滑动范围为内部滑动视图最大滑动范围之和）的 ScrollController，创建并应用_NestedScrollPosition；当用户滑动等事件发生，通过_NestedScrollViewCustomScrollView 的_NestedScrollPosition 接收外部所有的滑动事件全部归集到_NestedScrollCoordinator（比如 applyUserOffset 方法）统一处理，按照 ScrollPhysics 等分别修改 header 和 body 的 ScrollPosition，从而实现了这两处滑动事件的联动。</p>
<p>所以，在分析 NestedScrollView 的时候，主要涉及到以下类：</p>
<ul>
<li><strong>NestedScrollViewState</strong>：是 NestedScrollView 真正执行逻辑的类，将_NestedScrollCoordinator、_NestedScrollViewCustomScrollView、ScrollController 等组装在一起，对外暴露操纵_NestedScrollCoordinator 的方法</li>
<li>_NestedScrollViewCustomScrollView：继承自 CustomScrollView，主要作用是创建自定义的 NestedScrollViewViewport，后者又创建了 RenderNestedScrollViewViewport 主要用途是更新 SliverOverlapAbsorberHandle</li>
<li><strong>_NestedScrollCoordinator</strong>：处理_NestedScrollPosition 转发过来的滑动事件，将其分发给 header（其实是容纳 header 和 body 的_NestedScrollViewCustomScrollView）和 body。</li>
<li><strong>_NestedScrollController</strong>：给_NestedScrollCoordinator 的 inner 和 outer 的 ScrollController，内部创建_NestedScrollPosition。</li>
<li><strong>_NestedScrollPosition</strong>：给_NestedScrollCoordinator 的 inner 和 outer 的 ScrollPosition，会将 animateTo、jumpTo、pointerScroll、updateCanDrag、hold、drag 等和滑动有关的事件转发给_NestedScrollCoordinator 统一处理。</li>
<li>其余辅助类</li>
</ul>
<p>下面对这些类逐一分析：</p>
<h3> NestedScrollViewState</h3>
<p>NestedScrollView 是 StatefulWidget，其主要逻辑都在创建的 State——NestedScrollViewState 中。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>NestedScrollView._buildSlivers 方法将 headerSliverBuilder 创建的 header 和 body 放到一个列表中，会被 NestedScrollViewState 传入到自定义的 CustomScrollView——_NestedScrollViewCustomScrollView 中。</p>
<p>需要注意 SliverFillRemaining 默认会创建_SliverFillRemainingWithScrollable，后者创建的 RenderObject 是_SliverFillRemainingWithScrollable。在 RenderSliverFillRemainingWithScrollable.performLayout 方法会使用他所处 viewport 主轴方向的尺寸作为自己的 scrollExtent。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说无论 inner scrolling view 的尺寸如何，它（下面称其为 body）占用的 scrollExtent 都是所处的 viewport 的主轴尺寸 mainAxisExtent；再加上 headerSliverBuilder 方法创建的 header，导致_NestedScrollViewCustomScrollView 所创建的 viewport 的最大可滑动范围_maxScrollExtent（其值等于 header+body 的 scrollExtent）一定大于 viewport 的主轴方向尺寸 mainAxisExtent，从而计算出_NestedScrollViewCustomScrollView 的 ScrollPosition 的最大滑动范围（maxScrollExtent）为：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，无论 NestedScrollView 的 body 内容尺寸如何，它为 header+body 分配的尺寸只比 viewport 的尺寸多出一个 header 的尺寸。这个也是 NestedScrollView 实现协调 header 和 body 滑动的基础。</p>
<p>让我们再看一下 NestedScrollViewState 的实现：</p>
<p>NestedScrollViewState 中一个重要的属性就是<code>_NestedScrollCoordinator? _coordinator</code>，它在<code>initState()</code>方法中初始化。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>能注意到，_NestedScrollCoordinator 中持有了 widget.controller，并且还会在 didChangeDependencies、didUpdateWidget 方法被调用时通过_NestedScrollCoordinator.setParent 方法更新，主要有两个作用：1. 获取 initialScrollOffset；2. 通过_outerPosition?.setParent 使得 widget.controller 可以监听 outerPosition 的变化。</p>
<p>然后，在 NestedScrollViewState.build 方法中，会创建_NestedScrollViewCustomScrollView 对象：</p>
<ul>
<li>
<p>将_coordinator!._outerController 作为其 controller，这样会创建，_outerPosition，后者会将_NestedScrollViewCustomScrollView 的事件转发给_coordinator，这样其接管了外层的滑动事件；</p>
</li>
<li>
<p>此外在 NestedScrollView._buildSlivers 方法中创建的 header 和 body 作为_NestedScrollViewCustomScrollView 也就是 CustomScrollView 的 slivers。</p>
<p>这也是创建 header 的<strong>NestedScrollView.headerSliverBuilder 只接受可以创建 RenderSliver 的 widget</strong>的原因。</p>
</li>
</ul>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>_NestedScrollViewCustomScrollView 继承自 CustomScrollView，主要作用是创建继承自 Viewport 的 NestedScrollViewViewport，而后者又主要负责创建和更新继承自 RenderViewport 的 RenderNestedScrollViewViewport——其在内部更新和维护 SliverOverlapAbsorberHandle。</p>
<blockquote>
<p><code>SliverOverlapAbsorberHandle</code>: Handle to provide to a <code>SliverOverlapAbsorber</code>, a <code>SliverOverlapInjector</code>, and an <code>NestedScrollViewViewport</code>, to shift overlap in a <code>NestedScrollView</code>.</p>
</blockquote>
<p>到目前位置，UI 展示部分的内容已经完成，我们的 NestedScrollView 可以将 header 和 body 显示在屏幕上面，但是如果要联动处理在 header 和 body 上面的滑动事件，还需要_NestedScrollCoordinator、_NestedScrollController 和_NestedScrollPosition 的配合。</p>
<h3> _NestedScrollController</h3>
<p>_NestedScrollController 继承自 ScrollController，其逻辑比较简单，主要添加了两项功能：</p>
<h4> 创建_NestedScrollPosition</h4>
<p>创建_NestedScrollPosition 的逻辑比较简单，主要是将 coordinator 也一并传入。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 在 ScrollPosition 变化时通知 coordinator</h4>
<p>在 attach(ScrollPosition position) 中调用_scheduleUpdateShadow() 和_NestedScrollCoordinator 的 updateParent、updateCanDrag，对传入的 ScrollPosition 添加回调_scheduleUpdateShadow()。</p>
<p>在 detach(ScrollPosition position) 中调用_scheduleUpdateShadow()，对传入的 ScrollPosition 移除回调_scheduleUpdateShadow()。</p>
<p>而这个_scheduleUpdateShadow() 方法主要作用是异步执行 coordinator.updateShadow() 更新 NestedScrollView，实现滑动效果。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> _NestedScrollPosition</h3>
<p>在 inner scrolling widget 和 outer viewport 都使用_NestedScrollPosition，它追踪这些 viewport 使用的 offset，并且内部持有_NestedScrollCoordinator，所以此 class 上触发 activities 时，可以推迟或者影响 coordinator。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> setParent</h4>
<p>_NestedScrollPosition.setParent 中，将自己和传入的 ScrollController 绑定在一起：</p>
<ul>
<li>将自身加入 ScrollController._positions</li>
<li>ScrollController 监听自身变化时执行 notifyListeners 通知监听者</li>
</ul>
<h4> absorb</h4>
<p>在 absorb 方法中将 activity 的 delegate 更新为当前 ScrollPosition：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> applyClampedDragUpdate</h4>
<p>此方法返回的是没有使用的 delta，此方法不会主动创建 overscroll/underscroll，如果当前 ScrollPosition 在范围内，则不会发送 overscroll/underscroll；如果已经超出范围，则只会“减轻”这种情况，而不会“加重”。</p>
<p>之所以不会 overscroll，是因为 min 和 max 的取值限定了他们的范围，以一个垂直方向向下布局的滑动列表为例：</p>
<ul>
<li>
<p>delat &lt; 0，即向上滑动，范围是 min：-double.infinity ~ max：0（overscroll 时）或者 maxScrollExtent 和 pixels 中最大值（只能滑到最大范围）。</p>
<p>也就是说，向上滑动时，如果已经在顶部出现 overscroll（此时 pixels 应该为负值），那么最多滑动到 0（也就是恢复到初始位置），没有顶部 overscroll 时（此时 pixels 为正值，可能在 maxScrollExtent 范围内，也可能超出范围，即底部出现 overscroll），那么此时最多向上滑动 maxScrollExtent 和 pixels，也就是说要么不能超范围，要是超了范围，就不能再超了。</p>
<p>而最小滑动范围为-double.infinity，无论 pixels 正负，当其 delta 为负时，其值都只会增大，取值-double.infinity 是为了将 pixels 包含在内。</p>
</li>
<li>
<p>delta &gt; 0，即向下滑动，范围是 min：minScrollExtent 和 pixels 最小值 ~ double.infinity。</p>
<p>也就是说，向下滑动最小到初始位置，最大值不限定（因为此时可能 offset 已经由于某种原因超过 maxScrollExtent 了）。</p>
</li>
</ul>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> applyFullDragUpdate</h4>
<p>此方法在满足 overscroll 条件时，会应用 overscroll，并发出 OverscrollNotification 通知。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> applyClampedPointerSignalUpdate</h4>
<p>applyClampedPointerSignalUpdate 方法返回未使用的 delta，不考虑 ScrollPhysics 的影响。</p>
<h4> applyNewDimensions()</h4>
<p>此方法是_outerScrollPosition 接管 body 滑动事件的关键，也是<strong>body 中 scrolling view 使用了自己的 ScrollController 之后 NestedScrollView 就无法协调 header 和 body 滑动</strong>的原因。</p>
<p>在默认的 ScrollController 中，createScrollPosition() 方法创建的是 ScrollPositionWithSingleContext，当 content 或者 viewport 的尺寸变化之后会调用其 applyNewDimensions() 方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后会调用 ScrollableState 的 setCanDrag 方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见_gestureRecognizers 默认为空，只有主动调用 ScrollableState.setCanDrag(true) 之后滑动视图中的 Scrollable 才能识别手势并处理。</p>
<p>而在_NesetedScrollPosition 的方法中，并没有调用，而是：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码分析可知，如果使用默认的_NestedScrollController 创建的_NestedScrollPosition，最后只有_outerPosition 更新了_gestureRecognizers 可以识别手势，而使用_innerScrollPosition 的 body 内部的 scrolling view 无法识别手势。</p>
<p>所以，当没有给 body 中的 scrolling view 主动设置 ScrollController 时，无论是在 header 还是 body 的手势事件都会由 ScrollPosition 来转发给_NestedScrollCoordinator 统一协调处理；而<strong>如果给 body 中的 scrolling view 主动设置 ScrollController</strong>，由于 ScrollController 默认创建的 ScrollPositionWithSingleContext 会按照实际情况更新_gestureRecognizers，<strong>从而当用户手势在 body 中 scrolling view 的范围时，手势事件会被其捕获并内部消耗，而非转发到_NestedScrollCoordinator 处理，所以就会使 NestedScrollView 失效</strong>。</p>
<br>
<p>此外还持有了_NestedScrollCoordinator，在 animateTo/jumpTo/pointerScroll/applyNewDimensions/hold/drag 等与滑动相关的方法被调用时执行_NestedScrollCoordinator 中对应的方法，这样就将 outer viewport 和 inner scrolling view 的滑动事件都归集到_NestedScrollCoordinator 统一处理。</p>
<h3> _NestedScrollCoordinator</h3>
<p>为了与_NestedScrollPosition 保持一致，方便接收其转发的事件，_NestedScrollCoordinator 也实现了 ScrollActivityDelegate 接口：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> beginActivity</h4>
<p>beginActivity 用来对 outer 和 inner 应用 ScrollActivity，在 goIdle/goBallistic/animateTo/jumpTo/pointerScroll/drag/hold 等与滑动有关的方法中都有直接或间接的调用。</p>
<p>其中 outer activity 是直接指定的，而 inner activity 则是根据 innerActivityGetter 和 inner position 动态计算。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此方法的一种使用方式如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建 outer scroll activity 的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见在计算 outer scroll activity 的时候，需判断 body 内是不是有 inner scrolling view：</p>
<ul>
<li>没有，按照正常创建 BallisticScrollActivity 的流程创建</li>
<li>有，将 inner 的 space 也计入，然后以此计算 BallisticScrollActivity</li>
</ul>
<p>创建 inner scroll activity 的方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> applyUserOffset</h4>
<p>applyUserOffset() 是_NestedScrollCoordinator 的重点，也是 NestedScrollView 能够实现协调 inner 和 outer 滑动事件的关键。</p>
<p>在看 applyUserOffset() 方法之前，先看一下 drag() 方法，在此方法中创建 ScrollDragController 时 delegate 传入的是_NestedScrollCoordinator。</p>
<p>当用户操作屏幕发生 drag 事件时，手势事件会被 ScrollableState 中的 RawGestureDetector 识别到：</p>
<ul>
<li>drag 开始时调用<code>_handleDragStart</code>，通过_NestedScrollPosition 转发调用<code>_NestedScrollCoordinator.drag</code>方法创建了<code>ScrollDragController drag</code></li>
</ul>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>drag 开始时更新时<code>_handleDragUpdate</code>，内部调用<code>ScrollDragController.update</code>,在 update 方法内部执行了<code>delegate.applyUserOffset</code>，此处的<code>delegate</code>就是我们之前传入的_NestedScrollCoordinator</li>
</ul>
<p>根据上述分析，在用户滑动屏幕时，会执行<code>_NestedScrollCoordinator.applyUserOffset</code>方法：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析为何 inner 有 scrolling view 时，NestedScrollView.physics 为 BouncingScrollPhysics() 不生效：</p>
<p>从上述代码我们看到，可以产生 overscroll 效果的 applyFullDragUpdate 只有在 inner 中没有 scrolling view 的时候才会被_outerPosition 应用，其他两个场景都只有 inner position 应用。</p>
<p>而其余场景中，_outerPosition 和 inner position 都应用的是 applyClampedDragUpdate 方法：</p>
<ul>
<li>向下滑动 delta 大于 0，代码会执行到<code>outerDelta -= _outerPosition!.applyClampedDragUpdate(outerDelta)</code>，因为此时限制了 applyClampedDragUpdate 中的 newPixels 范围为（当 ScrollPosition 的 pixels 等于 0 时）minScrollExtent~double.infinity，所以 clampedDelta = newPixels - pixels 等于 minScrollExtent（也就是 0），跳过剩余步骤直接返回了 delta。所以没有执行 BouncingScrollPhysics() 逻辑</li>
<li>向上滑动 delta 小于 0，代码会执行<code>final double innerDelta = _outerPosition!.applyClampedDragUpdate(outerDelta,);</code>，在此方法中，如果有 overscroll 则会先恢复到 0，否则最多上划到 maxScrollExtent，所以也不会执行 BouncingScrollPhysics() 逻辑</li>
</ul>
<br>
<p>通过上述步骤，NestedScrollView 将 header 和 body 的滚动事件进行组合、分发。</p>
<h2> 优劣对比</h2>
<p>NestedScrollView 将 header 和 body 中可滑动 view（inner）的滑动事件组合起来：向上滑动时，先等达到 header 最大滑动范围之后，再将滑动分配给 inner 消耗；当向下滑动时，一般先恢复 inner 的 overscroll（如果_floatHeaderSlivers 为 true，会先尝试下滑 header），尝试将其恢复至 offset 为 0 的状态，再尝试将 header 向下滑动到初始位置，最后如果有 overscroll，会尝试应用到 inner 上面。</p>
<p>CustomScrollView 也支持在同一个页面内嵌套多个滑动列表并关联（在其 slivers 中传入多个 SliverList,SliverGrid 等），但是 CustomScrollView 不支持普通的滑动 view，比如 ListView 等，这些滑动布局会内部消耗掉滑动事件，从而无法与 CustomScrollView 内其余 sliver 正常联动。</p>
<h2> 总结</h2>
<p>NestedScrollView 内部通过 NestedScrollViewState.build() 创建继承自 CustomScrollView 的_NestedScrollViewCustomScrollView。</p>
<p>通过 NestedScrollView._buildSlivers() 将 NestedScrollView.headerSliverBuilder 返回的 sliver 列表（下称 header）和被 SliverFillRemaining 包裹的 body 组合在一起，使得在_NestedScrollViewCustomScrollView 中创建的 viewport 的创建的_NestedScrollCoordinator.outerPosition 的_maxScrollExtent 为 NestedScrollView 的 header 的主轴尺寸，而_NestedScrollCoordinator._innerPositions 的_maxScrollExtent 则是与 body 实际内容一致。</p>
<p>_NestedScrollViewCustomScrollView 的 ScrollController 是_NestedScrollCoordinator._outerController，其创建了_NestedScrollCoordinator.outerPosition，所以整个 NestedScrollView 的滑动事件都会通过_NestedScrollCoordinator._outerController 转到给_NestedScrollCoordinator.applyUserOffset 方法。</p>
<p>在_NestedScrollCoordinator.applyUserOffset 方法中，根据滑动方向的不同，依次协调_NestedScrollCoordinator.outerPosition 和_NestedScrollCoordinator._innerPositions 处理用户 drag 等产生的 delta，修改这两个 ScrollPosition 的值，从而实现 header 和 body 的滑动联动。</p>
<h2> 参考资料</h2>
<p><a href="https://api.flutter.dev/flutter/widgets/NestedScrollView-class.html" target="_blank" rel="noopener noreferrer">NestedScrollView_api.flutter.dev</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Flutter 滑动分析之 Scrollview</title>
      <link>https://jixiaoyong.github.io/blog/posts/60f8d92f.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/60f8d92f.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 滑动分析之 Scrollview</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 16 Jul 2022 02:14:01 GMT</pubDate>
      <content:encoded><![CDATA[<p>Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：</p>
<ul>
<li>基于 RenderBox 的 <em>box protocol</em> 实现的，主要基于 Size 实现布局。常见的有 SingleChildScrollView。</li>
<li>基于 RenderSliver 的 <em>sliver protocol</em> 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自 ScrollView 的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。</li>
</ul>
<p>上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。</p>
<br>
<p>上回我们对 SingleChildScrollView 的实现做了简单分析（见《<a href="https://jixiaoyong.github.io/blog/posts/d3bdcb53.html" target="_blank" rel="noopener noreferrer">Flutter 滑动分析之 SingleChildScrollView</a>》），本文将对另外一种遵循 <em>sliver protocol</em> 的 ScrollView 做一分析。</p>
<p>官方对 ScrollView 的定义是：“A widget that scrolls”。</p>
<p>其主要由三部分组成：</p>
<ul>
<li>
<p>一个<strong>ScrollWidget</strong>，监听用户手势，实现 scrolling 的交互设计</p>
</li>
<li>
<p>一个<strong>viewport widget</strong>，根据传入的 shrinkwrap 值的 true/false 分别会是 ShrinkWrappingViewport 或者 Viewport。通过根据传入的 ViewportOffset 不同而值展示 slivers 的一部分内容来实现滑动的视觉设计效果。</p>
</li>
<li>
<p>一个或多个<strong>slivers</strong>，可以被组合起来创建各种 scrolling effects（比如 list，grids，expanding header 等）的 widget，是真正显示在屏幕上的 widget。</p>
<p>由于默认的 ScrollView 创建的 viewport 的 slivers 属性只接受能创建 RenderSliver 的 Widget，所以 ScrollView 的<code>List&lt;Widget&gt; buildSlivers(BuildContext context)</code>方法只能返回 SliverXXX 之类（比如 SliverList）可以创建 RenderSliver 的 Widget。</p>
</li>
</ul>
<br>
<p>ScrollView 是一个抽象类，它主要的作用是将上面提到的三部分组合起来，为（遵从 sliver protocol 的）scrollable widget 封装屏蔽掉滑动底层细节，提供像<code>buildSlivers</code>之类的方法方便子类能够快速实现一个 scrollable widget。</p>
<h2> 源码分析</h2>
<p><code>abstract class ScrollView extends StatelessWidget{}</code></p>
<p>ScrollView 继承自 StatelessWidget，他的主要逻辑在 build 方法中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上述代码，我们可以验证之前的判断：ScrollView 本身是对 Scrollable、viewport、slivers 的封装。具体的处理滑动手势、更新 ScrollPosition、发送 ScrollNotification 等等都在 Scrollable 中处理了，ScrollView 的子类只需要按照要求提供 slivers（通过 buildSlivers 方法）和其他一些必须的信息即可。</p>
<p>上面的代码中还分别调用了 buildViewport 和 buildSlivers 方法，接下来我们逐一分析一下他们的源码。</p>
<h3> Widget buildViewport()</h3>
<p>buildViewport 方法顾名思义，是用来创建 viewport 的。在 ScrollView 中默认会按照 shrinkWrap 的不同创建两种 viewport，他的子类也可以根据需要重写此方法以返回自己的 viewport。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在 buildViewport() 方法中，显示在 debug 模式下检查确保 widget 已经确定了文本方向（TextDirection 是 rtl 还是 ltr）；然后根据 shrinkWrap 的不同分别创建 ShrinkWrappingViewport 或者 Viewport，他们会根据 offset 的变化展示不同部分的 slivers。</p>
<p>ShrinkWrappingViewport 和 Viewport 都是继承自 MultiChildRenderObjectWidget 的 widget，主要逻辑是分别创建对应的 RenderObject：RenderShrinkWrappingViewport 和 RenderViewport，而这两者又都继承自 RenderViewportBase。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> RenderViewportBase</h4>
<p><code>abstract class RenderViewportBase&lt;ParentDataClass extends ContainerParentDataMixin&lt;RenderSliver&gt;&gt; extends RenderBox with ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt; implements RenderAbstractViewport {}</code></p>
<p>RenderViewportBase 继承自 RenderBox，混入了 ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;类，本身不持有 children，但提供了在 RenderBox 中容纳 RenderSliver 的一些通用方法：</p>
<ul>
<li>自动添加监听_offset 的方法，在其变化时执行 markNeedsLayout() 方法实现滑动效果</li>
<li>提供按照_offset 的值 layout、paint 持有的 children 的方法</li>
<li>通过 hitTestChildren 实现 children 的 hit test</li>
</ul>
<h5> 校验 children 类型是否为 RenderSliver</h5>
<p>在 RenderViewportBase 混入的 ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;的 debugValidateChild() 方法中会<strong>检验 child 的类型是否为指定的 ChildType</strong>（在 RenderViewportBase 中 ChildType 为 RenderSliver），如果不是则会抛出 FlutterError，这也是 ScrollView 默认 Viewport 只支持可以创建 RenderSliver 的 Widget 的原因。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见 ContainerRenderObjectMixin 提供了检测 child 类型的方法，那么它是在什么时候被调用的呢？</p>
<p>无论是 Viewport 还是 ShrinkWrappingViewport 都继承自 MultiChildRenderObjectWidget，其会创建 MultiChildRenderObjectElement。</p>
<p>MultiChildRenderObjectElement.insertRenderObjectChild() 添加 child 中的 RenderObject 时都会先检查一下 child 的类型：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而因为不管是 RenderShrinkWrappingViewport 还是 RenderViewport 都是继承自 RenderViewportBase，也就会执行<code>ContainerRenderObjectMixin&lt;RenderSliver, ParentDataClass&gt;.debugValidateChild(child)</code>方法，校验 child 类型是否为 RenderSliver，所以会在其<code>slivers</code>中直接传入 box widget 则会报错“A RenderViewport expected a child of type <strong>RenderSliver</strong> but received a child of type RenderXXX.”</p>
<h4> RenderViewport</h4>
<p><code>class RenderViewport extends RenderViewportBase&lt;SliverPhysicalContainerParentData&gt; {}</code></p>
<p>RenderViewport 是 Flutter 滑动机制的主力，他通过监听<code>offset</code>的变化展示<code>children</code>的一部分来实现滑动的视觉效果，他会占据父级给的最大空间（<strong>大小由父级指定</strong>）。</p>
<p>其内部持有一个双向的 slivers 列表<code>children</code>，以在 zero scroll offset 的<code>center</code>为锚点：</p>
<ul>
<li>slivers 列表中在 center 之前的 Slivers 按照列表反方向，沿着 axisDirection 的反方向展示。</li>
<li>slivers 列表中在 center 之后的 Slivers 按照列表的方向，沿着 axisDirection 的方向展示。</li>
</ul>
<p>比如一个 axisDirection 为 AxisDirection.down，children 列表为["1", "2", "3", "center", "5", "6", "7"]，center 为“center”，那么默认会展示["center", "5", "6", "7"]，当手指向下滑动的时候，会依次展示出“3”、“2”、“1”，等完全下拉之后，展示内容为：["1", "2", "3", "center", "5", "6", "7"]。</p>
<h4> RenderShrinkWrappingViewport</h4>
<p><code>class RenderShrinkWrappingViewport extends RenderViewportBase&lt;SliverLogicalContainerParentData&gt;{}</code></p>
<p>RenderShrinkWrappingViewport 通过监听<code>offset</code>的变化展示<code>children</code>的一部分来实现滑动的视觉效果，与 Viewport 不同的是，他会 shrinkWrap（收缩包装）自己以便在主轴上匹配 children 的 size（<strong>大小由 RenderShrinkWrappingViewport 根据 children 计算而来</strong>），<strong>比较耗费性能</strong>（特别是当 item 可能会通过折叠展开等方式改变尺寸时）。</p>
<h3> List&lt;Widget&gt; buildSlivers()</h3>
<p>ScrollView 的 buildSlivers 方法是抽象方法，由子类根据需要实现，<em>一般子类也只需要重写此方法即可</em>。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用示例</h2>
<p>CustomScrollView 就是继承自 ScrollView：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 CustomScrollView 的实现比较简单，主要逻辑是将传入的参数<code>slivers</code>作为<code>List&lt;Widget&gt; buildSlivers(BuildContext context)</code>的返回值。这导致我们在使用 CustomScrollView 的时候，需要传入 SliverList、SliverAppBar 等这些继承自 SliverMultiBoxAdaptorWidget 能创建 RenderSliver 的 Widget，而不是普通的 box widget。</p>
<h2> 总结</h2>
<p>ScrollView 的子类借助 SliverMultiBoxAdaptorWidget 及其子类可以实现<strong>对 item 的懒加载</strong>从而避免创建无法通过 viewport 可见的 children（这种类型的传参一般都需传入 SliverChildDelegate 的子类），从而优化性能。</p>
<p>而根据 shrinkWrap 的不同，分别使用 Viewport 和 ShrinkWrappingViewport 创建 viewport，从而分别实现按照父级指定 size 或按照子级计算 size（比较耗性能）。</p>
<p>ScrollView 是 Flutter 中基于 sliver protocol 的 scrollable widget 的父类，因为 viewport 的限制只接受创建 RenderSliver 的 widget 作为其直接子类。其子类则通过 SliverMultiBoxAdaptorWidget 及其子类实现加载 box widget。</p>
<p>以下类都是基于 ScrollView 实现的 scrollable widget：</p>
<ul>
<li><a href="https://api.flutter.dev/flutter/widgets/CustomScrollView-class.html" target="_blank" rel="noopener noreferrer">CustomScrollView</a></li>
<li><a href="https://api.flutter.dev/flutter/widgets/BoxScrollView-class.html" target="_blank" rel="noopener noreferrer">BoxScrollView</a>
<ul>
<li><a href="https://api.flutter.dev/flutter/widgets/ListView-class.html" target="_blank" rel="noopener noreferrer">ListView</a></li>
<li><a href="https://api.flutter.dev/flutter/widgets/GridView-class.html" target="_blank" rel="noopener noreferrer">GridView</a></li>
</ul>
</li>
</ul>
<h2> 参考资料</h2>
<p><a href="https://api.flutter.dev/flutter/widgets/ScrollView-class.html" target="_blank" rel="noopener noreferrer">ScrollView_api.flutter.dev</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Flutter 滑动分析之 SingleChildScrollView</title>
      <link>https://jixiaoyong.github.io/blog/posts/d3bdcb53.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/d3bdcb53.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Flutter 滑动分析之 SingleChildScrollView</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 15 Jul 2022 10:36:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：</p>
<ul>
<li>基于 RenderBox 的 box protocol 实现的，主要基于 Size 实现布局。常见的有 SingleChildScrollView。</li>
<li>基于 RenderSliver 的 sliver protocol 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自 ScrollView 的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。</li>
</ul>
<p>上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。</p>
<p>本文只对 SingleChildScrollView 的源码实现做一简单分析：它是如何实现滚动效果，有什么优势和限制。</p>
<p>官方对其定义是：“A box in which a single widget can be scrolled”。明确表明，SingleChildScrollView 是遵守 box protocol 的 widget，在其内部也只能有一个<strong>box widget</strong>。</p>
<h2> 用例</h2>
<p>下面是一个 SingleChildScrollView 的简单使用：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，SingleChildScrollView 中容纳了一个叫 Column 的 child，如果 Column 的高度无法在屏幕中完全展示，就 SingleChildScrollView 就会保证用户可以上下滑动，从而展示对应的内容；否则如果能够完全显示，则内容无法滑动。</p>
<h2> 源码分析</h2>
<h3> SingleChildScrollView</h3>
<p><code>class SingleChildScrollView extends StatelessWidget {}</code></p>
<p>作为一个 StatelessWidget，SingleChildScrollView 的主要逻辑在他的<code>build()</code>方法中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，正如之前所言，SingleChildScrollView 是依赖于封装 Scrollable 实现滑动效果。我们注意到在 Scrollable.viewportBuilder 中传入的是_SingleChildViewport，这个类处理了 Scrollable 传入的 ScrollPosition 也即这里的 ViewportOffset：</p>
<h3> _SingleChildViewport</h3>
<p>_SingleChildViewport 继承自 SingleChildRenderObjectWidget，主要逻辑是创建和更新 RenderObject——_RenderSingleChildViewport。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见处理 offset 以便更新 content 实现滑动效果的主要逻辑在_RenderSingleChildViewport 这个 RenderObject 中。</p>
<h3> _RenderSingleChildViewport</h3>
<p>先看一下_RenderSingleChildViewport 的继承关系：<br>
<code>class _RenderSingleChildViewport extends RenderBox with RenderObjectWithChildMixin&lt;RenderBox&gt; implements RenderAbstractViewport{}</code></p>
<p>由上述代码可知，_RenderSingleChildViewport：</p>
<ul>
<li>是 RenderBox，也就是说其内部 lay out 遵守 box protocol</li>
<li>RenderObjectWithChildMixin&lt;RenderBox&gt;，RenderObjectWithChildMixin 为 RenderObject 提供一套管理单个 child 的模式，它的<strong>泛型指定了 child 的类型只能是 RenderBox</strong>，这也就是为什么我们之前说 SingleChildScrollView 的 child 只能是 box widget。</li>
<li>实现了 RenderAbstractViewport 接口，这个接口表示 render object 是内部比实际要大，提供了一些方法供 ScrollPosition 和其他 viewport 调用，来获取一些使此 viewport 在屏幕上可见的信息。</li>
</ul>
<p>在修改 axisDirection、offset、cacheExtent 等三个属性的时候会触发 markNeedsLayout() 方法重新进行 lay out；<br>
在修改 clipBehavior 属性的时候只会触发 markNeedsPaint() 和 markNeedsSemanticsUpdate() 方法。</p>
<p>此外，在每次设置 offset 的时候，都会对齐添加监听，这样当 Scrollable 中由于用户手势或者通过 ScrollController 调用 jumpTo/animateTo 等方法修改了 ScrollPosition 的时候，都会使得 Scrollab 的 viewport 也就是我们这里的_RenderSingleChildViewport 收到通知、从而进行对应处理：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上述在修改 offset 的时候添加/移除监听，在 attach/detach 方法中也有对应操作：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的分析我们也可以看出，除了设置修改 axisDirection、offset、cacheExtent 等属性的时候会触发 layout 外，其余时候只会触发重新 paint。</p>
<h4> layout</h4>
<p>一般来说 Flutter Widget 要展示在屏幕上需要经历 build、layout、paint 三步，在分析 SingleChildScrollView 如何根据 offset 的变化实现 scroll 效果之前，我们先看一下他是如何实现 layout 的。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到在 SingleChildScrollView 先让 child 在主轴方向尽可能自由布局，取得其最大值，然后自身在满足父级约束的情况下应用 child 的 size：如果 child.size 在父级约束内就直接应用，负责采用父级的约束。</p>
<p>这样最终的效果就是我们的 SingleChildScrollView 在 child 不超过父级约束的时候只占据 child 的内容，当 child 的内容大于父级约束时，SingleChildScrollView 自身的尺寸是父级给定的最大尺寸，而 child 本身在主轴方向上的尺寸是大于 SingleChildScrollView 的尺寸。这样也为我们后续通过监听 offset 修改显示部分 child 的内容实现滑动效果提供了可能。</p>
<blockquote>
<p>这也告诉我们 SingleChildScrollView 的父级需要指定指定主轴方向约束，否则会出现异常。<br>
比如在 Column 中直接使用 SingleChildScrollView 就会在内容过长的时候发生<em>overflowed</em>错误并且无法滑动 SingleChildScrollView，这是因为 SingleChildScrollView 和 child 都按照最长的尺寸布局，并且这个尺寸超过了父级约束。<br>
在 SingleChildScrollView 外层添加 Expanded 作为父级，相当于给他指定了一个约束（占据剩余空间），所以可以解决这个问题。</p>
</blockquote>
<p>之后，又根据_viewportExtent 以及_minScrollExtent/_maxScrollExtent 分别设置了 viewport 和 content 的范围，让我们看一下这三个值的来历：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，_viewportExtent 是取值主轴方向的 size 大小，也就是 SingleChildScrollView 的尺寸。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>_minScrollExtent 默认返回 0.0；<br>
_maxScrollExtent 返回的是主轴方向上 child 减去 SingleChildScrollView 之后的尺寸和 0.0 之间的最大值，换言之，如果 child 比 SingleChildScrollView 尺寸大，_maxScrollExtent 就是多出来的那一部分，也就是我们可以滑动的范围，否则为 0.0，也就是 SingleChildScrollView 不可滑动。</p>
<h4> paint</h4>
<p>到目前为止，我们的 SingleChildScrollView 顺利得到了尺寸，假设 child 尺寸大于 SingleChildScrollView 的最大尺寸，那么当用户滑动屏幕导致 offset 改变的时候，又是如何实现滑动效果的呢？</p>
<p>先看一个属性：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，_paintOffset 是根据 ScrollPosition 计算出来的真正的 child 和 SingleChildScrollView 的偏移 offset。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此为止，我们可以得出以下结论：</p>
<p>_RenderSingleChildViewport 接收传入的 child，并监听传入的 Offset，当其变化时执行 markNeedPaint()；<br>
其先让 child 在主轴方向尽可能大的进行 layout，然后自身在父级约束条件下尽可能满足 child size，这样当 child 比父级给的约束大时，child 保持自身大小，而 viewport 的 size 则在父级给的最大尺寸内展示一部分 child 内容；<br>
当 Offset 变化时，按照 Offset.pixels 计算出对应的 paintOffset，重新绘制 child，展示另外一部分 child 的内容，从而实现滑动效果。</p>
<h4> hitTest</h4>
<p>_RenderSingleChildViewport 将 hitTest 直接转发给了 child：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br>
<p>至此，SingleChildScrollView 基于 Scrollable、ScrollPosition 和_RenderSingleChildView 完成了支持内部单个 box widget 的滑动效果。</p>
<h2> 优劣对比</h2>
<p>相对于使用 Sliver 实现滑动效果的 Widget 来说，SingleChildScrollView 使用简单，使用的是 box protocol，适用于 child 通常是完全可见的，但是在某些特殊场景（比如竖屏变为横屏等）下可能显示不全的情况，SingleChildScrollView 可以保证在父级无法完整显示 child 的时候使其支持滑动。<br>
SingleChildScrollView 使用起来也比较方便。</p>
<p>但是，正如上面分析的，无论 content 是否可见，SingleChildScrollView 都会将其 layout/paint（也就是说<strong>会将所有内容全部加载</strong>），这样如果 content 超出 viewport 的部分比较多就会非常<strong>耗费性能</strong>。</p>
<p>对于这种情况，就应该考虑使用 ListView/GridView/CustomScrollView 等基于 sliver protocol 的 scrollable widget。在 shrinkWrap 属性为 false 的情况下，viewport 会只创建<strong>屏幕可见部分 + viewport 前后缓存区域</strong>的内容，在 content 滑出这部分区域时 dispose，当其再次滑入时再 recreate，从而保证性能。</p>
<h2> 进阶使用</h2>
<h3> 为 Column 的 children 安全应用 spacedAround，center 等效果</h3>
<p>想要给 Column 的 children 设置 spacedAround 效果，又需要保证在父级空间不足时能够完整显示所有 children 的内容的话，就需要结合 SingleChildScrollView（空间不足时可滑动）、LayoutBuilder（获取父级约束信息）、ConstrainedBox（设置 Column 约束）来实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里使用 ConstrainedBox 确保了 Column 主轴方向最小尺寸是父级大小：</p>
<ul>
<li>当父级尺寸大于 Column 的 children 尺寸时，多出的空隙由 Column 按照 MainAxisAlignment.spaceAround 原则分配，由于 SingleChildScrollView 的 child 尺寸和父级一致，所需不会滑动；</li>
<li>当父级尺寸小于 Column 的 children 尺寸时，Column 的尺寸为 children 的尺寸之和（相互之间没有间隙），此时 SingleChildScrollView 的 child 尺寸大于父级尺寸，所以可以上下滑动，保证了 Column 的 children 可以完全显示。</li>
</ul>
<h3> 为 Column 的 children 安全应用 Expanded、Space 等效果</h3>
<p>在一些场景下，需要用到 Expanded、Space 等填充 Column 剩余的空间以展示某些内容，比如一直位于屏幕下方的版权信息，但是当 Column 的 children 尺寸大于父级尺寸时，又会导致 children 内容无法完整显示，如果直接在 Column 上加一个 SingleChildScrollView 作为父级，又会因为 SingleChildScrollView 给 child 在主轴方向的尺寸无限制，而 Expanded 又要求占据所有剩余空间从而导致出错。</p>
<p>此时可以在上面例子的基础上增加 IntrinsicHeight/InstrinsicWidth 来解决此问题：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面例子中，作为 SingleChildScrollView 子级的 Column 内部能够使用 Expanded 的关键在于 InstrinsicHeight：它的定义是“一个将 child 调整为 child 固有高度的 widget”，也就是说，当<strong>child 可能有无限的高度时，与其无限拓展，它更希望将自己 size 定位一个更加合理的固有高度</strong>（Expanded、Spacer 等非 RenderObjectWidget 本身没有高度，所以在这里不会被计算）。</p>
<p>那么，当父级指定的最小约束 minHeight 大于 InstrinsicHeight.child 的最大固有高度时，child 将按照父级的最小高度设置；<br>
当父级指定的最大约束是 double.infinity 无限大时，InstrinsicHeight 会强制其 child 的大小为固有高度。</p>
<p>但是需要注意的是，IntrinsicHeight/InstrinsicWidth 因为至少需要对 child 进行两次 layout（一次获取 intrinsic dimensions，一次真正的执行 layout），所以会<strong>比较耗费性能</strong>。因此应当保证 Column 子级数量尽可能少，并且可以使用 SizeBox 给 child 指定大小以减轻计算 intrinsic dimensions 的压力。</p>
<h2> 总结</h2>
<p>SingleChildScrollView 作为遵守 box protocol 的 scrollable widget，使用简单，适用于页面内容通常为全部可见，但特殊情况下可能无法完整显示因而需要支持滚动的情况。</p>
<p>其 child 只支持可以生成 RenderBox 的 Widget，会一次性创建所有 child 内容，在其内部使用 ListView 等时需要开启 shrinkWrap 从而导致其懒创建 item 失效，比较耗费性能。</p>
<p>因此，如果是大量 item、child 内容超出 viewport 部分时，应当考虑使用基于 Sliver 的 ListView/GridView/CustomScrollView 等。</p>
<h2> 参考资料</h2>
<p><a href="https://api.flutter.dev/flutter/widgets/SingleChildScrollView-class.html" target="_blank" rel="noopener noreferrer">SingleChildScrollView_api.flutter.dev</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Hello World</title>
      <link>https://jixiaoyong.github.io/blog/posts/4a17b156.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/4a17b156.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Hello World</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 20 Mar 2016 22:06:06 GMT</pubDate>
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener noreferrer">GitHub</a>.</p>
<h3> Quick Start</h3>
<h4> Create a new post</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener noreferrer">Writing</a></p>
<h4> Run server</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener noreferrer">Server</a></p>
<h4> Generate static files</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener noreferrer">Generating</a></p>
<h4> Deploy to remote sites</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener noreferrer">Deployment</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>JVM 内存分配</title>
      <link>https://jixiaoyong.github.io/blog/posts/f31c11c5.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/f31c11c5.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">JVM 内存分配</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 24 Feb 2018 15:39:19 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本笔记基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》及部分在线博客整理。</p>
</blockquote>
<p>JVM：java virtual machine，一个 java 程序（进程）拥有一个 jvm 实例</p>
<h2> 内存</h2>
<p>JVM 区域总体分两类，heap 区和非 heap 区：</p>
<p><strong>heap 区</strong>：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代 - 养老区）。<br>
<strong>非 heap 区</strong>：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(Java 虚拟机栈)、Local Method Statck(本地方 法栈)。</p>
<h2> 内存划分</h2>
<h3> 1.head</h3>
<p>堆，所有线程共享，存放所有对象实例、数组，GC 主要场所，会 OOM</p>
<p>分类</p>
<p><strong>1.新生代</strong></p>
<ul>
<li>
<p>eden 刚刚创建的对象优先</p>
</li>
<li>
<p>s1 经历几次 GC</p>
</li>
<li>
<p>s2 经历几次 GC</p>
</li>
</ul>
<p><strong>2.老年代</strong></p>
<ul>
<li>
<p>存活时间长的老年对象</p>
</li>
<li>
<p>大对象，如数组，大 String...</p>
</li>
</ul>
<h3> 2.stack</h3>
<p>栈，线程私有，存放基本数据和对象的引用，LIFO，会 OOM，StackOverflow</p>
<h4> java virtual machine stack</h4>
<p>线程请求的栈深度大于 JVM 允许的深度会导致 Stack Overflow<br>
在编译期完成内存分配，如果虚拟机栈可以动态扩展，但是当拓展时无法申请到足够内存时会导致 OutOfMemory</p>
<p><strong>stack &nbsp;frame</strong></p>
<p>stack frame：栈帧，每执行一个方法就会产生一个栈帧并压入栈中</p>
<ul>
<li>
<p>局部变量表</p>
<ul>
<li>基本数据类型</li>
<li>对象引用</li>
<li>returnAddress 类型，指向了一条字节码指令的位置</li>
</ul>
</li>
<li>
<p>操作数栈</p>
</li>
<li>
<p>动态链接</p>
</li>
<li>
<p>方法出口等</p>
</li>
</ul>
<h4> native method stack</h4>
<p>与 java 虚拟机栈作用类似，不过 native method stack 是为 native 方法服务。<br>
jvm 可以自由实现它，甚至在 sun HotSpot VM 中将他与虚拟机栈合并<br>
会 OOM，stackOverflow</p>
<h3> 3.method area</h3>
<p>方法区，线程共享，存放类信息，常量，静态变量，即时编译器编译后的代码，会 OOM</p>
<p><strong>运行时常量池</strong></p>
<p>类加载后，编译器生成的各种字面量和符号引用会放到方法区的运行时常量池中，会 OOM<br>
<code>String.intern()</code>，有该 string 对象则返回，无则创建并返回</p>
<blockquote>
<p><code>String.intern()</code>方法的注意事项：</p>
<p>JDK1.6 及以下：将首次出现的对象实例<strong>复制</strong>到永久代，返回其引用</p>
<p>JDK1.7 及以上：只会<strong>记录</strong>下首次出现的实例的引用，返回其引用</p>
<p>所以：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JDK1.6 及以下输出<code>false</code>，在 JDK1.7 及以上输出<code>true</code></p>
<p>此外，由于<code>String</code>类是<code>final</code>的，每次<code>new String("str")</code>会产生两个对象：一个是字符串<code>str</code>本身，一个是值为<code>str</code>的字符串。</p>
</blockquote>
<p>以<code>String s = "Hello";</code>为例，解释几个概念：</p>
<p><strong>字面量</strong> 源码中表示具体的值，如<code>Hello</code></p>
<p><strong>符号引用</strong> 用来指代某种值得符号，如<code>s</code></p>
<p><strong>直接引用</strong> 可以定位到内存中的（类、对象、方法、变量）等的具体地址</p>
<h3> 4.program count</h3>
<p><strong>程序计数器</strong>，线程私有，占用内存小，当做当前线程执行字节码的行号指示器。</p>
<p>若执行 java 方法，计数器记录的是正在执行的虚拟机字节码指令的位置</p>
<p>若执行的是 native 方法，则计数器为空 undefined。</p>
<p>此内存区域是唯一一个在 java 虚拟机规范字没有规定任何 OOMError 的区域</p>
<h2> 内存溢出</h2>
<blockquote>
<p>以 Sun HotSpot VM 为例</p>
</blockquote>
<h3> 1.java 堆溢出</h3>
<p>对象过多导致 head 内存溢出</p>
<ol>
<li>是内存泄漏 memory leak，定位泄露对象</li>
<li>是内存溢出 memory overflow，检查虚拟机堆参数是否可以调大；去除非必须的生命周期长的对象</li>
</ol>
<h3> 2.虚拟机栈和本地方法栈溢出</h3>
<ol>
<li>
<p>单线程，Stack Overflow</p>
<p>单线程下，栈帧过大或者虚拟机栈容量太小，当内存无法分配时都会导致 Stack Overflow 异常</p>
</li>
<li>
<p>多线程，</p>
<p>多线程时，每个线程栈分配的内存越大，越容易尝试内存溢出 OOM</p>
<p>原因：虚拟机最大内存一定的情况下，去掉共享的 Head 和 MethodArea 占的内存，剩下的内存/单个线程最大栈内存=最大线程数量，当单个线程最大栈内存增加时，可以产生的线程数就会越少</p>
</li>
</ol>
<h3> 3.运行时常量池溢出</h3>
<p>运行时常量池属于方法区，当常量过多时会导致 OOM，可以用 String.intern() 方法尝试</p>
<h3> 4.方法区溢出</h3>
<p>经常动态生成大量 Class 的应用，如 Spring 等框架，需要注意 OOM</p>
<h3> 5.本地直接内存溢出</h3>
<p>原生方法直接操作物理内存时导致物理内存不够，产生 OOM</p>
<h2> GC 垃圾回收</h2>
<p>JVM 中 GC 会根据不同情况采取以下一系列算法组合进行内存回收</p>
<h3> 回收算法</h3>
<h4> 1.复制算法</h4>
<p><strong>原理</strong>：内存一分为二，只使用一半；GC 时将存活对象复制到另一半内存，剩下的则清空</p>
<p><strong>优缺点</strong>：1.无 STW，但不适合对象过多的情况；2.内存利用效率低</p>
<h4> 2.标记清除法</h4>
<p><strong>原理</strong>：从 GC Roots 开始遍历，可达标记存活，不可达则未标记</p>
<p>java 中，GC Roots 可以是以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI 引用的对象</li>
</ul>
<p><strong>优缺点</strong>：1.要 StopTheWorld 防止标记的时候新 new 的对象未被标记而出错；</p>
<p>2.清除对象后内存不连续，会有一定的浪费</p>
<h4> 3.标记压缩法</h4>
<p><strong>原理</strong>：类似【标记清除法】，但会对标记进行压缩，如 a-&gt;b-&gt;c，会被压缩为 a-&gt;c，具体试讲所有存活的对象都向一端移动，直接清理掉端边界外的内存</p>
<p><strong>优缺点</strong>：1.也要 StopTheWorld</p>
<h4> 4.引用计数算法</h4>
<p><strong>原理</strong>：引用 +1，不引用 -1，为 0 则删除，但是会有相互循环引用的问题，java 未使用</p>
<p><strong>优缺点</strong>：相互循环使用：<br>
a = b<br>
b = a<br>
除此之外再没有用到 a，b 的地方，但是由于 a，b 的引用不为 0 所以无法被回收，导致内存浪费</p>
<h3> 回收过程</h3>
<p>一个不可达对象在“死缓”到“执行死刑”前至少经历两个标记过程</p>
<ol>
<li>
<p>第一次标记，筛选：是否有必要执行 finalize() 方法，若是则放到 F-Queue 队列中【触发】该方法，但不保证执行完该方法。</p>
<p>可以在 finlize() 方法中<strong>自救一次</strong>：在该方法中将<em>自身 this</em>赋值给其他变量，这样在第二次标记时会被移出<em>即将回收</em>集合；但是由于 finlize() 方法只会被调用一次，所以只能自救一次。并<em>不推荐该方法</em>，该方法所有可以做的工作，可以用<strong>try...finally</strong>或者其他方法更好的实现</p>
</li>
<li>
<p>第二次标记，若 finalize() 方法以及调用过，或者为重写该方法，则“没必要执行”，可以回收</p>
</li>
</ol>
<h2> 对象</h2>
<h3> 对象引用</h3>
<h4> 强引用 StrongReference</h4>
<p>People p = new People();哪怕抛出 OOM 也不会被 GC 回收的对象</p>
<h4> 软引用 SoftReference</h4>
<p>SoftReference sf = new SoftReference(p);只要有足够内存就不会被 GC 回收，若内存不够则会被 GC 回收，常用作服务器缓存</p>
<h4> 弱引用 WeakReference</h4>
<p>在下次 GC 回收之前都存在，用作 android 等内存紧张的设备中的缓存</p>
<h4> 虚引用 PhantomReference</h4>
<p>无法影响其生存时间，也无法通过虚引用获取其实例，设置虚引用只是为了在对象被 GC 回收时获取系统通知</p>
<h2> 脑图</h2>
<figure><img src="https://jixiaoyong.github.io/images/blog/2018-02/JVMMemory.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/blog/2018-02/JVMMemory.png" type="image/png"/>
    </item>
    <item>
      <title>JVM 类加载机制之 ClassLoader</title>
      <link>https://jixiaoyong.github.io/blog/posts/b3994218.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b3994218.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">JVM 类加载机制之 ClassLoader</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 15 Apr 2018 08:40:32 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文为<a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener noreferrer">《一看你就懂，超详细 java 中的 ClassLoader 详解 - CSDN 博客》</a>阅读笔记</p>
</blockquote>
<h2> 简述</h2>
<p>JVM 有三种类加载器：</p>
<ol>
<li><strong>BootStrap ClassLoader</strong> 启动类加载器，加载核心类库，主要加载核心类库，%JRE_HOME%\lib 下的 rt.jar、resources.jar、charsets.jar 和 class 等。</li>
<li><strong>Extention ClassLoader</strong> 扩展类加载器，加载目录%JRE_HOME%\lib\ext 目录下的 jar 包和 class 文件。</li>
<li><strong>App ClassLoader</strong> 应用程序加载器，加载当前应用的 classpath 的所有类。</li>
</ol>
<p>除以上三种外，还有用户自定义的类加载器。</p>
<p>每个类由加载它的类加载器和类本身确定其唯一性。也就是说，类加载器不同，类肯定不同。</p>
<h2> 加载过程</h2>
<p>在加载类时，通过**“双亲委托”<strong>机制，依次从</strong>1** -&gt; <strong>3</strong>向上查询，再从<strong>3</strong>-&gt;<strong>1</strong>依次返回结果：</p>
<ol>
<li>调用<code>findLoadedClass(className) </code>查询是否已经加载该类</li>
<li>调用父加载器的<code>loadClass(className,false)</code>，若父加载器为空，则调用<code>BootStrap ClassLoader</code></li>
<li>如果还是没有加载到该类，调用<code>findClass(className)</code></li>
</ol>
<p>这样子保证了每个类都是先经过最顶端的类加载器<code>BootStrap ClassLoader</code>，如果没有加载到再依次经过<code>Extention ClassLoader</code>、<code>App ClassLoader</code> 加载，确保如 String 等关键类不会被自定义的 ClassLoader 加载而导致异常。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>AppClassLoader</code>和<code>ExtClassLoader</code>都继承自<code>URLClassLoader</code></p>
<p><code>AppClassLoader</code>的父加载器是<code>ExtClassLoader</code>，<code>ExtClassLoader</code>的父加载器为<code>null</code>，故而会调用<code>BootStrap ClassLoader</code></p>
<p>ClassLoader 如果没有指定父加载器，则默认的父加载器为<code>AppClassLoader</code>，自定义 ClassLoader 也是如此。</p>
<h2> 自定义 ClassLoader</h2>
<p>自定义 ClassLoader 一般步骤：</p>
<ol>
<li>继承自<code>ClassLoader</code></li>
<li>重写<code>findClass()</code></li>
<li>在<code>findClass()</code>方法中调用并返回<code>defineClass()</code></li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而<code>defineClass()</code>则将一个字节数组转化为一个类的实例（Converts an array of bytes into an instance of class with an optional ProtectionDomain）</p>
<h2> contextClassLoader</h2>
<p>每个线程都有一个 ClassLoader：<code>contextClassLoader</code>，通过将其设置为自定义的 ClassLoader 可以在加载类的时候做一些特殊的事情。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果为：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JVM 类加载机制解析</title>
      <link>https://jixiaoyong.github.io/blog/posts/cf83ef31.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/cf83ef31.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">JVM 类加载机制解析</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 26 Feb 2018 11:28:56 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简述</h2>
<p>本文介绍了 java 虚拟机类加载机制。</p>
<h2> 类加载机制</h2>
<p>JVM 类加载一共 7 步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的 1,2,3 步，在实际中有可能从其中间某一步开始。</p>
<p>类加载机制一般分为三部分：<strong>加载 Loading -&gt; 连接 Linking -&gt; 初始化 Initializing</strong></p>
<figure><img src="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true" alt="JVM Class Loader" tabindex="0" loading="lazy"><figcaption>JVM Class Loader</figcaption></figure>
<p>其中<strong>加载、验证、准备和初始化</strong>发生的顺序是确定的，但<strong>解析</strong>可以在初始化之后开始（java 动态绑定）</p>
<blockquote>
<p>java 绑定分为静态绑定和动态绑定：</p>
<ul>
<li><strong>静态绑定</strong>：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对 java，简单的可以理解为程序编译期的绑定。java 当中的方法只有 final，static，private 和构造方法是前期绑定的。</li>
<li><strong>动态绑定</strong>：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在 java 中，几乎所有的方法都是后期绑定的。</li>
</ul>
<p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/ns_code/article/details/17881581</a></p>
</blockquote>
<h2> 类加载机制具体过程</h2>
<h3> **I.Loading **</h3>
<p><strong>加载</strong>，JVM 将文件（class，jar，zip，网络等）中的二进制字节流保存到虚拟机方法区和堆中，并用该二进制表示形式创建类或者接口的过程。</p>
<blockquote>
<p>Loading is the process of finding the binary representation of a class or interface type with a particular name and <em>creating</em> a class or interface from that binary representation</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html</a> (<em>英文文档若无特殊说明都是引用官方文档，下同</em>)</p>
</blockquote>
<ol>
<li>
<p>用<strong>类全限定名</strong>获取类的二进制字节流</p>
</li>
<li>
<p>将字节流中<strong>静态存储结构</strong>转化为<strong>方法区</strong>的运行时数据结构</p>
</li>
<li>
<p><u><em>在<strong>堆</strong>中生成一个代表该类的 java.lang.Class 对象，作为方法区数据的访问入口。</em></u></p>
<p>（<s><strong>这句话存疑</strong> ，有人说<a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener noreferrer">在堆中</a> ,也有人说在<a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener noreferrer">方法区</a> ,官方文档未相关描述</s></p>
<p><code>2019/01/12 更新</code> Class 对象没有明确规定实在<strong>JAVA 堆</strong>中，对应 HotSpot 虚拟机来说，该对象在<strong>方法区</strong>中）</p>
</li>
</ol>
<p>类加载的地方是开发人员可控性最强的地方。除了可以使用系统的 ClassLoader 外还可以自定义 ClassLoader（后文详述）。</p>
<p>类加载根据加载的类不同分为两种：</p>
<ul>
<li>非数组类 使用系统/自定义的类加载器完成加载</li>
<li>数组类 数组类不通过类加载器创建，而是通过 JVM 直接创建，但是数组类的元素类型要通过类加载器创建</li>
</ul>
<p>数组类的元素加载，根据数组元素的类型不同，分为两类：</p>
<ul>
<li>引用类 通过普通类加载器加载，并将数组用该类加载器标识</li>
<li>非引用类 将数组与引导类加载器标识</li>
</ul>
<p>数组类的可见性与其元素类的可见性一致。</p>
<hr>
<h3> **II.Linking **</h3>
<p><strong>连接</strong>，是将类或者接口组合到 java 虚拟机运行状态的过程，这样他就可以被运行。</p>
<blockquote>
<p>Linking is the process of taking a class or interface and combining(组合) it into the run-time state of the Java Virtual Machine so that it can be executed(运行)</p>
</blockquote>
<p>连接一般分为 3 部分：验证 Verification、准备 Preparation、解析 Resolution。</p>
<blockquote>
<p>Linking a class or interface involves(包括) verifying and preparing(验证和准备) that class or interface, its direct(直接) superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.</p>
</blockquote>
<h4> <strong>Verification</strong></h4>
<p><strong>验证</strong>，保证 class 文件中的字节流信息符合虚拟机的要求。</p>
<blockquote>
<p>Verification(<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.10" target="_blank" rel="noopener noreferrer">§4.10</a>) ensures that the binary representation(二进制格式) of a class or interface is structurally correct(结构正确) (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.9" target="_blank" rel="noopener noreferrer">§4.9</a>). Verification may cause additional classes and interfaces to be loaded (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener noreferrer">§5.3</a>) but need not cause them to be verified or prepared.</p>
</blockquote>
<p>验证内容包括：</p>
<ol>
<li>文件格式验证，验证字节流符合 class 文件格式规范；</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h4> **Preparation **</h4>
<p><strong>准备</strong>，在方法区对类变量分配内存，<strong>初始化为默认值</strong>（“零值”）。</p>
<p>比如：<code>static int i = 5；</code>在这一步只会进行到<code>i = 0</code> ，而<code>i = 5</code>要在初始化那一步才进行；</p>
<p>但是如果是 final 修饰的<strong>常量</strong>，则在此分配具体值。</p>
<blockquote>
<p><em>Preparation</em> involves creating the static fields for a class or interface and initializing such fields to their default values (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.3" target="_blank" rel="noopener noreferrer">§2.3</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.4" target="_blank" rel="noopener noreferrer">§2.4</a>). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener noreferrer">§5.5</a>), not preparation.</p>
</blockquote>
<p>准备工作可能在创建之后的任何时候发生，但是必须在初始化之前完成。</p>
<h4> <strong>Resolution</strong></h4>
<p><strong>解析</strong>，是在运行时常量池中动态确定符号引用的具体值的过程。</p>
<p>每个栈帧 frame 都有一个<code>当前方法</code>到<code>运行时常量池</code> 的引用，用来支持方法代码 (method code) 的<strong>动态链接（dynamic linking）</strong>。</p>
<p>method code：要被执行的方法以及通过符号引用的变量。</p>
<blockquote>
<p>Each frame (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener noreferrer">§2.6</a>) contains a reference to the run-time constant pool (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener noreferrer">§2.5.5</a>) for the type of the current method to support <em>dynamic linking</em> of the method code.</p>
</blockquote>
<p>动态链接将符号引用（symbolic references）转化为具体方法的调用（concrete method references）即直接引用，根据需要加载类来解析未定义的符号，将变量访问转化为运行时内存（runtime location）。</p>
<blockquote>
<p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p>
<p><em>方法和变量的这种后期绑定，使得方法使用的其他类的更改不太可能破坏这个代码。</em></p>
<p>直接引用可以直接定位到内存中某一段地址；符号引用则与 JVM 内存无管</p>
</blockquote>
<p>解析分为：</p>
<ol>
<li>类，接口解析</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
</ol>
<hr>
<h3> <strong>III.Initialization</strong></h3>
<p><strong>初始化</strong> ，<em>Initialization</em> of a class or interface consists of executing its class or interface initialization method（执行类，接口的构造方法<code>clinit()</code>）</p>
<p>类或接口在被初始化之前，必须先被连接 linked（verified, prepared, and optionally（可选）resolved.）。</p>
<p>初始化有且只有以下五种情况：</p>
<ul>
<li><code>new</code>、读取/设置类（只有直接定义其的类才会，子类等不受影响）的静态变量（final 修饰的常量除外）、执行静态方法</li>
<li><code>java.lang.reflect</code>反射调用类</li>
<li>初始化时，如果父类未初始化，先触发父类的初始化（接口类除外）</li>
<li>虚拟机等启动时执行主类的<code>main()</code>方法时，需要先初始化主类</li>
<li>JDK1.7 动态支持时，如果<code>java.lang.invoke.MethodHandle</code>实例最后解析结果<code>REF_get/put/invokeStatic的方法句柄对应的类未被初始化时，需要先初始化对应的类</code></li>
</ul>
<p>以上 5 种称为对一个类的<strong>主动引用</strong>，其余不会触发初始化，称为<strong>被动引用</strong></p>
<p><code>clinit()</code> ,有<strong>类变量赋值，静态语句块</strong>会由编译器合并为<code>clinit()</code>方法，分为两种：</p>
<ol>
<li>类 父类的<code>clinit()</code>方法会先于子类执行</li>
<li>接口 接口<code>clinit()</code>方法无需调用父类接口的<code>clinit()</code>方法；接口的实现类也无需执行接口的<code>clinit()</code>方法</li>
</ol>
<p><code>clinit()</code> 是线程安全的，在同一个类加载器中，多个线程的中只会有<strong>一个线程执行一次<code>clinit()</code></strong>，其余线程阻塞等待</p>
<p><code>clinit()</code>和<code>init()</code>不同如下：</p>
<blockquote>
<p><strong>init</strong>是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行 init 方法<u>（是在<strong>new 对象</strong>的时候<strong>初始化非静态变量</strong>）</u>；</p>
<p>而 clinit 是类构造器方法，也就是在 jvm 进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段 jvm 会调用 clinit 方法<u>（是在<strong>JVM 初始化类</strong>的时候<strong>初始化静态变量</strong>）</u>。</p>
<p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/u013309870/article/details/72975536</a></p>
</blockquote>
<p>如果类没有静态赋值、静态语句块等则不会有<code>clinit()</code>方法。</p>
<p><code>clinit()</code>先于<code>init()</code>执行。</p>
<h2> 参考文献</h2>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener noreferrer">Java Virtual Machine Specification Chapter 5. Loading, Linking, and Initializing</a></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.2" target="_blank" rel="noopener noreferrer">Chapter&nbsp;2.&nbsp;The Structure of the Java Virtual Machine</a></p>
<p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener noreferrer">【深入 Java 虚拟机】之四：类加载机制</a></p>
<p><a href="http://blog.csdn.net/zhangliangzi/article/details/51319033" target="_blank" rel="noopener noreferrer">JVM 类加载机制详解（一）JVM 类加载过程</a></p>
<p><a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener noreferrer">Jvm 系列 3—类的加载 - Gityuan 博客 | 袁辉辉博客 </a></p>
<p><a href="http://wiki.jikexueyuan.com/project/java-vm/class-loading-mechanism.html" target="_blank" rel="noopener noreferrer">类加载机制 - 深入理解 Java 虚拟机 - 极客学院 Wiki </a></p>
<p><a href="http://blog.csdn.net/javazejian/article/details/70768369" target="_blank" rel="noopener noreferrer">深入理解 Java 类型信息 (Class 对象) 与反射机制 - CSDN 博客</a></p>
<p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener noreferrer">深入理解 jvm--Java 中 init 和 clinit 区别完全解析 - CSDN 博客</a></p>
]]></content:encoded>
      <enclosure url="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true" type="image/"/>
    </item>
    <item>
      <title>Java 笔记之 HashMap 保存数据</title>
      <link>https://jixiaoyong.github.io/blog/posts/ff927bd4.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/ff927bd4.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 笔记之 HashMap 保存数据</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 15 Dec 2019 08:41:35 GMT</pubDate>
      <content:encoded><![CDATA[<img src="https://images.pexels.com/photos/159644/art-supplies-brushes-rulers-scissors-159644.jpeg?cs=srgb&amp;dl=art-supplies-arts-and-crafts-ballpens-159644.jpg&amp;fm=jpg" class="full-image">
<p>Photo by **<a href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" target="_blank" rel="noopener noreferrer">Pixabay </a>**from <strong><a href="https://www.pexels.com/photo/pencils-in-stainless-steel-bucket-159644/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" target="_blank" rel="noopener noreferrer">Pexels</a></strong></p>
<p><code>HashMap</code>使用由<code>Node&lt;K,V&gt;</code>（继承自<code>Map.Entry&lt;K,V&gt;</code>）组成的<strong>数组</strong><code>table</code>保存数据。</p>
<p>在<code>table</code>中保存数据时根据<code>key</code>的<code>hashCode</code>计算到一个<strong>随机保存位置（但都在<code>table</code>数组的大小范围内）</strong>，当存储的<strong>数据总量</strong>超过加载系数<code>loadFactor</code>规定的<strong>阈值</strong>时则对<code>table</code>进行<strong>扩容</strong>。</p>
<h2> HashMap 有以下全局变量</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><code>loadFactor</code>：默认的负载因子<strong>0.75</strong>是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下：</p>
<p>如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Load factor 的值；</p>
<p>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子<code>loadFactor</code>的值，这个值可以大于 1。</p>
<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>
</blockquote>
<p>每个<code>Node</code>包含了以下信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在执行<code>hashMap.put("k", "v");</code>时，会先计算<code>key</code>的<code>hash</code>值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> <code>V put(K key, V value)</code></h2>
<p>使用<code>HashMap</code>保存数据时：</p>
<ol>
<li>
<p>使用<code>hash(Object key)</code>计算<code>key</code>的<code>hash</code>值</p>
</li>
<li>
<p>通过<code>hash</code>值计算<code>value</code>应该保存的位置<code>i</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此时会判断是否需要扩容 (<strong>只有<code>table</code>为空，或者当前存储的数据总数<code>size</code>大于阈值<code>threshold</code>时才会扩容</strong><code>resize()</code>)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>接下来会插入数据</p>
<ul>
<li>指定位置为空（没有<em>hash 冲突</em>），或已有<code>key</code>相同的值：则直接插入<code>value</code></li>
<li>已经存在值并且数量大于 8：则将链表转化为红黑树（JDK1.8），否则以链表形式保存数据</li>
<li>在移除数据时，如果红黑树数量小于 6：则将红黑树转化为链表</li>
</ul>
</li>
</ol>
<blockquote>
<p>在 JDK1.7 中，数据以数组或链表形式保存，JDK1.8 中则新增了红黑树。</p>
<p>发生 hash 冲突时，JDK1.7 采用采用头插法，可能会产生逆序和环形链表；JDK1.8 采用尾插法，直接插入链表或红黑树尾部。</p>
<p>具体 JDK1.7 与 1.8 对比查看<a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener noreferrer">这里</a></p>
</blockquote>
<h2> <code>V get(Object key)</code></h2>
<p>使用<code>HashMap</code>获取数据时：</p>
<ol>
<li>
<p>计算 key 的<code>hash值</code></p>
</li>
<li>
<p>查找对应位置的<code>node</code></p>
<ul>
<li>
<p><code>null</code>：返回<code>null</code></p>
</li>
<li>
<p><code>node</code>不为空且<code>key</code>一致：返回该<code>node</code></p>
</li>
<li>
<p><code>node</code>不为空且<code>key</code>不一致：</p>
<p>如果是<em>链表</em>：遍历链表查找是否存在与<code>key</code>一致的<code>node</code></p>
<p>如果是<em>树</em>：遍历树查找是否存在与<code>key</code>一致的<code>node</code></p>
</li>
</ul>
</li>
</ol>
<h2> <code>V remove(Object key)</code></h2>
<p>使用<code>HashMap</code>移除数据时：</p>
<p>其大体过程与<code>get(Object key)</code>类似，遍历找到对应的<code>node</code>并删除。</p>
<h2> 计算索引</h2>
<p>一个<code>key</code>对应的索引<code>index</code>是由这个<code>key</code>的<code>hash()</code>值对<code>HashMap</code>的数组长度<code>length</code>的余数：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>又有**在<code>Length</code>为 2<sup>n</sup>**时：</p>
<p>hash % 2<sup>n</sup> =  hash &amp; ( 2<sup>n</sup> - 1)</p>
<blockquote>
<p>hash % 2<sup>n</sup> = hash - (hash / 2<sup>n</sup>) * 2<sup>n</sup><br>
= hash - (hash&gt;&gt;n) * 2<sup>n</sup><br>
= hash &amp; ( 2<sup>n</sup> - 1)</p>
</blockquote>
<p>而<code>HashMap</code>的长度<code>Length</code>又只能是 2<sup>n</sup>，所以：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 保存值</h2>
<ul>
<li>
<p>当<code>table</code>为空或者长度超过加载因子<code>DEFAULT_LOAD_FACTOR</code>规定的容量 (默认容量为 16，加载因子为 0.75) 时会自动扩容。</p>
</li>
<li>
<p>当<code>table[index]</code>为空时，直接新建<code>Node</code>并保存到<code>table[index]</code>中。</p>
</li>
<li>
<p>当<code>table[index]</code>不为空时：</p>
<ul>
<li>如果是同一个<code>key</code>则覆盖旧的值</li>
<li>如果是不同的<code>key</code>则先尝试以链表保存数据</li>
<li>如果是不同的<code>key</code>，并且链表长度超过<code>MIN_TREEIFY_CAPACITY</code>规定的长度（默认 64），则将链表转化为红黑树 (JDK1.8 新增)</li>
</ul>
</li>
</ul>
<h2> 序列化</h2>
<p>在<a href="#HashMap%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">第一节</a>我们可以看到，<code>HashMap</code>的很多变量都被标记为<code>transient</code>，这表示在<code>Serializable</code>序列化时不主动去序列化这些值，那这样岂不是没法反序列化这些数据了？</p>
<p>其实在后面我们可以看到，<strong><code>HashMap</code>在<code>writeObject()</code>方法中主动保存了部分数据</strong>（原因是默认的<code>Serializable</code>由于不同 JVM 实现对同一对象如<code>String</code>的<code>HashCode</code>不一定一致，会导致严重的问题——<code>HashMap</code>基于<code>hash</code>值保存数据）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并在<code>readObject()</code>恢复了这些值。</p>
<h2> 位运算</h2>
<table>
<thead>
<tr>
<th>位运算</th>
<th>符号</th>
<th>计算</th>
</tr>
</thead>
<tbody>
<tr>
<td>按位与</td>
<td>&amp;</td>
<td>相同为 1，不同为 0</td>
</tr>
<tr>
<td>按位或</td>
<td>|</td>
<td>有 1 则 1</td>
</tr>
<tr>
<td>按位异或</td>
<td>^</td>
<td>相同为 0，不同位 1</td>
</tr>
<tr>
<td>按位取反</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>左移</td>
<td>&lt;&lt;</td>
<td>相当于乘以 2<sup>n</sup></td>
</tr>
<tr>
<td>右移</td>
<td><code>&gt;&gt;</code></td>
<td>相当于除以 2<sup>n</sup></td>
</tr>
<tr>
<td>无符号右移</td>
<td><code>&gt;&gt;&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2> 参考资料</h2>
<p><a href="https://www.zhihu.com/question/28562088/answer/111668116" target="_blank" rel="noopener noreferrer">HashCode 计算扰动分析 - 关于 hashMap 的一些按位与计算的问题？ - 胖君的回答 - 知乎 </a></p>
<p><a href="http://baijiahao.baidu.com/s?id=1646023968436883100&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener noreferrer">一文读懂 Java 之 HashMap 索引位置计算</a></p>
<p><a href="https://blog.csdn.net/changhangshi/article/details/82114727" target="_blank" rel="noopener noreferrer">hashMap 在 jdk1.7 与 jdk1.8 中的原理及不同</a></p>
<p><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener noreferrer">真实面试题之：Hashmap 的结构，1.7 和 1.8 有哪些区别</a></p>
<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener noreferrer">Java 8 系列之重新认识 HashMap</a></p>
<p><a href="http://www.blogjava.net/killme2008/archive/2009/04/15/265721.html" target="_blank" rel="noopener noreferrer">java.util.HashMap 源码要点浅析</a></p>
<p><a href="https://coderanch.com/t/469720/java/HashMap-Entry-transient" target="_blank" rel="noopener noreferrer">Why HashMap.Entry is transient?</a></p>
<p><a href="https://segmentfault.com/q/1010000000630486" target="_blank" rel="noopener noreferrer">Java 中 HashMap 关键字 transient 的疑惑</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 笔记之匿名内部类和 final</title>
      <link>https://jixiaoyong.github.io/blog/posts/875283bd.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/875283bd.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 笔记之匿名内部类和 final</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 20 Dec 2019 14:02:16 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 为什么<code>匿名内部类</code>使用<code>局部引用</code>要用<code>final</code>？</h2>
<p>先说结论：</p>
<p>由于 JAVA 匿名内部类的实现并不是真正的闭包，而是在生成内部类的时候<strong>将局部变量的引用拷贝了一份到内部类中</strong>。如果不将这个外部类设置为<code>final</code>的话，外部类或者内部类修改这个局部变量后，另外一处使用的仍然是修改前的值，这样就会产生问题，而如果将其修改为<code>final</code>则保证了局部变量与内部类使用的值是一致的。</p>
<h2> JDK1.8 后局部变量不要求用<code>final</code>了？</h2>
<p>不对，仍然是要求<code>final</code>的。</p>
<p>只不过编译器判断该局部变量不会再被修改时（<em>effectively final</em> 事实上的<code>final</code>），可以省略。</p>
<blockquote>
<p>Any local variable, formal parameter, or exception parameter used but not declared in an inner class <strong>must either be declared final or be effectively final</strong> (§4.12.4), or a compile-time error occurs where the use is attempted.</p>
<p>Any local variable used but not declared in an inner class must be definitely assigned (§16 (Definite Assignment)) before the body of the inner class, or a compile-time error occurs.</p>
<p><a href="https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3</a></p>
</blockquote>
<h2> 为什么外部类的全局变量不需要<code>final</code>？</h2>
<p>因为全局变量是通过传入内部类的**外部类引用<code>this$0</code>**来引用的 (而非直接复制全局变量的值)，这样内部类和外部类持有的是同一个全部变量，自然不会存在两处更新不同步的问题。</p>
<h2> 源码解析</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看看内部类<code>OutClass$1</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p><a href="https://www.runoob.com/w3cnote/inner-lambda-final.html" target="_blank" rel="noopener noreferrer">https://www.runoob.com/w3cnote/inner-lambda-final.html</a></p>
<p><a href="https://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class/4732617#4732617" target="_blank" rel="noopener noreferrer">Why are only final variables accessible in anonymous class?--stackoverflow</a></p>
<p><a href="https://www.zhihu.com/question/21395848/answer/110829597" target="_blank" rel="noopener noreferrer">java 为什么匿名内部类的参数引用时 final？ - 胖君的回答 - 知乎</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 笔记之计算 Java 对象的大小及其应用</title>
      <link>https://jixiaoyong.github.io/blog/posts/b0793c74.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b0793c74.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 笔记之计算 Java 对象的大小及其应用</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 21 Dec 2019 01:44:32 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 原理</h2>
<p><strong>注意 除非特殊说明，以下所说的计算 Java 对象大小，不涉及该对象所持有的对象本身的大小，只计算该 Java 对象本身的大小（其中引用类型对象大小只计算为 4 bytes），如果要遍历计算 Java 对象大小（包含其持有对象的大小）可以参考<a href="https://www.javaworld.com/article/2077408/sizeof-for-java.html" target="_blank" rel="noopener noreferrer">这篇文章 Sizeof for Java</a></strong></p>
<p>一个 Java 对象在内存中的大小包括以下 (以 64 位 JVM 启用压缩为例，综合<a href="https://blog.csdn.net/ITer_ZC/article/details/41822719" target="_blank" rel="noopener noreferrer">这里</a>和<a href="https://blog.csdn.net/u013380694/article/details/102739636" target="_blank" rel="noopener noreferrer">这里</a>的信息整理)：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>大小（byte）</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象头</td>
<td>8</td>
<td>保存对象的 class 信息、ID、在虚拟机中的状态</td>
</tr>
<tr>
<td>Oop 指针</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>数据区</td>
<td></td>
<td>对象实际包含的数据，引用类型大小为 4 bytes</td>
</tr>
<tr>
<td>数组长度</td>
<td>4</td>
<td>只有数组对象才有</td>
</tr>
<tr>
<td>8 比特对齐</td>
<td></td>
<td>将对象总大小对齐到 8 字节所需的填充</td>
</tr>
</tbody>
</table>
<blockquote>
<p>此外，如果是（非静态）内部类的话，由于他默认持有外部类的引用，所以会比普通类的对象多 4 个 byte。</p>
<p><a href="https://stackoverflow.com/a/12193259/8389461" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/a/12193259/8389461</a></p>
</blockquote>
<p>可以参照<a href="https://www.jianshu.com/p/9d729c9c94c4" target="_blank" rel="noopener noreferrer">这张图</a></p>
<figure><img src="https://jixiaoyong.github.io/images/20191221191518.webp" alt="图片来自 https://www.jianshu.com/p/9d729c9c94c4" tabindex="0" loading="lazy"><figcaption>图片来自 <a href="https://www.jianshu.com/p/9d729c9c94c4" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/9d729c9c94c4</a></figcaption></figure>
<p>其中，数据区占用的大小如下：</p>
<p>（图片来自于<a href="https://speakerdeck.com/romainguy/android-memories?slide=29" target="_blank" rel="noopener noreferrer">android-memories</a>）</p>
<figure><img src="https://jixiaoyong.github.io/images/20191221104050.png" alt="Size of data from speakerdeck.com" tabindex="0" loading="lazy"><figcaption>Size of data from <a href="http://speakerdeck.com" target="_blank" rel="noopener noreferrer">speakerdeck.com</a></figcaption></figure>
<p>##示例</p>
<p>根据<a href="https://speakerdeck.com/romainguy" target="_blank" rel="noopener noreferrer">Romain Guy</a>在<a href="https://speakerdeck.com/romainguy/android-memories?slide=34" target="_blank" rel="noopener noreferrer">SpeakerDeck</a>中的说法：</p>
<blockquote>
<p>一个空的 class 占用了 4+8=12 个 byte 的内存，再加上 8 比特对齐，实际占用大小为 16 比特。</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>占用大小：</p>
<table>
<thead>
<tr>
<th>Allocation</th>
<th>Size in bytes</th>
</tr>
</thead>
<tbody>
<tr>
<td>dlmalloc 引用</td>
<td>4</td>
</tr>
<tr>
<td>Object overhead（对象头）</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>Total = 4 + 8 =12 bytes</p>
<p>经过<em>8-byte aligned</em>后：total = 16 bytes</p>
<p><a href="https://speakerdeck.com/romainguy/android-memories?slide=34" target="_blank" rel="noopener noreferrer">https://speakerdeck.com/romainguy/android-memories?slide=34</a></p>
</blockquote>
<p>此外还有<strong>包含了数据的对象</strong>大小计算方式如下：</p>
<figure><img src="https://jixiaoyong.github.io/images/20191221171816.png" alt="图片来自 https://speakerdeck.com/romainguy/android-memories?slide=42" tabindex="0" loading="lazy"><figcaption>图片来自 <a href="https://speakerdeck.com/romainguy/android-memories?slide=42" target="_blank" rel="noopener noreferrer">https://speakerdeck.com/romainguy/android-memories?slide=42</a></figcaption></figure>
<p>对于数组的大小计算（参考<a href="https://www.cnblogs.com/zhanjindong/p/3757767.html" target="_blank" rel="noopener noreferrer">一个 Java 对象到底占用多大内存？</a>和<a href="https://speakerdeck.com/romainguy/android-memories?slide=54" target="_blank" rel="noopener noreferrer">romainguy/android-memories</a>，后者关于数组大小的计算中<code>width&amp;padding = 8 </code>的意义存疑）:</p>
<p>按照开头的公式：<code>数组大小 = 8 对象头 + 4 Oop指针 + 4 数组大小标记length + 数组数据占用大小 + 8比特对齐 </code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 计算对象大小的工具</h2>
<p>具体的如何计算 Java 中 Object 大小，可以参考<a href="https://stackoverflow.com/a/52682/8389461" target="_blank" rel="noopener noreferrer">stackoverflow 的这个回答</a>（<a href="https://github.com/cirosantilli/java-cheat/tree/a907ad2243dce2109c54d27323f9387065b5ca5c/instrument" target="_blank" rel="noopener noreferrer">这里</a>有一份 Github 上面的实现源码）</p>
<p>可以参考文章：</p>
<p><a href="https://blog.csdn.net/ITer_ZC/article/details/41822719" target="_blank" rel="noopener noreferrer">聊聊 JVM（三）两种计算 Java 对象大小的方法</a></p>
<p><a href="https://www.iteye.com/blog/brandnewuser-2113828" target="_blank" rel="noopener noreferrer">准确计算 Java 中对象的大小</a></p>
<p><a href="https://www.cnblogs.com/zhanjindong/p/3757767.html" target="_blank" rel="noopener noreferrer">一个 Java 对象到底占用多大内存？</a></p>
<p>这里提供一个实例（<a href="https://github.com/cirosantilli/java-cheat/tree/a907ad2243dce2109c54d27323f9387065b5ca5c/instrument" target="_blank" rel="noopener noreferrer">参考自这里</a>）：</p>
<p><code>Sizeof.java</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Makefile</code></p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用时先新建一个 Java 类，在其中调用<code>sizeof()</code>方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以用如下命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 实际应用</h2>
<h3> <code>String</code>最长为 65534</h3>
<p><code>String s = “”;</code>中，在编译期最多可以有 65534 个字符</p>
<blockquote>
<p><s>原因是，Java 中的 UTF-8 编码的 Unicode 字符串在常量池中以<code>CONSTANT_Utf8</code>类型表示，常量池中的所有字面量几乎都是通过<code>CONSTANT_Utf8_info</code>描述的。</s></p>
<p><s>这里面的<code>u2 length</code>表明了该类型存储数据的长度，而<code>u2</code>是无符号的 16 位整数，因此理论上允许的的最大长度是<code>2^16=65536</code>。而 Java class 文件是使用一种变体<code>UTF-8</code>格式来存放字符的，<code>null</code> 值使用两个字节来表示，因此只剩下<code> 65536－ 2 ＝ 65534</code>个字节。</s></p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>所以，在 Java 中，所有需要保存在常量池中的数据，长度最大不能超过 65535，这当然也包括字符串的定义</strong></p>
<p>上面提到的这种 String 长度的限制是<em>编译期的限制</em>，也就是使用<code>String s= “”;</code>这种字面值方式定义的时候才会有的限制。</p>
<p>String 在<em>运行期</em>有没有限制呢，答案是有的，就是我们前文提到的那个<code>Integer.MAX_VALUE </code>，这个值约等于 4G，在运行期，如果 String 的长度超过这个范围，就可能会抛出异常。(在 jdk 1.9 之前）</p>
<p><a href="https://blog.csdn.net/u013380694/article/details/102739636" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/u013380694/article/details/102739636</a></p>
</blockquote>
<p><strong>一个 String 对象，占用大小（JDK1.8）为 24 bytes</strong>（不计算持有的 char 数组占用的大小）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再加上在 64 位 JVM 中，一个对象具有 12 bytes 的<code>对象头+引用</code>，要求对齐到 8 的倍数 (来源<a href="https://www.baeldung.com/java-size-of-object#1-objects-references-and-wrapper-classes" target="_blank" rel="noopener noreferrer">2.1. Objects, References and Wrapper Classes</a>)，所以一个 String 对象的大小是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 枚举类 enum</h3>
<h4> 枚举类大小的计算</h4>
<p>枚举类中的每个枚举都是该枚举类的一个对象。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们用<code>javap</code>查看其编译后的字节码可以看到：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单计算一下这个<code>EnumClazz</code>的大小（不含引用对象的大小）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们再看一下每个枚举类的值（以<code>EnumClazz.Day</code>为例）的大小：</p>
<p><code>enum</code>类的每个值实际上都继承自<code>java.lang.Enum</code>类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由此，我们可以计算<code>EnumClazz.Day</code>的大小：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，本例中<strong>每一个枚举类值占用 24 bytes</strong>，由此可以计算出<code>EnumClazz</code>实际占用的大小应该是：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> Android 中是否应该使用枚举</h4>
<p>关于 Android 中使用枚举和常量所占用的大小对比<em>RomainGuy</em>有<a href="https://speakerdeck.com/romainguy/android-memories?slide=67" target="_blank" rel="noopener noreferrer">下图</a>的对比。</p>
<figure><img src="https://jixiaoyong.github.io/images/20191221172243.png" alt="https://speakerdeck.com/romainguy/android-memories?slide=67" tabindex="0" loading="lazy"><figcaption><a href="https://speakerdeck.com/romainguy/android-memories?slide=67" target="_blank" rel="noopener noreferrer">https://speakerdeck.com/romainguy/android-memories?slide=67</a></figcaption></figure>
<p>关于是否应该在 Android 中使用枚举类，可以参考下文：</p>
<p><a href="https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/" target="_blank" rel="noopener noreferrer">https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/</a></p>
<p><a href="https://stackoverflow.com/a/29972028/8389461" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/a/29972028/8389461</a></p>
<p>总结起来其结论就是：</p>
<p><strong>当需要用到枚举类的特性时，比如非连续判断，方法重载等时就使用枚举，否则就使用占用内存更小的常量类。</strong></p>
<h3> SparseArray&amp;ArrayMap VS HashMap</h3>
<p><code>HashMap</code>的数据是经过包装后保存在<code>HashMap.Node&lt;K,V&gt;</code>数组中。</p>
<p>下面是<code>HashMap</code>的结构：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看看 Android 提供的<code>android.util.SparseArray</code>类 (具体分析可参考：<a href="https://juejin.im/entry/57c3e8c48ac24700634bd3cf" target="_blank" rel="noopener noreferrer">SparseArray 的使用及实现原理</a>)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再结合<a href="https://developer.android.google.cn/reference/android/util/SparseArray" target="_blank" rel="noopener noreferrer">官方的描述</a>，<code>SparseArray</code>类很明显要比<code>HashMap</code>占用更少的内存：</p>
<ul>
<li>将<code>KEY</code>和<code>VALUE</code>直接保存在数组中，避免了将其包装为一个<code>Node</code>对象的开销</li>
<li>由于<code>SparseArray</code>类的 key 是<code>int</code>类型而非被自动装箱后的<code>Integer</code>对象，所以当同样使用<code>int</code>类型的<code>key</code>保存数据时，<code>SparseArray</code>类的<code>key</code>要占用更少的内存。</li>
</ul>
<blockquote>
<p><code>SparseArray</code> is intended to be more memory-efficient than a <a href="https://developer.android.google.cn/reference/java/util/HashMap" target="_blank" rel="noopener noreferrer"><code>HashMap</code></a>, because it <strong>avoids auto-boxing keys</strong> and its data structure <strong>doesn't rely on an extra entry</strong> object for each mapping.</p>
<p><a href="https://developer.android.google.cn/reference/android/util/SparseArray" target="_blank" rel="noopener noreferrer">https://developer.android.google.cn/reference/android/util/SparseArray</a></p>
</blockquote>
<p>但是，<code>SparseArray</code>有以下局限性：</p>
<ul>
<li>
<p>在每次<code>put/get/remove</code>的时候都需要使用二分法 (<code>ContainerHelpers.binarySearch(mKeys, mSize, key)</code>) 查找是否已经存在<code>KEY</code>对应的值（有的话查找其位置）</p>
</li>
<li>
<p>在添加和删除 item 的时候都需要在数组中增删条目（耗时，尽管为了优化性能，<code>SparseArray</code>在删除时只是将对于的值标记为<code>DELETED</code>，在下次更新该<code>KEY</code>对于的值时直接覆盖，或者在<code>GC</code>时删除）。</p>
<p><code>  private static final Object DELETED = new Object();</code></p>
<p>HashMap 的删除涉及到数组、链表和红黑树（JDK1.8）</p>
</li>
<li>
<p><strong>在容纳数百个项目时性能会比 HashMap 小大约 50%</strong>。</p>
</li>
</ul>
<blockquote>
<p>每当需要<strong>增长数组</strong>或<strong>获取数组大小</strong>或<strong>获取条目值</strong>时，都必须执行垃圾回收 GC。</p>
</blockquote>
<p>此外，还有以下可以替换 HashMap 的 (数据来自<a href="https://stackoverflow.com/a/31413003/8389461" target="_blank" rel="noopener noreferrer">这里</a>)：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，还有<code>android.util.ArrayMap</code>其特性与<code>SparseArray</code>类似（<strong>两者占用内存小，但是慢并且最好不要用来存储大容量的数据</strong>），只不过它支持 key 值为其他类型，占用内存大小在<code>SparseArray</code>和<code>HashMap</code>之间 (参考<a href="https://blog.csdn.net/u010687392/article/details/47809295" target="_blank" rel="noopener noreferrer">这里</a>)，此外<code>ArrayMap</code>的 API 和<code>HashMap</code>类似。</p>
<blockquote>
<p>根据<a href="https://speakerdeck.com/romainguy" target="_blank" rel="noopener noreferrer">Romain Guy</a>的<a href="https://speakerdeck.com/romainguy/android-memories?slide=94" target="_blank" rel="noopener noreferrer">计算</a>：</p>
<p>保存 1000 个 int 对象的<code>SparseArray</code> 占用大小为：8072 bytes</p>
<p>保存 1000 个对象的<code>HashMap&lt;Integer,Integer&gt;</code> 占用大小为：64136 bytes</p>
<p>几乎相差 8 倍！</p>
</blockquote>
<p>综上，<strong>当要保存的数据量比较小（小于几千个）的时候，如果 KEY 是基本类型，推荐使用<code>SparseArray</code>及其衍生类以节省内存，如果 KEY 是其他类型则使用<code>ArrayMap</code>;否则使用<code>HashMap</code>更加高效</strong>。</p>
<h2> 参考资料</h2>
<p>除文章中罗列的链接外：</p>
<p><a href="https://blog.csdn.net/u013380694/article/details/102739636" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/u013380694/article/details/102739636</a></p>
<p><a href="https://www.javaworld.com/article/2077408/sizeof-for-java.html" target="_blank" rel="noopener noreferrer">Sizeof for Java -- javaworld.com</a></p>
<p><a href="https://speakerdeck.com/romainguy/android-memories" target="_blank" rel="noopener noreferrer">RomainGuy-Android Memories</a>（推荐）</p>
<p><a href="https://stackoverflow.com/a/31413003/8389461" target="_blank" rel="noopener noreferrer">SparseArray vs HashMap</a></p>
<p><a href="https://blog.csdn.net/u010687392/article/details/47809295" target="_blank" rel="noopener noreferrer">Android 内存优化（使用 SparseArray 和 ArrayMap 代替 HashMap）</a></p>
<p><a href="https://juejin.im/entry/57c3e8c48ac24700634bd3cf" target="_blank" rel="noopener noreferrer">SparseArray 的使用及实现原理</a></p>
<p><a href="https://developer.android.google.cn/reference/android/util/SparseArray" target="_blank" rel="noopener noreferrer">SparseArray -- developer.android.google.cn</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20191221191518.webp" type="image/webp"/>
    </item>
    <item>
      <title>Java 笔记之 ThreadLocal</title>
      <link>https://jixiaoyong.github.io/blog/posts/9a8e41a8.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/9a8e41a8.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 笔记之 ThreadLocal</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 20 Dec 2019 04:54:48 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>ThreadLocal</code>是<code>Thread</code>中用来保存<strong>线程私有变量</strong>的数据结构。</p>
<p>一个<code>ThreadLocal</code>只能保存一个值，有<code>set/get/remove</code>方法。</p>
<p>在<code>Thread</code>有一个<code>threadLocals</code>（<code>ThreadLocal.ThreadLocalMap</code>）变量，该变量是一个定制的 Hash Map，用来保存线程私有的数据（类型为<code>ThreadLocal&lt;?&gt; Key, Object Value</code>）。</p>
<h2> 特点</h2>
<ol>
<li>
<p>一个<code>Thread</code>可以有多个<code>ThreadLocal</code>变量</p>
</li>
<li>
<p><strong>不同<code>Thread</code>可以通过一个<code>ThreadLocal</code>变量分别保存不同的变量而互不影响</strong>。</p>
</li>
<li>
<p>如果不同的<code>Thread</code>使用的<code>ThreadLocal</code>变量保存的是<strong>同一个引用类型的对象</strong>（假设为<code>obj</code>），无论这些<code>Thread</code>使用的是同一个<code>ThreadLocal</code>对象还是完全不同的<code>ThreadLocal</code>对象，只要<code>obj</code>指向的对象改变，其余线程中的<code>ThreadLocal</code>对象也会访问到<code>obj</code>的最新值。</p>
</li>
</ol>
<h2> 使用与解析</h2>
<p>当我们新建一个<code>ThreadLocal</code>并为之赋值时</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候就会调用<code>set()</code>方法（方式 1）或者<code>setInitialValue()</code>方法（方式 2）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这两个方法到最后都相当于调用了<code>Thread</code>对象的<code>threadLocals</code>的<code>set(ThreadLocal&lt;?&gt; key, Object value)</code>方法，这个方法最终以<code>ThreadLocal</code>对象为 KEY，将数据保存到了<code>Thread</code>对象自己的<code>threadLocals</code>中。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以即使是<strong>同一个<code>ThreadLocal</code>对象，在不同的线程中进行<code>set/get/remove</code>都只是更新了本线程中<code>ThreadLocal</code>对象对应的值</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 内存泄漏</h2>
<p>在<code>ThreadLocal.ThreadLocalMap</code>中，最终用来保存<code>ThreadLocal</code>以及对应值的是一个<code>Entry</code>数组：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的代码可以看到，<code>Entry</code>对<code>ThreadLocal</code>是<strong>弱引用</strong>，按照“强软弱虚”引用的等级来划分，每次 GC 的时候，如果这个<code>ThreadLocal</code>对象没有被引用，就会被回收掉，这时如果该<code>Thread</code>还在运行，那么<code>threadLocals</code>中保存的<code>ThreadLocal&lt;?&gt; k</code>已经被回收了，但是<code>Object v</code>对象仍然保存在<code>threadLocals</code>中但是没有办法再访问到，造成内存泄漏。</p>
<p>解决方法参考：</p>
<blockquote>
<p>使用<code>ThreadLocal</code>时会发生内存泄漏的前提条件：</p>
<p>①<code>ThreadLocal</code>引用被设置为<code>null</code>，且后面没有<code>set，get,remove</code>操作。</p>
<p>② 线程一直运行，不停止。（线程池）</p>
<p>③ 触发了垃圾回收。（Minor GC 或 Full GC）</p>
<p>我们看到<code>ThreadLocal</code>出现内存泄漏条件还是很苛刻的，所以我们只要破坏其中一个条件就可以避免内存泄漏，单但为了更好的避免这种情况的发生我们使用<code>ThreadLocal</code>时遵守以下两个小原则：</p>
<p>①<code>ThreadLocal</code>申明为<code>private static final</code>。 <code>Private</code>与<code>final </code>尽可能不让他人修改变更引用， <code>Static </code>表示为类属性，只有在程序结束才会被回收。</p>
<p>②<code>ThreadLocal</code>使用后务必调用<code>remove</code>方法。最简单有效的方法是使用后将其移除。</p>
<p>版权声明：本文为 CSDN 博主「pony-zi」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：<a href="https://blog.csdn.net/zzg1229059735/article/details/82715741" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/zzg1229059735/article/details/82715741</a></p>
</blockquote>
<h2> 总结</h2>
<p>现在我们知道了，所谓的<em>通过<code>ThreadLocal</code>实现线程本地变量与其他线程隔离</em>，是在创建<code>ThreadLocal</code>的时候，<strong>保存的就是属于当前线程的独立的变量，并且之后的修改也不会（无法）修改到其他线程中对应的值</strong>，但如果<code>ThreadLocal</code>本身保存的都是同一个对象，则这个对象在所有的线程中还是共享的。</p>
<h2> 参考资料</h2>
<p><a href="https://www.cnblogs.com/whoislcj/p/5811989.html" target="_blank" rel="noopener noreferrer">Android 线程管理之 ThreadLocal 理解及应用场景</a></p>
<p><a href="https://blog.csdn.net/shenyo/article/details/80391818" target="_blank" rel="noopener noreferrer">ThreadLocal 深入分析（Jdk 1.8）</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 中三种常用的排序方法</title>
      <link>https://jixiaoyong.github.io/blog/posts/1fd30f6e.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/1fd30f6e.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 中三种常用的排序方法</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 20 Dec 2016 15:25:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。<br>
以下示例皆为从小到大的排序</p>
<h2> 1.冒泡排序</h2>
<p>每一次比较都可能要交换元素。<br>
冒泡排序的思想是：<br>
每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为 m）放到后面，并将 m 与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。<br>
在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。<br>
依次类推，总共遍历 n-1 轮，即可完成排序。<br>
具体代码如下：</p>

<h2> 2.选择排序</h2>
<p>每次比较的时候不交换<br>
选择排序的思想：<br>
每次比较的时候找到的两个数中的较大值并记下其位置，等到当前一轮的遍历完成之后，将最后一个未排序元素与这一轮遍历找到的最大值交换<br>
最多交换 n-1 次<br>
代码如下：</p>

<h2> 3.插入排序法</h2>
<p>插入排序法思想：<br>
将待排序的元素分为有序和无序两种，刚开始排序的时候假设只有第一个元素是有序的，其余 n-1 个元素都是无序的；<br>
排序开始的时，将无序部分的一个元素（a）与有序部分的最后一个元素（b）进行比较，如果 a&lt;b，则将 a 与 b 交换，再将 a 与下一个有序元素进行比较；否则，将 a 加到 b 后面，作为有序部分的最后一个元素。<br>
接着再从无序部分取出一个元素与有序部分的元素依次比较，直达所有元素都为有序元素。<br>
遍历 n-1 次<br>
代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Java 中的泛型</title>
      <link>https://jixiaoyong.github.io/blog/posts/b2cdb69e.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b2cdb69e.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 中的泛型</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 03 Nov 2018 03:01:34 GMT</pubDate>
      <content:encoded><![CDATA[<p>Java 中的泛型实现了<strong>参数类型化</strong>的概念。</p>
<p>主要有以下形式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本文主要记录 Java 泛型一些比较特殊的知识点。</p>
<h2> 泛型特性</h2>
<p>泛型在 Java SE5 被引入，可以在类和方法中，将类型作为类型参数传入。</p>
<p>泛型类型参数会在实际运行时被<strong>擦除</strong>到他的第一个边界。如<code>&lt;T&gt;</code>会被擦除为<code>Objet</code>，而<code>&lt;T extends ClazzA&gt;</code>则会被擦除为<code>ClazzA</code>。</p>
<h2> 需要注意的地方</h2>
<h3> 不能有泛型数组</h3>
<p>这是因为 Java 中 Object[]默认为所有数组的父类，如下代码虽然在编译期不会报错，但是在运行时会被检查出 objArr 指向的数组实际类型（String）和要赋予的类型（Integer）不一致而报错。</p>
<p>也就是说，数组只能存放<strong>定义的实际类型</strong>以及他们的<strong>子类型</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果支持泛型数组：由于泛型类型参数会在运行时被擦除，导致即使到了运行时也无法发现这个错误，从而会导致错误。</p>
<p>如下，加入支持泛型参数，则 objArr1 中实际保存的类型（Map&lt;String,Integer&gt;），在编译的时候由于 objArr1 和 objArr2 都是 Object 类型的数组，编译通过；在运行的时候，由于 Map 中的泛型参数类型已经被擦除，也无法区分 objArr1 和 objArr2 中实际指向的两个 Map&lt;K,V&gt;数组，也是合法的，这样原本定义的是 Map&lt;String,Integer&gt;数组，却可以保存任何类似的 Map，而这本来是不允许的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Collections 类通过一种别扭的方法绕过了这个问题，在 Collections 类编译时会产生类型未检查转换的警告。</p>
<p><code>ArrayList</code>具体实现的构造函数如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为何这些代码在访问 <code>backingArray</code>时没有产生 <code>ArrayStoreException</code>呢？无论如何，都不能将 <code>Object</code>数组赋给 <code>String</code>数组。因为泛型是通过擦除实现的，<code>backingArray</code>的类型实际上就是 <code>Object[]</code>，因为 <code>Object</code>代替了 <code>V</code>。</p>
<p><strong>这意味着：实际上这个类期望 <code>backingArray</code>是一个 <code>Object</code>数组，但是编译器要进行额外的类型检查，以确保它包含 <code>V</code>类型的对象。</strong></p>
<p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/java/j-jtp01255.html</a></p>
</blockquote>
<h2> 泛型容器</h2>
<p>由于泛型的类型在运行时会被擦除，所以将类型检查放到了编译期。</p>
<p><code>List&lt;Clazz&gt;</code> 泛型列表只能保存指定泛型类型<code>T</code>的数据，而不能保存其子类。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是能保存 Fruit 的容器应该也要能安全的保存 Apple，为了实现这一点，类似于数组中<code>Object[] arr = Apple[]</code>的向上转型，可以使用<code>?</code>引入协变。</p>
<h3> 协变</h3>
<p><code>List&lt;? extends T&gt;</code> 可以<strong>合法的指向一个<code>List&lt; SubT&gt;</code></strong>，这个过程会完成自动<strong>向上转型</strong>，成为可以持有<strong>某个诸如 T 或者 T 的子类</strong>的 List，但是编译器不知道这个<strong>类</strong>具体是什么，所以拒绝向其中传递任何类型对象，即使 Object 也不行。</p>
<p>可以这么想，<code>&lt;? extends T&gt;</code>表示的是 T 的子类，那么<code>List&lt;? extends T&gt;</code> 保存的便是<strong>T 的某个子类</strong>，所以不能保存 Object 或者 T 等类型，又由于列表不能保存不同的类型，所以也不能保存任何 T 的子类，即容器将数组在运行时才会有的类型检查放到了编译期（原因是运行时类型会被擦除）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 逆变</h3>
<p><code>List&lt;? super T&gt;</code> <strong>主动声明</strong>通配符<code>?</code>的超类型为<code>T</code>,即 List 保存的是<strong>T 的某个父类</strong>，那么 List 也可以安全的保存<strong>T 或者 T 的子类</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p><a href="https://www.zhihu.com/question/20928981/answer/39234969" target="_blank" rel="noopener noreferrer">java 为什么不支持泛型数组？ - ylxfc 的回答 - 知乎</a></p>
<p><a href="https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html" target="_blank" rel="noopener noreferrer">Oracle Java 泛型原理</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html" target="_blank" rel="noopener noreferrer">Java 理论和实践 - 了解泛型 - 识别和避免学习使用泛型过程中的陷阱</a></p>
<p><a href="https://www.jianshu.com/p/2bf15c5265c5" target="_blank" rel="noopener noreferrer">Java 泛型（二）协变与逆变</a></p>
<p>《Java 编程思想 第 4 版》</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 创建线程安全的单例 Singleton</title>
      <link>https://jixiaoyong.github.io/blog/posts/36721083.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/36721083.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 创建线程安全的单例 Singleton</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 14 Feb 2018 10:34:16 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>在编码中常常会用到单例，来确保类有一个唯一的对象，一般情况下将构造方法私有化既可以实现，但当考虑到多线程时事情会变得有些复杂，本文讨论的正是几种多线程的情况下实现单例的方法。</p>
<h2> 1.普通单例</h2>
<p>私有化构造方法，对外提供一个公有、静态的方法，在其内部判断类对象是否已经存在，否的话生成类对象再返回。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，在考虑多线程时，由于 java 代码是一行行进行的，假设有两个线程 t1、t2，当 as 为 null 的时候 t1 执行到 tag1 位置，判断为 true，于是准备执行 tag2，就在此时，cup 调度 t2 开始执行 tag1，此时 t1 尚未执行 tag2，所以在 t2 中 tag1 判断为 true,t2 也开始执行 tag2 生成一个新对象,这样当 t1 再次执行 tag2 时就会再生成一个新对象，这样就同时存在多个类的对象。</p>
<h2> 2.同步锁</h2>
<p>对上面的代码稍作优化,可以看到使用了 synchronized，对判断是否需要初始化进行了同步锁，这样当线程 t1 访问时，语句被锁定，t2 运行到这里时，只能等 t1 运行完这段语句并释放之后，才能继续访问，此时 as 已经被赋予了对象，所以不会再继续新建，这样就保证了单例。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样也存在一个问题，每个线程每次获取单例都要进入同步锁，这样累计下来必然影响效率。</p>
<h2> 3.双重检查锁定</h2>
<p>那么在判断 as 为 null 后，对 as 的初始化进行同步锁呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样子，当判断 as 为 null 时，才会进行初始化，同时由于初始化过程加锁，所以 t1 和 t2 无法同时访问初始化语句 tag2，也保证了只能创建一个单例。</p>
<p>看起来很完美，但是由于 java 语言的特性，在该段代码编译为汇编语言时，上述方法会被编译为类似下面的过程：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，当 t1 执行到语句 2，而 t2 开始执行语句 1 时，此时由于 as 已经分配了内存不为 null，所以 t2 直接执行语句 4，此时 t2 获取到的是一个没有执行构造方法的 ASingleton 对象，显然这样十分危险。在线程复杂的情况下很容易出现问题。</p>
<p>下面提供了两个结局思路，为简便起见，将其简单分为“饿汉模式”和“懒汉模式”（其实上述方法也可分为这两个模式，but，who cares...）。</p>
<h2> 4.饿汉模式实现单例</h2>
<p>饿汉模式，即在声明的时候就将对象初始化。</p>
<p>这样实现单例的原理是类的静态变量全局唯一。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样仍然有个问题，可能在用到 ASingleton 类的时候，并不需要立即获取到其单例，在这种情况下，饿汉模式仍然有浪费资源的嫌疑。</p>
<h2> 5.懒汉模式实现单例</h2>
<p>懒汉模式，只有要用到该实例时，才获取该单例。</p>
<p>这次我们用到的时静态内部类，静态内部类与类的静态变量不同，只有明确调用静态内部类的时候才会初始化静态内部类。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，至此已经完成了 java 实现单例的绝大部分方法，但其实还有一张更加简洁的方法，那就是用 enmu 实现。</p>
<h2> 6.enmu 实现单例</h2>
<p>由于枚举类型的对象是唯一的，所以是实现单例的较优选择。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，android 开发者要注意，枚举占用的内存是普通单例的两倍多，所以，并不推荐在 android 中使用。</p>
<p>关于枚举的更详细资料，参阅(深入理解 Java 枚举类型(enum))[<a href="http://blog.csdn.net/javazejian/article/details/71333103#t7" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/javazejian/article/details/71333103#t7</a>]</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 反射简单应用</title>
      <link>https://jixiaoyong.github.io/blog/posts/3e9e8cb1.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/3e9e8cb1.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 反射简单应用</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 16 Jan 2018 13:28:57 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>反射，用来在运行时获取给定类的构造函数，变量，方法，并对其作以修改，而不必在编译时获取该类。</p>
<blockquote>
<p>Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</p>
<p>--<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html</a></p>
</blockquote>
<h2> 简单使用</h2>
<p>定义一个待反射的类 ATestClass.java</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 TestReflect.java 中反射</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 小结</h2>
<p>反射的用法较为简单</p>
<ul>
<li>通过<code>Class.froName()</code> 获取 Class 对象<code>clazz</code> ，获取要反射的 Class 对象<code>aTestClsObj</code></li>
<li>通过<code>clazz</code> 获取要反射 Class 的变量、方法</li>
<li>通过<code>aTestClsObj</code> 操作这些变量，方法</li>
</ul>
<p>其中需要注意的有</p>
<ul>
<li><code>f.setAccessible(true);</code> 方法可以解除<code>private</code> 限制，进而可以操作类的私有变量，方法</li>
<li><code>clazz.getXXX()</code> 方法获取<strong>全部公有</strong>变量、方法，<strong>包括父类或接口</strong>的 xx，<code>clazz.getDeclaredXXX()</code> 方法获取<strong>全部</strong> 变量、方法，包括私有的，实现接口的方法，<strong>但是不包括父类的</strong></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 实现 AES 加密解密应用</title>
      <link>https://jixiaoyong.github.io/blog/posts/375fcf66.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/375fcf66.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 实现 AES 加密解密应用</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 22 Jan 2018 15:51:19 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>最近手机中涉及到用户账户密码保存的问题，选用 AES 加密算法进行加密后，再通过 SharedPreferences 保存在手机端。</p>
<p>本文主要介绍 AES 的加密、解密用法。</p>
<h2> 代码</h2>
<p>初始化秘钥</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加密</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解密</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加密和解密的结果都是二进制的，无法直接转化为字符串，所以还需要将二进制与十六进制互转</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以在初始化一个 key 后，对文本进行加密和解密</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考文献</h2>
<p><a href="http://blog.csdn.net/hbcui1984/article/details/5201247" target="_blank" rel="noopener noreferrer">JAVA 实现 AES 加密 - CSDN 博客</a></p>
<p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-22/encryption" target="_blank" rel="noopener noreferrer">源码 github 链接</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 并发编程笔记</title>
      <link>https://jixiaoyong.github.io/blog/posts/b4abf652.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b4abf652.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 并发编程笔记</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 28 Oct 2019 10:26:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Thread.join()</h2>
<p><code>cThread.join()</code>方法使当前线程阻塞，直到子线程<code>cThread</code>执行完毕后，当前线程才会恢复运行。</p>
<p>实现原理：</p>
<ol>
<li>
<p><code> join()</code>方法调用了<code>join(0)</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code> join(long millis)</code>是一个同步方法，最后会通过调用<code>wait()</code>方法挂起当前线程（即<code>调用线程</code>），直到其他线程调用子线程<code>cThread</code>的<code>notify()</code>或者<code>notifyAll()</code>方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>子线程<code>run()</code>执行完毕后，系统在关闭该子线程前，会调用其<code>exit()</code>方法，继而在<code>ThreadGroup.threadTerminated(Thread t)</code>中唤醒被阻塞的调用线程。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> notify() 和 notifyAll() 的区别区别</h2>
<p>先了解两个概念：</p>
<p><strong>锁池</strong>：某个<code>Thread</code>调用某个对象的同步方法（<code>synchronized</code>），但还没获取到该对象的锁时，会进入锁池和其他类似的线程一起竞争该对象的锁。</p>
<p><strong>等待池</strong>：当某个<code>Thread</code>调用某个对象的<code>wait()</code>方法释放掉该对象的锁进入阻塞后（waiting on this object's monitor），会进入等待池。等待池中的线程不会竞争该对象的锁。</p>
<p><code>notify()</code>方法会从等待池中唤醒一个指定线程，该线程可以再次回到锁池竞争该对象的锁，<strong>但可能会导致死锁</strong>（如果唯一唤醒的线程阻塞了并依赖其他线程唤醒，但其他线程都在等待池无法竞争锁，导致死锁）。</p>
<p><code>notifyAll()</code>方法则会唤醒所有在等待池中的线程，之后他们都可以回到锁池竞争该对象的锁。</p>
<h2> 参考资料</h2>
<p><a href="https://juejin.im/post/5b3054c66fb9a00e4d53ef75#heading-2" target="_blank" rel="noopener noreferrer">Java Thread 的 join() 之刨根问底</a></p>
<p><a href="https://www.zhihu.com/question/37601861/answer/145545371" target="_blank" rel="noopener noreferrer">java 中的 notify 和 notifyAll 有什么区别？ - 大王叫我来巡山的回答 - 知乎</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 注解</title>
      <link>https://jixiaoyong.github.io/blog/posts/3f6454bb.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/3f6454bb.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 注解</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 21 Jan 2018 12:53:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>注解，<em>是描述 Java 代码的代码，它能够被编译器解析，向编译器、虚拟机说明一些事情，就像 java 中给程序员看的注释一样</em>。</p>
<p>Android 应用开发这方面比较火的是<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener noreferrer">Butter Knife</a> ,本文讲述如何自定义注解替换 findViewById()。</p>
<p>实现<strong>注解（annotation）<strong>的思路：通过</strong>反射</strong>获取到类中使用注解的变量，方法，再调用不同的方法对这些变量，方法进行处理以达到目的。</p>
<p>主要涉及三方面：</p>
<ul>
<li>定义一个注解类</li>
<li>定义一个注解帮助类</li>
<li>使用注解</li>
</ul>
<h2> java 元注解</h2>
<p>java 语言有四个预留的注解，用来生成其他自定义的注解：</p>
<ul>
<li>@Target</li>
</ul>
<p>说明注解所能修饰的范围。其值一般为 <a href="http://ElementType.xxx" target="_blank" rel="noopener noreferrer">ElementType.xxx</a>，主要有：</p>
<ol>
<li>CONSTRUCTOR 描述构造器</li>
<li>FIELD 描述域</li>
<li>LOCAL_VARIABLE 描述局部变量</li>
<li>METHOD 描述方法</li>
<li>PACKAGE 描述包</li>
<li>PARAMETER 描述参数</li>
<li>TYPE 描述类，接口，enum 声明</li>
</ol>
<ul>
<li>@Retention</li>
</ul>
<p>说明注解存活的生命周期，其值一般为 <a href="http://RetentionPolicy.xxx" target="_blank" rel="noopener noreferrer">RetentionPolicy.xxx</a>，主要有</p>
<ol>
<li>SOURCE 仅源文件有效，被编译器丢弃</li>
<li>CLASS 在 class 文件中有效，可能被虚拟机忽略</li>
<li>RUNTIME 在运行时有效，在 class 被装载时被获取</li>
</ol>
<ul>
<li>@Documented</li>
</ul>
<blockquote>
<p>用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API</p>
</blockquote>
<p>表示是否将注解信息添加在 java 文档中。有该注解则会被 Javadoc 工具文档化</p>
<p>是一个标记注解，没有值</p>
<ul>
<li>@Inherited</li>
</ul>
<p>表示该标记会被标记的 class 的子类继承，在查找该注解时，如果当前类没有，会自动向上到其父类中查找，直到<em>该注解类型被找到或是查找完了 Object 类还未找到</em></p>
<p>是一个标记注解，没有值</p>
<p><strong>注解不能继承其他注解或接口</strong></p>
<h2> 内建注解</h2>
<p>java 中常见的内建注解：</p>
<ul>
<li><code>@Override</code> 重写父类方法</li>
<li><code>@Deprecated</code> 不赞成使用的 api</li>
<li><code>@SuppressWarnings() </code> 忽略指定警告</li>
</ul>
<p>参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>deprecation</td>
<td>使用了过时的类或方法时的警告</td>
</tr>
<tr>
<td>unchecked</td>
<td>执行了未检查的转换时的警告</td>
</tr>
<tr>
<td>fallthrough</td>
<td>当 Switch 程序块进入进入下一个 case 而没有 Break 时的警告</td>
</tr>
<tr>
<td>path</td>
<td>在类路径、源文件路径等有不存在路径时的警告</td>
</tr>
<tr>
<td>serial</td>
<td>当可序列化的类缺少 serialVersionUID 定义时的警告</td>
</tr>
<tr>
<td>finally</td>
<td>任意 finally 子句不能正常完成时的警告</td>
</tr>
<tr>
<td>all</td>
<td>以上所有情况的警告</td>
</tr>
</tbody>
</table>
<h2> 自定义注解</h2>
<h3> 注解类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注解参数支持数据类型如下：</p>
<p>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>
2.String 类型<br>
3.Class 类型<br>
4.enum 类型<br>
5.Annotation 类型 6.以上所有类型的数组</p>
</blockquote>
<h3> 注解帮助类</h3>
<p>主要提供使用注解的方法，代码中的注解替换为真正要实现的逻辑，为注解和使用注解的类搭建一个桥梁。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用注解</h3>
<p>在类中通过<code>@xxx()</code> 使用注解，并通过帮助类真正实现注解逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考文章</h2>
<ul>
<li><a href="http://www.importnew.com/23816.html" target="_blank" rel="noopener noreferrer">Java 核心技术点之注解 - ImportNew</a></li>
<li><a href="http://gityuan.com/2016/01/23/java-annotation/" target="_blank" rel="noopener noreferrer">java 注解--gityuan</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 笔记之 YYYY 格式化日期</title>
      <link>https://jixiaoyong.github.io/blog/posts/87a89a43.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/87a89a43.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 笔记之 YYYY 格式化日期</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 07 Jan 2020 03:38:54 GMT</pubDate>
      <content:encoded><![CDATA[<p>最近看到一个<a href="https://v2ex.com/t/633650?p=1" target="_blank" rel="noopener noreferrer">帖子</a>，表示有人以<code>"YYYY-MM-dd"</code>格式化日期时，在<code>2019-12-30</code>时出现<code>2020-12-30</code>的 BUG。</p>
<p>本文来简单分析一下为什么会出现这个情况。</p>
<p>根据<a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#year" target="_blank" rel="noopener noreferrer">JDK 文档关于日期的定义</a>，<code>y</code>表示的是我们日常使用的年份，而<code>Y</code>表示的是<code>Week year</code>。</p>
<p>先了解几个知识点：</p>
<h2> Week year</h2>
<p><code>Week year</code>表示的是<strong>这个周所属的年份</strong>。</p>
<blockquote>
<p>A <em>week year</em> is in sync with a <code>WEEK_OF_YEAR</code> cycle. All weeks between the first and last weeks (inclusive) have the same <em>week year</em> value. Therefore, the first and last days of a week year may have different calendar year values.</p>
<p>来源：<a href="https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year</a></p>
</blockquote>
<h2> WEAK_OF_YEAR</h2>
<p>指的是这一年所有的周，从第 01 周开始到该年最后一周。</p>
<p>要注意这个周不一定是自然周，所包含的日期也不一定全部都是当年的日期。</p>
<blockquote>
<p>Values calculated for the <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html#WEEK_OF_YEAR" target="_blank" rel="noopener noreferrer"><code>WEEK_OF_YEAR</code></a> field range from 1 to 53. The first week of a calendar year is the earliest seven day period starting on <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html#getFirstDayOfWeek()" target="_blank" rel="noopener noreferrer"><code>getFirstDayOfWeek()</code></a> that contains at least <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html#getMinimalDaysInFirstWeek()" target="_blank" rel="noopener noreferrer"><code>getMinimalDaysInFirstWeek()</code></a> days from that year.</p>
</blockquote>
<h2> 第 01 周</h2>
<p>根据这份<a href="https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year" target="_blank" rel="noopener noreferrer">JDK 文档</a>，当 <code>getFirstDayOfWeek()</code> is <code>MONDAY</code>（2） and <code>getMinimalDaysInFirstWeek()</code> is 4 时，JAVA 判断周日期的标准与<a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener noreferrer">ISO_8601</a>兼容：</p>
<blockquote>
<p>第 01 周有几个相互等效且兼容的描述：</p>
<p>一年中第一个星期四的星期（正式的 ISO 定义），</p>
<p>1 月 4 日这一周，</p>
<p>起始年份中大部分（四天或以上）的第一周，以及</p>
<p>从 12 月 29 日至 1 月 4 日的星期一开始的一周。</p>
<p>来源：<a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/ISO_8601</a></p>
</blockquote>
<p>按照 JAVA 文档中的定义，每年最开始的几天和最后的几天的<code>Week year</code>不一定是当年的年份值，而是受到每年的<em>第 01 周/最后一周</em>的影响。</p>
<p>JAVA 中判断周主要受到<code>Calendar</code>对象的<code>getFirstDayOfWeek()</code>和<code>getMinimalDaysInFirstWeek()</code>这两个本地值的影响。</p>
<p>其中：</p>
<ul>
<li><code>getFirstDayOfWeek() </code>指定一周的第一天，比如，美国一周从<code>SUNDAY</code> 开始，法国则是<code>MONDAY</code> 。</li>
<li><code>getMinimalDaysInFirstWeek()</code> 一年第一周所需最小的天数。比如 1 表示只要包含第一天就算该年的第一周，而 7 表示只有完整的一周都在该年才算该年的第一周。</li>
</ul>
<p><strong>注意</strong>：真正影响我们格式化日期结果的是<code>SimpleDateFormat</code>中的<code>calendar</code>对象对应的值。</p>
<p>而通过打印这个<code>simpleDateFormat.calendar</code>，我们看到：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以可以得出结论，JAVA<strong>默认只要次年的 1 月 1 日在在这个跨年周，那么本周所有日期的<code>Week year</code>都是次年的</strong>（<code>JDK1.7</code>）。</p>
<h2> 问题分析</h2>
<p>有了以上知识，我们再看看<code>2019-12-30</code>以<code>YYYY</code>格式化为什么会出现问题：</p>
<p>先看一下这些日期对应的星期：</p>
<table>
<thead>
<tr>
<th>周日</th>
<th>周一</th>
<th>周二</th>
<th>周三</th>
<th>周四</th>
<th>周五</th>
<th>周六</th>
</tr>
</thead>
<tbody>
<tr>
<td>29</td>
<td>30</td>
<td>31</td>
<td><strong>1</strong></td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>首先根据 JDK 默认的<code>第01周</code>的定义，<code>2020-01-01</code>所在的周为<code>2020的第一周</code>，所以<code>2019-12-29到2020-01-04</code>都属于是<code>2020年的第01周</code>。</p>
<p>再根据<code>YYYY</code>表示的是<code>Week year</code>的结论，可以知道，当使用<code>YYYY</code>格式化时，<code>2019-12-29到2020-01-04</code>都会得到<code>2020</code>。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而如果我们把第一周最小天数<code>minimalDaysInFirstWeek</code>改为<code>5</code>天，那么很明显这一周属于<code>2020</code>年的天数（从周日到周一，只有 1 号到 4 号 4 天）不够 5 天，所以这一周被划归为<code>2019</code>年的第<code>53周</code>，<code>2019-12-29到2020-01-04</code>的<code>week year</code>都是属于<code>2019</code>。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再比如下面这个<a href="https://blog.csdn.net/bewilderment/article/details/48391717" target="_blank" rel="noopener noreferrer">示例</a>中的<code>2010-12-26</code>。</p>
<figure><img src="https://img-blog.csdn.net/20150912103324519?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>按照<code>JDK1.7</code>默认算法，一周从周日（<code>2010-12-26</code>）开始，并且当年的 1 月 1 日（<code>2011-01-01</code>）所在周为该年第一周，所以<code>2010-12-26到2011-01-01</code>都被划到了<code>2011</code>年的第一周。</p>
<p>但如果按照<a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener noreferrer">ISO_8601</a>的标准，一周从周一开始，并且起始年份包含的天数至少要有<code>4</code>天：</p>
<p>则很明显<code>2010-12-26</code>属于<code>2010</code>年的<code>51周</code>，而<code>2010-12-27到2011-01-02</code>都属于<code>2010</code>年的第<code>52周</code>（属于 2020 年的只有 2 天，不满足第一周的条件）。</p>
<table>
<thead>
<tr>
<th>周一</th>
<th>周二</th>
<th>周三</th>
<th>周四</th>
<th>周五</th>
<th>周六</th>
<th>周日</th>
</tr>
</thead>
<tbody>
<tr>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
</tr>
<tr>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<h2> 总结</h2>
<p>结合以上结论，我们可以看到，在 JAVA 中（<code>JDK1.7</code>）：</p>
<ul>
<li>
<p><code>“YYYY” </code>表示<code>Week year</code></p>
</li>
<li>
<p>每年最开始的几天和最后的几天的<code>Week year</code>不一定是当年的值，而是受到当年的第一周/最后一周的影响。</p>
</li>
<li>
<p>JAVA 周的判断与<code>simpleDateFormat.calendar.minimalDaysInFirstWeek</code>和<code>simpleDateFormat.calendar.firstDayOfWeek</code>有关。</p>
<p>而这两个值都属于本地化值，<strong>在国内可以简单理解为一年 1 月 1 日所在的周就是当年的第一周。</strong></p>
</li>
<li>
<p>我们可以通过修改<code>minimalDaysInFirstWeek</code>和<code>firstDayOfWeek</code>来更改<code>YYYY</code>格式化的值。</p>
</li>
</ul>
<h2> 附录</h2>
<p>JDK 中日期格式化的参数及含义（来自 <a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#month%EF%BC%89%EF%BC%9A" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#month）：</a></p>
<table>
<thead>
<tr>
<th>Letter</th>
<th>Date or Time Component</th>
<th>Presentation</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>G</code></td>
<td>Era designator</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener noreferrer">Text</a></td>
<td><code>AD</code></td>
</tr>
<tr>
<td><code>y</code></td>
<td>Year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#year" target="_blank" rel="noopener noreferrer">Year</a></td>
<td><code>1996</code>; <code>96</code></td>
</tr>
<tr>
<td><code>Y</code></td>
<td>Week year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#year" target="_blank" rel="noopener noreferrer">Year</a></td>
<td><code>2009</code>; <code>09</code></td>
</tr>
<tr>
<td><code>M</code></td>
<td>Month in year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#month" target="_blank" rel="noopener noreferrer">Month</a></td>
<td><code>July</code>; <code>Jul</code>; <code>07</code></td>
</tr>
<tr>
<td><code>w</code></td>
<td>Week in year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>27</code></td>
</tr>
<tr>
<td><code>W</code></td>
<td>Week in month</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>D</code></td>
<td>Day in year</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>189</code></td>
</tr>
<tr>
<td><code>d</code></td>
<td>Day in month</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>F</code></td>
<td>Day of week in month</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td>Day name in week</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener noreferrer">Text</a></td>
<td><code>Tuesday</code>; <code>Tue</code></td>
</tr>
<tr>
<td><code>u</code></td>
<td>Day number of week (1 = Monday, ..., 7 = Sunday)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>a</code></td>
<td>Am/pm marker</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener noreferrer">Text</a></td>
<td><code>PM</code></td>
</tr>
<tr>
<td><code>H</code></td>
<td>Hour in day (0-23)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>k</code></td>
<td>Hour in day (1-24)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>24</code></td>
</tr>
<tr>
<td><code>K</code></td>
<td>Hour in am/pm (0-11)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>h</code></td>
<td>Hour in am/pm (1-12)</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>12</code></td>
</tr>
<tr>
<td><code>m</code></td>
<td>Minute in hour</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>30</code></td>
</tr>
<tr>
<td><code>s</code></td>
<td>Second in minute</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>55</code></td>
</tr>
<tr>
<td><code>S</code></td>
<td>Millisecond</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener noreferrer">Number</a></td>
<td><code>978</code></td>
</tr>
<tr>
<td><code>z</code></td>
<td>Time zone</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#timezone" target="_blank" rel="noopener noreferrer">General time zone</a></td>
<td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td>
</tr>
<tr>
<td><code>Z</code></td>
<td>Time zone</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#rfc822timezone" target="_blank" rel="noopener noreferrer">RFC 822 time zone</a></td>
<td><code>-0800</code></td>
</tr>
<tr>
<td><code>X</code></td>
<td>Time zone</td>
<td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#iso8601timezone" target="_blank" rel="noopener noreferrer">ISO 8601 time zone</a></td>
<td><code>-08</code>; <code>-0800</code>; <code>-08:00</code></td>
</tr>
</tbody>
</table>
<h2> 参考资料</h2>
<p>感谢这篇文章，让我推翻了上一次的结论，发现了真正的原因：<a href="https://blog.csdn.net/bewilderment/article/details/48391717" target="_blank" rel="noopener noreferrer">JAVA 中的 SimpleDateFormat yyyy 和 YYYY 的区别</a></p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year" target="_blank" rel="noopener noreferrer">GregorianCalenda jdk1.7</a></p>
<p>在线显示本周是一年第几周的网站：<a href="https://www.epochconverter.com/weeknumbers" target="_blank" rel="noopener noreferrer">What's the Current Week Number?</a></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdn.net/20150912103324519?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" type="image/"/>
    </item>
    <item>
      <title>Java 笔记之序列化与反序列化：Serializable、Externalizable 和 Parcelable</title>
      <link>https://jixiaoyong.github.io/blog/posts/9d9183ec.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/9d9183ec.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 笔记之序列化与反序列化：Serializable、Externalizable 和 Parcelable</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 24 Dec 2019 01:38:59 GMT</pubDate>
      <content:encoded><![CDATA[<img src="https://images.pexels.com/photos/2881229/pexels-photo-2881229.jpeg?cs=srgb&amp;dl=white-and-blue-cables-2881229.jpg&amp;fm=jpg" class="full-image">
<p>Photo by <a href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" target="_blank" rel="noopener noreferrer">Pixabay </a> from <a href="https://www.pexels.com/photo/close-up-of-telephone-booth-257736/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" target="_blank" rel="noopener noreferrer">Pexels</a></p>
<p><strong>序列化</strong>：指将<code>Java对象</code>转化为<code>字节流</code>以便在网络、文件中保存、传输。</p>
<p><strong>反序列化</strong>：指的是从<code>字节流</code>中恢复<code>Java对象</code>。</p>
<p>本文主要讨论 Android 和 Java 中实现序列化的 4 种方式，并探讨一下其实现原理。</p>
<p>Android &amp; Java 中实现序列化的方式有：</p>
<ul>
<li><code>android.os.Parcelable</code> Android 平台特有，需要自己实现具体细节，性能消耗小，只能在内存中存在</li>
<li><code>java.io.Serializable</code> 实现简单，只需要实现<code>Serializable</code>接口即可，可以输出到文件、网络等</li>
<li><code>java.io.Externalizable</code> 需要自己实现具体细节</li>
<li><a href="https://github.com/twitter/Serial/blob/master/README-CHINESE.rst/" target="_blank" rel="noopener noreferrer"><code>Twitter Serial</code></a> Twitter 出品的高性能序列化方案，它力求帮助开发者实现高性能和高可控的序列化过程。（本文不详细介绍，可以参考<a href="https://www.jianshu.com/p/1b42608478c0" target="_blank" rel="noopener noreferrer">这篇文章</a>）</li>
</ul>
<h2> Serializable</h2>
<p><code>Serializable</code>接口没有任何方法，只是一个标记——表示这个类可以用来<code>序列化/反序列化</code>（由<code>ObjectOutputStream/ObjectInputStream</code>实现具体细节）。</p>
<p>一个类没有实现<code>Serializable接口</code>，或者包含没有<code>实现Serializable接口的变量</code>，则会序列化失败<code>NotSerializableException</code>。</p>
<h3> serialVersionUID</h3>
<p>使用<code>serialVersionUID</code>标记当前<code>Serializable</code>的版本。</p>
<p>如果没有指定，系统会自动用对象的<code>hashCode()</code>指定<code>serialVersionUID</code>，该值会在类发生改变时变化，从而导致反序列化失败。</p>
<p>而如果<code>serialVersionUID</code>一致，即使类结构有变化，也会反序列化（给新增的变量默认值），所以最好赋予一个默认的值。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> readResolve()</h3>
<p>如果<code>class</code>实现了<code>readResolve()</code>方法，会在反序列化时用到并返回这里提供的对象（反序列化得到的对象会被丢弃）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这个特性我们可以确保在反序列化的时候也能实现<strong>单例</strong>：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是根据下面的说法，要实现可以序列化的单例最简单安全的，还是使用枚举：</p>
<blockquote>
<p><strong>事实上，如果依赖 readResolve 进行实例控制，带有对象引用类型的所有实例域则都必须声明为 transient 的</strong>。否则，利用<code>readResolve()</code>方法实现的单例也会遭受到攻击。</p>
<p>实现可序列化最简单安全的方式是采用枚举的形式，应该尽可能采用这种方式。如果采用<code>readResolve</code>实现的话，要确保该类的所有实例域都为<code>基本类型</code>，或者是<code>transient</code>的。</p>
<p><a href="https://cl0610.github.io/effective-java-learning/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%BA%8F%E5%88%97%E5%8C%96/77.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%85%88%E4%BA%8EreadResolve.html" target="_blank" rel="noopener noreferrer">77.单例模式，枚举类型优先于 readResolve</a></p>
</blockquote>
<h3> 自定义序列化过程</h3>
<p>如果想要自己处理序列化的过程，可以实现下面的方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，可以使用下面的方法实现<code>读/写</code><strong>该类自身的属性</strong>（<code>All non-static and non-transient fields of the current class, include private</code>），然后在调用诸如<code>out.writeObject(string);</code>等方法<strong>保存其他变量</strong>。</p>
<blockquote>
<p>The method does not need to concern itself with the state belonging to its superclasses or subclasses.</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>readObjectNoData</code>方法主要用在序列化流和我们要反序列化的类不一致时初始化一些必要的状态。</p>
<blockquote>
<p>这种情况可能出现在接收方使用了一个与发送方不同版本的类。接收方的版本多扩展了一些字段，而发送方的版本没有这些字段。还有一种可能就是序列化流被篡改了。这时，无论是恶意的流还是不完整的流，都可以用 <code>readObjectNoData</code> 方法来将序列化得到的对象初始化到正确的状态。<br>
作者：福尔马林<br>
链接：<a href="https://juejin.im/post/5d7206c5f265da03ab427181" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5d7206c5f265da03ab427181</a></p>
</blockquote>
<p>此外，还可以使用<code>ObjectOutputStream</code>的<code>putFields()</code>和<code>ObjectInputStream</code>的<code>readFields()</code>写入/读取变量。使用这种方法可以<em>加密/解密</em>部分变量，或者在序列化的时候<em>只处理部分变量</em>。</p>
<p>具体使用方法见如下：</p>
<blockquote>
<p><strong>注意</strong>：<code>putFields()/readFields()</code>方法分别不能与<code>defaultWriteObject/defaultReadObject</code>一起使用；</p>
<p><code>putFields.put()</code>之后必须调用<code>out.writeFields()</code>方法</p>
<p>并且，没有在<code>putFields()</code>中加入的数据，在<code>readObject</code>中只能获取到该类型的默认值</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 父类未继承 Serializable 的类的序列化</h3>
<p>如果一个类实现了序列化，但他的父类没有实现序列化，那么父类<strong>必须要有一个公开的无参构造函数</strong>，否则反序列化时会出错。</p>
<p>此时反序列化时，父类的变量值（<code>public, protected, and (if accessible) package fields</code>）都会是<strong>默认的值</strong>或者是在<strong>父类无参构造函数中初始化的值</strong>（即使这些值在子类对象中已经被修改了）。</p>
<p>要想使得这些值也可以支持序列化，可以通过<code>writeObject/readObject</code>自己处理这些值的序列化。</p>
<p>反之，如果一个类实现了<code>Serializable</code>接口，那么他的子类也自动支持序列化与反序列化。</p>
<h3> 实现</h3>
<p>下面是使用<code>Serializable</code>实现序列化与反序列化的简单示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 多次序列化同一个对象</h3>
<p>返序列化读取的过程在<code>readResolve()</code>方法一节已经涉及到了，我们在看一下保存的部分，这里会有一个有意思的现象：</p>
<blockquote>
<p>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener noreferrer">https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html</a></p>
</blockquote>
<p>这会导致一个问题：当使用同一个<code>ObjectOutputStream对象</code>序列化<code>同一个序列化对象</code>时，即使在第一次序列化并保存后修改了这个对象的部分属性，当再次序列化时保存的<strong>只是前一个对象的引用</strong>——也就是说将完全相同一个对象保存了两次，<strong>第二次做的修改在序列化的时候并没有保存</strong>。</p>
<p>我们写个简单的 DEMO 验证一下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是为什么呢，我们可以在源码中看到原因：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了避免这种情况，在保存同一个对象时要注意使用不同的<code>ObjectOutputStream</code>对象，或者可以使用<code>writeUnshared</code>方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 优缺点</h3>
<ul>
<li>简单，只需要实现接口</li>
<li>序列化的字节流可以在文件、网络中传递，可以持久化保存</li>
<li>性能差，序列化过程大量使用反射和临时变量</li>
</ul>
<h2> Externalizable</h2>
<p><code>Externalizable</code>继承自<code>Serializable</code>。</p>
<p>用户需要通过<code>writeExternal(ObjectOutput out)</code>和<code>readExternal(ObjectInput in)</code>实现序列化与反序列化的细节，并且需要一个明确实现的**<code>public no-arg constructor</code>**</p>
<h3> 实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 原理</h3>
<p>看源码可以知道，如果检测到当前对象是<code>Externalizable</code>时，就会去调用该对象的<code>writeExternal方法</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 优缺点</h3>
<ul>
<li>比<code>Serializable</code>麻烦，序列化与反序列化都需要用户自己实现</li>
<li>灵活，可以自定义要参与到序列化与反序列化的变量</li>
</ul>
<h2> Parcelable</h2>
<p><code>Parcelable</code>是 Android 为了解决<code>Serializable</code>性能问题而推出的，主要用在 Android 的<code>Intent</code>或<code>线程间通信</code>中。</p>
<p><code>Parcelable</code>通过<code>Parcel</code>传输到<code>IBinder</code>中，从而实现跨进程传输。</p>
<blockquote>
<p>对于<code>kotlin</code>语言来说，Android Studio 自动生成的<code>Parcelable</code>代码不会处理 val 变量（因为这些变量不会变化）</p>
<p>此外，<code>Parcelable</code>在反序列化时，调用<code>parcel.readParcelable(classLoader)</code>传入的是<code>ClassLoader</code>。</p>
</blockquote>
<h3> 实现</h3>
<p>下面是一个<code>Parcelable</code>的实现：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 原理</h3>
<p>原理参考这篇文章<a href="https://www.kancloud.cn/xcy396/android_tech/1296524" target="_blank" rel="noopener noreferrer">Parcelable 源码分析</a></p>
<h3> 优缺点</h3>
<ul>
<li>性能好，<code>Parcelable</code>接口比<code>Serializable</code>接口效率更高，性能方面高出 10 多倍 [^Parcelable 源码分析]:</li>
<li>较复杂，需要自己实现对象的序列化内容</li>
</ul>
<h2> 总结</h2>
<p>一般需要持久化保存数据或在网络间传输时推荐使用<code>Serializable</code>或者<code>Externalizable</code>。</p>
<p>在 Android 中<code>Activity</code>之间等传递对象，以及跨进程传递对象等时使用<code>Parcelable</code>以节省性能。</p>
<h2> 参考资料</h2>
<p><a href="http://darryrzhong.xyz/2019/09/15/Android%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">Android 之序列化详解</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener noreferrer">Java 序列化的高级认识</a></p>
<p><a href="https://juejin.im/post/5d7206c5f265da03ab427181#heading-0" target="_blank" rel="noopener noreferrer">【原创】（译）Java 序列化魔法方法及使用示例</a></p>
<p><a href="https://www.javacodegeeks.com/2019/08/serialization-everything-java-serialization-explained.html" target="_blank" rel="noopener noreferrer">What is Serialization? Everything You Need to Know About Java Serialization Explained With Example</a></p>
<p><a href="https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf#heading-0" target="_blank" rel="noopener noreferrer">java 序列化，看这篇就够了</a></p>
<p><a href="https://blog.csdn.net/qq_16628781/article/details/70049623" target="_blank" rel="noopener noreferrer">Java 之 Serializable/Externalizable 序列化和反序列化</a></p>
<p><a href="https://cl0610.github.io/effective-java-learning/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%BA%8F%E5%88%97%E5%8C%96/77.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%85%88%E4%BA%8EreadResolve.html" target="_blank" rel="noopener noreferrer">77.单例模式，枚举类型优先于 readResolve</a></p>
<p>Pareclable 实现原理：<a href="https://juejin.im/post/5a3b24ab6fb9a04515440bd7" target="_blank" rel="noopener noreferrer">Parcelable 最强解析</a></p>
<p>Parcelable 使用：<a href="https://www.jianshu.com/p/32a2ec8f35ae" target="_blank" rel="noopener noreferrer">详细介绍 Android 中 Parcelable 的原理和使用方法</a></p>
<p><a href="https://www.kancloud.cn/xcy396/android_tech/1296524" target="_blank" rel="noopener noreferrer">Parcelable 源码分析</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 线程安全与 volatile 和 synchronize</title>
      <link>https://jixiaoyong.github.io/blog/posts/24967ad4.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/24967ad4.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Java 线程安全与 volatile 和 synchronize</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 12 Jan 2019 07:54:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>Java 多线程编码中，保证线程安全的实质是保证对数据操作的原子性，即一个线程对数据的操作能够及时的更新到其他使用该数据的线程中，这样就可以避免多个线程因为操作的数据值不一致而产生错误。</p>
<figure><img src="https://jixiaoyong.github.io/images/20190112144856.png" alt="线程、主内存、工作内存三者交互关系——深入理解 JAVA 虚拟机" tabindex="0" loading="lazy"><figcaption>线程、主内存、工作内存三者交互关系——深入理解 JAVA 虚拟机</figcaption></figure>
<p>由于 Java 内存模型（JMM）规定，所有线程公用的数据保存在主内存中，而线程在使用时先从主内存中取到线程私有的工作内存中，之后再在使用完毕后同步到主内存中，在这过程中，如果其他线程也用到了该数据则可能会出现问题，因此在线程操作数据时需要考虑线程并发时操作数据的同步问题。</p>
<p><code>volatile</code>和<code>synchronize</code>因此而生。</p>
<h2> volatile</h2>
<p><code>volatile</code>修饰的变量有两个特性：</p>
<ul>
<li>变量对所有线程可见 普通变量则需要等线程操作完毕，将结果从工作内存写入到主内存中才可以被其他线程可见，volatile 修饰的变量会在修改后通知其他线程该变量已经被更改，从而让其他线程再去主内存中读取最新的值</li>
<li>禁止指令重排优化</li>
</ul>
<p><code>volatile</code>修饰的变量执行效率和普通变量差别不大，其写操作因为要插入内存屏障，所以会稍微慢一些</p>
<p>需要注意的是：</p>
<ul>
<li>
<p>由于 Java 运算的具体实现并非原子性的，故而虽然<code>volatile</code>修饰的变量在所有线程可见，但是并发下并不线程安全。</p>
<blockquote>
<p>Java 代码编译成 class 文件后可以看到，类似<code>c = c + 1</code>这样的语句，会被分为：读取<code>c</code>的值；计算<code>c+1</code>的值；将结果赋予<code>c</code>这几步来完成。所以在此期间如果有其他的线程访问这段代码，就会发生冲突。</p>
</blockquote>
</li>
<li>
<p>Java 会通过<strong>指令重排</strong>来优化代码</p>
<blockquote>
<p>指令重排 指对于变量的赋值会在定义该变量和使用该变量的值之间的任意位置执行，不一定和代码中的顺序一致</p>
</blockquote>
<p><code>volatile</code>修饰的变量则会插入<em>内存屏障</em>，从而实现屏蔽指令重排的效果</p>
</li>
</ul>
<h2> synchronize</h2>
<p><code>synchronize</code>实现的原理是<strong>锁定指定的对象</strong>（如果没有指定则锁定对应的类对象或 class 对象），然后阻塞其他线程进入（获取到该锁的线程可以多次重入）。</p>
<p>由于 Java 的线程实现是映射到系统线程的，阻塞和唤醒需要由系统内核完成，会消耗大量的时间，因此<code>synchronize</code>是<strong>重量级操作</strong>。</p>
<h2> JMM 与三个特征</h2>
<p>JMM 的设计是围绕着<strong>原子性、可见性、有序性</strong>三个特征进行的。</p>
<ul>
<li>
<p><strong>原子性</strong> JVM 中的<code>read,load,assign,use,store,write</code>操作和<code>synchronize</code></p>
</li>
<li>
<p><strong>可见性</strong> 一个线程更改了共享变量的值时，其余线程能够立即得知这个更改。通过<code>synchronize</code>，<code>final</code>和<code>volatile</code>保证。</p>
<p><code>final</code>要保证可见性的前提是要被<strong>安全的构建出来</strong>，避免**“this 引用逃逸”**</p>
<blockquote>
<p><strong>this 引用逃逸</strong> 对象还没有被构造完成，他的<code>this引用</code>就已经被发布出去了。</p>
<p>在构造函数中生成内部类，由于内部类自动持有外部类的<code>this引用</code>，如果有对象在内部类语句之后构造，则就有可能发生“内部类访问这个对象时，该对象还没有构造完毕”的情况。</p>
</blockquote>
</li>
<li>
<p><strong>有序性</strong> 通过<code>synchronize</code>,<code>volatile</code>保证。</p>
</li>
</ul>
<p>线程从内部观察时有序（线程内是串行的语义），线程外部观察是无序（由指令重排、工作内存与主内存同步延迟导致）</p>
<h2> 实现线程安全</h2>
<p>实现线程安全有以下几种方法：</p>
<h3> 互斥同步（阻塞同步）</h3>
<p>互斥同步的思想是：多个线程使用同一个共享数据时，保证同一时刻只能被一个线程使用</p>
<p>有两种途径：</p>
<ul>
<li><code>synchronize</code> （原生语法层），优先使用</li>
<li><code>ReentrantLock</code> 重入锁（API 层），功能有：1.等待可中断（可以放弃等待）2.公平锁 多个线程申请锁时必须按照申请时间顺序获得锁 3.锁绑定多个条件</li>
</ul>
<h3> 非阻塞同步</h3>
<p>减少了阻塞/唤醒的耗时，在操作时进行 CAS（比较并交换），在冲突发生的时候不断尝试执行所需操作，直到执行成功。</p>
<p>但是有一个逻辑漏洞：如果在第一次操作失败到第二次再次尝试操作之间，<em>其他线程对齐进行了操作但是该数据最终没有被变化</em>，当第二次再次尝试时，其实已经被其他线程访问过了。</p>
<h3> 无同步方案</h3>
<p>保证线程安全，不一定需要同步，当线程操作的数据不是共享数据时，即使不同步也是线程安全的。</p>
<ul>
<li><strong>可重入代码</strong> 指在代码执行的过程中，如果中断其运行并运行其他的线程，当再次返回继续执行该代码时不会影响到其执行结果的代码。这种代码一般没有用到堆中的公用资源。</li>
<li><strong>线程本地存储</strong> 共享数据值存在于同一个线程中，如每个线程的 ThreadLocal 对象</li>
</ul>
<h2> 锁优化</h2>
<p>JDK1.6 以后，在 HotSpot 虚拟机上实现了许多锁优化技术：</p>
<ul>
<li>
<p>自旋锁</p>
<p>实现阻塞同步时，阻塞和唤醒会很耗时，为了避免这种情况，可以先对其进行<em>忙循环</em>，如果还不行再去执行阻塞操作</p>
<p><em>自适应自旋</em> 由 JVM 智能决定自旋次数</p>
</li>
<li>
<p>锁消除</p>
<p>JVM 会自动取出不必要的锁</p>
</li>
<li>
<p>锁粗化</p>
<p>如果一段代码中有连续的锁，则 JVM 会将这些锁合并为一个大锁</p>
</li>
<li>
<p>轻量级锁</p>
<p>轻量级锁消耗比传统锁机制小，会优先尝试使用轻量级锁，如果不行，在升级为互斥锁</p>
<p>大多数情况下会减少消耗，但如果存在锁竞争，则除了互斥锁的开销外，还有轻量级锁的开销</p>
</li>
<li>
<p>偏向锁</p>
<p>在无竞争的情况下消除同步</p>
</li>
<li>
<p>乐观锁</p>
<p>读取数据时默认该对象不会被其他对象更改而不加锁，每次写数据时对比当前值与持有值是否一致，一致时才去更新数据</p>
</li>
</ul>
<h2> 参考资料</h2>
<p>《深入理解 Java 虚拟机——JVM 高级特性与最佳实践》周志明</p>
<p><a href="https://blog.csdn.net/u010571316/article/details/77993309" target="_blank" rel="noopener noreferrer">this 引用逃逸——蜡笔小勋</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20190112144856.png" type="image/png"/>
    </item>
    <item>
      <title>Kotlin 学习笔记 1</title>
      <link>https://jixiaoyong.github.io/blog/posts/135b2780.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/135b2780.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Kotlin 学习笔记 1</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 09 Feb 2018 08:18:01 GMT</pubDate>
      <content:encoded><![CDATA[<p>这是我在学习 Bennyhuo（ <a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="noopener noreferrer">github</a> ）的 kotlin 入门视频时的一些笔记，比较偏基础，用于查缺补漏。</p>
<ul>
<li>
<p>xx.map() &amp; xx.flatMap()</p>
<p>xx.flatMap() 用于返回<strong>可迭代</strong>的数组，而 xx.map() 则是任何<strong>可迭代</strong>数据都有的用来遍历的方法。</p>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>enum class 枚举类型</p>
<p>分为有参和无参，枚举变量以<code>,</code>分隔，如果 enum 还有方法或者伴生对象，则最后一个变量后为<code>;</code>，否则可为<code>,</code>、<code>;</code>或者没有。</p>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 有参的情况如下</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 使用：通过 enum 的 valueOf() 方法获取枚举对象实例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>companion object 伴生对象</p>
<p>在类的定义，可以直接用<code>类名.方法名()</code>调用，相当于 java 中的静态方法</p>
<p>一个类中只能有一个伴生对象</p>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>object 修饰的类</p>
<p>等同于只有一个实例的类，相当于 java 中的静态类，所有方法可以直接用类名调用</p>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>fun ClassName.funName() 为类添加新的方法</p>
<p>对于不能直接修改的类，有需要对其增加一个方法，可以自定义一个<code>ClassName.funName()</code>的方法来达到这个目的。</p>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 在使用时可以通过<code>Country</code>的对象调用<code>syaNum()</code>方法</p>
<ul>
<li>
<p>data class 数据类</p>
<p>可以有方法，方便复制。</p>
<p>必须至少有一个参数，并且参数都需要用 var/val 修饰</p>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>文件读取
<ul>
<li>resource 目录下的文件读取</li>
</ul>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>
<p>与 RxJava 结合</p>
<p>统计文本中字母个数，基于 RxJava 1.2.1</p>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Kotlin 学习笔记 2</title>
      <link>https://jixiaoyong.github.io/blog/posts/8a52763a.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/8a52763a.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Kotlin 学习笔记 2</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 11 Feb 2018 03:38:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 尾递归优化</h2>
<p>把递归通过编译器转化为迭代，从而避免 Stack Overflow</p>
<p>“以时间换取空间”</p>
<p>普通递归：</p>
<p>调用函数之后，还需要使用其返回值供自己使用，即自身返回值依赖于下一级函数，一般是调用自身的代码后面，还有其他的代码要执行。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尾递归：<br>
调用自身之后，无需再返回当前函数，将处理结果以其他形式返回。<br>
普通递归和尾递归都存在栈溢出风险（未优化前，例子中的函数计算 10000 到 100000 的阶乘时会溢出），kotlin 提供了一种尾递归优化的方法——<code>tailrec</code>，使得编译器在编译时将递归转化为迭代，从而避免栈溢出。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本例中传入<code>fun2()</code>的<code>Result</code>实例保存了计算结果</p>
<h2> sealed class 密封类</h2>
<p>密封类的所有子类必须在一个文件 (xx.kt) 中，他的子类是有限的，所以当<code>when()</code>的时候不需要<code>else</code>。</p>
<p>某种意义上他们像是一种<code>enum class</code>，只不过他的子类可以有多个实例。</p>
<blockquote>
<p>Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.</p>
</blockquote>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> kotlin 抛出异常</h2>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> kotlin 中的泛型</h2>
<p><code>out</code> 协变，使用子类泛型的对象可以赋值给使用父类泛型的对象，相当于<code>extend</code>，用于方法的返回值（生产者）时使用</p>
<p><code>in</code> 逆变，使用父类泛型的对象可以赋值给使用子类泛型的对象，相当于<code>super</code>，用于方法的参数（消费者）时使用</p>
<p>不变，当泛型即当消费者，又当生产者时，不用<code>in</code>或者<code>out</code></p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 星号投射</h2>
<blockquote>
<p>你对类型参数一无所知，但仍然希望以安全的方式使用它。</p>
</blockquote>
<p><strong>安全的使用</strong>，则表示该类<code>Group&lt;T&gt;</code>满足</p>
<blockquote>
<p>1.子类至少接收和父类一样范围的参数 &gt;= ---&gt; 父类入参为 Noting 不能安全写入</p>
<p>2.子类最多返回和父类一样范围的参数 &lt;= ---&gt; 父类出参为 Any? 可以安全读取</p>
</blockquote>
<p>则有以下三种实现方式</p>
<figure><img src="https://jixiaoyong.github.io/images/20191022194750.png" alt="in-out-star-projection-approaches" tabindex="0" loading="lazy"><figcaption>in-out-star-projection-approaches</figcaption></figure>
<p>其中：</p>
<p><code>Group&lt;in Noting&gt;</code> 的<code>fetch()</code>方法一直返回<code>Any?</code></p>
<p><code>Group&lt;out Any?&gt;</code> 的<code>T</code>需要与实际的<code>Group</code>的<code>T</code>保持一致，否则会报错</p>
<p><code>Group&lt;*&gt;</code> 既能<code>insert</code>正确返回对应的类型，也不用实时修改</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 委托</h2>
<p>委托是将重复出现的代码放到一个地方。</p>
<figure><img src="https://jixiaoyong.github.io/images/20191023194526.png" alt="委托示意图" tabindex="0" loading="lazy"><figcaption>委托示意图</figcaption></figure>
<ul>
<li>类委托：</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样 B 便可以将<code>Interface</code>中方法的实现委托给类<code>A</code>的对象<code>a</code></p>
<ul>
<li>委托属性：</li>
</ul>
<p>将同一类型的属性的<code>get</code>、<code>set</code>方法放到一个地方实现，可以在加入<code>其它操作</code></p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>委托类的初始化函数：</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>Map 委托：</li>
</ul>
<p>将类的<code>属性</code>名称和<code>map</code>中的<code>key</code>一一对应，从而将对于<code>value</code>赋值给<code>属性</code></p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>veroable</li>
</ul>
<p>可以拦截赋值操作</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 中缀函数</h2>
<p>需要满足三个条件：</p>
<ol>
<li>成员函数或拓展函数</li>
<li>只有一个参数</li>
<li>infix 声明</li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> inline 内联函数</h2>
<p><code>inline</code>修饰的函数在被调用时将字节码动态插入到被到调用的地方。</p>
<p><code>inline</code>修饰的函数的<code>lambda参数</code>如果运行在该函数内部的*<code>子函数/其他环境</code>*，则不允许这个 lambda 函数<strong>非局部返回</strong>（因为没有办法从该 <code>子函数/其他环境</code> 中直接退出 lambda 所在的外层函数），对于这种 lambda 函数需要添加**<code>crossinline</code>**修饰。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Kotlin 也存在 Java 泛型所具有的<strong>类型擦除</strong>问题，为了优化该问题，inline 函数可以结合<code>reified</code>实现<strong>实体化类型参数</strong></p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>**原理：**内联函数会直接被插入到被调用的地方，而<code>reified</code>修饰的类型参数会保证将用户调用时写的类型<code>String</code>同时也写入到被调用的地方，如此便没有发生类型擦除。</p>
<h2> coroutines 协程</h2>
<p>协程可以看做是一个轻量级的 thread，他运行在线程当中，由用户控制，没有上下文切换的开销。</p>
<p>在 Android 中使用协程，特别是在 IO 操作及网络请求等需要根据耗时操作更新界面的需求时，可以将 IO 操作和界面操作串行，避免切换线程、回调嵌套等导致代码可读性查的问题。</p>
<p>如配合支持协程的 retrofit，我们可以将网络请求简化如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>kotlin 协程需要单独添加依赖：</p>
<div class="language-groovy line-numbers-mode" data-ext="groovy"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一个父协程总是等待所有的子协程执行结束，父协程被取消的时候，所有它的子协程也会被递归的取消。</p>
<h3> 协程中<code>runBlocking</code>与<code>coroutineScope</code>的区别</h3>
<p>相同点：</p>
<p>依次执行内部代码，如果<code>代码1</code>是启动协程，那么启动该子协程后，继续执行<code>代码1</code>后面的代码直到最后一行（类似启动新线程，不会阻塞当前线程），然后再等待所有内部协程结束，才会退出。</p>
<p>不同点：</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" target="_blank" rel="noopener noreferrer"><strong><code>runBlocking</code></strong></a>：会运行一个新的协程线程，并阻塞其所在<code>线程</code>,直到其内部所有协程/子协程执行完毕才会退出。设计用来以阻塞的方式执行协程代码，不应该在协程中使用。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" target="_blank" rel="noopener noreferrer"><strong><code>coroutineScope</code></strong></a>：不会阻塞其所在线程，要在协程中使用，当其内部所有协程/子协程执行完毕才会退出。设计用来执行并行操作，一旦有子协程失败，则其他子协程都会被取消，整个代码块执行失败。</p>
<h3> 协程的思维导图</h3>
<iframe width="853" height="480" src="https://embed.coggle.it/diagram/Xb_CZoumpCamgUAj/1235701ea5f157867e045f0f5ac28f886effdb5fa1e27b72afa5266e6e3e8891" frameborder="0" allowfullscreen=""></iframe>
<p>需要说明的是</p>
<p><code>Dispatchers.Unconfined</code> 非受限，不会限定协程运行的线程，而是随环境切换</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 协程局部变量</h3>
<p>通过<code>ThreadLocal</code>、<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/index.html" target="_blank" rel="noopener noreferrer"><code>ThreadContextElement</code></a>，配合<code>asContextElement("value")</code>方法实现。和协程所在的线程没有关系。</p>
<p>直接修改<code>ThreadLocal</code>的值，会在切换协程的时候失效（会被改为切换到的协程所使用的的值），当再次切回本协程时，被重置为上一个通过<code>asContextElement("value")</code>方法更新的值或者<code>null</code>（如果没有指定）。</p>
<blockquote>
<p>原理：<strong>启动和恢复时保存<code>ThreadLocal</code>在当前线程的值，并修改为 value，挂起和结束时修改当前线程<code>ThreadLocal</code>的值为之前保存的值</strong></p>
<p>—— <a href="https://johnnyshieh.me/posts/kotlin-coroutine-concurrency/" target="_blank" rel="noopener noreferrer">Kotlin Coroutines(协程) 完全解析（五），协程的并发</a></p>
</blockquote>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 在 Android 中使用</h3>
<p>Kotlin 官方推荐一下两种方式：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p><a href="https://typealias.com/guides/star-projections-and-how-they-work/" target="_blank" rel="noopener noreferrer">Star-Projections and How They Work</a></p>
<p><a href="https://blog.csdn.net/u013064109/article/details/83507076" target="_blank" rel="noopener noreferrer">Kotlin 的独门秘籍 Reified 实化类型参数 (下篇)</a></p>
<p><a href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html" target="_blank" rel="noopener noreferrer">Kotlin 协程官网</a></p>
<p><a href="https://johnnyshieh.me/posts/kotlin-coroutine-concurrency/" target="_blank" rel="noopener noreferrer">Kotlin Coroutines(协程) 完全解析（五），协程的并发</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20191022194750.png" type="image/png"/>
    </item>
    <item>
      <title>Kotlin 学习笔记 3</title>
      <link>https://jixiaoyong.github.io/blog/posts/fd5546ac.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/fd5546ac.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Kotlin 学习笔记 3</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 24 Dec 2019 01:38:59 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文为笔记性质，尚未成文，待整理</p>
</blockquote>
<h2> 异步流</h2>
<ol>
<li>lazy 方式创建一个序列，只有在访问的时候才生产对应的项目</li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>
<p>使用 Flow 流在不阻塞主线程的情况下，延迟生产多个值并返回</p>
<p>当流在一个可取消的挂起函数（例如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" target="_blank" rel="noopener noreferrer">delay</a>）中挂起的时候取消，否则不能取消。</p>
</li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html" target="_blank" rel="noopener noreferrer">flowOf</a> 构建器定义了一个发射固定值集的流。</p>
<p>使用 <code>.asFlow()</code> 扩展函数，可以将各种集合与序列转换为流。</p>
<p>可以使用操作符转换流，就像使用集合与序列一样。过渡操作符应用于上游流，并返回下游流。这些操作符也是冷操作符，就像流一样。这类操作符（<code>map</code>、<code>fliter</code>...）本身不是挂起函数，但是可以调用挂起函数<code>suspend</code>。它运行的速度很快，返回新的转换流的定义。</p>
<p>在流转换操作符中，最通用的一种称为 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html" target="_blank" rel="noopener noreferrer">transform</a>。它可以用来模仿简单的转换，例如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" target="_blank" rel="noopener noreferrer">map</a> 与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html" target="_blank" rel="noopener noreferrer">filter</a>，以及实施更复杂的转换。使用 <code>transform</code> 操作符，我们可以 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" target="_blank" rel="noopener noreferrer">发射</a> 任意值任意次</p>
<p>限长过渡操作符（例如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html" target="_blank" rel="noopener noreferrer">take</a>）在流触及相应限制的时候会将它的执行取消。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>流构造器中的协程上下文默认和 collect 的协程上下文一致，如果强行转换上下文会出错。</p>
<p>而使用<code>flowOn()</code>则可以指定流创建的协程上下文：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 flow 的生产和收集很消耗时间时，可以用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html" target="_blank" rel="noopener noreferrer"><code>buffer()</code></a>函数将<code>buffer()</code>之前的代码在一个单独的协程运行，collect 则在调用协程运行，这样将 flow 的构建、收集由串行转化为并行可以节约时间（如果构建运行的快，则会挂起直到 collect 赶上来）。</p>
<blockquote>
<p>It will use two coroutines for execution of the code. A coroutine <code>Q</code> that calls this code is going to execute <code>collect</code>, and the code before <code>buffer</code> will be executed in a separate new coroutine <code>P</code> concurrently with <code>Q</code></p>
</blockquote>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 合并 conflate</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html" target="_blank" rel="noopener noreferrer">conflate</a> operator can be used to skip intermediate values when a collector is too slow to process them.</p>
<p>当 collect 比构建慢的时候，就只会请求最新的值，而跳过中间生产的这些值。</p>
<p>比如，构建器生产了 1，2，... ,100 这些数，而 collect 读取的慢，第一次读的时候是 1，等处理完再读取的时候构建器生产的是 5，那么 collect 就读取 5，中间的 2，3，4 都会被丢弃。</p>
<p>Conflation is one way to speed up processing when both the emitter and collector are slow . The other way is to cancel a slow collector and restart it every time a new value is emitted.</p>
<p><code>collectLatest</code>可以保证每次都获取最新的值，如果 collect 比生产慢，那么当新的值生产出来时，collect 会被取消，并且去处理最新的值。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 组合多个流</h2>
<p><code>zip</code>将两个流“压缩”为一个流：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 flow 表示变量或操作的最新值时 (参见关于合并的相关章节) ，可能需要执行依赖于相应流的最新值的计算，并在任何上游流发出值时重新计算它。相应的操作符族称为联合操作符 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html" target="_blank" rel="noopener noreferrer"><code>combine</code></a>。即每个构建值发生变化时都会触发 collect。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html" target="_blank" rel="noopener noreferrer"><code>flatMapConcat</code></a> 可以将 flow 的内容“抹平”（即假设原先为<code>Array&lt;Array&lt;Int&gt;&gt;</code>，则押平后为：<code>Array&lt;Int&gt;</code>）。串行执行，即先执行代码块，然后对其<code>flatMapConcat</code>，然后 collect，之后再执行下一轮的 Flow 项目。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html" target="_blank" rel="noopener noreferrer"><code>flatMapMerge</code></a> 按顺序调用它的代码块，但是同时收集结果流，这相当于首先执行一个顺序映射，然后对结果调用 flattonmerge。并行执行，先依次对 Flow 项目调用代码块，然后哪个值先出来，就先对其调用 <code>flatMapMerge</code>，然后 collect。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html" target="_blank" rel="noopener noreferrer"><code>flatMapLatest</code></a> 类似 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html" target="_blank" rel="noopener noreferrer"><code>collectLatest</code></a> ，每次新值出来就会取消还没有处理结束的旧流的操作。</p>
<h2> 流异常</h2>
<p>流的异常有如下捕获方式：</p>
<ol>
<li>
<p><a href="https://kotlinlang.org/docs/reference/exceptions.html" target="_blank" rel="noopener noreferrer"><code>try/catch</code></a> block</p>
</li>
<li>
<p>透明捕获 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" target="_blank" rel="noopener noreferrer">catch</a> ，只会捕获发送在他之前的异常</p>
</li>
<li>
<h4> 声明式捕获 将 collect 的主要逻辑放到 onEach 中，保证 onEach 在 catch 之前</h4>
</li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 流完成</h2>
<ol>
<li>
<p><code>try</code>/<code>finally</code></p>
</li>
<li>
<p><code>onCompletion()</code></p>
</li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而且他还可以判断是否是异常退出。但是只是判断，并不会处理、拦截异常，并且只能处理上游的异常。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> launchIn(this) 与 collect</h2>
<p><code>collect</code>后的代码只有在 collect 执行完后才能执行，而<code>launchIn</code>可以指定其在单独的协程程序中启动流的集合，从而不会阻塞当前协程。</p>
<h2> Channel</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html" target="_blank" rel="noopener noreferrer">Channel</a> 类似于 BlockingQueue。但他的操作是挂起的。<br>
Channel 提供了在协程之间传递多个值的方法</p>
<p><code>send</code> 发送 缓存区已满或不存在时调用方会被挂起</p>
<p><code>channel.receive()</code> 接收</p>
<p><code>channel.close()</code> 关闭通道，表示没有更多的元素进入通道</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" target="_blank" rel="noopener noreferrer"><code>CoroutineScope.produce</code></a> Launches new coroutine to produce a stream of values by sending them to a channel and returns a reference to the coroutine as a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/index.html" target="_blank" rel="noopener noreferrer">ReceiveChannel</a>. This resulting object can be used to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html" target="_blank" rel="noopener noreferrer">receive</a> elements produced by this coroutine. 在新的协程中生产并返回了一个<code>ReceiveChannel&lt;T&gt;</code>对象。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html" target="_blank" rel="noopener noreferrer"><code>ReceiveChannel&lt;E&gt;.consumeEach</code></a> 遍历 ReceiveChannel 的 item 执行指定 action，并在块执行完毕后消耗掉这个 ReceiveChannel（调用 cancel()）。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/index.html" target="_blank" rel="noopener noreferrer">ReceiveChannel</a>.<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html" target="_blank" rel="noopener noreferrer">cancel()</a> 取消接收来自这个通道的剩余元素，关闭通道并从中删除所有缓存的元素。</p>
<p><code>tickerChannel</code> 定时返回<code>Unit</code>的<code>channel</code>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Flow/Channel/Sequence 的区别</h2>
<p><code>Flow</code>是用来异步返回多个值，其内部操作可以挂起</p>
<p><code>Channel</code> 用来在协程之间传递多个值（transfer a stream of values）</p>
<p><code>Sequence</code> 用来逐个在 item 中延迟执行完整操作，相比于<code>list</code>等整体执行完毕才进行下一级操作的“弓”字型，<code>Sequence</code>多级操作是逐个 item 依次完整执行多级操作的“几”字型。</p>
<h2> 管道</h2>
<p>管道指：1.一个协程在流中开始生产无穷多个元素 2.另一个或多个协程消费这些流</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没有缓冲的通道：如果发送先被调用，则它将被挂起直到接收被调用，如果接收先被调用，它将被挂起直到发送被调用。</p>
<p>带缓冲的通道： <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel.html" target="_blank" rel="noopener noreferrer">Channel()</a> 工厂函数与 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" target="_blank" rel="noopener noreferrer">produce</a> 建造器通过一个可选的参数 <code>capacity</code> 来指定 <em>缓冲区大小</em>。缓冲允许发送者在被挂起前发送多个元素，就像 <code>BlockingQueue</code> 有指定的容量一样，当缓冲区被占满的时候将会引起阻塞。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>发送和接收操作是 <em>公平的</em> 并且尊重调用它们的多个协程。它们遵守先进先出原则。</p>
<p>计时器通道是一种特别的会合通道，每次经过特定的延迟都会从该通道进行消费并产生 <code>Unit</code> 。如果在间隔还没到的时候调用<code>tickerChannel.receive()</code>则会返回<code>null</code>。产生的间隔由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-ticker-mode/index.html" target="_blank" rel="noopener noreferrer"><code>TickerModel</code></a>控制</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>coroutineContext.cancelChildren()</code> // 取消所有的子协程来让主协程结束</p>
<h2> 异常</h2>
<h3> 异常的传播</h3>
<p>协程构建器有两种风格：自动的传播异常（<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" target="_blank" rel="noopener noreferrer">launch</a> 以及 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html" target="_blank" rel="noopener noreferrer">actor</a>）或者将它们暴露给用户（<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" target="_blank" rel="noopener noreferrer">async</a> 以及 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" target="_blank" rel="noopener noreferrer">produce</a>）。前者对待异常是不处理的，类似于 Java 的 <code>Thread.uncaughtExceptionHandler</code>，而后者依赖用户来最终消耗异常，比如说，通过 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html" target="_blank" rel="noopener noreferrer">await</a> 或 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html" target="_blank" rel="noopener noreferrer">receive</a></p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html" target="_blank" rel="noopener noreferrer">CoroutineExceptionHandler</a> 仅在预计不会由用户处理的异常上调用，所以在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" target="_blank" rel="noopener noreferrer">async</a> 构建器中注册它没有任何效果。</p>
<p>协程内部使用 <code>CancellationException</code> 来进行取消，这个异常会被所有的处理者忽略，所以那些可以被 <code>catch</code> 代码块捕获的异常仅仅应该被用来作为额外调试信息的资源。</p>
<p>如果协程遇到除 <code>CancellationException</code> 以外的异常，它将取消具有该异常的父协程。这种行为不能被覆盖，且它被用来提供一个稳定的协程层次结构来进行<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/composing-suspending-functions.md#structured-concurrency-with-async" target="_blank" rel="noopener noreferrer">结构化并发</a>而无需依赖 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html" target="_blank" rel="noopener noreferrer">CoroutineExceptionHandler</a> 的实现。且当所有的子协程被终止的时候，原本的异常被父协程所处理。</p>
<p>应该将<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html" target="_blank" rel="noopener noreferrer">CoroutineExceptionHandler</a> 总是被设置在由 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html" target="_blank" rel="noopener noreferrer">GlobalScope</a> 启动的协程中。将异常处理者设置在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" target="_blank" rel="noopener noreferrer">runBlocking</a> 主作用域内启动的协程中是没有意义的，尽管子协程已经设置了异常处理者，但是主协程也总是会被取消的。</p>
<p>异常被抛出后，所有同级的子协程都会被关闭，然后异常传递给父协程，直到异常被处理。</p>
<p>一个协程的多个子协程抛出异常将会发生什么？通常的规则是“第一个异常赢得了胜利“。</p>
<h3> 监督</h3>
<p>普通的取消 是一种双向机制，在协程的整个层次结构之间传播。</p>
<p>SupervisorJob 它类似于常规的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job.html" target="_blank" rel="noopener noreferrer">Job</a>，但他的取消只会向下传播</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 监督作业</h5>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html" target="_blank" rel="noopener noreferrer">SupervisorJob</a> 可以被用于这些目的。它类似于常规的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job.html" target="_blank" rel="noopener noreferrer">Job</a>，唯一的不同是：SupervisorJob 的取消只会向下传播。这是非常容易从示例中观察到的：</p>
<h5> 监督作用域</h5>
<p>对于<em>作用域</em>的并发，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html" target="_blank" rel="noopener noreferrer">supervisorScope</a> 可以被用来替代 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" target="_blank" rel="noopener noreferrer">coroutineScope</a> 来实现相同的目的。它只会单向的传播并且当子作业自身执行失败的时候将它们全部取消。它也会在所有的子作业执行结束前等待，就像 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" target="_blank" rel="noopener noreferrer">coroutineScope</a> 所做的那样。</p>
<h5> 监督协程中的异常</h5>
<p>常规的作业和监督作业之间的另一个重要区别是异常处理。每一个子作业应该通过异常处理机制处理自身的异常。这种差异来自于子作业的执行失败不会传播给它的父作业的事实。</p>
<h3> 协程的线程安全</h3>
<ol>
<li>
<p>使用线程安全的数据结构</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>以细粒度限制线程</p>
</li>
<li>
<p>以粗粒度限制线程</p>
<p>2、3 都是保证将对共享变量的操作限制在同一个线程中，从而保证线程安全。</p>
</li>
<li>
<p>互斥</p>
<p>类似于线程的锁，协程的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html" target="_blank" rel="noopener noreferrer">Mutex</a> 的 lock 和 unlock 方法可以保证同一时间只有一个协程访问指定代码。Mutex 不会阻塞线程。</p>
</li>
<li>
<p>Actors</p>
<p>一个 <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank" rel="noopener noreferrer">actor</a> 是由协程、被限制并封装到该协程中的状态以及一个与其它协程通信的 <em>通道</em> 组合而成的一个实体。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html" target="_blank" rel="noopener noreferrer">CompletableDeferred</a> 通信原语表示未来可知（可传达）的单个值。</p>
<p>在使用时，由于 actor 是一个协程，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html" target="_blank" rel="noopener noreferrer"><code> SendChannel .send()</code></a> 方法会在通道缓存满的时候挂起调用方，从而最终保证了<code>counter++</code>方法是依次执行的，不会产生并发问题。</p>
<p>actor 在高负载下比锁更有效，因为在这种情况下它总是有工作要做，而且根本不需要切换到不同的上下文。</p>
</li>
</ol>
<blockquote>
<p>注意，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html" target="_blank" rel="noopener noreferrer">actor</a> 协程构建器是一个双重的 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" target="_blank" rel="noopener noreferrer">produce</a> 协程构建器。一个 actor 与它接收消息的通道相关联，而一个 producer 与它发送元素的通道相关联。</p>
</blockquote>
<h2> Select 表达式</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html" target="_blank" rel="noopener noreferrer">select</a> 表达式允许我们使用其 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html" target="_blank" rel="noopener noreferrer">onReceive</a> 子句 <em>同时</em> 从两个生产者接收数据：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html" target="_blank" rel="noopener noreferrer">onReceiveOrNull</a> 可以允许为空，这样可以在关闭通道时执行特定操作</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/on-send.html" target="_blank" rel="noopener noreferrer">onSend</a> 子句 发送消息</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Select 延迟值可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html" target="_blank" rel="noopener noreferrer">onAwait</a> 子句查询</p>
<iframe width="853" height="480" src="https://embed.coggle.it/diagram/Xb_CZoumpCamgUAj/1235701ea5f157867e045f0f5ac28f886effdb5fa1e27b72afa5266e6e3e8891" frameborder="0" allowfullscreen=""></iframe>
<h2> 参考资料</h2>
<p><a href="https://blog.csdn.net/u013064109/article/details/83507076" target="_blank" rel="noopener noreferrer">Kotlin 的独门秘籍 Reified 实化类型参数 (下篇)</a></p>
<p><a href="https://www.kotlincn.net/docs/reference/coroutines/flow.html" target="_blank" rel="noopener noreferrer">Kotlin 协程 中文官网--异步流</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Kotlin 笔记之 Flow</title>
      <link>https://jixiaoyong.github.io/blog/posts/10414aef.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/10414aef.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Kotlin 笔记之 Flow</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 25 Feb 2021 04:20:12 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p><code>Flow</code>是 Kotlin 协程库中的库，用于<strong>异步返回多个值</strong>，官方介绍是参考<code>RxJava</code>等响应式流实现的，但是“<em>拥有尽可能简单的设计，对 Kotlin 以及挂起友好且遵从结构化并发</em>”。本文主要参考<a href="https://www.kotlincn.net/docs/reference/coroutines/flow.html" target="_blank" rel="noopener noreferrer">Flow 中文文档</a>，梳理了学习过程中的要点和理解，以便日后查验。</p>
<h2> 正文</h2>
<p>对于异步返回多个值的需求，集合（如<code>List</code>等）只能一次性返回多个值，而序列（ <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html" target="_blank" rel="noopener noreferrer"><code>Sequence</code></a> ）只支持阻塞代码，<code>Flow</code>则支持挂起函数异步返回多个值。</p>
<h3> 创建 Flow</h3>
<ol>
<li>
<p><code>flow{...}</code></p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code>.asFlow()</code></p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><code>flowOf{}</code></p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ol>
<p>因为<strong>流只会在被收集的时候才会被启动</strong>（指执行类似<code>flow{...}</code>中的内容），所以上述<code>simple()</code>在被调用时会尽快返回且不等待，所以无需<code>suspend</code>修饰。</p>
<h3> 流的收集/末端流操作符</h3>
<ul>
<li>
<p><code>collect{...}</code> 收集<code>emit</code>发送的值</p>
<p>配合<code>onEach{}</code>可以将<code>collect</code>中执行的代码放到<code>onEach</code>中。</p>
</li>
<li>
<p><code>collectLatest{...}</code> 收集<code>emit</code>发送的值，但每次新的<code>emit</code>到来时，取消之前的收集器，创建新的收集器（用新的值执行<code>{...}</code>中的代码）</p>
</li>
<li>
<p><code>launchIn</code> 指定在单独的协程中启动流的收集，这样就可以立即继续进一步执行代码，不会挂起后面的协程代码。</p>
</li>
<li>
<p><code>single()</code> 只接受 flow 发送的一个值，0 个或多个都会报错</p>
</li>
<li>
<p><code>first{...}</code> 查找符合条件的第一个值</p>
</li>
<li>
<p><code>reduce()</code> 求和</p>
</li>
<li>
<p><code>fold(initial,{...})</code> 在初始值<code>initial</code>的基础上求和</p>
</li>
<li>
<p><code>toList</code>、<code>toSet</code></p>
</li>
</ul>
<h3> 过渡流操作符</h3>
<p>过渡操作符应用于上游流，并返回下游流。就像流一样。这类操作符本身不是挂起函数。它运行的速度很快，返回新的转换流的定义。</p>
<ul>
<li><code>map{}</code></li>
<li><code>filter{}</code></li>
<li><code>take(n)</code> 限长操作符，只取前 n 个发射的值</li>
</ul>
<h3> 流上下文</h3>
<p>流默认运行在收集器提供的上下文中，但是可以通过<code>flowOn </code>更改：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 展平流</h3>
<p>将嵌套有<code>Flow</code>的<code>Flow</code>（如<code>Flow&lt;Flow&lt;String&gt;&gt;</code>）<strong>展平</strong>为单个流（如<code>Flow&lt;String&gt;</code>）。</p>
<ul>
<li>
<p><code>flatMapConcat</code> 将收集到的流交给<code>{...}</code>处理后，等待内部流处理完毕后，再去请求下一个流</p>
</li>
<li>
<p><code>flatMapMerge</code> 先顺序收集所有流，再同时收集结果流</p>
</li>
<li>
<p><code>flatMapLatest{...}</code> 类似于<code>collectLatest{...}</code>，在新流发出的时候，立即取消<code>{...}</code>中所有的代码</p>
</li>
<li>
<p><code>flattenConcat</code> 依次展平流</p>
</li>
<li>
<p><code>flattenMerge{...}</code> 并发拼接，先执行<code>{...}</code>中的方法，再执行<code>collect</code>等方法，顺序会乱。</p>
</li>
</ul>
<h3> 异常处理</h3>
<ul>
<li>
<p><code>try/catch</code></p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code>catch()</code></p>
<p><strong>透明捕获</strong>：只捕获上游异常，其之后的异常不会被处理。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>声明式捕获</strong>：将<code>collect</code>的代码移动到<code>onEach</code>中，将其放到<code>catch</code>之前，从而使其被<code>catch</code>捕获。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> 流取消</h3>
<ul>
<li><code>flow { ... }</code> 创建的流的繁忙循环默认可以取消</li>
<li>其他流如果需要取消，可以添加 <code>.onEach { currentCoroutineContext().ensureActive() }</code> 或者<code>.cancellable()</code></li>
</ul>
<h3> 流完成</h3>
<ul>
<li>
<p>命令式</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>声明式</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>onCompletion</code>的可空参数 <code>Throwable</code> 可以用于确定流收集是正常完成（为<code>null</code>）还是有异常发生。他不会处理异常。</p>
</li>
</ul>
<h3> 其余操作</h3>
<ul>
<li>
<p><code>buffer()</code> 缓冲发射项，收集完成后再传给下一步</p>
</li>
<li>
<p><code>conflate()</code> 合并发射项，会丢弃来不及处理的中间值，只获取并处理最新的值</p>
</li>
<li>
<p><code>zip()</code> 合并两个流的值，两个流中的值一一对应</p>
<p>例如<code>(1,2,3) 3s发射一次,(a,b,c) 4s发射一次</code>直接拼接，合并之后为 <code>(1a,2b,3c)</code></p>
</li>
<li>
<p><code>combine()</code> 结合两个流的值，任意一个流中的值发生变化都会触发执行计算</p>
<p>例如<code>(1,2,3) 3s发射一次,(a,b,c) 4s发射一次</code>直接拼接，合并之后为 <code>(1a,2a,2b,3b,3c)</code></p>
</li>
</ul>
<h2> 参考文献</h2>
<p><a href="https://www.kotlincn.net/docs/reference/coroutines/flow.html" target="_blank" rel="noopener noreferrer">Kotlin Flow 中文文档</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Lambda 表达式在 kotlin 中的应用</title>
      <link>https://jixiaoyong.github.io/blog/posts/53875104.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/53875104.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Lambda 表达式在 kotlin 中的应用</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Fri, 09 Feb 2018 03:09:06 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 一个例子</h2>
<p><strong>普通写法</strong>：</p>
<ol>
<li>定义一个接口 OnClickListener</li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>定义方法 SetOnClickListener</li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义的方法和 Java 中写法类似，在使用该方法时也类似：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>lambda 写法</strong>：</p>
<p>定义只需要一步：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用起来也更加简洁：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>方法最后一个参数是 lambda 表达式时，lambda 表达式的方法<code>{}</code>可以放到<code>()</code>的后面，如果只有这一个参数时，<code>()</code>也可以省略</p>
</blockquote>
<p>当方法只有一个参数时，可以省略参数，还用<code>it</code>代替：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>甚至更加简洁，如果要执行的方法和 listener 定义的方法返回值类型相同，可以直接引用该方法：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> lambda</h2>
<p>lambda 在 Java8 中引进，可以很好的替代匿名内部类，使代码更加简洁。</p>
<p>lambda 表达式形式如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>lambda 表达式总是被大括号括着，完整语法形式的参数声明放在大括号内，并有可选的类型标注，函数体跟在一个 <code>-&gt;</code> 符号之后。如果推断出的该 lambda 的返回类型不是 <code>Unit</code>，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。</p>
<p><a href="http://kotlincn.net" target="_blank" rel="noopener noreferrer">kotlincn.net</a> <a href="http://www.kotlincn.net/docs/reference/lambdas.html#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener noreferrer">高阶函数和 lambda 表达式</a></p>
</blockquote>
<p>使用 lambda 的形式如下<code>() -&gt; {}</code>,<code>()</code>内是参数，<code>{}</code>是函数具体的行为。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子来自 <a href="http://importNew.com" target="_blank" rel="noopener noreferrer">importNew.com</a>,<a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener noreferrer">Java8 lambda 表达式 10 个示例</a></p>
<h2> 小知识点</h2>
<ul>
<li>xx.map()</li>
</ul>
<p>凡是<strong>可迭代</strong>的数据都可以使用<code>map()</code>函数</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以更简洁：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>xx.flatMap()</li>
</ul>
<p>返回<strong>可迭代</strong>的数组，可以和<code>xx.map()</code>一起使用</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>LeetCode 笔记--重建二叉树</title>
      <link>https://jixiaoyong.github.io/blog/posts/a64dc0bc.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/a64dc0bc.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">LeetCode 笔记--重建二叉树</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 20 Feb 2020 03:14:24 GMT</pubDate>
      <content:encoded><![CDATA[<p>二叉树的遍历根据根节点与左右子节点的遍历顺序的不同分为三种：</p>
<ul>
<li>
<p>前序遍历</p>
<p>根左右：先遍历根节点，再左子树，再右子树（先从根节点开始，记录左节点直到没有）</p>
<p>第一个为根节点</p>
</li>
<li>
<p>中序遍历</p>
<p>左根右：先左子树，再根子树，再右子树（从树的最左边的节点开始遍历）</p>
</li>
<li>
<p>后序遍历</p>
<p>左右根：先左子树，后右子树，再根节点</p>
<p>最后一个为根节点</p>
</li>
</ul>
<p>在遍历的时候，当父节点只有一个子节点时，依然要遵循以上三种遍历的先后顺序（没有该子节点则不写内容），以保证某一侧的子树（“左边的子树”或“右边的子树”）所有节点都被完全遍历，之后才可以根据遍历的规则切换到下一子树。</p>
<p>如如下子树：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前序遍历：GDAFEMHZ</p>
<p>中序遍历：ADEFGHMZ</p>
<p>后续遍历：AEFDHZMG</p>
<h2> 常见应用</h2>
<p>一般都是给定中序排序，再加上一个前序排序、后续排序来逆向生成二叉树。</p>
<p>根据之前的知识，此类题的解答思路一般为：</p>
<p>先根据前序排序、后续排序的特点，找到根节点，之后再根据找到的根节点将中序排序分为左、右子树两个部分。这样循环直到整个树的每个节点都被遍历完毕，完整的二叉树也会被建立起来。</p>
<p>我们以下面这个二叉树为例：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用代码表示如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资料</h2>
<p><a href="https://www.jianshu.com/p/9e8922486154" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/9e8922486154</a></p>
<p><a href="https://charlesliuyx.github.io/2018/10/22/%5B%E7%9B%B4%E8%A7%82%E7%AE%97%E6%B3%95%5D%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener noreferrer">【直观算法】二叉树遍历算法总结</a></p>
<p><a href="https://jingyan.baidu.com/album/cdddd41cb8d79753ca00e144.html?picindex=1" target="_blank" rel="noopener noreferrer">知道中序和后序遍历，画二叉树和写出前序遍历 </a></p>
<p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener noreferrer">leetcode-重建二叉树</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux下配置Git，使用AndroidStudio同步工程到Github</title>
      <link>https://jixiaoyong.github.io/blog/posts/25db0a11.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/25db0a11.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Linux下配置Git，使用AndroidStudio同步工程到Github</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 28 Apr 2016 22:06:06 GMT</pubDate>
      <content:encoded><![CDATA[<p>这篇文章介绍了如何在 linux 环境下安装和配置 git 与 github ，并且使用 Android Studio 将本地的项目同步到 github 上面。</p>
<h2> 安装 git</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 配置 git 和 github</h2>
<ul>
<li>
<p>创建 Github 账号</p>
</li>
<li>
<p>生成 ssh key</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在 github 上面添加 ssh key</p>
</li>
</ul>
<p>进入 Account Settings –&gt; SSH Keys –&gt; Add SSH Key 添加 SSH Keys ：<br>
名字起一个容易识别的名字，key 是生成的 <code>/home/username/.ssh/id_rsa.pub.</code> 中的内容，直接粘贴到指定位置就行</p>
<ul>
<li>
<p>测试 ssh key 是否成功</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<p>提示如<code>You’ve successfully authenticated, but GitHub does not provide shell access</code>则说明成功连接 github</p>
<ul>
<li>
<p>配置 Github</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> 用 Android Studio 同步工程到 Github</h2>
<ul>
<li>
<p>启动 android studio</p>
<p>进入<code>android studio/bin</code>，终端输入<code>./studio.sh</code></p>
</li>
<li>
<p>选择 <code>VCS ---&gt; Import into Version Control --&gt; Share Project on Github</code></p>
</li>
</ul>
<p>第一次进入会要求输入 github 的账号和密码 按照要求输入即可<br>
此后还会要求你输入一个本地密码，当下次同步的时候需要输入<br>
之后就进入到选择同步的仓库，新建一个仓库，开始同步就可以了</p>
<p><strong>到这里就顺利的在 Android Studio 上面将工程同步到 Github 上面了</strong></p>
<hr>
<p><strong>以下为原文提到的其他方法，摘录如下，以备后用：</strong></p>
<h2> 利用 Git 从本地上传到 GitHub</h2>
<p>第一步： 进入要所要上传文件的目录</p>
<p>输入命令 <code>git init</code></p>
<p>第二步： 创建一个本地仓库 origin</p>
<p>使用命令</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>youname</code>是你的 GitHub 的用户名，<code>yourRepo</code>是你要上传到 GitHub 的仓库</p>
<p>第三步： 比如你要添加一个文件 xxx 到本地仓库，使用命令 <code>git add xxx</code>，可以使用 <code>git add .</code> 自动判断添加哪些文件</p>
<p>然后把这个添加提交到本地的仓库，使用命令 <code>git commit -m</code>说明这次的提交</p>
<p>最后把本地仓库 origin 提交到远程的 GitHub 仓库，使用命令 <code>git push origin master</code></p>
<h2> 从 GitHub 克隆项目到本地</h2>
<p>第一步： 到 GitHub 的某个仓库，然后复制右边的有个<code>HTTPS clone url</code></p>
<p>第二步： 回到要存放的目录下，使用命令 <code>git clone https://github.com/chenguolin/scrapy.git</code>，这里的 url 只是一个例子</p>
<p>第三步： 如果本地的版本不是最新的，可以使用命令 <code>git fetch origin</code>，origin 是本地仓库</p>
<p>第四步： 把更新的内容合并到本地分支，可以使用命令 <code>git merge origin/master</code></p>
<p>如果你不想手动去合并，那么你可以使用：<br>
<code>git pull &lt;本地仓库&gt; master</code> // 这个命令可以拉去最新版本并自动合并</p>
<h2> GitHub 的分支管理</h2>
<ul>
<li>创建</li>
</ul>
<p>1 创建一个本地分支： <code>git branch &lt;新分支名字&gt;</code></p>
<p>2 将本地分支同步到 GitHub 上面： <code>git push &lt;本地仓库名&gt; &lt;新分支名&gt;</code></p>
<p>3 切换到新建立的分支： <code>git checkout &lt;新分支名&gt;</code></p>
<p>4 为你的分支加入一个新的远程端： <code>git remote add &lt;远程端名字&gt; &lt;地址&gt;</code></p>
<p>5 查看当前仓库有几个分支: <code>git branch</code></p>
<ul>
<li>删除</li>
</ul>
<p>1 从本地删除一个分支： <code>git branch -d &lt;分支名称&gt;</code></p>
<p>2 同步到 GitHub 上面删除这个分支： <code>git push &lt;本地仓库名&gt; :&lt;GitHub端分支&gt;</code></p>
<h2> 说明</h2>
<p>这篇文章是我今天在 linux 下安装 git ，上传工程到 github 上面时的步骤的总结，大部分内容都参考/摘录自下面这篇文章，感谢原作者的分享，原文信息及链接如下：</p>
<blockquote>
<p>Linux 下 Git 和 GitHub 使用方法总结<br>
[日期：2014-03-07] 来源：Linux 社区 作者：chenguolin<br>
<a href="http://www.linuxidc.com/Linux/2014-03/97821.htm" target="_blank" rel="noopener noreferrer">http://www.linuxidc.com/Linux/2014-03/97821.htm</a></p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 下配置 JDK 和 AndroidStudio 开发环境</title>
      <link>https://jixiaoyong.github.io/blog/posts/ca532ade.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/ca532ade.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Linux 下配置 JDK 和 AndroidStudio 开发环境</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 27 Apr 2016 22:06:06 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 下载 JDK 并解压</h2>
<ul>
<li>到官网下载 jdk</li>
<li>下载到的 JDK 文件解压</li>
</ul>
<h2> 设置环境变量</h2>
<p>管理员权限进入 etc/environment 写入以下代码</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 配置 alternatives</h2>
<p>打开终端执行以下命令：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里 JDK 的环境就配置好了</p>
<h2> 运行 Android Studio</h2>
<p>进入 android studio/bin 目录下，打开终端，</p>
<p>输入 <code>./studio.sh</code></p>
<p>到这里，就可以正常运行 android studio 了</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux常用命令</title>
      <link>https://jixiaoyong.github.io/blog/posts/d0edc1ed.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/d0edc1ed.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Linux常用命令</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 14 Jan 2019 12:16:53 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 复制，删除，移动</h2>
<p><code>cp</code>拷贝，<code>rm</code>删除，<code>mv</code>移动。</p>
<p><code>-r</code>表示递归 <code>-f</code>强制，无提示</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 切换目录</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 新建文件、文件夹</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Linux 文件和目录名字除了“/”都合法，但是尽量不要用正则表达式之类的符号，因为有可能会在进行正则匹配时造成误删等问题</p>
<p>假设当前目录有文件<code>f1,f2,f3</code>和<code>f[123]</code><br>
执行：<code>rm f[123]</code>本来是希望删除<code>f[123]</code>,但是由于正则匹配，会先删除<code>f1,f2,f3</code>这三个文件。</p>
<h2> 查看文件信息</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 常用目录</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 文件相关</h2>
<h3> ls</h3>
<p><strong><code>ls</code></strong> 展示当前目录下文件信息：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>l</code>展示目录下的文件列表，<code>a </code>展示所有文件（包括隐藏文件），<code> h</code> 展示带单位的文件大小， <code>d</code>展示当前目录本身信息</p>
<h3> chmod</h3>
<p><strong><code>chmod</code></strong> 更改权限</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>mode</code>组成如下：<code>[范围] [操作] [权限]</code></p>
<p><code>范围</code>：<code>u</code>用户、<code>g</code>群组、<code>o</code>其他、<code>a</code>以上所有（ugo）</p>
<p><code>操作</code>：<code>+</code> 增加、<code>-</code> 减去、<code>=</code> 等于</p>
<p><code>权限</code>：<code>r</code> 读权限<code>4</code>、<code> w</code> 写权限<code>2</code>、 <code>x</code> 执行权限<code>1</code> 、无权限 <code>0</code></p>
<p><strong>权限验证</strong> ： root 用户可以访问任何用户文件，不受权限限制；普通用户需要验证权限</p>
<p><em>要读取文件夹中的内容，也需要执行权限<code>x</code></em></p>
<h3> 文件权限与 umask</h3>
<p>Linux 创建新项目时默认的权限分别是：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，经过 umask（此处为 0022）遮盖后，变成了 755 ，644，这才是真正创建后的结果</p>
<p>可以通过<code>umask查看</code>umask 的值，一般只去其<strong>后 3 位</strong>，遮盖的原则是从原先的权限中<strong>减去</strong>umask 中的权限：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 查看、管理当前用户信息</h3>
<p><code>users</code> 和<code>whoami</code>输出当前用户名</p>
<p>增、删、改用户：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>userdel -r username</code>在删除用户时，也会删除用户对应的主目录<code>home</code></p>
<p><code>groups</code> 查看用户所在群组，其中第一个是主要群组，其余是次要群组。</p>
<p><em>主要群组</em> 在用户创建新的文件时，文件群组权限一项默认为该群组</p>
<p><code>who</code> 、<code>w</code>可以查看用户相关信息</p>
<p><code>id</code> 查看某人或者自己相关的<code>UID、GID</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>GID</code> 系统 &lt;500 ，用户 &gt;500</p>
<h3> 改密码</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 文件打包、压缩和解压缩</h3>
<p><code>.gz</code> 压缩后格式，<code>.tar </code>打包后格式，<code>tar.gz</code>先打包后压缩的格式（常用）</p>
<h4> gzip</h4>
<p>gzip 压缩会删除源文件,</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>#</code> 压缩等级</p>
<p><code>v</code> 显示压缩前后压缩比</p>
<p><code>t</code> 校验是否是 gzip 压缩的文件</p>
<p><code>c</code> 压缩文件并输出到屏幕</p>
<p><code>d</code> 解压文件</p>
<p>使用:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> tar</h4>
<p>打包，在压缩文件夹时，一般为了效率都会先打包，在压缩，由此形成的格式一般是类似<code>*.tar.gz*</code>的后缀。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>c</code> 建立打包文档</p>
<p><code>x</code> 解包<code> -C</code> 输出目录</p>
<p><code>t</code> 查看打包文件的内容</p>
<p><code>j</code> / <code>z</code> 使用<code>bz2</code> / <code>gzip</code> 压缩、解压</p>
<p><code>v</code> 输出信息</p>
<p><code>f</code> 后面紧跟要操作的文件</p>
<h2> bash shell</h2>
<p>bash 是用户和内容交互的桥梁 <code>用户 ↔ bash ↔ Unix内核</code></p>
<p><code>env</code> 查看环境变量</p>
<p><code>type</code> 查看类型</p>
<p><code>which</code> 查看指令的位置</p>
<p><code>clear</code> 、 <code>cls</code> 清屏</p>
<p><strong>bash shell 设置</strong></p>
<h3> 自定义变量</h3>
<p><code>key=value</code> 增加一个值为<code>value</code>的变量<code>key</code></p>
<p>其中，如果 value 有空格的话需要用引号包住：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>echo $KEY​ </code>可以输出<code>KEY</code>的值</p>
<p><code>set</code> 查看所有变量</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 别名配置</h3>
<p><code>alias</code> 查看所有别名</p>
<p><code>alias newCmd=oldCmd</code>使用<code>newCmd</code>表示<code>oldCmd</code></p>
<p><code>unalias newCmd</code> 删除别名</p>
<p>如:<code>alias cls=clear</code>,执行<code>cls</code>就等于执行<code>clear</code></p>
<h3> 环境变量</h3>
<p><code>export KEY=VALUE</code> 将值为<code>VALUE</code>的<code>KEY</code>添加到环境变量（本次 shell 有效）</p>
<p>此外还可以写到一些文件中，在开机、登录、注销登录时调用执行——自动执行脚本**<code>shell startup scripts</code>**</p>
<h3> shell startup scripts</h3>
<p>开机时执行：</p>
<ul>
<li>
<p><code>/etc/profile</code></p>
</li>
<li>
<p><code>/ect/profile.d/*.sh</code></p>
</li>
<li>
<p><code>~/.bash_profile , ~/.bash_login , ~/.profile</code>这三个只要其中一个成功执行了，后面的就不会执行，<code>~/.bash_profile</code>会执行<code>~/.bashrc</code></p>
</li>
<li>
<p><code>/etc/.bashrc</code></p>
</li>
</ul>
<p>未登录时会执行：</p>
<ul>
<li><code>~/.bashrc</code></li>
<li><code>/etc/bashrc</code></li>
<li><code>/etc/profile.d/*.sh</code></li>
</ul>
<p>注销时执行<code>~/bash_logout</code></p>
<p><strong>在修改了以上文件后，可以使用<code>source path_to_file</code>或者重新登录使其立即生效</strong></p>
<h2> 标准输入输出等</h2>
<table>
<thead>
<tr>
<th>代码编号</th>
<th>名称</th>
<th>代码</th>
<th>作用对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>标准输入</td>
<td>stdin</td>
<td>键盘等</td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
<td>stdout</td>
<td>屏幕等</td>
</tr>
<tr>
<td>2</td>
<td>标准错误</td>
<td>stderr</td>
<td>屏幕等</td>
</tr>
</tbody>
</table>
<p>定向</p>
<ul>
<li><code>&lt;</code>和<code>&lt;&lt;</code> 输入和 追加输入</li>
<li><code>&gt;</code> 和<code>&gt;&gt;</code> 输出 和追加输出</li>
</ul>
<p>使用：<code>ls -al | &gt;&gt; result.txt</code>将<code>ls</code>的内容追加输出到<code>result.txt</code>文件中。</p>
<p><code>|</code>叫做管道，可以将前者的<strong>标准输出</strong>当做后者的输入。</p>
<p><code>cmd0 &amp;&amp; cmd1</code> 前者执行成功才会执行后者；</p>
<p><code>cmd0 || cmd1</code> 前者执行失败才会执行后者。</p>
<h2> grep</h2>
<p>查询内容</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>c</code> 计算次数</p>
<p><code>i</code> 忽略大小写</p>
<p><code>n</code> 行号</p>
<p><code>v</code> 显示没有该字符的行号</p>
<p><code>'key' </code>可以是正则表达式</p>
<p><code>--color=auto</code> 对查找到的文本显示颜色</p>
<h2> sort</h2>
<p>排序，默认以第一列排序</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>f</code> 忽略大小写</p>
<p><code>b</code>忽略最前面的空格（要是排序不生效时可以试一下，推荐）</p>
<p><code>k</code> 以第几列为标准排序，默认第一列</p>
<p><code>n</code> 以数组排序</p>
<p><code>r</code> 逆序</p>
<p><code>t</code> 待排序的文件的分隔符，默认是 tab</p>
<p><code>M</code> 以英文月份排序</p>
<h2> wc</h2>
<p>统计字符数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>l</code> 行</p>
<p><code>w</code> 词</p>
<p><code>m</code> 字符</p>
]]></content:encoded>
    </item>
    <item>
      <title>OKHttpUtils 分析</title>
      <link>https://jixiaoyong.github.io/blog/posts/6ff87ae7.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/6ff87ae7.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">OKHttpUtils 分析</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 17 Mar 2019 05:32:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>本文是对张鸿洋的 OKHttp 辅助类<a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="noopener noreferrer"><strong>okhttputils</strong></a>简要分析，以便学习如何封装常见工具的思想，建议配合源码食用。</p>
<p>主要涉及类：</p>
<ul>
<li>OkHttpUtils</li>
<li>OkHttpRequestBuilder</li>
<li>OkHttpRequest</li>
<li>RequestCall</li>
<li>Callback</li>
</ul>
<h2> 基础</h2>
<p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener noreferrer">OkHttp</a>是可以用于 Android 和 Java 的 Http 框架，经典的使用分为 3 步：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然整体的逻辑已经很简单了，但是在实际使用的时候，不可能对每个网络请求都写一次上述代码，所以就需要对齐进行必要的封装以简化网络请求流程。</p>
<p>okhttputils 就做到了这一点，并且将上述第二步常见网络请求的过程也加入链式调用中，使用起来更加连贯：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>9~10</code>行相当于 OKHttp 步骤 2 创建网络请求，<code>11~14</code>则就是步骤 3 执行网络请求的过程。</p>
<p>每次使用网络请求时只需要选择<code>get</code>、<code>post</code>等方法获取并配置相应<code>builder</code>，然后选择<code>execute</code>执行即可。</p>
<h2> 实现分析</h2>
<p>那么 okhttputils 是如何实现这一点的呢？</p>
<p>首先看看<code>OkHttpUtils</code>的结构：</p>
<figure><img src="https://jixiaoyong.github.io/images/20190317141417.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到大体上可以将其分为 3 个部分：</p>
<ol>
<li>OkHttpClient 相关</li>
<li>网络请求相关信息</li>
<li>与具体执行网络请求有关的方法</li>
</ol>
<h3> OkHttpClient 相关</h3>
<p>我们先来看第一部分，OkHttpUtils 本质上只是对 OkHttpClient 的方法进行了一次封装，所以其肯定要持有 OkHttpClient 对象，一般来说一个 APP 只需要一个 OkHttpClient 对象即可，所以可以看到 OkHttpUtils 做了双重锁定的单例处理：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们在第一次使用<code>OkHttpUtils</code>的时候初始化的<code>OkHttpClient</code>便会被保存到这里，之后的使用中就不需要再去反复创建了。</p>
<p>此外在<code>OkHttpUtils</code>的结构中可以注意到有一个<code>mPlatform</code>的变量，他会根据当前是 Android 还是其他平台的不同被初始化为 Android 主线程或者普通线程池，这个我们在后面回调网络请求状态的时候会用到。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 网络请求相关信息</h3>
<p>有了<code>OkHttpClient</code>对象之后，下一步便是创建一个适当的网络请求。</p>
<p>在<code>OkHttpUtils</code>中使用的是<code>OkHttpRequestBuilder &lt;T extends OkHttpRequestBuilder&gt;</code>的子类来收集、配置相关的一些属性。</p>
<p>在该类中，定义了一系列网络请求基本的参数：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外还有一个抽象方法，用来创建执行网络请求的<code>RequestCall</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个方法在其子类中的实现一般是调用<code>OkHttpRequest</code>子类的<code>build</code>方法，可以看到<code>OkHttpRequestBuilder</code>只是将网络请求的相关参数传递到<code>OkHttpRequest</code>中。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>OkHttpRequest</code>中，利用上述的参数可以并通过<code>generateRequest(Callback callback)</code>方法创建<code>Request</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的抽象方法<code>wrapRequestBody()</code>，<code>buildRequest()</code>的实现，也是<code>OkHttpRequest</code>各个子类主要的不同点。</p>
<blockquote>
<p><code>Callback</code>是在<code>okhttp3.Callback</code>的基础上增加了 before，progress 和对请求结果的处理等的回调。</p>
</blockquote>
<p><code>OkHttpRequest</code>类的<code>build</code>方法则只是将其自身传递给<code>okhttp3.Call</code>的封装类<code>RequestCall</code>，创建并返回该类的对象：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 执行网络请求</h3>
<p><code>RequestCall</code>类则是对<code>okhttp3.Call</code>类的进一步封装，对外提供更多的接口：开始、取消网络请求<code>cancel()</code>,<code>readTimeOut()</code>…等接口。</p>
<p>当执行<code>RequestCall</code>的<code>execute</code>方法时：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看其最后只是将<code>RequestCall</code>和<code>callback</code>传递给了<code>OkHttpUtils</code>类的<code>execute</code>方法，也就是说，最终还是调用了<code>okhttp3.Call</code>的<code>enqueue()</code>方法，在这里执行了真正的网络请求：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而网络请求的回调，则是在本文最开始的<code>mPlatform</code>提供的线程中进行。这样保证了在 Android 中，<code>onBefore</code>、<code>onAfter</code>、<code>inProgress</code>等回调能够在 UI 线程进行。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p>在本文中，<code>okhttputils</code>将初始化<code>OkHttpClient</code>的动作提取出来，这样同一个应用只需要在最开始的时候配置一下诸如网络超时、cookie 等既可。</p>
<p>在具体的实现中，通过<code>OkHttpRequestBuilder</code>收集网络请求的属性并传递给<code>OkHttpRequest</code>，在其子类中按照不同的需要实现生成<code>Request</code>的方法。</p>
<p><code>OkHttpRequestBuilder</code>的<code>build()</code>方法会生成<code>RequestCall</code>对象，<code>RequestCall</code>对象的<code>execute()</code>方法会调用<code>OkHttpRequestBuilder</code>对象的<code>generateRequest()</code>方法产生<code>Request</code>，并据此产生<code>Call</code>对象，最后通过该<code>Call</code>对象的 enqueue 方法执行网络请求。</p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20190317141417.png" type="image/png"/>
    </item>
    <item>
      <title>Python 自动创建发布 hexo 文章并同步 github</title>
      <link>https://jixiaoyong.github.io/blog/posts/d9a2e1ba.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/d9a2e1ba.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Python 自动创建发布 hexo 文章并同步 github</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 31 Jan 2018 16:09:12 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<blockquote>
<p>环境 linux(deepin)</p>
<p>python 2.7</p>
</blockquote>
<p>这是一个 Python 脚本，用于实现 hexo 文章创建、生成网页并预览、发布到对应 <a href="http://xxx.github.io" target="_blank" rel="noopener noreferrer">xxx.github.io</a> 博客的全过程。</p>
<h2> 使用方法</h2>
<h3> 使用时需要根据自己的项目更新 <a href="http://main.py" target="_blank" rel="noopener noreferrer">main.py</a> 的一下变量：</h3>
<ul>
<li>
<p>hexo_url = 'your_path/hexo/blog'</p>
<p>【必需】本地 hexo 博客路径</p>
</li>
<li>
<p>hexo_public_dir = 'your_path/hexo/blog/public'</p>
<p>【必需】本地 hexo 博客输出路径</p>
</li>
<li>
<p>hexo_post_dir = 'your_path/hexo/blog/source/_posts'</p>
<p>【可选】本地 hexo 博客文章源文件路径</p>
</li>
<li>
<p>git_dir = 'your_path/xxx.github.io'</p>
<p>【必需】博客要同步的 git 工程路径</p>
</li>
<li>
<p>git_backup_dir = 'your_path/xxx.github.io/blog/backup/sources/_posts'</p>
<p>【可选】本路径用于备份 post 源文件到 github</p>
</li>
<li>
<p><a href="http://hexo.py" target="_blank" rel="noopener noreferrer">hexo.py</a> 中的<code>post()</code>方法中<code>webbrowser.open('http://jixiaoyong.github.io/blog/')</code>中的博客地址，发布完后默认打开该网页。（后期也可以改为<code>post()</code>参数传入，这样只需要更改<code>main.py</code>就行）</p>
</li>
</ul>
<h3> 运行<code>main.py</code>文件</h3>
<ul>
<li>在 Linux 命令行输入如下命令，并回车，根据提示操作即可。</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ Windows 下可以运行<code>start.cmd</code>脚本（待实现）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>操作过程提示及说明如下：（渣英语请忽略...）</p>
<ul>
<li>
<p>input yout file name 输入要发布的文章名称 xxx（当前版本暂不支持中文）</p>
<p>输入回车会自动创建 <a href="http://xxx.md" target="_blank" rel="noopener noreferrer">xxx.md</a> 文件并打开（需要系统支持该格式）</p>
</li>
<li>
<p>are you finish your post 输入 y 或 n，选择是否用 hexo 编译文章</p>
<p>y:编译文章 n:不编译文章，退出命令行</p>
</li>
<li>
<p>post or not 输入 y 或 n，选择是否发布文章到网站，可以在打开的页面预览后做决定</p>
<p>y:发布文章 n:不发布文章，退出命令行</p>
</li>
<li>
<p>update post《xxx》提示开始发布文章，自动打开网页，并保存源文件</p>
</li>
</ul>
</li>
</ul>
<h2> 源代码</h2>
<p>源代码已经上传<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-31/python%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%96%87%E7%AB%A0" target="_blank" rel="noopener noreferrer">github</a></p>
<h2> 后期计划</h2>
<ul>
<li>增加文件名中文支持</li>
<li><s>增加图片自动上传、替换为 github 链接</s>(2018/2/2 已实现)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Python 入门知识</title>
      <link>https://jixiaoyong.github.io/blog/posts/a8f97c56.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/a8f97c56.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Python 入门知识</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 20 Jan 2018 15:49:17 GMT</pubDate>
      <content:encoded><![CDATA[<p>基于 Python3.x</p>
<p>Python 文件默认格式<code>.py</code></p>
<p>首行默认以下命令：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 数据类型</h2>
<ul>
<li>
<p><strong>数字</strong></p>
<p>整数 int 1，2，3</p>
<p>长整数 long 1112L</p>
<p>浮点数 float（小数）1.23，3.14</p>
<p>复数 complex 3.14j</p>
</li>
<li>
<p><strong>字符串</strong></p>
<p>'abc'，"abc"，'''abc‘’‘</p>
<p>'x'和"x" 区别不大</p>
<p>'''abc‘’‘文本可以跨行</p>
<p>字符串前面加 r 或者 R 表示字符串内部不需要转义，否则要用<code>\</code> 转义</p>
<p>支持<code>a[0]</code>取值</p>
</li>
<li>
<p><strong>布尔值</strong></p>
<p><code>True</code> 和<code>False</code></p>
<p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算</p>
</li>
<li>
<p><strong>空值</strong></p>
<p><code>None</code></p>
</li>
<li>
<p><strong>变量</strong></p>
<p>命名规则：开头<code>aA_</code>，其后可以包含<code>aA_1</code></p>
</li>
<li>
<p><strong>常量</strong></p>
<p>不能变的变量</p>
</li>
</ul>
<h2> 集合</h2>
<ul>
<li>
<p><strong>列表 list</strong></p>
<p>[1,2,3,3]</p>
<p>插入 list.insert(1,'vaule')</p>
<p>删除 list.pop() / list.pop(1)</p>
</li>
<li>
<p>**元组 tuple **</p>
<p>(1,2,3,3)</p>
<p>与列表类似，但是一旦初始化就不能再修改</p>
<hr>
</li>
<li>
<p><strong>字典 dict</strong></p>
<p a:1,b:vaule=""></p>
<p>键值对，读取快，相当于 java 的 map</p>
</li>
<li>
<p><strong>set</strong></p>
<p>set([1,2,3])</p>
<p>键的集合，不能有重复的，相当于 java 的 set</p>
</li>
</ul>
<h2> 逻辑语句</h2>
<ul>
<li>if ... : ... elif ... : ... else : ...</li>
<li>for x in xs : ...</li>
<li>while x : ...</li>
</ul>
<h2> 自定义函数</h2>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>return</strong></li>
</ul>
<p>可以没有 return，默认返回 None</p>
<p>可以 return 多个值，实际上返回的是一个 tuple</p>
<ul>
<li><strong>pass</strong></li>
</ul>
<p>不想执行任何语句，但是为了符合语法规范，可以用 pass 当做占位符</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>抛出异常</strong></li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中 TypeError 需要继承自<code>error</code>或者<code>Exception</code></p>
<ul>
<li><strong>参数</strong></li>
</ul>
<p>位置参数</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>默认参数</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong> 默认参数必须是参数中后面的几位；默认值必须不可变，如 int，string 等</p>
<p>可变参数</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>*args</code> 表示参数个数可变，可以输入 list/tuple 等，或者依次输入多个参数，用逗号分隔</p>
<p>关键词参数</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>**keywords</code> 表示接受关键词作为参数传入，可以传入 dict，或者依次输入多个关键词参数</p>
<p>命名关键词参数</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>限制输入的关键字，限制只有 name 和 age 作为关键词参数</p>
<h2> 使用其他文件的函数</h2>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 类</h2>
<ul>
<li><strong>定义类</strong></li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所有的类方法必须至少有一个参数，推荐命名为 self，系统会自动传入类对象，无需手动传入。</p>
<ul>
<li><strong>继承</strong></li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>子类继承父类，则需要在子类定义时传入父类</p>
<p>子类如果有与父类同名方法，则优先调用子类方法，除非子类特别调用父类的方法</p>
]]></content:encoded>
    </item>
    <item>
      <title>Python 爬取 gityuan 所有文章列表</title>
      <link>https://jixiaoyong.github.io/blog/posts/6e070881.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/6e070881.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Python 爬取 gityuan 所有文章列表</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 28 Jan 2018 14:03:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>更新内容：</p>
<ul>
<li>爬取 <a href="http://gityuan.com" target="_blank" rel="noopener noreferrer">gityuan.com</a> 网站所有文章列表并输出 json</li>
<li>汇总信息输出 config.json 为后面的客户端做准备</li>
</ul>
<p>更新文件：</p>
<ul>
<li>spider_main.py</li>
<li>html_output.py</li>
<li><strong>gityuan_urls.py</strong></li>
<li><strong>html_downloader.py</strong></li>
</ul>
<h2> 代码</h2>
<ul>
<li><strong>spider_main.py</strong></li>
</ul>
<p>作为入口类，主要增加了初始化所有 URL，以及便利这些 URL 的功能。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其<code>craw()</code>方法修改如下：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>html_output.py</strong></li>
</ul>
<p>主要改动如下：</p>
<ol>
<li><code>output_html(self,file_name)</code>方法增加一个<code>file_name</code>的参数，并在内部调用<code>self.mkdir()</code>方法生成 output 目录，方便同时输出多个文档</li>
<li><code>mkdir()</code>方法，创建文件</li>
<li><code>end(self,file_name_start, url, num)</code>方法，输出汇总文档，代码如下</li>
</ol>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>gityuan_urls.py</strong></li>
</ul>
<p>主要代码如下，通过循环遍历获取所有文章列表信息</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>html_downloader.py</strong></li>
</ul>
<p>就在本文编辑的过程中，爬虫被识别，并且限制访问文件数量，所以对下载功能做了简单的伪装、增加超时处理。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 结语</h2>
<p>当前爬虫主体功能以及实现，可以爬取 <a href="http://gityuan.com" target="_blank" rel="noopener noreferrer">gityuan.com</a> 所有有效文章列表，可以满足客户端需求。但仍然存在以下问题：</p>
<ol>
<li>没有伪装，爬虫<strong>很容易</strong>被识别并被拒绝服务（<s>就在刚刚写下这句话的时候，就发生了被限制访问，真*乌鸦嘴</s>）。</li>
<li>由于原网站特性，其置顶文章每页都有，会导致部分数据重复。</li>
<li>未爬取具体文章内容。</li>
</ol>
<blockquote>
<p><strong>说明</strong></p>
<p>本文只为学术研究，其中涉及到的第三方网站及其所有资源均属原主所有。向 gityuan 大神致敬，欢迎访问其<a href="http://gityuan.com/" target="_blank" rel="noopener noreferrer">blog</a>。</p>
</blockquote>
<h2> 源码</h2>
<p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/gityuan_spider" target="_blank" rel="noopener noreferrer">github 链接</a></p>
<p><code>tag</code>为<code>gityuan_spider1.5</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>Python 爬虫爬取 gityuan.com 数据并输出 json</title>
      <link>https://jixiaoyong.github.io/blog/posts/9c0ccf0d.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/9c0ccf0d.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Python 爬虫爬取 gityuan.com 数据并输出 json</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 27 Jan 2018 14:25:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<blockquote>
<p>本文基于 Python2.7</p>
</blockquote>
<p>这篇文章基于我在<a href="www.imooc.com">慕课网</a>上面学习 Python 简单爬虫写的内容，教程内容是爬取 1000 条百度百科的数据，但是教程中爬虫截止 2018-01-27 已经失效，刚好看到大神 <a href="http://gityuan.com" target="_blank" rel="noopener noreferrer">gityuan.com</a> 的内容，于是用 Python 实现爬取其网页内容并生成 json 数据。</p>
<p>本文即上述过程整理。</p>
<p>本文涉及源代码已上传 github（<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/gityuan_spider" target="_blank" rel="noopener noreferrer">点这里查看</a>）。</p>
<h2> 框架</h2>
<p>爬虫主要活动是：</p>
<ol>
<li>爬取目标网页内容</li>
<li>对获取到的内容进行分析，获取有用数据</li>
<li>将处理好的数据按格式输出</li>
</ol>
<p>此外还需要有一个专门管理爬虫活动的主类，故而文件结构如下：</p>
<ol>
<li>spider_main.py 入口类</li>
<li>url_manager.py 管理要下载的链接</li>
<li>html_downloader.py 下载网页内容</li>
<li>html_paeser.py 对获取到的数据进行解析、加工</li>
<li>html_out.py 输出格式化的数据</li>
</ol>
<p>目前只实现了爬取 <a href="http://gityuan.com" target="_blank" rel="noopener noreferrer">gityuan.com</a> 第一页内容并输出 json，所以暂时不需要实现 url_manager.py</p>
<h2> 关键代码</h2>
<p><strong>spider_main.py</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在<code>__init__()</code> 方法初始化各个变量；</li>
<li>在<code>craw()</code>中分别实现下载、解析网页内容、输出加工数据</li>
</ul>
<p><strong>html_download.py</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下载并返回网页内容，比较简单</p>
<p><strong>html_parser.py</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是爬虫功能的重点之一：对网页数据进行解析，由此数据才变为可用数据</p>
<p>主要是通过第三方插件<code>BeautifulSoup</code>解析数据，并保存到数组<code>res_data</code>中，具体见代码中实现</p>
<p><strong>html_output.py</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本类也很重要，主要是数据存取，以及将解析好的数据格式化输出</p>
<h2> 说明</h2>
<p>本文中代码经二次处理，不一定与源代码一致，但思路如此，以供参考。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Dart Isolate 源码分析</title>
      <link>https://jixiaoyong.github.io/blog/posts/a951661c.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/a951661c.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Dart Isolate 源码分析</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 28 May 2022 07:20:01 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Isolate</h2>
<p>💡 本文基于 Dart 2.17.1</p>
<p><a href="https://api.dart.cn/stable/2.17.1/dart-isolate/Isolate-class.html" target="_blank" rel="noopener noreferrer">Isolate</a>, an isolated Dart execution context.</p>
<p>All Dart code runs in an isolate, and <strong>code can access classes and values only from the same isolate</strong>. Different isolates can communicate by <strong>sending values through ports</strong> (see <a href="https://api.dart.cn/stable/2.17.1/dart-isolate/ReceivePort-class.html" target="_blank" rel="noopener noreferrer">ReceivePort</a>, <a href="https://api.dart.cn/stable/2.17.1/dart-isolate/SendPort-class.html" target="_blank" rel="noopener noreferrer">SendPort</a>).</p>
<blockquote>
<p>In Dart an isolate has its own event loop, its own global fields, can run in parallel with other isolates and have their own live-cycle.<br>
— <a href="https://github.com/dart-lang/sdk/issues/36097#issuecomment-746510375" target="_blank" rel="noopener noreferrer">https://github.com/dart-lang/sdk/issues/36097#issuecomment-746510375</a></p>
</blockquote>
<p>The new isolate has its <strong>own memory and its own thread</strong> working in parallel with the main isolate.</p>
<figure><img src="https://jixiaoyong.github.io/images/isolate_and_isolate_group.png" alt="https://www.youtube.com/watch?v=NoVYI94MJio&amp;ab_channel=Flutterly" tabindex="0" loading="lazy"><figcaption><a href="https://www.youtube.com/watch?v=NoVYI94MJio&amp;ab_channel=Flutterly" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=NoVYI94MJio&amp;ab_channel=Flutterly</a></figcaption></figure>
<p><a href="https://www.youtube.com/watch?v=NoVYI94MJio&amp;ab_channel=Flutterly" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=NoVYI94MJio&amp;ab_channel=Flutterly</a></p>
<p>Isolate 创建会占用内存，可以使用<code>IsolateGroup</code>来解决，并且目前为止 Dart 和 Flutter 都默认支持在使用<code>Isolate.spawn</code>创建新 Isolate 的时候使用 IsolateGroup（<code>Isolate.spwanUri</code>创建的时候会创建<strong>单独</strong>的 IsolateGroup 和 Isolate）。</p>
<blockquote>
<p>💡 在创建 isolate 的时候可以添加<code>addOnExitListener</code> 或者<code>addErrorListener</code>之类的监听，但是可能在执行添加代码的时候<strong>isolate 就已经终止了</strong>而导致这些方法收不到回调。<br>
为了避免这种情况，可以在创建 isolate 的时候指定他的状态为**<code>paused</code>**。</p>
</blockquote>
<p>与 isolate 有关的类有：</p>
<ul>
<li><code>Isolate</code> 位置在<code>sdk\lib\isolate\isolate.dart</code>。主要是<code>Isolate</code> 通用方法、属性的抽象描述，没有具体实现。</li>
<li><code>Isolate</code> 位置在<code>sdk\lib\_internal\vm\lib\isolate_patch.dart</code>，是 app 等平台对应的具体实现，部分方法调用了 native 层的 Isolate 实现。</li>
<li><code>Isolate</code> 位置在<code>runtime\vm\isolate.h</code>以及<code>runtime\vm\isolate.cc</code>中，是 Isolate 的 native 层实现。</li>
</ul>
<p>他们的关系大致如图：</p>
<figure><img src="https://jixiaoyong.github.io/images/isolate_class_dart_and_native.png" alt="Untitled" tabindex="0" loading="lazy"><figcaption>Untitled</figcaption></figure>
<h2> 简单使用</h2>
<h3> 创建新 Isolate 的方式：</h3>
<ul>
<li><code>Isolate(``SendPort controlPort``, {this.pauseCapability, this.terminateCapability});</code> 这种方式创建一种<strong>能力受限</strong>的 Isolate。The capabilities should be the subset of the capabilities that are available to the original isolate.本质上并没有在 native 层孵化一个新的 Isolate。</li>
</ul>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>Isolate.spawn(``void entryPoint(T message), T message,...)</code> 创建一个和当前 Isolate<strong>共享同一份代码</strong>的 Isolate，并执行 entryPoint 方法，一般在 message 中传入 SendPort 以便从 entryPoint 中向来时的 Isolate 发送消息，新建的 Isolate 和当前 Isolate 在同一个 IsolateGroup 中。</li>
</ul>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>Isolate.spawnUri（Uri uri,List&lt;String&gt; args,var message,...）</code>* 指定的<code>uri</code>中创建并孵化一个 isolate，执行 uri 对应的 library 中的<code>main</code>方法（0~2 个入参），并传入无参、args 或 message 作为参数</li>
</ul>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用方法</h3>
<h4> <strong>pause</strong></h4>
<p><code>Capability pause([Capability? resumeCapability])</code>，暂停 Isolate，停止从*<code>event loop queue</code>* 中取（并处理）消息，但是依然可以往里面加入消息</p>
<p><em><code>resumeCapability</code></em> 是用来区分 pause 的，必须使用同一个*<code>resumeCapability</code>*来 resume isolate。</p>
<ul>
<li>使用同一个*<code>resumeCapability</code>*多次<code>pause</code>，只需一次<code>resume</code>就可以恢复<code>isolate</code></li>
<li>使用不同*<code>resumeCapability</code><em>多次<code>pause</code>，必须使用对应的</em><code>resumeCapability</code><em>依次<code>resume</code>才可以恢复<code>isolate</code> （<strong>注意</strong>：这里也只需要使用当时 pause isolate 的</em><code>resumeCapability</code>* 依次调用 resume 即可，而不用保持次数一致，比如，有 2 个*<code>resumeCapability</code> ，*调用 pause 次数分别为 a 1,b 2，那么要想 resume isolate，也只需要分别使用 a,b 调用一次 resume 即可）</li>
</ul>
<h4> ping</h4>
<p>使用 isolate 往<code>receivePort.sendPort</code>发送 response 消息，<strong>即使 isolate 当前被 pause 也可以正常发送</strong></p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>ping 可以正常发送的原因是：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 MessageHandler 中有两种 MessageQueue：<code>oob_queue_</code>和<code>queue_</code> ，前者优先级高，即使 isolate 被 pause 也会执行</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>像是<code>ping</code>/<code>kill</code>/<code>pause</code>/<code>addOnExitListener</code>/<code>removeOnExitListener</code>这些指令消息都是压入到<code>obb_queue_</code>中优先处理的。</p>
<h2> 源码分析</h2>
<p>先看一下常用的几个方法是怎么实现的。</p>
<h3> 获取当前 Isolate</h3>
<p>（<em>sdk/lib/isolate/isolate.dart</em>）<code>Isolate.current</code> →</p>
<p>(<em>sdk/lib/_internal/vm/lib/isolate_patch.dart</em>) <code>Isolate get current</code> → <code>Isolate._getCurrentIsolate()</code> → <code>_getPortAndCapabilitiesOfCurrentIsolate()</code></p>
<p>（<em>runtime/lib/isolate.cc</em>）<code>DEFINE_NATIVE_ENTRY(Isolate_getPortAndCapabilitiesOfCurrentIsolate, 0, 0)</code></p>
<p>先看一下<em>sdk/lib/_internal/vm/lib/isolate_patch.dart</em>中的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，最后是根据 native 端返回的信息，新建了一个 Isolate 引用，但是因为<code>_currentIsolate</code>是<code>static final</code>的，所以只会被调用一次，确保了在 Dart SDK 中调用<code>Isolate.current</code> 时获取的是当前唯一的 Isolate。</p>
<p>让我们看一下在 native 中是如何找到当前的 Isolate 的：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见是直接取的<strong>当前线程对应的 isolate</strong>对应的值，经过包装再返回到调用方。</p>
<h3> 创建 Isolate</h3>
<p>在 Dart 中创建 Isolate 有 3 种方式：</p>
<ul>
<li><code>Isolate(this.controlPort, {this.pauseCapability, this.terminateCapability});</code> <strong>*create</strong> an* <em>isolate，本质上只是将</em><code>controlPort</code> 等设置为传入的对象，并没有在 native 层新建 Isolate</li>
<li><code>Isolate.spawn</code> <strong>create</strong> and <strong>spawns</strong> an <em>isolate</em></li>
<li><code>Isolate.spawnUri</code> <strong>create</strong> and <strong>spawns</strong> an <em>isolate</em></li>
</ul>
<figure><img src="https://jixiaoyong.github.io/images/Isolate_spawn_spawnuri.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这里分析一下后面两种方式，对比一下差异：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 APP 等来说，上述<code>Isolate.spawn</code>和<code>Isolate.spawnUri</code>的实现都在<code>vm</code>下面的<code>isolate_patch.dart</code>中（js 会返回<code>_unsupported()</code>）：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实，根据上述的代码，不管是<code>Isolate.spawnUri()</code> 还是<code>Isolate.spawn</code>，都是先调用<code>RawReceivePort</code>获取<code>RawReceivePort readyPort</code>，最后都是调用了<code>_spawnCommon(readyPort)</code> 方法，最终通过<code>new Isolate(controlPort, pauseCapability: capabilities[0], terminateCapability: capabilities[1])</code>方法创建了新的<code>Isolate</code> 。</p>
<p>这个方法的定义在<code>sdk/lib/isolate/isolate.dart</code>中：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在 Dart 中，我们拿到的 Isolate 主要是<strong>持有一个和 native 中对应 SendPort</strong>。</p>
<p>通过上面的分析：</p>
<ul>
<li><code>Isolate.spawn</code>最后调用了<code>_spawnFunction</code>方法（native 层实现为<code>Isolate_spawnFunction</code>）；</li>
<li><code>Isolate.spawnUri</code>最后调用了<code>_spawnUri</code>方法（native 层实现为<code>Isolate_spawnUri</code>）。</li>
</ul>
<blockquote>
<p>💡 <code>new RawReceivePort()</code>方法主要是创建一个不存在于<code>_RawReceivePortImpl</code>的<code>static final _portMap = &lt;int, Map&lt;String, dynamic&gt;&gt;{};</code> 中的 SendPort（具体实现在<code>PortMap::CreatePort</code>中）。</p>
</blockquote>
<h4> Isolate_spawnFunction</h4>
<p><code>Isolate.spawn</code>最后调用了<code>_spawnFunction</code>方法，来看一下对应的<code>Isolate_spawnFunction</code> 的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见，<code>Isolate_spawnFunction</code>方法中主要还是解析收到的各种参数，最后在当前 isolate 对应的 IsolateGroup 的线程池中执行<code>SpawnIsolateTask</code>：</p>
<h5> SpawnIsolateTask</h5>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> RunLightWeight</h5>
<p>因为这里我们的<code>isolate→group</code>不为空，所以走的是<code>RunLightWeight</code>:</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里主要进行了 2 步：</p>
<ul>
<li>使用<code>CreateWithinExistingIsolateGroup</code>创建 Isolate</li>
<li>使用全局的<code>initialize_callback</code> （也就是<code>Isolate::InitializeCallback()</code>）初始化 Isolate</li>
</ul>
<h6> Isolate::InitializeCallback()</h6>
<p>这其中的<code>Isolate::InitializeCallback()</code>是在<code>Dart::Init</code>的时候就已经设置了的：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，上文的<code>Isolate::InitializeCallback()</code>实际上就是<code>OnIsolateInitialize</code>，它的主要作用就是在 isolate 创建好之后进行统一的初始化操作，绑定一些数据：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> CreateWithinExistingIsolateGroup</h6>
<p><code>CreateWithinExistingIsolateGroup</code> → <code>CreateIsolate</code></p>
<p>再看一下创建 Isolate 的具体方法，这个在不同的 device 上面不一样，我们只关注 vm 下面的实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里主要有两步：</p>
<ul>
<li><code>Dart::CreateIsolate</code>创建了<code>Isolate* I</code>；</li>
<li>然后调用<code>Dart::InitializeIsolate</code>初始化 isolate。</li>
</ul>
<p><strong>Dart::CreateIsolate：</strong></p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>💡 在 Dart 虚拟机启动（<code>Dart::DartInit</code>）的时候，也会调用<code>Dart::InitIsolate</code>创建虚拟机对应的 Isolate，执行 UI 操作：<br>
<code>vm_isolate_ = Isolate::InitIsolate(kVmIsolateName, group, api_flags, is_vm_isolate);</code></p>
</blockquote>
<p>在<code>Isolate::InitIsolate</code>方法中，先是用<code>isolate_group</code>创建了新的 Isolate，然后将其与<code>Thread</code>，<code>MessageHandler</code>，<code>SendPort</code>等绑定：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Dart::InitializeIsolate</strong></p>
<p>这里主要是对 isolate 进行初始化，并在初始化完成后通知创建这个 isolate 的 isolate。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，如果是调用<code>Isolate.spawn()</code>的话，先从当前 isolate 获取对应的 Isolate Group，然后使用这个 Isolate Group 创建配置一个新的 isolate，这样在同一个 isolate group 中的 Isolate 可以共享常量，heap 等。</p>
<h4> Isolate_spawnUri</h4>
<p>如果是使用<code>Isolate.spawnUri()</code>的话，就会通过<code>Isolate_spawnUri</code>来创建 isolate。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到<code>Isolate_spawnUri</code>还是执行了<code>SpawnIsolateTask</code> 。</p>
<h5> SpawnIsolateTask</h5>
<p>在<code>SpawnIsolateTask.Run</code>方法中，因为<code>spawnUri</code>中<code>IsolateSpawnState</code>的<code>IsolateGroup</code>为<code>nulltrp</code>，所以这里执行的是<code>RunHeavyweight(name)</code>：</p>
<h5> RunHeavyweight</h5>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要创建 Isolate 的过程在<code>Isolate::CreateGroupCallback();</code>中，让我们看一下他是怎么来的：</p>
<h5> Isolate::CreateGroupCallback()</h5>
<p>他和上述<code>Isolate::InitializeCallback_</code>的来源一致，都是在<code>Dart_Initialize</code>中配置的，此外，还使用了<code>parent_isolate_-&gt;init_callback_data()</code>。</p>
<p>先看一下的<code>CreateIsolateGroupAndSetup</code>实现：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里创建 Isolate 的时候，区分了几种情况：</p>
<ul>
<li>如果是 kernel-service（<code>DART_KERNEL_ISOLATE_NAME</code>）就执行<code>CreateAndSetupKernelIsolate</code></li>
<li>如果是 dartdev（<code>DART_DEV_ISOLATE_NAME</code>）就执行<code>CreateAndSetupDartDevIsolate</code></li>
<li>如果是 vm-service（<code>DART_VM_SERVICE_ISOLATE_NAME</code>）就执行<code>CreateAndSetupServiceIsolate</code></li>
<li>如果以上都不满足，就执行<code>CreateIsolateGroupAndSetupHelper</code></li>
</ul>
<p>显然，当我们在 Dart 代码中调用<code>Isolate.spawnUri</code>的时候，这里会执行的是<code>CreateIsolateGroupAndSetupHelper</code>：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里可以看到，<code>CreateIsolateGroupAndSetupHelper</code>按照是 JIT 还是 AOT 的编译方式，有不同的获取数据的方式，但不管哪种方式，最后都执行了一下三步：</p>
<ul>
<li>创建<code>IsolateData* isolate_data</code> 使用<code>isolate_group_data</code>创建 IsolateData</li>
<li>创建<code>Dart_Isolate isolate</code> 创建<code>Dart_Isolate</code>，将<code>script_uri</code>，<code>isolate_data</code>，和<code>isolate_group_data</code>等绑定</li>
<li>创建并返回<code>Dart_Isolate created_isolate</code>包装<code>isolate</code> ，进行数据绑定，并将 isolate 标记为<code>runnable</code></li>
</ul>
<h6> Dart_CreateIsolateGroup</h6>
<p>这里分析一下**<code>Dart_CreateIsolateGroup</code>的过程：**</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Run(Isolate* child)</h4>
<p>在上面的分析中，我们注意到，无论是<code>RunHeavyweight(const char* name)</code>还是<code>RunLightweight(const char* name)</code>方法，最后在创建了新的 isolate 之后，都执行了<code>Run(Isolate* child)</code>方法，在这里正式启动了 isolate：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里只是做了一些环境准备，然后在<code>EnqueueEntrypointInvocationAndNotifySpawner</code>方法中将 isolate 要运行的所有东西都准备好，然后再在<code>Dart_RunLoopAsync</code>方法中正式开始 isolate 处理 event queue.</p>
<p><strong>EnqueueEntrypointInvocationAndNotifySpawner</strong></p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里主要做了 3 件事：</p>
<ul>
<li>查找 isolate 开始运行的第一个方法<code>entrypoint</code>，比如<code>Isolate.spawn</code>的<code>entrypoint</code>或者<code>Isolate.spawnUri</code>的<code>main</code>方法</li>
<li>解析参数，分别是 isolate 初始运行方法，参数<code>args</code>、<code>messgae</code>、是否<code>spawn_uri</code>等等，将其与上一步找到的<code>entrypoint</code>结合</li>
<li>（如果需要的话暂停创建好的 isolate），并通知 isolate 的父 isolate 当前 isolate 创建成功（附带当前 isolate 的<code>send_port</code>）</li>
</ul>
<p>至此，Isolate 的创建工作已经完成，在<code>Dart_RunLoopAsync</code>开始 isolate 处理消息：</p>
<p><strong>Dart_RunLoopAsync</strong></p>
<p>在这里主要是开始处理 event loop。</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Isolate::Run()</code>实际上是开启了处理消息队列：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里通过<code>ThreadPool::ScheduleTaskLocked</code>方法获取<code>new_worker</code>：</p>
<ul>
<li>如果已有的 worker 有空闲的或者已经达到最大数目了，就等待已有的 worker 执行任务</li>
<li>否则就创建新的 worker，并在新的线程运行</li>
</ul>
<p>在获取到 worker 之后，就执行<code>MessageHandlerTask</code>（见下文详细分析）。</p>
<p>我们主要关注 3 点：</p>
<ul>
<li><code>ScheduleTaskLocked</code> 分配 Worker</li>
<li><code>OSThread::Start</code>中使用<code>&amp;Worker::Main</code> 在新系统线程开启 Worker 循环</li>
<li><code>MessageHandlerTask</code> 执行具体的消息分发内容</li>
</ul>
<h5> <strong>ScheduleTaskLocked</strong></h5>
<p>先详细看一下获取<code>new_worker</code>的<code>ThreadPool::ScheduleTaskLocked</code>方法：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的逻辑是：</p>
<p>将当前任务加入到<code>tasks_</code>队列中。</p>
<ul>
<li>如果空闲<code>count_idle_</code> 的 Worker 比等待中的任务数<code>pending_tasks_</code>多，那就发送通知，使用已有的 Worker 处理任务。</li>
<li>如果当前 Worker 数量已经最大了，那就将等待中的任务数 pending<em>tasks</em> 加一，等待有空闲的 Worker 处理任务。</li>
<li>否则，就新建一个 Worker（会对应创建一个新的系统线程）来处理任务。</li>
</ul>
<h5> &amp;<strong>Worker::Main</strong></h5>
<p>在<code>ThreadPool::RunImpl(std::unique_ptr&lt;Task&gt; task)</code>这里，StartThread 的第二个参数，**<code>&amp;Worker::Main</code>**启动了一个循环，不断的在任务队列<code>tasks_</code>中取出消息并执行：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>MessageHandlerTask</strong></p>
<p>无论是哪种 Worker，最后都是执行的<code>MessageHandlerTask</code>：</p>
<div class="language-cpp line-numbers-mode" data-ext="cpp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，这里执行了<code>MessageHandler::HandleMessages</code>方法，来处理消息：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>MessageHandler::DequeueMessage</code>则是按照优先级，依次从<code>oob_queue_</code>和<code>queue_</code>中获取消息：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于<code>oob_queue_</code>和<code>queue_</code> 的区别如下：</p>
<div class="language-jsx line-numbers-mode" data-ext="jsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里消息处理的步骤也启动了。</p>
<p>总结一下，<code>Dart_RunLoopAsync</code>的主要功能是触发 isolate 的<code>message_handler</code>处理消息分发：</p>
<p><code>Dart_RunLoopAsync</code> → <code>Isolate::Run()</code> → <code>message_handler()-&gt;Run()</code> → <strong>pool_-&gt;</strong><code>Run&lt;MessageHandlerTask&gt;</code> <strong>→</strong> <code>ThreadPool::RunImpl</code></p>
<p>在<code>ThreadPool::RunImpl(std::unique_ptr&lt;Task&gt; task)</code>这里主要触发了 2 步：</p>
<ul>
<li><code>ScheduleTaskLocked</code>获取到<code>new_worker</code></li>
<li><code>new_worker</code>调用<code>ThreadPool::Worker::StartThread()</code>方法开启循环</li>
</ul>
<p>然后根据是否创建了<code>new_worker</code>有两种情况：</p>
<ul>
<li>有<code>new_worker</code>，使用在<code>OSThread::Start</code>方法中创建了一个新的系统线程，执行<code>ThreadPool::Worker::Main</code>（这个方法的主要作用使用<code>new_worker</code>从线程池中的取出任务执行）</li>
<li>没有<code>new_worker</code>，那么等待已有的 Worker 空闲时执行任务</li>
</ul>
<p>无论如何，这里的 Worker 要执行的任务都是在<code>MessageHandler::Run</code>方法中指定的<code>MessageHandlerTask</code> ，而这个任务的内容便是开启<code>MessageHandler::HandleMessages</code> 方法，按照优先级不断的依次从<code>oob_queue_</code>和<code>queue_</code>中获取消息并处理。</p>
<h2> 总结</h2>
<figure><img src="https://jixiaoyong.github.io/images/Isolate_spawn_spawnuri_dart_and_native.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Isolate 是 Dart 代码运行的地方，拥有独立的 event loop，和全局变量，在自己单独的线程运行。</p>
<p>Isolate.spawn 默认会创建在同一个 IsolateGroup 中的 Isolate，他们之间共享 Heap（这里会发生 GC）和一个线程池。</p>
<p>Isolate.spawnUri 会从制定的 Uri 中创建一个新的 IsolateGroup 和对应的 Isolate，并执行 Uri 中的 main 方法。</p>
<p>Isolate 内部维持一个 Event Loop。</p>
]]></content:encoded>
      <enclosure url="https://www.youtube.com/watch?v=NoVYI94MJio&amp;ab_channel=Flutterly" type="image/"/>
    </item>
    <item>
      <title>Dart VM</title>
      <link>https://jixiaoyong.github.io/blog/posts/550e5790.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/550e5790.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Dart VM</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 02 Jun 2022 07:18:57 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文是对 Dart 官方 VM 的介绍的总结摘要，推荐直接阅读<a href="https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md" target="_blank" rel="noopener noreferrer">官方原文</a>。</p>
</blockquote>
<p>Dart VM is a collection of components for executing Dart code natively. Notably, it includes the following:</p>
<ul>
<li><strong>Runtime System</strong>
<ul>
<li>Object Model</li>
<li>Garbage Collection</li>
<li>Snapshots</li>
</ul>
</li>
<li><strong>Core libraries’ native methods</strong></li>
<li><strong>Development Experience components</strong> accessible via&nbsp;<em>service protocol</em>&nbsp;* Debugging * Profiling * Hot-reload</li>
<li><strong>Just-in-Time (JIT) and Ahead-of-Time (AOT) compilation pipelines</strong></li>
<li><strong>Interpreter</strong></li>
<li><strong>ARM simulators</strong></li>
</ul>
<p>下图是 runtime 执行代码的示意图：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/isolates.png" alt="isolate" tabindex="0" loading="lazy"><figcaption>isolate</figcaption></figure>
<p>isolate 中有两种 Thread：</p>
<ul>
<li>一个 mutator thread 用来执行 dart 代码</li>
<li>多个 helper thread 用来执行 GC、JIT 等</li>
</ul>
<p>此外，一个 isolate 有一个 heap，用来存储所有的 dart object（GC 发生在这里）。</p>
<p>一个 OSThread 一次只能进入一个 isolate，当其进入之后，该 isolate 的 mutator thread 便和这个 OSThread 关联起来执行 dart 代码。当 OSThread 要进入一个 isolate 的时候，必须先退出当前关联的 isolate。</p>
<p>isolate 的 mutator thread 可能在不同时间关联不同的 OSThread，但同一时刻最多只能有一个 OSThread。</p>
<p>VM 执行 Dart 代码有两种方式：JIT 和 AOT，不管哪一种都不会直接执行 Dart 源码，而是经过转化之后的 Kernel Binary(also called&nbsp;<em>dill files</em>)which contain serialized&nbsp;<a href="https://github.com/dart-lang/sdk/blob/main/pkg/kernel/README.md" target="_blank" rel="noopener noreferrer">Kernel ASTs</a>。</p>
<p>一般来说，从 Dart source code 到 Dart VM 执行分为下面几步：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/dart-to-kernel.png" alt="dart-to-kernel" tabindex="0" loading="lazy"><figcaption>dart-to-kernel</figcaption></figure>
<blockquote>
<p>VM expects to be given&nbsp;<strong><em>Kernel binaries</em></strong>&nbsp;(also called&nbsp;<em>dill files</em>) which contain serialized&nbsp;<a href="https://github.com/dart-lang/sdk/blob/main/pkg/kernel/README.md" target="_blank" rel="noopener noreferrer">Kernel ASTs</a>. The task of translating <strong>Dart source</strong> into <strong>Kernel AST</strong> is handled by the&nbsp;<a href="https://github.com/dart-lang/sdk/tree/master/pkg/front_end" target="_blank" rel="noopener noreferrer">common front-end (<strong>CFE</strong>)</a> written in Dart and shared between different Dart tools (e.g. VM, dart2js, Dart Dev Compiler).</p>
</blockquote>
<p>Dart VM has multiple ways to execute the code, for example:</p>
<ul>
<li>from source or Kernel binary using <strong>JIT</strong>;</li>
<li>from snapshots:
<ul>
<li>from <strong>AOT</strong> snapshot;</li>
<li>from <strong>AppJIT</strong> snapshot.</li>
</ul>
</li>
</ul>
<h2> 1. Running from source via JIT.</h2>
<h3> 从 Dart Source 加载到 VM 中</h3>
<p>为了保证直接从源代码执行 Dart 的便利性，独立的 dart 可执行文件承载了一个称为内核服务（*kernel service）*的辅助 isolate，它处理 Dart 源代码编译成内核的过程。然后，VM 将运行产生的内核二进制文件（Kernel Binary）。</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-service.png" alt="kernel-service" tabindex="0" loading="lazy"><figcaption>kernel-service</figcaption></figure>
<p>上图中，一个被称为<em>kernel service</em>的 isolate 使用 CFE 将 Dart Source 编译为为<em>Kernel Binary</em>然后交给 main isolate 执行。</p>
<p>这并不是安排 CFE 和 VM 执行 Dart Source 的唯一方式，比如 Flutter 就将 CFE（封装之后的）和 VM 分别置于两个设备上：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/flutter-cfe.png" alt="flutter-cfe" tabindex="0" loading="lazy"><figcaption>flutter-cfe</figcaption></figure>
<p>当热更新触发时，Flutter 使用封装过的 CFE 以及一个 Flutter 独有的 Kernel-to-Kernel 转换，将修改过的 Dart Source 编译为 Kernel Binary，然后推送到设备上面（比如手机）执行。</p>
<h3> 在 VM 中执行</h3>
<p>上面是 Dart Source 加载到 VM 的过程，下面是<strong>Dart 代码在 VM 中执行的过程</strong>分析：</p>
<p>1）当<em>Kernel Binary</em>加载到 VM 中之后，只会解析加载的类和库的基本信息。</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-1.png" alt="kernel-loaded-1" tabindex="0" loading="lazy"><figcaption>kernel-loaded-1</figcaption></figure>
<p>2）当 runtime 实际用到的时候才会去获取完整的信息用来创建对象分配内存等：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/kernel-loaded-2.png" alt="kernel-loaded-2" tabindex="0" loading="lazy"><figcaption>kernel-loaded-2</figcaption></figure>
<p>此时，从<em>Kernel Binary</em>中读取出了<em>class members</em>，此时已经有足够的信息让 runtime 用来调用方法（successfully resolve and invoke methods）了，比如调用 main 方法，但是<strong>具体的方法体此时依旧还没有被反序列</strong>（deserialized）。</p>
<p>3）在这个阶段，所有的 function 只是持有了一个真正要执行的方法体的<em>placeholder</em>指向<em>LazyCompileStub</em>，当 runtime 要执行的时候再创建并运行可执行代码。</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/raw-function-lazy-compile.png" alt="raw-function-lazy-compile" tabindex="0" loading="lazy"><figcaption>raw-function-lazy-compile</figcaption></figure>
<p>这时候执行方法有两个阶段：</p>
<ol>
<li><strong>unoptimized</strong> 默认执行时直接从<em>Kernel Binary</em>创建<em>IL</em>然后转化为<em>machine code</em>并运行</li>
<li><strong>optimized</strong> 在 a 阶段的热点代码会被从普通<em>IL</em>优化为<em>SSA IL</em>，然后转化为<em>machine code</em>运行，如果遇到优化失效的，再回退到 a 阶段执行代码（后面是否需要再走 b 阶段，需要重新判断）</li>
</ol>
<h4> unoptimized code</h4>
<p>这个阶段，从<em>Kernel Binary</em>生成<em>Machine Code</em>主要分为 2 步：</p>
<p><strong>（1）<em>Kernel Binary</em> → <em>IL</em></strong></p>
<p>在这个阶段，从<em>Kernel Binary</em>中的<em>AST</em>中解析产生对应的<em>control flow graph</em>(<strong>CFG</strong>)。</p>
<blockquote>
<p>CFG 由<em>intermediate language</em>(<strong>IL</strong>) 组成，这个阶段使用的 IL 指令类似基于 stack 的虚拟机：他们从 stack 中读取操作数，执行操作，然后将结果 push 回这个 stack 中。</p>
</blockquote>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/unoptimized-compilation.png" alt="unoptimized-compilation" tabindex="0" loading="lazy"><figcaption>unoptimized-compilation</figcaption></figure>
<p>但并不是所有的方法都有对应的<em>Dart/Kernel AST bodies</em>（比如一些<em>native</em>方法或者<em>artificial tear-off functions</em> generated by Dart VM），这种情况下，他们凭空创建（<em>in these cases IL is just created from the thin air</em>）。</p>
<p><strong>(2) <em>IL</em> → <em>Machine Code</em></strong></p>
<p>由一条 IL 对应生成多行 machine language instruction</p>
<p>在这个阶段不会进行优化，主要目的是快速创建出可执行代码（<em>produce executable code quickly</em>）</p>
<p><strong>内联缓存（inline caching）</strong></p>
<p>在这个阶段，编译器（<em>unoptimizing compiler</em>）不会尝试静态解析任何没有在 Kernel Binary 中解析的调用（<em>any calls that were not resolved in Kernel binary</em>），因此调用 (<code>MethodInvocation</code> or&nbsp;<code>PropertyGet</code> AST nodes) 被认为是完全动态的，VM 使用内联缓存（inline caching）来实现动态调用。</p>
<p>内联缓存的实现主要有：</p>
<ul>
<li>一个<strong>call site specific cache</strong>，将调用的类与方法映射在一起，如果 receiver 和已有的缓存类对应，那么就应该调用对应的方法，还有个计数器（<em>invocation frequency counters</em>）标记这个方法被调用多少次（对应下文的 RawICData）</li>
<li>一个共享的<strong>lookup stub</strong>，实现了方法调用的最快路径（<em>method invocation fast path</em>），在发生调用时通过 lookup stub 查询是否有 entry 与 receiver 的类匹配，有的话就用调用 entry 并增加 frequency counter；否则就调用系统的 runtime system helper 兜底（如果成功运行了就更新上面的缓存，这样下次调用就不用再走 runtime 了）。</li>
</ul>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/inline-cache-1.png" alt="inline-cache-1" tabindex="0" loading="lazy"><figcaption>inline-cache-1</figcaption></figure>
<aside>
💡 **Unoptimizing compiler** by itself is enough to execute any possible Dart code.</aside>
<h4> optimized code</h4>
<p>虽然<strong>Unoptimizing compiler</strong>可以执行任意 Dart 代码，但是太慢了，所以在以上述方式执行代码的同时会记录以下信息：</p>
<ul>
<li>Inline cache 收集在调用点的<strong>receiver 类型</strong>（<em>receiver types observed at callsites</em>）</li>
<li>和方法对应的 execution counters 以及 basic blocks within functions 追踪代码的<strong>热点区域</strong>（hot regions of the code）</li>
</ul>
<p>Optimized compilations 和 Unoptimizing compiler 开始的步骤类似：</p>
<p><strong>(1) <em>Kernel Binary</em> → <em>unoptimized IL</em></strong></p>
<p><strong>(2) <em>unoptimized IL</em> → <em>SSA based IL</em> → <em>optimized IL</em></strong></p>
<p>当上述代码执行的时候，如果程序调用计数器（<em>invocation frequency counters</em>）到达某个阈值，这个方法就会被交给一个后台优化编译器（<em>background optimizing compiler</em>）来优化，将 unoptimized IL 转化为*SSA（static single assignment）*形式的 IL。</p>
<p>最后将 SSA IL 优化为 optimized IL。</p>
<p><strong>(3) <em>optimized IL</em> → <em>machine code</em></strong></p>
<p>在优化完成后，编译器会要求 mutator thread 进入 safepoint 并将优化后的代码绑定到方法上（attaches optimized code to the function）。</p>
<blockquote>
<p>safepoint 的含义是，thread 关联的 state（比如 heap，stack frame 等）是一致的，并且可以在不中断线程的情况下访问或修改。通常意味着 thread 被暂停，或者在当前环境外（比如执行 native 代码）。</p>
</blockquote>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/optimizing-compilation.png" alt="optimizing-compilation" tabindex="0" loading="lazy"><figcaption>optimizing-compilation</figcaption></figure>
<p>上述这种基于乐观假设的优化，可能没法处理部分情况，从而回退到未优化的代码（deoptimization），然后再执行未优化过程（通常会丢弃优化后的代码，再判断是否有热点代码需要优化），主要有 2 种方式：</p>
<ol>
<li><strong><em>eager deoptimization</em></strong> 在内联检查的时候，判断优化的条件是否满足，不满足的话就丢弃优化代码</li>
<li><strong><em>lazy deoptimization</em></strong> 全局分析指示在更改优化代码的内容时丢弃优化代码（之前优化的条件不满足了）。</li>
</ol>
<h2> 2. Running from <strong>AOT</strong> snapshot</h2>
<p>Snapshot's format is low level and optimized for fast startup，包含了要创建的 object 以及如何关联这些对象的说明信息（instructions）。</p>
<p>VM 可以将 Heap/甚至是 Heap 中的 object graph 序列化成为 snapshot，然后再从这个 snapshot 中重建对应的状态：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot.png" alt="snapshot" tabindex="0" loading="lazy"><figcaption>snapshot</figcaption></figure>
<p>最初的 snapshot 并不包含 machine code，直到 AOT compiler 的出现。</p>
<p>AOT compiler 和 snapshot-with-code 使得 VM 可以在那些 JIT 受限的设备上运行：</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot-with-code.png" alt="snapshot-with-code" tabindex="0" loading="lazy"><figcaption>snapshot-with-code</figcaption></figure>
<p><strong>snapshot-with-code</strong>和普通的<strong>snapshot</strong>基本一致，<strong>唯一不同的是多出的 machine code 不需要 deserizlization</strong>，事实上 machine code 在被分配到内存后可以立即成为 heap 的一部分（<em>directly become part of the heap after it was mapped into memory</em>）。</p>
<h2> 3. Running from <strong>AppJIT</strong> snapshot</h2>
<p><strong>AppJIT</strong> snapshot 主要用于减少大型 Dart application 的 JIT 热身时间。</p>
<p>AppJIT snapshots were introduced to <strong>reduce JIT warm up time for large Dart applications</strong> like&nbsp;<code>dartanalyzer</code>or&nbsp;<code>dart2js</code>. When these tools are used on small projects they spent as much time doing actual work as VM spends JIT compiling these apps.</p>
<p>他的主要实现是：先用模拟数据在 VM 上运行，然后将其生成的 code 以及 VM 内部的数据结构序列化为 AppJIT snapshot 加载到 VM 中运行，只在正式的数据和模拟训练的配置无法匹配的时候执行 JIT（<em>execution profile on the real data does not match execution profile observed during training</em>）。</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/snapshot-appjit.png" alt="snapshot-appjit" tabindex="0" loading="lazy"><figcaption>snapshot-appjit</figcaption></figure>
<h2> 4. Running from <strong>AppAOT</strong> snapshot</h2>
<p>AOT 与 JIT 各有优劣：</p>
<ul>
<li>AOT 启动时间更短</li>
<li>JIT 峰值性能更优</li>
</ul>
<p>无法进行 JIT 意味着</p>
<ol>
<li>AOT snapshot&nbsp;<em>must</em>&nbsp;contain executable code for each and every function that could be invoked during application execution;</li>
<li>the executable code&nbsp;<em>must not</em>&nbsp;rely on any speculative assumptions that could be violated during execution;</li>
</ol>
<p>为了满足上述要求，AOT 汇编过程会进行全局静态分析以确定程序的哪些部分是可以从已知的 entry point 触达的，分配哪些类的实例，以及类型在程序中是如何应用的（which parts of the application are reachable from known set of&nbsp;<em>entry points</em>, instances of which classes are allocated and how types flow through the program）。</p>
<p>AOT 上述这些分析是保守的，可能在准确性上犯错，与之相比，JIT 则在性能方面不行，因为 JIT 需要 deoptimize 兜底实现正确的行为。</p>
<p>所以 AOT 将所有潜在的可触达的功能编译为 native code，而无需投机性优化（All potentially reachable functions are then compiled to native code without any speculative optimizations）。</p>
<figure><img src="https://jixiaoyong.github.io/images/dart_vm/aot.png" alt="aot" tabindex="0" loading="lazy"><figcaption>aot</figcaption></figure>
<p>从上图可以看出，AOT 中，Kernel Binary 先经过 TFA 收集变量、方法等信息，以此来<strong>移除不可达的方法</strong>，并 devirtuablize method（确定<a href="https://www.techopedia.com/definition/24299/virtual-method#:~:text=A%20virtual%20method%20is%20a,oriented%20language%2C%20such%20as%20C%23." target="_blank" rel="noopener noreferrer">虚拟方法</a>的具体执行）。之后经过 VM 再移除一些不可达方法。</p>
<p>Resulting snapshot can then be run using&nbsp;<em>precompiled runtime</em>, a special variant of the Dart VM which excludes components like JIT and dynamic code loading facilities.</p>
<h3> Switchable Calls</h3>
<p>即使有全局和局部分析，AOT 编译依然可能包含一些无法被非虚拟化（<em>devirtualized</em>）的 call sites，为了解决这个问题，AOT 编译出的代码和 runtime 会使用 JIT 中用到的内联缓存（<em>Inline Caching</em>）技术的拓展——<strong><em>switchable calls</em></strong>。</p>
<h2> 参考资料</h2>
<p><a href="https://github.com/dart-lang/sdk/blob/main/runtime/docs/index.md" target="_blank" rel="noopener noreferrer">sdk/index.md at main · dart-lang/sdk</a></p>
<p><a href="https://www.jianshu.com/p/a5b1997a01ba" target="_blank" rel="noopener noreferrer">Dart VM 介绍</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/dart_vm/isolates.png" type="image/png"/>
    </item>
    <item>
      <title>之前发布的几个 App</title>
      <link>https://jixiaoyong.github.io/blog/posts/1a589649.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/1a589649.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">之前发布的几个 App</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 08 Jan 2018 14:35:34 GMT</pubDate>
      <content:encoded><![CDATA[<p>在之前学习 android 的过程中，跟着教程做了几个 app，虽然随着使用的 api 的失效，大多数应用如今已经不能正常使用了，但是作为初入编程的一点点小纪念，还是为他们写一个索引文章，至少能够晚一些消寂于这广阔的数据海洋中。</p>
<h2> <a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/" target="_blank" rel="noopener noreferrer">NiceNews</a></h2>
<p>Posted on 2016-05-30</p>
<p>NieceNews 我制作的第二款 APP，一个实时新闻软件。</p>
<figure><img src="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/images/icon.png" alt="NiceNews" tabindex="0" loading="lazy"><figcaption>NiceNews</figcaption></figure>
<h2> <a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/IWeather/" target="_blank" rel="noopener noreferrer">IWeather</a></h2>
<p>Posted on 2016-07-16</p>
<p>IWeather，我的第三个 Android 应用，一个天气预报 APP。</p>
<figure><img src="http://jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/IWeather/images/1.png" alt="IWeather" tabindex="0" loading="lazy"><figcaption>IWeather</figcaption></figure>
<h2> <a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/2048/" target="_blank" rel="noopener noreferrer">2048</a></h2>
<p>Posted on 2016-07-21</p>
<p>2048，我的第四个 Android 应用，同时也是我的第一款游戏 APP。</p>
<figure><img src="http://jixiaoyong.github.io/blogbackup/blog_2016To2017/2016/07/2048/images/1.png" alt="2048" tabindex="0" loading="lazy"><figcaption>2048</figcaption></figure>
<h2> <a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/I%E7%9C%8B%E7%9F%A5%E4%B9%8E/" target="_blank" rel="noopener noreferrer">I 看知乎</a></h2>
<p>Posted on 2016-07-24 |</p>
<p>i 看知乎，我的第五个 Android 应用。</p>
<figure><img src="http://jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/I看知乎/images/1.png" alt="logo" tabindex="0" loading="lazy"><figcaption>logo</figcaption></figure>
<p>学习的过程需要不断的重复，更需要有条理的总结，我会把平时学习的心得体会，经验，以及无聊时瞎琢磨得出来的稀奇古怪的想法放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。</p>
]]></content:encoded>
      <enclosure url="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/images/icon.png" type="image/png"/>
    </item>
    <item>
      <title>从 Sunflower 开始学习优雅的 Jetpack 架构</title>
      <link>https://jixiaoyong.github.io/blog/posts/27065732.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/27065732.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">从 Sunflower 开始学习优雅的 Jetpack 架构</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 24 Jan 2019 11:48:31 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Google 大法 NB！！！(破音)</p>
</blockquote>
<h2> 前言</h2>
<p><a href="https://developer.android.google.cn/jetpack/" target="_blank" rel="noopener noreferrer">Jetpack</a>是 Google 推出的一系列 Android 软件集合，<em>"使您可以更轻松地开发出色的 Android 应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上"</em>。</p>
<p><a href="https://github.com/googlesamples/android-sunflower" target="_blank" rel="noopener noreferrer">Sunflower</a>则是 Google 用来演示如何使用 Jetpack 进行 Android 开发的 Demo，有着非常优雅的架构与十分简洁的代码，可以帮助我们很好地学习 Jetpack 以及 MVVM 思想。</p>
<p>本文主要是结合 Sunflower 中的示例代码，分析 Jetpack 架构中各部分的作用，以及他们如何巧妙的搭配使用，方便指导日后对 Jetpack 的使用。</p>
<blockquote>
<p>本文中的大部分代码、示意图除非特殊注明外，皆来自 Google 的<a href="https://github.com/googlesamples/android-sunflower" target="_blank" rel="noopener noreferrer">Sunflower 工程</a>或其他互联网资源，根据篇幅需要做了部分精简，所有权益归原作者所有。</p>
</blockquote>
<p>下图是<a href="https://developer.android.google.cn/jetpack/" target="_blank" rel="noopener noreferrer">Google Jetpack 官网</a>对 Jetpack 的介绍图：</p>

## 对 Sunflower 的整体分析
<p>下图是 Sunflower 架构的简单示意图：</p>
<figure><img src="https://jixiaoyong.github.io/images/20190124212220.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到，APP 的界面有<code>我的花园</code>、<code>植物目录</code>和<code>植物介绍</code>三部分，这三者的切换逻辑通过实现。</p>
<p>每个界面的<strong>XML</strong>中的布局信息（包括<code>数据、事件（clickListener等），RecycleView的LayoutManager，Adapter等等</code>）通过<strong>DataBinding</strong>与<strong>ViewModel</strong>中的可观察数据<strong>LiveData</strong>绑定在一起，只要数据库中的<code>数据</code>有更新，就会通过<code>LiveData</code>主动通知布局更新界面；同时<code>DataBinding</code>还通过与<code>Adapter</code>（这些继承自<strong>ListAdapter</strong>的 Adapter 实现了的作用）将<code>ItemView</code>的<code>ViewModel</code>与布局<code>XML</code>中绑定在一起，通过<code>BindingAdapter</code>对<code>XML</code>中的数据做预处理（加载 imgUrl 中的图片到 ImageView 等等）。</p>
<p>在中指定这些<code>DataBinding</code>与之间以及<code>ViewModel</code>与<code>数据库</code>之间的逻辑关系，这些数据与操作都受着的影响。</p>
<p><code>ViewModel</code>的数据来源——<code>Model</code>在这里的实现是一个<code>数据库</code>。每个<code>ViewModel</code>有一个<code>XXXViewModelFactory</code>类，用来使用数据类<code>XXXRepository</code>类的实例创建对应的<code>ViewModel</code>。<code>XXXViewModelFactory</code>向<code>Activity</code>等屏蔽了<code>ViewModel</code>的具体实现。</p>
<p><code>XXXRepository</code>类的出现时为了将<code>ViewModel</code>与数据的具体实现解耦合，这样<code>ViewModel</code>只需要关心他要的操作而不必关系数据来源的具体实现。在本例中，<code>XXXRepository</code>类对应封装了这数据库<code>AppDatabase</code>中对两个表的操作。</p>
<p>数据库使用实现，从底层开始依次分为<code>表Entity</code>，<code>数据访问对象DAO</code>和<code>数据库DataBase</code>三个层次。每个 DAO 对应一个包装类<code>XXXRepository</code>类供<code>ViewModel</code>使用。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>则管理着一个从 Json 读取数据并加载到数据库中的后台任务<code>SeedDatabaseWorker</code>。<h2> 具体实现分析</h2>
<p>首先看一下**<code>View</code>**部分，Sunflower 只有简单的 3 个页面，全都是用<code>Fragment</code>实现，由<code>Activity</code>通过<code>Navigation</code>控制切换：</p>
<ul>
<li><code>GardenActivity</code> 主页面，唯一的一个 Activity</li>
<li><code>GardenFragment</code> 我的花园 界面，会显示用户在植物目录中选择并种植的植物信息</li>
<li><code>PlantListFragment</code> 植物目录 界面，所有的植物信息列表</li>
<li><code>PlantDetailFragment</code> 植物介绍 界面，当在“我的花园”或“植物列表”选择了某个植物后，会进入该界面显示植物详细介绍</li>
</ul>
<h3> Navigation 控制界面切换</h3>
<p>先看一下<a href="https://developer.android.google.cn/topic/libraries/architecture/navigation/" target="_blank" rel="noopener noreferrer">Navigation</a>的定义：</p>
<blockquote>
<p>Navigation 是 APP 设计中的关键部分，可以用来定义用户从不同的界面切换、进入和推出的交互逻辑。</p>
</blockquote>
<p>和布局文件一样，我们可以在编译器的可视化界面中，直接预览、设计不同界面切换效果。他可以负责<code>Fragment</code>、<code>Activity</code>、<code>Navigation graphs</code> 与 <code>subgraphs</code> 以及<code>Custom destination types</code>，他们之间通过不同的<code>action</code>连接起来。</p>
<p>通过官方文档可知，<code>Navigation</code>可以和<code>AppBar</code>，<code>ToolBar</code>等组合起来控制 Fragment 显示，此外可以通过<code>ViewModel</code>在绑定到同一个<code>Activity</code>的<code>Fragment</code>之间共享数据，或者也可以通过<a href="https://developer.android.google.cn/topic/libraries/architecture/navigation/navigation-pass-data" target="_blank" rel="noopener noreferrer"><code>Bundle</code>或<code>Safe Args</code></a>在两个<code>Fragment</code>之间传递数据。</p>
<p>那么，在<code>Sunflower</code>中<code>Navigation</code>是怎么控制界面切换的呢？</p>
<p>首先，在<code>res/navigation/</code>目录下面新建一个<code>嵌套导航图(Nested navigation graphs)</code>,定义各个界面之前的切换关系：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在 Activity 对应的 XML 中插入该导航：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后就可以在 Activity 或者 Fragment 中获取该导航的实力，用来切换界面了：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> DataBinding 绑定布局和数据</h3>
<p>Navigation 解决了不同的布局间交互的逻辑，DataBinding 则充当布局 View 和数据（ViewModel、LiveData）之间的桥梁，将二者联系起来。</p>
<p>从<a href="https://developer.android.google.cn/topic/libraries/data-binding/" target="_blank" rel="noopener noreferrer">官网</a>的表述中我们知道，DataBinding 使用在 XML 中声明的方式（而非编程的方式），将布局中的组件捆绑到 APP 中使用到的数据上，这样当数据更新时，布局也会随之自动更新。</p>
<p>DataBinding 在 XML 中的形式如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是原先的页面布局信息<code>&lt;ConstraintLayout... /&gt;</code>包裹在<code>&lt;layout... /&gt;</code>中，同时多了一个数据域<code>&lt;data... /&gt;</code>，我们可以在其中定义一些变量<code>&lt;variable... /&gt;</code>，并在布局中使用：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除了常见的<code>android:text</code>，<code>android:onClick</code>等通用的属性可以直接绑定外，我们还可以通过自定义<a href="https://developer.android.google.cn/topic/libraries/data-binding/binding-adapters.html" target="_blank" rel="noopener noreferrer"><strong>Binding adapters</strong></a>支持更多形式的属性绑定：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码就支持了<code>app:goneUnless</code>的解析，我们只要在 XML 中为组件加上这个属性就可以实现相应的效果：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，我们需要在对应的 Activity 或 Fragment 中，用如下代码将布局与页面绑定到一起：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>ActivityMainBinding</code>类是<code>DataBinding</code>根据 XML 文件的名字自动替我们生成的，规律是<code>XML文件名+Binding</code>的驼峰命名。</p>
<p>在 Sunflower 中有类似的应用有很多处：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> ViewModel 管理数据与页面的交互</h3>
<p><code>DataBinding</code>通过标记的形式将数据和组件绑定，在这个过程中他使用的数据则是来自于<code>ViewModel</code>的。在页面<code>Activity</code>(或<code>Fragment</code>) 中，我们可以处理这两者之间的关系。</p>
<p><code>ViewModel</code>是设计用来以一种可以感知生命周期（<code>lifecycle</code>）的方式存储和管理与 UI 相关的数据，它可以允许数据在诸如屏幕旋转的变化中存活下来，也就是说<code>VideModule</code>的数据生命周期可能要比他附着的<code>Activity</code>或<code>Fragment</code>的生命周期长。</p>
<p>同时，<code>UI controller</code>可以在<code>Activity</code>等不再需要数据时，自动调用<code>ViewModel</code>的<code>onCleared()</code>方法清除这些数据以避免内存泄漏。</p>
<p>下图是<code>ViewModel</code>和<code>Activity</code>的生命周期对比：</p>

此外，由于默认的获取 ViewModel 的方法只能调取无参构造函数，当需要向 ViewModel 传递参数时，就需要用到 Factory 工厂模式来创建 ViewModel：
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以将<code>ViewModel</code>于<code>LiveData</code>结合，这样在<code>Activity</code>等地方对<code>LiveData</code>进行订阅后，当<code>LiveData</code>的值发生变化时<code>Activity</code>等可以及时得到通知，而做出相应变化。此外<code>ViewModel</code>与<code>lifecycle</code>的结合可以保证在<code>Activity</code>等生命周期结束后数据得到及时的清理。</p>
<h3> Room 保存数据</h3>
<blockquote>
<p>Room 持久性库在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 强大功能的同时，能够流畅的访问数据库。——Android Developers</p>
</blockquote>
<p><code>Room</code>需要 3 个元素：</p>
<ul>
<li><code>Database</code> 数据库，可以提供对表格的操作方法<code>@DAO</code>。是一个继承自<code>RoomDatabase</code>的抽象类。</li>
<li><code>Entity</code> 表格，规定了每个表格可以保存的数据格式。是一个普通类。</li>
<li><code>Dao</code> 数据访问结构（<code>Data Access Object</code>），定义了对表格<code>@Entity</code>中的数据的操作。是一个接口或者抽象类。</li>
</ul>
<p>此外，还可以对<code>@DAO</code>进行进一步的封装得到一个<code>XXXRepository</code>类，<code>ViewModel</code>通过这个<code>XXXRepository</code>类来操作数据，从而将其与数据的具体实现解耦。</p>
<h3> WorkManager 管理任务</h3>
<p><code>WorkManager</code>用来管理即时或定时任务，官方定义是在指定约束条件成熟时可靠的在后台执行对应的任务。</p>
<p>具体使用可以参考这个<a href="https://gist.github.com/jixiaoyong/041d8b0775e392302b4cd57a98b4f6fa" target="_blank" rel="noopener noreferrer">GIST</a>。</p>
<p>和他相关的有下面几个关键类：</p>
<ul>
<li><code>Worker</code> 定义要执行的任务内容</li>
<li><code>WorkRequest</code> 代表一项单独的任务，明确具体要执行的任务内容（Worker）、任务的类型（WorkRequest.Builder 的子类，决定任务一次性还是重复的）以及任务执行的条件（Constraints，如联网、电池电量等等）</li>
<li>WorkManager 执行管理 WorkRequest，安排执行 Worker 中的工作内容。</li>
</ul>
<h2> 参考资料</h2>
<p><a href="https://developer.android.google.cn/jetpack/" target="_blank" rel="noopener noreferrer">Android Jetpack 官网</a></p>
<p><a href="https://blog.csdn.net/weixin_42215792/article/details/80395379" target="_blank" rel="noopener noreferrer">Android Jetpack-Navigation 使用中参数的传递</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20190124212220.png" type="image/png"/>
    </item>
    <item>
      <title>利用 travis 通过 Hexo 在 Github 上自动部署 Markdown 文档</title>
      <link>https://jixiaoyong.github.io/blog/posts/b00ac86a.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b00ac86a.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">利用 travis 通过 Hexo 在 Github 上自动部署 Markdown 文档</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 20 Dec 2018 14:35:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<blockquote>
<p>本文介绍了一个只需要更新 Markdown 文档到 Github，即可实时更新博客内容的方法。</p>
<p>本文参考<a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener noreferrer">这篇文章</a> 实现，并根据我的需求更改了部分内容，以实现<strong>部署多个 hexo 工程到同一 Github 项目不同目录下</strong>。</p>
</blockquote>
<p>Github 为我们提供了<a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">Github Pages</a> 方便我们建立简单的网页来介绍项目，很多时候我们用他来搭建静态博客。</p>
<p>通过<a href="https://hexo.io/" target="_blank" rel="noopener noreferrer">Hexo</a>可以将我们写的<code>Markdown文档</code>格式化为<code>静态网页</code>，再将其部署到 Github 上面对应的<code>user_name.github.io</code>上面，就可以拥有一个在线的静态博客。</p>
<p>但是受 Hexo 的限制，每次更新博客内容都需要在更新完 Markdown 文档后，都需要再次重新创建对应的静态网页、将更新提交到 Github。这样的步骤繁琐且没有意义，而且更换电脑后这些环境都需要重新设置一次。</p>
<p>通过<a href="https://www.travis-ci.org" target="_blank" rel="noopener noreferrer">travis</a>提供的免费 CI 技术，可以让云服务器代替我们实现 Hexo 创建以及同步 Github 等步骤，每次更新博客时<strong>只需要将写好的 Markdown 文档推送到 Github 项目对应目录中，等待一会儿就可以看到更新后的博客了</strong>。</p>
<p>具体搭建过程可以参考<a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener noreferrer">这篇文章</a> 本文只讲述实现<strong>部署多个 hexo 工程到同一 Github 项目不同目录下</strong>需要注意的地方：。</p>
<blockquote>
<p><strong>懒——是第一生产力</strong></p>
</blockquote>
<h2> 具体差异</h2>
<h3> hexo 分支的结构</h3>
<p>因为有多个 hexo 项目，所以在 github 项目的 hexo 分支下，对不同的 hexo 项目分别新建文件夹存放。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> .travis.yml</h3>
<p>重点修改<code>script:</code>和<code>after_script:</code>两部分：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文档链接：<a href="https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/.travis.yml" target="_blank" rel="noopener noreferrer">.travis.yml</a></p>
<h2> 更新博客内容</h2>
<p>当以上内容都配置完成后，只要新建一个符合 hexo 要求的文档，并提交到 Github 对应项目的 hexo 分支中<code>source</code>目录，Travis 便会自动帮我们创建并更新静态网页。</p>
<h2> 参考文档</h2>
<p><a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener noreferrer">Hexo 遇上 Travis-CI：可能是最通俗易懂的自动发布博客图文教程</a> （完全在该文档指导下完成，部分步骤有差异，感谢作者<a href="https://juejin.im/user/56efe6461ea493005565dafd" target="_blank" rel="noopener noreferrer">MichaelX</a> ）</p>
]]></content:encoded>
    </item>
    <item>
      <title>Hexo+Github=Blog</title>
      <link>https://jixiaoyong.github.io/blog/posts/f7965978.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/f7965978.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">Hexo+Github=Blog</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 24 Mar 2016 22:06:06 GMT</pubDate>
      <content:encoded><![CDATA[<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一直以来，为了有一个合适的在线写字的地方，我尝试过许多种工具，从最初的 QQ 空间开始，到各种门户网站的博客，再到自己开始尝试搭建博客，一路奔忙，门户网站的限制太多，自己搭建的博客又时常由于空间提供商的各种问题而无法访问。许多时候一个平台只能使用一段时间，这样子颠颠撞撞大概也有五六年的时间了。</p>
<p>一直听说 github 这个平台的各种优点，尤其是可以作为稳定而免费的空间托管博客最令我心动，但是之前多次尝试不得其道，终以失败告终。最近在学习 Android 语言的时候，又再次用起了 github，不过这次是用它来存储代码。不得不承认，使用 github 来控制程序版本真是一件令人愉悦的事件。</p>
<p>机缘巧合，因为需要将学习过程中的一些笔记，心得总结找个地方整理，显然单纯的使用 github 并不是一个好办法，而其他的平台的博客限制又太多，于是又尝试用 github 搭建一个博客，虽然对这些知识并不是很熟悉，但误打误撞竟然也成功的搭建好了博客。下面就把整个建站的过程大概梳理一下，以便以后查看。</p>
<h2> 准备 git 和 node 环境</h2>
<p>下载软件：</p>
<ul>
<li>git</li>
<li>github windows 客户端 (可选)</li>
<li>node 客户端</li>
</ul>
<h3> 装 git 环境</h3>
<ul>
<li>
<p>安装 git:</p>
<p>git 安装时按照默认的配置，一路点击确定就可以。</p>
</li>
<li>
<p>安装 github 客户端（可选，如果熟悉 git 命令可以直接命令行操作）</p>
<p>github 安装分为两种：</p>
<ul>
<li>用官网的安装包，在安装的时候需要从网上下载资料，受网速限制，这种方法很慢，而且容易出错；</li>
<li>直接找一份 github 离线安装包解压到本地即可使用，我就是使用后一种方法。</li>
</ul>
</li>
</ul>
<h3> 安装 node</h3>
<p>安装 node 客户端：</p>
<p>下载并安装 node ,我使用的版本是 node-v5.7.1-x64。</p>
<h3> 校验环境</h3>
<p>在安装完 git, node 之后<code>win 键 + R</code> 输入 <code>cmd</code> 打开 windows 自带终端窗口；</p>
<p>分别输入<code>git</code> 、 <code>npm</code>之后，如果显示出 <em>帮助信息</em> 而非 <em>“不是内部或外部命令，也不是可运行的程序或批处理文件”</em> 这样的提示，就说明 git 和 node 已经配置好了环境变量，否则就需要手动配置。</p>
<h4> 配置环境变量方法：</h4>
<ul>
<li>此电脑 –&gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量</li>
<li>找到用户环境变量 –&gt; path，并添加 git 和 npm 的安装路径。</li>
</ul>
<blockquote>
<p>更详细的教程可以参考这里：<a href="https://www.google.com/search?q=%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" target="_blank" rel="noopener noreferrer">如何修改环境变量</a></p>
</blockquote>
<p>这样子 git 和 node 应该就可以正常使用了。</p>
<h2> 安装配置 hexo</h2>
<h3> 安装 hexo</h3>
<p>打开命令行，全局安装 Hexo ,加 -g 参数：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看 hexo 版本</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>到这里 hexo 就在电脑上面安装好了。</p>
<h3> 配置 hexo</h3>
<ul>
<li>进入存放 hexo 文件的目录下，创建一个文件夹 blog 存储 hexo 的文件</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后进入这个文件夹</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>启动 hexo 服务器</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>打开本地地址：<a href="http://localhost:4000/" target="_blank" rel="noopener noreferrer">http://localhost:4000/</a> ，就可以看到本地搭建好的 hexo 博客了<br>
这样子一个 hexo 博客就在本地搭建好了</p>
<h3> 目录的解释：</h3>
<p>scaffolds 脚手架，也就是一个工具模板 scripts 写文件的 js，扩展 hexo 的功能<br>
source 存放博客正文内容<br>
source/_drafts 草稿箱<br>
source/_posts 文件箱<br>
themes 存放皮肤的目录<br>
themes/landscape 默认的皮肤<br>
_config.yml 全局的配置文件<br>
db.json 静态常量</p>
<h3> 一些 hexo 语句解释</h3>
<p>help 查看帮助信息<br>
init 创建一个 hexo 项目<br>
migrate 从其他系统向 hexo 迁移<br>
version 查看 hexo 的版本<br>
–config 参数，指定配置文件，代替默认的_config.yml<br>
–debug 参数，调试模式，输出所有日志信息<br>
–safe 参数，安全模式，禁用所有的插件和脚本<br>
–silent 参数，无日志输出模式</p>
<h3> 新建文章</h3>
<p>命名为“新的文章”，输入命令：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>hexo 默认生成 md 文件，新生成的文章在目录：.\blog\source_posts\新的文章.md，对其进行相应的编辑即可<br>
文章格式：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>或者你也可以直接自己在对应位置新建 file_name.md 文件（常用）</p>
</blockquote>
<h2> 配置 github</h2>
<ul>
<li>注册并登录 github<br>
进入 <a href="https://github.com/" target="_blank" rel="noopener noreferrer">https://github.com/</a> ，注册新账户，并且登录</li>
<li>新建 respositoy<br>
在主页点击 New respositoy 新建一个名字为 <a href="http://yourname.github.io" target="_blank" rel="noopener noreferrer">yourname.github.io</a><br>
的 respositoy；</li>
<li>设置新建一个 github pages<br>
进入仓库主页，选择 settings --&gt; github pages --&gt; Launch automatic page generator ,按照默认的主题配置选择一个就好</li>
</ul>
<h2> 上传网站</h2>
<p>对于 hexo 的相关配置：<br>
打开_config.yml，修改以下部分：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此处由于我是将网站放在二级目录 ./blog/ 下面，所以 root 目录设置如此，使用的是绝对路径，否则在网页上显示的时候，css 等由于路径不对，加载可能会有问题。</p>
<h3> 部署方法 1</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这行语句是使用 hexo 自动 deploy 到 github 时的设置，~如果正常的话，当用 hexo 对网站静态化处理后，再执行 hexo deploy 就可以自动部署到 github 上面了，但是我的电脑 git 或者 node 由于是不同时间装的期间还重装了几次系统，可能导致某些设置有误，所以在执行 hexo deploy 的时候一直提示有问题，故而采用另一种办法手动同步网站，这句话也可以不修改。~</p>
<h3> 部署方法 2</h3>
<ul>
<li>
<p>用 hexo 对文章进行静态化处理：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<p>在<code>blog\public</code>目录下生成的 <code>public</code> 包含所有的静态化文件，此时，这个文件夹内所有的内容就是处理好的网站，将其发布到合适的空间就可以正常显示。<br>
由于之前的 git 或者 node 配置有误，所以这时候采用手动同步网站：</p>
<ul>
<li>将上次在 github 上建立的项目 <a href="http://yourname.github.io" target="_blank" rel="noopener noreferrer">yourname.github.io</a><br>
同步到本地。<br>
同步的方法很多，这里我选择的是使用 github 的 windows 客户端，比较方便：</li>
</ul>
<p>打开 github 客户端，找到项目，选择 clone 到本地即可。</p>
<p>之后打开同步的项目，确认当前的 branch 是 master，否则同步之后网站不会显示。</p>
<p>在 github 同步的目录下找到上次建好的项目<code>yourname.github.io</code>,进入之后，将上文获得到的 public 内容放入目标文件夹，我选择的是将博客放在子目录，所以这里新建了一个 blog 文件夹用于放置博客，所以就是将 public<br>
全部内容 放入./yourname.github.io/blog/ 目录下，这样子在网站上显示的时候，博客的网址就是 <a href="http://yourname.github.io/blog/" target="_blank" rel="noopener noreferrer">http://yourname.github.io/blog/</a></p>
<p>这样一个简单的利用 github 托管的 hexo 博客就搭建好了。</p>
<blockquote>
<p>注：本文内容是根据我建立博客时的做法整理而成，其中有部分内容是参考网上的教程，文中引用的文字全部来自<a href="http://blog.fens.me/hexo-bootstarp-github/" target="_blank" rel="noopener noreferrer">http://blog.fens.me/hexo-bootstarp-github/</a> ，此文对我帮助很大，感谢作者张丹 (Conan) 的分享。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>加载已安装应用、未安装 apk 中的资源</title>
      <link>https://jixiaoyong.github.io/blog/posts/8d60b485.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/8d60b485.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">加载已安装应用、未安装 apk 中的资源</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 15 Apr 2018 13:40:32 GMT</pubDate>
      <content:encoded><![CDATA[<p>加载已安装应用、未安装 apk 中的资源，其思路主要是获取到对应的 ClassLoader/Context，通过 ClassLoader 加载 R.java 等类，再通过反射获取对应的资源 id 及资源。</p>
<h2> 加载已安装应用资源</h2>
<h3> sharedUserId</h3>
<p>在当前应用中加载已安装的其他应用资源，需要二者有相同的<code>sharedUserId</code>，这样 Android 系统为二者分配同一个 Linux 用户 ID，两个 App 可以相互访问代码、资源等。</p>
<blockquote>
<p>通过 Shared User id，拥有同一个 User id 的多个 APK 可以配置成运行在同一个进程中。所以默认就是可以互相访问任意数据。也可以配置成运行成不同的进程，同时可以访问其他 APK 的数据目录下的数据库和文件。就像访问本程序的数据一样。</p>
<p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51316688" target="_blank" rel="noopener noreferrer">Android 逆向之旅---Android 中的 sharedUserId 属性详解 - CSDN 博客</a></p>
</blockquote>
<p>具体设置方法如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 筛选所有已安装应用信息</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 生成插件 App 的 Context</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 通过 Context 反射获取插件 App 中的资源</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 加载未安装 Apk 内资源</h2>
<h3> 获取 apk 信息</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 获取 ClassLoader</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>getDir() 调用了 Context 的 getDir()</p>
<p>Retrieve, creating if needed, a new directory in which the application can place its own custom data files. You can use the returned File object to create and access files in this directory. Note that files created through a File object will only be accessible by your own application; you can only set the mode of the entire directory, not of individual files.</p>
</blockquote>
<h3> 通过反射加载类，获取资源</h3>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>AssetManager.addAssetPath()</code>方法是用来将 apk 等中的资源添加到<code>AssetManager</code>中，再通过其获取到<code>Resources对象</code>，这样就获取到未安装 apk 中的资源了。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考资源</h2>
<p><a href="https://www.cnblogs.com/lee0oo0/p/3665066.html" target="_blank" rel="noopener noreferrer">Android 之 Android apk 动态加载机制的研究（二）：资源加载和 activity 生命周期管理 - lee0oo0 - 博客园 </a></p>
<p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51316688" target="_blank" rel="noopener noreferrer">Android 逆向之旅---Android 中的 sharedUserId 属性详解 - CSDN 博客</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>数据结构_Hash 表</title>
      <link>https://jixiaoyong.github.io/blog/posts/1f6681a0.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/1f6681a0.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">数据结构_Hash 表</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sun, 23 Dec 2018 09:35:36 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>Hash 表是一种可以快速插入和查找的数据结构，将数据保存在通过 hash 函数计算得到的下标中。</p>
<p>插入和删除 所需时间为 O(1)。在确定容量、无需遍历时效果最好。</p>
<p>当其大小接近容量时，效率会变得很差。</p>
<h2> 存储方式</h2>
<p>Hash 表有两种存储方式</p>
<ol>
<li>
<p>开放地址法</p>
<p>开放地址法，直接将数据存储在数组中。</p>
<p>当 hash 算出的地址已经被占用时，则走过一定的步长找到另外一个空位（在填充质数很大时就会很耗时）并保存数据。</p>
</li>
<li>
<p>链地址法</p>
<p>链地址法，创建保存数据的数组，该数组中不直接保存数据，而是保存一个用来存储这些数据的链表，将数据项直接存储的链表中。</p>
<p>当 hash 算法计算出的地址时，遍历数组中对应的链表找到空位并保存。</p>
</li>
</ol>
<p>其中，开放地址法又分为 3 种实现：</p>
<ul>
<li>
<p>线性探测</p>
<p>每次前进的步长为 1</p>
<p>即查找的位置依次是<code>x + 1,2,3,4,5,……</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>二次探测</p>
<p>每次前进的步长为当前查找次数的平方</p>
<p>即查找的位置依次是<code>x + 1,4,9,……</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>再哈希法</p>
<p>每次前进的步长是根据另外一个 hash 算法计算出来的值</p>
<p>这个算法要求如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>已经有一个公认的比较好的二次 hash 算法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> 比较</h2>
<p><strong>再哈希法 VS 二次探测法</strong></p>
<p>在小型哈希表中，再哈希法比二次探测好；</p>
<p>但如果容量充足，并且容量大小不再变化时，二次探测效果好，在装填因子小于 0.5 时几乎没有性能损失</p>
<p><strong>开放地址法 VS 链地址法</strong></p>
<p>hash 表容器大小未知时，用链地址法比较好</p>
<p>当装填因子变得很大时，开放地址法性能下降很快，但链地址法只是线性下降。</p>
<h2> 源码</h2>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/Hash.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a>查看源码</p>
]]></content:encoded>
    </item>
    <item>
      <title>数据结构_二叉树</title>
      <link>https://jixiaoyong.github.io/blog/posts/101c73f.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/101c73f.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">数据结构_二叉树</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 03 Jan 2019 14:09:40 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>本文介绍了二叉树，及其应用。</p>
<p>树，既能像链表那样快速插入和删除，又可以像数组那样快速查找。</p>
<figure><img src="https://jixiaoyong.github.io/images/20190103200423.png" alt="树" tabindex="0" loading="lazy"><figcaption>树</figcaption></figure>
<p>每棵树有且只有一个<strong>根</strong>，从根到任何一个节点<strong>有且只有一条路径</strong>；每个节点都可以有 0 个或者多个<strong>子节点</strong>，没有子节点的节点叫做<strong>叶子节点</strong>。</p>
<p><strong>层</strong>是指从根节点到该节点的“代”树，根节点的在<strong>0 层</strong>。</p>
<h2> 二叉搜索树</h2>
<p>一个节点只能有 0~2 个子节点的树叫做<strong>二叉树</strong>；</p>
<p>如果二叉树的左子节点的关键字小于该节点，右子节点的关键字大于该节点，则该二叉树称为<strong>二叉搜索树</strong>。</p>
<p>如下，是一个二叉树的节点：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 遍历</h3>
<p>遍历树指安装一定的顺序访问数的每个节点，按照访问节点的顺序不同，可以分为三种：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>以中序遍历为例，其访问节点的顺序如下：</p>
<ol>
<li>调用自身遍历该节点的左子树；</li>
<li>访问这个节点；</li>
<li>调用自身遍历该节点的右子树。</li>
</ol>
<p>实现如下：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 最大值和最小值</h3>
<p>二叉搜索树的最大值是右子树中最右端没有子节点的右子节点；</p>
<p>二叉搜索树的最小值是左子树中最左端没有子节点的左子节点。</p>
<h3> 删除</h3>
<p>二叉搜索树因为节点要满足<code>左子节点 &lt; 节点 &lt; 右子节点</code>这个条件，所以删除需要分以下几种情况：</p>
<p>按照要删除的节点子节点数目的不同，分为 3 种情况</p>
<ul>
<li>
<p>要删除的节点是叶节点 将其父节点的指向设为 null 即可</p>
</li>
<li>
<p>要删除的节点有且只有一个节点 将其父节点指向其子节点</p>
</li>
<li>
<p>要删除的节点有两个子节点 这时候可以找该子节点的右子树中最小的（或者左子树中最大的）节点并替换掉要删除的节点，</p>
<p>与此同时如果这个节点有右子节点（或对应的左子节点）则按照 2/3 的规则处理，这样就能保证这个树的结构不会出错</p>
</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 哈夫曼编码</h2>
<p>哈夫曼编码用来对一段文本进行压缩，解压。</p>
<blockquote>
<p>压缩：用字符的编码替代字符</p>
<p>解压：用字符代替对应的编码</p>
</blockquote>
<p>实现思路如下：</p>
<ul>
<li>

</li>
<li>

</li>
<li>

</li>
<li>

</li>
</ul>
<p>其过程如下图所示：</p>
<figure><img src="https://jixiaoyong.github.io/images/20190103203447.png" alt="哈夫曼编码示意图" tabindex="0" loading="lazy"><figcaption>哈夫曼编码示意图</figcaption></figure>
<h2> 源码</h2>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/BinaryTree.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a> 查看<code>二叉树</code>源码</p>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/HuffmanCodeUtils.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a> 查看<code>哈夫曼编码</code>源码</p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20190103200423.png" type="image/png"/>
    </item>
    <item>
      <title>数据结构_图</title>
      <link>https://jixiaoyong.github.io/blog/posts/a71f2ecc.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/a71f2ecc.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">数据结构_图</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Thu, 27 Dec 2018 15:59:36 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p><strong>图</strong>，是由可以有多个边的顶点组成的结构。</p>
<p>两个顶点之间有边连接，则称这两个顶点是<strong>邻接</strong>的。</p>
<p>几个相互邻接的顶点组成的线叫做<strong>路径</strong>,至少有一条路径可以到达所有顶点的图叫做<strong>连通图</strong>。</p>
<p>如果图的顶点只能从 A→B，不能从 B→A，就称图是<strong>有向图</strong>。</p>
<p>如果边被赋予一定的权值（数字），就称图为<strong>带权图</strong></p>
<img width="30%" height="30%" src="https://jixiaoyong.github.io/images/20181227232301.png">
<h2> 存储方式</h2>
<p>图一般有两种存储方式：</p>
<ul>
<li>
<p>邻接矩阵 用 N*N 的数组保存图中所有的顶点，<code>Arr[m][n]</code>即表示 m、n 顶点是否邻接（Y:1,N:0）。</p>
<p>比较占地方。</p>
<figure><img src="https://jixiaoyong.github.io/images/20181227233341.png" alt="邻接矩阵" tabindex="0" loading="lazy"><figcaption>邻接矩阵</figcaption></figure>
</li>
<li>
<p>邻接表 用一个 N 大小的数组保存，数组元素是保存着顶点和他所有的邻接点的链表。</p>
<figure><img src="https://jixiaoyong.github.io/images/20181227233435.png" alt="邻接表" tabindex="0" loading="lazy"><figcaption>邻接表</figcaption></figure>
</li>
</ul>
<h2> 操作</h2>
<p>图的操作有插入（顶点），搜索等等。</p>
<p>以下操作以邻接表方式为例。</p>
<h3> 插入</h3>
<p>插入分为插入顶点和插入边。</p>
<p>插入边的时候需要注意，要同时更新 start 和 end 两个顶点对应的链表。</p>
<h3> 移除</h3>
<p>原理同插入边。</p>
<h3> 搜索</h3>
<p>搜索要求从某个特定顶点开始，沿着边移动到其他顶点，移动完毕后要保证访问了每个顶点。</p>
<p>搜索又分为 DFS（深度优先搜索）、BFS（广度优先搜索）。</p>
<h4> DFS</h4>
<p>DFS 的思想是，依次沿着顶点某一个邻接点，纵深访问，将该邻接点当做新的顶点压入栈中，继续纵深访问，直到有顶点没有可以访问的邻接顶点，将其打印出来（从栈中推出）；然后再返回上一层的邻接顶点中还可以访问的顶点（查找当前栈顶元素未访问的邻接点），直到没有可以访问的顶点。</p>
<p>用栈实现，会先往深处遍历完一条路径，再遍历下一条。每个顶点只访问一次</p>
<p>规则：</p>
<ul>
<li>

</li>
<li>

</li>
<li>

</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> BFS</h4>
<p>BFS 的思想是，向将当前顶点的所有可以访问的邻接点访问完毕；之后将该顶点打印（推出），再去访问其邻接点的所有可以访问邻接点（从队列头取出一个顶点，查找其未访问的邻接点）。</p>
<p>用队列实现，会先遍历完本层所有的顶点，然后再移向下一层</p>
<p>规则：</p>
<ul>
<li>

</li>
<li>

</li>
<li>

</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 最小生成树 MST</h2>
<blockquote>
<p>生成树（Template:Lang-en-short）是具有图 G 的全部顶点，但边数最少的连通子图。</p>
<p>——维基百科</p>
</blockquote>
<p>带权图的生成树中，总权重最小的称为最小生成树。</p>
<p>最小生成树边比顶点数小 1。</p>
<ul>
<li>
<p>当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。</p>
</li>
<li>
<p>如果图的每一条边的权值都互不相同，那么最小生成树将只有一个。</p>
</li>
</ul>
<p>无向不带权图中，只需要找出最小数量的边即可。用 DFS 比较好实现，因为他对每个顶点只访问一次。</p>
<h2> 拓扑排序</h2>
<p>拓扑排序是指<strong>有向图</strong>的顶点排序，满足以下条件<a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">*</a>：</p>
<ol>
<li>每个顶点出现且只出现一次；</li>
<li>若 A 在序列中排在 B 的前面，则在图中不存在从 B 到 A 的<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84_(%E5%9B%BE%E8%AE%BA)" target="_blank" rel="noopener noreferrer">路径</a>。</li>
</ol>
<p>实现思路是：</p>
<ul>
<li>
<p>依次推出有向图中没有后继点的顶点作为排序的最后项，这是因为按照拓扑排序<code>条件2</code>没有后继点的顶点必然排在后面；</p>
</li>
<li>
<p>当去掉没有后继点的顶点后又会产生新的没有后继点的顶点，这样依次循环，当图中没有顶点的时候，就可以在有向无环图中完成拓扑排序。</p>
</li>
</ul>
<p>对于有环存在（即存在类似 A→B，B→C，C→A 的情况）的有向图，会出现找不到<code>没有后继点的顶点</code>，但同时<code>图中顶点数不为0</code>的情况，遇到这种情况退出循环，并说明有环存在即可。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 源码</h2>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/GraphClazz.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a> 查看<code>DFS/BFS/MST</code>源码</p>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/Digraph.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a> 查看<code>拓扑排序</code>源码</p>
<h2> 参考资料</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener noreferrer">拓扑排序——维基百科</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20181227233341.png" type="image/png"/>
    </item>
    <item>
      <title>数据结构_堆</title>
      <link>https://jixiaoyong.github.io/blog/posts/b3af796a.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/b3af796a.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">数据结构_堆</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 25 Dec 2018 12:51:36 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>堆是一种特殊的二叉树，用他实现的优先级队列插入和删除时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(LogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。</p>
<h2> 特征</h2>
<ol>
<li>堆是完全二叉树<a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">*</a></li>
<li>常用数组实现</li>
<li>每个堆的节点都满足堆的条件，即堆的每个节点关键字都大于（或等于）子节点的关键字</li>
</ol>
<p><code>特征3</code>保证了根节点是堆中最大的值，以及顺着某一个节点一直到遇到叶节点的路径上的节点关键字是依次递减的，但是没法保证这个值是这个堆中的最小值，这是因为堆中每个节点的左右子节点的位置和大小无关，两条这样的路径之前的值的大小没有一定的关系。</p>
<h2> 操作</h2>
<p>堆可以进行插入、移除，遍历等操作，时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(LogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。初次之外，利用堆根节点关键值最大这个属性，还可以进行堆排序,时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*LogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<p>对于在数组中保存的堆，设元素下标为<code>x</code>，则各个相关元素下标如下：</p>
<ul>
<li>父节点<code> (x-1)/2</code></li>
<li>左子节点 <code>2*x+1</code></li>
<li>右子节点 <code>2*x+2</code></li>
</ul>
<p>在插入，移除的时候为了保证满足堆的条件，需要对堆进行向上或向下的遍历，将修改的值移动到对应的位置，在这过程中涉及到复制和交换。如果每次比较都需要交换数据的话会复制很多次，而如果将最终要移动值保存在临时变量中，用一个值专门记录要移动到的下标，在每次符合条件时只复制参与对比的值，在最后再将要临时保存的值复制到目的下标，就会减少复制的次数。</p>
<p>如下图就将复制次数从 9 次减少到了 5 次。</p>
<figure><img src="https://jixiaoyong.github.io/images/20181225213813.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 插入</h3>
<p>插入操作思路是，将元素插入到数组最后一位，然后依次向元素父节点遍历，将不满足的元素下沉，直到找到满足<code>堆特征3</code>（父节点关键字大于该点，并且子节点关键字小于该点）的下标，或者指向了根目录，将该元素插入该处。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 移除</h3>
<p>移除指的是将根节点推出堆中。</p>
<p>基本思路是将根节点推出，再将数组最后一个节点（同时也是堆的最后一个节点）移动到根节点空出的位置，再依次向下遍历，直到将该节点放到符合堆条件的位置或者到达叶子节点。</p>
<p>和插入相比，移除时要移动的节点要比较的稍微多些。</p>
<ul>
<li>该节点是叶节点 直接插入 ✅</li>
<li>有两个子节点 和两个叶子节点中最大的比较，如果小于则交换，并再和新的子节点比较</li>
<li>只有左节点 如果左节点大于本节点则交换，否则就是该位置</li>
</ul>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 堆排序</h3>
<p>利用堆<code>根节点关键值最大</code>这一特性，可以进行堆排序。</p>
<p>只需要将待排序的数组依次插入堆中，然后再依次移除即可。</p>
<p>这样需要有两倍与待排序数组大小的空间。如果每次插入时候只保存数据，不进行向上遍历，在每次移除数据时进行向下遍历，将当前剩余数据最大值选出来（其余数据仍然无序）从堆中移除根元素时都会在数组末尾空出一个位置，将该值存储在该位置即可，这样等完全插入、移除后就得到一个有序数组【从数组末尾开始依次减小】</p>
<p>堆排序和快速排序时间复杂度都是 <code>O(N*LogN)</code> ，但是由于向上、向下遍历耗时，实际上要比快速排序稍慢一些。但是堆排序堆数据初始分布不敏感一直都是 <code>O(N*LogN)</code> ，快速排序在某些情况下时间复杂度可达到 <code>O(N^2)</code> 。</p>
<h2> 附录</h2>
<h3> 满二叉树</h3>
<p>满二叉树指除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。</p>
<p>如果一个二叉树的层数为 K，且节点总数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>k</mi></msup><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(2^k) -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，则它就是满二叉树。</p>
<figure><img src="https://jixiaoyong.github.io/images/20181225210750.png" alt="满二叉树" tabindex="0" loading="lazy"><figcaption>满二叉树</figcaption></figure>
<h3> 完全二叉树</h3>
<p>完全二叉树 如果将二叉树每层从左到右遍历，那么完全二叉树只有最后一层的右边会出现没有叶子节点的情况，即在前 1~n 之间没有“洞”。</p>
<p>如下图就是一个完全二叉树：</p>
<figure><img src="https://jixiaoyong.github.io/images/20181225211304.png" alt="完全二叉树" tabindex="0" loading="lazy"><figcaption>完全二叉树</figcaption></figure>
<p>但下图不是完全二叉树：</p>
<figure><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt="不是完全二叉树" tabindex="0" loading="lazy"><figcaption>不是完全二叉树</figcaption></figure>
<h2> 源码</h2>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/HeadClazz.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a> 查看源码</p>
<h2> 参考链接</h2>
<p><a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener noreferrer">满二叉树——百度百科</a></p>
<p><a href="https://blog.csdn.net/u013812939/article/details/46798743" target="_blank" rel="noopener noreferrer">完全二叉树与满二叉树的区别</a></p>
<p>《Java 数据结构和算法 （第二版）》 Robert Lafore 陈维宁</p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20181225213813.png" type="image/png"/>
    </item>
    <item>
      <title>数据结构_总结</title>
      <link>https://jixiaoyong.github.io/blog/posts/851be5ef.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/851be5ef.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">数据结构_总结</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Sat, 05 Jan 2019 05:55:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>本文汇总了数据结构的优缺点及应用场景。</p>
<p>通用数据结构：数组、链表、树、哈希表</p>
<p>专用数据结构：栈、队列、优先级队列</p>
<p>排序：冒泡排序、选择排序、插入排序，希尔排序、快速排序、归并排序、堆排序</p>
<p>图：邻接矩阵、邻接表</p>
<h2> 通用数据结构</h2>
<p>这些数据结构使用关键字的值存储、查找数据</p>
<p>其速度如下：</p>
<p><code>哈希表 &gt; 树 &gt; 链表 &gt; 数组</code></p>
<p>数组：数据量小，大小可以预测时使用</p>
<p>链表：数据大小不可预知，或需要频繁插入删除元素时使用</p>
<p>二叉搜索树：如果数组和链表都很慢时，优先考虑二叉树</p>
<p>平衡树：二叉搜索树很快，但是如果遇到数据是逆序的时候，就会很耗性能，而平衡树则不会</p>
<p>哈希表：在数据存储结构中最快，但是需要有额外的空间</p>
<p>下面是以上数据结构的速度：</p>
<figure><img src="https://jixiaoyong.github.io/images/20190105140704.png" alt="通用数据结构速度统计" tabindex="0" loading="lazy"><figcaption>通用数据结构速度统计</figcaption></figure>
<h2> 专用数据结构</h2>
<p>包括栈、队列、优先级队列（堆），都是抽象数据结构 (ADT)，由更加基础的<code>通用数据结构</code>组成。</p>
<p>不能查找或者遍历，只能访问指定元素（头部，队列也可以访问尾部）。</p>
<h3> 栈</h3>
<p>先进后出 (FILO)，最后插入的数据在栈顶，每次只能访问栈顶元素。</p>
<h3> 队列</h3>
<p>先进先出 (FIFO)，最后插入的数据在队尾，最先插入的在队首，每次先弹出队首的元素。</p>
<h3> 优先级队列</h3>
<p>是一种特殊的队列，不同的是优先级高的在队首，优先级低的在队尾，每次弹出优先级最高的元素（这意味着每次插入或弹出时要进行排序）。</p>
<h3> 效率</h3>
<figure><img src="https://jixiaoyong.github.io/images/20190105141727.png" alt="专用数据结构效率比较" tabindex="0" loading="lazy"><figcaption>专用数据结构效率比较</figcaption></figure>
<h2> 排序</h2>
<p>排序包括冒泡排序、选择排序、插入排序，希尔排序、快速排序、归并排序、堆排序。</p>
<p>一般使用排序优先级：</p>
<p><code>插入排序 &gt; 希尔排序 &gt; 快速排序 &gt; 归并排序 &gt; 堆排序</code></p>
<p>归并排序：需要辅助存储空间</p>
<p>堆排序：需要一个堆的数据结构，比快速排序更适于非随机数据</p>
<p>快速排序：处理非随机数据时会慢到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mtext>​</mtext></mrow><annotation encoding="application/x-tex">O(N^2)​</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">​</span></span></span></span></p>
<p>下面是排序算法比较：</p>
<figure><img src="https://jixiaoyong.github.io/images/20190105142406.png" alt="排序算法比较" tabindex="0" loading="lazy"><figcaption>排序算法比较</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20190105140704.png" type="image/png"/>
    </item>
    <item>
      <title>数据结构_数组，链表</title>
      <link>https://jixiaoyong.github.io/blog/posts/9a784fe0.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/9a784fe0.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">数据结构_数组，链表</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Tue, 01 Jan 2019 03:19:52 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>本文介绍了数组、链表等数据结构。</p>
<p>设定所有排序：小 → 大。</p>
<h2> 数组</h2>
<p>数组（array）是一组具有相同类型元素的集合，用一段连续的内存来保存。使用下标来访问保存的元素，如<code>a[0]</code>。</p>
<p>数组是一种数据存储结构。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数组大小固定，对指定下标元素读写快 O(1)，但是查找慢 O(N)，删除元素慢 O(N)。</p>
<h3> 有序数组</h3>
<p>在每次插入的时候对元素进行排序，就得到有序数组。</p>
<p>有序数组查找快 O(LogN)，但插入慢 O(N)，删除元素慢 O(N)。</p>
<p><strong>有序数组插入</strong>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在有序数组要找到某个元素 t 可以使用二分查找，其思想是：</p>
<ol>
<li>选取一个中间值 n 将当前数组一分为二。</li>
<li>如果<code>t==n</code>那么查找结束，如果<code>t&lt;n</code>,那么在右半部分数组查找，否则在左半部分数组查找。</li>
<li>重复步骤<code>1</code>,<code>2</code>，直到找到 n 或者数组已经不可再分（不存在 n），结束查找。</li>
</ol>
<p><strong>二分法查找</strong>：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 链表</h2>
<p>链表的每个节点除了保存的数据外，还保存着下一个节点的引用<code>next</code>，最后一个元素中该引用为<code>null</code>。</p>
<p>链表的大小不固定，查找，删除，插入指定节点都需要 O(N)</p>
<p>链表有以下分类：</p>
<ul>
<li>
<p>单链表 每个节点只有指向下一个节点的引用，链表只保留第一个链节点的引用<code>first</code></p>
<figure><img src="https://jixiaoyong.github.io/images/20190101132535.png" alt="单链表" tabindex="0" loading="lazy"><figcaption>单链表</figcaption></figure>
</li>
<li>
<p>双向链表 每个节点保存有父节点和子节点的引用。双向链表也可以是双端链表。</p>
<figure><img src="https://jixiaoyong.github.io/images/20190101132614.png" alt="双向链表" tabindex="0" loading="lazy"><figcaption>双向链表</figcaption></figure>
</li>
</ul>
<p><strong>双端链表</strong> 双端链表保存第一个链节点<code>farst</code>和最后一个链节点<code>last</code>的引用。</p>
<figure><img src="https://jixiaoyong.github.io/images/20190101132649.png" alt="双端链表" tabindex="0" loading="lazy"><figcaption>双端链表</figcaption></figure>
<h2> 源码</h2>
<p><a href="https://github.com/jixiaoyong/Notes-Files/tree/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/link" target="_blank" rel="noopener noreferrer">👉 点这里</a> 查看<code>链表</code>源码</p>
<h2> 参考文献</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener noreferrer">数组--维基百科</a></p>
<p><a href="https://book.douban.com/subject/1144007/" target="_blank" rel="noopener noreferrer">Java 数据结构和算法（第二版）Robert Laforce 计晓云等译</a></p>
]]></content:encoded>
      <enclosure url="https://jixiaoyong.github.io/images/20190101132535.png" type="image/png"/>
    </item>
    <item>
      <title>数据结构_栈和队列</title>
      <link>https://jixiaoyong.github.io/blog/posts/8d059318.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/8d059318.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">数据结构_栈和队列</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Wed, 02 Jan 2019 11:54:53 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>本文介绍栈、队列两种抽象数据类型。</p>
<h2> 栈</h2>
<p>栈<code>stack</code>，又称堆栈，是一种抽象数据类型，每次只能访问栈顶元素<code>top</code>，可以进行压入<code>push</code>和推出<code>pop</code>操作。其元素<strong>先进后出 (FILO)</strong>。</p>
<h2> 队列</h2>
<p>队列<code>queue</code>,是和栈相对的一种抽象数据类型，每次从后端<code>rear</code>插入，从前端<code>front</code>删除。其元素<strong>先进先出 (FIFO)</strong>。</p>
<p>用链表实现的队列可以自由扩充，不存在伪溢出问题，但是插入和读取比较耗时；</p>
<p>用数组实现的队列大小固定，可以使用<strong>循环队列</strong>解决伪溢出问题，即当尾端（前端也类似）指针指向超出数组大小时，可以指向数组开始位置，因为此时大小不超过数组的队列前端已经指向 0 之后的位置了，所以不会冲突。</p>
<h3> 优先级队列</h3>
<p>和队列定义一致，只是在每次插入的时候都进行排序，以满足排序规则（如<code>尾端→前端</code> <code>小→大</code>）。</p>
<h2> 中缀表达式与后缀表达式</h2>
<p>中缀表达式，指运算符在操作数中间的，如<code>1 + 2</code>。</p>
<p>后缀表达式，指运算符在操作数后面的，如<code>1 2 +</code>。</p>
<p>中缀表达式 ↔ 后缀表达式：</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>转换规则：</p>
<p>设一个栈用于保存运算符，从左到右依次遍历中缀表达式，假设读取到的是<code>x</code></p>
<ol>
<li>
<p>如果是操作数，则直接打印</p>
</li>
<li>
<p>如果是运算符<code>(</code>，则压入栈中</p>
</li>
<li>
<p>如果是运算符<code>)</code>，则推出栈中的元素，直到遇到<code>(</code>,推出<code>(</code>，继续读取下一个</p>
</li>
<li>
<p>否则，读取栈顶元素<code>top</code>，如果是<code>(</code>，将<code>x</code>压入栈中；</p>
<p>如果<code>x</code>优先于<code>top</code>，将<code>x</code>压入栈中；</p>
<p>否则，将<code>top</code>推出，在此和新的<code>top</code>比较，直到遇到<code>top</code>是<code>(</code>或者优先级比<code>x</code>高，或者栈已经空了，将<code>x</code>插入栈中。</p>
</li>
</ol>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 源码</h2>
<p>👉<a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/InfixAndPostfix/CovertInfixToPostfix.java" target="_blank" rel="noopener noreferrer">点这里</a>查看<code>中缀表达式 → 后缀表达式</code>源码</p>
<h2> 参考资料</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener noreferrer">堆栈——维基百科</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97" target="_blank" rel="noopener noreferrer">队列——维基百科</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>数据结构_简单排序</title>
      <link>https://jixiaoyong.github.io/blog/posts/125c8a12.html</link>
      <guid>https://jixiaoyong.github.io/blog/posts/125c8a12.html</guid>
      <source url="https://jixiaoyong.github.io/blog/rss.xml">数据结构_简单排序</source>
      <description>Let&amp;apos;s make something different!</description>
      <pubDate>Mon, 31 Dec 2018 06:45:45 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简单排序</h2>
<p>所有排序顺序为 <code>小 → 大</code>。</p>
<p>时间负责度都是 O(N<sup>2</sup>)。</p>
<p>排序速度：<code>插入排序&gt;选择排序&gt;冒泡排序</code></p>
<h3> 冒泡排序</h3>
<p>时间复杂度：O(N<sup>2</sup>)</p>
<p>最慢的排序，但是简单</p>
<p>规则如下：</p>
<ol>
<li>从左到右，比较 a 和 b，如果<code>a&gt;b</code>，就交换 a 和 b 的位置</li>
<li>再将 a，b 中较大的那个与 c 按照 2 的规则比较，直到最后一位</li>
<li>重复 1，2 直到没有待排序的项目</li>
</ol>
<p>其思想是：每次选出当前未排序的元素中最大的元素并放到队尾（每次比较最大元素都会“冒泡”到队尾），这样当连续遍历 n 次后，每个元素都会排好序。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 选择排序</h3>
<p>时间复杂度：O(N<sup>2</sup>)</p>
<p>因为交换次数少，所以比冒泡快</p>
<p>规则如下：</p>
<ol>
<li>假设第一项值最大，设其坐标为<code>max</code>，从左到右依次比较<code>max</code>和其他元素，如果遇到比<code>max</code>大的，将 max 坐标指向该值</li>
<li>每轮结束后<code>max</code>就表示这轮比较最大的值坐标，将其与当前未排序的最后一项交换</li>
<li>这样重复步骤 1，2， <code>n次</code>就可以排序完成</li>
</ol>
<p>其思想是：每次比较当前最大的值，记录下其坐标，等当前比较完成就和<code>未比较的最后一位</code>交换，（这样子避免每次比较都要交换）。同样这样子比较 n 次就可以完成排序。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 插入排序</h3>
<p>时间复杂度：O(N<sup>2</sup>)</p>
<p>比冒泡快一倍，比选择排序快一些</p>
<p>思想：假设一个标记元素的左边全部是有序数组，右边全是无序数组，那么只需要将右边的元素依次拿出来插入到左边的有序数组中即可。刚开始这个标记元素可以为 0 或者 1（假设一个元素就是有序的）。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 源码</h2>
<p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/sort/BasicSort.kt" target="_blank" rel="noopener noreferrer">👉 点这里</a>查看源码</p>
]]></content:encoded>
    </item>
  </channel>
</rss>