<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/https/jixiaoyong.github.io/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.ico">
  <link rel="mask-icon" href="/blog/https/jixiaoyong.github.io/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jixiaoyong.github.io","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":true,"version":"8.12.3","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="本文讨论的 Flutter 动画主要限定在: 随着每一帧的变化，修改 Flutter Widget 的大小、颜色、位置等属性，使之看起来从一种状态渐变为另外一种状态 这一范围。  在之前的文章中，我们将 Flutter 中动画的实现分为 底层实现 和 封装好的 Widget 两大部分，目前已经分析了底层实现的部分：  AnimationController Tween&amp;Curve  而">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter动画分析之AnimatedWidget &amp; ImplicitlyAnimatedWidget">
<meta property="og:url" content="https://jixiaoyong.github.io/blog/posts/65caa519/index.html">
<meta property="og:site_name" content="Ji Xiaoyong&#39;s Blog">
<meta property="og:description" content="本文讨论的 Flutter 动画主要限定在: 随着每一帧的变化，修改 Flutter Widget 的大小、颜色、位置等属性，使之看起来从一种状态渐变为另外一种状态 这一范围。  在之前的文章中，我们将 Flutter 中动画的实现分为 底层实现 和 封装好的 Widget 两大部分，目前已经分析了底层实现的部分：  AnimationController Tween&amp;Curve  而">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_widget.png">
<meta property="og:image" content="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_select.png">
<meta property="article:published_time" content="2022-08-22T00:58:45.000Z">
<meta property="article:modified_time" content="2022-08-29T12:58:02.132Z">
<meta property="article:author" content="JI, XIAOYONG">
<meta property="article:tag" content="flutter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_widget.png">


<link rel="canonical" href="https://jixiaoyong.github.io/blog/posts/65caa519/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jixiaoyong.github.io/blog/posts/65caa519/","path":"posts/65caa519/","title":"Flutter动画分析之AnimatedWidget & ImplicitlyAnimatedWidget"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Flutter动画分析之AnimatedWidget & ImplicitlyAnimatedWidget | Ji Xiaoyong's Blog</title>
  




<link rel="dns-prefetch" href="https://vercel.xiaoyong.ml">
  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ji Xiaoyong's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ImplicitlyAnimatedWidget"><span class="nav-text">ImplicitlyAnimatedWidget</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initState"><span class="nav-text">initState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constructTweens"><span class="nav-text">_constructTweens</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#didUpdateWidget"><span class="nav-text">didUpdateWidget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forEachTween"><span class="nav-text">forEachTween</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#didUpdateTweens"><span class="nav-text">didUpdateTweens</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TweenAnimationBuilder"><span class="nav-text">TweenAnimationBuilder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AnimatedWidget"><span class="nav-text">AnimatedWidget</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AnimatedState"><span class="nav-text">_AnimatedState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AnimatedBuilder"><span class="nav-text">AnimatedBuilder</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JI, XIAOYONG"
      src="//jixiaoyong.github.io/images/default_avatar.jpg">
  <p class="site-author-name" itemprop="name">JI, XIAOYONG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jixiaoyong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jixiaoyong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jixiaoyong1995@gmail.com" title="E-Mail → mailto:jixiaoyong1995@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jixiaoyong.github.io/blog/posts/65caa519/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//jixiaoyong.github.io/images/default_avatar.jpg">
      <meta itemprop="name" content="JI, XIAOYONG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Flutter动画分析之AnimatedWidget & ImplicitlyAnimatedWidget | Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flutter动画分析之AnimatedWidget & ImplicitlyAnimatedWidget<a href="https://github.com/jixiaoyong/blog_source_code/edit/master/blog/source/_posts/Flutter%E5%8A%A8%E7%94%BB%E5%88%86%E6%9E%90%E4%B9%8BAnimatedWidget&ImplicitlyAnimatedWidget.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-22 08:58:45" itemprop="dateCreated datePublished" datetime="2022-08-22T08:58:45+08:00">2022-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-29 20:58:02" itemprop="dateModified" datetime="2022-08-29T20:58:02+08:00">2022-08-29</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/blog/posts/65caa519/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/blog/posts/65caa519/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/blog/posts/65caa519/"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>本文讨论的 Flutter 动画主要限定在: <em>随着每一帧的变化，修改 Flutter Widget 的大小、颜色、位置等属性，使之看起来从一种状态渐变为另外一种状态</em> 这一范围。</p>
</blockquote>
<p>在之前的文章中，我们将 Flutter 中动画的实现分为 <em>底层实现</em> 和 <em>封装好的 Widget</em> 两大部分，目前已经分析了底层实现的部分：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://xiaoyong.ml/blog/posts/6ec43bd8/">AnimationController</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaoyong.ml/blog/posts/820d6240/">Tween&amp;Curve</a></li>
</ul>
<p>而 Flutter 封装好的动画 Widget 主要分为两大类：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_widget.png" alt="Flutter中与动画有关的Widget"></p>
<ul>
<li><p><strong>ImplicitlyAnimatedWidget</strong> 隐式动画，关于动画的开始、停止等都封装在 Widget 内部，只要 Widget <em>前后传入的值不同</em> 便可以自动从 old 渐变到 new，内置的这些类主要以 <em>AnimatedFoo</em> 命名。</p>
</li>
<li><p><strong>AnimatedWidget</strong>，显式动画，需要使用者自己创建 Animation（一般是 AnimationController）并通过其 _主动管理动画_，此类 Widget 主要是监听 AnimationController 的值并刷新 Widget 的内容。</p>
<p>此类 Widget 主要有三种使用方式：</p>
<ul>
<li>继承 AnimatedWidget</li>
<li>使用 AnimatedBuilder</li>
<li>使用各种内置的 AnimatedWidget 子类，一般以 FooTransition 命名。</li>
</ul>
</li>
</ul>
<p>对于 Flutter 中这些与动画有关的类如何选择，Flutter 官方给了一张图：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter/animate/flutter_animate_select.png" alt="如何实现Flutter中的动画"></p>
<p>简单来说，Flutter 有一些内置的动画，在要写动画的时候，可以依次考虑（实现程度由易到难）：</p>
<ul>
<li>AnimatedFoo 参考<a target="_blank" rel="noopener" href="https://medium.com/flutter/flutter-animation-basics-with-implicit-animations-95db481c5916">文章</a>，设置新的状态，这些控件会自动从之前的状态切换到新状态</li>
<li>TweenAnimationBuilder 参考<a target="_blank" rel="noopener" href="https://medium.com/flutter/custom-implicit-animations-in-flutter-with-tweenanimationbuilder-c76540b47185">文章</a>，将任意属性在 Tween 指定的范围变化，和上面的 AnimatedFoo 都是属于<a target="_blank" rel="noopener" href="https://api.flutter.dev/flutter/widgets/ImplicitlyAnimatedWidget-class.html">Implicitly animated widgets</a>（隐式动画，由系统控件控制动画）。</li>
<li>FooTranslation</li>
<li>AnimatedBuilder &#x2F; AnimatedWidget</li>
<li>CustomPainter</li>
</ul>
<br/>

<p>本文将对 Flutter 内置封装好的动画相关的 Widget 的实现和用法进行简单分析。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>按照上述分析，Flutter 中的动画 Widget 可以大体分为 <em>隐式动画</em> 和 <em>显式动画</em> 两种。</p>
<h2 id="ImplicitlyAnimatedWidget"><a href="#ImplicitlyAnimatedWidget" class="headerlink" title="ImplicitlyAnimatedWidget"></a>ImplicitlyAnimatedWidget</h2><blockquote>
<p>ImplicitlyAnimatedWidgets (and their subclasses) automatically animate changes in their properties whenever they change.</p>
</blockquote>
<p>隐式动画内部持有 AnimationController 以管理动画，默认没有动画，当使用不同的值重新构建 Widget 的时候，会执行动画，使用者只能设置 Duration 和 Curve，如果想要更深入的控制动画（比如暂停动画）则应该使用 AnimatedWidget。</p>
<p>ImplicitlyAnimatedWidget 主要分为 2 大类：</p>
<ul>
<li>TweenAnimationBuilder，which animates any property expressed by a Tween to a specified target value.</li>
<li>AnimatedFoo<ul>
<li>AnimatedAlign, which is an implicitly animated version of Align.</li>
<li>AnimatedContainer, which is an implicitly animated version of Container.</li>
<li>AnimatedDefaultTextStyle, which is an implicitly animated version of DefaultTextStyle.</li>
<li>AnimatedScale, which is an implicitly animated version of Transform.scale.</li>
<li>AnimatedRotation, which is an implicitly animated version of Transform.rotate.</li>
<li>AnimatedSlide, which implicitly animates the position of a widget relative to its normal position.</li>
<li>AnimatedOpacity, which is an implicitly animated version of Opacity.</li>
<li>AnimatedPadding, which is an implicitly animated version of Padding.</li>
<li>AnimatedPhysicalModel, which is an implicitly animated version of PhysicalModel.</li>
<li>AnimatedPositioned, which is an implicitly animated version of Positioned.</li>
<li>AnimatedPositionedDirectional, which is an implicitly animated version of PositionedDirectional.</li>
<li>AnimatedTheme, which is an implicitly animated version of Theme.</li>
<li>AnimatedCrossFade, which cross-fades between two given children and animates itself between their sizes.</li>
<li>AnimatedSize, which automatically transitions its size over a given duration.</li>
<li>AnimatedSwitcher, which fades from one widget to another.</li>
</ul>
</li>
</ul>
<p>我们简单分析一下 ImplicitlyAnimatedWidget 和 TweenAnimationBuilder：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplicitlyAnimatedWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ImplicitlyAnimatedWidget(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">this</span>.curve = Curves.linear,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.duration,</span><br><span class="line">    <span class="keyword">this</span>.onEnd,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The curve to apply when animating the parameters of this container.</span></span></span><br><span class="line">  <span class="keyword">final</span> Curve curve;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The duration over which to animate the parameters of this container.</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Duration</span> duration;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Called every time an animation completes.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">This can be useful to trigger additional actions (e.g. another animation)</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">at the end of the current animation.</span></span></span><br><span class="line">  <span class="keyword">final</span> VoidCallback? onEnd;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ImplicitlyAnimatedWidgetState&lt;ImplicitlyAnimatedWidget&gt; createState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ImplicitlyAnimatedWidget.createState()</code>必须返回 ImplicitlyAnimatedWidgetState 或者 AnimatedWidgetBaseState 及其子类。</p>
</blockquote>
<p>ImplicitlyAnimatedWidget 作为 StatefulWidget，它的主要逻辑在 ImplicitlyAnimatedWidgetState 中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplicitlyAnimatedWidgetState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ImplicitlyAnimatedWidget</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">T</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 隐式动画内部维护着自己的AnimationController</span></span><br><span class="line">  AnimationController <span class="keyword">get</span> controller =&gt; _controller;</span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> AnimationController _controller = AnimationController(</span><br><span class="line">    duration: widget.duration,</span><br><span class="line">    debugLabel: kDebugMode ? widget.toStringShort() : <span class="keyword">null</span>,</span><br><span class="line">    vsync: <span class="keyword">this</span>,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 驱动此隐式动画的animation</span></span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; <span class="keyword">get</span> animation =&gt; _animation;</span><br><span class="line">  <span class="keyword">late</span> Animation&lt;<span class="built_in">double</span>&gt; _animation = _createCurve();</span><br><span class="line"></span><br><span class="line">  CurvedAnimation _createCurve() &#123;</span><br><span class="line">    <span class="keyword">return</span> CurvedAnimation(parent: _controller, curve: widget.curve);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImplicitlyAnimatedWidgetState 中，根据传入的 <em>Duration</em> 和 <em>Curve</em> ，创建并持有了 <em>AnimationController</em> 和 <em>Animation&lt;double&gt;</em> 用于驱动隐式动画。</p>
<h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><p>在<code>ImplicitlyAnimatedWidgetState.initState</code>方法中:</p>
<ul>
<li>监听<code>_controller</code>的状态，当<code>AnimationStatus.completed</code>时回调<code>ImplicitlyAnimatedWidget.onEnd</code>方法；</li>
<li>此外还调用了<code>_constructTweens()</code>遍历 Tween，并调用由子类实现的<code>forEachTween()</code>方法（子类在此方法内部，获取到对应的 Tween，比如 Padding，从而在监听到<code>_controller</code>变化并触发 rebuilt 时使用<code>Animatable.evaluate()</code>方法获取并显示最新的属性，实现动画效果）；</li>
<li>最后还调用了<code>didUpdateTweens()</code>方法通知子类 Tweens 发生变化了。</li>
</ul>
<h3 id="constructTweens"><a href="#constructTweens" class="headerlink" title="_constructTweens"></a>_constructTweens</h3><p><code>_constructTweens()</code>方法会创建一个 TweenVisitor&lt;dynamic&gt;并传给子类 <code>forEachTween()</code>方法，子类可以使用其获取对应的 Tween 对象。</p>
<p><code>_constructTweens()</code>则在此过程中，使用<code>_shouldAnimateTween()</code>得知了子类中是否有 Tween 可以开始动画——<code>shouldStartAnimation</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> _constructTweens() &#123;</span><br><span class="line">  <span class="built_in">bool</span> shouldStartAnimation = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// forEachTween方法由子类实现</span></span><br><span class="line">  forEachTween((Tween&lt;<span class="built_in">dynamic</span>&gt;? tween, <span class="built_in">dynamic</span> targetValue, TweenConstructor&lt;<span class="built_in">dynamic</span>&gt; constructor) &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">      tween ??= constructor(targetValue);</span><br><span class="line">      <span class="comment">// 判断targetValue是否不等于Tween.end</span></span><br><span class="line">      <span class="keyword">if</span> (_shouldAnimateTween(tween, targetValue))</span><br><span class="line">        shouldStartAnimation = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tween = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tween;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> shouldStartAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> _shouldAnimateTween(Tween&lt;<span class="built_in">dynamic</span>&gt; tween, <span class="built_in">dynamic</span> targetValue) &#123;</span><br><span class="line">  <span class="keyword">return</span> targetValue != (tween.end ?? tween.begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="didUpdateWidget"><a href="#didUpdateWidget" class="headerlink" title="didUpdateWidget"></a>didUpdateWidget</h3><p>当 ImplicitlyAnimatedWidget 被重新创建时，会调用 ImplicitlyAnimatedWidgetState.didUpdateWidget 方法。</p>
<p>在此方法中，除了检查并更新 Curve、Duration、Tween 之外，最重要的是使用 AnimationController.forward()开启了动画。也就是说——“<strong>ImplicitlyAnimatedWidget 第一次插入 Widget Tree 时没有动画，当再次被更新时会触发动画</strong>”。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> didUpdateWidget(T oldWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">  <span class="comment">// 如果Curve变化则创建新的CurveAnimation</span></span><br><span class="line">  <span class="keyword">if</span> (widget.curve != oldWidget.curve) &#123;</span><br><span class="line">    (_animation <span class="keyword">as</span> CurvedAnimation).dispose();</span><br><span class="line">    _animation = _createCurve();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新duration</span></span><br><span class="line">  _controller.duration = widget.duration;</span><br><span class="line">  <span class="keyword">if</span> (_constructTweens()) &#123;</span><br><span class="line">    <span class="comment">// 如果Tween可以开始，则更新其begin和end值</span></span><br><span class="line">    forEachTween((Tween&lt;<span class="built_in">dynamic</span>&gt;? tween, <span class="built_in">dynamic</span> targetValue, TweenConstructor&lt;<span class="built_in">dynamic</span>&gt; constructor) &#123;</span><br><span class="line">      _updateTween(tween, targetValue);</span><br><span class="line">      <span class="keyword">return</span> tween;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 当Widget更新后，开始动画</span></span><br><span class="line">    _controller</span><br><span class="line">      ..value = <span class="number">0.0</span></span><br><span class="line">      ..forward();</span><br><span class="line">    didUpdateTweens();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEachTween"><a href="#forEachTween" class="headerlink" title="forEachTween"></a>forEachTween</h3><p>子类必须实现此方法，使用传入的 TweenVisitor 创建自己对应的 Tween。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> forEachTween(TweenVisitor&lt;<span class="built_in">dynamic</span>&gt; visitor);</span><br></pre></td></tr></table></figure>

<h3 id="didUpdateTweens"><a href="#didUpdateTweens" class="headerlink" title="didUpdateTweens"></a>didUpdateTweens</h3><p>当 Tween 变化时会调用此方法通知子类，子类（可选）可以实现此方法。</p>
<br/>

<p>到目前为止，我们的 AnimationController 已经控制动画开始执行，但是因为<strong>没有监听 AnimationController.value 的变化</strong>，所以还不能自动触发 ImplicitlyAnimatedWidgetState.build()方法。</p>
<p>为了实现动画效果，子类可以选择<strong>自己主动监听 AnimationController</strong>；或者，<strong>继承 AnimatedWidgetBaseState</strong>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimatedWidgetBaseState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ImplicitlyAnimatedWidget</span>&gt; <span class="keyword">extends</span> <span class="title">ImplicitlyAnimatedWidgetState</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 注意此处监听了AnimationController的变化并自动触发setState</span></span><br><span class="line">    controller.addListener(_handleAnimationChanged);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleAnimationChanged() &#123;</span><br><span class="line">    setState(() &#123; <span class="comment">/* The animation ticked. Rebuild with new animation value */</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImplicitlyAnimatedWidget 的子类主要实现 AnimatedWidgetBaseState&#x2F;ImplicitlyAnimatedWidgetState 的<code>forEachTween()</code>和<code>build()</code>方法即可。前者用于生成 Widget 所需的 Tween；后者则使用生成的 Tween&lt;T&gt;的<code>evaluate(animation)</code>方法计算对应的属性并展示。</p>
<p>以 AnimatedPadding 为例，它继承自 ImplicitlyAnimatedWidget，创建的_AnimatedPaddingState 继承自 AnimatedWidgetBaseState&lt;AnimatedPadding&gt;：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimatedPaddingState</span> <span class="keyword">extends</span> <span class="title">AnimatedWidgetBaseState</span>&lt;<span class="title">AnimatedPadding</span>&gt; </span>&#123;</span><br><span class="line">  EdgeInsetsGeometryTween? _padding;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> forEachTween(TweenVisitor&lt;<span class="built_in">dynamic</span>&gt; visitor) &#123;</span><br><span class="line">    <span class="comment">// 创建所需要的Tween</span></span><br><span class="line">    _padding = visitor(_padding, widget.padding, (<span class="built_in">dynamic</span> value) =&gt; EdgeInsetsGeometryTween(begin: value <span class="keyword">as</span> EdgeInsetsGeometry)) <span class="keyword">as</span> EdgeInsetsGeometryTween?;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当AnimationController监听的Ticker时执行setState触发rebuilt</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      <span class="comment">// 使用CurveAnimation计算当前对应的padding值</span></span><br><span class="line">      padding: _padding!</span><br><span class="line">        .evaluate(animation)</span><br><span class="line">        .clamp(EdgeInsets.zero, EdgeInsetsGeometry.infinity),</span><br><span class="line">      child: widget.child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>上述分析是继承 ImplicitlyAnimatedWidget 实现隐式动画的常用流程，Flutter 中内置的 AnimatedFoo 动画都是类似实现。</p>
<h3 id="TweenAnimationBuilder"><a href="#TweenAnimationBuilder" class="headerlink" title="TweenAnimationBuilder"></a>TweenAnimationBuilder</h3><p>ImplicitlyAnimatedWidget 的子类（以 AnimatedFoo 命名的一众子类）提供了常见的动画效果，但是如果有特殊的动画效果需要实现，除了直接继承 ImplicitlyAnimatedWidget 之外，还可以使用 TweenAnimationBuilder 并传入 Tween 来实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> TweenAnimationBuilder&lt;<span class="built_in">double</span>&gt;(</span><br><span class="line">  tween: Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: targetValue),</span><br><span class="line">  duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>),</span><br><span class="line">  builder: (BuildContext context, <span class="built_in">double</span> size, Widget? child) &#123;</span><br><span class="line">    <span class="keyword">return</span> IconButton( ... );</span><br><span class="line">  &#125;,</span><br><span class="line">  child: <span class="keyword">const</span> Icon(Icons.aspect_ratio),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>当 Widget <strong>首次 build 的时候就会触发动画</strong>从 Tween.begin 过渡到 Tween.end；当再次提供一个有<strong>新 end 的 Tween 也可以随时触发新动画</strong>（新动画从动画当前值开始）。</p>
<p>需要注意：</p>
<ul>
<li>传入到 TweenAnimationBuilder 中的 Tween 被其持有（可能修改）,所以不应当再操作它；</li>
<li>当动画执行完毕会调用 TweenAnimationBuilder.onEnd 方法；</li>
<li>为了性能，应当将不需要每次更新的 subtree 传入到 TweenAnimationBuilder.child 中避免重绘。</li>
</ul>
<p>和其他 ImplicitlyAnimatedWidget 的子类一样，TweenAnimationBuilder 的主要逻辑也在继承自 AnimatedWidgetBaseState 的_TweenAnimationBuilderState 中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TweenAnimationBuilderState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>?&gt; <span class="keyword">extends</span> <span class="title">AnimatedWidgetBaseState</span>&lt;<span class="title">TweenAnimationBuilder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  Tween&lt;T&gt;? _currentTween;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// 内部持有使用者传入的Tween</span></span><br><span class="line">    _currentTween = widget.tween;</span><br><span class="line">    _currentTween!.begin ??= _currentTween!.end;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="keyword">if</span> (_currentTween!.begin != _currentTween!.end) &#123;</span><br><span class="line">      <span class="comment">// 如果Tween有效则开始动画</span></span><br><span class="line">      controller.forward();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> forEachTween(TweenVisitor&lt;<span class="built_in">dynamic</span>&gt; visitor) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      widget.tween.end != <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">&#x27;Tween provided to TweenAnimationBuilder must have non-null Tween.end value.&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">    _currentTween = visitor(_currentTween, widget.tween.end, (<span class="built_in">dynamic</span> value) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(<span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">throw</span> StateError(<span class="string">&#x27;Constructor will never be called because null is never provided as current tween.&#x27;</span>);</span><br><span class="line">    &#125;) <span class="keyword">as</span> Tween&lt;T&gt;?;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 使用者实现builder创建对应的Widget</span></span><br><span class="line">    <span class="keyword">return</span> widget.builder(context, _currentTween!.evaluate(animation), widget.child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时需要注意，只有传入 TweenAnimationBuilder 的 Tween 是一个新的、并且 end 值和之前不一样的才会触发动画。如果 end 值一样则无动画、如果不是新的则 builder 的内容只会突然变化为 end 值对应状态而无动画。</p>
<h2 id="AnimatedWidget"><a href="#AnimatedWidget" class="headerlink" title="AnimatedWidget"></a>AnimatedWidget</h2><p>之前分析的 TweenAnimationBuilder 以及 ImplicitlyAnimatedWidget 的其他子类，基本上都只能定义动画的 Tween、Duration、Curve 等，动画的开始结束动都由这些 Widget 内部控制。</p>
<p>如果需要手动主动控制动画，可以选择使用 <strong>显式动画</strong> —— AnimatedWidget 及其子类：</p>
<p>其同样也分为 2 大类：</p>
<ul>
<li>AnimatedBuilder, which is useful for complex animation use cases and a notable exception to the naming scheme of AnimatedWidget subclasses.</li>
<li>FooTransition 子类<ul>
<li>AlignTransition, which is an animated version of Align.</li>
<li>DecoratedBoxTransition, which is an animated version of DecoratedBox.</li>
<li>DefaultTextStyleTransition, which is an animated version of DefaultTextStyle.</li>
<li>PositionedTransition, which is an animated version of Positioned.</li>
<li>RelativePositionedTransition, which is an animated version of Positioned.</li>
<li>RotationTransition, which animates the rotation of a widget.</li>
<li>ScaleTransition, which animates the scale of a widget.</li>
<li>SizeTransition, which animates its own size.</li>
<li>SlideTransition, which animates the position of a widget relative to its normal position.</li>
<li>FadeTransition, which is an animated version of Opacity.</li>
<li>AnimatedModalBarrier, which is an animated version of ModalBarrier.</li>
</ul>
</li>
</ul>
<p>AnimatedWidget 比 ImplicitlyAnimatedWidget 简单许多，其接受一个 Listenable 对象，在_AnimatedState 中监听其并触发 rebuilt。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimatedWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AnimatedWidget(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.listenable,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(listenable != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Commonly an [Animation] or a [ChangeNotifier].</span></span><br><span class="line">  <span class="keyword">final</span> Listenable listenable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供了build方法供子类根据不同的状态创建Widget</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AnimatedWidget.listenable</code>通常是 AnimationController，当然也可以是其他实现 Listenable 的类（including ChangeNotifier and ValueNotifier）。</p>
<h3 id="AnimatedState"><a href="#AnimatedState" class="headerlink" title="_AnimatedState"></a>_AnimatedState</h3><p>AnimatedWidget 的主要逻辑在对应的_AnimatedState 中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimatedState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimatedWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 监听listenable，调用setState从而触发rebuilt</span></span><br><span class="line">    widget.listenable.addListener(_handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(AnimatedWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">    <span class="comment">// 如果listenable改变了则重写添加listener</span></span><br><span class="line">    <span class="keyword">if</span> (widget.listenable != oldWidget.listenable) &#123;</span><br><span class="line">      oldWidget.listenable.removeListener(_handleChange);</span><br><span class="line">      widget.listenable.addListener(_handleChange);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    widget.listenable.removeListener(_handleChange);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleChange() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// The listenable&#x27;s state is our build state, and it changed already.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意这里使用了子类实现的Widget.build方法创建Widget</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; widget.build(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，相对于隐式动画 ImplicitlyAnimatedWidget，显示动画 AnimatedWidget 的逻辑要简单的多，只是监听传入的 Listenable 并触发 rebuilt 即可。对于动画的控制则由 Listenable（通常是 AnimationController）处理。</p>
<p>也就是说，显示动画 AnimatedWidget 只是<strong>替子类做了监听&#x2F;移除监听 Listenable 的值变化，并触发 rebuilt 的工作</strong>，如何获取变化的值，以及展示对应的 Widget 则需要子类自己处理。</p>
<p>他的子类 FooTransition 实现逻辑也比较简单，只需要在在 Widget.build 根据不同的状态创建创建不同属性的 Widget 即可：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RotationTransition</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> RotationTransition(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> Animation&lt;<span class="built_in">double</span>&gt; turns,</span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.filterQuality,</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(turns != <span class="keyword">null</span>),</span><br><span class="line">      <span class="comment">// AnimatedWidget会监听turns的值变化，自动触发rebuilt，</span></span><br><span class="line">      <span class="comment">// 从而调用此build()方法更新Widget</span></span><br><span class="line">       <span class="keyword">super</span>(key: key, listenable: turns);</span><br><span class="line"></span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; <span class="keyword">get</span> turns =&gt; listenable <span class="keyword">as</span> Animation&lt;<span class="built_in">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> FilterQuality? filterQuality;</span><br><span class="line">  <span class="keyword">final</span> Alignment alignment;</span><br><span class="line">  <span class="keyword">final</span> Widget? child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Transform.rotate(</span><br><span class="line">      <span class="comment">// 这里根据turns的值计算当前的角度</span></span><br><span class="line">      angle: turns.value * math.pi * <span class="number">2.0</span>,</span><br><span class="line">      alignment: alignment,</span><br><span class="line">      filterQuality: filterQuality,</span><br><span class="line">      child: child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnimatedBuilder"><a href="#AnimatedBuilder" class="headerlink" title="AnimatedBuilder"></a>AnimatedBuilder</h3><p>一般来说，Flutter 内置的以 FooTransition 命名的 AnimatedWidget 的子类可以满足基本的需求，但是如果想要实现更复杂的效果，除了直接继承 AnimatedWidget 之外，还可以使用 AnimatedBuilder 实现丰富的动画：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AnimatedBuilder(</span><br><span class="line">      animation: _controller,</span><br><span class="line">      child: Container( ... ),</span><br><span class="line">      builder: (BuildContext context, Widget? child) &#123;</span><br><span class="line">        <span class="keyword">return</span> Transform.rotate(</span><br><span class="line">          angle: _controller.value * <span class="number">2.0</span> * math.pi,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>而 AnimatedBuilder 的实现也比较简单：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimatedBuilder</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates an animated builder.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The [animation] and [builder] arguments must not be null.</span></span></span><br><span class="line">  <span class="keyword">const</span> AnimatedBuilder(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> Listenable animation,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(animation != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key, listenable: animation);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Called every time the animation changes value.</span></span></span><br><span class="line">  <span class="keyword">final</span> TransitionBuilder builder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The child widget to pass to the [builder].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">可选，如果AnimatedBuilder要创建的一部分内容和动画无关，为了优化性能，</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">可以将其传给child，并在builder中直接复用</span></span></span><br><span class="line">  <span class="keyword">final</span> Widget? child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> builder(context, child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>ImplicitlyAnimatedWidget 隐式动画</strong>，内部创建并监听 AnimationController 以维护动画，控制动画的开始和结束，用户可以通过传入 Duration、Curve、Tween 等决定动画的时长、曲线、开始和结束值等，当动画相关的属性变化时，隐式动画会自动播放，使用者不可以直接控制动画。<br>Flutter 内置的隐式动画为 TweenAnimationBuilder 和 AnimatedFoo。</p>
<p><strong>AnimatedWidget 显式动画</strong>，接受 Listenable（通常是 AnimationController）并监听其值变化，以触发 Widget 重新 build，其子类中一般会监听 Listenable 的值并计算设置 Widget 对应的属性。使用者需要负责创建、控制 Listenable 从而控制动画播放。Flutter 内置的显式动画为 AnimatedBuilder 和 FooTransition。</p>
<p>在使用Flutter实现<strong>Widget动画</strong>时，可以按照以下顺序选择实现方式：</p>
<ol>
<li>AnimatedFoo，选择内置的隐式动画，以实现当Padding、Alignment等属性变化时自动渐变到新值的动画效果。</li>
<li>TweenAnimationBuilder&#x2F;继承ImplicitlyAnimatedWidget，当上一步无法满足需求时，可以考虑进一步自定义实现隐式动画。</li>
<li>FooTransition，如果不止要展示动画，还希望能够控制动画开始、结束，就使用内置的显式动画结合自己创建的AnimationController实现动画。</li>
<li>AnimationBuilder&#x2F;AnimatedWidget，如果没有满足条件的内置显式动画，可以使用自定义实现显式动画。</li>
<li>CustomPainter，如果上述方法仍然无法满足动画需求，可以考虑使用CustomPainter自己绘制动画。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://flutter.cn/docs/development/ui/animations">动画效果介绍 flutter.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://api.flutter.dev/flutter/widgets/ImplicitlyAnimatedWidget-class.html">ImplicitlyAnimatedWidget</a></p>
<p><a target="_blank" rel="noopener" href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html">AnimatedWidget</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>JI, XIAOYONG
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jixiaoyong.github.io/blog/posts/65caa519/" title="Flutter动画分析之AnimatedWidget &amp; ImplicitlyAnimatedWidget">https://jixiaoyong.github.io/blog/posts/65caa519/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/flutter/" rel="tag"># flutter</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/posts/820d6240/" rel="prev" title="Flutter动画分析之Tween&Curve">
                  <i class="fa fa-chevron-left"></i> Flutter动画分析之Tween&Curve
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JI, XIAOYONG</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>





  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://vercel.xiaoyong.ml","cssUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css","commentCount":true,"pageview":true,"libUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.js","locale":{"placeholder":"ヾ(=^▽^=)ノ"},"meta":["nick","mail","link"],"login":"enable","pageSize":10,"el":"#waline","comment":true,"path":"/blog/posts/65caa519/"}</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
