<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/https/jixiaoyong.github.io/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.ico">
  <link rel="mask-icon" href="/blog/https/jixiaoyong.github.io/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jixiaoyong.github.io","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":true,"version":"8.15.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="本文基于Flutter 3.0  Flutter App基于Dart语言编写，提供了一套简单易用的API，可以让开发者在Flutter中快速开发出一个精美的APP。那么在Flutter中是如何绘制一个APP呢，runApp是怎么将我们编写的Widget等添加到手机上的呢？本文简单从Widget,Element,RenderObjet三者的关系来梳理一下Flutter的绘制过程。 让我们运行一个“">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter APP绘制过程简析">
<meta property="og:url" content="https://jixiaoyong.github.io/blog/posts/4cbcfe72/index.html">
<meta property="og:site_name" content="Ji Xiaoyong&#39;s Blog">
<meta property="og:description" content="本文基于Flutter 3.0  Flutter App基于Dart语言编写，提供了一套简单易用的API，可以让开发者在Flutter中快速开发出一个精美的APP。那么在Flutter中是如何绘制一个APP呢，runApp是怎么将我们编写的Widget等添加到手机上的呢？本文简单从Widget,Element,RenderObjet三者的关系来梳理一下Flutter的绘制过程。 让我们运行一个“">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_hello_center_text.png">
<meta property="og:image" content="https://jixiaoyong.github.io/images/flutter_run_app/heritance_of_widget.png">
<meta property="og:image" content="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_widget_elelemt_renderobject_tree.png">
<meta property="article:published_time" content="2022-06-25T01:03:30.000Z">
<meta property="article:modified_time" content="2023-03-13T12:42:57.666Z">
<meta property="article:author" content="JI, XIAOYONG">
<meta property="article:tag" content="flutter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_hello_center_text.png">


<link rel="canonical" href="https://jixiaoyong.github.io/blog/posts/4cbcfe72/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jixiaoyong.github.io/blog/posts/4cbcfe72/","path":"posts/4cbcfe72/","title":"Flutter APP绘制过程简析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Flutter APP绘制过程简析 | Ji Xiaoyong's Blog</title>
  







<link rel="dns-prefetch" href="https://vercel.xiaoyong.ml">
  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ji Xiaoyong's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#runApp"><span class="nav-text">runApp</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WidgetsFlutterBinding-ensureInitialized"><span class="nav-text">WidgetsFlutterBinding.ensureInitialized()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scheduleAttachRootWidget-app"><span class="nav-text">..scheduleAttachRootWidget(app)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RenderObjectToWidgetAdapter"><span class="nav-text">RenderObjectToWidgetAdapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attachToRenderTree"><span class="nav-text">attachToRenderTree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scheduleWarmUpFrame"><span class="nav-text">..scheduleWarmUpFrame()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RenderView"><span class="nav-text">RenderView</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Center"><span class="nav-text">Center</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#alignment-Alignment-center"><span class="nav-text">alignment: Alignment.center</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#renderObject-RenderPositionedBox"><span class="nav-text">renderObject: RenderPositionedBox</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#widget-Center"><span class="nav-text">_widget: Center</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#child-StatelessElement"><span class="nav-text">_child: StatelessElement</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Text"><span class="nav-text">Text</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RichText"><span class="nav-text">RichText</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JI, XIAOYONG"
      src="//jixiaoyong.github.io/images/default_avatar.jpg">
  <p class="site-author-name" itemprop="name">JI, XIAOYONG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jixiaoyong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jixiaoyong" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jixiaoyong1995@gmail.com" title="E-Mail → mailto:jixiaoyong1995@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jixiaoyong.github.io/blog/posts/4cbcfe72/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//jixiaoyong.github.io/images/default_avatar.jpg">
      <meta itemprop="name" content="JI, XIAOYONG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Flutter APP绘制过程简析 | Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flutter APP绘制过程简析<a href="https://github.com/jixiaoyong/blog_source_code/edit/master/blog/source/_posts/Flutter%20APP%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%E7%AE%80%E6%9E%90.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-25 09:03:30" itemprop="dateCreated datePublished" datetime="2022-06-25T09:03:30+08:00">2022-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-13 20:42:57" itemprop="dateModified" datetime="2023-03-13T20:42:57+08:00">2023-03-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/blog/posts/4cbcfe72/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/blog/posts/4cbcfe72/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/blog/posts/4cbcfe72/"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>本文基于Flutter 3.0</p>
</blockquote>
<p>Flutter App基于Dart语言编写，提供了一套简单易用的API，可以让开发者在Flutter中快速开发出一个精美的APP。那么在Flutter中是如何绘制一个APP呢，runApp是怎么将我们编写的Widget等添加到手机上的呢？本文简单从Widget,Element,RenderObjet三者的关系来梳理一下Flutter的绘制过程。</p>
<p>让我们运行一个“最”简单的Flutter App，分析一下在这个过程中涉及到的Widget、Element、RenderObject这三个tree的关系。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  runApp(<span class="keyword">const</span> Center(</span><br><span class="line">    <span class="comment">// Center非必须，为了让文本居中显得更清晰</span></span><br><span class="line">    child: Text(</span><br><span class="line">      <span class="string">&quot;Hello center text!&quot;</span>,</span><br><span class="line">      textDirection: TextDirection.ltr, <span class="comment">// 文本方向</span></span><br><span class="line">    ),</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的效果如下：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_hello_center_text.png" alt="flutter_run_app_hello_center_text"></p>
<p>让我们使用Flutter DevTools看一下实际生成的Widget Details Tree</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root]</span><br><span class="line"> &gt;renderObject:RenderView#a00a5</span><br><span class="line"></span><br><span class="line"> Center</span><br><span class="line">  alignment:Alignment.center </span><br><span class="line">  widthFactor:null</span><br><span class="line">  heightFactor:null</span><br><span class="line">  &gt;renderObject:RenderPositionedBox#94e0d</span><br><span class="line"></span><br><span class="line">  Text</span><br><span class="line">   &quot;Hello center text!&quot;</span><br><span class="line">   textAlign:null</span><br><span class="line">   textDirection:ltr</span><br><span class="line">   locale:null </span><br><span class="line">   softWrap:null </span><br><span class="line">   overflow:null</span><br><span class="line">   textScaleFactor:null </span><br><span class="line">   maxLines:null </span><br><span class="line">   textWidthBasis:null </span><br><span class="line">   textHeightBehavior:null</span><br><span class="line">   </span><br><span class="line">   RichText</span><br><span class="line">    textDirection:ltr</span><br><span class="line">    softWrap:wrapping at box width </span><br><span class="line">    maxLines:unlimited</span><br><span class="line">    text:&quot;Hello center text!&quot;</span><br><span class="line">    renderObject:RenderParagraph#71aa1</span><br></pre></td></tr></table></figure>

<p>可以看到，除了我们在代码里面添加的Center和Text这两个Widget之外，还多出来好几个Widget&#x2F;RenderObject，当我们仔细查看具体的Widget，可以看到其内部还有XXXElement，BuildOwner之类的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Center</span><br><span class="line"> alignment:Alignment.center </span><br><span class="line"> widthFactor:null</span><br><span class="line"> heightFactor:null</span><br><span class="line"> renderObject:RenderPositionedBox#94e0d </span><br><span class="line"> &gt;_parent:RenderObjectToWidgetElement </span><br><span class="line"> _debugReassembleConfig:null</span><br><span class="line"> _notificationTree:null </span><br><span class="line"> &gt;_slot:Object</span><br><span class="line"> _depth:2 </span><br><span class="line"> &gt;_widget:Center </span><br><span class="line"> &gt;_owner:BuildOwner</span><br><span class="line"> &gt;_lifecycleState:_ElementLifecycle</span><br><span class="line"> &gt;_debugForgottenChildrenWithGlobalKey:_HashSet </span><br><span class="line"> _inheritedWidgets:null</span><br><span class="line"> _dependencies:null</span><br><span class="line"> _hadUnsatisfiedDependencies:true </span><br><span class="line"> _dirty:false</span><br><span class="line"> _inDirtyList:false</span><br><span class="line"> _debugBuiltOnce:false</span><br><span class="line"> _debugA1lowIgnoredCallsToMarkNeedsBuild:false </span><br><span class="line"> _debugDoingBuild:false</span><br><span class="line"> &gt;_ancestorRenderObjectElement:RenderObjectToWidgetElement </span><br><span class="line"> &gt;_child:StatelessElement</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述涉及到的几个类彼此之间到底是什么关系，我们的“<code>Hello center text!</code>”又是怎样才显示到屏幕上的，让我们接下来一个一个分析一下：</p>
<h1 id="runApp"><a href="#runApp" class="headerlink" title="runApp"></a>runApp</h1><p>在执行runApp的时候主要执行了三步</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; \lib\src\widgets\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">	<span class="comment">// 创建render tree的根节点RenderView</span></span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">		<span class="comment">// 将我们的app widget绑定到RenderView</span></span><br><span class="line">    ..scheduleAttachRootWidget(app)</span><br><span class="line">		<span class="comment">// 安排屏幕帧绘制</span></span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WidgetsFlutterBinding-ensureInitialized"><a href="#WidgetsFlutterBinding-ensureInitialized" class="headerlink" title="WidgetsFlutterBinding.ensureInitialized()"></a>WidgetsFlutterBinding.ensureInitialized()</h2><p>创建RenderView具体的逻辑在<code>WidgetsFlutterBinding.ensureInitialized</code>方法中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; \lib\src\widgets\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding._instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ensureInitialized</code>方法中，如果<code>WidgetsBinding._instance</code>为null则会先用构造方法创建，因为<code>WidgetsFlutterBinding</code>继承自BindingBase，所以实际上执行下方的方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\foundation\binding.dart</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> </span>&#123;</span><br><span class="line">	BindingBase() &#123;</span><br><span class="line">    initInstances();</span><br><span class="line">    initServiceExtensions();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了2件事，我们关注<code>initInstances()</code>方法，这个方法的主要逻辑都在他的子类中，也就是之前<code>WidgetsFlutterBinding</code>混合的几个BindingBase子类中，我们关注和屏幕渲染有关的RendererBinding：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\rendering\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The glue between the render tree and the Flutter engine.</span></span></span><br><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 这里创建了PipelineOwner，用来管理rendering pipeline也就是我们app中所有的RenderObject</span></span><br><span class="line">    _pipelineOwner = PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    platformDispatcher</span><br><span class="line">      ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">    <span class="comment">// 注意这里创建了RenderView</span></span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    initMouseTracker();</span><br><span class="line">    <span class="keyword">if</span> (kIsWeb) &#123;</span><br><span class="line">      addPostFrameCallback(_handleWebFirstFrame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a [RenderView] object to be the root of the</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">[RenderObject] rendering tree, and initializes it so that it</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">will be rendered when the next frame is requested.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Called automatically when the binding is created.</span></span></span><br><span class="line">  <span class="keyword">void</span> initRenderView() &#123;</span><br><span class="line">    renderView = RenderView(configuration: createViewConfiguration(), <span class="built_in">window</span>: <span class="built_in">window</span>);</span><br><span class="line">    renderView.prepareInitialFrame();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">set</span> renderView(RenderView value) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(value != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 注意这里，将renderView设置为_pipeline的根节点</span></span><br><span class="line">    _pipelineOwner.rootNode = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要关注两件事：</p>
<ul>
<li><p>创建了用于管理渲染管道的PipelineOwner <code>_pipelineOwner</code></p>
<p>Pipeline是用来管理rendering tree，其内部持有我们的renderView作为rootNode，同时维护了_nodesNeedingLayout，_nodesNeedingCompositingBitsUpdate，_nodesNeedingPaint，_nodesNeedingSemantics四个列表，当flutter framework每次需要往屏幕上绘制内容时会依次遍历这四个列表，将RenderObject绘制到屏幕上面。</p>
</li>
<li><p>创建了rendering tree的根节点<code>renderView</code> ，并将其设置为<code>_pipelineOwner</code>的根节点</p>
</li>
</ul>
<h2 id="scheduleAttachRootWidget-app"><a href="#scheduleAttachRootWidget-app" class="headerlink" title="..scheduleAttachRootWidget(app)"></a>..scheduleAttachRootWidget(app)</h2><p>此方法是<code>WidgetsFlutterBinding</code>的另外一个混合类<code>WidgetsBinding</code>负责具体实现：</p>
<p><code>WidgetsBinding</code>的<code>scheduleAttachRootWidget</code> 方法最后调用了<code>attachRootWidget(Widget rootWidget)</code> ：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The glue between the widgets layer and the Flutter engine.</span></span></span><br><span class="line"><span class="keyword">mixin</span> WidgetsBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将rootWidget绑定到renderViewElement</span></span><br><span class="line"> <span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isBootstrapFrame = renderViewElement == <span class="keyword">null</span>;</span><br><span class="line">    _readyToProduceFrames = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 用于将rootWidget绑定到renderView上面</span></span><br><span class="line">    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">      child: rootWidget,</span><br><span class="line">    )</span><br><span class="line">   <span class="comment">// 在此创建或者使用已有的RenderObjectToWidgetElement，并作为根Element</span></span><br><span class="line">   <span class="comment">// 并将RenderObjectToWidgetAdapter和RenderView与之绑定</span></span><br><span class="line">   <span class="comment">// 这里的_buildOwner在WidgetsBinding.initInstances方法创建，用于管理widget框架的类</span></span><br><span class="line">   .attachToRenderTree(buildOwner!, renderViewElement <span class="keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);</span><br><span class="line">    <span class="keyword">if</span> (isBootstrapFrame) &#123;</span><br><span class="line">      <span class="comment">// 如果是启动框架，就安排更新帧</span></span><br><span class="line">      SchedulerBinding.instance.ensureVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有3步：</p>
<ul>
<li>创建RenderObjectToWidgetAdapter包装RenderView</li>
<li>在<code>attachToRenderTree</code>方法中创建RenderObjectToWidgetElement并<code>mount</code>到element tree中（widget tree实际上并不存在，而是通过element tree管理）</li>
<li>需要的话安排一次frame（刷新页面）</li>
</ul>
<p>还需要注意一个新的角色<code>buildOwner</code>，这个对象全局唯一（一般由parent传给child），在<code>WidgetsBinding.initInstances</code>方法创建，用来管理与Widget tree相关的类，实际上就是通过管理Element的插入，移除，更新来间接管理Widget tree（对应我们在之前遇到的用来管理rendering tree的<code>pipelineOwner</code> ，这两个Owner管理着我们所说的Flutter的Widget&#x2F;Element&#x2F;RenderObject“三”个tree）。</p>
<h3 id="RenderObjectToWidgetAdapter"><a href="#RenderObjectToWidgetAdapter" class="headerlink" title="RenderObjectToWidgetAdapter"></a>RenderObjectToWidgetAdapter</h3><p>前面我们知道<code>renderView</code>其实是一个RenderObject，所以这里为他创建了一个对应的Widget——<code>RenderObjectToWidgetAdapter</code>，其主要作用是将<code>rootWidget</code>（也就是我们最开始写的Center Widget及其child）绑定到之前生成的<code>renderView</code>上面，并将<code>renderView</code>作为自己对应的RenderObject。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\binding.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a bridge from a [RenderObject] to an [Element] tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Used by [WidgetsBinding] to attach the root widget to the [RenderView].</span></span></span><br><span class="line">  RenderObjectToWidgetAdapter(&#123;</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.container,</span><br><span class="line">    <span class="keyword">this</span>.debugShortDescription,</span><br><span class="line">  &#125;) : </span><br><span class="line">   <span class="comment">// 注意这里用container也就是RenderView创建了一个GlobalObjectKey，</span></span><br><span class="line">   <span class="comment">// 在RenderObjectToWidgetElementmount的时候会用到</span></span><br><span class="line">   <span class="keyword">super</span>(key: GlobalObjectKey(container));</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObjectWithChildMixin&lt;T&gt; createRenderObject(BuildContext context) =&gt; container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RenderObjectToWidgetAdapter.createRenderObject</code> 返回的就是<code>container</code> 也就是我们的RenderView。</p>
<h3 id="attachToRenderTree"><a href="#attachToRenderTree" class="headerlink" title="attachToRenderTree"></a>attachToRenderTree</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\binding.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        <span class="comment">// 创建RenderObjectToWidgetElement，并将RenderObjectToWidgetAdapter与之绑定</span></span><br><span class="line">        element = createElement();</span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 创建好Element之后，将BuildOwner与之绑定</span></span><br><span class="line">        element!.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      owner.buildScope(element!, () &#123;</span><br><span class="line">        <span class="comment">// 这里最终会通过updateChild方法将rootWidget对应的Element插入到</span></span><br><span class="line">        <span class="comment">// RenderObjectToWidgetElement下面,在rootWidget中第一个RenderObjectElement</span></span><br><span class="line">        <span class="comment">// 的mount方法中，通过attachRenderObject(newSlot)将自己的renderObject绑定到renderView</span></span><br><span class="line">        element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element!;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RenderObjectToWidgetAdapter</code>在<code>attachToRenderTree</code> 方法中，创建对应的<code>RenderObjectToWidgetElement</code> 与自己绑定，并且同时也将<code>rootWidget</code>和之前创建的rendering tree的根节点<code>renderView</code>绑定。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|— RenderObjectToWidgetAdapter   —|— RenderObjectToWidgetElement  —|— RenderView —|</span><br></pre></td></tr></table></figure>

<p>我们再来看一下<code>RenderObjectToWidgetElement</code>调用的父类<code>RenderObjectElement.mount</code>方法:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="comment">// 本例中这里实际上获取到的是RenderView</span></span><br><span class="line">    _renderObject = (widget <span class="keyword">as</span> RenderObjectWidget).createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将RenderView绑定到指定newSlot(这里是null)中</span></span><br><span class="line">    attachRenderObject(newSlot);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> attachRenderObject(<span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">    _slot = newSlot;</span><br><span class="line">    <span class="comment">// 这里因为RenderView是根节点，所以_ancestorRenderObjectElement和parentDataElement都为null</span></span><br><span class="line">    <span class="comment">// 但是对于RenderView下级的节点，比如本例中的Center Widget，他对应的祖先节点就是持有RenderView</span></span><br><span class="line">    <span class="comment">// 的RenderObjectToWidgetElement，所以这里会将CenterWidget的RenderPositionedBox</span></span><br><span class="line">    <span class="comment">// 作为RenderView的child</span></span><br><span class="line">    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">    _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot);</span><br><span class="line">    <span class="keyword">final</span> ParentDataElement&lt;ParentData&gt;? parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">    <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">      _updateParentData(parentDataElement.widget <span class="keyword">as</span> ParentDataWidget&lt;ParentData&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>此外，还会调用的<code>Element.mount</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="comment">// Element的方法：</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    _parent = parent;</span><br><span class="line">    _slot = newSlot;</span><br><span class="line">    _lifecycleState = _ElementLifecycle.active;</span><br><span class="line">    _depth = _parent != <span class="keyword">null</span> ? _parent!.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Only assign ownership if the parent is non-null. If parent is null</span></span><br><span class="line">      <span class="comment">// (the root node), the owner should have already been assigned.</span></span><br><span class="line">      <span class="comment">// See RootRenderObjectElement.assignOwner().</span></span><br><span class="line">      _owner = parent.owner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(owner != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 这里将RenderObjectToWidgetElement注册到owner中，key是创建RenderObjectToWidgetAdapter时候创建的GlobalObjectKey</span></span><br><span class="line">    <span class="keyword">final</span> Key? key = widget.key;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">      owner!._registerGlobalKey(key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _updateInheritance();</span><br><span class="line">    attachNotificationTree();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里将<code>RenderObjectToWidgetElement</code> 注册到了BuildOwner中</p>
<p>在<code>RenderObjectToWidgetElement</code>的<code>mount</code>方法执行时，除了调用父类的<code>mount</code>方法外，还会触发<code>_rebuild()</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetElement</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RootRenderObjectElement</span> </span>&#123;&#123;</span><br><span class="line">  <span class="built_in">Element?</span> _child;</span><br><span class="line">  <span class="keyword">void</span> _rebuild() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里分析可知,这里的widget即`RenderObjectToWidgetElement` 的widget，也就是</span></span><br><span class="line">  <span class="comment">// `RenderObjectToWidgetAdapter`，他的child也就是rootWidget</span></span><br><span class="line">  <span class="comment">// 所以updateChild传入的值分别是null，RenderObjectToWidgetAdapter.child</span></span><br><span class="line">  <span class="comment">// 会创建rootWidget对应的element并将其作为当前element的child</span></span><br><span class="line">      _child = updateChild(_child, (widget <span class="keyword">as</span> RenderObjectToWidgetAdapter&lt;T&gt;).child, _rootChildSlot);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_rebuild</code>方法中，我们可以看到，在<code>WidgetsBinding.attachRootWidget</code>方法中给RenderObjectToWidgetAdapter作为<code>child</code>参数传入的<code>rootWidget</code>（也即我们示例中的<code>Center</code>Widget），在这里被传入了RenderView对应的RenderObjectToWidgetElement的<code>child</code>中（这里的过程我们下面Center一节再分析），从而将其插入到Flutter的渲染树中。</p>
<p>这样RenderView（<code>RenderObject</code>）就有了对应的<code>Widget</code>和<code>Element</code>，并且有了自己的<code>child</code>。</p>
<h2 id="scheduleWarmUpFrame"><a href="#scheduleWarmUpFrame" class="headerlink" title="..scheduleWarmUpFrame()"></a>..scheduleWarmUpFrame()</h2><p>这个方法则是尽快安排一个frame以便在屏幕下次刷新的时候显示app的内容（在app启动之后的第一次！！！），这样我们的app启动了，我们写的内容也能正常显示到屏幕上。</p>
<p>通过上述分析，我们可以得知，runApp方法执行之后，创建了<code>RenderView</code>对象，并将其作为整个Flutter APP的RenderObject rendering tree的根节点（后续所有的Widget创建的RenderObject都是在RenderView的下层），并且初始化它以便在下一帧的时候对其进行渲染。</p>
<br>

<p>分析完了<code>runApp</code>，我们再来看一下刚刚提到的几个类，以及他们是如何添加到我们的flutter app中的。</p>
<h1 id="RenderView"><a href="#RenderView" class="headerlink" title="RenderView"></a>RenderView</h1><p>先看一下在最顶层的<a target="_blank" rel="noopener" href="https://github.com/flutter/flutter/blob/a0248ebdf20d2befe29cdf325dc7331826151dab/packages/flutter/lib/src/rendering/view.dart#L63">RenderView</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">↓[root]</span><br><span class="line"> &gt;renderObject:RenderView#a00a5</span><br><span class="line"> parent:null</span><br><span class="line"> _debugReassembleConfig:null</span><br><span class="line"> _notificationTree:nul1</span><br><span class="line"> slot:null</span><br><span class="line"> depth:1</span><br><span class="line"> _widget:RenderObjectToWidgetAdapter</span><br><span class="line"> &gt;_owner:BuildOwner</span><br><span class="line"> _lifecycleState:_ElementLifecycle</span><br><span class="line"> _debugForgottenChildrenWithGlobalKey:_HashSet</span><br><span class="line"> _inheritedWidgets:nul1</span><br><span class="line"> _dependencies:null</span><br><span class="line"> _hadUnsatisfiedDependencies:false</span><br><span class="line"> _dirty:false</span><br><span class="line"> _inDirtyList:false</span><br><span class="line"> _debugBuiltOnce:false</span><br><span class="line"> _debugA1lowIgnoredCallsToMarkNeedsBuild:false</span><br><span class="line"> _debugDoingBuild:false</span><br><span class="line"> _ancestorRenderObjectElement:null</span><br><span class="line"> _child:SingleChildRenderObjectElement</span><br><span class="line"> _newWidget:null</span><br></pre></td></tr></table></figure>

<p>查阅源码可知，RenderView是RenderObject，一般情况下是Flutter的根View，表示整个rendering tree的output surface，处理引导着render pipeline。</p>
<p>RenderView有且仅有一个RenderBox类型的<code>child</code>，他会强制将<code>child</code>的<code>size</code>改为RenderView初始化时候的入参<code>configuration</code>的值（一般是当前<code>window</code>也就是<strong>手机屏幕</strong>的逻辑像素<code>size</code>）。</p>
<h1 id="Center"><a href="#Center" class="headerlink" title="Center"></a>Center</h1><p>上节我们说道，Center Widget通过<code>RenderObjectToWidgetElement.updateChild</code>（最终调用Element同名方法）方法插入到渲染树中，下面我们详细分析一下这个过程：</p>
<p>在<code>updateChild</code>中，因为<code>child==null</code>，而<code>newWidget</code>也就是Center不为<code>null</code>，所以直接使用<code>inflateWidget(newWidget, newSlot)</code>创建新的Element并作为RenderObjectToWidgetElement的<code>_child</code>，而作为第一次创建的Center，在<code>Element.inflateWidget</code>方法中大概会执行下面几步：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="comment">// Element的inflateWidget方法：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line"><span class="keyword">return</span> newChild;</span><br></pre></td></tr></table></figure>

<p>也就是这里先执行了<code>Center.createElement</code>方法创建Element，然后调用此<code>Element.mount</code>方法将Element添加到Element tree。</p>
<p>让我们再看一下Center的Widget Details Tree：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Center</span><br><span class="line"> alignment:Alignment.center </span><br><span class="line"> widthFactor:null</span><br><span class="line"> heightFactor:null</span><br><span class="line"> renderObject:RenderPositionedBox#94e0d </span><br><span class="line"> &gt;_parent:RenderObjectToWidgetElement </span><br><span class="line"> _debugReassembleConfig:null</span><br><span class="line"> _notificationTree:null </span><br><span class="line"> &gt;_slot:Object</span><br><span class="line"> _depth:2 </span><br><span class="line"> &gt;_widget:Center </span><br><span class="line"> &gt;_owner:BuildOwner</span><br><span class="line"> &gt;_lifecycleState:_ElementLifecycle</span><br><span class="line"> &gt;_debugForgottenChildrenWithGlobalKey:_HashSet </span><br><span class="line"> _inheritedWidgets:null</span><br><span class="line"> _dependencies:null</span><br><span class="line"> _hadUnsatisfiedDependencies:true </span><br><span class="line"> _dirty:false</span><br><span class="line"> _inDirtyList:false</span><br><span class="line"> _debugBuiltOnce:false</span><br><span class="line"> _debugA1lowIgnoredCallsToMarkNeedsBuild:false </span><br><span class="line"> _debugDoingBuild:false</span><br><span class="line"> &gt;_ancestorRenderObjectElement:RenderObjectToWidgetElement </span><br><span class="line"> &gt;_child:StatelessElement</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到Center的<code>_parent</code>和<code>_ancestorRenderObjectElement</code>是RenderObjectToWidgetElement，<code>_depth</code>是2，这个和我们最初的分析一致，因为Center（其实严格来说，是Center Widget的（或子级的）RenderObject）是RenderView的<code>child</code>。</p>
<p>我们接下来主要关注一下几个属性：</p>
<ul>
<li><code>alignment</code>: Alignment.center</li>
<li><code>renderObject</code>: RenderPositionedBox</li>
<li><code>_widget</code>: Center</li>
<li><code>_child</code>: StatelessElement</li>
</ul>
<p>先看一下Center的源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\basic.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Center</span> <span class="keyword">extends</span> <span class="title">Align</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a widget that centers its child.</span></span></span><br><span class="line">  <span class="keyword">const</span> Center(&#123; Key? key, <span class="built_in">double?</span> widthFactor, <span class="built_in">double?</span> heightFactor, Widget? child &#125;)</span><br><span class="line">    : <span class="keyword">super</span>(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Center代码十分简单，主要的逻辑在他的父类Align中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\basic.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Align</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> Align(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="comment">// 这里alignment默认是居中</span></span><br><span class="line">    <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">    <span class="keyword">this</span>.widthFactor,</span><br><span class="line">    <span class="keyword">this</span>.heightFactor,</span><br><span class="line">    Widget? child,</span><br><span class="line">    &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderPositionedBox createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// Center的父类可以创建自己的RenderObject</span></span><br><span class="line">    <span class="keyword">return</span> RenderPositionedBox(</span><br><span class="line">      alignment: alignment,</span><br><span class="line">      widthFactor: widthFactor,</span><br><span class="line">      heightFactor: heightFactor,</span><br><span class="line">      textDirection: Directionality.maybeOf(context),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderPositionedBox renderObject) &#123;</span><br><span class="line">    renderObject</span><br><span class="line">      ..alignment = alignment</span><br><span class="line">      ..widthFactor = widthFactor</span><br><span class="line">      ..heightFactor = heightFactor</span><br><span class="line">      ..textDirection = Directionality.maybeOf(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Align其实是一个<code>SingleChildRenderObjectWidget</code> ,对应的Element是<code>SingleChildRenderObjectElement</code>，他创建的RenderObject是<code>RenderPositionedBox</code> 。</p>
<p><code>SingleChildRenderObjectElement</code> 是一个<code>RenderObjectElement</code> 也就意味着他在rendering tree有一个关联的RenderObject负责layout，painting以及hit-test。</p>
<p>回到我们的Center Widget中：</p>
<h2 id="alignment-Alignment-center"><a href="#alignment-Alignment-center" class="headerlink" title="alignment: Alignment.center"></a><strong>alignment: Alignment.center</strong></h2><p><strong>Alignment.center</strong>是在创建Center的时候默认设置的对齐方式</p>
<h2 id="renderObject-RenderPositionedBox"><a href="#renderObject-RenderPositionedBox" class="headerlink" title="renderObject: RenderPositionedBox"></a><strong>renderObject: RenderPositionedBox</strong></h2><p><strong>RenderPositionedBox</strong>是Center Widget对应的RenderObject，在<code>SingleChildRenderObjectWidget.mount</code> 的时候创建。其本身并不在屏幕上绘制肉眼可见的内容，而是将child按照指定的对齐方式进行定位。</p>
<p><code>RenderPositionedBox</code> 的继承关系：<code>RenderPositionedBox</code> → <code>RenderAligningShiftedBox</code> → <code>RenderShiftedBox</code> → <code>RenderBox</code> → <code>RenderObject</code></p>
<p><strong>RenderPositionedBox</strong>可以按照给定的<code>AlignmentGeometry</code>定位child。在本例中，他的几个属性如下：</p>
<ul>
<li><code>alignment</code>: Alignment.center</li>
<li><code>_owner</code>: PipelineOwner</li>
<li><code>_parent</code>: RenderView</li>
<li><code>_child</code>: RenderParagraph</li>
</ul>
<p>前三个属性含义很明显，这里我们注意到他的<code>_child</code>并不是我们预期的<code>Text</code>，这个原因我们后面再分析。</p>
<h2 id="widget-Center"><a href="#widget-Center" class="headerlink" title="_widget: Center"></a><strong>_widget: Center</strong></h2><p>其实通过上述的分析，我们应该已经知道，我们在Widget Details Tree中看到的Center其实是Center Widget对应的Element，也就是<code>SingleChildRenderObjectElement</code> 。</p>
<p>其继承关系：<code>SingleChildRenderObjectElement</code> → <code>RenderObjectElement</code> → <code>Element</code></p>
<p>根据Element的定义，这里的Widget是在Widget创建<code>SingleChildRenderObjectElement</code>的时候传入的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Element</span>(Widget widget)</span><br><span class="line">    : <span class="keyword">assert</span>(widget != <span class="keyword">null</span>),</span><br><span class="line">      _widget = widget;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Abstract const constructor. This constructor enables subclasses to provide</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">const constructors so that they can be used in const expressions.</span></span></span><br><span class="line">  <span class="keyword">const</span> SingleChildRenderObjectWidget(&#123; Key? key, <span class="keyword">this</span>.child &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">The widget below this widget in the tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">&#123;@macro flutter.widgets.ProxyWidget.child&#125;</span></span></span><br><span class="line">  <span class="keyword">final</span> Widget? child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  SingleChildRenderObjectElement createElement() =&gt; SingleChildRenderObjectElement(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个Element在上述<code>WidgetsBinding.attachRootWidget</code>步骤中通过一系列操作，最终在RenderObjectToWidgetElement的<code>updateChild</code>方法被创建并被<code>BuildOwner</code> 插入到tree中。</p>
<p>这里的<code>_widget</code>才真正对应着我们在<code>runApp</code>里面传入的Center Widget，他的<code>child</code>也正是我们的Text。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Center</span><br><span class="line"> alignment:Alignment.center</span><br><span class="line"> widthFactor:null</span><br><span class="line"> heightFactor:null</span><br><span class="line"> &gt;renderObject:RenderPositionedBox#6e802</span><br><span class="line"> &gt;_parent:RenderObjectToWidgetElement</span><br><span class="line"> _debugReassembleConfig:null</span><br><span class="line"> _notificationTree:null</span><br><span class="line"> _slot:Object</span><br><span class="line"> denth:2 _</span><br><span class="line"> [[[widget:Center]]] //注意这里</span><br><span class="line">  key:null</span><br><span class="line">  location:_Location</span><br><span class="line">  [[[child:Text]]] //注意这里</span><br><span class="line">   key:null</span><br><span class="line">   &gt;_location:_Location</span><br><span class="line">   data:&#x27;Hello center text!&#x27;</span><br><span class="line">   textSpan:null</span><br><span class="line">   style:null</span><br><span class="line">   strutStyle:null</span><br><span class="line">   textAlign:null</span><br><span class="line">   &gt;textDirection:TextDirection</span><br><span class="line">   locale:null</span><br><span class="line">   softWrap:null</span><br><span class="line">   overflow:null</span><br><span class="line">   textScaleFactor:null</span><br><span class="line">   maxLines:null</span><br><span class="line">   semanticsLabel:null</span><br><span class="line">   textWidthBasis:null</span><br><span class="line">   textHeightBehavior:null</span><br><span class="line">  &gt;alignment:Alignment</span><br><span class="line">  widthFactor:null</span><br><span class="line">  heightFactor:nul1</span><br><span class="line"> &gt;_owner:BuildOwner</span><br></pre></td></tr></table></figure>

<h2 id="child-StatelessElement"><a href="#child-StatelessElement" class="headerlink" title="_child: StatelessElement"></a><strong>_child: StatelessElement</strong></h2><p>Center对应的Element的<code>_child</code>是一个StatelessElement，按照我们上一步的分析，StatelessElement应该是Text Widget创建，事实也确实如此：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">↓_child: StatelessElement</span><br><span class="line"> &gt;_parent: SingleChildRenderObjectElement</span><br><span class="line"> debugReassembleConfig： null</span><br><span class="line"> _notificationTree: null</span><br><span class="line"> slot: null</span><br><span class="line"> depth: 3</span><br><span class="line"> &gt;_widget: Text</span><br><span class="line"> &gt;_owner: BuildOwner</span><br><span class="line"> &gt;_lifecycleState: _ElementLifecycle</span><br><span class="line"> &gt;_debugForgottenChildrenWithGlobalKey: _HashSet</span><br><span class="line"> _inheritedWidgets: null</span><br><span class="line"> dependencies: null</span><br><span class="line"> _hadUnsatisfiedDependencies: true</span><br><span class="line"> _dirty: false</span><br><span class="line"> _inDirtyList: false</span><br><span class="line"> debugBuiltOnce: false</span><br><span class="line"> _debugAllowIgnoredCallsToMarkNeedsBuild: false</span><br><span class="line"> &gt;_child: MultichildRenderObjectElement</span><br><span class="line"> debugDoingBuild: false</span><br></pre></td></tr></table></figure>

<p>让我们分析一下这个<code>_child</code>的赋值过程：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _child = updateChild(_child, (widget <span class="keyword">as</span> SingleChildRenderObjectWidget).child, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Center对应的Element——<code>SingleChildRenderObjectElement</code> 在<code>mount</code>的时候，同时也会更新<code>child</code>（本例中Center的<code>child</code>是Text），这里调用的是Element的<code>updateChild</code>方法，他的逻辑如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|                     | **newWidget == <span class="keyword">null</span>**  | **newWidget != <span class="keyword">null</span>**   |</span><br><span class="line">| :-----------------: | :--------------------- | :---------------------- |</span><br><span class="line">|  **child == <span class="keyword">null</span>**  |  Returns <span class="keyword">null</span>.         |  Returns <span class="keyword">new</span> [<span class="built_in">Element</span>]. |</span><br><span class="line">|  **child != <span class="keyword">null</span>**  |  Old child <span class="keyword">is</span> removed, returns <span class="keyword">null</span>. | Old child updated <span class="keyword">if</span> possible, returns child or <span class="keyword">new</span> [<span class="built_in">Element</span>]. |</span><br></pre></td></tr></table></figure>

<p><code>updateChild</code>的逻辑分为4种情况：其余情况都比较简单，只有<code>newWidget != null</code>或者<code>child != null</code>的时候需要判断一下，如果可以更新就更新否则就创建新的Element，可以分为下面这几种情况：</p>
<ul>
<li><code>child.widget == newWidget</code>：两个是同一个对象，就只更新<code>child</code>的<code>slot</code></li>
<li><code>Widget.canUpdate(child.widget, newWidget)</code>：二者的<code>runtimeType</code>和<code>key</code>一样，就调用<code>child.update(newWidget)</code>更新<code>child._widget</code>，必要时更新<code>child</code>的<code>slot</code></li>
<li>否则创建新的<code>element</code>并替代</li>
</ul>
<p>到这里跟Center插入到render tree的步骤一样，将Text插入到了tree中。</p>
<h1 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h1><p>接下来我们分析一下Text是如何被加入Widget Details Tree的。</p>
<p>其继承关系：<code>Text</code> → <code>StatelessWidget</code> → <code>Widget</code></p>
<p>Text是StatelessWidget，他的内容比较简单，主要的逻辑都在<code>build</code>方法中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; \lib\src\widgets\text.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Text(</span><br><span class="line">    <span class="built_in">String</span> <span class="keyword">this</span>.data, &#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    ...</span><br><span class="line">  &#125;) : </span><br><span class="line">       textSpan = <span class="keyword">null</span>,</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultTextStyle defaultTextStyle = DefaultTextStyle.of(context);</span><br><span class="line">    TextStyle? effectiveTextStyle = style;</span><br><span class="line">    <span class="keyword">if</span> (style == <span class="keyword">null</span> || style!.inherit)</span><br><span class="line">      effectiveTextStyle = defaultTextStyle.style.merge(style);</span><br><span class="line">    <span class="keyword">if</span> (MediaQuery.boldTextOverride(context))</span><br><span class="line">      effectiveTextStyle = effectiveTextStyle!.merge(<span class="keyword">const</span> TextStyle(fontWeight: FontWeight.bold));</span><br><span class="line">    <span class="comment">// 注意这里返回了RichText</span></span><br><span class="line">    Widget result = RichText(</span><br><span class="line">      textAlign: textAlign ?? defaultTextStyle.textAlign ?? TextAlign.start,</span><br><span class="line">      textDirection: textDirection, <span class="comment">// RichText uses Directionality.of to obtain a default if this is null.</span></span><br><span class="line">      ...</span><br><span class="line">      text: TextSpan(</span><br><span class="line">        style: effectiveTextStyle,</span><br><span class="line">        text: data,</span><br><span class="line">        children: textSpan != <span class="keyword">null</span> ? &lt;InlineSpan&gt;[textSpan!] : <span class="keyword">null</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，作为StatelessWidget，他也创建了一个<code>StatelessElement</code> ：</p>
<p>其继承关系：<code>StatelessElement</code> → <code>ComponentElement</code> → <code>Element</code></p>
<p>按照之前的分析，Text插入到tree中执行的方法分别是<code>Text.createElement</code>和Text对应的Element——<code>StatelessElement.mount</code>方法：</p>
<p>Text是StatelessWidget的子类，他的主要逻辑都在StatelessWidget：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> StatelessWidget(&#123; Key? key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatelessElement createElement() =&gt; StatelessElement(<span class="keyword">this</span>);</span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其<code>createElement</code>创建的是StatelessElement，也就是说Text插入到Center过程主要在StatelessElement中。</p>
<p><code>StatelessElement.mount</code>方法主要逻辑在ComponentElement中，这个方法除了调用Element同名方法外，还调用了<code>ComponentElement._firstBuild()</code> → <code>Element.rebuild()</code> → <code>ComponentElement.performRebuild()</code> ：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="comment">// ComponentElement类中的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    Widget? built;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里调用Element对应的Widget的build方法创建Widget，也就是RichText</span></span><br><span class="line">      built = build();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// We delay marking the element as clean until after calling build() so</span></span><br><span class="line">      <span class="comment">// that attempts to markNeedsBuild() during build() will be ignored.</span></span><br><span class="line">      _dirty = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">assert</span>(_debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将上述创建的Widget：built经过处理后赋值给Element的_child</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, built, slot);</span><br><span class="line">      <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      built = ErrorWidget.builder(...);</span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, built, slot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要有两个步骤：</p>
<ul>
<li>调用<code>ComponentElement.build</code>方法，生产Widget（本例中，间接调用了Text的<code>build</code>方法）</li>
<li>调用<code>ComponentElement.updateChild</code>方法，更新<code>child</code>（最终执行的是Element同名方法逻辑）</li>
</ul>
<p>到目前为止，我们的Widget&#x2F;Element&#x2F;RenderObject tree如下（第四级RichText下面再分析）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**Widget**:       RenderObjectToWidgetAdapter → Center                         → Text              → *RichText*</span><br><span class="line"></span><br><span class="line">**<span class="built_in">Element</span>**:      RenderObjectToWidgetElement → SingleChildRenderObjectElement → StatelessElement  → *MultiChildRenderObjectElement*</span><br><span class="line"></span><br><span class="line">**RenderObject**: RenderView                  → RenderPositionedBox            → [X]               → *RenderParagraph*</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line"><span class="number">1.</span> 这里的[X]实际上不存在，只是为了和Text对应表示这里本应该有一个对应的RenderObject</span><br><span class="line"><span class="number">2.</span> 最后一列*RichText*对应的节点目前还没有分析到，此处仅做提前展示</span><br></pre></td></tr></table></figure>

<p>不难看出，在从定往下数第三层也就是Text对应的这一级中，RenderObject tree这里并没有对应的对象，在上面的分析中，我们也看到了StatelessWidget本身并没有创建RenderObject的方法。实际上，Widget分为多个种类，只有RenderObject类及其子类才会创建RenderObject：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_run_app/heritance_of_widget.png" alt="Untitled"></p>
<h2 id="RichText"><a href="#RichText" class="headerlink" title="RichText"></a>RichText</h2><p>终于到了我们这个app真正在屏幕上显示的内容这里了，上面我们分析到，Text作为StatelessWidget，本身并不会产生可以在屏幕上绘制的RenderObject，而是通过他的<code>build</code>方法返回一个可以产生RenderObject的Widget，在本例中，这个Widget就是RichText：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\basic.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichText</span> <span class="keyword">extends</span> <span class="title">MultiChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">  RenderParagraph createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(textDirection != <span class="keyword">null</span> || debugCheckHasDirectionality(context));</span><br><span class="line">    <span class="keyword">return</span> RenderParagraph(text,</span><br><span class="line">      textAlign: textAlign,</span><br><span class="line">      textDirection: textDirection ?? Directionality.of(context),</span><br><span class="line">      softWrap: softWrap,</span><br><span class="line">      overflow: overflow,</span><br><span class="line">      textScaleFactor: textScaleFactor,</span><br><span class="line">      maxLines: maxLines,</span><br><span class="line">      strutStyle: strutStyle,</span><br><span class="line">      textWidthBasis: textWidthBasis,</span><br><span class="line">      textHeightBehavior: textHeightBehavior,</span><br><span class="line">      locale: locale ?? Localizations.maybeLocaleOf(context),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RichText继承自<code>MultiChildRenderObjectWidget</code> ，如上节分析的，是一种<code>RenderObjectWidget</code>，它创建了真正在屏幕上渲染的RenderObject——<code>RenderParagraph</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\rendering\paragraph.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderParagraph</span> <span class="keyword">extends</span> <span class="title">RenderBox</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">ContainerRenderObjectMixin</span>&lt;<span class="title">RenderBox</span>, <span class="title">TextParentData</span>&gt;,</span></span><br><span class="line"><span class="class">             <span class="title">RenderBoxContainerDefaultsMixin</span>&lt;<span class="title">RenderBox</span>, <span class="title">TextParentData</span>&gt;,</span></span><br><span class="line"><span class="class">                  <span class="title">RelayoutWhenSystemFontsChangeMixin</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面说道，Text本身作为StatelessWidget并不产生RenderObject，那么这里的RenderParagraph是如何找到并插入到rendering tree中的呢？</p>
<p>带着这个疑问，我们看一下<code>MultiChildRenderObjectWidget</code> 创建的<code>MultiChildRenderObjectElement</code> ：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="keyword">final</span> MultiChildRenderObjectWidget multiChildRenderObjectWidget = widget <span class="keyword">as</span> MultiChildRenderObjectWidget;</span><br><span class="line">    <span class="comment">// 本例中不涉及children</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; children = <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt;.filled(multiChildRenderObjectWidget.children.length, _NullElement.instance);</span><br><span class="line">    <span class="built_in">Element?</span> previousChild;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; children.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> newChild = inflateWidget(multiChildRenderObjectWidget.children[i], IndexedSlot&lt;<span class="built_in">Element?</span>&gt;(i, previousChild));</span><br><span class="line">      children[i] = newChild;</span><br><span class="line">      previousChild = newChild;</span><br><span class="line">    &#125;</span><br><span class="line">    _children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，在MultiChildRenderObjectElement的<code>mount</code>方法中：</p>
<ul>
<li>调用父类<code>mount</code>方法</li>
<li>遍历了所有的<code>children</code>将其插入到MultiChildRenderObjectElement中。</li>
</ul>
<p>在前面的Text源码中，我们注意到给只给<code>RichText.text</code>赋值了，RichText的<code>textSpan</code>和<code>children</code>都是<code>null</code>，所以后面对<code>children</code>的处理在本例中不涉及，让我们看一下<code>super.mount(parent, newSlot)</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="comment">// 这里调用对应的RenderObjectWidget创建_renderObject</span></span><br><span class="line">    _renderObject = (widget <span class="keyword">as</span> RenderObjectWidget).createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将其绑定到rendering tree中</span></span><br><span class="line">    attachRenderObject(newSlot);</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有2步：</p>
<ul>
<li>通过<code>widget.createRenderObject</code> 创建<code>_renderObject</code>，本例中就是用RichText创建了RenderParagraph</li>
<li>调用<code>RenderObjectElement.attachRenderObject</code>方法将<code>_renderObject</code>插入到rendering tree</li>
</ul>
<p>让我们看一下attachRenderObject的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="comment">// RenderObjectElement类的方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> attachRenderObject(<span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">    _slot = newSlot;</span><br><span class="line">    <span class="comment">// 向上遍历，找到父级节点中最近的RenderObjectElement</span></span><br><span class="line">    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">    <span class="comment">// 将renderObject插入</span></span><br><span class="line">    _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot);</span><br><span class="line">    <span class="keyword">final</span> ParentDataElement&lt;ParentData&gt;? parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">    <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">      _updateParentData(parentDataElement.widget <span class="keyword">as</span> ParentDataWidget&lt;ParentData&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RenderObjectElement? _findAncestorRenderObjectElement() &#123;</span><br><span class="line">    <span class="built_in">Element?</span> ancestor = _parent;</span><br><span class="line">    <span class="keyword">while</span> (ancestor != <span class="keyword">null</span> &amp;&amp; ancestor <span class="keyword">is</span>! RenderObjectElement)</span><br><span class="line">      ancestor = ancestor._parent;</span><br><span class="line">    <span class="keyword">return</span> ancestor <span class="keyword">as</span> RenderObjectElement?;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>attachRenderObject</code>方法中插入的方式很简单：先在当前tree中向上找到父级中离得最近的RenderObjectElement，在本例中是Center这个Widget对应的SingleChildRenderObjectElement（注意不是创建RichText的Text），然后调用其<code>insertRenderObjectChild</code>方法将当前的RenderParagraph插入到rendering tree中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; lib\src\widgets\framework.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> insertRenderObjectChild(RenderObject child, <span class="built_in">Object?</span> slot) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObjectWithChildMixin&lt;RenderObject&gt; renderObject = <span class="keyword">this</span>.renderObject <span class="keyword">as</span> RenderObjectWithChildMixin&lt;RenderObject&gt;;</span><br><span class="line">    renderObject.child = child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SingleChildRenderObjectElement的<code>insertRenderObjectChild</code>方法中先是查找当前Element持有的<code>renderObject</code>,然后将我们传入的RichText的RenderObject——RenderParagraph赋值给<code>renderObject.child</code>。</p>
<p>到这里，我们的所有Widget在Element的组织下，将对于的RenderObject添加到Rendering Tree中，他们的关系如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**Widget**:       RenderObjectToWidgetAdapter → Center                         → Text              → RichText</span><br><span class="line"></span><br><span class="line">**<span class="built_in">Element</span>**:      RenderObjectToWidgetElement → SingleChildRenderObjectElement → StatelessElement  → MultiChildRenderObjectElement</span><br><span class="line"></span><br><span class="line">**RenderObject**: RenderView                  → RenderPositionedBox                                → RenderParagraph</span><br></pre></td></tr></table></figure>

<p>这样，当屏幕刷新的时候，这些内容便绘制在屏幕上面。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在<code>runApp</code>方法中，WidgetsFlutterBinding作为将flutter framework绑定到flutter engine的粘合剂：</p>
<ul>
<li><p>在<code>ensureInitialized</code>方法中创建了<code>_pipelineOwner</code>（管理rendering tree）、<code>renderView</code>和<code>buildOwner</code>（通过管理Element tree间接管理widget tree），并将<code>renderView</code>设置为<code>_pipelineOwner</code>的根节点。</p>
</li>
<li><p>在<code>scheduleAttachRootWidget</code>方法中，为<code>renderView</code>创建并绑定了对应的Widget（RenderObjectToWidgetAdapter）和Element（RenderObjectToWidgetElement）。然后通过<code>RenderObjectToWidgetElement.mount</code>方法，将之前创建的<code>buildOwner</code>与自己绑定。</p>
<p>并且将我们在<code>runApp</code>传入的Widget<code>rootWidget</code>（也就是本例中的Center Widget）对应的Element添加为RenderObjectToWidgetElement的子节点。并依此将Text、Text内部的RichText等对应的Element都加入到Element tree中，直到遍历完整个Widget tree。</p>
</li>
<li><p>在<code>scheduleWarmUpFrame</code>方法中安排在下一次屏幕刷新的时候将我们的内容展示在屏幕上面。</p>
</li>
</ul>
<p>下面是我们这个“最”简单的Flutter App的结构示意：</p>
<p><img src="https://jixiaoyong.github.io/images/flutter_run_app/flutter_run_app_widget_elelemt_renderobject_tree.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://api.flutter.dev/">Flutter - Dart API docs</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=PnWxW21vDak">Flutter, what are Widgets, RenderObjects and Elements? - Norbert Kozsir | Flutter Europe</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FU2Eeizo95o&ab_channel=RetroPortalStudio">Flutter Widgets Explained | Understand How Flutter Works!</a></p>
<p><a target="_blank" rel="noopener" href="http://zxfcumtcs.github.io/2020/12/05/deepinto-flutter-pipelineowner/">深入浅出 Flutter Framework 之 PipelineOwner</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>JI, XIAOYONG
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jixiaoyong.github.io/blog/posts/4cbcfe72/" title="Flutter APP绘制过程简析">https://jixiaoyong.github.io/blog/posts/4cbcfe72/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/flutter/" rel="tag"># flutter</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/posts/db62c118/" rel="prev" title="Dart event loop">
                  <i class="fa fa-chevron-left"></i> Dart event loop
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/posts/d3bdcb53/" rel="next" title="Flutter滑动分析之SingleChildScrollView">
                  Flutter滑动分析之SingleChildScrollView <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JI, XIAOYONG</span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>





  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://vercel.xiaoyong.ml","cssUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css","commentCount":true,"pageview":true,"libUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.js","locale":{"placeholder":"ヾ(=^▽^=)ノ"},"meta":["nick","mail","link"],"login":"enable","pageSize":10,"el":"#waline","comment":true,"path":"/blog/posts/4cbcfe72/"}</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
