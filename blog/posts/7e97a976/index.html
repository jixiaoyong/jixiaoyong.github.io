<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/https/jixiaoyong.github.io/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.ico">
  <link rel="mask-icon" href="/blog/https/jixiaoyong.github.io/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jixiaoyong.github.io","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":true,"version":"8.14.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Android中的跨进程通信IPC主要有以下几种方式：  BroadcastReceiver ContentProvider AIDL Messenger Socket 文件  Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制 进程是资源分配的基本单位，线程是调度的基本单位。 一些基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Android笔记之跨进程通信">
<meta property="og:url" content="https://jixiaoyong.github.io/blog/posts/7e97a976/index.html">
<meta property="og:site_name" content="Ji Xiaoyong&#39;s Blog">
<meta property="og:description" content="Android中的跨进程通信IPC主要有以下几种方式：  BroadcastReceiver ContentProvider AIDL Messenger Socket 文件  Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制 进程是资源分配的基本单位，线程是调度的基本单位。 一些基础知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jixiaoyong.github.io/images/20200422114446.png">
<meta property="og:image" content="https://jixiaoyong.github.io/images/20200422114721.jpg">
<meta property="og:image" content="https://jixiaoyong.github.io/images/20200422115508.gif">
<meta property="og:image" content="https://jixiaoyong.github.io/images/20200422115253.png">
<meta property="og:image" content="https://jixiaoyong.github.io/images/20200422115031.jpg">
<meta property="og:image" content="https://jixiaoyong.github.io/images/20200422114923.jpg">
<meta property="article:published_time" content="2019-12-26T10:52:54.000Z">
<meta property="article:modified_time" content="2022-12-13T09:09:08.807Z">
<meta property="article:author" content="JI, XIAOYONG">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jixiaoyong.github.io/images/20200422114446.png">


<link rel="canonical" href="https://jixiaoyong.github.io/blog/posts/7e97a976/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jixiaoyong.github.io/blog/posts/7e97a976/","path":"posts/7e97a976/","title":"Android笔记之跨进程通信"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android笔记之跨进程通信 | Ji Xiaoyong's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>
<link rel="dns-prefetch" href="https://vercel.xiaoyong.ml">
  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ji Xiaoyong's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">一些基础知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-IPC"><span class="nav-text">linux IPC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binder"><span class="nav-text">Binder</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#others"><span class="nav-text">others</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JI, XIAOYONG"
      src="//jixiaoyong.github.io/images/default_avatar.jpg">
  <p class="site-author-name" itemprop="name">JI, XIAOYONG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jixiaoyong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jixiaoyong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jixiaoyong1995@gmail.com" title="E-Mail → mailto:jixiaoyong1995@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jixiaoyong.github.io/blog/posts/7e97a976/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//jixiaoyong.github.io/images/default_avatar.jpg">
      <meta itemprop="name" content="JI, XIAOYONG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android笔记之跨进程通信 | Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android笔记之跨进程通信<a href="https://github.com/jixiaoyong/blog_source_code/edit/master/blog/source/_posts/Android%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-26 18:52:54" itemprop="dateCreated datePublished" datetime="2019-12-26T18:52:54+08:00">2019-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-12-13 17:09:08" itemprop="dateModified" datetime="2022-12-13T17:09:08+08:00">2022-12-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/blog/posts/7e97a976/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/blog/posts/7e97a976/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/blog/posts/7e97a976/"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Android中的跨进程通信IPC主要有以下几种方式：</p>
<ul>
<li>BroadcastReceiver</li>
<li>ContentProvider</li>
<li>AIDL</li>
<li>Messenger</li>
<li>Socket</li>
<li>文件</li>
</ul>
<p>Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制</p>
<p><strong>进程是资源分配的基本单位，线程是调度的基本单位。</strong></p>
<h1 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h1><p> 以下内容来自：</p>
<p>作者：SylvanasSun<br>链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/59f8691b51882534af254317">https://juejin.im/post/59f8691b51882534af254317</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>Linux为每个进程维护了一个单独的虚拟地址空间。<strong>虚拟地址空间分为内核空间与用户空间</strong>，用户空间包括代码、数据、堆、共享库以及栈，内核空间包括内核中的代码和数据结构，内核空间的某些区域被映射到所有进程共享的物理页面。Linux也将一组连续的虚拟页面（大小等于内存总量）映射到相应的一组连续的物理页面，这种做法为内核提供了一种便利的方法来访问物理内存中任何特定的位置。</p>
<p><img src="https://jixiaoyong.github.io/images/20200422114446.png" alt="示意图来自https://juejin.im/post/59f8691b51882534af254317"></p>
<p>Linux通过将一个虚拟内存区域与一个硬盘上的文件关联起来，以初始化这个虚拟内存区域的内容，这个过程称为<strong>内存映射</strong>（memory mapping）。这种将虚拟内存系统集成到文件系统的方法可以简单而高效地把程序和数据加载到内存中。</p>
<p><strong>普通文件映射就是将一个文件与一块内存建立起映射关系，对该文件进行IO操作可以绕过内核直接在用户态完成（用户态在该虚拟地址区域读写就相当于读写这个文件）</strong>。匿名文件映射一般在用户空间需要分配一段内存来存放数据时，由内核创建匿名文件并与内存进行映射，之后用户态就可以通过操作这段虚拟地址来操作内存了。匿名文件映射最熟悉的应用场景就是动态内存分配（malloc()函数）。</p>
<p><strong>内存映射提供了共享对象的机制，来避免内存资源的浪费。一个对象被映射到虚拟内存的一个区域，要么是作为共享对象，要么是作为私有对象的。</strong> 进程对共享对象的写操作对于其他也使用到该共享对象的进程是可见的。</p>
<p>CPU获取到虚拟地址，然后通过MMU（内存管理单元）将其翻译为物理地址。</p>
<h1 id="linux-IPC"><a href="#linux-IPC" class="headerlink" title="linux IPC"></a>linux IPC</h1><p>优缺点参考：</p>
<blockquote>
<ol>
<li>管道：在创建时分配一个page大小的内存，缓存区大小比较有限；</li>
<li>消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li>
<li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li>套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li>
<li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ol>
<p>作者：Gityuan<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39440766/answer/89210950">https://www.zhihu.com/question/39440766/answer/89210950</a></p>
</blockquote>
<ul>
<li>管道Pipe</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)">管道</a> 是将标准输入输出连接起来的进程。 <strong>数据复制2次，有长度限制</strong></p>
<p><img src="https://jixiaoyong.github.io/images/20200422114721.jpg" alt="示意图来自https://pic002.cnblogs.com/images/2012/426620/2012110216160766.jpg"></p>
<p>如图，进程1将数据<strong>写入</strong>到管道（内存缓存区），进程2从管道中<strong>读取</strong>数据。数据从写端流入管道，从读端流出，这样就实现了进程间通信</p>
<p>每个进程的输出被当做下一个进程的输入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | less //将ls -l 的结果输入到less中，实现分页</span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html">Linux进程间通信之管道(pipe)、命名管道(FIFO)与信号(Signal)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/skyroben/article/details/71513385">https://blog.csdn.net/skyroben/article/details/71513385</a></p>
<ul>
<li>消息队列Message</li>
</ul>
<p>是一串可以有不同类型的消息块的链表，可以避免阻塞。<strong>数据复制2次，有长度限制</strong>，缓冲小。</p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html">https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html</a></p>
<ul>
<li>共享内存</li>
</ul>
<p>多个进程可以访问一个公用的内存空间。效率最高的IPC。<strong>数据内存复制0次,但是没有同步互斥机制</strong></p>
<ul>
<li>套接字Socket</li>
</ul>
<p>传输效率低，<strong>数据复制2次</strong></p>
<ul>
<li>信号量 semaphore</li>
</ul>
<p>与管道不同，信号量是为了保护进程共享资源在同一时刻只能被一个进程访问。解决同步和互斥问题。</p>
<p>sv：信号变量</p>
<p>对信号量的操作只有一下P(sv)和V(sv)两个原子操作:</p>
<ol>
<li>进程1访问资源时对信号量进行等待操作P(sv)（如果sv&gt;0则操作资源并将信号量-1，否则挂起进程等待）；</li>
<li>当该进程1对资源执行完操作后，对信号量进行发送操作V(sv)（此时如果有进程2等待sv而挂起，则恢复进程2，否则就给sv+1）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/skyroben/article/details/72513985">https://blog.csdn.net/skyroben/article/details/72513985</a></p>
<ul>
<li>信号 Signal</li>
</ul>
<p>信号是进程间通信中唯一的异步通信机制，通知接收信号的进程发生了什么事情。而进程接受到信号后可以忽略，捕获处理，或者使用系统默认操作。</p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html">https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html</a></p>
<p>只能承载很小的信息量，主要用在进程的中断控制</p>
<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><p>数据拷贝1次，有权限校验（为发送方添加了UID&#x2F;PID身份）</p>
<p><img src="https://jixiaoyong.github.io/images/20200422115508.gif" alt="参与Binder通信的所有角色 图片来自https://blog.csdn.net/universus/article/details/6211589"></p>
<p>时序图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">title:  Binder交互时序图 </span><br><span class="line"></span><br><span class="line">participant Client</span><br><span class="line">participant ServerManager</span><br><span class="line">participant Binder驱动</span><br><span class="line">participant Server</span><br><span class="line"></span><br><span class="line">note over Server: 服务创建Binder</span><br><span class="line">Server-&gt; Binder驱动: Binder对象及名字</span><br><span class="line">note over Binder驱动: Binder驱动在内核创建Binder对应实体节点及引用</span><br><span class="line">Binder驱动-&gt; ServerManager: 内核中的Binder对象引用及名字</span><br><span class="line">note over ServerManager: 注册Binder（将名字和应用填入查找表）</span><br><span class="line">Client -&gt; ServerManager: 客户端需要的Binder对象名字</span><br><span class="line">note over ServerManager: 查找保存的内核Binder对象应用</span><br><span class="line">ServerManager -&gt; Client: 客户端需要的Binder对象引用</span><br><span class="line">note over Client: 操作内核Binder</span><br><span class="line">Client --&gt;&gt; Server:相当于操作Server</span><br></pre></td></tr></table></figure>

<p><img src="https://jixiaoyong.github.io/images/20200422115253.png" alt="20200422115253"></p>
<p>理论上的Binder逻辑：</p>
<blockquote>
<p>SMgr提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成SMgr时Binder驱动会自动为它创建Binder实体（这就是那只预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。</p>
<p>在数据从发送方向接收方拷贝时，驱动会根据发送数据包的大小，使用最佳匹配算法从缓存池中找到一块大小合适的空间，<strong>将数据从发送缓存区复制过来</strong>。</p>
<p>为了实现用户空间到用户空间的拷贝，Binder驱动的mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。</p>
<p>版权声明：本文为CSDN博主「universus」的原创文章，遵循 CC 4.0 BY-SA </p>
<p>版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/universus/article/details/6211589">https://blog.csdn.net/universus/article/details/6211589</a></p>
</blockquote>
<p>主要参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/universus/article/details/6211589">https://blog.csdn.net/universus/article/details/6211589</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/freekiteyu/article/details/70082302">https://blog.csdn.net/freekiteyu/article/details/70082302</a></p>
<p>Binder通信主要涉及一下对象：</p>
<ul>
<li>Server</li>
<li>Client</li>
<li>ServerManager</li>
<li>Binder驱动</li>
</ul>
<p>首先要知道，Server，Client以及ServerManager一般都在不同的进程之中，那么Server，Client如何与ServerManager通信并注册&#x2F;查询所需的服务呢？这里就需要用到<strong>0号引用Binder</strong>。</p>
<p><strong>0号引用Binder</strong> 是ServerManager内部创建匿名Binder，所有的Client（相对于ServerManager来说其他和他交互的都是Client）都默认持有这个Binder的引用。</p>
<p>所以一个完整的AIDL通信过程如下：</p>
<ol>
<li>Server创建一个Binder和对应名字</li>
<li>Server通过持有的0号引用Binder和ServerManager通信。<br>将生成的Binder和对应名字发送到Binder驱动，Binder驱动会为这个Binder在内核空间创建对应实体节点及其引用（<strong>复制了一次</strong>），并通过0号引用将其发给ServerManager。</li>
<li>ServerManager收到内核中的Binder对象引用及名字后将其保存到查找表中。</li>
<li>Client通过0号引用Binder和ServerManager通信。<br>Client将需要的Binder的名字发给ServerManager，ServerManager查询到已经注册的内核Binder引用并将其发给Client。</li>
<li>Client获取到内核Binder的引用进行操作。</li>
</ol>
<p>再来看看一个完整的流程：</p>
<p>在Service中，我们会先创建一个mIBinder对象并且在<code>public IBinder onBind(Intent intent)</code>方法返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">IBinder</span> <span class="variable">mIBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AidlBinderInterface</span>.Stub() &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//这里实现我们服务能够提供的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追踪onBind方法，我们会发现<code>mIBinder</code>的对象会在ActivityThread中的<code>private void handleBindService(BindServiceData data)</code>方法中被传入到IActivityManager的publishService方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">    ActivityManager.getService().publishService(</span><br><span class="line">                                data.token, data.intent, binder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityManager.getService()方法是通过IPC获取到ActivityManager的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Singleton</span>&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> IActivityManager <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> IActivityManager.Stub.asInterface(b);</span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>而根据<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/91c97710976a">这篇文章</a>，这个binder最终会被传输到绑定这个服务时所用的ServiceConnection对象的<code>onServiceConnected</code>方法中（<strong>即mIBinder通过ServerManager从Service传递到了Client</strong>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">mConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            mServiceInterface = AidlBinderInterface.Stub.asInterface(service);</span><br><span class="line">            <span class="comment">//我们通过得到的这个mServiceInterface可以在客户端调用服务所实现的方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>根据<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangyongfeiyong/article/details/51953300">Android服务之bindService源码分析</a>mConnection会通过<code>context.bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</code>最终在ActivityManagerService通过Binder驱动程序调用ActivityThread类中的scheduleBindService方法传递到Service所在进程中，并根据Service的状态不同而被调用对应方法（<strong>即mConnection通过ServerManager从Client传递到了Service</strong>）。</p>
<p><img src="https://jixiaoyong.github.io/images/20200422115031.jpg" alt="图片来自https://img-blog.csdn.net/20160719100800917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>在这其中我们用到了两个涉及到AIDL文件：</p>
<ul>
<li>private IBinder mIBinder &#x3D; new AidlBinderInterface.Stub() {}</li>
<li>mServiceInterface &#x3D; AidlBinderInterface.Stub.asInterface(service);</li>
</ul>
<p>再来看看我们写的对应的AIDL文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface AidlBinderInterface &#123;</span><br><span class="line"> //在这里定义服务需要提供的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个文件中都是我们自己定义的方法，系统自动帮我们实现了更详细的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aidl;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AidlBinderInterface</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">com</span>.example.aidl.AidlBinderInterface &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.example.aidl.AidlBinderInterface&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         * 将DESCRIPTOR和这个接口绑定到一起</span></span><br><span class="line"><span class="comment">         * 本方法会在服务创建IBinder对象的时候调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.example.aidl.AidlBinderInterface interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.aidl.AidlBinderInterface <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查询本地是否有符合该描述（DESCRIPTOR）接口的Binder对象</span></span><br><span class="line">            android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="comment">// 有的话直接返回本地对象</span></span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="literal">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.aidl.AidlBinderInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.aidl.AidlBinderInterface) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有的话，创建代理类，进行跨进程通信</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.example.aidl.AidlBinderInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在通信时，如果asInterface返回本地对象，则会执行本地对接口（DESCRIPTOR）的实现方法，</span></span><br><span class="line">        <span class="comment">// 否则就会调用代理类com.example.aidl.AidlBinderInterface.Stub.Proxy中对应的方法进行跨进程通信</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">            java.lang.<span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> DESCRIPTOR;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getAvailablePointTags: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    java.util.List&lt;String&gt; _result = <span class="built_in">this</span>.getAllStringTags();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               ...</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 代理类</span></span><br><span class="line"><span class="comment">         * 通过Binder对象mRemote执行AidlBinderInterface接口的具体方法</span></span><br><span class="line"><span class="comment">         * 具体则在mRemote.transact()实现了跨进程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">com</span>.example.aidl.AidlBinderInterface &#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//系统对我们在AIDL中定义的方法的具体实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;StringTag&gt; <span class="title function_">getAllStringTags</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;StringTags&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                     <span class="comment">// mRemote.transact()方法会：1.给服务端发消息 2.挂起当前线程 3.收到服务端返回后唤醒当前线程</span></span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getAllStringTags, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(StringTag.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//系统对每个接口方法的编号</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_getAllStringTags</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面这些是系统根据我们在aidl中定义的方法写的接口</span></span><br><span class="line">        <span class="keyword">public</span> java.util.List&lt;StringTag&gt; <span class="title function_">getAllStringTags</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可知<code>mRemote</code>便是指向AMS服务的<code>BinderProxy</code>对象 <a target="_blank" rel="noopener" href="https://www.diycode.cc/topics/384">https://www.diycode.cc/topics/384</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/a284628487/p/3187320.html">https://www.cnblogs.com/a284628487/p/3187320.html</a></p>
<p><img src="https://jixiaoyong.github.io/images/20200422114923.jpg" alt="图片来自https://images0.cnblogs.com/blog/391137/201307/12211553-49c477a875e84b2aae764c67f38f26b2.jpg"></p>
<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><p>如果在BroadcastReceiver 的onReceive方法中创建一个线程，那么当该方法返回时，Android系统就会认为该BroadcastReceiver已经完成任务了，从而会在需要回收内存时杀死进程以及其中的Thread。创建一个<a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/app/job/JobService.html?hl=zh-cn">JobService</a>可以避免这个情况。</p>
<blockquote>
<p>So, the system may kill the process at any time to reclaim memory, and in doing so, it terminates the spawned thread running in the process.</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/components/activities/process-lifecycle?hl=zh-cn">https://developer.android.google.cn/guide/components/activities/process-lifecycle?hl=zh-cn</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/universus/article/details/6211589">https://blog.csdn.net/universus/article/details/6211589</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/429a1ff3560c">https://www.jianshu.com/p/429a1ff3560c</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/a284628487/p/3187320.html">https://www.cnblogs.com/a284628487/p/3187320.html</a></p>
<p><a target="_blank" rel="noopener" href="http://hoyouly.fun/2019/07/17/Android-AIDL/">http://hoyouly.fun/2019/07/17/Android-AIDL/</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/entry/59c9cd59f265da065754e6f1">https://juejin.im/entry/59c9cd59f265da065754e6f1</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>JI, XIAOYONG
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jixiaoyong.github.io/blog/posts/7e97a976/" title="Android笔记之跨进程通信">https://jixiaoyong.github.io/blog/posts/7e97a976/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/android/" rel="tag"># android</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/posts/9d9183ec/" rel="prev" title="Java笔记之序列化与反序列化：Serializable、Externalizable和Parcelable">
                  <i class="fa fa-chevron-left"></i> Java笔记之序列化与反序列化：Serializable、Externalizable和Parcelable
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/posts/87a89a43/" rel="next" title="Java笔记之YYYY格式化日期">
                  Java笔记之YYYY格式化日期 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JI, XIAOYONG</span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>





  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://vercel.xiaoyong.ml","cssUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css","commentCount":true,"pageview":true,"libUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.js","locale":{"placeholder":"ヾ(=^▽^=)ノ"},"meta":["nick","mail","link"],"login":"enable","pageSize":10,"el":"#waline","comment":true,"path":"/blog/posts/7e97a976/"}</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
