<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/https/jixiaoyong.github.io/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.ico">
  <link rel="mask-icon" href="/blog/https/jixiaoyong.github.io/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jixiaoyong.github.io","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":true,"version":"8.12.3","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="本文基于Dart 2.17    Dart App中所有的代码都在一个isolate中运行（各个isolate之间的代码运行时是隔离的），一个isolate有自己的heap，维持有一个消息队列event_loop，处理两种消息：  event queue 执行用户点击、屏幕刷新、绘制，一般的Future、IO、Stream流等，每次执行完毕都会先检查执行micro task queue中的任务，">
<meta property="og:type" content="article">
<meta property="og:title" content="Dart event loop">
<meta property="og:url" content="https://jixiaoyong.github.io/blog/posts/db62c118/index.html">
<meta property="og:site_name" content="Ji Xiaoyong&#39;s Blog">
<meta property="og:description" content="本文基于Dart 2.17    Dart App中所有的代码都在一个isolate中运行（各个isolate之间的代码运行时是隔离的），一个isolate有自己的heap，维持有一个消息队列event_loop，处理两种消息：  event queue 执行用户点击、屏幕刷新、绘制，一般的Future、IO、Stream流等，每次执行完毕都会先检查执行micro task queue中的任务，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop.png">
<meta property="og:image" content="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop_sequeue.png">
<meta property="og:image" content="https://jixiaoyong.github.io/images/dart/event_loop/dart_test_queue_code.png">
<meta property="og:image" content="https://jixiaoyong.github.io/images/dart/event_loop/dart_test_queue_output.png">
<meta property="article:published_time" content="2022-06-11T10:25:29.000Z">
<meta property="article:modified_time" content="2022-08-04T07:33:06.414Z">
<meta property="article:author" content="JI, XIAOYONG">
<meta property="article:tag" content="dart">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop.png">


<link rel="canonical" href="https://jixiaoyong.github.io/blog/posts/db62c118/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jixiaoyong.github.io/blog/posts/db62c118/","path":"posts/db62c118/","title":"Dart event loop"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dart event loop | Ji Xiaoyong's Blog</title>
  




<link rel="dns-prefetch" href="https://vercel.xiaoyong.ml">
  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ji Xiaoyong's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-text">1. 同步方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-micro-task"><span class="nav-text">2. micro task</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RootZone-scheduleAsyncCallback"><span class="nav-text">_RootZone._scheduleAsyncCallback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RootZone-startMicrotaskLoop"><span class="nav-text">_RootZone._startMicrotaskLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncRun-scheduleImmediate"><span class="nav-text">_AsyncRun._scheduleImmediate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScheduleImmediateClosure"><span class="nav-text">_ScheduleImmediateClosure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pendingImmediateCallback"><span class="nav-text">_pendingImmediateCallback</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-event"><span class="nav-text">3. event</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="nav-text">代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Future-then"><span class="nav-text">Future.then</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Timer"><span class="nav-text">Timer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BATimer"><span class="nav-text">创建Timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timer-enqueue"><span class="nav-text">timer._enqueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#milliSeconds-x3D-x3D-0"><span class="nav-text">_milliSeconds &#x3D;&#x3D; 0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#milliSeconds-%E2%89%A0-0"><span class="nav-text">_milliSeconds ≠ 0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handleMessage"><span class="nav-text">_handleMessage</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-text">结论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JI, XIAOYONG"
      src="//jixiaoyong.github.io/images/default_avatar.jpg">
  <p class="site-author-name" itemprop="name">JI, XIAOYONG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jixiaoyong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jixiaoyong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jixiaoyong1995@gmail.com" title="E-Mail → mailto:jixiaoyong1995@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jixiaoyong.github.io/blog/posts/db62c118/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//jixiaoyong.github.io/images/default_avatar.jpg">
      <meta itemprop="name" content="JI, XIAOYONG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Dart event loop | Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dart event loop<a href="https://github.com/jixiaoyong/blog_source_code/edit/master/blog/source/_posts/DartEventLoop.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-11 18:25:29" itemprop="dateCreated datePublished" datetime="2022-06-11T18:25:29+08:00">2022-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-04 15:33:06" itemprop="dateModified" datetime="2022-08-04T15:33:06+08:00">2022-08-04</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/blog/posts/db62c118/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/blog/posts/db62c118/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/blog/posts/db62c118/"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>本文基于Dart 2.17</p>
</blockquote>
<br>

<p>Dart App中所有的代码都在一个isolate中运行（各个isolate之间的代码运行时是隔离的），一个isolate有自己的heap，维持有一个消息队列event_loop，处理两种消息：</p>
<ol>
<li><code>event queue</code> 执行用户点击、屏幕刷新、绘制，一般的Future、IO、Stream流等，每次执行完毕都会先检查执行micro task queue中的任务，直到其为空再执行下一个event queue</li>
<li><code>microTask queue</code> 优先执行，一般执行跑完即弃的小任务，如Dart内部的微任务</li>
</ol>
<p>上述两种event会在普通的Dart同步方法执行完毕后执行，无论是microTask还是普通的event，他们都是<strong>concurrency并行</strong>执行（也就是说实际上还是<strong>上一个执行完毕，再执行另外一个</strong>），所以如果这些event中存在耗时长的方法，<strong>依旧会阻塞其他方法的执行</strong>，可能导致UI卡顿等情况。</p>
<br>

<p>在代码执行的过程中，各种事件（如用户点击、屏幕刷新、future、microtask等）都会被当做一个个event放入到event queue中，然后不停的从event loop取出事件并执行：</p>
<p><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop.png" alt="dart_event_loop"></p>
<p>他们的执行顺序如下：</p>
<p><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_event_loop_sequeue.png" alt="dart_event_loop_sequeue"></p>
<p>可以从下述例子详细看一下代码执行的时候各个方法执行过程：</p>
<p><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_test_queue_code.png" alt="dart_test_queue_code"></p>
<p><img src="https://jixiaoyong.github.io/images/dart/event_loop/dart_test_queue_output.png" alt="dart_test_queue_output"></p>
<br>

<p>本文根据Dart SDK源码分析一下event loop的实现。</p>
<p>代码参考：<a target="_blank" rel="noopener" href="https://gist.github.com/jixiaoyong/ac811902db42a51cf97e3290788ade4a">https://gist.github.com/jixiaoyong/ac811902db42a51cf97e3290788ade4a</a></p>
<h1 id="1-同步方法"><a href="#1-同步方法" class="headerlink" title="1. 同步方法"></a>1. 同步方法</h1><p>同步方法包括普通的方法，以及一下几种会按照同步方法立即执行的方式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Future.<span class="keyword">sync</span>(() =&gt; <span class="built_in">print</span>(<span class="string">&quot;Hello, I am future created by Future.sync&quot;</span>));</span><br><span class="line">Future.forEach(</span><br><span class="line">      [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">      (element) =&gt;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Hello, I am future(<span class="subst">$element</span>) created by Future.forEach&quot;</span>));</span><br><span class="line">Future.doWhile(() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (repeatCounter++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;repeat (<span class="subst">$repeatCounter</span>/3) inner Future.doWhile&quot;</span>);</span><br><span class="line">      <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="2-micro-task"><a href="#2-micro-task" class="headerlink" title="2. micro task"></a>2. micro task</h1><p>microtask会在同步方法执行完毕之后立即被执行，一般用来执行“即抛型”的方法，不应当执行耗时方法。microtask列表会一直执行，直到event loop中没有micro task了，才会去执行Future等普通的event。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scheduleMicrotask(() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello, world! I am a microtask.&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Future.microtask(</span><br><span class="line">      () =&gt; <span class="built_in">print</span>(<span class="string">&quot;Hello, I am microtask created by Future.microtask&quot;</span>));</span><br><span class="line"></span><br><span class="line">Future.value(<span class="number">1</span>).then((value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am future created by Future.value&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Future.error(Exception(<span class="string">&quot;Hello, I am future created by Future.error&quot;</span>))</span><br><span class="line">      .onError((error, stackTrace) =&gt; <span class="built_in">print</span>(error));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Future.value([FutureOr&lt;T&gt;? value])</code> 比较特殊，如果<code>value</code> 是future，那么他会在value执行完毕后返回他的值，如果<code>value</code>不是future，他就会立即执行属于microtask</p>
</blockquote>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>让我们看一下上述方法的具体实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\future.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">factory</span> Future.microtask(FutureOr&lt;T&gt; computation()) &#123;</span><br><span class="line">    _Future&lt;T&gt; result = <span class="keyword">new</span> _Future&lt;T&gt;();</span><br><span class="line">    scheduleMicrotask(() &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        result._complete(computation());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e, s) &#123;</span><br><span class="line">        _completeWithErrorCallback(result, e, s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>Future.microtask</code>本质还是调用<code>scheduleMicrotask</code>实现的，其实现如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\schedule_microtask.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&#x27;vm:entry-point&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"><span class="keyword">void</span> scheduleMicrotask(<span class="keyword">void</span> <span class="built_in">Function</span>() callback) &#123;</span><br><span class="line">  _Zone currentZone = Zone._current;</span><br><span class="line">  <span class="keyword">if</span> (identical(_rootZone, currentZone)) &#123;</span><br><span class="line">    <span class="comment">// No need to bind the callback. We know that the root&#x27;s scheduleMicrotask</span></span><br><span class="line">    <span class="comment">// will be invoked in the root zone.</span></span><br><span class="line">    _rootScheduleMicrotask(<span class="keyword">null</span>, <span class="keyword">null</span>, _rootZone, callback);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _ZoneFunction implementation = currentZone._scheduleMicrotask;</span><br><span class="line">  <span class="keyword">if</span> (identical(_rootZone, implementation.zone) &amp;&amp;</span><br><span class="line">      _rootZone.inSameErrorZone(currentZone)) &#123;</span><br><span class="line">    _rootScheduleMicrotask(</span><br><span class="line">        <span class="keyword">null</span>, <span class="keyword">null</span>, currentZone, currentZone.registerCallback(callback));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Zone.current.scheduleMicrotask(Zone.current.bindCallbackGuarded(callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Zone.scheduleMicrotask()</code>最后调用的是<code>_RootZone</code>的同名方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\zone.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RootZone</span> <span class="keyword">extends</span> <span class="title">_Zone</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span> scheduleMicrotask(<span class="keyword">void</span> f()) &#123;</span><br><span class="line">    _rootScheduleMicrotask(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">this</span>, f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _rootScheduleMicrotask(</span><br><span class="line">    Zone? self, ZoneDelegate? parent, Zone zone, <span class="keyword">void</span> f()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!identical(_rootZone, zone)) &#123;</span><br><span class="line">    <span class="built_in">bool</span> hasErrorHandler = !_rootZone.inSameErrorZone(zone);</span><br><span class="line">    <span class="keyword">if</span> (hasErrorHandler) &#123;</span><br><span class="line">      f = zone.bindCallbackGuarded(f);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      f = zone.bindCallback(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _scheduleAsyncCallback(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RootZone-scheduleAsyncCallback"><a href="#RootZone-scheduleAsyncCallback" class="headerlink" title="_RootZone._scheduleAsyncCallback"></a>_RootZone._scheduleAsyncCallback</h3><p>这里调用了<code>_RootZone._scheduleAsyncCallback</code>方法，将传入的callback当做microtask执行。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\schedule_microtask.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Schedules a callback to be called as a microtask.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The microtask is called after all other currently scheduled</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">microtasks, but as part of the current system event.</span></span></span><br><span class="line"><span class="keyword">void</span> _scheduleAsyncCallback(_AsyncCallback callback) &#123;</span><br><span class="line">  _AsyncCallbackEntry newEntry = <span class="keyword">new</span> _AsyncCallbackEntry(callback);</span><br><span class="line">  _AsyncCallbackEntry? lastCallback = _lastCallback;</span><br><span class="line">  <span class="keyword">if</span> (lastCallback == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _nextCallback = _lastCallback = newEntry;</span><br><span class="line">    <span class="keyword">if</span> (!_isInCallbackLoop) &#123;</span><br><span class="line">      _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lastCallback.next = newEntry;</span><br><span class="line">    _lastCallback = newEntry;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RootZone-startMicrotaskLoop"><a href="#RootZone-startMicrotaskLoop" class="headerlink" title="_RootZone._startMicrotaskLoop"></a>_RootZone._startMicrotaskLoop</h3><p>这里面的<code>_startMicrotaskLoop</code>方法是实际上处理microtask的地方：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\schedule_microtask.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Whether we are currently inside the callback loop.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">If we are inside the loop, we never need to schedule the loop,</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">even if adding a first element.</span></span></span><br><span class="line"><span class="built_in">bool</span> _isInCallbackLoop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _microtaskLoop() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> entry = _nextCallback; entry != <span class="keyword">null</span>; entry = _nextCallback) &#123;</span><br><span class="line">    _lastPriorityCallback = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">var</span> next = entry.next;</span><br><span class="line">    _nextCallback = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) _lastCallback = <span class="keyword">null</span>;</span><br><span class="line">    (entry.callback)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _startMicrotaskLoop() &#123;</span><br><span class="line">  _isInCallbackLoop = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Moved to separate function because try-finally prevents</span></span><br><span class="line">    <span class="comment">// good optimization.</span></span><br><span class="line">    _microtaskLoop();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _lastPriorityCallback = <span class="keyword">null</span>;</span><br><span class="line">    _isInCallbackLoop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_nextCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>_AsyncRun._scheduleImmediate</code>方法则是触发处理microtask的方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\schedule_microtask.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AsyncRun</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Schedule the given callback before any other event in the event-loop.</span></span></span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="keyword">void</span> _scheduleImmediate(<span class="keyword">void</span> <span class="built_in">Function</span>() callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncRun-scheduleImmediate"><a href="#AsyncRun-scheduleImmediate" class="headerlink" title="_AsyncRun._scheduleImmediate"></a>_AsyncRun._scheduleImmediate</h3><p><code>_AsyncRun._scheduleImmediate</code>方法的实现在<code>schedule_microtask_patch.dart</code>中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk/lib/_internal/vm/lib/schedule_microtask_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AsyncRun</span> </span>&#123;</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _scheduleImmediate(<span class="keyword">void</span> callback()) &#123;</span><br><span class="line">    <span class="keyword">final</span> closure = _ScheduleImmediate._closure;</span><br><span class="line">    <span class="keyword">if</span> (closure == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedError(<span class="string">&quot;Microtasks are not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    closure(callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> _ScheduleImmediateClosure(<span class="keyword">void</span> callback());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScheduleImmediate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> _ScheduleImmediateClosure? _closure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line"><span class="keyword">void</span> _setScheduleImmediateClosure(_ScheduleImmediateClosure closure) &#123;</span><br><span class="line">  _ScheduleImmediate._closure = closure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line"><span class="keyword">void</span> _ensureScheduleImmediate() &#123;</span><br><span class="line">  _AsyncRun._scheduleImmediate(_startMicrotaskLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScheduleImmediateClosure"><a href="#ScheduleImmediateClosure" class="headerlink" title="_ScheduleImmediateClosure"></a>_ScheduleImmediateClosure</h3><p>可以看到，microtask实际上是使用<code>_ScheduleImmediateClosure</code>调用的，关于他主要有两个方法：</p>
<ol>
<li><code>_setScheduleImmediateClosure</code></li>
<li><code>_ensureScheduleImmediate</code></li>
</ol>
<p>让我们先看一下第一个方法<code>_setScheduleImmediateClosure</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\dartutils.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PrepareAsyncLibrary方法会在Dart虚拟机启动的时候被调用</span></span><br><span class="line">Dart_Handle DartUtils::PrepareAsyncLibrary(Dart_Handle async_lib,</span><br><span class="line">                                           Dart_Handle isolate_lib) &#123;</span><br><span class="line">  Dart_Handle schedule_immediate_closure = Dart_Invoke(</span><br><span class="line">      isolate_lib, NewString(<span class="string">&quot;_getIsolateScheduleImmediateClosure&quot;</span>), <span class="number">0</span>, NULL);</span><br><span class="line">  RETURN_IF_ERROR(schedule_immediate_closure);</span><br><span class="line">  Dart_Handle args[<span class="number">1</span>];</span><br><span class="line">  args[<span class="number">0</span>] = schedule_immediate_closure;</span><br><span class="line">  <span class="keyword">return</span> Dart_Invoke(async_lib, NewString(<span class="string">&quot;_setScheduleImmediateClosure&quot;</span>), <span class="number">1</span>,</span><br><span class="line">                     args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要调用了Dart中的<code>_getIsolateScheduleImmediateClosure</code>方法创建了<code>schedule_immediate_closure</code>，然后通过<code>_setScheduleImmediateClosure</code>返回：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\isolate_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The embedder can execute this function to get hold of</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[<span class="emphasis">_isolateScheduleImmediate] above.</span></span></span></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line"><span class="built_in">Function</span> _getIsolateScheduleImmediateClosure() &#123;</span><br><span class="line">  <span class="keyword">return</span> _isolateScheduleImmediate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">The closure that should be used as scheduleImmediateClosure, when the VM</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">is responsible for the event loop.</span></span></span></span><br><span class="line"><span class="keyword">void</span> _isolateScheduleImmediate(<span class="keyword">void</span> callback()) &#123;</span><br><span class="line">  <span class="keyword">assert</span>((_pendingImmediateCallback == <span class="keyword">null</span>) ||</span><br><span class="line">      (_pendingImmediateCallback == callback));</span><br><span class="line">  _pendingImmediateCallback = callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">The callback that has been registered through `scheduleImmediate`.</span></span></span></span><br><span class="line">_ImmediateCallback? _pendingImmediateCallback;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法会将传递进来的<code>callback</code>赋值给<code>_pendingImmediateCallback</code>。</p>
<p>而结合上面的代码，<code>_ensureScheduleImmediate</code> 方法主要也是用来触发<code>_ScheduleImmediateClosure</code>执行回调事件。</p>
<br>

<p>到目前为止，我们能确定的是：</p>
<ul>
<li>在Dart VM启动的时候，会创建一个<code>_ScheduleImmediateClosure</code>并保存在<code>_pendingImmediateCallback</code>;</li>
<li>当有新的microtask加入的时候，会触发<code>_startMicrotaskLoop</code>方法在<code>_microtaskLoop()</code>中实际处理一个microtask（这里的<code>_startMicrotaskLoop</code>触发的实际是通过<code>_AsyncRun._scheduleImmediate(_startMicrotaskLoop)</code>将其使用<code>_pendingImmediateCallback</code> 包裹之后执行的）。</li>
</ul>
<h3 id="pendingImmediateCallback"><a href="#pendingImmediateCallback" class="headerlink" title="_pendingImmediateCallback"></a>_pendingImmediateCallback</h3><p>现在的问题是，这个<code>_pendingImmediateCallback</code> 什么时候会被安排执行呢？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\isolate_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line"><span class="keyword">void</span> _runPendingImmediateCallback() &#123;</span><br><span class="line">  <span class="keyword">final</span> callback = _pendingImmediateCallback;</span><br><span class="line">  <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">    _pendingImmediateCallback = <span class="keyword">null</span>;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RawReceivePortImpl</span> <span class="keyword">implements</span> <span class="title">RawReceivePort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Called from the VM to retrieve  the handler and handle a message.</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line">  <span class="keyword">static</span> _handleMessage(<span class="built_in">int</span> id, <span class="keyword">var</span> message) &#123;</span><br><span class="line">    <span class="keyword">final</span> handler = _portMap[id]?[<span class="string">&#x27;handler&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(floitsch): this relies on the fact that any exception aborts the</span></span><br><span class="line">    <span class="comment">// VM. Once we have non-fatal global exceptions we need to catch errors</span></span><br><span class="line">    <span class="comment">// so that we can run the immediate callbacks.</span></span><br><span class="line">    handler(message);</span><br><span class="line">    _runPendingImmediateCallback();</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的关键代码，在<code>_handleMessage</code>方法中，会先执行<code>RawReceivePort</code>原本的handler内容，然后，执行<code>_runPendingImmediateCallback()</code>。</p>
<p>在<code>_runPendingImmediateCallback</code>则会执行<code>_pendingImmediateCallback</code>的内容，也就是前面的<code>_startMicrotaskLoop</code>，处理event loop中的micro task。</p>
<br>

<p>这也就证明了我们之前说的“<strong>microtask会在同步方法之后立即执行，并在每次普通的event loop执行完毕之后，都会检查并执行event loop中的microtask，之后才继续执行普通event</strong>”。</p>
<p>在下面的分析中，我们也还可以看到，在event每次处理Timer事件之后，都会检查执行micro task。</p>
<h1 id="3-event"><a href="#3-event" class="headerlink" title="3. event"></a>3. event</h1><blockquote>
<p>除了下面列出来的使用Future或者Timer等创建的方法外，屏幕点击、刷新等事件也在此类event中。</p>
</blockquote>
<p>当前event loop中没有micro task之后，就会执行一次此类普通event，然后再检查一次event loop，如果有micro task就执行micro task直到清空micro task，否则继续执行下一个普通event，直到event loop列表为空，退出app。</p>
<p>先看几种会触发此类事件的方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am future&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Future.any([</span><br><span class="line">    Future(() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;I am Future run immediately Future.any&quot;</span>;</span><br><span class="line">    &#125;),</span><br><span class="line">    Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;I am Future run delay, will be discard Future.any&quot;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]).then((value) =&gt; <span class="built_in">print</span>(value));</span><br><span class="line"></span><br><span class="line">Future.wait([</span><br><span class="line">    Future(() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;I am Future run immediately Future.wait 1/2&quot;</span>;</span><br><span class="line">    &#125;),</span><br><span class="line">    Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;I am Future run delay Future.wait 2/2&quot;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]).then((value) =&gt; <span class="built_in">print</span>(value));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以及Timer</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Timer.periodic(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), (timer) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am running inner(<span class="subst">$&#123;timer.tick&#125;</span>/2) Timer.periodic&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (timer.tick == <span class="number">2</span>) &#123;</span><br><span class="line">      timer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;Hello, I will run asynchronously as soon as possible with Timer.run&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">Timer(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I will run asynchronously after 1 second with Timer&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们依次看一下上述几个方法的具体实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\future.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">factory</span> Future.delayed(<span class="built_in">Duration</span> duration, [FutureOr&lt;T&gt; computation()?]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (computation == <span class="keyword">null</span> &amp;&amp; !typeAcceptsNull&lt;T&gt;()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ArgumentError.value(</span><br><span class="line">          <span class="keyword">null</span>, <span class="string">&quot;computation&quot;</span>, <span class="string">&quot;The type parameter is not nullable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _Future&lt;T&gt; result = <span class="keyword">new</span> _Future&lt;T&gt;();</span><br><span class="line">    <span class="keyword">new</span> Timer(duration, () &#123;</span><br><span class="line">      <span class="keyword">if</span> (computation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result._complete(<span class="keyword">null</span> <span class="keyword">as</span> T);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          result._complete(computation());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e, s) &#123;</span><br><span class="line">          _completeWithErrorCallback(result, e, s);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Future&lt;T&gt; any&lt;T&gt;(<span class="built_in">Iterable</span>&lt;Future&lt;T&gt;&gt; futures) &#123;</span><br><span class="line">    <span class="keyword">var</span> completer = <span class="keyword">new</span> Completer&lt;T&gt;.<span class="keyword">sync</span>();</span><br><span class="line">    <span class="keyword">void</span> onValue(T value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!completer.isCompleted) completer.complete(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> onError(<span class="built_in">Object</span> error, StackTrace stack) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!completer.isCompleted) completer.completeError(error, stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> future <span class="keyword">in</span> futures) &#123;</span><br><span class="line">			<span class="comment">// 一旦有一个future执行完毕，就立即返回结果，并丢弃掉后续future的返回</span></span><br><span class="line">      future.then(onValue, onError: onError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> completer.future;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:recognized&quot;</span>, <span class="string">&quot;other&quot;</span>)</span><br><span class="line">  <span class="keyword">static</span> Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; wait&lt;T&gt;(<span class="built_in">Iterable</span>&lt;Future&lt;T&gt;&gt; futures,</span><br><span class="line">      &#123;<span class="built_in">bool</span> eagerError = <span class="keyword">false</span>, <span class="keyword">void</span> cleanUp(T successValue)?&#125;) &#123;</span><br><span class="line">    <span class="comment">// This is a VM recognised method, and the _future variable is deliberately</span></span><br><span class="line">    <span class="comment">// allocated in a specific slot in the closure context for stack unwinding.</span></span><br><span class="line">    <span class="keyword">final</span> _Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; _future = _Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt;();</span><br><span class="line">    <span class="built_in">List</span>&lt;T?&gt;? values; <span class="comment">// Collects the values. Set to null on error.</span></span><br><span class="line">    <span class="built_in">int</span> remaining = <span class="number">0</span>; <span class="comment">// How many futures are we waiting for.</span></span><br><span class="line">    <span class="keyword">late</span> <span class="built_in">Object</span> error; <span class="comment">// The first error from a future.</span></span><br><span class="line">    <span class="keyword">late</span> StackTrace stackTrace; <span class="comment">// The stackTrace that came with the error.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle an error from any of the futures.</span></span><br><span class="line">    <span class="keyword">void</span> handleError(<span class="built_in">Object</span> theError, StackTrace theStackTrace) &#123;</span><br><span class="line">      remaining--;</span><br><span class="line">      <span class="built_in">List</span>&lt;T?&gt;? valueList = values;</span><br><span class="line">      <span class="keyword">if</span> (valueList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cleanUp != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">in</span> valueList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// Ensure errors from cleanUp are uncaught.</span></span><br><span class="line">              T cleanUpValue = value;</span><br><span class="line">              <span class="keyword">new</span> Future.<span class="keyword">sync</span>(() &#123;</span><br><span class="line">                cleanUp(cleanUpValue);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        values = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining == <span class="number">0</span> || eagerError) &#123;</span><br><span class="line">          _future._completeError(theError, theStackTrace);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          error = theError;</span><br><span class="line">          stackTrace = theStackTrace;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; !eagerError) &#123;</span><br><span class="line">        _future._completeError(error, stackTrace);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// As each future completes, put its value into the corresponding</span></span><br><span class="line">      <span class="comment">// position in the list of values.</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> future <span class="keyword">in</span> futures) &#123;</span><br><span class="line">        <span class="built_in">int</span> pos = remaining;</span><br><span class="line">				<span class="comment">// 在这里依次执行future</span></span><br><span class="line">        future.then((T value) &#123;</span><br><span class="line">          remaining--;</span><br><span class="line">          <span class="built_in">List</span>&lt;T?&gt;? valueList = values;</span><br><span class="line">          <span class="keyword">if</span> (valueList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valueList[pos] = value;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">              _future._completeWithValue(<span class="built_in">List</span>&lt;T&gt;.from(valueList));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cleanUp != <span class="keyword">null</span> &amp;&amp; value != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// Ensure errors from cleanUp are uncaught.</span></span><br><span class="line">              <span class="keyword">new</span> Future.<span class="keyword">sync</span>(() &#123;</span><br><span class="line">                cleanUp(value);</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; !eagerError) &#123;</span><br><span class="line">              <span class="comment">// If eagerError is false, and valueList is null, then</span></span><br><span class="line">              <span class="comment">// error and stackTrace have been set in handleError above.</span></span><br><span class="line">              _future._completeError(error, stackTrace);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, onError: handleError);</span><br><span class="line">        <span class="comment">// Increment the &#x27;remaining&#x27; after the call to &#x27;then&#x27;.</span></span><br><span class="line">        <span class="comment">// If that call throws, we don&#x27;t expect any future callback from</span></span><br><span class="line">        <span class="comment">// the future, and we also don&#x27;t increment remaining.</span></span><br><span class="line">        remaining++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _future.._completeWithValue(&lt;T&gt;[]);</span><br><span class="line">      &#125;</span><br><span class="line">      values = <span class="keyword">new</span> <span class="built_in">List</span>&lt;T?&gt;.filled(remaining, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, st) &#123;</span><br><span class="line">      <span class="comment">// The error must have been thrown while iterating over the futures</span></span><br><span class="line">      <span class="comment">// list, or while installing a callback handler on the future.</span></span><br><span class="line">      <span class="comment">// This is a breach of the `Future` protocol, but we try to handle it</span></span><br><span class="line">      <span class="comment">// gracefully.</span></span><br><span class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span> || eagerError) &#123;</span><br><span class="line">        <span class="comment">// Throw a new Future.error.</span></span><br><span class="line">        <span class="comment">// Don&#x27;t just call `_future._completeError` since that would propagate</span></span><br><span class="line">        <span class="comment">// the error too eagerly, not giving the callers time to install</span></span><br><span class="line">        <span class="comment">// error handlers.</span></span><br><span class="line">        <span class="comment">// Also, don&#x27;t use `_asyncCompleteError` since that one doesn&#x27;t give</span></span><br><span class="line">        <span class="comment">// zones the chance to intercept the error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Future.error(e, st);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allocate a list for values, thus indicating that there was an</span></span><br><span class="line">        <span class="comment">// error.</span></span><br><span class="line">        <span class="comment">// Set error to the caught exception.</span></span><br><span class="line">        error = e;</span><br><span class="line">        stackTrace = st;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _future;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，除了<code>Future.wait</code>和<code>Future.any</code> <strong>这两个处理Future集合的方法外，<code>Future.delayed</code> 这个方法内部是实际上是</strong>通过Timer实现**的。</p>
<h3 id="Future-then"><a href="#Future-then" class="headerlink" title="Future.then"></a>Future.then</h3><p>在看Timer实现之前，先看一下<code>Futrue.then</code>的实现,他对应的实现是<code>_Future.then</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\future_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Future</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// Register callbacks to be called when this future completes.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// When this future completes with a value, the [onValue] callback will be called with that value.</span></span><br><span class="line"><span class="comment">//  If this future is already completed, the callback will not be called immediately, </span></span><br><span class="line"><span class="comment">// but will be scheduled in a later microtask</span></span><br><span class="line">Future&lt;R&gt; then&lt;R&gt;(FutureOr&lt;R&gt; f(T value), &#123;<span class="built_in">Function?</span> onError&#125;) &#123;</span><br><span class="line">    Zone currentZone = Zone.current;</span><br><span class="line">    <span class="keyword">if</span> (identical(currentZone, _rootZone)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onError != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">          onError <span class="keyword">is</span>! <span class="built_in">Function</span>(<span class="built_in">Object</span>, StackTrace) &amp;&amp;</span><br><span class="line">          onError <span class="keyword">is</span>! <span class="built_in">Function</span>(<span class="built_in">Object</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArgumentError.value(</span><br><span class="line">            onError,</span><br><span class="line">            <span class="string">&quot;onError&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Error handler must accept one Object or one Object and a StackTrace&quot;</span></span><br><span class="line">                <span class="string">&quot; as arguments, and return a value of the returned future&#x27;s type&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      f = currentZone.registerUnaryCallback&lt;FutureOr&lt;R&gt;, T&gt;(f);</span><br><span class="line">      <span class="keyword">if</span> (onError != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This call also checks that onError is assignable to one of:</span></span><br><span class="line">        <span class="comment">//   dynamic Function(Object)</span></span><br><span class="line">        <span class="comment">//   dynamic Function(Object, StackTrace)</span></span><br><span class="line">        onError = _registerErrorHandler(onError, currentZone);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _Future&lt;R&gt; result = <span class="keyword">new</span> _Future&lt;R&gt;();</span><br><span class="line">    _addListener(<span class="keyword">new</span> _FutureListener&lt;T, R&gt;.then(result, f, onError));</span><br><span class="line">		<span class="comment">// 返回创建好的Future</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>_Futrue.then</code>只是对传入的回调的进行了包装，实际上是通过<code>_Future._addListener()</code>实现具体的逻辑：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\future_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">get</span> _mayComplete =&gt; (_state &amp; _completionStateMask) == _stateIncomplete;</span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _isPendingComplete =&gt; (_state &amp; _statePendingComplete) != <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _mayAddListener =&gt;</span><br><span class="line">      _state &lt;= (_statePendingComplete | _stateIgnoreError);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _addListener(_FutureListener listener) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(listener._nextListener == <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">// 如果是待完成的或者忽略错误的,将当前listener添加到链表头部；</span></span><br><span class="line">		<span class="comment">// 在后文处理结果的时候，会从链表尾部开始读取</span></span><br><span class="line">    <span class="keyword">if</span> (_mayAddListener) &#123;</span><br><span class="line">      listener._nextListener = _resultOrListeners;</span><br><span class="line">      _resultOrListeners = listener;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (_isChained) &#123;</span><br><span class="line">        <span class="comment">// Delegate listeners to chained source future.</span></span><br><span class="line">        <span class="comment">// If the source is complete, instead copy its values and</span></span><br><span class="line">        <span class="comment">// drop the chaining.</span></span><br><span class="line">        _Future source = _chainSource;</span><br><span class="line">        <span class="keyword">if</span> (!source._isComplete) &#123;</span><br><span class="line">				  <span class="comment">// 如果依赖于source，那么就添加为source的listener</span></span><br><span class="line">          source._addListener(listener);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _cloneResult(source);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">assert</span>(_isComplete);</span><br><span class="line">      <span class="comment">// Handle late listeners asynchronously.</span></span><br><span class="line">      _zone.scheduleMicrotask(() &#123;</span><br><span class="line">				<span class="comment">// Propagates the value/error of [source] to its [listeners]</span></span><br><span class="line">        _propagateToListeners(<span class="keyword">this</span>, listener);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_Future._addListener(_FutureListener listener)</code>中基本上做了如下判断：</p>
<ul>
<li>如果Future是延迟完成的，就添加监听。</li>
<li>如果Future已经完成了，就加入到micro task中，安排执行listener回调（<code>_propagateToListeners(this, listener)</code>）。</li>
</ul>
<p>具体可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904196819402759">Flutter之Future原理解析</a>。</p>
<br>

<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>我们再看一下Timer的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\timer.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Timer.run</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> run(<span class="keyword">void</span> <span class="built_in">Function</span>() callback) &#123;</span><br><span class="line">    <span class="keyword">new</span> Timer(<span class="built_in">Duration</span>.zero, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">factory</span> Timer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> <span class="built_in">Function</span>() callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Zone.current == Zone.root) &#123;</span><br><span class="line">      <span class="comment">// No need to bind the callback. We know that the root&#x27;s timer will</span></span><br><span class="line">      <span class="comment">// be invoked in the root zone.</span></span><br><span class="line">      <span class="keyword">return</span> Zone.current.createTimer(duration, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Zone.current</span><br><span class="line">        .createTimer(duration, Zone.current.bindCallbackGuarded(callback));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">factory</span> Timer.periodic(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> callback(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Zone.current == Zone.root) &#123;</span><br><span class="line">      <span class="comment">// No need to bind the callback. We know that the root&#x27;s timer will</span></span><br><span class="line">      <span class="comment">// be invoked in the root zone.</span></span><br><span class="line">      <span class="keyword">return</span> Zone.current.createPeriodicTimer(duration, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> boundCallback = Zone.current.bindUnaryCallbackGuarded&lt;Timer&gt;(callback);</span><br><span class="line">    <span class="keyword">return</span> Zone.current.createPeriodicTimer(duration, boundCallback);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建Timer"><a href="#创建Timer" class="headerlink" title="创建Timer"></a>创建Timer</h3><p>可以看到，Timer的创建实际上是Zone通过两种方式创建的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\zone.dart</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Zone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// <span class="language-markdown">Creates a [Timer] where the callback is executed in this zone.</span></span></span><br><span class="line">  Timer createTimer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> <span class="built_in">Function</span>() callback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Creates a periodic [Timer] where the callback is executed in this zone.</span></span></span><br><span class="line">  Timer createPeriodicTimer(<span class="built_in">Duration</span> period, <span class="keyword">void</span> callback(Timer timer));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zone是抽象类，他的实现是<code>_RootZone</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\zone.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RootZone</span> <span class="keyword">extends</span> <span class="title">_Zone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Timer createTimer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> f()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Timer._createTimer(duration, f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Timer createPeriodicTimer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> f(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Timer._createPeriodicTimer(duration, f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里实际上是调用了Timer中对应的私有方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\async\timer.dart</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">external</span> <span class="keyword">static</span> Timer _createTimer(</span><br><span class="line">      <span class="built_in">Duration</span> duration, <span class="keyword">void</span> <span class="built_in">Function</span>() callback);</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> Timer _createPeriodicTimer(</span><br><span class="line">      <span class="built_in">Duration</span> duration, <span class="keyword">void</span> callback(Timer timer));</span><br></pre></td></tr></table></figure>

<p>他们的具体实现在<code>timer_patch.dart</code>中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Timer _createTimer(<span class="built_in">Duration</span> duration, <span class="keyword">void</span> callback()) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">factory</span> = VMLibraryHooks.timerFactory;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">factory</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedError(<span class="string">&quot;Timer interface not supported.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> milliseconds = duration.inMilliseconds;</span><br><span class="line">    <span class="keyword">if</span> (milliseconds &lt; <span class="number">0</span>) milliseconds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">factory</span>(milliseconds, (_) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">static</span> Timer _createPeriodicTimer(</span><br><span class="line">      <span class="built_in">Duration</span> duration, <span class="keyword">void</span> callback(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">factory</span> = VMLibraryHooks.timerFactory;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">factory</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedError(<span class="string">&quot;Timer interface not supported.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> milliseconds = duration.inMilliseconds;</span><br><span class="line">    <span class="keyword">if</span> (milliseconds &lt; <span class="number">0</span>) milliseconds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">factory</span>(milliseconds, callback, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论是单次的还是循环的Timer都是使用<code>VMLibraryHooks.timerFactory</code>创建的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line">_setupHooks() &#123;</span><br><span class="line">  VMLibraryHooks.timerFactory = _Timer._<span class="keyword">factory</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The Timer factory registered with the dart:async library by the embedder.</span></span><br><span class="line">  <span class="keyword">static</span> Timer _<span class="keyword">factory</span>(</span><br><span class="line">      <span class="built_in">int</span> milliSeconds, <span class="keyword">void</span> callback(Timer timer), <span class="built_in">bool</span> repeating) &#123;</span><br><span class="line">    <span class="keyword">if</span> (repeating) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _Timer.periodic(milliSeconds, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Timer(milliSeconds, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">factory</span> _Timer(<span class="built_in">int</span> milliSeconds, <span class="keyword">void</span> callback(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> _createTimer(callback, milliSeconds, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> _Timer.periodic(<span class="built_in">int</span> milliSeconds, <span class="keyword">void</span> callback(Timer timer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> _createTimer(callback, milliSeconds, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最终都是调用的<code>_Timer._createTimer</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> _Timer _createTimer(</span><br><span class="line">      <span class="keyword">void</span> callback(Timer timer), <span class="built_in">int</span> milliSeconds, <span class="built_in">bool</span> repeating) &#123;</span><br><span class="line">    <span class="comment">// Negative timeouts are treated as if 0 timeout.</span></span><br><span class="line">    <span class="keyword">if</span> (milliSeconds &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      milliSeconds = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add one because DateTime.now() is assumed to round down</span></span><br><span class="line">    <span class="comment">// to nearest millisecond, not up, so that time + duration is before</span></span><br><span class="line">    <span class="comment">// duration milliseconds from now. Using microsecond timers like</span></span><br><span class="line">    <span class="comment">// Stopwatch allows detecting that the timer fires early.</span></span><br><span class="line">    <span class="built_in">int</span> now = VMLibraryHooks.timerMillisecondClock();</span><br><span class="line">    <span class="built_in">int</span> wakeupTime = (milliSeconds == <span class="number">0</span>) ? now : (now + <span class="number">1</span> + milliSeconds);</span><br><span class="line"></span><br><span class="line">    _Timer timer =</span><br><span class="line">        <span class="keyword">new</span> _Timer._internal(callback, wakeupTime, milliSeconds, repeating);</span><br><span class="line">    <span class="comment">// Enqueue this newly created timer in the appropriate structure and</span></span><br><span class="line">    <span class="comment">// notify if necessary.</span></span><br><span class="line">    timer._enqueue();</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在创建timer的时候，先获取了当前的时间戳，然后计算出timer的唤醒时间<code>wakeupTime</code> ，最后调用<code>_Timer._internal</code>创建timer。</p>
<p><code>_Timer._internal</code>只是简单创建了Timer:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Timer._internal(</span><br><span class="line">      <span class="keyword">this</span>._callback, <span class="keyword">this</span>._wakeupTime, <span class="keyword">this</span>._milliSeconds, <span class="keyword">this</span>._repeating)</span><br><span class="line">      : _id = _nextId();</span><br></pre></td></tr></table></figure>

<p>在创建根据需要创建好Timer之后，使用<code>_Timer._enqueue</code>方法把Timer放入到相应的队列中。</p>
<h3 id="timer-enqueue"><a href="#timer-enqueue" class="headerlink" title="timer._enqueue"></a>timer._enqueue</h3><p>主要看一下<code>timer._enqueue()</code>方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Timers are ordered by wakeup time. Timers with a timeout value of &gt; 0 do</span></span><br><span class="line">  <span class="comment">// end up on the TimerHeap. Timers with a timeout of 0 are queued in a list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _heap = <span class="keyword">new</span> _TimerHeap();</span><br><span class="line">  <span class="keyword">static</span> _Timer? _firstZeroTimer;</span><br><span class="line">  <span class="keyword">static</span> _Timer _lastZeroTimer = _sentinelTimer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adds a timer to the heap or timer list. Timers with the same wakeup time</span></span><br><span class="line">  <span class="comment">// are enqueued in order and notified in FIFO order.</span></span><br><span class="line">  <span class="keyword">void</span> _enqueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_milliSeconds == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_firstZeroTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        _lastZeroTimer = <span class="keyword">this</span>;</span><br><span class="line">        _firstZeroTimer = <span class="keyword">this</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _lastZeroTimer._indexOrNext = <span class="keyword">this</span>;</span><br><span class="line">        _lastZeroTimer = <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Every zero timer gets its own event.</span></span><br><span class="line">      _notifyZeroHandler();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _heap.add(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (_heap.isFirst(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        _notifyEventHandler();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到无论是单次还是循环的Timer最后都是使用<code>_Timer._internal</code>创建的，然后再使用<code>_Timer._enqueue()</code>方法将timer添加到<code>heap</code>或者<code>timer list</code>中：</p>
<ul>
<li>如果Timer的<code>_milliSeconds</code>为0，则会被添加到<code>_lastZeroTimer</code>中（并将上一个timer的_indexOrNext指向自己），并在<code>_notifyZeroHandler()</code>方法发送_ZERO_EVENT事件（最终会触发<code>_Timer._handleMessage</code> ）；</li>
<li>否则则将其加入到<code>_heap</code>中，如果他是第一个timer，就通过<code>_notifyEventHandler()</code>启动处理Timer的event handler（这个线程会在合适的时间唤起Timer执行<code>_Timer._handleMessage</code>方法）。</li>
</ul>
<p>在具体分析整个过程之前，我们先看一下几个属性的创建过程：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Timer</span> <span class="keyword">implements</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> _RawReceivePortImpl? _receivePort;</span><br><span class="line">  <span class="keyword">static</span> SendPort? _sendPort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the event handler to wake this isolate at a specific time.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _scheduleWakeup(<span class="built_in">int</span> wakeupTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_receivePortActive) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    VMLibraryHooks.eventHandlerSendData(<span class="keyword">null</span>, _sendPort!, wakeupTime);</span><br><span class="line">    _scheduledWakeupTime = wakeupTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue one message for each zero timer. To be able to distinguish from</span></span><br><span class="line">  <span class="comment">// EventHandler messages we send a _ZERO_EVENT instead of a _TIMEOUT_EVENT.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _notifyZeroHandler() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_receivePortActive) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    _sendPort!.send(_ZERO_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a receive port and register a message handler for the timer</span></span><br><span class="line">  <span class="comment">// events.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _createTimerHandler() &#123;</span><br><span class="line">    <span class="keyword">var</span> receivePort = _receivePort;</span><br><span class="line">    <span class="keyword">if</span> (receivePort == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_sendPort == <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">final</span> port = _RawReceivePortImpl(<span class="string">&#x27;Timer&#x27;</span>);</span><br><span class="line">      port.handler = _handleMessage;</span><br><span class="line">      _sendPort = port.sendPort;</span><br><span class="line">      _receivePort = port;</span><br><span class="line">      _scheduledWakeupTime = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      receivePort._setActive(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _receivePortActive = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码我们可以看到：</p>
<ul>
<li><code>_sendPort</code>是<code>_receivePort</code>对应的sendPort，后者的handler是<code>_handleMessage()</code>方法</li>
<li>无论是<code>_notifyEventHandler()</code>还是 <code>_notifyZeroHandler()</code>都会保证<code>_createTimerHandler()</code>被<strong>调用过</strong>。</li>
</ul>
<h4 id="milliSeconds-x3D-x3D-0"><a href="#milliSeconds-x3D-x3D-0" class="headerlink" title="_milliSeconds &#x3D;&#x3D; 0"></a>_milliSeconds &#x3D;&#x3D; 0</h4><p>先看一下<code>_milliSeconds</code>为0的情况：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue one message for each zero timer. To be able to distinguish from</span></span><br><span class="line">  <span class="comment">// EventHandler messages we send a _ZERO_EVENT instead of a _TIMEOUT_EVENT.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _notifyZeroHandler() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_receivePortActive) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    _sendPort!.send(_ZERO_EVENT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的分析，<code>_sendPort!.send(_ZERO_EVENT)</code>发送的消息，通过<code>MessageHandler::PostMessage</code>处理，最后调用<code>_receivePort</code>的handler也就是在<code>_handleMessage(msg)</code>方法中执行。</p>
<h4 id="milliSeconds-≠-0"><a href="#milliSeconds-≠-0" class="headerlink" title="_milliSeconds ≠ 0"></a>_milliSeconds ≠ 0</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _notifyEventHandler() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_handlingCallbacks) &#123;</span><br><span class="line">      <span class="comment">// While we are already handling callbacks we will not notify the event</span></span><br><span class="line">      <span class="comment">// handler. _handleTimeout will call _notifyEventHandler once all pending</span></span><br><span class="line">      <span class="comment">// timers are processed.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are no pending timers. Close down the receive port.</span></span><br><span class="line">    <span class="keyword">if</span> ((_firstZeroTimer == <span class="keyword">null</span>) &amp;&amp; _heap.isEmpty) &#123;</span><br><span class="line">      <span class="comment">// No pending timers: Close the receive port and let the event handler</span></span><br><span class="line">      <span class="comment">// know.</span></span><br><span class="line">      <span class="keyword">if</span> (_sendPort != <span class="keyword">null</span>) &#123;</span><br><span class="line">        _cancelWakeup();</span><br><span class="line">        _shutdownTimerHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_heap.isEmpty) &#123;</span><br><span class="line">      <span class="comment">// Only zero timers are left. Cancel any scheduled wakeups.</span></span><br><span class="line">      _cancelWakeup();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Only send a message if the requested wakeup time differs from the</span></span><br><span class="line">    <span class="comment">// already scheduled wakeup time.</span></span><br><span class="line">    <span class="keyword">var</span> wakeupTime = _heap.first._wakeupTime;</span><br><span class="line">    <span class="keyword">if</span> ((_scheduledWakeupTime == <span class="number">0</span>) || (wakeupTime != _scheduledWakeupTime)) &#123;</span><br><span class="line">      _scheduleWakeup(wakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the event handler to wake this isolate at a specific time.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _scheduleWakeup(<span class="built_in">int</span> wakeupTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_receivePortActive) &#123;</span><br><span class="line">      _createTimerHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    VMLibraryHooks.eventHandlerSendData(<span class="keyword">null</span>, _sendPort!, wakeupTime);</span><br><span class="line">    _scheduledWakeupTime = wakeupTime;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可见，当_milliSeconds ≠ 0的时候，会将其加入到<code>_heap</code>中，如果当前的timer是<code>_heap</code>中第一个，则调用<code>_notifyEventHandler()</code>告诉event handler<strong>在指定的时间唤起isolate</strong>。</p>
<p>这里主要的实现是<code>VMLibraryHooks.eventHandlerSendData</code>，他的实现如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\bin\common_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">&quot;vm:entry-point&quot;</span>, <span class="string">&quot;call&quot;</span>)</span><br><span class="line">_setupHooks() &#123;</span><br><span class="line">  VMLibraryHooks.eventHandlerSendData = _EventHandler._sendData;</span><br><span class="line">  VMLibraryHooks.timerMillisecondClock = _EventHandler._timerMillisecondClock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\bin\eventhandler_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_EventHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;EventHandler_SendData&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="keyword">void</span> _sendData(<span class="built_in">Object?</span> sender, SendPort sendPort, <span class="built_in">int</span> data);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&quot;vm:external-name&quot;</span>, <span class="string">&quot;EventHandler_TimerMillisecondClock&quot;</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="built_in">int</span> _timerMillisecondClock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; runtime\bin\eventhandler.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Send data to the EventHandler thread to register for a given instance</span></span><br><span class="line"><span class="comment"> * args[0] a ReceivePort args[1] with a notification event args[2].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> FUNCTION_NAME(EventHandler_SendData)(Dart_NativeArguments args) &#123;</span><br><span class="line">  <span class="comment">// Get the id out of the send port. If the handle is not a send port</span></span><br><span class="line">  <span class="comment">// we will get an error and propagate that out.</span></span><br><span class="line">  Dart_Handle handle = Dart_GetNativeArgument(args, <span class="number">1</span>);</span><br><span class="line">  Dart_Port dart_port;</span><br><span class="line">  handle = Dart_SendPortGetId(handle, &amp;dart_port);</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsError(handle)) &#123;</span><br><span class="line">    Dart_PropagateError(handle);</span><br><span class="line">    UNREACHABLE();</span><br><span class="line">  &#125;</span><br><span class="line">  Dart_Handle sender = Dart_GetNativeArgument(args, <span class="number">0</span>);</span><br><span class="line">  intptr_t id;</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsNull(sender)) &#123;</span><br><span class="line">    id = kTimerId;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Socket* socket = Socket::GetSocketIdNativeField(sender);</span><br><span class="line">    ASSERT(dart_port != ILLEGAL_PORT);</span><br><span class="line">    socket-&gt;set_port(dart_port);</span><br><span class="line">    socket-&gt;Retain();  <span class="comment">// inc refcount before sending to the eventhandler.</span></span><br><span class="line">    id = reinterpret_cast&lt;intptr_t&gt;(socket);</span><br><span class="line">  &#125;</span><br><span class="line">  int64_t data = DartUtils::GetIntegerValue(Dart_GetNativeArgument(args, <span class="number">2</span>));</span><br><span class="line">  event_handler-&gt;SendData(id, dart_port, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的实现在native层的<code>EventHander</code>中名为<code>event handler</code>的子线程中<strong>通过异步IO执行任务</strong>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line"> public:</span><br><span class="line">  EventHandler() &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> SendData(intptr_t id, Dart_Port dart_port, int64_t data) &#123;</span><br><span class="line">    delegate_.SendData(id, dart_port, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的系统实现不同，对于Android来说：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; runtime\bin\eventhandler_android.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> EventHandlerImplementation::SendData(intptr_t id,</span><br><span class="line">                                          Dart_Port dart_port,</span><br><span class="line">                                          int64_t data) &#123;</span><br><span class="line">  WakeupHandler(id, dart_port, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> EventHandlerImplementation::WakeupHandler(intptr_t id,</span><br><span class="line">                                               Dart_Port dart_port,</span><br><span class="line">                                               int64_t data) &#123;</span><br><span class="line">  InterruptMessage msg;</span><br><span class="line">  msg.id = id;</span><br><span class="line">  msg.dart_port = dart_port;</span><br><span class="line">  msg.data = data;</span><br><span class="line">  <span class="comment">// WriteToBlocking will write up to 512 bytes atomically, and since our msg</span></span><br><span class="line">  <span class="comment">// is smaller than 512, we don&#x27;t need a thread lock.</span></span><br><span class="line">  <span class="comment">// See: http://linux.die.net/man/7/pipe, section &#x27;Pipe_buf&#x27;.</span></span><br><span class="line">  ASSERT(kInterruptMessageSize &lt; PIPE_BUF);</span><br><span class="line">  intptr_t result =</span><br><span class="line">      FDUtils::WriteToBlocking(interrupt_fds_[<span class="number">1</span>], &amp;msg, kInterruptMessageSize);</span><br><span class="line">  <span class="keyword">if</span> (result != kInterruptMessageSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;Interrupt message failure:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FATAL1(<span class="string">&quot;Interrupt message failure. Wrote %&quot;</span> Pd <span class="string">&quot; bytes.&quot;</span>, result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后系统会在时间到了之后，会调用<code>EventHandlerImplementation::HandleEvents</code>通过<code>_send_port</code>发送消息，并触发<code>_receivePort</code>的hander也就是<code>_handleMessage</code>方法处理消息。</p>
<h4 id="handleMessage"><a href="#handleMessage" class="headerlink" title="_handleMessage"></a>_handleMessage</h4><p>无论是_milliSeconds &#x3D;&#x3D; 0 的时候<code>_sendPort!.send(_ZERO_EVENT);</code>，还是_milliSeconds !&#x3D; 0 通过<code>EventHandler</code>发送_TIMEOUT_EVENT消息，最终都会使用<code>_handleMessage</code>处理消息：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _handleMessage(msg) &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;_Timer&gt; pendingTimers;</span><br><span class="line">    <span class="keyword">if</span> (msg == _ZERO_EVENT) &#123;</span><br><span class="line">      pendingTimers = _queueFromZeroEvent();</span><br><span class="line">      <span class="keyword">assert</span>(pendingTimers.length &gt; <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span>(msg == _TIMEOUT_EVENT);</span><br><span class="line">      _scheduledWakeupTime = <span class="number">0</span>; <span class="comment">// Consumed the last scheduled wakeup now.</span></span><br><span class="line">      pendingTimers = _queueFromTimeoutEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    _runTimers(pendingTimers);</span><br><span class="line">    <span class="comment">// Notify the event handler or shutdown the port if no more pending</span></span><br><span class="line">    <span class="comment">// timers are present.</span></span><br><span class="line">    _notifyEventHandler();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_handleMessage</code>中按照msg的类型取出对应的<code>pendingTimers</code>然后再<code>_runTimers</code>中执行，在执行完毕或者遇到错误时，调用<code>_notifyEventHandler()</code>通知<code>event handler</code>或者关闭<code>TimerHandler</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; sdk\lib\_internal\vm\lib\timer_impl.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _runTimers(<span class="built_in">List</span>&lt;_Timer&gt; pendingTimers) &#123;</span><br><span class="line">    <span class="comment">// If there are no pending timers currently reset the id space before we</span></span><br><span class="line">    <span class="comment">// have a chance to enqueue new timers.</span></span><br><span class="line">    <span class="keyword">if</span> (_heap.isEmpty &amp;&amp; (_firstZeroTimer == <span class="keyword">null</span>)) &#123;</span><br><span class="line">      _idCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast exit if no pending timers.</span></span><br><span class="line">    <span class="keyword">if</span> (pendingTimers.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all of the pending timers. New timers added as part of the</span></span><br><span class="line">    <span class="comment">// callbacks will be enqueued now and notified in the next spin at the</span></span><br><span class="line">    <span class="comment">// earliest.</span></span><br><span class="line">    _handlingCallbacks = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 在这里遍历处理所有的pendingTimers</span></span><br><span class="line">      <span class="keyword">for</span> (; i &lt; pendingTimers.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Next pending timer.</span></span><br><span class="line">        <span class="keyword">var</span> timer = pendingTimers[i];</span><br><span class="line">        timer._indexOrNext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// One of the timers in the pending_timers list can cancel</span></span><br><span class="line">        <span class="comment">// one of the later timers which will set the callback to</span></span><br><span class="line">        <span class="comment">// null. Or the pending zero timer has been canceled earlier.</span></span><br><span class="line">        <span class="keyword">var</span> callback = timer._callback;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!timer._repeating) &#123;</span><br><span class="line">            <span class="comment">// Mark timer as inactive.</span></span><br><span class="line">            timer._callback = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer._milliSeconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> ms = timer._milliSeconds;</span><br><span class="line">            <span class="built_in">int</span> overdue =</span><br><span class="line">                VMLibraryHooks.timerMillisecondClock() - timer._wakeupTime;</span><br><span class="line">            <span class="keyword">if</span> (overdue &gt; ms) &#123;</span><br><span class="line">              <span class="built_in">int</span> missedTicks = overdue ~/ ms;</span><br><span class="line">              timer._wakeupTime += missedTicks * ms;</span><br><span class="line">              timer._tick += missedTicks;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          timer._tick += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          callback(timer);</span><br><span class="line">          <span class="comment">// Re-insert repeating timer if not canceled.</span></span><br><span class="line">          <span class="keyword">if</span> (timer._repeating &amp;&amp; (timer._callback != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            timer._advanceWakeupTime();</span><br><span class="line">            timer._enqueue();</span><br><span class="line">          &#125;</span><br><span class="line">					<span class="comment">// 每次执行完event之后，都要执行没有被执行的micro task</span></span><br><span class="line">          <span class="comment">// Execute pending micro tasks.</span></span><br><span class="line">          _runPendingImmediateCallback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _handlingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// Re-queue timers we didn&#x27;t get to.</span></span><br><span class="line">      <span class="keyword">for</span> (i++; i &lt; pendingTimers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> timer = pendingTimers[i];</span><br><span class="line">        timer._enqueue();</span><br><span class="line">      &#125;</span><br><span class="line">      _notifyEventHandler();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，这里依次遍历传入的pendingTimers，并在每次执行完event后，去检查执行一下micro task。</p>
<br>

<p>根据创建Timer的时候_milliSeconds是否等于0：会分别使用<code>MessageHandler</code><strong>执行</strong>或者在<strong>名为event handler的IO线程</strong>通过<code>isolate</code>中的<code>MessageHandler</code>来执行任务；最后都会触发Timer的<code>_handleMessage</code>方法在<code>_runTimers</code>方法中执行callback。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>综上，dart中的方法总共有3种，按照优先级从前到后依次是：</p>
<ol>
<li>普通的同步方法</li>
<li>micro task</li>
<li>其他event：部分Future、Timer、点击事件、屏幕刷新等</li>
</ol>
<p>在方法执行的时候：</p>
<ol>
<li>先执行完毕所有的同步方法；</li>
<li>然后判断是否有micro task，有的话就立即执行；</li>
<li>否则，就执行普通的event，每次执行完一个event就执行一次步骤2；</li>
<li>直到当前app中既没有micro task也没有普通的event，退出app。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://github.com/dart-lang/sdk">dart sdk</a></p>
<p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20170704074724/https://webdev.dartlang.org/articles/performance/event-loop">The Event Loop and Dart</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904196819402759#heading-0">Flutter之Future原理解析 - 掘金</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904196819386375">Flutter之Timer原理解析 - 掘金</a></p>
<p><a target="_blank" rel="noopener" href="https://dart.dev/">Dart 官网</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>JI, XIAOYONG
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jixiaoyong.github.io/blog/posts/db62c118/" title="Dart event loop">https://jixiaoyong.github.io/blog/posts/db62c118/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/dart/" rel="tag"># dart</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/posts/3db5282/" rel="prev" title="Dart 读取文件过程分析">
                  <i class="fa fa-chevron-left"></i> Dart 读取文件过程分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/posts/4cbcfe72/" rel="next" title="Flutter APP绘制过程简析">
                  Flutter APP绘制过程简析 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JI, XIAOYONG</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>





  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://vercel.xiaoyong.ml","cssUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css","commentCount":true,"pageview":true,"libUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.js","locale":{"placeholder":"ヾ(=^▽^=)ノ"},"meta":["nick","mail","link"],"login":"enable","pageSize":10,"el":"#waline","comment":true,"path":"/blog/posts/db62c118/"}</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
