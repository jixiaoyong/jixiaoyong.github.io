<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/https/jixiaoyong.github.io/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/favicon.ico">
  <link rel="mask-icon" href="/blog/https/jixiaoyong.github.io/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jixiaoyong.github.io","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":true,"version":"8.12.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：  基于 RenderBox 的 box protocol 实现的，主要基于 Size 实现布局。常见的有SingleChildScrollView。 基于 RenderSliver 的 sliver protocol 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrol">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter滑动分析之NestedScrollView">
<meta property="og:url" content="https://jixiaoyong.github.io/blog/posts/ae8e53be/index.html">
<meta property="og:site_name" content="Ji Xiaoyong&#39;s Blog">
<meta property="og:description" content="Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：  基于 RenderBox 的 box protocol 实现的，主要基于 Size 实现布局。常见的有SingleChildScrollView。 基于 RenderSliver 的 sliver protocol 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrol">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-19T09:48:12.000Z">
<meta property="article:modified_time" content="2022-07-22T09:56:34.408Z">
<meta property="article:author" content="JI, XIAOYONG">
<meta property="article:tag" content="flutter">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jixiaoyong.github.io/blog/posts/ae8e53be/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jixiaoyong.github.io/blog/posts/ae8e53be/","path":"posts/ae8e53be/","title":"Flutter滑动分析之NestedScrollView"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Flutter滑动分析之NestedScrollView | Ji Xiaoyong's Blog</title>
  




<link rel="dns-prefetch" href="https://vercel.xiaoyong.ml">
  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ji Xiaoyong's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E4%BE%8B"><span class="nav-text">用例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NestedScrollViewState"><span class="nav-text">NestedScrollViewState</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NestedScrollController"><span class="nav-text">_NestedScrollController</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-NestedScrollPosition"><span class="nav-text">创建_NestedScrollPosition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8ScrollPosition%E5%8F%98%E5%8C%96%E6%97%B6%E9%80%9A%E7%9F%A5coordinator"><span class="nav-text">在ScrollPosition变化时通知coordinator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NestedScrollPosition"><span class="nav-text">_NestedScrollPosition</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setParent"><span class="nav-text">setParent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#absorb"><span class="nav-text">absorb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applyClampedDragUpdate"><span class="nav-text">applyClampedDragUpdate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applyFullDragUpdate"><span class="nav-text">applyFullDragUpdate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applyClampedPointerSignalUpdate"><span class="nav-text">applyClampedPointerSignalUpdate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NestedScrollCoordinator"><span class="nav-text">_NestedScrollCoordinator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#beginActivity"><span class="nav-text">beginActivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applyUserOffset"><span class="nav-text">applyUserOffset</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="nav-text">优劣对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JI, XIAOYONG"
      src="//jixiaoyong.github.io/images/default_avatar.jpg">
  <p class="site-author-name" itemprop="name">JI, XIAOYONG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jixiaoyong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jixiaoyong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jixiaoyong1995@gmail.com" title="E-Mail → mailto:jixiaoyong1995@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jixiaoyong.github.io/blog/posts/ae8e53be/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//jixiaoyong.github.io/images/default_avatar.jpg">
      <meta itemprop="name" content="JI, XIAOYONG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Flutter滑动分析之NestedScrollView | Ji Xiaoyong's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flutter滑动分析之NestedScrollView<a href="https://github.com/jixiaoyong/blog_source_code/edit/master/blog/source/_posts/Flutter%E6%BB%91%E5%8A%A8%E5%88%86%E6%9E%90%E4%B9%8BNestedScrollView.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-19 17:48:12" itemprop="dateCreated datePublished" datetime="2022-07-19T17:48:12+08:00">2022-07-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-22 17:56:34" itemprop="dateModified" datetime="2022-07-22T17:56:34+08:00">2022-07-22</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/blog/posts/ae8e53be/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/blog/posts/ae8e53be/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/blog/posts/ae8e53be/"></span>
    </span>
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：</p>
<ul>
<li>基于 RenderBox 的 box protocol 实现的，主要基于 Size 实现布局。常见的有<a target="_blank" rel="noopener" href="https://xiaoyong.ml/blog/posts/d3bdcb53/">SingleChildScrollView</a>。</li>
<li>基于 RenderSliver 的 sliver protocol 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自<a target="_blank" rel="noopener" href="https://xiaoyong.ml/blog/posts/60f8d92f/">ScrollView</a>的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。</li>
</ul>
<p>上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。</p>
<p>本文只对 NestedScrollView 的源码实现做一简单分析：它是如何实现联动滚动效果，有什么优势和限制。</p>
<p>官方对其定义是：“A scrolling view inside of which can be nested other scrolling views, with their scroll positions being intrinsically linked.”。</p>
<p>顾名思义，NestedScrollView 是一个可以在<strong>内部嵌套其他 scrolling views 的滑动 View</strong>，按照所处位置的不同，使用<code>headerSliverBuilder</code>提供 header 部分的 scrolling views（限制只能是可以产生 RenderSliver 的 widget），而使用<code>body</code>提供在填充 header 之下所有区域的 widget（限制只能是产生 RenderBox 的 widget）。</p>
<h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><p>下面是一个 NestedScrollView 经典的使用方式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">var</span> _tabBar = TabBar(</span><br><span class="line">    isScrollable: <span class="keyword">true</span>,</span><br><span class="line">    tabs: tabs</span><br><span class="line">        .map((e) =&gt; Tab(</span><br><span class="line">              child: Container(</span><br><span class="line">                height: <span class="built_in">double</span>.infinity,</span><br><span class="line">                child: Center(child: Text(<span class="string">&quot;Tab<span class="subst">$e</span>&quot;</span>)),</span><br><span class="line">              ),</span><br><span class="line">            ))</span><br><span class="line">        .toList(),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    body: DefaultTabController(<span class="comment">// 此处的controller是给TabBar和TabBarView使用的</span></span><br><span class="line">        length: tabs.length,</span><br><span class="line">        child: NestedScrollView(</span><br><span class="line">          headerSliverBuilder: (context, innerScroll) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="comment">// 必须是能够产生RenderSliver的Widget</span></span><br><span class="line">              SliverAppBar(</span><br><span class="line">                pinned: <span class="keyword">true</span>,</span><br><span class="line">                toolbarHeight: <span class="number">0</span>,</span><br><span class="line">                expandedHeight: <span class="number">200</span>,</span><br><span class="line">                bottom: _tabBar,<span class="comment">//在这里传入TabBar</span></span><br><span class="line">              ),</span><br><span class="line">            ];</span><br><span class="line">          &#125;,</span><br><span class="line">          body: TabBarView(<span class="comment">// body必须是能产生RenderBox的widget</span></span><br><span class="line">              children: tabs</span><br><span class="line">                  .map((e) =&gt; ListView(<span class="comment">// 这里的列表滑动和header的滑动联动</span></span><br><span class="line">                        children: <span class="built_in">List</span>.generate(</span><br><span class="line">                            <span class="number">100</span>,</span><br><span class="line">                            (index) =&gt; SizedBox(</span><br><span class="line">                                height: <span class="number">80</span>,</span><br><span class="line">                                child: Text(<span class="string">&quot;Hello TabBarView <span class="subst">$e</span>   <span class="subst">$index</span>&quot;</span>))),</span><br><span class="line">                      ))</span><br><span class="line">                  .toList()),</span><br><span class="line">        )),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，NestedScrollView 包括了 headerSliverBuilder 创建的 header 部分，以及 header 下面的 body 部分，二者的滑动效果联动在一起，好像是同一个 scrolling view。比如，当向上滑动 TabBarView 中列表时，会先向上滑动 header 内容，等到 header 无需再滑动才会向上滑动列表。</p>
<p>而如果没有 NestedScrollView 的话，ListView 和 header 的滑动是独立的两个事件。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>NestedScrollView 本质上还是对 CustomScrollView（的子类_NestedScrollViewCustomScrollView）的进一步封装。</p>
<p>它借助于_NestedScrollCoordinator 的<code>_outerController</code> 和<code>_innerController</code> 这两个分别传入_NestedScrollViewCustomScrollView（header 和 body 其实是他的 <code>slivers</code>） 和 body 中的 scrolling view 的 ScrollController，创建并应用_NestedScrollPosition；当用户滑动等事件发生，通过_NestedScrollPosition 将 header 和 body 中的滑动事件全部归集到_NestedScrollCoordinator 统一处理，从而实现了这两处滑动事件的联动。</p>
<p>所以，在分析 NestedScrollView 的时候，主要涉及到以下类：</p>
<ul>
<li><strong>NestedScrollViewState</strong>：是 NestedScrollView 真正执行逻辑的类，将_NestedScrollCoordinator、_NestedScrollViewCustomScrollView、ScrollController 等组装在一起，对外暴露操纵_NestedScrollCoordinator 的方法</li>
<li>_NestedScrollViewCustomScrollView：继承自 CustomScrollView，主要作用是创建自定义的 NestedScrollViewViewport，后者又创建了 RenderNestedScrollViewViewport 主要用途是更新 SliverOverlapAbsorberHandle</li>
<li><strong>_NestedScrollCoordinator</strong>：处理_NestedScrollPosition 转发过来的滑动事件，将其分发给 header（其实是容纳 header 和 body 的_NestedScrollViewCustomScrollView）和 body。</li>
<li><strong>_NestedScrollController</strong>：给_NestedScrollCoordinator 的 inner 和 outer 的 ScrollController，内部创建_NestedScrollPosition。</li>
<li><strong>_NestedScrollPosition</strong>：给_NestedScrollCoordinator 的 inner 和 outer 的 ScrollPosition，会将 animateTo、jumpTo、pointerScroll、updateCanDrag、hold、drag 等和滑动有关的事件转发给_NestedScrollCoordinator 统一处理。</li>
</ul>
<p>下面对这些类逐一分析：</p>
<h2 id="NestedScrollViewState"><a href="#NestedScrollViewState" class="headerlink" title="NestedScrollViewState"></a>NestedScrollViewState</h2><p>NestedScrollView是StatefulWidget，其主要逻辑都在创建的State——NestedScrollViewState中。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedScrollView</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; _buildSlivers(BuildContext context, ScrollController innerController, <span class="built_in">bool</span> bodyIsScrolled) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Widget&gt;[</span><br><span class="line">      ...headerSliverBuilder(context, bodyIsScrolled),</span><br><span class="line">      SliverFillRemaining(</span><br><span class="line">        child: PrimaryScrollController(</span><br><span class="line">          controller: innerController,</span><br><span class="line">          child: body,<span class="comment">// SliverFillRemaining只能容纳可以产生RenderBox的widget</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  NestedScrollViewState createState() =&gt; NestedScrollViewState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NestedScrollView._buildSlivers方法将headerSliverBuilder创建的header和body放到一个列表中，会被NestedScrollViewState传入到自定义的CustomScrollView——_NestedScrollViewCustomScrollView中。</p>
<p>需要注意SliverFillRemaining默认会创建_SliverFillRemainingWithScrollable，后者创建的RenderObject是_SliverFillRemainingWithScrollable。在RenderSliverFillRemainingWithScrollable.performLayout方法会使用他所处viewport主轴方向的尺寸作为自己的scrollExtent。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">  <span class="keyword">final</span> SliverConstraints constraints = <span class="keyword">this</span>.constraints;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> extent = constraints.remainingPaintExtent - math.min(constraints.overlap, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    child!.layout(constraints.asBoxConstraints(</span><br><span class="line">      minExtent: extent,</span><br><span class="line">      maxExtent: extent,</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> paintedChildSize = calculatePaintOffset(constraints, from: <span class="number">0.0</span>, to: extent);</span><br><span class="line">  <span class="keyword">assert</span>(paintedChildSize.isFinite);</span><br><span class="line">  <span class="keyword">assert</span>(paintedChildSize &gt;= <span class="number">0.0</span>);</span><br><span class="line">  geometry = SliverGeometry(</span><br><span class="line">    scrollExtent: constraints.viewportMainAxisExtent,<span class="comment">// 这里使用的是viewport的主轴尺寸</span></span><br><span class="line">    paintExtent: paintedChildSize,</span><br><span class="line">    maxPaintExtent: paintedChildSize,</span><br><span class="line">    hasVisualOverflow: extent &gt; constraints.remainingPaintExtent || constraints.scrollOffset &gt; <span class="number">0.0</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    setChildParentData(child!, constraints, geometry!);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说无论inner scroll view的尺寸如何，它（下面称其为body）占用的scrollExtent都是所处的viewport的主轴尺寸mainAxisExtent；再加上headerSliverBuilder方法创建的header，导致_NestedScrollViewCustomScrollView所创建的viewport的最大可滑动范围_maxScrollExtent（其值等于header+body的scrollExtent）大于viewport的主轴方向尺寸mainAxisExtent，从而计算出_NestedScrollViewCustomScrollView的ScrollPosition的范围最大为:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_outScrollPosition.maxScrollExtent = viewport._maxScrollExtent - viewport.mainAxisExtent</span><br><span class="line">                = (body.scrollExtent + header.scrollExtent) - viewport.mainAxisExtent</span><br><span class="line">                = (viewport.mainAxisExtent + header.scrollExtent) - viewport.mainAxisExtent</span><br><span class="line">                = header.scrollExtent</span><br></pre></td></tr></table></figure>

<p>所以，无论NestedScrollView的body内容尺寸如何，它为header+body分配的尺寸只比viewport的尺寸多出一个header的尺寸。这个也是NestedScrollView实现协调header和body滑动的基础。</p>
<p>让我们再看一下NestedScrollViewState的实现：</p>
<p>NestedScrollViewState中一个重要的属性就是<code>_NestedScrollCoordinator? _coordinator</code>，它在<code>initState()</code>方法中初始化。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedScrollViewState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NestedScrollView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// inner和outer controller都来自_coordinator</span></span><br><span class="line">  ScrollController <span class="keyword">get</span> innerController =&gt; _coordinator!._innerController;</span><br><span class="line">  ScrollController <span class="keyword">get</span> outerController =&gt; _coordinator!._outerController;</span><br><span class="line"></span><br><span class="line">  _NestedScrollCoordinator? _coordinator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _coordinator = _NestedScrollCoordinator(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      widget.controller,<span class="comment">// 注意这里传入了widget处获取的controller</span></span><br><span class="line">      _handleHasScrolledBodyChanged,</span><br><span class="line">      widget.floatHeaderSlivers,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能注意到，_NestedScrollCoordinator中持有了widget.controller，并且还会在didChangeDependencies、didUpdateWidget方法被调用时通过_NestedScrollCoordinator.setParent方法更新。</p>
<p>然后，在NestedScrollViewState.build方法中，会创建_NestedScrollViewCustomScrollView对象：</p>
<ul>
<li><p>将_coordinator!._outerController作为其controller，这样_coordinator便接管了外层的滑动事件；</p>
</li>
<li><p>此外在NestedScrollView._buildSlivers方法中创建的header和body作为_NestedScrollViewCustomScrollView也就是CustomScrollView的slivers。</p>
<p>这也是创建header的NestedScrollView.headerSliverBuilder只接受可以创建RenderSliver的widget的原因。</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">final</span> ScrollPhysics scrollPhysics = widget.physics?.applyTo(<span class="keyword">const</span> ClampingScrollPhysics())</span><br><span class="line">    ?? widget.scrollBehavior?.getScrollPhysics(context).applyTo(<span class="keyword">const</span> ClampingScrollPhysics())</span><br><span class="line">    ?? <span class="keyword">const</span> ClampingScrollPhysics();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _InheritedNestedScrollView(</span><br><span class="line">    state: <span class="keyword">this</span>,</span><br><span class="line">    child: Builder(</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        _lastHasScrolledBody = _coordinator!.hasScrolledBody;</span><br><span class="line">        <span class="keyword">return</span> _NestedScrollViewCustomScrollView(</span><br><span class="line">          dragStartBehavior: widget.dragStartBehavior,</span><br><span class="line">          scrollDirection: widget.scrollDirection,</span><br><span class="line">          reverse: widget.reverse,</span><br><span class="line">          physics: scrollPhysics,</span><br><span class="line">          scrollBehavior: widget.scrollBehavior ?? ScrollConfiguration.of(context).copyWith(scrollbars: <span class="keyword">false</span>),</span><br><span class="line">          <span class="comment">// 注意这里使用的从_coordinator获取的_outerController</span></span><br><span class="line">          controller: _coordinator!._outerController,</span><br><span class="line">          <span class="comment">// 这里将header和body传入slivers，</span></span><br><span class="line">          <span class="comment">// _NestedScrollViewCustomScrollView创建的viewport是继承自</span></span><br><span class="line">          <span class="comment">// Viewport的NestedScrollViewViewport，其只接受可以创建</span></span><br><span class="line">          <span class="comment">// RenderSliver的widget</span></span><br><span class="line">          slivers: widget._buildSlivers(</span><br><span class="line">            context,</span><br><span class="line">            _coordinator!._innerController,</span><br><span class="line">            _lastHasScrolledBody!,</span><br><span class="line">          ),</span><br><span class="line">          handle: _absorberHandle,</span><br><span class="line">          clipBehavior: widget.clipBehavior,</span><br><span class="line">          restorationId: widget.restorationId,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_NestedScrollViewCustomScrollView继承自CustomScrollView，主要作用是创建继承自Viewport的NestedScrollViewViewport，而后者又主要负责创建和更新继承自RenderViewport的RenderNestedScrollViewViewport——其在内部更新和维护SliverOverlapAbsorberHandle。</p>
<blockquote>
<p><code>SliverOverlapAbsorberHandle</code>: Handle to provide to a <code>SliverOverlapAbsorber</code>, a <code>SliverOverlapInjector</code>, and an <code>NestedScrollViewViewport</code>, to shift overlap in a <code>NestedScrollView</code>.</p>
</blockquote>
<p>到目前位置，UI展示部分的内容已经完成，我们的NestedScrollView可以将header和body显示在屏幕上面，但是如果要联动处理在header和body上面的滑动事件，还需要_NestedScrollCoordinator、_NestedScrollController和_NestedScrollPosition的配合。</p>
<h2 id="NestedScrollController"><a href="#NestedScrollController" class="headerlink" title="_NestedScrollController"></a>_NestedScrollController</h2><p>_NestedScrollController继承自ScrollController，其逻辑比较简单，主要添加了两项功能：</p>
<h3 id="创建-NestedScrollPosition"><a href="#创建-NestedScrollPosition" class="headerlink" title="创建_NestedScrollPosition"></a>创建_NestedScrollPosition</h3><p>创建_NestedScrollPosition的逻辑比较简单，主要是将coordinator也一并传入。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ScrollPosition createScrollPosition(</span><br><span class="line">  ScrollPhysics physics,</span><br><span class="line">  ScrollContext context,</span><br><span class="line">  ScrollPosition? oldPosition,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> _NestedScrollPosition(</span><br><span class="line">    coordinator: coordinator,</span><br><span class="line">    physics: physics,</span><br><span class="line">    context: context,</span><br><span class="line">    initialPixels: initialScrollOffset,</span><br><span class="line">    oldPosition: oldPosition,</span><br><span class="line">    debugLabel: debugLabel,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在ScrollPosition变化时通知coordinator"><a href="#在ScrollPosition变化时通知coordinator" class="headerlink" title="在ScrollPosition变化时通知coordinator"></a>在ScrollPosition变化时通知coordinator</h3><p>在attach(ScrollPosition position)中调用_scheduleUpdateShadow()和_NestedScrollCoordinator的updateParent、updateCanDrag，对传入的ScrollPosition添加回调_scheduleUpdateShadow()。</p>
<p>在detach(ScrollPosition position)中调用_scheduleUpdateShadow()，对传入的ScrollPosition移除回调_scheduleUpdateShadow()。</p>
<p>而这个_scheduleUpdateShadow()方法主要作用是异步执行coordinator.updateShadow()更新NestedScrollView，实现滑动效果。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _scheduleUpdateShadow() &#123;</span><br><span class="line">  <span class="comment">// We do this asynchronously for attach() so that the new position has had</span></span><br><span class="line">  <span class="comment">// time to be initialized, and we do it asynchronously for detach() and from</span></span><br><span class="line">  <span class="comment">// the position change notifications because those happen synchronously</span></span><br><span class="line">  <span class="comment">// during a frame, at a time where it&#x27;s too late to call setState. Since the</span></span><br><span class="line">  <span class="comment">// result is usually animated, the lag incurred is no big deal.</span></span><br><span class="line">  SchedulerBinding.instance.addPostFrameCallback(</span><br><span class="line">    (<span class="built_in">Duration</span> timeStamp) &#123;</span><br><span class="line">      coordinator.updateShadow();</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NestedScrollPosition"><a href="#NestedScrollPosition" class="headerlink" title="_NestedScrollPosition"></a>_NestedScrollPosition</h2><p>在inner scrolling widget和outer viewport都使用_NestedScrollPosition，它追踪这些viewport使用的offset，并且内部持有_NestedScrollCoordinator，所以此class上触发activities时，可以推迟或者影响coordinator。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NestedScrollPosition</span> <span class="keyword">extends</span> <span class="title">ScrollPosition</span> <span class="keyword">implements</span> <span class="title">ScrollActivityDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _NestedScrollCoordinator coordinator; <span class="comment">// 协调inner和outer滑动事件</span></span><br><span class="line">  <span class="comment">// 是在NestedScrollView中传给_NestedScrollViewCustomScrollView的ScrollController</span></span><br><span class="line">  ScrollController? _parent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setParent(ScrollController? value) &#123;</span><br><span class="line">    _parent?.detach(<span class="keyword">this</span>);</span><br><span class="line">    _parent = value;</span><br><span class="line">    _parent?.attach(<span class="keyword">this</span>);<span class="comment">// 将此ScrollPosition和_parent绑定</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setParent"><a href="#setParent" class="headerlink" title="setParent"></a>setParent</h3><p>_NestedScrollPosition.setParent中，将自己和传入的ScrollController绑定在一起：</p>
<ul>
<li>将自身加入ScrollController._positions</li>
<li>ScrollController监听自身变化时执行notifyListeners通知监听者</li>
</ul>
<h3 id="absorb"><a href="#absorb" class="headerlink" title="absorb"></a>absorb</h3><p>在absorb方法中将activity的delegate更新为当前ScrollPosition：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> absorb(ScrollPosition other) &#123;</span><br><span class="line">  <span class="keyword">super</span>.absorb(other);</span><br><span class="line">  <span class="comment">// 部分activity会使用此来操作scroll view</span></span><br><span class="line">  activity!.updateDelegate(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyClampedDragUpdate"><a href="#applyClampedDragUpdate" class="headerlink" title="applyClampedDragUpdate"></a>applyClampedDragUpdate</h3><p>此方法返回的是没有使用的delta，此方法不会主动创建overscroll&#x2F;underscroll，如果当前ScrollPosition在范围内，则不会发送overscroll&#x2F;underscroll；如果已经超出范围，则只会“减轻”这种情况，而不会“加重”。</p>
<p>之所以不会overscroll，是因为min和max的取值限定了他们的范围，以一个垂直方向向下布局的滑动列表为例：</p>
<ul>
<li><p>delat &lt; 0，即向上滑动，范围是 min：-double.infinity ~ max： 0（overscroll时）或者 maxScrollExtent和pixels中最大值（只能滑到最大范围）。</p>
<p>也就是说，向上滑动时，如果已经在顶部出现overscroll（此时pixels应该为负值），那么最多滑动到0（也就是恢复到初始位置），没有顶部overscroll时（此时pixels为正值，可能在maxScrollExtent范围内，也可能超出范围，即底部出现overscroll），那么此时最多向上滑动maxScrollExtent和pixels，也就是说要么不能超范围，要是超了范围，就不能再超了。</p>
<p>而最小滑动范围为-double.infinity，无论pixels正负，当其delta为负时，其值都只会增大，取值-double.infinity是为了将pixels包含在内。</p>
</li>
<li><p>delta &gt; 0，即向下滑动，范围是 min：minScrollExtent和pixels最小值 ~ double.infinity。</p>
<p>也就是说，向下滑动最小到初始位置，最大值不限定（因为此时可能offset已经由于某种原因超过maxScrollExtent了）。</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the amount of delta that was not used.</span></span><br><span class="line"><span class="comment">// Positive delta means going down (exposing stuff above), negative delta</span></span><br><span class="line"><span class="comment">// going up (exposing stuff below).</span></span><br><span class="line"><span class="built_in">double</span> applyClampedDragUpdate(<span class="built_in">double</span> delta) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(delta != <span class="number">0.0</span>);</span><br><span class="line">  <span class="comment">// If we are going towards the maxScrollExtent (negative scroll offset),</span></span><br><span class="line">  <span class="comment">// then the furthest we can be in the minScrollExtent direction is negative</span></span><br><span class="line">  <span class="comment">// infinity. For example, if we are already overscrolled, then scrolling to</span></span><br><span class="line">  <span class="comment">// reduce the overscroll should not disallow the overscroll.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If we are going towards the minScrollExtent (positive scroll offset),</span></span><br><span class="line">  <span class="comment">// then the furthest we can be in the minScrollExtent direction is wherever</span></span><br><span class="line">  <span class="comment">// we are now, if we are already overscrolled (in which case pixels is less</span></span><br><span class="line">  <span class="comment">// than the minScrollExtent), or the minScrollExtent if we are not.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// In other words, we cannot, via applyClampedDragUpdate, _enter_ an</span></span><br><span class="line">  <span class="comment">// overscroll situation.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// An overscroll situation might be nonetheless entered via several means.</span></span><br><span class="line">  <span class="comment">// One is if the physics allow it, via applyFullDragUpdate (see below). An</span></span><br><span class="line">  <span class="comment">// overscroll situation can also be forced, e.g. if the scroll position is</span></span><br><span class="line">  <span class="comment">// artificially set using the scroll controller.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// delat &lt; 0，即向上滑动，范围是 min：-double.infinity ~ max： 0</span></span><br><span class="line">  <span class="comment">//（overscroll时）或者 maxScrollExtent和pixels中最大值（只能滑到最大范围）</span></span><br><span class="line">  <span class="comment">// delta &gt; 0，即向下滑动，范围是 min：minScrollExtent和pixels最小值 ~ </span></span><br><span class="line">  <span class="comment">// double.infinity（也就是说，向下滑动最小到初始位置，最大值不限定</span></span><br><span class="line">  <span class="comment">// [因为此时可能offset已经由于某种原因超过maxScrollExtent了]）</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> min = delta &lt; <span class="number">0.0</span></span><br><span class="line">    ? -<span class="built_in">double</span>.infinity<span class="comment">// 向上滑动</span></span><br><span class="line">    : math.min(minScrollExtent, pixels);<span class="comment">// 向下滑动</span></span><br><span class="line">  <span class="comment">// The logic for max is equivalent but on the other side.</span></span><br><span class="line">  <span class="comment">// 这里的逻辑是，如果向下滑动，那么max为无限大；</span></span><br><span class="line">  <span class="comment">// 如果向上滑动并且已经overscroll了，那么max是0（即恢复初始位置），否则为maxScrollExtent即最大滑动范围</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> max = delta &gt; <span class="number">0.0</span></span><br><span class="line">    ? <span class="built_in">double</span>.infinity<span class="comment">// 向下滑动</span></span><br><span class="line">    <span class="comment">// If pixels &lt; 0.0, then we are currently in overscroll. The max should be</span></span><br><span class="line">    <span class="comment">// 0.0, representing the end of the overscrolled portion.</span></span><br><span class="line">    <span class="comment">// pixels比maxScrollExtent大可能是由于jumpTo等情况，此时max为pixels表示不能继续滑动超出此值</span></span><br><span class="line">    : pixels &lt; <span class="number">0.0</span> ? <span class="number">0.0</span> : math.max(maxScrollExtent, pixels);<span class="comment">// 向上滑动</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> oldPixels = pixels;</span><br><span class="line">  <span class="comment">//newPixels是可以应用到ScrollPosition的pixels，其范围：</span></span><br><span class="line">  <span class="comment">// 1. delta为负，即向上滑动，pixels - delta = pixels + |delta| &gt; pixels，</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.1 当pixels小于0也就是存在overscroll时，其范围是pixels + |delta|~0，</span></span><br><span class="line">  <span class="comment">// 此时overscroll偏移量为pixels + |delta|，newPixels在pixels + |delta|~0之间，【不会再加深越界】</span></span><br><span class="line">  <span class="comment">// 1.2 当pixels大于等于0也就是不存在overscroll时，其范围是pixels + |delta|~maxScrollExtent</span></span><br><span class="line">  <span class="comment">// 此时，newPixels在pixels + |delta|~maxScrollExtent之间，最大为maxScrollExtent【newPixels不会越界】</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. delta为正，即向下滑动，pixels - delta = pixels - |delta| &lt; pixels</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1 当pixels小于0也就是存在overscroll时，pixels - delta = pixels - |delta| &lt; pixels，</span></span><br><span class="line">  <span class="comment">// 其范围是（pixels和minScrollExtent较小值）~double.infinity，也就是delta不会</span></span><br><span class="line">  <span class="comment">// 被应用，newPixels会等于pixels，如果已经越界了，【不会再加深越界】</span></span><br><span class="line">  <span class="comment">// 2.2 当pixels大于等于0也就是不存在overscroll时，其范围是minScrollExtent~double.infinity，</span></span><br><span class="line">  <span class="comment">// newPixels会在minScrollExtent和pixels之间，【newPixels的值不会越界】</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> newPixels = (pixels - delta).clamp(min, max);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> clampedDelta = newPixels - pixels;<span class="comment">// 对比ScrollPosition变化的值</span></span><br><span class="line">  <span class="comment">// position的pixels为0且向下滑动时这里clampedDelta为0，不执行剩余步骤</span></span><br><span class="line">  <span class="keyword">if</span> (clampedDelta == <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">return</span> delta;</span><br><span class="line">  <span class="comment">// 返回超出界限的值overscroll，如果为0表示可以任意超出界限，不为0表示不可以应用到</span></span><br><span class="line">  <span class="comment">//ScrollPosition上的值，根据physics而不同</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> overscroll = physics.applyBoundaryConditions(<span class="keyword">this</span>, newPixels);</span><br><span class="line">  <span class="comment">// 减去了overscroll，所以这里actualNewPixels是真正可以应用的pixels</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> actualNewPixels = newPixels - overscroll;</span><br><span class="line">  <span class="comment">// offset表示经过上述计算之后，ScrollPosition实际将要产生的变化</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> offset = actualNewPixels - oldPixels;</span><br><span class="line">  <span class="keyword">if</span> (offset != <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据physics的不同，这里offset可能会导致ScrollPosition内部视觉上出现越界现象，此时overscroll为0，</span></span><br><span class="line">    <span class="comment">// 或者没有越界内容，overscroll为0或者应用了delta之后会出现的越界值</span></span><br><span class="line">    forcePixels(actualNewPixels);<span class="comment">//更新pixels</span></span><br><span class="line">    didUpdateScrollPositionBy(offset);<span class="comment">// 发出ScrollUpdateNotification通知</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// delta为负时，offset为正值；delta为正值时，offset为负值。总之delta绝对值减少了。</span></span><br><span class="line">  <span class="keyword">return</span> delta + offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyFullDragUpdate"><a href="#applyFullDragUpdate" class="headerlink" title="applyFullDragUpdate"></a>applyFullDragUpdate</h3><p>此方法在满足overscroll条件时，会应用overscroll，并发出OverscrollNotification通知。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> applyFullDragUpdate(<span class="built_in">double</span> delta) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(delta != <span class="number">0.0</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> oldPixels = pixels;</span><br><span class="line">  <span class="comment">// Apply friction:</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> newPixels = pixels - physics.applyPhysicsToUserOffset(</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    delta,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (oldPixels == newPixels)<span class="comment">// 应用delta之后没有变化，返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// delta must have been so small we dropped it during floating point addition</span></span><br><span class="line">  <span class="comment">// Check for overscroll:</span></span><br><span class="line">  <span class="comment">// 按照physics的规则，如果可以overscroll则返回0，下面的actualNewPixels会展示出越界的效果</span></span><br><span class="line">  <span class="comment">// 否则返回不能消耗的delta，会发出overscroll通知</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> overscroll = physics.applyBoundaryConditions(<span class="keyword">this</span>, newPixels);</span><br><span class="line">  <span class="comment">// 如果physics允许越界返回overscroll是0，则这里actualNewPixels最终是越界的pixels</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> actualNewPixels = newPixels - overscroll;</span><br><span class="line">  <span class="keyword">if</span> (actualNewPixels != oldPixels) &#123;</span><br><span class="line">    forcePixels(actualNewPixels);<span class="comment">// 更新当前ScrollPosition的pixels值</span></span><br><span class="line">    didUpdateScrollPositionBy(actualNewPixels - oldPixels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (overscroll != <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 发出overscroll的OverscrollNotification通知，然后会有地方处理overscroll</span></span><br><span class="line">    <span class="comment">// 比如Android会触发在ScrollableState.build方法中的_configuration.buildOverscrollIndicator</span></span><br><span class="line">    <span class="comment">// 对应的ScrollBehavior.buildViewportChrome创建蓝色波纹效果</span></span><br><span class="line">    didOverscrollBy(overscroll);</span><br><span class="line">    <span class="keyword">return</span> overscroll;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyClampedPointerSignalUpdate"><a href="#applyClampedPointerSignalUpdate" class="headerlink" title="applyClampedPointerSignalUpdate"></a>applyClampedPointerSignalUpdate</h3><p>applyClampedPointerSignalUpdate方法返回未使用的delta，不考虑ScrollPhysics的影响。</p>
<br>

<p>此外还持有了_NestedScrollCoordinator，在animateTo&#x2F;jumpTo&#x2F;pointerScroll&#x2F;applyNewDimensions&#x2F;hold&#x2F;drag等与滑动相关的方法被调用时执行_NestedScrollCoordinator中对应的方法，这样就将outer viewport和inner scrolling view的滑动事件都归集到_NestedScrollCoordinator统一处理。</p>
<h2 id="NestedScrollCoordinator"><a href="#NestedScrollCoordinator" class="headerlink" title="_NestedScrollCoordinator"></a>_NestedScrollCoordinator</h2><p>为了与_NestedScrollPosition保持一致，方便接收其转发的事件，_NestedScrollCoordinator也实现了ScrollActivityDelegate接口：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NestedScrollCoordinator</span> <span class="keyword">implements</span> <span class="title">ScrollActivityDelegate</span>, <span class="title">ScrollHoldController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> NestedScrollViewState _state;<span class="comment">// 用于获取NestedScrollView的ScrollController</span></span><br><span class="line">  ScrollController? _parent;<span class="comment">// 用户传入的NestedScrollView的ScrollController</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> _floatHeaderSlivers;<span class="comment">// header是否悬浮，是的话向“下”滑动时会先将header滑动出来</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分别应用于outer（即_NestedScrollViewCustomScrollView）和inner（即body中的</span></span><br><span class="line">  <span class="comment">// scrolling view）的ScrollController</span></span><br><span class="line">  <span class="keyword">late</span> _NestedScrollController _outerController;</span><br><span class="line">  <span class="keyword">late</span> _NestedScrollController _innerController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beginActivity"><a href="#beginActivity" class="headerlink" title="beginActivity"></a>beginActivity</h3><p>beginActivity用来对outer和inner应用ScrollActivity，在goIdle&#x2F;goBallistic&#x2F;animateTo&#x2F;jumpTo&#x2F;pointerScroll&#x2F;drag&#x2F;hold等与滑动有关的方法中都有直接或间接的调用。</p>
<p>其中outer activity是直接指定的，而inner activity则是根据innerActivityGetter和inner position动态计算。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> beginActivity(ScrollActivity newOuterActivity, _NestedScrollActivityGetter innerActivityGetter) &#123;</span><br><span class="line">  _outerPosition!.beginActivity(newOuterActivity);<span class="comment">// outer直接应用ScrollActivity</span></span><br><span class="line">  <span class="built_in">bool</span> scrolling = newOuterActivity.isScrolling;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions) &#123;</span><br><span class="line">    <span class="comment">// 依次遍历inner scrolling view计算对应的newInnerActivity</span></span><br><span class="line">    <span class="keyword">final</span> ScrollActivity newInnerActivity = innerActivityGetter(position);</span><br><span class="line">    position.beginActivity(newInnerActivity);</span><br><span class="line">    scrolling = scrolling &amp;&amp; newInnerActivity.isScrolling;</span><br><span class="line">  &#125;</span><br><span class="line">  _currentDrag?.dispose();</span><br><span class="line">  _currentDrag = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!scrolling)</span><br><span class="line">    <span class="comment">// 如果都没有滑动，就表示当前NestedScrollView停止</span></span><br><span class="line">    updateUserScrollDirection(ScrollDirection.idle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的一种使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> goBallistic(<span class="built_in">double</span> velocity) &#123;</span><br><span class="line">  beginActivity(</span><br><span class="line">    createOuterBallisticScrollActivity(velocity),<span class="comment">// 创建outer activity</span></span><br><span class="line">    (_NestedScrollPosition position) &#123;<span class="comment">// 根据position创建inner activity</span></span><br><span class="line">      <span class="keyword">return</span> createInnerBallisticScrollActivity(</span><br><span class="line">        position,</span><br><span class="line">        velocity,</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建outer scroll activity的方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ScrollActivity createOuterBallisticScrollActivity(<span class="built_in">double</span> velocity) &#123;</span><br><span class="line">  <span class="comment">// This function creates a ballistic scroll for the outer scrollable.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// It assumes that the outer scrollable can&#x27;t be overscrolled, and sets up a</span></span><br><span class="line">  <span class="comment">// ballistic scroll over the combined space of the innerPositions and the</span></span><br><span class="line">  <span class="comment">// outerPosition.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// First we must pick a representative inner position that we will care</span></span><br><span class="line">  <span class="comment">// about. This is somewhat arbitrary. Ideally we&#x27;d pick the one that is &quot;in</span></span><br><span class="line">  <span class="comment">// the center&quot; but there isn&#x27;t currently a good way to do that so we</span></span><br><span class="line">  <span class="comment">// arbitrarily pick the one that is the furthest away from the infinity we</span></span><br><span class="line">  <span class="comment">// are heading towards.</span></span><br><span class="line">  _NestedScrollPosition? innerPosition;</span><br><span class="line">  <span class="keyword">if</span> (velocity != <span class="number">0.0</span>) &#123;<span class="comment">// 选择在正方向上离我们最远的inner position</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (innerPosition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (velocity &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (innerPosition.pixels &lt; position.pixels)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">assert</span>(velocity &lt; <span class="number">0.0</span>);</span><br><span class="line">          <span class="keyword">if</span> (innerPosition.pixels &gt; position.pixels)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      innerPosition = position;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (innerPosition == <span class="keyword">null</span>) &#123;<span class="comment">// 这里表示只有outer或者velocity为0</span></span><br><span class="line">    <span class="comment">// It&#x27;s either just us or a velocity=0 situation.</span></span><br><span class="line">    <span class="keyword">return</span> _outerPosition!.createBallisticScrollActivity(</span><br><span class="line">      _outerPosition!.physics.createBallisticSimulation(</span><br><span class="line">        _outerPosition!,</span><br><span class="line">        velocity,</span><br><span class="line">      ),</span><br><span class="line">      mode: _NestedBallisticScrollActivityMode.independent,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里表示NestedScrollView中存在inner和outer scrolling view，且velocity不为0</span></span><br><span class="line">  <span class="comment">// 在innerPosition和outerPosition组合的space之上设置overscroll</span></span><br><span class="line">  <span class="keyword">final</span> _NestedScrollMetrics metrics = _getMetrics(innerPosition, velocity);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _outerPosition!.createBallisticScrollActivity(</span><br><span class="line">    _outerPosition!.physics.createBallisticSimulation(metrics, velocity),</span><br><span class="line">    mode: _NestedBallisticScrollActivityMode.outer,</span><br><span class="line">    metrics: metrics,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见在计算outer scroll activity的时候，需判断body内是不是有inner scrolling view：</p>
<ul>
<li>没有，按照正常创建BallisticScrollActivity的流程创建</li>
<li>有，将inner的space也计入，然后以此计算BallisticScrollActivity</li>
</ul>
<p>创建inner scroll activity的方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScrollActivity createInnerBallisticScrollActivity(_NestedScrollPosition position, <span class="built_in">double</span> velocity) &#123;</span><br><span class="line">  <span class="keyword">return</span> position.createBallisticScrollActivity(</span><br><span class="line">    position.physics.createBallisticSimulation(</span><br><span class="line">      _getMetrics(position, velocity),</span><br><span class="line">      velocity,</span><br><span class="line">    ),</span><br><span class="line">    mode: _NestedBallisticScrollActivityMode.inner,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyUserOffset"><a href="#applyUserOffset" class="headerlink" title="applyUserOffset"></a>applyUserOffset</h3><p>applyUserOffset是_NestedScrollCoordinator的重点，也是NestedScrollView能够实现协调inner和outer滑动事件的主要逻辑。</p>
<p>在看applyUserOffset方法之前，先看一下drag()方法，在此方法中创建ScrollDragController时delegate传入的是_NestedScrollCoordinator。</p>
<p>当用户操作屏幕发生drag事件时，手势事件会被ScrollableState中的RawGestureDetector识别到：</p>
<ul>
<li>drag开始时调用<code>_handleDragStart</code>，通过_NestedScrollPosition转发调用<code>_NestedScrollCoordinator.drag</code>方法创建了<code>ScrollDragController drag</code></li>
<li>drag开始时更新时<code>_handleDragUpdate</code>，内部调用<code>ScrollDragController.update</code>,在update方法内部执行了<code>delegate.applyUserOffset</code>，此处的<code>delegate</code>就是我们之前传入的_NestedScrollCoordinator</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法在ScrollableState中被RawGestureDetector通过</span></span><br><span class="line"><span class="comment">// ScrollableState._handleDragStart -&gt; _NestedScrollPosition.drag </span></span><br><span class="line"><span class="comment">// -&gt; _NestedScrollCoordinator.drag链路调用</span></span><br><span class="line">Drag drag(DragStartDetails details, VoidCallback dragCancelCallback) &#123;</span><br><span class="line">  <span class="keyword">final</span> ScrollDragController drag = ScrollDragController(</span><br><span class="line">    delegate: <span class="keyword">this</span>,</span><br><span class="line">    details: details,</span><br><span class="line">    onDragCanceled: dragCancelCallback,</span><br><span class="line">  );</span><br><span class="line">  beginActivity(</span><br><span class="line">    DragScrollActivity(_outerPosition!, drag),</span><br><span class="line">    (_NestedScrollPosition position) =&gt; DragScrollActivity(position, drag),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assert</span>(_currentDrag == <span class="keyword">null</span>);</span><br><span class="line">  _currentDrag = drag;</span><br><span class="line">  <span class="keyword">return</span> drag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述分析，在用户滑动屏幕时，会执行<code>_NestedScrollCoordinator.applyUserOffset</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> applyUserOffset(<span class="built_in">double</span> delta) &#123;</span><br><span class="line">  <span class="comment">// 更新scroll方向</span></span><br><span class="line">  updateUserScrollDirection(</span><br><span class="line">    delta &gt; <span class="number">0.0</span> ? ScrollDirection.forward : ScrollDirection.reverse,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assert</span>(delta != <span class="number">0.0</span>);</span><br><span class="line">  <span class="keyword">if</span> (_innerPositions.isEmpty) &#123;</span><br><span class="line">    <span class="comment">// 如果没有inner（body内部没有scrolling view），就由outer完全处理滑动事件</span></span><br><span class="line">    _outerPosition!.applyFullDragUpdate(delta);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delta &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// Dragging &quot;up&quot;</span></span><br><span class="line">    <span class="comment">// 先恢复inner overscroll，然后是outer view，以便header内容尽快scroll out</span></span><br><span class="line">    <span class="built_in">double</span> outerDelta = delta;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (position.pixels &lt; <span class="number">0.0</span>) &#123; <span class="comment">// This inner position is in overscroll.</span></span><br><span class="line">        <span class="comment">// 先从overscrolled恢复并返回剩余没有使用的delta</span></span><br><span class="line">        <span class="comment">// 因为delta是负值，如果“消耗”掉了一部分，那么potentialOuterDelta会比delta大</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">double</span> potentialOuterDelta = position.applyClampedDragUpdate(delta);</span><br><span class="line">        <span class="comment">// In case there are multiple positions in varying states of</span></span><br><span class="line">        <span class="comment">// overscroll, the first to &#x27;reach&#x27; the outer view above takes</span></span><br><span class="line">        <span class="comment">// precedence.此处outerDelta为剩余没有消耗的delta</span></span><br><span class="line">        outerDelta = math.max(outerDelta, potentialOuterDelta);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outerDelta != <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果还有剩下的，让outer view消耗</span></span><br><span class="line">      <span class="comment">// delta &lt; 0;所以如果outer有underscroll则会先恢复到0然后返回（现有限制下不会出现</span></span><br><span class="line">      <span class="comment">// 此情况），否则最多可以向上滑动到maxScrollExtent</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">double</span> innerDelta = _outerPosition!.applyClampedDragUpdate(</span><br><span class="line">        outerDelta,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (innerDelta != <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="comment">// 还有剩下的，让inner开始滑动</span></span><br><span class="line">        <span class="comment">// 这里吧剩下的innerDelta完全给了inner scroll position的applyFullDragUpdate方法</span></span><br><span class="line">        <span class="comment">// inner会先向上滑动，如果physics支持underscroll会执行underscroll，否则最多滑动</span></span><br><span class="line">        <span class="comment">// 到maxScrollExtent，然后发出overscroll的通知，让Scrollable绘制蓝色波纹（Android）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> _innerPositions)</span><br><span class="line">          position.applyFullDragUpdate(innerDelta);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Dragging &quot;down&quot; - delta is positive</span></span><br><span class="line">    <span class="built_in">double</span> innerDelta = delta;</span><br><span class="line">    <span class="comment">// Apply delta to the outer header first if it is configured to float.</span></span><br><span class="line">    <span class="keyword">if</span> (_floatHeaderSlivers)</span><br><span class="line">    <span class="comment">// _floatHeaderSlivers为true，先让outer复现出来，最多向下滑动到minScrollExtent</span></span><br><span class="line">      <span class="comment">// 也就是恢复原位</span></span><br><span class="line">      innerDelta = _outerPosition!.applyClampedDragUpdate(delta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (innerDelta != <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="comment">// Apply the innerDelta, if we have not floated in the outer scrollable,</span></span><br><span class="line">      <span class="comment">// any leftover delta after this will be passed on to the outer</span></span><br><span class="line">      <span class="comment">// scrollable by the outerDelta.</span></span><br><span class="line">      <span class="built_in">double</span> outerDelta = <span class="number">0.0</span>; <span class="comment">// it will go positive if it changes</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; overscrolls = &lt;<span class="built_in">double</span>&gt;[];</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;_NestedScrollPosition&gt; innerPositions = _innerPositions.toList();</span><br><span class="line">      <span class="comment">// inner scrolling view先消耗delta</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> _NestedScrollPosition position <span class="keyword">in</span> innerPositions) &#123;</span><br><span class="line">        <span class="comment">// 向下滑动inner scrolling view</span></span><br><span class="line">        <span class="comment">// 如果inner physics不支持overscroll，则执行完innerDelta之后，最多会返回未执行的overscroll</span></span><br><span class="line">        <span class="comment">// 如果支持，则会消耗完innerDelta，这里的overscroll为0</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">double</span> overscroll = position.applyClampedDragUpdate(innerDelta);</span><br><span class="line">        outerDelta = math.max(outerDelta, overscroll);</span><br><span class="line">        overscrolls.add(overscroll);<span class="comment">// 保存没有被使用的overscroll</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (outerDelta != <span class="number">0.0</span>)</span><br><span class="line">        <span class="comment">// 在此处，即使设置了outer的physics为BouncingScrollPhysics，因为当ScrollPosition的</span></span><br><span class="line">        <span class="comment">// offset为0时，applyClampedDragUpdate不会主动从0变为负值，所以无法应用underscroll效果</span></span><br><span class="line">        <span class="comment">// 此处outerDelta-=overscroll的结果是outerDelta是outer消耗的那一部分内容</span></span><br><span class="line">        outerDelta -= _outerPosition!.applyClampedDragUpdate(outerDelta);</span><br><span class="line">        <span class="comment">// 这里outerDelta是剩下的delta</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now deal with any overscroll 最后交给inner处理overscroll</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; innerPositions.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// 此处的remainingDelta是未执行的overscroll减去了outer消耗的内容</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">double</span> remainingDelta = overscrolls[i] - outerDelta;</span><br><span class="line">        <span class="keyword">if</span> (remainingDelta &gt; <span class="number">0.0</span>)</span><br><span class="line">          <span class="comment">// 如果还有剩下的overscroll，与physics等结合计算之后，继续消耗（之前在</span></span><br><span class="line">          <span class="comment">// applyClampedDragUpdate无法消耗，在这里也消耗不了，不过可以发送overscroll</span></span><br><span class="line">          <span class="comment">// 的通知，让Scrollable知道之后做出蓝色波纹（Android机型）等效果）</span></span><br><span class="line">          innerPositions[i].applyFullDragUpdate(remainingDelta);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析为何inner有scrolling view时，NestedScrollView.physics为BouncingScrollPhysics()不生效：</p>
<p>从上述代码我们看到，可以产生overscroll效果的applyFullDragUpdate只有在inner中没有scrolling view的时候才会被_outerPosition应用，其他两个场景都只有inner position应用。</p>
<p>而其余场景中，_outerPosition和inner position都应用的是applyClampedDragUpdate方法：</p>
<ul>
<li>向下滑动 delta大于0，代码会执行到<code>outerDelta -= _outerPosition!.applyClampedDragUpdate(outerDelta)</code>，因为此时限制了applyClampedDragUpdate中的newPixels范围为（当ScrollPosition的pixels等于0时）minScrollExtent~double.infinity，所以clampedDelta &#x3D; newPixels - pixels等于minScrollExtent（也就是0），跳过剩余步骤直接返回了delta。所以没有执行BouncingScrollPhysics()逻辑</li>
<li>向上滑动 delta小于0，代码会执行<code>final double innerDelta = _outerPosition!.applyClampedDragUpdate(outerDelta,);</code>，在此方法中，如果有overscroll则会先恢复到0，否则最多上划到maxScrollExtent，所以也不会执行BouncingScrollPhysics()逻辑</li>
</ul>
<br>

<p>通过上述步骤，NestedScrollView将header和body的滚动事件进行组合、分发。</p>
<h1 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h1><p>NestedScrollView将header和body中可滑动view（inner）的滑动事件组合起来：向上滑动时，先等达到header最大滑动范围之后，再将滑动分配给inner消耗；当向下滑动时，一般先恢复inner的overscroll（如果_floatHeaderSlivers为true，会先尝试下滑header），尝试将其恢复至offset为0的状态，再尝试将header向下滑动到初始位置，最后如果有overscroll，会尝试应用到inner上面。</p>
<p>CustomScrollView也支持在同一个页面内嵌套多个滑动列表并关联（在其slivers中传入多个SliverList,SliverGrid等），但是CustomScrollView不支持普通的滑动view，比如ListView等，这些滑动布局会内部消耗掉滑动事件，从而无法与CustomScrollView内其余sliver正常联动。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>NestedScrollView内部通过NestedScrollViewState.build()创建继承自CustomScrollView的_NestedScrollViewCustomScrollView。</p>
<p>通过NestedScrollView._buildSlivers()将NestedScrollView.headerSliverBuilder返回的sliver列表（下称header）和被SliverFillRemaining包裹的body组合在一起，使得在_NestedScrollViewCustomScrollView中创建的viewport的创建的_NestedScrollCoordinator.outerPosition的_maxScrollExtent为NestedScrollView的header的主轴尺寸，而_NestedScrollCoordinator._innerPositions的_maxScrollExtent则是与body实际内容一致。</p>
<p>_NestedScrollViewCustomScrollView的ScrollController是_NestedScrollCoordinator._outerController，其创建了_NestedScrollCoordinator.outerPosition，所以整个NestedScrollView的滑动事件都会通过_NestedScrollCoordinator._outerController转到给_NestedScrollCoordinator.applyUserOffset方法。</p>
<p>在_NestedScrollCoordinator.applyUserOffset方法中，根据滑动方向的不同，依次协调_NestedScrollCoordinator.outerPosition和_NestedScrollCoordinator._innerPositions处理用户drag等产生的delta，修改这两个ScrollPosition的值，从而实现header和body的滑动联动。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://api.flutter.dev/flutter/widgets/NestedScrollView-class.html">NestedScrollView_api.flutter.dev</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>JI, XIAOYONG
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jixiaoyong.github.io/blog/posts/ae8e53be/" title="Flutter滑动分析之NestedScrollView">https://jixiaoyong.github.io/blog/posts/ae8e53be/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/flutter/" rel="tag"># flutter</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/posts/60f8d92f/" rel="prev" title="Flutter滑动分析之Scrollview">
                  <i class="fa fa-chevron-left"></i> Flutter滑动分析之Scrollview
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JI, XIAOYONG</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>





  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://vercel.xiaoyong.ml","cssUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css","commentCount":true,"pageview":true,"libUrl":"https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.js","locale":{"placeholder":"ヾ(=^▽^=)ノ"},"meta":["nick","mail","link"],"login":"enable","pageSize":10,"el":"#waline","comment":true,"path":"/blog/posts/ae8e53be/"}</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/2.5.1/waline.min.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
