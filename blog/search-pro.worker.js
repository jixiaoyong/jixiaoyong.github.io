const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":470,\"nextId\":470,\"documentIds\":{\"0\":\"v-22a39d25\",\"1\":\"v-0d1a32a8\",\"2\":\"v-076645fa\",\"3\":\"v-55034978\",\"4\":\"v-55034978#闹钟类型\",\"5\":\"v-55034978#触发时间\",\"6\":\"v-55034978#间隔时间\",\"7\":\"v-55034978#待定的intent\",\"8\":\"v-55034978#取消闹钟\",\"9\":\"v-55034978#在重启时恢复闹钟\",\"10\":\"v-55034978#设置一个每天指定时间循环的闹钟\",\"11\":\"v-55034978#监听每日循环的闹钟\",\"12\":\"v-55034978#条件满足后关闭当日循环闹钟\",\"13\":\"v-08e0756d\",\"14\":\"v-15c8d844\",\"15\":\"v-db18a49e\",\"16\":\"v-4d514ca0\",\"17\":\"v-4d514ca0#启动一个service\",\"18\":\"v-4d514ca0#service绑定服务的三种方式\",\"19\":\"v-4d514ca0#_1-拓展binder类\",\"20\":\"v-4d514ca0#_2-messenger\",\"21\":\"v-4d514ca0#_3-aidl\",\"22\":\"v-699f4098\",\"23\":\"v-699f4098#looper\",\"24\":\"v-699f4098#looper-perpare\",\"25\":\"v-699f4098#looper-loop\",\"26\":\"v-699f4098#looper-mylooper\",\"27\":\"v-699f4098#handler\",\"28\":\"v-699f4098#handler-sendmessage\",\"29\":\"v-699f4098#handler-dispatchmessage\",\"30\":\"v-699f4098#handler-post\",\"31\":\"v-699f4098#msg的获取\",\"32\":\"v-93dad108\",\"33\":\"v-93dad108#支持的数据格式\",\"34\":\"v-93dad108#注意事项\",\"35\":\"v-93dad108#aidl\",\"36\":\"v-93dad108#服务端\",\"37\":\"v-93dad108#客户端\",\"38\":\"v-93dad108#监听并处理binder死亡事件\",\"39\":\"v-93dad108#aidl的权限验证\",\"40\":\"v-5c35a44c\",\"41\":\"v-c7702a08\",\"42\":\"v-05d142e6\",\"43\":\"v-6e0e2460\",\"44\":\"v-28241246\",\"45\":\"v-28241246#void-put-int-key-e-value\",\"46\":\"v-28241246#e-get-int-key\",\"47\":\"v-28241246#void-remove-int-key\",\"48\":\"v-28241246#gc\",\"49\":\"v-28241246#hashmap与sparearray及其衍生类对应关系\",\"50\":\"v-28241246#v-put-k-key-v-value\",\"51\":\"v-28241246#v-get-object-key\",\"52\":\"v-28241246#v-remove-object-key\",\"53\":\"v-62708f73\",\"54\":\"v-17b09672\",\"55\":\"v-54807f4e\",\"56\":\"v-aa8d6032\",\"57\":\"v-3bc77afc\",\"58\":\"v-e310c73e\",\"59\":\"v-e310c73e#others\",\"60\":\"v-6d8e9f0f\",\"61\":\"v-997c4592\",\"62\":\"v-997c4592#方法1\",\"63\":\"v-997c4592#方法2\",\"64\":\"v-6829c860\",\"65\":\"v-ed65b9dc\",\"66\":\"v-97a7bf52\",\"67\":\"v-defabfdc\",\"68\":\"v-defabfdc#一般流程\",\"69\":\"v-defabfdc#代码\",\"70\":\"v-190a31c0\",\"71\":\"v-190a31c0#_1-新建activity等\",\"72\":\"v-190a31c0#_2-utils-java实现hook具体逻辑\",\"73\":\"v-148b4ef8\",\"74\":\"v-148b4ef8#layout-weight\",\"75\":\"v-148b4ef8#pendingintent\",\"76\":\"v-148b4ef8#android模拟器访问电脑localhost\",\"77\":\"v-148b4ef8#获取屏幕画面\",\"78\":\"v-148b4ef8#获取网络信息-请求网络\",\"79\":\"v-1c8228bd\",\"80\":\"v-5b8dcbce\",\"81\":\"v-9217970e\",\"82\":\"v-0009fa4f\",\"83\":\"v-0009fa4f#inject\",\"84\":\"v-0009fa4f#component\",\"85\":\"v-0009fa4f#module和-provides\",\"86\":\"v-0009fa4f#named和-qualifier\",\"87\":\"v-0009fa4f#singleton和-scope\",\"88\":\"v-744771ce\",\"89\":\"v-744771ce#application范围内的-component\",\"90\":\"v-744771ce#创建单个activity的-subcomponent\",\"91\":\"v-744771ce#创建单个activity的-module\",\"92\":\"v-744771ce#使application继承自-hasactivityinjector\",\"93\":\"v-744771ce#在activity中使用自动注入依赖\",\"94\":\"v-744771ce#这一切是怎么实现的呢\",\"95\":\"v-e05d7056\",\"96\":\"v-e05d7056#代码分析\",\"97\":\"v-e05d7056#rootzone-scheduleasynccallback\",\"98\":\"v-e05d7056#rootzone-startmicrotaskloop\",\"99\":\"v-e05d7056#asyncrun-scheduleimmediate\",\"100\":\"v-e05d7056#scheduleimmediateclosure\",\"101\":\"v-e05d7056#pendingimmediatecallback\",\"102\":\"v-e05d7056#代码分析-1\",\"103\":\"v-e05d7056#future-then\",\"104\":\"v-e05d7056#timer\",\"105\":\"v-e05d7056#创建timer\",\"106\":\"v-e05d7056#timer-enqueue\",\"107\":\"v-e05d7056#milliseconds-0\",\"108\":\"v-e05d7056#milliseconds-0-1\",\"109\":\"v-e05d7056#handlemessage\",\"110\":\"v-004da386\",\"111\":\"v-004da386#dart端发起文件读写请求\",\"112\":\"v-004da386#io-service中转\",\"113\":\"v-004da386#native处理dart的指令\",\"114\":\"v-004da386#ioservice-newserviceport\",\"115\":\"v-004da386#dart-newnativeport\",\"116\":\"v-004da386#dart-newsendport\",\"117\":\"v-4201cf3a\",\"118\":\"v-4201cf3a#widgetsflutterbinding-ensureinitialized\",\"119\":\"v-4201cf3a#scheduleattachrootwidget-app\",\"120\":\"v-4201cf3a#renderobjecttowidgetadapter\",\"121\":\"v-4201cf3a#attachtorendertree\",\"122\":\"v-4201cf3a#schedulewarmupframe\",\"123\":\"v-4201cf3a#alignment-alignment-center\",\"124\":\"v-4201cf3a#renderobject-renderpositionedbox\",\"125\":\"v-4201cf3a#widget-center\",\"126\":\"v-4201cf3a#child-statelesselement\",\"127\":\"v-4201cf3a#richtext\",\"128\":\"v-6dd099cd\",\"129\":\"v-6dd099cd#inheritedwidget的获取方式\",\"130\":\"v-6dd099cd#代码示例\",\"131\":\"v-415ca167\",\"132\":\"v-38366e9b\",\"133\":\"v-38366e9b#statelesswidget\",\"134\":\"v-38366e9b#statefulwidget\",\"135\":\"v-38366e9b#intent\",\"136\":\"v-38366e9b#线程\",\"137\":\"v-38366e9b#本地资源\",\"138\":\"v-38366e9b#生命周期\",\"139\":\"v-38366e9b#布局\",\"140\":\"v-38366e9b#点击事件\",\"141\":\"v-c52e25d6\",\"142\":\"v-c52e25d6#try-catch\",\"143\":\"v-c52e25d6#errorwidget-builder\",\"144\":\"v-c52e25d6#fluttererror-onerror\",\"145\":\"v-c52e25d6#runzonedguarded-onerror\",\"146\":\"v-8922c842\",\"147\":\"v-8922c842#implicitlyanimatedwidget\",\"148\":\"v-8922c842#initstate\",\"149\":\"v-8922c842#constructtweens\",\"150\":\"v-8922c842#didupdatewidget\",\"151\":\"v-8922c842#foreachtween\",\"152\":\"v-8922c842#didupdatetweens\",\"153\":\"v-8922c842#tweenanimationbuilder\",\"154\":\"v-8922c842#animatedwidget\",\"155\":\"v-8922c842#animatedstate\",\"156\":\"v-8922c842#animatedbuilder\",\"157\":\"v-7f43ef61\",\"158\":\"v-7f43ef61#animation\",\"159\":\"v-7f43ef61#其他子类\",\"160\":\"v-7f43ef61#animationcontroller\",\"161\":\"v-7f43ef61#构造方法\",\"162\":\"v-7f43ef61#startsimulation\",\"163\":\"v-7f43ef61#tick\",\"164\":\"v-7f43ef61#其他方法\",\"165\":\"v-7f43ef61#simulation\",\"166\":\"v-7f43ef61#interpolationsimulation\",\"167\":\"v-7f43ef61#repeatingsimulation\",\"168\":\"v-7f43ef61#springsimulation\",\"169\":\"v-2f20ab09\",\"170\":\"v-2f20ab09#简单使用-standard-hero-animations\",\"171\":\"v-2f20ab09#原理分析\",\"172\":\"v-2f20ab09#进阶使用-radial-hero-animations\",\"173\":\"v-2f20ab09#原理分析-1\",\"174\":\"v-2f20ab09#其他属性\",\"175\":\"v-2f20ab09#hero\",\"176\":\"v-2f20ab09#herostate\",\"177\":\"v-2f20ab09#heroflightmanifest\",\"178\":\"v-2f20ab09#herocontroller\",\"179\":\"v-2f20ab09#maybestartherotransition\",\"180\":\"v-2f20ab09#startherotransition\",\"181\":\"v-2f20ab09#heroflight\",\"182\":\"v-41dea5de\",\"183\":\"v-41dea5de#animatable\",\"184\":\"v-41dea5de#tween\",\"185\":\"v-41dea5de#curvetween\",\"186\":\"v-41dea5de#curve\",\"187\":\"v-62867451\",\"188\":\"v-62867451#image\",\"189\":\"v-62867451#imagestate\",\"190\":\"v-62867451#resolveimage\",\"191\":\"v-62867451#updatesourcestream\",\"192\":\"v-62867451#handleimageframe\",\"193\":\"v-62867451#build\",\"194\":\"v-62867451#rawimage\",\"195\":\"v-62867451#renderimage\",\"196\":\"v-62867451#imageprovider\",\"197\":\"v-62867451#imagecache\",\"198\":\"v-62867451#putifabsent\",\"199\":\"v-018189cc\",\"200\":\"v-018189cc#extendedimage\",\"201\":\"v-018189cc#extendednetworkimageprovider\",\"202\":\"v-018189cc#extendedimageprovider\",\"203\":\"v-d4e1dc4a\",\"204\":\"v-d4e1dc4a#powerimage\",\"205\":\"v-d4e1dc4a#powerimagestate\",\"206\":\"v-d4e1dc4a#powertextureimage\",\"207\":\"v-d4e1dc4a#powerexternalimage\",\"208\":\"v-d4e1dc4a#powerimageprovider\",\"209\":\"v-d4e1dc4a#loadasync\",\"210\":\"v-d4e1dc4a#powertextureimageprovider\",\"211\":\"v-d4e1dc4a#powerexternalimageprovider\",\"212\":\"v-4819e612\",\"213\":\"v-4819e612#nestedscrollviewstate\",\"214\":\"v-4819e612#nestedscrollcontroller\",\"215\":\"v-4819e612#创建-nestedscrollposition\",\"216\":\"v-4819e612#在-scrollposition-变化时通知-coordinator\",\"217\":\"v-4819e612#nestedscrollposition\",\"218\":\"v-4819e612#setparent\",\"219\":\"v-4819e612#absorb\",\"220\":\"v-4819e612#applyclampeddragupdate\",\"221\":\"v-4819e612#applyfulldragupdate\",\"222\":\"v-4819e612#applyclampedpointersignalupdate\",\"223\":\"v-4819e612#applynewdimensions\",\"224\":\"v-4819e612#nestedscrollcoordinator\",\"225\":\"v-4819e612#beginactivity\",\"226\":\"v-4819e612#applyuseroffset\",\"227\":\"v-2ee0f8cf\",\"228\":\"v-2ee0f8cf#widget-buildviewport\",\"229\":\"v-2ee0f8cf#renderviewportbase\",\"230\":\"v-2ee0f8cf#校验-children-类型是否为-rendersliver\",\"231\":\"v-2ee0f8cf#renderviewport\",\"232\":\"v-2ee0f8cf#rendershrinkwrappingviewport\",\"233\":\"v-2ee0f8cf#list-widget-buildslivers\",\"234\":\"v-21050536\",\"235\":\"v-21050536#singlechildscrollview\",\"236\":\"v-21050536#singlechildviewport\",\"237\":\"v-21050536#rendersinglechildviewport\",\"238\":\"v-21050536#layout\",\"239\":\"v-21050536#paint\",\"240\":\"v-21050536#hittest\",\"241\":\"v-21050536#为column的children安全应用spacedaround-center等效果\",\"242\":\"v-21050536#为column的children安全应用expanded、space等效果\",\"243\":\"v-2f1e223e\",\"244\":\"v-2f1e223e#quick-start\",\"245\":\"v-2f1e223e#create-a-new-post\",\"246\":\"v-2f1e223e#run-server\",\"247\":\"v-2f1e223e#generate-static-files\",\"248\":\"v-2f1e223e#deploy-to-remote-sites\",\"249\":\"v-374c7c33\",\"250\":\"v-374c7c33#_1-head\",\"251\":\"v-374c7c33#_2-stack\",\"252\":\"v-374c7c33#java-virtual-machine-stack\",\"253\":\"v-374c7c33#native-method-stack\",\"254\":\"v-374c7c33#_3-method-area\",\"255\":\"v-374c7c33#_4-program-count\",\"256\":\"v-374c7c33#_1-java堆溢出\",\"257\":\"v-374c7c33#_2-虚拟机栈和本地方法栈溢出\",\"258\":\"v-374c7c33#_3-运行时常量池溢出\",\"259\":\"v-374c7c33#_4-方法区溢出\",\"260\":\"v-374c7c33#_5-本地直接内存溢出\",\"261\":\"v-374c7c33#回收算法\",\"262\":\"v-374c7c33#_1-复制算法\",\"263\":\"v-374c7c33#_2-标记清除法\",\"264\":\"v-374c7c33#_3-标记压缩法\",\"265\":\"v-374c7c33#_4-引用计数算法\",\"266\":\"v-374c7c33#回收过程\",\"267\":\"v-374c7c33#对象引用\",\"268\":\"v-374c7c33#强引用strongreference\",\"269\":\"v-374c7c33#软引用softreference\",\"270\":\"v-374c7c33#弱引用weakreference\",\"271\":\"v-374c7c33#虚引用phantomreference\",\"272\":\"v-35a24ba4\",\"273\":\"v-33ad4072\",\"274\":\"v-33ad4072#i-loading\",\"275\":\"v-33ad4072#ii-linking\",\"276\":\"v-33ad4072#verification\",\"277\":\"v-33ad4072#preparation\",\"278\":\"v-33ad4072#resolution\",\"279\":\"v-33ad4072#iii-initialization\",\"280\":\"v-33acf090\",\"281\":\"v-04faf74b\",\"282\":\"v-28b7ad47\",\"283\":\"v-28b7ad47#string最长为65534\",\"284\":\"v-28b7ad47#枚举类enum\",\"285\":\"v-28b7ad47#枚举类大小的计算\",\"286\":\"v-28b7ad47#android中是否应该使用枚举\",\"287\":\"v-28b7ad47#sparsearray-arraymap-vs-hashmap\",\"288\":\"v-01b9970a\",\"289\":\"v-2d248a9b\",\"290\":\"v-e9b5c75a\",\"291\":\"v-e9b5c75a#不能有泛型数组\",\"292\":\"v-e9b5c75a#协变\",\"293\":\"v-e9b5c75a#逆变\",\"294\":\"v-379dd82c\",\"295\":\"v-4085b7a8\",\"296\":\"v-2ea04aec\",\"297\":\"v-a2c472b8\",\"298\":\"v-29aa1258\",\"299\":\"v-29aa1258#注解类\",\"300\":\"v-29aa1258#注解帮助类\",\"301\":\"v-29aa1258#使用注解\",\"302\":\"v-807e8bb2\",\"303\":\"v-49ff4288\",\"304\":\"v-49ff4288#serialversionuid\",\"305\":\"v-49ff4288#readresolve\",\"306\":\"v-49ff4288#自定义序列化过程\",\"307\":\"v-49ff4288#父类未继承serializable的类的序列化\",\"308\":\"v-49ff4288#实现\",\"309\":\"v-49ff4288#多次序列化同一个对象\",\"310\":\"v-49ff4288#优缺点\",\"311\":\"v-49ff4288#实现-1\",\"312\":\"v-49ff4288#原理\",\"313\":\"v-49ff4288#优缺点-1\",\"314\":\"v-49ff4288#实现-2\",\"315\":\"v-49ff4288#原理-1\",\"316\":\"v-49ff4288#优缺点-2\",\"317\":\"v-acbc2d2a\",\"318\":\"v-acbc2d2a#互斥同步-阻塞同步\",\"319\":\"v-acbc2d2a#非阻塞同步\",\"320\":\"v-acbc2d2a#无同步方案\",\"321\":\"v-4dccca98\",\"322\":\"v-301bc5b1\",\"323\":\"v-301bc5b1#协程中runblocking与coroutinescope的区别\",\"324\":\"v-301bc5b1#协程的思维导图\",\"325\":\"v-301bc5b1#协程局部变量\",\"326\":\"v-301bc5b1#在android中使用\",\"327\":\"v-70d9837c\",\"328\":\"v-70d9837c#声明式捕获-将collect的主要逻辑放到oneach中-保证oneach在catch之前\",\"329\":\"v-70d9837c#异常的传播\",\"330\":\"v-70d9837c#监督\",\"331\":\"v-70d9837c#监督作业\",\"332\":\"v-70d9837c#监督作用域\",\"333\":\"v-70d9837c#监督协程中的异常\",\"334\":\"v-70d9837c#协程的线程安全\",\"335\":\"v-8846514c\",\"336\":\"v-8846514c#创建flow\",\"337\":\"v-8846514c#流的收集-末端流操作符\",\"338\":\"v-8846514c#过渡流操作符\",\"339\":\"v-8846514c#流上下文\",\"340\":\"v-8846514c#展平流\",\"341\":\"v-8846514c#异常处理\",\"342\":\"v-8846514c#流取消\",\"343\":\"v-8846514c#流完成\",\"344\":\"v-8846514c#其余操作\",\"345\":\"v-6b58c4e7\",\"346\":\"v-0041f05e\",\"347\":\"v-1381a5b2\",\"348\":\"v-2e6f3250\",\"349\":\"v-254d294c\",\"350\":\"v-254d294c#ls\",\"351\":\"v-254d294c#chmod\",\"352\":\"v-254d294c#文件权限与umask\",\"353\":\"v-254d294c#查看、管理当前用户信息\",\"354\":\"v-254d294c#改密码\",\"355\":\"v-254d294c#文件打包、压缩和解压缩\",\"356\":\"v-254d294c#gzip\",\"357\":\"v-254d294c#tar\",\"358\":\"v-254d294c#自定义变量\",\"359\":\"v-254d294c#别名配置\",\"360\":\"v-254d294c#环境变量\",\"361\":\"v-254d294c#shell-startup-scripts\",\"362\":\"v-332b6346\",\"363\":\"v-332b6346#okhttpclient相关\",\"364\":\"v-332b6346#网络请求相关信息\",\"365\":\"v-332b6346#执行网络请求\",\"366\":\"v-354e8e1a\",\"367\":\"v-354e8e1a#使用时需要根据自己的项目更新main-py的一下变量\",\"368\":\"v-354e8e1a#运行main-py文件\",\"369\":\"v-8f24cc26\",\"370\":\"v-71643da6\",\"371\":\"v-64009630\",\"372\":\"v-4065541e\",\"373\":\"v-4065541e#创建新isolate的方式\",\"374\":\"v-4065541e#使用方法\",\"375\":\"v-4065541e#pause\",\"376\":\"v-4065541e#ping\",\"377\":\"v-4065541e#获取当前isolate\",\"378\":\"v-4065541e#创建isolate\",\"379\":\"v-4065541e#isolate-spawnfunction\",\"380\":\"v-4065541e#spawnisolatetask\",\"381\":\"v-4065541e#runlightweight\",\"382\":\"v-4065541e#isolate-initializecallback\",\"383\":\"v-4065541e#createwithinexistingisolategroup\",\"384\":\"v-4065541e#isolate-spawnuri\",\"385\":\"v-4065541e#spawnisolatetask-1\",\"386\":\"v-4065541e#runheavyweight\",\"387\":\"v-4065541e#isolate-creategroupcallback\",\"388\":\"v-4065541e#dart-createisolategroup\",\"389\":\"v-4065541e#run-isolate-child\",\"390\":\"v-4065541e#scheduletasklocked\",\"391\":\"v-4065541e#worker-main\",\"392\":\"v-0556e594\",\"393\":\"v-0556e594#从dart-source加载到vm中\",\"394\":\"v-0556e594#在vm中执行\",\"395\":\"v-0556e594#unoptimized-code\",\"396\":\"v-0556e594#optimized-code\",\"397\":\"v-0556e594#switchable-calls\",\"398\":\"v-7d6c7f4f\",\"399\":\"v-2db74d78\",\"400\":\"v-2db74d78#navigation控制界面切换\",\"401\":\"v-2db74d78#databinding绑定布局和数据\",\"402\":\"v-2db74d78#viewmodel管理数据与页面的交互\",\"403\":\"v-2db74d78#room保存数据\",\"404\":\"v-2db74d78#workmanager管理任务\",\"405\":\"v-9852d376\",\"406\":\"v-9852d376#hexo分支的结构\",\"407\":\"v-9852d376#travis-yml\",\"408\":\"v-ec117a1e\",\"409\":\"v-ec117a1e#装-git-环境\",\"410\":\"v-ec117a1e#安装-node\",\"411\":\"v-ec117a1e#校验环境\",\"412\":\"v-ec117a1e#配置环境变量方法\",\"413\":\"v-ec117a1e#安装-hexo\",\"414\":\"v-ec117a1e#配置-hexo\",\"415\":\"v-ec117a1e#目录的解释\",\"416\":\"v-ec117a1e#一些-hexo-语句解释\",\"417\":\"v-ec117a1e#新建文章\",\"418\":\"v-ec117a1e#部署方法-1\",\"419\":\"v-ec117a1e#部署方法-2\",\"420\":\"v-6eae82a2\",\"421\":\"v-6eae82a2#shareduserid\",\"422\":\"v-6eae82a2#筛选所有已安装应用信息\",\"423\":\"v-6eae82a2#生成插件app的context\",\"424\":\"v-6eae82a2#通过context反射获取插件app中的资源\",\"425\":\"v-6eae82a2#获取apk信息\",\"426\":\"v-6eae82a2#获取classloader\",\"427\":\"v-6eae82a2#通过反射加载类-获取资源\",\"428\":\"v-1cadefb2\",\"429\":\"v-2753e596\",\"430\":\"v-2753e596#遍历\",\"431\":\"v-2753e596#最大值和最小值\",\"432\":\"v-2753e596#删除\",\"433\":\"v-f23e8534\",\"434\":\"v-f23e8534#插入\",\"435\":\"v-f23e8534#移除\",\"436\":\"v-f23e8534#搜索\",\"437\":\"v-f23e8534#dfs\",\"438\":\"v-f23e8534#bfs\",\"439\":\"v-0781e8be\",\"440\":\"v-0781e8be#插入\",\"441\":\"v-0781e8be#移除\",\"442\":\"v-0781e8be#堆排序\",\"443\":\"v-0781e8be#满二叉树\",\"444\":\"v-0781e8be#完全二叉树\",\"445\":\"v-1c9f5176\",\"446\":\"v-1c9f5176#栈\",\"447\":\"v-1c9f5176#队列\",\"448\":\"v-1c9f5176#优先级队列\",\"449\":\"v-1c9f5176#效率\",\"450\":\"v-7e33dd04\",\"451\":\"v-7e33dd04#有序数组\",\"452\":\"v-7cb7bad2\",\"453\":\"v-7cb7bad2#优先级队列\",\"454\":\"v-500e9f6b\",\"455\":\"v-500e9f6b#冒泡排序\",\"456\":\"v-500e9f6b#选择排序\",\"457\":\"v-500e9f6b#插入排序\",\"458\":\"v-1bc5c65e\",\"459\":\"v-4e3a0568\",\"460\":\"v-1cc6761e\",\"461\":\"v-1cc6761e#增量的选择\",\"462\":\"v-1cc6761e#具体实现\",\"463\":\"v-1cc6761e#划分\",\"464\":\"v-1cc6761e#划分算法\",\"465\":\"v-1cc6761e#快速排序的思路\",\"466\":\"v-1cc6761e#枢纽的选择\",\"467\":\"v-1cc6761e#具体实现-1\",\"468\":\"v-346ad374\",\"469\":\"v-e1e3da16\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,86],\"1\":[1,47],\"2\":[1,201],\"3\":[2,106],\"4\":[1,19],\"5\":[1,45],\"6\":[1,9],\"7\":[1,25],\"8\":[1,7],\"9\":[1,9],\"10\":[1,57],\"11\":[1,47],\"12\":[1,24],\"13\":[1,292],\"14\":[3,148],\"15\":[2,126],\"16\":[1],\"17\":[1,154],\"18\":[1],\"19\":[2,74],\"20\":[2,97],\"21\":[2,50],\"22\":[5,10],\"23\":[1],\"24\":[3,37],\"25\":[3,29],\"26\":[3,11],\"27\":[1],\"28\":[3,25],\"29\":[3,25],\"30\":[3,31],\"31\":[1,44],\"32\":[1,35],\"33\":[1,8],\"34\":[1,32],\"35\":[1,127],\"36\":[1,183],\"37\":[1,38],\"38\":[1,7],\"39\":[1,13],\"40\":[1,204],\"41\":[1,181],\"42\":[1,20],\"43\":[1,162],\"44\":[1,69],\"45\":[7,69],\"46\":[5,27],\"47\":[5,25],\"48\":[2,45],\"49\":[1,143],\"50\":[6,24],\"51\":[5,21],\"52\":[5,51],\"53\":[1,197],\"54\":[1,176],\"55\":[1,238],\"56\":[1,193],\"57\":[1,127],\"58\":[1,489],\"59\":[1,65],\"60\":[1,107],\"61\":[1,76],\"62\":[1,38],\"63\":[1,144],\"64\":[1,183],\"65\":[1,240],\"66\":[1,118],\"67\":[1,6],\"68\":[1,19],\"69\":[1,108],\"70\":[1,18],\"71\":[2,43],\"72\":[3,154],\"73\":[1],\"74\":[2,17],\"75\":[1,51],\"76\":[1,9],\"77\":[1,13],\"78\":[2,85],\"79\":[1,232],\"80\":[1,303],\"81\":[1,201],\"82\":[3,48],\"83\":[2,20],\"84\":[2,41],\"85\":[3,90],\"86\":[3,62],\"87\":[3,90],\"88\":[4,33],\"89\":[2,17],\"90\":[2,12],\"91\":[2,46],\"92\":[2,39],\"93\":[1,40],\"94\":[2,77],\"95\":[3,119],\"96\":[1,79],\"97\":[3,52],\"98\":[3,69],\"99\":[3,41],\"100\":[2,111],\"101\":[2,150],\"102\":[1,211],\"103\":[2,157],\"104\":[1,47],\"105\":[1,141],\"106\":[2,150],\"107\":[4,49],\"108\":[4,238],\"109\":[2,200],\"110\":[2,66],\"111\":[1,388],\"112\":[2,232],\"113\":[1],\"114\":[2,93],\"115\":[2,736],\"116\":[2,112],\"117\":[2,127],\"118\":[3,143],\"119\":[3,91],\"120\":[1,57],\"121\":[1,166],\"122\":[2,170],\"123\":[3,2],\"124\":[2,31],\"125\":[3,113],\"126\":[3,242],\"127\":[1,223],\"128\":[3,139],\"129\":[1,25],\"130\":[1,164],\"131\":[4,158],\"132\":[2,93],\"133\":[1,32],\"134\":[1,66],\"135\":[1,73],\"136\":[1,116],\"137\":[1,41],\"138\":[1,21],\"139\":[1,8],\"140\":[1,36],\"141\":[1,35],\"142\":[2,27],\"143\":[2,97],\"144\":[2,35],\"145\":[3,26],\"146\":[2,89],\"147\":[1,177],\"148\":[1,29],\"149\":[2,33],\"150\":[1,58],\"151\":[1,10],\"152\":[1,94],\"153\":[1,124],\"154\":[1,112],\"155\":[2,102],\"156\":[1,125],\"157\":[1,133],\"158\":[1,73],\"159\":[1,66],\"160\":[1,21],\"161\":[1,109],\"162\":[2,45],\"163\":[2,44],\"164\":[1,18],\"165\":[1,44],\"166\":[2,36],\"167\":[2,47],\"168\":[1,81],\"169\":[1,17],\"170\":[4,95],\"171\":[1,91],\"172\":[4,122],\"173\":[1,66],\"174\":[1,40],\"175\":[1,49],\"176\":[2,101],\"177\":[2,82],\"178\":[1,101],\"179\":[2,106],\"180\":[2,214],\"181\":[2,190],\"182\":[2,72],\"183\":[1,103],\"184\":[1,112],\"185\":[1,64],\"186\":[1,132],\"187\":[1,26],\"188\":[1,110],\"189\":[2,17],\"190\":[2,49],\"191\":[2,49],\"192\":[2,57],\"193\":[1,108],\"194\":[1,52],\"195\":[1,62],\"196\":[1,144],\"197\":[1,96],\"198\":[1,308],\"199\":[2,47],\"200\":[1,41],\"201\":[1,157],\"202\":[1,156],\"203\":[2,62],\"204\":[1,21],\"205\":[1,56],\"206\":[1,59],\"207\":[1,93],\"208\":[1,34],\"209\":[2,117],\"210\":[1,62],\"211\":[1,600],\"212\":[1,230],\"213\":[1,253],\"214\":[2,6],\"215\":[2,18],\"216\":[4,74],\"217\":[2,41],\"218\":[1,12],\"219\":[1,17],\"220\":[1,245],\"221\":[1,63],\"222\":[1,7],\"223\":[2,148],\"224\":[2,37],\"225\":[1,160],\"226\":[1,346],\"227\":[1,198],\"228\":[3,113],\"229\":[1,38],\"230\":[4,98],\"231\":[1,47],\"232\":[1,23],\"233\":[3,110],\"234\":[1,75],\"235\":[1,72],\"236\":[2,31],\"237\":[2,74],\"238\":[1,104],\"239\":[1,88],\"240\":[1,58],\"241\":[2,69],\"242\":[2,125],\"243\":[2,33],\"244\":[2],\"245\":[4,9],\"246\":[2,6],\"247\":[3,6],\"248\":[4,6],\"249\":[1,38],\"250\":[2,21],\"251\":[2,6],\"252\":[4,18],\"253\":[3,10],\"254\":[3,58],\"255\":[3,13],\"256\":[2,8],\"257\":[2,18],\"258\":[2,5],\"259\":[2,3],\"260\":[2,3],\"261\":[1],\"262\":[2,11],\"263\":[2,20],\"264\":[2,13],\"265\":[2,17],\"266\":[1,32],\"267\":[1],\"268\":[1,5],\"269\":[1,8],\"270\":[1,2],\"271\":[1,3],\"272\":[1,213],\"273\":[1,46],\"274\":[3,77],\"275\":[3,58],\"276\":[1,44],\"277\":[2,58],\"278\":[1,67],\"279\":[2,129],\"280\":[1,268],\"281\":[1,153],\"282\":[1,176],\"283\":[2,111],\"284\":[1],\"285\":[1,69],\"286\":[1,28],\"287\":[4,187],\"288\":[1,189],\"289\":[1,87],\"290\":[1,20],\"291\":[1,106],\"292\":[1,33],\"293\":[1,32],\"294\":[1,143],\"295\":[1,127],\"296\":[1,111],\"297\":[1,117],\"298\":[1,94],\"299\":[1,49],\"300\":[1,59],\"301\":[1,25],\"302\":[1,322],\"303\":[3,45],\"304\":[1,25],\"305\":[2,125],\"306\":[1,128],\"307\":[1,22],\"308\":[1,106],\"309\":[1,155],\"310\":[1,21],\"311\":[1,46],\"312\":[1,61],\"313\":[1,19],\"314\":[1,74],\"315\":[1,1],\"316\":[1,39],\"317\":[1,93],\"318\":[3,19],\"319\":[1,12],\"320\":[1,48],\"321\":[1,140],\"322\":[1,338],\"323\":[5,26],\"324\":[1,13],\"325\":[1,62],\"326\":[1,33],\"327\":[1,288],\"328\":[3,180],\"329\":[1,56],\"330\":[1,17],\"331\":[1,8],\"332\":[1,10],\"333\":[1,4],\"334\":[1,130],\"335\":[1,20],\"336\":[1,33],\"337\":[2,26],\"338\":[1,12],\"339\":[1,15],\"340\":[1,26],\"341\":[1,43],\"342\":[1,10],\"343\":[1,20],\"344\":[1,31],\"345\":[1,130],\"346\":[2,117],\"347\":[2,189],\"348\":[1,33],\"349\":[1,83],\"350\":[1,11],\"351\":[1,33],\"352\":[1,26],\"353\":[2,38],\"354\":[1,3],\"355\":[2,7],\"356\":[1,22],\"357\":[1,48],\"358\":[1,25],\"359\":[1,9],\"360\":[1,13],\"361\":[3,103],\"362\":[1,85],\"363\":[1,44],\"364\":[1,82],\"365\":[1,105],\"366\":[1,13],\"367\":[3,37],\"368\":[4,55],\"369\":[1,182],\"370\":[1,171],\"371\":[2,162],\"372\":[2,102],\"373\":[2,97],\"374\":[1],\"375\":[1,37],\"376\":[1,156],\"377\":[1,68],\"378\":[1,242],\"379\":[2,79],\"380\":[1,38],\"381\":[1,90],\"382\":[3,195],\"383\":[1,433],\"384\":[2,115],\"385\":[1,6],\"386\":[1,90],\"387\":[3,244],\"388\":[2,75],\"389\":[4,392],\"390\":[1,80],\"391\":[3,438],\"392\":[2,135],\"393\":[2,33],\"394\":[1,48],\"395\":[2,109],\"396\":[2,257],\"397\":[2,22],\"398\":[1,37],\"399\":[1,98],\"400\":[1,124],\"401\":[1,127],\"402\":[1,43],\"403\":[1,29],\"404\":[1,24],\"405\":[1,30],\"406\":[1,15],\"407\":[3,67],\"408\":[1,51],\"409\":[3,19],\"410\":[2,10],\"411\":[1,25],\"412\":[2,19],\"413\":[2,45],\"414\":[2,30],\"415\":[2,25],\"416\":[3,25],\"417\":[1,104],\"418\":[2,30],\"419\":[2,70],\"420\":[2,8],\"421\":[1,44],\"422\":[1,34],\"423\":[1,13],\"424\":[1,30],\"425\":[1,19],\"426\":[1,62],\"427\":[2,51],\"428\":[2,67],\"429\":[2,38],\"430\":[1,27],\"431\":[1,3],\"432\":[1,78],\"433\":[2,34],\"434\":[1,4],\"435\":[1,2],\"436\":[1,8],\"437\":[1,60],\"438\":[1,151],\"439\":[2,47],\"440\":[1,39],\"441\":[1,57],\"442\":[1,26],\"443\":[1,8],\"444\":[1,18],\"445\":[2,51],\"446\":[1,5],\"447\":[1,6],\"448\":[1,6],\"449\":[1,18],\"450\":[3,24],\"451\":[1,75],\"452\":[2,27],\"453\":[1,95],\"454\":[2,8],\"455\":[1,56],\"456\":[1,62],\"457\":[1,49],\"458\":[2,117],\"459\":[2,178],\"460\":[2,50],\"461\":[1,14],\"462\":[1,81],\"463\":[1,7],\"464\":[1,12],\"465\":[1,13],\"466\":[1,11],\"467\":[1,70],\"468\":[1,7],\"469\":[1]},\"averageFieldLength\":[1.5914893617021277,81.19829660293846],\"storedFields\":{\"0\":{\"h\":\"关于\",\"t\":[\"A developer. A man who love the world.\",\"Keep touch with me:\",\"Languages and Tools:\",\"学习的过程需要不断的探索、累积，更需要有条理的总结，我会把平时学习的心得体会、经验总结放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。\",\"我的邮箱是：aml4aWFveW9uZzE5OTVAZ21haWwuY29tCg==\",\"在我学习的过程中，互联网给了我莫大的支持与帮助。但不可否认的是，中文互联网存在着很多“相互借鉴”的资料，其中不可避免有很多未经查实的资料，其危害不小。\",\"今天就因为这种问题，白白耽搁了一晚上的时间。而这还是我已经发现的有明显谬论的地方，其他没有发现的更是不知几多。\",\"很遗憾在此之前，我自己也写过不少这样欠缺思考，直接“拿来主义”的文章，真是惭愧。今日起，技术类文章务必自己理解了，理顺了才写，务必每个观点都有对应的参考依据。宁可少写，也不能乱写瞎写。之前的文章，也要慢慢的修正。\",\"哎呀，一不小心立了个 Flag，千万不要打脸(￣ ε(#￣)☆╰╮(￣ ▽ ￣///)。\",\"今后写博客，尽量避免写一些口水文，基础教程之类的文章，这类文章在我的学习过程中对我有很大的帮助，但网络上已经有很多步骤更加具体，内容更加完善的文章，实在没有必要再花费时间在这里了。日后逐渐深入源码，探究平常用法背后的实现原理，希望以此记录自己提升技术能力的过程。\",\"如你所见，这是一个托管在 GitHub 上面的博客，基于vuepress 2.0的hope主题，感谢所有为以上提到的项目有过付出的人，没有他们的话这个小站不会存在。\",\"在此之前，本博客使用了大约五六年的主题是基于Hexo的NexT主题，在我对编程尚且懵懂之际，为我提供了一个尚且不错的博客，感谢以上各位朋友。\",\"选好方向\",\"广泛阅读\",\"深入思考\",\"及时总结\",\"定时输出\"]},\"1\":{\"h\":\"Android开发常用设置\",\"t\":[\"国内较快的仓库：\",\"maven {url'http://maven.aliyun.com/nexus/content/groups/public/'}\",\"RecyclerView添加依赖 注意RecyclerView的版本号要和当前工程中其他android.support包版本保持一致，否则虽然导入了对应的包，但是仍然无法正常使用。\",\"compile 'com.android.support:recyclerview-v7:26+'\",\"设置： 自动添加依赖：insert imports on paste: None 自动删除无用依赖：Optimize imports on the fly\",\"设置ndk环境变量 /etc/profile\",\"#set ndk env\\nNDKROOT=/home/jixiaoyong/AndroidDev/Sdk/ndk-bundle\\nexport PATH=NDKROOT:PATH\"]},\"2\":{\"h\":\"Android11文件分区存储在图片读写的适配\",\"t\":[\"当APP目标版本是Android 10（API 29）及以后时，由于Android引入了分区存储，APP不能直接通过路径访问文件，访问外部存储空间中的媒体文件除了需要READ_EXTERNAL_STORAGE 或 WRITE_EXTERNAL_STORAGE 权限之外，需要通过其他APP分享的Uri读写文件，同理要给其余APP分享文件也许要通过FileProvider生成Uri并赋予对应的权限。\",\"本文以从相册中获取图片、请求系统裁剪并返回图片为例展示对应的适配方法。\",\"1.从相册中获取图片\",\"从相册中获取到的图片Uri一般如：content://raw//storage/emulated/0/DCIM/Camera/IMG_20210531_183008.HEIC\",\"app内部要读取其内容的话，可以通过context.getContentResolver().openInputStream(imageUri)\",\"或者\",\"Cursor cursor = context.getContentResolver().query(uri, filePathColumn, null, null, null);//从系统表中查询指定Uri对应的照片 cursor.moveToFirst(); int columnIndex = cursor.getColumnIndex(filePathColumn[0]); if (columnIndex >= 0) { picturePath = cursor.getString(columnIndex); } \",\"等方式读取，操作该图片。\",\"2.将外部文件保存到本地并获取Uri\",\"由于上述方式获取到的Uri只对本APP赋予了权限，要是希望将此图片分享给第三方APP进一步加工处理，则可能出现第三方APP没有读写权限而导致操作失败的情况，为了避免这种情况，可以将获取到的图片缓存到APP私有目录，并且重新生成Uri并赋予将要处理该图的第三方APP对应权限。\",\"将外部文件缓存本地的步骤参考第一步操作即可自行完成，主要讲解一下如何将对外分享的Uri赋予读写权限。\",\"下面这个方法在不同系统分别采用不同方式获取文件对应的Uri。\",\" public static Uri getUriForFile(Context context, File file) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { return FileProvider.getUriForFile(context, \\\"com.your.app.packagename.fileprovider\\\", file); } else { return Uri.fromFile(file); } } \",\"其中com.your.app.packagename.fileprovider是FileProvider的authorities。\",\"要使用FileProvider可以参考定义FileProvider操作，一般只需要修改authorities即可，同时如果是开发Android库，为了避免与主工程已有的FileProvider冲突，可以继承FileProvider类并修改下文中name字段。\",\"<manifest> ... <application> ... <provider android:name=\\\"androidx.core.content.FileProvider\\\" android:authorities=\\\"com.mydomain.fileprovider\\\" android:exported=\\\"false\\\" android:grantUriPermissions=\\\"true\\\"> <meta-data android:name=\\\"android.support.FILE_PROVIDER_PATHS\\\" android:resource=\\\"@xml/file_paths\\\" /> </provider> ... </application> </manifest> \",\"同时，为了定义此FileProvider可以使用的文件目录范围，可以在res/xml文件夹中新建file_paths.xml并做如下配置，也可参考官方文档或者Android N 7.0 FileProvider 兼容适配 原理解析：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <paths> <root-path name=\\\"camera_photos\\\" path=\\\"\\\" /> <external-files-path // 对应Context#getExternalFilesDir(String)获取的路径，一般为存储卡中Android/data/com.your.app.packagename/file下面的目录 name=\\\"external_files\\\" path=\\\".\\\" /> </paths> \",\"3.对外分享有权限的Uri\",\"对于上述步骤获取到的图片Uri赋予权限有两种方式：\",\"第一种，通过Intent传递出去的imgUri，可以使用以下方式：\",\"intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); intent.setDataAndType(imgUri, \\\"image/*\\\"); \",\"但是这种只适用于主动分享出去的文件，在调用第三方APP裁剪的场景中，一般还需要一个outPutUri用于保存裁剪之后的图片，对于这种场景，可以查询可能会调用的APP并赋予其访问权限：\",\"if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) { List<ResolveInfo> resInfoList = context.getPackageManager() .queryIntentActivities(intent, PackageManager.MATCH_ALL); for (ResolveInfo resolveInfo : resInfoList) { String packageName = resolveInfo.activityInfo.packageName; contextWrap.getActivity().grantUriPermission(packageName, outPutUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION); } } \",\"这样不管是分享出去的原图，还是裁剪之后保存的图片都给第三方APP赋予了权限，保证其可以正常访问。\",\"https://developer.android.google.cn/reference/androidx/core/content/FileProvider\",\"Android N 7.0 FileProvider 兼容适配 原理解析\"]},\"3\":{\"h\":\"Android AlarmManager设置重复任务\",\"t\":[\"近期有一个实现定时启动APP提醒用户的需求，一番比较之后觉得用闹钟AlarmManager实现比较合适，本文是对此过程的梳理，属于比较基础性的内容。\",\"需求需要实现\",\"\\\"每天在指定时间范围内,循环提示用户直到满足指定的条件\\\"\",\"拆分需求：\",\"每天都要提醒\",\"在时间范围内一直循环\",\"满足条件后结束当天循环\",\"Android中可以用到的循环任务实现有Handler、Timer、ScheduledExecutorService（这三个可以看这里），还有最近的WorkManager和我们要用到的AlarmManager。\",\"WorkManager offers a backwards compatible (API level 14+) API leveraging JobScheduler API (API level 23+) and above to help optimize battery life and batch jobs and a combination of AlarmManager & BroadcastReceiver on lower devices.\",\"这几个方案中，前三者都需要APP在前台运行，WorkManager和AlarmManager则在APP退出之后也可以使用，甚至在低版本上WorkManager底层也是通过AlarmManager实现的。\",\"WorkManager主要倾向于保证任务在APP退出，甚至设备关机重启等情况下也会被执行，虽然也提供循环任务的，但是无法确保在精确的时间得到执行，且最小间隔15min。\",\"相比之下，AlarmManager可以确保任务在指定时间（精确的时间）得到执行，并且对于循环的间隔也更加灵活。\",\"Android推荐选择方案\",\"据Android官网介绍，闹钟主要用于在应用程序生命周期之外进行定时操作。\",\"闹钟具有以下特征：\",\"它们可让您按设定的时间和/或间隔触发 intent。\",\"您可以将它们与广播接收器结合使用，以启动服务以及执行其他操作。\",\"它们在应用外部运行，因此即使应用未运行，或设备本身处于休眠状态，您也可以使用它们来触发事件或操作。\",\"它们可以帮助您最大限度地降低应用的资源要求。您可以安排定期执行操作，而无需依赖定时器或持续运行后台服务。\",\"需要注意的是，Android为了避免重复闹钟可能带来的性能消耗，推荐使用不是很精确的setInexactRepeating()， 而不是精确的setRepeating()，并且在API19+之后的所有的重复闹钟都不是精确的，如果需要精确闹钟需要使用 setWindow(int, long, long, android.app.PendingIntent) 或setExact(int, long, android.app.PendingIntent)。 重复闹钟具有以下特征：\",\"闹钟类型。要了解详情，请参阅选择闹钟类型。\",\"触发时间。如果您指定的触发时间为过去的时间，则闹钟会立即触发。\",\"闹钟的间隔。例如，每天一次、每小时一次、每 5 分钟一次，等等。\",\"闹钟触发的待定 intent。当您设置了使用同一待定 intent 的第二个闹钟时，它会替换原始闹钟。\"]},\"4\":{\"h\":\"闹钟类型\",\"t\":[\"闹钟有两个类型：\",\"距离系统启动后的时间，主要用于“间隔多久重复一次”这样的需求\",\"ELAPSED_REALTIME 距离开机时间多久后启用闹钟，如果系统在休眠中则不会唤醒\",\"ELAPSED_REALTIME_WAKEUP 在系统休眠时也会唤醒系统\",\"精确的时间UTC，主要用于“在当天下午8点整开始”等这样的需求\",\"RTC 在指定的时间触发闹钟，不会唤醒机器\",\"RTC_WAKEUP 在指定时间触发闹钟，并且唤醒设备\"]},\"5\":{\"h\":\"触发时间\",\"t\":[\"闹钟触发的时间，分为从设备上次启动时间和精准时间两种。\",\"如果触发的时间早于当前系统时间的话，系统会根据过去的时间和重复间隔选择一个合适的时间来触发（有几分钟内的误差）。\",\"从实际运行来看，使用ELAPSED_*的基本上会立即（几秒钟）触发该闹钟，并且每次循环间隔有几毫秒的误差。\",\"使用RTC_*则会在刚开始的两三次出现间隔时间小于指定时间的情况，后期稳定：\",\"设置的闹钟间隔为10分钟，闹钟开始时间早于当前时间，唤醒结果如下\",\"alarmMgr.setRepeating(AlarmManager.RTC_WAKEUP, calendar.timeInMillis, 10 * 60 * 1000, alarmIntent ) 2019-12-06 14:13:46.696 2019-12-06 14:16:26.634 2019-12-06 14:24:26.765 2019-12-06 14:34:26.579 2019-12-06 14:43:46.785 \"]},\"6\":{\"h\":\"间隔时间\",\"t\":[\"间隔时间有两种：\",\"AlarmManager interval 如果设置的是setInexactRepeating()，则需要设置AlarmManager 指定的几种间隔时间。\",\"任意时间 setRepeating()方法可以使用任意时间\"]},\"7\":{\"h\":\"待定的intent\",\"t\":[\"当您设置了使用同一待定 intent 的第二个闹钟时，它会替换原始闹钟\",\"待定的Intent是一个PendingIntent，可以用来打开Service，Activity，Broadcast等等。\",\"private fun getPendingIntent( context: Context, action: String, requestCode: Int ): PendingIntent { return PendingIntent.getBroadcast(context, requestCode, Intent(action), 0) } \",\"注意这里的requestCode，当不需要该闹钟时可以根据这个来取消。\"]},\"8\":{\"h\":\"取消闹钟\",\"t\":[\"alarmManager.cancel(getPendingIntent(context,ACTION,RequestCode)) \"]},\"9\":{\"h\":\"在重启时恢复闹钟\",\"t\":[\"由于闹钟会在设备关机的时候被取消，所以需要监听设备开机广播（android.intent.action.BOOT_COMPLETED），并且恢复闹钟。\"]},\"10\":{\"h\":\"设置一个每天指定时间循环的闹钟\",\"t\":[\"private fun setupDailyAlarmClock( context: Context,startTime: Pair<Int, Int>) { val alarmMgr = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager val alarmIntent = getPendingIntent( context, BROADCAST_ACTION_REPEAT, RequestCode.START_REPEAT_INVENTORY ) // Set the alarm to start at xx:xx val calendar: Calendar = Calendar.getInstance().apply { timeInMillis = System.currentTimeMillis() set(Calendar.HOUR_OF_DAY, startTime.first) set(Calendar.MINUTE, startTime.second) set(Calendar.SECOND, 0) } // 1 day alarmMgr.setRepeating( AlarmManager.RTC_WAKEUP, calendar.timeInMillis, AlarmManager.INTERVAL_DAY, alarmIntent ) } \",\"在每天指定时间到了之后，开始设置一个间隔10分钟唤醒一次的闹钟，直到超时或者满足指定的条件后取消该闹钟。\"]},\"11\":{\"h\":\"监听每日循环的闹钟\",\"t\":[\"监听其发送的广播BROADCAST_ACTION_REPEAT。\",\"启用当日循环闹钟：\",\" fun setupRepeatAlarmClock(context: Context) { val startTime = SharePreferencesUtils.sharedPreferences .getString(KEY_STARTT_TIME,DEF_INVENTORY_TIME)?.toFormatTime() ?: return val alarmMgr = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager val alarmIntent = getPendingIntent( context, BROADCAST_ACTION_START, RequestCode.START_INVENTORY ) val tenMinutes = DEF_INVENTORY_DURATION * 60 * 1000 alarmMgr.setRepeating( AlarmManager.ELAPSED_REALTIME_WAKEUP,//从开机后多久 SystemClock.elapsedRealtime(),//当前自开机完后的时间 tenMinutes,//每十分钟循环一次 alarmIntent ) } \",\"在广播接收器中收听到BROADCAST_ACTION_START后去开启任务\"]},\"12\":{\"h\":\"条件满足后关闭当日循环闹钟\",\"t\":[\"在收到BROADCAST_ACTION_START后检测到已经超时或其他满足取消条件的情况，则取消任务。\",\"或者可以再订一个结束时间的闹钟，到时间后取消当日循环闹钟。\",\"val alarmManager = getSystemService(Context.ALARM_SERVICE) as AlarmManager alarmManager.cancel(pIntent) \",\"注意这里的pIntent需要与设置闹钟时的PendingIntent一致(满足Intent.filterEquals()的条件)。\",\"Android定时任务及循环任务基础大集合\",\"安排重复闹钟 Android官网\"]},\"13\":{\"h\":\"Android事件分发\",\"t\":[\"Android事件分发，指手指点击屏幕后，从Activity、ViewGroup到View的一系列过程。\",\"Android系统的窗口机制如下图：\",\"Activity内有一个Window对象，其实现类是PhoneWindow；\",\"DecorView为顶层View，DecorView是一个FrameLayout，其中有TitleView和ContentView；\",\"Android系统窗口管理机制\",\"TitleView为标题栏，ContentView就是平时在Activity的onCreate()方法中设置的视图，TitleView可以用this.requestWindowFeature(Window.FEATURE_NO_TITLE);隐藏掉，但是必须注意要在setContentView()之前，原因如下所示：\",\"public void setContentView(View view) { getWindow().setContentView(view); initWindowDecorActionBar(); } \",\"点击事件发生后，首先被调用的是Activity.dispatchTouchEvent()\",\"public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } \",\"可以看到，其内部先调用了getWindow().superDispatchTouchEvent(ev)这个方法，getWindow()返回的mWindow是PhoneWindow的对象。\",\"mWindow = new PhoneWindow(this, window, activityConfigCallback); \",\"再看看PhoneWindow.superDispatchTouchEvent()方法，显然又调用了DecorView的superDispatchTouchEvent()方法,在该方法中，调用了FrameLayout.dispatchKeyEvent(event)，此时点击事件从Activity转到了ViewGroup中。\",\"//PhoneWindow @Override public boolean superDispatchKeyEvent(KeyEvent event) { return mDecor.superDispatchKeyEvent(event); } //DecorView extends FrameLayout public boolean superDispatchKeyEvent(KeyEvent event) { // Give priority to closing action modes if applicable. if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) { final int action = event.getAction(); // Back cancels action modes first. if (mPrimaryActionMode != null) { if (action == KeyEvent.ACTION_UP) { mPrimaryActionMode.finish(); } return true; } } return super.dispatchKeyEvent(event); } \",\"ViewGroup与事件分发的方法有三个：\",\"dispatchTouchEvent() 分发事件，每次都会被调用\",\"onInterceptTouchEvent() 拦截事件，如果当前ViewGroup已经决定拦截事件，那么不会再调用\",\"onTouchEvent() 处理点击事件,如果设置了mOnTouchListener的话，则不会回调本方法\",\"这三个主要方法关系如下（伪代码，来自《Android开发艺术探索》）：\",\"//每次点击事件回调该方法 override fun dispatchTouchEvent(event: MotionEvent): Boolean { var result = false if (onInterceptTouchEvent(event)) {//viewGroup会回调该方法，确认是否拦截点击事件 result = onTouchEvent(event)//对点击事件进行处理 } else { result = child.dispatchTouchEvent(event) } } return result } \",\"当ViewGroup.dispatchTouchEvent()被调用后，会通过一系列条件判断是由ViewGroup拦截该事件，还是由子View消耗该事件。\",\"主要流程分为两部分\",\"1.检查是否需要拦截\",\"// http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/view/ViewGroup.java line2567-2582 public boolean dispatchTouchEvent(MotionEvent ev) { ... // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev);//在这里调用了onInterceptTouchEvent()方法，如果已经拦截了 ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } ... } public boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.isFromSource(InputDevice.SOURCE_MOUSE) && ev.getAction() == MotionEvent.ACTION_DOWN && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) && isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; } \",\"每次ACTION_DOWN事件都需要调用onInterceptTouchEvent()方法判断是否需要拦截\",\"其他MotionEvent事件，如果有能处理点击事件的子View（mFirstTouchTarget != null）且disallowIntercept为false也需要调用onInterceptTouchEvent()方法判断是否需要拦截，否则不需要拦截\",\"其余情况都需要拦截（没有可以处理点击事件的子View，并且不是ACTION_DOWN事件）\",\"如果ViewGroup判断要拦截该事件，则会调用dispatchTransformedTouchEvent()（后面会再讲到）通过他调用继承自View的dispatchTouchEvent(MotionEvent event)方法：\",\" // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { ... } \",\"否则就需要遍历其子View\",\"2.遍历ViewGroup的所有子View，寻找一个可以处理点击事件的子View\",\"dispatchTransformedTouchEvent() 调用了子View的dispatchTouchEvent()\",\"addTouchTarget() 对mFirstTouchTarget 进行更新\",\"public boolean dispatchTouchEvent(MotionEvent ev) { // 1. Check for interception.判断是否需要拦截 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {//mFirstTouchTarget表示能处理点击事件的子View //FLAG_DISALLOW_INTERCEPT每次ACTION_DOWN都会被重置 final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev);//调用拦截方法 ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } //2.遍历子View，寻找可以处理点击事件的子View if (!canceled && !intercepted) { for (int i = childrenCount - 1; i >= 0; i--) { if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. ... newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } } } } \",\"dispatchTransformedTouchEvent()方法如下，由于child != null其内部调用child.dispatchTouchEvent(event)方法，如此循环直到子View是一个View（单就ViewGroup和View而论）即将点击事件从ViewGroup分发到了View。\",\"private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { ... if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } } \",\"如果有子View可以处理点击事件，在addTouchTarget()方法内部对mFirstTouchTarget进行更新\",\"private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; } \",\"View的点击事件分发主要涉及到两个方法：\",\"dispatchTouchEvent()\",\"onTouchEvent()\",\"其点击事件分发用伪代码表示如下:\",\"public boolean dispatchTouchEvent(MotionEvent event) { if(mListenerInfo.mOnTouchListener.onTouch(this, event)){ return true; }else{ return onTouchEvent(event); } } \",\"可见View的dispatchTouchEvent()方法中，如果View注册了OnTouchListener则会先执行mOnTouchListener.onTouch()方法,如果该方法返回false才会执行onTouchEvent()。\",\"在看onTouchEvent()方法：\",\"如果View处于不可用状态下，也会消耗点击事件，只不过没有反应\",\"如果注册了OnClickListener会在ACTION_UP的时候调用mOnClickListener.onClick(this)\",\"public boolean onTouchEvent(MotionEvent event) { ... if(CLICKABLE&&LONG_CLICKABLE){//LONG_CLICKABLE默认为false，CLICKABLE、LONG_CLICKABLE会在设置点击事件时被设置为true switch (action) { case MotionEvent.ACTION_UP:{ ... performClick();//如果注册了OnClickListener则会调用其onClick()方法 } } } } public boolean performClick() { ... mListenerInfo.mOnClickListener.onClick(this); ... } \",\"整个Android的时间分发始于Activity,经过PhoneWindow、DecorView到达ViewGroup，再逐层分发到View中。\",\"如果底层没有处理点击事件，则又一层层向上返回，直到最顶层消耗掉点击事件。\",\"《Android开发艺术探索》\",\"Android源代码\"]},\"14\":{\"h\":\"Android 5.x以下加载MultiDex白屏的处理优化\",\"t\":[\"当APP的minSdkVersion低于Android 5时，在方法数大于65536时，需要将APP打包为多个DEX文件，此时需要添加MultiDex依赖。\",\"官方方法如下：\",\"1.build.gradle\",\"android { defaultConfig { ... minSdkVersion 15 targetSdkVersion 28 multiDexEnabled true } ... } dependencies { compile 'com.android.support:multidex:1.0.3' } \",\"2.MyApplication\",\"方式❶： public class MyApplication extends MultiDexApplication { ... } 方式❷： public class MyApplication extends SomeOtherApplication { @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); MultiDex.install(this); } } \",\"此外，为了避免一些启动期间需要的任何类未在主 DEX 文件中提供而导致java.lang.NoClassDefFoundError，还需要告诉AS将这些类添加到主DEX文件中：\",\"3.build.gradle\",\"android { buildTypes { release { ❶ multiDexKeepFile file('multidex-config.txt') ❷ multiDexKeepProguard('multidex-config.pro') ... } } } //multidex-config.txt com/example/MyClass.class com/example/MyOtherClass.class //multidex-config.pro -keep class com.example.MyClass -keep class com.example.MyClassToo -keep class com.example.** { *; } // All classes in the com.example package \",\"但是在实际运行中，Android 4.x的系统会在APP安装后第一次启动时，在MultiDex.install(this)方法中进行DEX文件合并优化等耗时操作（主线程），往往会持续数十秒以上，从而导致APP第一次启动时长时间白屏，十分影响体验。\",\"查阅相应的资料后大体有以下几种方案\",\"设置主Activity的背景为透明色\",\"这样当用户点击APP图标启动APP时，在主Activity启动之前看到的一直是桌面的样子而非白屏，但这只是一种障眼法，用户可能会以为系统卡顿，体验并不好。\",\"在Application中检测到是第一次启动的话，新开一个进程并在其中进行MultiDex.install(this)\",\"这种方法在主进程启动时，检测到尚未进行MultidexOpt，则阻塞当前进程，新开一个进程，在其中加载一个Activity，并在后台进程运行MultiDex.install(this)，当MultidexOpt完成后再关闭当前进程，返回主进程继续正常开启APP。\",\"由于主进程被阻塞的同时成为了后台进程，所以也不会触发ANR，此外子进程中的过渡Activity也只用到了基本的类，所以基本不用担心会触发java.lang.NoClassDefFoundError，而且过渡Activity可以展示进度、提示等用户友好的页面，相对来说体验也好了很多。\",\"但是这种方法从子进程返回主进程涉及到进程间通信，以及主进程的主Activity启动时生命周期会出现异常(onCreate() -> onStart() -> onResume() -> onPause()->onResume())，仍然不是很好的解决方法。\",\"结合上述的分析后，可以看到这种问题的优化思路主要在于如何在避免java.lang.NoClassDefFoundError的同时，在后台可靠的通过MultiDex.install(this)执行MultidexOpt操作。\",\"通过以上方案1和2的结合，可以有一个比较完美的解决方案：\",\"方案2中在过渡Activity的后台线程进行MultidexOpt操作思路是正确的，但是不需要再单独开一个进程，我们完全可以将其当做主进程的第一个Activity，等待MultidexOpt操作完成后再跳转到主Activity并finish掉本Activity，这样主Activity的生命周期也不会受影响。\",\"这种情况下在部分低端机上，过渡Activity到主Activity跳转时会出现短暂黑屏，我们可以在过渡页面将Activity切换动画设置为渐变效果，并将主Activity背景设置为透明，待主Activity完全加载好后再将背景切换为普通模式。\",\"综上处理，我们的Application无需改动，甚至主Activity也可以不做改动，只需要添加一个过渡页面为启动Activity，在其中后台进行MultidexOpt，等DEX文件处理完毕后再加载主Activity。对项目改动少并且逻辑较为简单。\",\"注：\",\"MultiDexOpt即执行MultiDex.install(getApplication());方法；\",\"需要注意过渡Activity尽量少的使用类，并且要确保过渡Activity可能会调用到的类加载到了主dex文件中。\",\"配置方法数超过 64K 的应用\",\"Android MultiDex初次启动APP优化方案优雅的实现\",\"MultiDex深入学习\"]},\"15\":{\"h\":\"Android paint绘制text\",\"t\":[\"Android中绘制文字的方法如下：\",\" /** * Draw the text, with origin at (x,y), using the specified paint. The origin is interpreted * based on the Align setting in the paint. * * @param text The text to be drawn * @param x The x-coordinate of the origin of the text being drawn * @param y The y-coordinate of the baseline of the text being drawn * @param paint The paint used for the text (e.g. color, size, style) */ public void drawText(@NonNull String text, float x, float y, @NonNull Paint paint) { super.drawText(text, x, y, paint); } \",\"其中y是文字baseline的y坐标。\",\"下图表示Paint.FontMetrics中存储的文字的各种信息（来源：简书）：\",\"我们没法直接获取到baseline的坐标，所以只能从另外一个角度考虑： 因为在绘制文字时，文字的上下中心（即上图中的center）是确定的，我们只要计算出center到baseline之间的偏移量，就可以计算出baseline的y坐标。\",\"又根据这个文章：\",\"基线到中线的距离 = (descent + ascent) / 2 - descent = (ascent - descent) / 2 \",\"(descent + ascent) / 2是中线center的值，而根据上图可知(descent + ascent) / 2 - descent的值就是baseline到center的距离。\",\"所以\",\"baseline的y坐标 = 文字的上下高度中心 + baseline的竖坐标和文字上下实际中心的偏移量 = center.y + 基线到中线的距离 = center.y + (ascent - descent) / 2 \",\"这个center.y根据场景不同可以是一行的行中心（文字在一行居中显示），或者控件的上下中心（文字在控件上下居中）\",\"得出结论：\",\"由于android绘制文字时，并不是从文字高度的中间开始绘制，而是从baseline开始绘制。所以在绘制文字时，为了使文字高度居中（在所指定的空间内居中，比如某一行，就在该行限定的高度内居中显示；某一控件，则整个控件的上下中间显示），需要在计算出来的文字上下中心的y坐标基础上加上baseline到文字中线的偏移量。\",\"除此之外，也可以类比得到：baseline.y = center.y + (bottom.y - top.y) / 2 - bottom.y\",\"基线（baeseline），坡顶（ascenter）,坡底（descenter）\",\"上坡度（ascent），下坡度（descent）\",\"行间距（leading）：坡底到下一行坡顶的距离\",\"字体的高度＝上坡度＋下坡度＋行间距\",\"https://blog.csdn.net/hanyongbai/article/details/84418369\",\"参考文章：https://www.jianshu.com/p/c1575636741ehttps://blog.csdn.net/hanyongbai/article/details/84418369http://www.imooc.com/article/277490?block_id=tuijian_wzhttps://blog.csdn.net/xuxingxing002/article/details/50971606\"]},\"16\":{\"h\":\"AndroidService相关知识\"},\"17\":{\"h\":\"启动一个Service\",\"t\":[\"MyServices.java\",\"必须继承自Service，或者如IntentService本身就是等其子类\",\"public class MyServices extends Service { @Nullable @Override public IBinder onBind(Intent intent) { Log.d(\\\"TAG\\\",\\\"onBind\\\"); return null; } @Override public void onCreate() { super.onCreate(); Log.d(\\\"TAG\\\",\\\"onCreate\\\"); } @Override public void onDestroy() { super.onDestroy(); Log.d(\\\"TAG\\\", \\\"onDestroy: \\\"); } } \",\"AndroidManifest.xml\",\"注册MyServices\",\"<application> <service android:name=\\\".MyServices\\\" android:exported=\\\"true\\\"> <intent-filter> <action android:name=\\\"cf.android666.myservices\\\" /> </intent-filter> </service> </application> \",\"MainActivity.java\",\"在java中调用Service，需要ServiceConnection类\",\"ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { Log.d(TAG, \\\"onServiceConnected: 服务绑定\\\"); } @Override public void onServiceDisconnected(ComponentName name) { Log.d(TAG, \\\"onServiceDisconnected: 服务解绑\\\"); } }; Intent intent = new Intent(context, MyServices.class); bindService(intent, mConnection, Service.BIND_AUTO_CREATE);//绑定Service //startService(intent); 启动service unbindService(mConnection);//解绑Service \",\"bindService()和startService()的区别在于：\",\"** bindService()将service和当前的activity绑定在一起，activity销毁时，service也会被销毁；\",\"** startService()则只是“启动”service，在此后service的活动和activity无关，并一直存活。\",\"Service在AndroidManifest.xml中的属性：\",\"android:name=\\\".MyService\\\"//必须被指定 android:exported=true/false //是否能被其他应用隐式调用 //有intent-filter则默认为true，否则默认false；若手动指定为false则即使有intent-filter也无法隐式调用 android:process=\\\"remote\\\"/\\\":remote\\\"//前者在共有的进程中进行，后者在名字为{packageName}:remote 的私有进程中进行，其他进行不可访问；如果不设置该属性，则service在应用自己的进程里面运行 \",\"Service默认运行在创建他的线程中，要是进行耗时操作，最好在service中单独创建一个线程，这样子可以在子线程工作，在主线程中更新工作进度。\",\"Service中的方法：\",\"//在初次创建服务时调用，并且直至服务死亡，只会被调用一次 void onCreate() //在绑定服务是才会被调用，必须实现该方法 IBinder onBind(Intent intent) //每一次通过startService()方法启动Service的时候都会被调用 int onStartCommand(Intent intent, int flags, int startId) //1.intent 启动时，启动组件传递过来的Intent //2.flags 表示启动请求时是否有额外数据，可以是： // 0：无 // START_FLAG_REDELIVERY：表示该方法返回值为START_REDELIVER_INTENT，在上个服务被杀死之前调用stopSelf()停止服务 // START_FLAG_RETRY：在onStartCommand()被调用后一直无返回值时，会尝试重新调用onStartCommand() //3.当前服务id \",\"其中onStartCommand()方法的返回值意义如下：\",\"START_STICKY :service在内存不足被杀死后，内存空闲时系统会重新创建service，一旦成功创建会回调onStartCommand()方法，此时intent是null，除非是挂起的intent如pendingintent，无限期运行\",\"START_NOT_STICKY：service因内存不足被杀死，内存再次空闲系统也不会再重新创建服务，最安全\",\"START_REDELIVER_INTENT：service因内存不足被杀死，会重建服务并传递给最后一个intent（最后一次调用startService() 时的intent），用于连续作业，如下载等\"]},\"18\":{\"h\":\"Service绑定服务的三种方式\"},\"19\":{\"h\":\"1.拓展Binder类\",\"t\":[\"要求客户端和服务在同一应用的同一进程内。客户端通过其访问service中的公共方法。\",\"步骤如下：\",\"创建BindService服务端，在类中创建一个实现了IBinder接口的实力对象并提供公共方法给客户端使用\",\"在onBind()回调方法返回此Binder实例\",\"在客户端的onServiceConnected()方法接收Binder，使用提供的方法绑定服务\",\"//service服务端 public class LocalService extends Service{ LocalService mService; private LocalBinder binder = new LocalBinder(); ... public IBinder onBind(Intent intent){ return binder; } public void doSomeThing(){ //服务中公共方法，可以被客户端通过IBInder获取实例调用 } public class LocalBinder extends Binder{ LocalService getService(){ return LocalService.this; } } } //客户端 public class BindActivity extends Activity{ protected void onCreate(...){ ServiceConnection conn = new ServiceConnection(){ //绑定服务时被调用，实现客户端和服务端交互（IBinder） public void onServiceConnected(ComponentName name, IBinder service){ LocalService.LocalBinder binder = (LocalService.LocalBinder)service;//获取服务端IBinder mService = binder.getService();//获取服务实例，以调用服务的公共方法 } //取消绑定时回调，多数时候是service被意外销毁，如内存不足 //当客户端取消绑定时，系统“绝对不会”调用该方法。 public void onServiceDisconnected(ComponentName name){ mService = null; } }; //创建绑定对象 Intent intent = new Intent(this,LocalService.class); //绑定服务 //参数3 flags则是指定绑定时是否自动创建Service。0代表不自动创建、BIND_AUTO_CREATE则代表自动创建 bindService(intent,conn,Service.BIND_AUTO_CREATE); //调用服务中的方法，最好先判断是否为null mService.doSomeThing(); //解除绑定 unbindService(conn); } } \"]},\"20\":{\"h\":\"2.Messenger\",\"t\":[\"service与不同进程通信（IPC） 。\",\"步骤如下：\",\"Service实现一个Handler，接收客户端每个调用的回调\",\"用Handler创建Messenger对象\",\"用Messenger创建IBinder对象，并通过onBind()返回客户端\",\"客户端使用IBinder实例化Messenger，用其将Message对象发送给Service\",\"Service在Handler接收并处理Message\",\"//Service public class MessageService extends Service{ public final static int MSG_WHAT = 1; //创建Handler接收、处理客户端msg class IncomingHanler extends Handler{ public void handleMessage(Message msg){ //do sth with msg... } } Messenger messenger = new Messenger(new IncomingHanlder()); public IBinder onBind(Intent intent){ return messenger.getBinder(); } } //客户端 //onCreate()方法中： mConnection = new ServiceConnection(){ public void onServiceConnected(ComponentName className, IBinder service){ Messenger mService = new Messenger(service); } }; //给服务发消息 Message msg = Message.obtain(null,MessengerService.MSG_WHAT,0,0); mService.send(msg); \",\"注意service要在不同的进程中：\",\"AndroidMinafast.xml <service android:name=\\\".messenger.MessengerService\\\" android:process=\\\":remote\\\" /> \",\"服务与客户端双向通信\",\"服务端，修改IncomingHandler，回复客户端消息\",\"class IncomingHandler extends Handler{ public void handleMessage(Message msg){ //回复消息 Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null,MessengerService.MSG_WHAT); Bundle bundle = new Bundle(); bundle.putString(\\\"key\\\",\\\"value\\\"); replyMsg.setData(bundle); try{ client.send(replyMsg); }catch(){} } } \",\"客户端，增加Messenger和Handler处理服务端回复\",\"private static class RecyclerReplyMsgHandler extends Hanlder{ public void handleMessage(Message msg){ //接收服务端返回的msg //do sth ... } } private Messenger mRecevierReplyMsg = new Messenger(new RecyclerReplyMsgHandler()); \",\"此外，在发送消息是需要将接收服务端回复的Messenger通过Message的replyTo传递给服务端\",\"//create msg... msg.replyTo = mRecevierReplyMsg; //send msg... \"]},\"21\":{\"h\":\"3.AIDL\",\"t\":[\"一般不会使用，具体使用可以参考这篇文章\",\"多个客户端可连接一个服务端，只有第一个客户端绑定时才会调用服务onBind()方法来检索IBinder，此后无需调用就可将同一个IBinder传递给其他客户端\",\"bindService() 绑定服务是异步进行的\",\"一般在activity可见生命周期内绑定-取消服务，不要在onResume()、onPause()期间执行绑定/解绑\",\"顺序\",\"结果\",\"先绑定后启动service\",\"启动service\",\"先启动后绑定service\",\"会绑定宿主，但是宿主死后仍按照启动service方式存活\",\"startForeground(int id, Notification notification) 该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。\",\"stopForeground(boolean removeNotification) 该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务。 但是，如果在服务正在前台运行时将其停止，则通知也会被删除。\",\"文章参考：\",\"关于Android Service真正的完全详解，你需要知道的一切 - CSDN博客\"]},\"22\":{\"h\":\"Android 异步消息机制 Handler、Message、Looper\",\"t\":[\"此文为鸿洋博客阅读笔记，配合原文食用口味更佳。\",\"Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系 - CSDN博客\",\"20200429160005\"]},\"23\":{\"h\":\"Looper\"},\"24\":{\"h\":\"Looper.perpare()\",\"t\":[\"Looper.perpare()方法创建Looper对象（同时创建MessageQueue对象），并与当前线程关联保存在sThreadLocal中。\",\"public static final void prepare() { if (sThreadLocal.get() != null) { throw new RuntimeException(\\\"Only one Looper may be created per thread\\\"); } sThreadLocal.set(new Looper(true)); } private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mRun = true; mThread = Thread.currentThread(); } \"]},\"25\":{\"h\":\"Looper.loop()\",\"t\":[\"Looper.loop()方法获取保存的Looper对象并由此获取到MessageQueue对象。\",\"通过for循环，不停的通过mQueue获取到msg，并调用msg.target.dispatchMessage(msg)执行msg对应的处理方法。\",\"最后通过msg.recycle()回收使用完的msg。\",\"public static void loop() { final Looper me = myLooper(); ... final MessageQueue queue = me.mQueue; ... for (;;) { Message msg = queue.next(); // might block ... msg.target.dispatchMessage(msg); ... msg.recycle(); } } \"]},\"26\":{\"h\":\"Looper.myLooper()\",\"t\":[\"myLooper()内部调用sThreadLocal获取已有的Looper对象\",\"public static Looper myLooper() { return sThreadLocal.get(); } \",\"Android的Activity默认在UI线程调用了Looper的prepare()和loop()方法\"]},\"27\":{\"h\":\"Handler\"},\"28\":{\"h\":\"handler.sendMessage()\",\"t\":[\"Handler构造方法会获取到mLooper和mQueue以及mCallback\",\" mLooper = Looper.myLooper(); mQueue = mLooper.mQueue; mCallback = callback; // Handler()中此值为null \",\"sendMessage()方法最终会调用sendMessageAtTime()方法,在其内部调用enqueueMessage()方法，将handler赋予msg.target，并将msg压入mQueue中\",\"//enqueueMessage方法 msg.target = this; queue.enqueueMessage(msg, uptimeMillis);//将handler发送的msg压入到当前线程的Looper持有的MessageQueue中 \"]},\"29\":{\"h\":\"handler.dispatchMessage()\",\"t\":[\"Handler的dispatchMessage()方法会在Looper.loop()中被调用\",\"public void dispatchMessage(Message msg) { if (msg.callback != null) { //msg自带的回调方法 handleCallback(msg); } else { if (mCallback != null) { //handler指定的回调方法 if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); //handler的handleMessage()方法 } } \",\"其中执行顺序是：msg.callback > mCallback > handleMessage()\"]},\"30\":{\"h\":\"handler.post()\",\"t\":[\"handler.post(new Runnable())调用了getPostMessage(r)方法将r赋予msg.callback\",\"public final boolean post(Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m; } \",\"最后也是在sendMessageDelayed方法中调用sendMessageAtTime()方法将msg压入MessageQueue中\",\"public final boolean sendMessageDelayed(Message msg, long delayMillis) { ... return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } \"]},\"31\":{\"h\":\"msg的获取\",\"t\":[\"Message.obtain(); 复用MessageMessage池中已有的对象，避免出现分配内存 推荐\",\"new Message();\",\"Looper在**perfare()**方法中创建Looper及MessageQueue对象并保存在sThreadLocal中，\",\"在**loop()**方法中通过myLooper()从sThreadLocal中取出mLooper，并由此获得mQueue，在for循环中通过mQueue.next()获取msg，用msg.target.dispatchMessage()方法回调handler中的msg处理方法。\",\"Handler在**构造函数**中通过Looper.myLooper()获取到当前线程的Looper和MessageQueue；\",\"**sendMessage()**方法最终通过sendMessageAtTime()调用enqueueMessage()方法将msg压入到MessageQueue中。\",\"至此将Looper和Handler通过MessageQueue联系在一起，并共同参与处理Message。\",\"此外**handler.post(runnable)也是通过在post()**内部调用getPostMessage()方法将runnable赋予msg.callback，并在post()中通过sendMessageDelayed()方法调用sendMessageAtTime()方法将msg压入MessageQueue中\"]},\"32\":{\"h\":\"Android中AIDL的使用\",\"t\":[\"AIDL（Android Interface Definition Language ，Android接口定义语言）用于Android IPC，适用于大量并发请求。\",\"主要分为两部分：\",\"服务端 创建Service监听Client的请求，通过创建AIDL将接口暴露给客户端\",\"客户端 绑定到服务端获取BInder对象，将其转化为对应AIDL，并调用接口对应方法。\",\"两者的连线就是AIDL，因此两个APP的AIDL必须一致，可以将AIDL文件放到一个Android Library中，或者打成aar文件供二者依赖。\",\"也可以将AIDL涉及到的AIDL文件、java都放到AIDL文件夹下，然后在build.gradle的android{...}中添加\",\" sourceSets{ main{ java.srcDirs = ['src/main/java','src/main/adil'] } } \",\"即添加一个java路径\"]},\"33\":{\"h\":\"支持的数据格式\",\"t\":[\"基本数据类型、List（ArrayList）、Map（HashMap）以及实现了Parcelable接口的对象、AIDL接口。\"]},\"34\":{\"h\":\"注意事项\",\"t\":[\"自定义的Parcelable对象、AIDL对象必须显示import。\",\"AIDL中用到的Parcelable对象必须新建一个同名AIDL接口，声明其为Parcelable类型。\",\"// People.aidl package cf.android666.androidlib; import cf.android666.androidlib.People; // Declare any non-default types here with import statements parcelable People; \",\"AIDL中除了基本数据类型，其他的参数必须标记方向（in,out,inout）。\",\"AIDL不支持方法重载，也就是说不能有两个同名的方法（即使参数类型、个数不同也不行）。\",\"AIDL中只支持方法，不支持静态变量。\"]},\"35\":{\"h\":\"AIDL\",\"t\":[\"// ManagerAidl.aidl package cf.android666.androidlib; import cf.android666.androidlib.People; import cf.android666.androidlib.TaskCallBack; interface ManagerAidl { //客户端提供的方法 List<People> getPeopleList(); void addPeople(in People people); //回调接口，用于服务端往客户端通信 void registerCallBack(in TaskCallBack callback); void unregisterCallBack(in TaskCallBack callback); } \",\"// TaskCallBack.aidl package cf.android666.androidlib; import cf.android666.androidlib.People; // https://blog.csdn.net/woshiwoshiyu/article/details/54266101 //回调的具体方法，供服务端回调 interface TaskCallBack { void callBack(in int size); void onPeopleChange(in List<People> peoples); } \",\"//People.java package cf.android666.androidlib; public class People implements Parcelable { ... } \",\"//PeopleManager.java package cf.android666.androidlib; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.os.IBinder; import android.os.RemoteException; import android.util.Log; import java.util.ArrayList; import java.util.List; /** * 一个管理类，封装了客户端绑定服务端的一些方法 * 属于客户端部分，不过放在AIDL中便于多个客户端开发 * Created by jixiaoyong on 2018/8/6. * email:jixiaoyong1995@gmail.com */ public class PeopleManager { private static PeopleManager mPeopleManager; private Context mContext; private Listener mListener; private ManagerAidl managerAidl; private List<People> peopleList; //实现该回调方法，用于调用客户端的具体方法 //注意这里是new TaskCallBack.Stub()，而非new TaskCallBack(),否则服务器无法接收到callback //TaskCallBack.Stub()是TaskCallBack的子类，当跨进程通信时传递的是proxy类 private TaskCallBack callBack = new TaskCallBack.Stub() { @Override public void callBack(int size) throws RemoteException { mListener.onCallback(size); } @Override public void onPeopleChange(List<People> peoples) throws RemoteException { peopleList = peoples; mListener.onPeopleListChange(peoples); } }; private ServiceConnection serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { //在连接上服务端后，客户端从IBinder对象中获取到AIDL接口对象，并执行其方法 managerAidl = ManagerAidl.Stub.asInterface(service); try { peopleList = managerAidl.getPeopleList(); managerAidl.registerCallBack(callBack); } catch (RemoteException e) { e.printStackTrace(); } mListener.onCreate(mPeopleManager); } @Override public void onServiceDisconnected(ComponentName name) { try { managerAidl.unregisterCallBack(callBack); } catch (RemoteException e) { e.printStackTrace(); } } }; private PeopleManager(Context context,Listener listener) { mContext = context; mListener = listener; peopleList = new ArrayList<>(); Intent intent = new Intent(); intent.setComponent(new ComponentName(\\\"cf.android666.demo\\\", \\\"cf.android666.demo.MService\\\"));//Android5.0后必须显示的启动服务 context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE); } public static void init(Context context,Listener listener) { mPeopleManager = new PeopleManager( context, listener); } public void addPeople(People people) { try { managerAidl.addPeople(people); } catch (RemoteException e) { e.printStackTrace(); } } public List<People> getPeopleList() { return peopleList; } //子类可以实现该Listener的方法，在服务端调用这些方法时执行对应操作 public interface Listener { void onCreate(PeopleManager peopleManager);//服务连接成功 void onCallback(int size); void onPeopleListChange(List<People> peoples); } } \"]},\"36\":{\"h\":\"服务端\",\"t\":[\"注意MService在AndroidManife.xml中配置:\",\"android:exported=\\\"true\\\"android:enabled=\\\"true\\\"android:process=\\\":people\\\"\",\"//MService.java package cf.android666.demo; import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.os.RemoteCallbackList; import android.os.RemoteException; import android.support.annotation.Nullable; import android.text.InputFilter; import android.util.Log; import java.util.ArrayList; import java.util.List; import cf.android666.androidlib.ManagerAidl; import cf.android666.androidlib.People; import cf.android666.androidlib.TaskCallBack; /** * Created by jixiaoyong on 2018/8/6. * email:jixiaoyong1995@gmail.com */ public class MService extends Service implements ManagerAidl.Stub.DeathRecipient { private List<People> mPeopleList; private static RemoteCallbackList<TaskCallBack> callbackList = new RemoteCallbackList<>();; private TaskCallBack mCallBack; //使用AIDL接口生成mIBinder，在服务端实现接口各个方法，供客户端调用 private IBinder mIBinder = new ManagerAidl.Stub() { @Override public List<People> getPeopleList() throws RemoteException { return mPeopleList; } @Override public void addPeople(People people) throws RemoteException { mPeopleList.add(people); onPeopleChange(mPeopleList); } @Override public void registerCallBack(TaskCallBack callback) throws RemoteException { mCallBack = callback; Log.d(\\\"TAG\\\", \\\"registerCallBack注册回调方法 callback == null\\\" + callback); if (callback != null) {//注意这里一定要判断非空 callbackList.register(callback); } } @Override public void unregisterCallBack(TaskCallBack callback) throws RemoteException { if (callback != null) { callbackList.unregister(callback); } } }; @Nullable @Override public IBinder onBind(Intent intent) { Log.d(\\\"tag\\\", \\\"onBind MService开始了\\\" ); if (mPeopleList == null) { mPeopleList = new ArrayList<>(); } for (int i = 0; i < 20; i++) { mPeopleList.add(new People(\\\"people\\\" + i, i)); } return mIBinder;//返回开始用AIDL创建的IBinder } //实现DeathRecipient接口的方法，在客户端终止后自动调用该方法 @Override public void binderDied() { callbackList.unregister(mCallBack); } //这里时在服务端调用回调方法的写法，是从callbackList依次取出来执行 private void onPeopleChange(List<People> peoples) { if (callbackList == null) { return; } int len = callbackList.beginBroadcast(); try { for (int i = 0; i < len; i++) { callbackList.getBroadcastItem(i).onPeopleChange(peoples); } } catch (RemoteException e) { e.printStackTrace(); }finally { callbackList.finishBroadcast(); } } } \",\"注意：\",\"这里用来注册监听的类是RemoteCallbackList\",\"我们知道跨进程的两个listener是两个不同的对象，那他是怎么保证跨进程注册、注销的是指定的listener呢？\",\"这是因为虽然两个listener对象不同，但是他们底层的Binder对象是同一个，在RemoteCallbackList中有一个以Binder对象为KEY的map来存放这些listener对象，当要注销时，只需要按当前待注销的listener的Binder对象找到已经注册了的listener并删除掉即可。\",\"ArrayMap<IBinder, Callback> mCallbacks = new ArrayMap<IBinder, Callback>() \",\"此外，RemoteCallbackList可以在客户端死亡的时候自动注销掉对应的listener，这是因为他在注册的同时也对Binder的死亡就行了监听。\",\"public boolean register(E callback, Object cookie) { synchronized (mCallbacks) { if (mKilled) { return false; } // Flag unusual case that could be caused by a leak. b/36778087 logExcessiveCallbacks(); IBinder binder = callback.asBinder(); try { Callback cb = new Callback(callback, cookie); binder.linkToDeath(cb, 0);//监听binder的死亡事件 mCallbacks.put(binder, cb); return true; } catch (RemoteException e) { return false; } } } ... //当binder死亡时，会主动移除其注册的listener public void binderDied() { synchronized (mCallbacks) { mCallbacks.remove(mCallback.asBinder()); } onCallbackDied(mCallback, mCookie); } \",\"方法运行的线程\",\"如果客户端和服务端运行在同一进程：客户端调用服务端和服务端回调客户端方法（RemoteCallbackList，下同）都会运行在同一线程，即客户端调用服务端时所在的线程，默认为主线程\",\"如果客户端和服务端运行在不同进程：客户端调用服务端方法，客户端会被挂起，直到服务端方法在Binder线程池中运行完毕,这种情况下服务端可以执行耗时操作而无需另建线程；服务端回调客户端方法运行在客户端主线程(与客户端调用服务端方法在同一线程)\",\"通过上述分析，可以注意到一个细节：虽然在服务端中回调客户端的方法是在服务端的Binder线程，但是在客户端中被回调的方法却是和客户端中主动调用服务端方法的线程一致。\"]},\"37\":{\"h\":\"客户端\",\"t\":[\"PeopleManager.init(this, this); \",\"//服务连接成功后，可以开始调用服务的一系列方法 @Override public void onCreate(PeopleManager peopleManager) { mPeopleManager = peopleManager; peopleList = peopleManager.getPeopleList(); for (int i = 0; i < peopleList.size(); i++) { Log.d(\\\"tag\\\", \\\"people list is \\\" + peopleList.get(i)); } } //其他回调方法，等服务端回调时会执行对应方法 @Override public void onPeopleListChange(List<People> peoples) { Log.d(\\\"TAG\\\", \\\"demo2 people变化了\\\" + peoples.size()); } \"]},\"38\":{\"h\":\"监听并处理Binder死亡事件\",\"t\":[\"当服务端进程意外死亡时，我们可以选择重新连接服务，一般有两种方式：\",\"binderDied 在客户端的Binder线程池中\",\"onServiceDisconnected 在客户端UI线程\"]},\"39\":{\"h\":\"AIDL的权限验证\",\"t\":[\"可以在服务的onBind(Intent intent)或者onTransact()方法中做验证\",\"做验证的手段有：1.permission验证；2.Uid，Pid等做验证\",\"《Android开发艺术探索》\"]},\"40\":{\"h\":\"Android中AIDL相关知识\",\"t\":[\"AIDL是Android中用于IPC的语言，具体使用可以参见这篇文章，这篇文章主要想总结一下AIDL具体为我们做了什么工作，主要参考书目《Android开发艺术探索》。\",\"在Android中，除了Socket、Intent中使用Bundle、本地文件共享，ContentProvider等等之外，还有一个独有的IPC方式即Binder。在日常编程中使用Binder的主要有AIDL和Messenger两种方式，而Messenger也是用AIDL来实现的。\",\"新建一个AIDL文件\",\"// IBookManager.aidl package cf.android666.myapplication; interface IBookManager { void getSth(); } \",\"用AndroidStudio自动生成一个Binder类\",\"使用Build->Make Project，会在app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out目录下生成IBookManager.java。\",\"AIDL从客户端(Client)发起请求至服务端(Server)相应的工作流程概览，图片来源(https://blog.csdn.net/qian520ao/article/details/78074983)\",\"AIDL从客户端(Client)发起请求至服务端(Server)的流程\",\"下面我们对IBookManager.java这个文件简单分析一下\",\"/* * This file is auto-generated. DO NOT MODIFY. * Original file: app/src/main/aidl/cf/android666/myapplication/IBookManager.aidl */ package cf.android666.myapplication; public interface IBookManager extends android.os.IInterface//IInterface接口，所有可以在Binder中传输的接口都要继承自该接口 { /** * Local-side IPC implementation stub class. * 持有Binder对象 * 获取客户端传过来的数据，根据方法 ID 执行相应操作。 * 将传过来的数据取出来，调用本地写好的对应方法。 * 将需要回传的数据写入 reply 流，传回客户端。 */ public static abstract class Stub extends android.os.Binder implements cf.android666.myapplication.IBookManager { private static final java.lang.String DESCRIPTOR = \\\"cf.android666.myapplication.IBookManager\\\";//是Binder的唯一标识，一般为当前Binder的类目 /** * Construct the stub at attach it to the interface. */ public Stub() { this.attachInterface(this, DESCRIPTOR);//将Binder和指定的接口绑定，这样当queryLocalInterface时会返回与DESCRIPTOR一致的IInterface } /** * Cast an IBinder object into an cf.android666.myapplication.IBookManager interface, * generating a proxy if needed. * 将服务端的Binder转化为客户端需要的IInterface * 如果是相同的进程，则直接返回服务端的Stub对象本身（没有跨进程）； * 如果是不同的进程，则返回的是Stub.Proxy代理类对象 */ public static cf.android666.myapplication.IBookManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) && (iin instanceof cf.android666.myapplication.IBookManager))) { return ((cf.android666.myapplication.IBookManager) iin); } return new cf.android666.myapplication.IBookManager.Stub.Proxy(obj); } @Override public android.os.IBinder asBinder() { return this; } /** * 客户端远程请求经过系统封装后调用该方法， * 生成 _data 和 _reply 数据流，并向 _data 中存入客户端的数据。 * 通过 transact() 方法将它们传递给服务端，并请求服务端调用指定方法。 * 接收 _reply 数据流，并从中取出服务端传回来的数据 */ @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { java.lang.String descriptor = DESCRIPTOR; switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getSth: { data.enforceInterface(descriptor);//从data中可以读取参数 this.getSth();//注意，这里调用的是IBookManager的getSth()，也就是需要我们在使用该Binder时实现的方法 reply.writeNoException();//可以往reply中写入结果 return true; } default: { return super.onTransact(code, data, reply, flags); } } } /** * Proxy类持有IBinder的引用 * */ private static class Proxy implements cf.android666.myapplication.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public void getSth() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getSth, _data, _reply, 0);//这里实际上是调用了远程的IBinder的transact()方法 _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } } } static final int TRANSACTION_getSth = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);//这个是我们在AIDL中定义的getSth()方法的标志，用于在onTransact中区分调用的是哪个方法 } public void getSth() throws android.os.RemoteException;//这个是我们在AIDL中定义的方法,需要在服务端实现，并且会在客户端被调用 } \",\"Android 深入浅出AIDL（二）\",\"Android Binder之应用层总结与分析\"]},\"41\":{\"h\":\"Android中View相关知识\",\"t\":[\"本文为笔记性质，尚未成文。\",\"Android中的坐标，以屏幕左上角顶点为原点(0,0)，以横轴为x轴，竖轴为y轴，数值依次递增。\",\"View的坐标信息有以下几种，其坐标都是以父View的左上角顶点为原点：\",\"x，y 是View的左上角坐标。\",\"translationX，translationY是View左上角顶点与父容器左上角顶点的偏移量，默认为0。\",\"left，top 是分别是View左上角顶点的x轴，y轴坐标。\",\"right，bottom分别是View右下角顶点的x轴，y轴坐标。\",\"注意\",\"x = translationX + left；\",\"y = translationY + top；\",\"改变translationX/Y的值便可以更改View的位置。当View平移的时候，代表原始位置信息的left，right，top，bottom的值并不会变化。\",\"在OnTouch事件中，我们可以从event得到两种值：\",\"event.rawX,event.rawY 代表 相对于手机屏幕原点的坐标\",\"event.X,event.Y 代表 相对于当前View左上角的坐标\",\"TouchSlop则代表认为滑动开始的最小距离\",\"ViewConfiguration.get(this).scaledTouchSlop \",\"mScroller.startScroll()方法可以实现平滑的滑动\",\"scrollX,scrollY表示的是view的X，Y坐标减去view内容的X，Y坐标。\",\"所以scrollX>0，则表示view内容向左移动，scrollX<0表示view内容向右移动。类似于窗户(view)位置不变，景色(view内容)的scrollX>0即景色向右移动，则在窗户中看到的效果是景色向窗户左边移动。\",\"private val mScroller = Scroller(context) fun smoothScrollBy(destX: Int, destY: Int) { mScroller.startScroll(scrollX, scrollY, destX, destY, 1000)//destX, destY的值如果是正的话，会向左，上方移动 invalidate() } override fun computeScroll() { if (mScroller.computeScrollOffset()) { scrollTo(mScroller.currX, mScroller.currY) postInvalidate() } } \",\"Scroller不能使View滑动，而只能配合View的computeScroll()方法实现是View的内容滑动的效果。\",\"mScroller.startScroll()记录下要滑动的数据，而invalidate()通知View重绘；\",\"每次重绘都会调用computeScroll()方法，利用mScroller计算出接下来要scrollTo()的具体值并执行，再次postInvalidate()通知View重绘；\",\"如此反复直到绘制滑动完毕。\",\"上述无论是translationX还是scrollX等引起的view变化，都不能改变View的定位（left，right，top，bottom值），而如果更改margin的值，则可以更改View的定位。\",\"WindowManager.LayoutParams.flags有三个常用选项：\",\"WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL // 只处理Window区域内的点击事件，之外的交给其他Window处理\",\"WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE // 不接受输入事件，不获取焦点，同时会开启FLAG_NOT_TOUCH_MODAL，最终事件会传递给下层具有焦点的Window\",\"WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED // 让Window显示在锁屏界面上\",\"WindowManager.LayoutParams.type代表Window的类型(三个)：\",\"应用Window 对应一个Activity。z-ordered:1~99\",\"子Window 不能单独存在，附属在特定的父Window中，如Dialog。z-ordered:1000~1999\",\"系统Window 需要系统权限，如Toast，状态栏等。z-ordered:2000~2999\",\"z-ordered值大的Window会覆盖掉低值的Window。\",\"recycleview滑动 ItemTouchHelper源码分析 https://www.jianshu.com/p/130fdd755471 嵌套滑动 https://blog.csdn.net/qq_15807167/article/details/51637678https://www.cnblogs.com/dasusu/p/9159904.html滑动展示删除按钮https://www.jianshu.com/p/9bfed6e127cc >> 对应的demo：https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt\",\"View滑动效果常用属性详解：scroll、translation、LayoutParams\"]},\"42\":{\"h\":\"Android中WebView使用的一些问题\",\"t\":[\"解决代码如下：\",\"//kotlin 代码 webView.webViewClient = object : WebViewClient() { override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean { view!!.loadUrl(url) return true } } \",\"此代码同样强制在webview中打开对应的网页\"]},\"43\":{\"h\":\"Android中的Messenger源码详解\",\"t\":[\"Messenger是Android中用于IPC的方式之一，使用Handler发送有序消息队列，底层是通过AIDL调用Binder实现。\",\"Messenger只用于服务端和客户端串行的传递消息，如果大量并发或者跨进程调用服务端的方法，就需要考虑AIDL而非Messenger。\",\"Messenger的使用可以参考这篇文章,本文主要探索一下Messenger源码实现。\",\"主要使用到的文件：\",\"IMessenger.aidl\",\"Messenger.java\",\"Handler.java\",\"一个典型的Messenger服务如下所示：\",\"class MessengerService : Service() { private val messenger = Messenger(MessengerHandler()) override fun onBind(intent: Intent?): IBinder? { return messenger.binder } //可以从客户端的得到的Messenger中取出该Handler，并实现客户端->服务端通信 class MessengerHandler : Handler() { override fun handleMessage(msg: Message?) { super.handleMessage(msg) //客户端的Messenger，用于服务端->客户端通信,可选 val client = msg?.replyTo client?.send(Message.obtain(null, 2, 1, 2)) } } } \",\"我们可以看到使用Handler创建一个Messenger，进入到源码看一下：\",\"private final IMessenger mTarget; public Messenger(Handler target) { mTarget = target.getIMessenger(); } \",\"我们看到，在这里创建了一个新的与给定的Handler绑定在一起的Messenger，再看看getIMessenger()方法：\",\"final IMessenger getIMessenger() { synchronized (mQueue) { if (mMessenger != null) { return mMessenger; } mMessenger = new MessengerImpl(); return mMessenger; } } private final class MessengerImpl extends IMessenger.Stub { public void send(Message msg) { msg.sendingUid = Binder.getCallingUid(); Handler.this.sendMessage(msg);//使用Handler发送消息 } } \",\"这里我们可以看到getIMessenger()方法会创建一个MessengerImpl对象，而这个对象\",\"实现了send()方法，也证实了我们之前的一个观点——Messenger底层是使用Handler发送消息。\",\"同时，看到MessengerImpl继承的IMessenger.Stub类我们可以联想到这里应该有一个AIDL实现：\",\"// /frameworks/base/core/java/android/os/IMessenger.aidl package android.os; import android.os.Message; /** @hide */ oneway interface IMessenger { void send(in Message msg); } \",\"oneway 关键字用于修改远程调用的行为。使用该关键字时，远程调用不会阻塞；它只是发送事务数据并立即返回。接口的实现最终接收此调用时，是以正常远程调用形式将其作为来自 Binder 线程池的常规调用进行接收。 如果 oneway 用于本地调用，则不会有任何影响，调用仍是同步调用\",\"https://developer.android.google.cn/guide/components/aidl?hl=zh-cn\",\"这也就解释了在服务的onBind(intent: Intent?)方法中，我们可以直接使用messenger.binder获取到Binder对象的原因。\",\"再看看Messenger客户端的实现：\",\"private lateinit var messenger: Messenger//服务端的Messenger private val replyMessenger: Messenger = Messenger(ReplyHandler())//客户端的Messenger，用于服务端->客户端通信，可选 private val mServiceConnection = object : ServiceConnection { override fun onServiceDisconnected(name: ComponentName?) { } override fun onServiceConnected(name: ComponentName?, service: IBinder?) { messenger = Messenger(service)//注意这里的构造方法传入的是IBinder对象 val message = Message.obtain(null, 1) message.replyTo = replyMessenger val data = Bundle() data.putString(\\\"msg\\\", \\\"Hello World\\\") try { messenger.send(message)//使用服务端的Messenger向服务端发送消息 } catch (e: Exception) { e.printStackTrace() } } } \",\"可以注意到在客户端通过Messenger(IBinder target)取得服务端的Messenger，而这里的IBinder对象则是通过服务端的Messenger的getBinder()获取的：\",\"public Messenger(IBinder target) { mTarget = IMessenger.Stub.asInterface(target); } \",\"Stub.asInterface()方法我们在之前的文章中介绍过，他会根据客户端和服务端是否在同一进程而决定返回Stub实例还是Proxy类实例以实现跨进程通信。\",\"而通过比较 Messenger(IBinder target)和Messenger(Handler target)两个构造方法我们也可以知道，两个方法都只是用来初始化了IMessenger mTarget对象，这也就解释了在服务端和客户端可以通过两个不同的构造方法获取到有同样功能的Messenger。\",\"《Android开发艺术探索》\",\"Android 接口定义语言 (AIDL)\"]},\"44\":{\"h\":\"Android中的SpareArray和ArrayMap实现分析\",\"t\":[\"日常开发中，常用的存储键值对的数据结构是HashMap，根据Java笔记之HashMap保存数据和Java笔记之计算Java对象的大小及其应用可以知道，HashMap存储键值对会占用比较多的内存控件，而对于内存限制较大的Android平台来说，为了避免这种浪费，官方推荐我们使用SpareArray和ArrayMap，本文对这两个类的实现进行分析比较。\",\"SpareArray以及他的衍生类都是以基本类型为key，因为避免了自动装箱，并且用数组直接保存key、value（而非像HashMap那样将其封装为Node对象后再保存），因而节省了内存。\",\"ArrayMap则支持所有类型的key，他是将key和value全部保存在一个数组中（n位为key，n+1位为value），避免了将其封装为Node对象带来的内存消耗。\",\"当要保存的数据量比较小（小于几千个）的时候，如果KEY是基本类型，推荐使用SparseArray及其衍生类以节省内存，如果KEY是其他类型则使用ArrayMap;否则使用HashMap更加高效。\",\"SpareArray以及他的衍生类主要用于以基本类型为key保存非大量数据的场景。\",\"相比HashMap而言，他的优点主要在于没有对保存的数据二次封装，没有对基本类型的数据自动装箱，存储单个数据的成本小，也没有hash计算。\",\"但他在添加数据时需要扩展数组(涉及到新建、复制数组，gc()等)，在删除数据时需要缩减数组 (查看gc()等源码发现他的数组只会增加，不会缩减)，以及通过二分法查找索引都会消耗性能。\",\"为了避免每次删除时都需要缩减数组，SpareArray在删除数组时只会将其赋值为DELETED，在下次调用其private void gc()方法时丢弃掉这些数据\",\"先看一下SpareArray的结构：\",\"public class SparseArray<E> implements Cloneable { private boolean mGarbage = false; //是否调用gc()方法 private int[] mKeys;//所有的key private Object[] mValues;//所有的value private int mSize;//所保存的数据个数 } \"]},\"45\":{\"h\":\"void put(int key, E value)\",\"t\":[\"添加方法先用二分法查找key对应的位置：\",\"如果有，则直接覆盖\",\"如果没有，则取反得到应该插入的位置，并分别插入key和value\",\"public void put(int key, E value) { // 先用二分法查找key对应的索引,找到的话返回对应索引， // 否则返回key应该插入的位置的取反值 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i >= 0) { // 如果已存在值则直接覆盖 mValues[i] = value; } else { // 对二分法查找到的值再取反，得到key应该插入的位置 i = ~i; if (i < mSize && mValues[i] == DELETED) { mKeys[i] = key; mValues[i] = value; return; } if (mGarbage && mSize >= mKeys.length) { gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); } // public static <T> T[] insert(T[] array, int currentSize, int index, T element) // Inserts an element into the array at the specified index, // growing the array if there is no more room. mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; } } \"]},\"46\":{\"h\":\"E get(int key)\",\"t\":[\"获取数据，先用二分法查找，如果找到就返回对应的值，否则返回null。\",\"public E get(int key) { return get(key, null); } public E get(int key, E valueIfKeyNotFound) { int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i < 0 || mValues[i] == DELETED) { return valueIfKeyNotFound; } else { return (E) mValues[i]; } } \"]},\"47\":{\"h\":\"void remove(int key)\",\"t\":[\"删除key以及对应的数据。\",\"同样先用二分法查找对应位置，有的话则标记为DELETED，等待下次gc()时丢弃。\",\"public void remove(int key) { delete(key); } public void delete(int key) { int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i >= 0) { if (mValues[i] != DELETED) { mValues[i] = DELETED; mGarbage = true; } } } \"]},\"48\":{\"h\":\"gc()\",\"t\":[\"在上文中我们看到，删除数据时，mGarbage被标记为true，这样当下一次进行put/valueAt/append/size等涉及到数组大小查询、改动等时，就出触发gc()以便整理数组结构。\",\"private void gc() { // Log.e(\\\"SparseArray\\\", \\\"gc start with \\\" + mSize); int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i < n; i++) { Object val = values[i]; // 这里的操作只是将没有被删除的数据移动到了数组的前面 // 而保证了数组后面都是DELETED或null，方便后续操作 if (val != DELETED) { if (i != o) { keys[o] = keys[i]; values[o] = val; values[i] = null; } o++; } } mGarbage = false; mSize = o; } \"]},\"49\":{\"h\":\"HashMap与SpareArray及其衍生类对应关系\",\"t\":[\"参考下图\",\"ArrayMap实现了Map<K, V>接口，他的API和HashMap相差无几，但是由于没有对数据再包装，动态调整数组的大小，一定范围内他比HashMap内存效率高。\",\"但是如果保存大量数据（超过千位）时，由于他需要二分法查找的影响会比HashMap慢很多。\",\"ArrayMap特殊之处在于将key，value保存到了同一个数组mArray中（n位保存key，n+1位保存value）。\",\"先看一下ArrayMap的结构：\",\"static Object[] mBaseCache; static int mBaseCacheSize; static Object[] mTwiceBaseCache; static int mTwiceBaseCacheSize; final boolean mIdentityHashCode;//是否强制使用System.identityHashCode(key)获取key的HashCode //System.identityHashCode(key)方法无论类是否重写了hashCode()方法， //都会调用Object.identityHashCode(key)来获取对象的hashCode int[] mHashes;//存储所有key的hash值 Object[] mArray;//存储key和value，大小是mHashes的两倍 //n位保存key，n+1位保存value int mSize; MapCollections<K, V> mCollections; \",\"在使用时：\",\"计算key的hash值，\",\"hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode(); \",\"然后使用indexOf()在mHashes中进行二分法查找对应的index\",\"index = indexOf(key, hash); \",\"indexOf()方法会先用二分法查找hash对应的index,如果index<0则返回index；否则在对比mArray中对应位置mArray[index<<1]的key与要查询的key：\",\"两者一致：返回index\",\"两者不一致：从index开始，先向后，再向前查询是否有相同的key,如果有返回对应index\",\"以上都没有找到：对mHashes中最后一个与key的hash一致的后一位index取反，并返回\",\"int indexOf(Object key, int hash) { final int N = mSize; // Important fast case: if nothing is in here, nothing to look for. if (N == 0) { return ~0; } int index = binarySearchHashes(mHashes, N, hash); // If the hash code wasn't found, then we have no entry for this key. if (index < 0) { return index; } // If the key at the returned index matches, that's what we want. if (key.equals(mArray[index<<1])) { return index; } // Search for a matching key after the index. int end; for (end = index + 1; end < N && mHashes[end] == hash; end++) { if (key.equals(mArray[end << 1])) return end; } // Search for a matching key before the index. for (int i = index - 1; i >= 0 && mHashes[i] == hash; i--) { if (key.equals(mArray[i << 1])) return i; } // Key not found -- return negative value indicating where a // new entry for this key should go. We use the end of the // hash chain to reduce the number of array entries that will // need to be copied when inserting. return ~end; } \"]},\"50\":{\"h\":\"V put(K key, V value)\",\"t\":[\"当添加item时，按照前述规则，先在mArray中查找key对应的索引index：\",\"index >= 0 ：已经有键为key的数据，直接覆盖旧值并返回\",\"index < 0 ：没有键为key的数据，对数组进行扩容，并保存对应数据\",\"index = ~index;//上文indexOf()中计算得出的key应该添加的位置 mHashes[index] = hash; mArray[index<<1] = key; mArray[(index<<1)+1] = value; \"]},\"51\":{\"h\":\"V get(Object key)\",\"t\":[\"get()方法就比较简单了，先查找key的索引，然后取出对应的数据value并返回即可：\",\" public V get(Object key) { final int index = indexOfKey(key); return index >= 0 ? (V)mArray[(index<<1)+1] : null; } \"]},\"52\":{\"h\":\"V remove(Object key)\",\"t\":[\"remove()方法也会先使用indexOfKey()计算key的index，然后删除对应位置的数据。\",\"此外，如果mHashes.length > (BASE_SIZE*2) && mSize < mHashes.length/3的话，还会缩减数组的大小为osize > (BASE_SIZE*2) ? (osize + (osize>>1)) : (BASE_SIZE*2)：\",\"public V removeAt(int index) { //...其他代码 if(mHashes.length > (BASE_SIZE*2) && mSize < mHashes.length/3){ //...其他代码 final int n = osize > (BASE_SIZE*2) ? (osize + (osize>>1)) : (BASE_SIZE*2); allocArrays(n); } //...其他代码 } private void allocArrays(final int size) { //...其他代码 mHashes = new int[size]; mArray = new Object[size<<1]; } \",\"GrowingArrayUtils.java 源码\",\"SparseArray.java 源码\",\"ArrayMap.java 源码\",\"App optimization with ArrayMap & SparseArray in Android\",\"Java笔记之HashMap保存数据\",\"Java笔记之计算Java对象的大小及其应用\",\"SparseArray 的使用及实现原理\"]},\"53\":{\"h\":\"Android今日头条屏幕适配方案的原理梳理\",\"t\":[\"最近在项目里面遇到了屏幕适配的问题，UI要求APP在不同手机上展示效果和设计稿保持“像素级”同步，在对比了几种屏幕适配方案之后，选择了基于今日头条的AndroidAutoSize适配方案。\",\"本文主要简单分析其适配原理，以及在实际使用中遇到的一个问题，需要更深入了解原理可以阅读文末参考文献。\",\"UI给的设计稿一般都是以像素px为单位，而在Android开发中官方推荐的使用的单位是dp。\",\"dp 是一个虚拟像素单位，1 dp 约等于中密度屏幕（160dpi；“基准”密度）上的 1 像素。对于其他每个密度，Android 会将此值转换为相应的实际像素数。\",\"—— Android Developer\",\"根据Android官方的定义，dp在屏幕上实际对应的像素px计算方式如下：\",\"px = dp * (dpi / 160) \",\"其中 dpi表示：屏幕每平方英寸有多少像素，可以通过屏幕对角线的像素数px/屏幕尺寸inch计算。\",\"而DisplayMetrics.density 字段表示根据当前像素密度指定将 dp 单位转换为像素时所必须使用的缩放系数，即上述方程等价于：\",\"px = dp * (dpi / 160) = dp * getResources().getDisplayMetrics().density \",\"这样，在dpi为160的屏幕上1dp占1px，在dpi为320的屏幕上占2px，那么就能保证同一dp的在不同dpi上占得像素是等比例变化的。\",\"但是，在现实生活中面对千变万化的Android屏幕，根据Jessyan的文章可知由于每种屏幕宽/高对应的总dp数不一定都是相同的，所以即使使用了dp作为单位，还是会出现同一dp在有些屏幕上刚好占满全屏，在有的屏幕上会无法占满全屏或超出屏幕范围。\",\"density 在每个设备上都是固定的，DPI / 160 = density，屏幕的总 px 宽度 / density = 屏幕的总 dp 宽度\",\"设备 1，屏幕宽度为 1080px，480DPI，屏幕总 dp 宽度为 1080 / (480 / 160) = 360dp\",\"设备 2，屏幕宽度为 1440px，560DPI，屏幕总 dp 宽度为 1440 / (560 / 160) = 411dp\",\"——Jessyan\",\"那么该怎么适配呢，再看一眼上述的公式：\",\"屏幕的总 px 宽度 / density = 屏幕的总 dp 宽度 \",\"以适配屏幕宽度为例，要使得dp在不同屏幕上对应的像素等比例变化，就要保证屏幕的总dp宽度一致，而屏幕的总 px 宽度是物理条件无法更改，那么就只能更改density。\",\"以我们使用的设计稿宽度为375dp为例：\",\"在分辨率为2160*1080 、尺寸为5.99英寸的屏幕上：\",\"density = 1080px / 375dp = 2.88 \",\"而在分辨率为2400*1176、尺寸为6.53英寸的屏幕上：\",\"density = 1176px / 375dp = 3.136 \",\"这样就保证了，不管在什么样的屏幕上，375dp始终都能够占满屏幕宽度，保证了布局在不同大小的屏幕上，在屏幕宽度上的比例一致性，也就解决屏幕适配的问题。\",\"上述的屏幕适配方案使用简单，且侵入小，在使用到项目中之后，除了部分字体等显示需要微调外，其余内容基本上都完美还原了设计稿的内容。\",\"但是在后续使用到状态栏相关代码的时候发现获取到的状态栏高度和实际高度不一致，导致显示异常，而使用Blankj的工具类 BarUtils.getStatusBarHeight()却可以获取到正确的高度。\",\"对比两种代码发现获取状态栏高度的代码逻辑几乎一样：\",\"public static int getStatusBarHeight(Resources resources) { int resourceId = resources.getIdentifier(\\\"status_bar_height\\\", \\\"dimen\\\", \\\"android\\\"); return resources.getDimensionPixelSize(resourceId); } \",\"不同的是，两种方法使用到的resources一个是APP的，一个是系统的\",\"// 1. 我使用到的resources，从当前activity获取 resources.displayMetrics.density // 2. Blankj使用的resources，从系统获取 Resources.getSystem().displayMetrics.density \",\"通过分别打印这两种resources可以发现，二者的density值不一样（以2160*1080 、尺寸为5.99英寸的屏幕为例）：\",\"context.resources.DisplayMetrics: DisplayMetrics{density=2.88, width=1080, height=2033, scaledDensity=2.88, xdpi=403.411, ydpi=403.411} Resources.getSystem().DisplayMetrics: DisplayMetrics{density=2.7, width=1080, height=2033, scaledDensity=2.7, xdpi=403.411, ydpi=403.411} \",\"这是由于使用了AndroidAutoSize适配方案后，APP内部的density已经被改成了2.88，而系统实际的density是2.7。\",\"又知道android中将像素和dp等单位转化的方法如下：\",\"// android.util.TypedValue public static float applyDimension(int unit, float value, DisplayMetrics metrics) { switch (unit) { case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); } return 0; } \",\"分析可知，通过getStatusBarHeight()获取到的状态栏是系统的状态栏69px（即25dp），但当使用APP内部的density=2.88计算时就会只有24dp，和实际的状态栏高度不一致，所以使用状态栏高度来控制布局的时候就会展示异常。\",\"骚年你的屏幕适配方式该升级了!-今日头条适配方案——jessyan\",\"一种极低成本的Android屏幕适配方式——字节跳动\",\"支持不同的像素密度——Android Developers\",\"Android 目前稳定高效的UI适配方案——拉丁吴\",\"AndroidAutoSize\",\"请问两种获取屏幕密度的方式有什么区别，望解答多谢\"]},\"54\":{\"h\":\"Android多渠道打包知识\",\"t\":[\"国内 Android 应用常常要分发到多个应用商店，使用 Android Studio 正确配置 build.gradle 与 AndroidManifest.xml 文件可以一步打包多个渠道。\",\"本文实现的多渠道打包可实现不同渠道：\",\"有不同的项目 id（applicationId）\",\"不同 App 名称（android:label）\",\"不同 App 图标（android:icon）\",\"等等\",\"*具体配置请参考 UMeng 官方文档。\",\"作为第三方统计平台，国内很多软件都使用的是 Umeng 的产品，故而大多数软件多渠道打包配置如下：\",\"添加依赖\",\"../app/build.gradle dependencies { //友盟sdk compile 'com.umeng.sdk:common:latest.integration' compile 'com.umeng.sdk:analytics:latest.integration' ...} \",\"修改 AndroidManifest.xml\",\"<application> ... <!--友盟初始化appkey和channel--> <meta-data android:value=\\\"${APP_KEY}\\\" android:name=\\\"UMENG_APPKEY\\\"/> <meta-data android:name=\\\"UMENG_CHANNEL\\\" android:value=\\\"${UMENG_CHANNEL_VALUE}\\\" /> </application> \",\"修改 build.gradle\",\"android { productFlavors { beta {} baidu {} zhushou91 {} //不能以数字开头 anzhi {} } productFlavors.all { flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name ,APP_KEY:umenInfo['APP_KEY']] //这里有一个知识点，用build.gradle读取properties文件信息，用于将部分信息统一放置在本地配置文件中，避免泄漏，若无此类要求可直接使用 APP_KEY:'da15d26d1a'等 } //解决flavor Dimensions问题 http://blog.csdn.net/syif88/article/details/75009663 flavorDimensions \\\"versionCode\\\" } //其他umeng要求的配置 \",\"这样编译完之后，通过通过 build>Generate Signed APK...便可以打包不同渠道的 apk，在友盟统计平台上统计各个渠道的 App 信息了。\",\"方法 1 要求依赖 umeng 模块，使用场景难免有些受限，其实我们也可以自己实现多渠道打包，方法 1 使用的应该也是此原理。\",\"AndroidManifest.xml\",\"在需要根据渠道不同而变化的地方使用${KEY}形式替换掉原先的值。\",\"例如：\",\"<application android:label=\\\"${APP_NAME}\\\" ...> <meta-data android:name=\\\"APP_TEXT\\\" android:value=\\\"${APP_TEXT}\\\"/>//可以在java文件中获取到 \",\"app/build.gradle\",\" productFlavors { beta {applicationId = \\\"cf.android666.mykotlin.beta\\\"//每个渠道有不同的包名 manifestPlaceholders = [APP_NAME : name ,APP_TEXT:'beta'] } baidu {applicationId = \\\"cf.android666.mykotlin.baidu\\\" manifestPlaceholders = [APP_NAME:'A APP',APP_TEXT:'baidu'] } } \",\"在 java 中获取meta-data（非必须）\",\"《Android 获取 Manifest 中<meta-data>元素的值》 - CSDN 博客 https://blog.csdn.net/zhang31jian/article/details/29868235\",\"//application中的meta-data var appInfo = context.packageManager.getApplicationInfo(context.packageName, PackageManager.GET_META_DATA) //service、receiver中的meta-data var appInfo = context.packageManager.getServiceInfo(ComponentName(context,MService::class.java), PackageManager.GET_META_DATA) var appName = appInfo.metaData.getString(\\\"APP_NAME\\\") \",\"还有一种方法，通过在项目中生成多个渠道的文件夹，在里面替换对应的资源文件，从而实现多渠道打包不同项目名，不同 icon 等等\",\"在../app/src/目录下新建对应渠道文件夹，和 main 同级\",\"在该渠道目录下新建对应的资源目录，在打包时自动替换对应资源\",\"​\",\"目录树如下\",\"src --baidu ----res/drawable --beta --main ----res/drawable \",\"此外还有美团的多渠道打包技术等\",\"具体可参考文章：美团 Android 自动化之旅—生成渠道包\"]},\"55\":{\"h\":\"Android实现可折叠toolbar\",\"t\":[\"使用到的类有：\",\"android.support.design.widget.CoordinatorLayout\",\"android.support.design.widget.AppBarLayout\",\"android.support.design.widget.CollapsingToolbarLayout\",\"android.support.v7.widget.Toolbar\",\"如图：\",\"CoordinatorLayout类，协调者布局，通过Behavior将一个子view（child）的行为和另一个子view（dependency）的活动联结起来，从而实现子view之间的联动。\",\"AppBarLayout类，是一个实现了材料设计的默认垂直布局的ViewGroup，当其是CoordinatorLayout类的直接子view时,另外一个CoordinatorLayout的子view指定了behavior为AppBarLayout.ScrollingViewBehavior的实例（app:layout_behavior=\\\"@string/appbar_scrolling_view_behavior\\\"）,且该子view需要是NestedScrollingChild的实现类。\",\"CollapsingToolbarLayout类，提供一个可以折叠的toolbar布局，可以在这个布局里面，设置toolbar以及和toolbar一起联动的子view，本案例中是一张图片。\",\"Toolbar类，实现toolbar的效果。\",\"源码：github\",\"<android.support.design.widget.CoordinatorLayout> <android.support.design.widget.AppBarLayout> <android.support.design.widget.CollapsingToolbarLayout app:layout_scrollFlags=\\\"scroll|exitUntilCollapsed\\\"> <ImageView app:layout_collapseMode=\\\"parallax\\\" /> <android.support.v7.widget.Toolbar app:layout_collapseMode=\\\"pin\\\" /> </android.support.design.widget.CollapsingToolbarLayout> </android.support.design.widget.AppBarLayout> <android.support.v4.view.ViewPager app:layout_behavior=\\\"@string/appbar_scrolling_view_behavior\\\" /> </android.support.design.widget.CoordinatorLayout> \",\"CoordinatorLayout在最外层，注意其直接子view必须就是要实现联动的view，否则联动失效。\",\"CollapsingToolbarLayout必须设置layout_scrollFlags，其余属性可选。\",\"layout_scrollFlags说明如下：\",\"scroll：所有想滚动出屏幕的view都需要设置这个flag， 没有设置这个flag的view将被固定在屏幕顶部。\",\"enterAlways：这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。\",\"enterAlwaysCollapsed：假设你定义了一个最小高度（minHeight）同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。\",\"exitUntilCollapsed：当你定义了一个minHeight，此布局将在滚动到达这个最小高度的时候折叠。\",\"snap：当一个滚动事件结束，如果视图是部分可见的，那么它将被滚动到收缩或展开。例如，如果视图只有底部25%显示，它将折叠。相反，如果它的底部75%可见，那么它将完全展开。\",\"作者：尹star\",\"链接：https://www.jianshu.com/p/5287d090e777\",\"CollapsingToolbarLayout的子view需要指定layout_collapseMode，还有一点需注意：和toolbar联动的子view高度需大于toolbar高度，否则无效果。\",\"ViewPager就是本案例中触发子view联动效果的dependency，需要指定其behavior：\",\"app:layout_behavior=\\\"@string/appbar_scrolling_view_behavior\\\" \",\"其实际对应于android.support.design.widget.AppBarLayout$ScrollingViewBehavior ，这个是系统实现的一个behavior，用于和嵌套滑动事件绑定，指定该behavior的子view需要是NestedScrollingChild的实现类（系统提供了4个实现类：NavigationMenuView、NestedScrollView、RecyclerView、SwipleRefreshLayout），所以viewPager中页面有上述4个类或其子类时，才能实现绑定效果。\",\"自定义Behavior\",\"自定义Behavior有两个目的：\",\"将两个或多个子view绑定；\",\"将一个子view与另一个子view的滑动事件绑定在一起\",\"两者的差异在于在实现CoordinatorLayout.Behavior<T> 类时候具体重写的方法不一样。\",\"目的1：需要重写的方法有：\",\"@Override public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) { //如果dependency是要依赖的子view（此处是TempView类）的实例，说明它就是我们所需要的Dependency return dependency instanceof TempView; } //每次dependency位置发生变化，都会执行onDependentViewChanged方法 @Override public boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) { //根据dependency的位置，设置child的位置,对child进行想要实现的变化 return true;//返回true表示改变了child 的尺寸和位置参数，否则返回false } \",\"目的2：需要重写的方法有：\",\"//判断是否要开始根据dependency子view的行为改变child的状态 @Override public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull ImageView child,@NonNull View directTargetChild, @NonNull View target, int axes, int type) { return child instanceof ImageView && axes == View.SCROLL_AXIS_VERTICAL;//子view是ImageView，并且滑动的方向是垂直的 } //当dependency子view滑动时，对child进行相应处理 @Override public void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull ImageView child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) { super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type); } \",\"确定 CoordinatorLayout 中 View 与 View 之间的依赖关系，通过 layoutDependsOn() 方法，返回值为 true 则依赖，否则不依赖。\",\"当一个被依赖项 dependency 尺寸或者位置发生变化时，依赖方会通过 Byhavior 获取到，然后在 onDependentViewChanged 中处理。如果在这个方法中 child 尺寸或者位置发生了变化，则需要 return true。\",\"当 Behavior 中的 View 准备响应嵌套滑动时，它不需要通过 layoutDependsOn() 来进行依赖绑定。只需要在 onStartNestedScroll() 方法中通过返回值告知 ViewParent，它是否对嵌套滑动感兴趣。返回值为 true 时，后续的滑动事件才能被响应。\",\"嵌套滑动包括滑动(scroll) 和 快速滑动(fling) 两种情况。开发者根据实际情况运用就好了。\",\"Behavior 通过 3 种方式绑定：1. xml 布局文件。2. 代码设置 layoutparam。3. 自定义 View 的注解。\",\"来源 ：针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN博客\",\"针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN博客\",\"CoordinatorLayout 自定义Behavior并不难，由简到难手把手带你撸三款！ - 泡在网上的日子\",\"一步一步深入理解CoordinatorLayout - 简书\",\"使用CoordinatorLayout打造一个炫酷的详情页 - 简书\"]},\"56\":{\"h\":\"Android控件组\",\"t\":[\"这几天的工作中用到了控件组来实现复杂布局，效果不错，记录下来备用。\",\"在这里定义要使用的控件组布局，这里的布局决定了布局显示的样子。\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <LinearLayout xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" xmlns:app=\\\"http://schemas.android.com/apk/res-auto\\\" android:layout_width=\\\"match_parent\\\" android:layout_height=\\\"wrap_content\\\" android:padding=\\\"10dp\\\"> <ImageView ... /> <EditText .../> <ImageView ... /> </LinearLayout> \",\"在values/attr.xml下新建对应文件，并添加对于自定义属性，以便可以在activity布局文件里面使用到该件组时自定义控一些属性。\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <resources> <!-- MSearchBar表明是给该控件使用的自定义属性 --> <declare-styleable name=\\\"MSearchBar\\\"> <!-- 以下为示例，可以根据需求增减 --> <attr name=\\\"textColor\\\" format=\\\"color\\\" /> <attr name=\\\"textSize\\\" format=\\\"dimension\\\" /> </declare-styleable> </resources> \",\"在该自定义控件的类xxx.java中，通过如下语句获取从用户使用时赋给这些属性的值：\",\"TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar); float textSize = array.getDimension(R.styleable.MSearchBar_textSize, 13); \",\"​\",\"用户动态给这些属性赋值：\",\" <cf.android666.jixiaoyong.weightgroup.weight.MSearchBar ... app:textColor=\\\"@color/colorPrimaryDark\\\"> </cf.android666.jixiaoyong.weightgroup.weight.MSearchBar> \",\"注意，这里写的是app:而非android:。\",\"​\",\"新建XXX.java，继承自布局文件的父布局LinearLayout\",\"更改参数少的构造方法的super(a1,a2,a3)为this(a1,a2,a3)，其中this()中的参数个数为参数最多的构造方法的参数数。\",\"注意 ：一定要做这一步，否则在使用该自定义控件组时，新建该类的对象会提示出错\",\"在最终会被调用的构造方法里面将xml里面定义的布局加载进来：\",\"//注意三个参数：布局文件：R.layout.weight_group_layout, root：this,是否依附到root：true //必须有前两个参数，否则控件的宽高等会有异常 View view = LayoutInflater.from(context).inflate(R.layout.weight_group_layout, this,true); \",\"使用自定义属性：\",\"public MSearchBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); //do sth TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar); float textSize = array.getDimension(R.styleable.MSearchBar_textSize, 13); editText.setTextSize(textSize); } \",\"给控件组内部控件添加点击事件监听：\",\"xxx.java 要实现点击事件监听接口：\",\"public class MSearchBar extends LinearLayout implements View.OnClickListener{} \",\"自定义接口，供使用xxx.java类时实现对监听事件的处理：\",\" public void setImgLeftOnClickListener(OnImgClickListener listener){ listenerL = listener; } public interface OnImgClickListener{ public void onClick(); } private OnImgClickListener listenerL; \",\"对要监听点击事件的控件设置监听，并调用listener.onClick()方法：\",\" //在构造方法等地方设置监听事件 imageViewLeft.setOnClickListener(this); //在xxx.java中重写onClick()方法 @Override public void onClick(View view) { switch (view.getId()) { //ImageLeft case R.id.imageView: if (listenerL != null) { listenerL.onClick(); } break; //imageRight case R.id.imageView2: if (listenerR != null) { listenerR.onClick(); } break; } } \",\"在布局文件main_activity.xml中添加该控件\",\" <cf.android666.jixiaoyong.weightgroup.weight.MSearchBar android:id=\\\"@+id/search_bar\\\" android:layout_width=\\\"match_parent\\\" android:layout_height=\\\"wrap_content\\\" app:textColor=\\\"@color/colorPrimaryDark\\\"> </cf.android666.jixiaoyong.weightgroup.weight.MSearchBar> \",\"​\",\"在java中使用该控件，设置监听事件\",\" MSearchBar searchBar = (MSearchBar) findViewById(R.id.search_bar); searchBar.setImgLeftOnClickListener(new MSearchBar.OnImgClickListener() { @SuppressLint(\\\"WrongConstant\\\") @Override public void onClick() { Toast.makeText(MainActivity.this, \\\"Click on Left\\\", Toast.LENGTH_SHORT).show(); } }); \",\"效果预览\",\"demo的github链接:github\"]},\"57\":{\"h\":\"Android笔记之Xfermode\",\"t\":[\"Xfermode是Android中用来指示Paint绘制的内容与View中已有内容的混合计算方式,也就是用来确定图形绘制到目标图形的时候，如何处理两个图形重合部分的颜色变化。共18个，分为Alpha合成和混合两种。\",\"设要绘制的图形为src，已经绘制好的图形为dst。\",\"需要注意的是，这些图片除了要绘制的图形有着色之外，其他部分要为透明，并且包括透明区域在内的图片大小（宽高）要能完全覆盖另外一张图片的图形区域，否则绘制出的图形可能与预设的效果不一致\",\"按照官方的定义，不同Xfermode绘制结果如下：\",\"要实现如上效果，需要注意：\",\"src和dst符合要求（要有合适的透明区域）\",\"这是因为xfermode的效果，使用透明部分的像素与已有图形对应位置交叉作用，得出所需要的效果，如果透明区域过小，则无法作用到对应的图形。下面这个来自Hencoder.com的图可以很形象的解释：\",\"在新的图层绘制（在新的图层按照xfermode规则绘制，然后再将其绘制到原有图层）：\",\"//新建图层 val saveCount = canvas.saveLayer(0F,0F,width.toFloat(),height.toFloat(),null,Canvas.ALL_SAVE_FLAG) //dst 已经绘制的图形 ; src 我们要绘制的图形 canvas.drawBitmap(dst,0F, 0F, dstPaint) srcPaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_OUT) canvas.drawBitmap(src,0F, 0F, srcPaint) srcPaint.xfermode = null //将新图层绘制到原有图层上 canvas.restoreToCount(saveCount) \",\"关闭硬件加速（可选）\",\"硬件加速的本质是把一部分CPU计算的工作量交给GPU完成，可以加速绘制速度。\",\"但是由于硬件加速不支持canvas.drawXXX()的部分方法，为了避免在某些机型上面无法使用这些方法，可以关闭硬件加速：\",\"view.setLayerType(LAYER_TYPE_SOFTWARE, null); \",\"关于硬件加速更详细的说明可以参考这里：HenCoder Android 自定义 View 1-8 硬件加速\",\"HenCoder.com关于PorterDuff.Mode.DST_IN的动画解释：\",\"可以看出，Xfermode的本质是处理dst与src重合与未重合部分的展示与否，以及颜色变化。\",\"这里的“重合部分”与“未重合部分”，其实也包括了各个图形的透明部分，将dst与src的透明与不透明颜色相互作用，才会出现下述效果。\",\"名称\",\"含义\",\"CLEAR\",\"清除所有内容\",\"DST\",\"只绘制DST\",\"DST_ATOP\",\"先绘制SRC，再在顶部绘制DST与SRC重合的部分\",\"DST_IN\",\"只绘制DST与SRC重合部分\",\"DST_OUT\",\"只绘制DST与SRC未重合部分\",\"DST_OVER\",\"将DST绘制在SRC上面\",\"SRC\",\"只绘制SRC\",\"SRC_ATOP\",\"先绘制DST，再在顶部绘制SRC与DST重合的部分\",\"SRC_IN\",\"只绘制SRC与DST重合部分\",\"SRC_OUT\",\"只绘制SRC与DST未重合部分\",\"SRC_OVER\",\"将SRC绘制在DST上面\",\"XOR\",\"ADD\",\"DARKEN\",\"LIGHTEN\",\"MULTIPLY\",\"OVERLAY\",\"SCREEN\",\"各个效果如下(源码及使用见github)：\",\"HenCoder Android 开发进阶: 自定义 View 1-2 Paint 详解\",\"HenCoder Android 自定义 View 1-8 硬件加速\",\"PorterDuff.Mode\"]},\"58\":{\"h\":\"Android笔记之跨进程通信\",\"t\":[\"Android中的跨进程通信IPC主要有以下几种方式：\",\"BroadcastReceiver\",\"ContentProvider\",\"AIDL\",\"Messenger\",\"Socket\",\"文件\",\"Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制\",\"进程是资源分配的基本单位，线程是调度的基本单位。\",\"以下内容来自：\",\"作者：SylvanasSun 链接：https://juejin.im/post/59f8691b51882534af254317 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\",\"Linux为每个进程维护了一个单独的虚拟地址空间。虚拟地址空间分为内核空间与用户空间，用户空间包括代码、数据、堆、共享库以及栈，内核空间包括内核中的代码和数据结构，内核空间的某些区域被映射到所有进程共享的物理页面。Linux也将一组连续的虚拟页面（大小等于内存总量）映射到相应的一组连续的物理页面，这种做法为内核提供了一种便利的方法来访问物理内存中任何特定的位置。\",\"示意图来自https://juejin.im/post/59f8691b51882534af254317\",\"Linux通过将一个虚拟内存区域与一个硬盘上的文件关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射（memory mapping）。这种将虚拟内存系统集成到文件系统的方法可以简单而高效地把程序和数据加载到内存中。\",\"普通文件映射就是将一个文件与一块内存建立起映射关系，对该文件进行IO操作可以绕过内核直接在用户态完成（用户态在该虚拟地址区域读写就相当于读写这个文件）。匿名文件映射一般在用户空间需要分配一段内存来存放数据时，由内核创建匿名文件并与内存进行映射，之后用户态就可以通过操作这段虚拟地址来操作内存了。匿名文件映射最熟悉的应用场景就是动态内存分配（malloc()函数）。\",\"内存映射提供了共享对象的机制，来避免内存资源的浪费。一个对象被映射到虚拟内存的一个区域，要么是作为共享对象，要么是作为私有对象的。 进程对共享对象的写操作对于其他也使用到该共享对象的进程是可见的。\",\"CPU获取到虚拟地址，然后通过MMU（内存管理单元）将其翻译为物理地址。\",\"优缺点参考：\",\"管道：在创建时分配一个page大小的内存，缓存区大小比较有限；\",\"消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；\",\"共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；\",\"套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；\",\"信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\",\"信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；\",\"作者：Gityuan 链接：https://www.zhihu.com/question/39440766/answer/89210950\",\"管道Pipe\",\"管道 是将标准输入输出连接起来的进程。 数据复制2次，有长度限制\",\"示意图来自https://pic002.cnblogs.com/images/2012/426620/2012110216160766.jpg\",\"如图，进程1将数据写入到管道（内存缓存区），进程2从管道中读取数据。数据从写端流入管道，从读端流出，这样就实现了进程间通信\",\"每个进程的输出被当做下一个进程的输入。\",\"ls -l | less //将ls -l 的结果输入到less中，实现分页 \",\"Linux进程间通信之管道(pipe)、命名管道(FIFO)与信号(Signal)https://blog.csdn.net/skyroben/article/details/71513385\",\"消息队列Message\",\"是一串可以有不同类型的消息块的链表，可以避免阻塞。数据复制2次，有长度限制，缓冲小。\",\"https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html\",\"共享内存\",\"多个进程可以访问一个公用的内存空间。效率最高的IPC。数据内存复制0次,但是没有同步互斥机制\",\"套接字Socket\",\"传输效率低，数据复制2次\",\"信号量 semaphore\",\"与管道不同，信号量是为了保护进程共享资源在同一时刻只能被一个进程访问。解决同步和互斥问题。\",\"sv：信号变量\",\"对信号量的操作只有一下P(sv)和V(sv)两个原子操作:\",\"进程1访问资源时对信号量进行等待操作P(sv)（如果sv>0则操作资源并将信号量-1，否则挂起进程等待）；\",\"当该进程1对资源执行完操作后，对信号量进行发送操作V(sv)（此时如果有进程2等待sv而挂起，则恢复进程2，否则就给sv+1）\",\"https://blog.csdn.net/skyroben/article/details/72513985\",\"信号 Signal\",\"信号是进程间通信中唯一的异步通信机制，通知接收信号的进程发生了什么事情。而进程接受到信号后可以忽略，捕获处理，或者使用系统默认操作。\",\"https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html\",\"只能承载很小的信息量，主要用在进程的中断控制\",\"数据拷贝1次，有权限校验（为发送方添加了UID/PID身份）\",\"参与Binder通信的所有角色 图片来自https://blog.csdn.net/universus/article/details/6211589\",\"时序图：\",\"20200422115253\",\"理论上的Binder逻辑：\",\"SMgr提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成SMgr时Binder驱动会自动为它创建Binder实体（这就是那只预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。\",\"在数据从发送方向接收方拷贝时，驱动会根据发送数据包的大小，使用最佳匹配算法从缓存池中找到一块大小合适的空间，将数据从发送缓存区复制过来。\",\"为了实现用户空间到用户空间的拷贝，Binder驱动的mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。\",\"版权声明：本文为CSDN博主「universus」的原创文章，遵循 CC 4.0 BY-SA\",\"版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/universus/article/details/6211589\",\"主要参考文章：https://blog.csdn.net/universus/article/details/6211589\",\"https://blog.csdn.net/freekiteyu/article/details/70082302\",\"Binder通信主要涉及一下对象：\",\"Server\",\"Client\",\"ServerManager\",\"Binder驱动\",\"首先要知道，Server，Client以及ServerManager一般都在不同的进程之中，那么Server，Client如何与ServerManager通信并注册/查询所需的服务呢？这里就需要用到0号引用Binder。\",\"0号引用Binder 是ServerManager内部创建匿名Binder，所有的Client（相对于ServerManager来说其他和他交互的都是Client）都默认持有这个Binder的引用。\",\"所以一个完整的AIDL通信过程如下：\",\"Server创建一个Binder和对应名字\",\"Server通过持有的0号引用Binder和ServerManager通信。 将生成的Binder和对应名字发送到Binder驱动，Binder驱动会为这个Binder在内核空间创建对应实体节点及其引用（复制了一次），并通过0号引用将其发给ServerManager。\",\"ServerManager收到内核中的Binder对象引用及名字后将其保存到查找表中。\",\"Client通过0号引用Binder和ServerManager通信。 Client将需要的Binder的名字发给ServerManager，ServerManager查询到已经注册的内核Binder引用并将其发给Client。\",\"Client获取到内核Binder的引用进行操作。\",\"再来看看一个完整的流程：\",\"在Service中，我们会先创建一个mIBinder对象并且在public IBinder onBind(Intent intent)方法返回。\",\"private IBinder mIBinder = new AidlBinderInterface.Stub() { ... //这里实现我们服务能够提供的方法 } \",\"追踪onBind方法，我们会发现mIBinder的对象会在ActivityThread中的private void handleBindService(BindServiceData data)方法中被传入到IActivityManager的publishService方法中。\",\"private void handleBindService(BindServiceData data) { ... IBinder binder = s.onBind(data.intent); ActivityManager.getService().publishService( data.token, data.intent, binder); } \",\"ActivityManager.getService()方法是通过IPC获取到ActivityManager的引用\",\" /** * @hide */ public static IActivityManager getService() { return IActivityManagerSingleton.get(); } private static final Singleton<IActivityManager> IActivityManagerSingleton = new Singleton<IActivityManager>() { @Override protected IActivityManager create() { final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } }; \",\"而根据这篇文章，这个binder最终会被传输到绑定这个服务时所用的ServiceConnection对象的onServiceConnected方法中（即mIBinder通过ServerManager从Service传递到了Client）：\",\"private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { mServiceInterface = AidlBinderInterface.Stub.asInterface(service); //我们通过得到的这个mServiceInterface可以在客户端调用服务所实现的方法 } @Override public void onServiceDisconnected(ComponentName name) { } }; \",\"根据Android服务之bindService源码分析mConnection会通过context.bindService(intent, mConnection, Context.BIND_AUTO_CREATE);最终在ActivityManagerService通过Binder驱动程序调用ActivityThread类中的scheduleBindService方法传递到Service所在进程中，并根据Service的状态不同而被调用对应方法（即mConnection通过ServerManager从Client传递到了Service）。\",\"图片来自https://img-blog.csdn.net/20160719100800917?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\",\"在这其中我们用到了两个涉及到AIDL文件：\",\"private IBinder mIBinder = new AidlBinderInterface.Stub() {}\",\"mServiceInterface = AidlBinderInterface.Stub.asInterface(service);\",\"再来看看我们写的对应的AIDL文件：\",\"interface AidlBinderInterface { //在这里定义服务需要提供的方法 } \",\"在这个文件中都是我们自己定义的方法，系统自动帮我们实现了更详细的内容：\",\"package com.example.aidl; // Declare any non-default types here with import statements public interface AidlBinderInterface extends android.os.IInterface { /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.example.aidl.AidlBinderInterface { private static final java.lang.String DESCRIPTOR = \\\"com.example.aidl.AidlBinderInterface\\\"; /** * Construct the stub at attach it to the interface. * 将DESCRIPTOR和这个接口绑定到一起 * 本方法会在服务创建IBinder对象的时候调用 */ public Stub() { this.attachInterface(this, DESCRIPTOR); } /** * Cast an IBinder object into an com.example.aidl.AidlBinderInterface interface, * generating a proxy if needed. */ public static com.example.aidl.AidlBinderInterface asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } // 查询本地是否有符合该描述（DESCRIPTOR）接口的Binder对象 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); // 有的话直接返回本地对象 if (((iin != null) && (iin instanceof com.example.aidl.AidlBinderInterface))) { return ((com.example.aidl.AidlBinderInterface) iin); } // 没有的话，创建代理类，进行跨进程通信 return new com.example.aidl.AidlBinderInterface.Stub.Proxy(obj); } @Override public android.os.IBinder asBinder() { return this; } // 在通信时，如果asInterface返回本地对象，则会执行本地对接口（DESCRIPTOR）的实现方法， // 否则就会调用代理类com.example.aidl.AidlBinderInterface.Stub.Proxy中对应的方法进行跨进程通信 @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { java.lang.String descriptor = DESCRIPTOR; switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getAvailablePointTags: { data.enforceInterface(descriptor); java.util.List<String> _result = this.getAllStringTags(); reply.writeNoException(); reply.writeTypedList(_result); return true; } ... default: { return super.onTransact(code, data, reply, flags); } } } /** * 代理类 * 通过Binder对象mRemote执行AidlBinderInterface接口的具体方法 * 具体则在mRemote.transact()实现了跨进程 */ private static class Proxy implements com.example.aidl.AidlBinderInterface { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } //系统对我们在AIDL中定义的方法的具体实现 @Override public java.util.List<StringTag> getAllStringTags() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List<StringTags> _result; try { _data.writeInterfaceToken(DESCRIPTOR); // mRemote.transact()方法会：1.给服务端发消息 2.挂起当前线程 3.收到服务端返回后唤醒当前线程 mRemote.transact(Stub.TRANSACTION_getAllStringTags, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(StringTag.CREATOR); } finally { _reply.recycle(); _data.recycle(); } return _result; } //系统对每个接口方法的编号 static final int TRANSACTION_getAllStringTags = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); } //下面这些是系统根据我们在aidl中定义的方法写的接口 public java.util.List<StringTag> getAllStringTags() throws android.os.RemoteException {} } \",\"可知mRemote便是指向AMS服务的BinderProxy对象 https://www.diycode.cc/topics/384\",\"https://www.cnblogs.com/a284628487/p/3187320.html\",\"图片来自https://images0.cnblogs.com/blog/391137/201307/12211553-49c477a875e84b2aae764c67f38f26b2.jpg\"]},\"59\":{\"h\":\"others\",\"t\":[\"如果在BroadcastReceiver 的onReceive方法中创建一个线程，那么当该方法返回时，Android系统就会认为该BroadcastReceiver已经完成任务了，从而会在需要回收内存时杀死进程以及其中的Thread。创建一个JobService可以避免这个情况。\",\"So, the system may kill the process at any time to reclaim memory, and in doing so, it terminates the spawned thread running in the process.\",\"https://developer.android.google.cn/guide/components/activities/process-lifecycle?hl=zh-cn\",\"https://blog.csdn.net/universus/article/details/6211589\",\"https://www.jianshu.com/p/429a1ff3560c\",\"https://www.cnblogs.com/a284628487/p/3187320.html\",\"http://hoyouly.fun/2019/07/17/Android-AIDL/\",\"https://juejin.im/entry/59c9cd59f265da065754e6f1\"]},\"60\":{\"h\":\"Android系统架构简介\",\"t\":[\"说明：本文基于Android系统开篇 - Gityuan博客 | 袁辉辉博客 的学习笔记整理\",\"Android系统大体分为4个模块，从底层开始依次是1.linux内核、2.系统库+Android运行时、3.框架层、4.应用层。\",\"下图描述了Android系统从开机到Apk运行的整个流程。\",\"系统启动框架图，来自gityuan.com\",\"流程如下：Loader -> Kernel -> Native-> Framework -> App\",\"Loader层\",\"Boot ROM ：开机时，引导芯片从ROM读取读取初始化代码，加载引导程序到RAM中。\",\"Boot Loader：是启动Android系统之前的引导程序，检查RAM、初始化硬件参数等。\",\"Kernel层（即Android内核层，进入Android系统）\",\"swapper进程（pid=0）：Boot Loader启动swapper（idle）进程，是由内核创建的第一个进程，用来初始化进程管理、内存管理、驱动等等。\",\"kthreadd进程（pid=2）：是Linux系统的内核进程，是所有内核进程的鼻祖。\",\"Syscall，在Native和Kernel之间的系统调用层。\",\"Native层\",\"init进程（pid=1）：由swapper进程创建，是所有用户进程鼻祖\",\"init进程孵化出用户守护进程、启动ServiceManager管理系统服务，启动开机动画Bootnaim。\",\"JNI，Java层和Native（C/C++）层之间。\",\"Framework层\",\"Zygote进程：由init进程fork生成，是Android系统第一个java进程，是所有java进程的父进程\",\"SystemServer进程：由Zygote进程fork而来，是Zygote孵化的第一个进程，负责启动和管理整个java framework，如ActivityManager、PowerManager...\",\"MediaServer进程：由init进程fork而来，负责启动和管理整个C++ framework\",\"APP层\",\"Launcher：Zygote进程孵化的第一个App进程，桌面App。\",\"其他由Zygote进程孵化的系统进程（Browser、Phone...）和非系统app进程。\",\"扼要内容如图：\",\"系统启动示意图\",\"Android常用的通信方式\",\"Binder\",\"Socket\",\"Handler\",\"Binder/Socket用于进程间（都具有独立的地址空间）通信，而Handler消息机制用于同进程的线程间（共享内存空间）通信\",\"在Android系统中：\",\"Zygote进程 --> Socket机制\",\"SystemServer、MediaServer、App之间 --> Binder IPC\",\"同一进程不同线程间 -->  Handler\"]},\"61\":{\"h\":\"Android笔记之贝塞尔曲线的应用\",\"t\":[\"贝塞尔曲线是用节点和控制点绘制的高精度曲线，Android中常用的有二阶、三阶贝塞尔曲线。本文介绍使用贝塞尔曲线绘制折线图，并实现动画效果。\",\"本文代码链接：https://github.com/jixiaoyong/library/blob/master/library/src/main/java/cf/android666/applibrary/view/BezierViewAnim.kt\",\"下图是二阶贝塞尔曲线绘制方法介绍，只要各个点满足条件：AD/AB = BE/BC = DF/DE，那么当沿着当前线段移动D、E点时，F点的运动轨迹就是一个贝塞尔曲线：\",\"图片来自: https://www.cnblogs.com/wjtaigwh/p/6647114.html\",\"动图示意如下：\",\"可以在下面的两个网站在线体验贝塞尔曲线：\",\"https://aaaaaaaty.github.io/bezierMaker.js/playground/playground.html\",\"https://bezier.method.ac/\",\"在绘制折线图时，我们获取的数据可以当做贝塞尔曲线的端点，Android为我们提供了绘制二阶和三阶贝塞尔曲线的方法：\",\"Path.quadTo(float x1, float y1, float x2, float y2)//二阶贝塞尔曲线：分别是控制点的x、y坐标和结束的的x、y坐标 Path.cubicTo(float x1, float y1, float x2, float y2, float x3, float y3)//三阶贝塞尔曲线：分别是控制点1、2的x、y坐标和结束的的x、y坐标 \",\"以Path.cubicTo()方法为例，在绘制三阶贝塞尔曲线时，起点和终点已知，剩下工作就是计算两个控制点的坐标。\"]},\"62\":{\"h\":\"方法1\",\"t\":[\"按照贝塞尔曲线的定义，计算各个点对应控制点的坐标，具体的计算原理我们可以参考这篇文章\",\"假设起点、终点分别为startPoint，endPoint，起点前一个点为beforePointF，终点后一个点为afterPoint，那么终止点1、2（controlPoint1、controlPoint2）的坐标满足（其中a,b为任意正数，比如1/6）：\",\" val controlPoint1X = startPoint.x + (endPoint.x - beforePointF.x) * a val controlPoint1Y = startPoint.y + (endPoint.y - beforePointF.y) * a val controlPoint2X = endPoint.x - (afterPoint.x - startPoint.x) * b val controlPoint2Y = endPoint.y - (afterPoint.y - startPoint.y) * b \",\"这里要处理特殊情况：第一个点P0的前一个仍然为P0，最后一个点Pn的后一个点仍为Pn\",\"但这种情况绘制出来的贝塞尔曲线如下：\",\"可以看到除了P0和Pn外，其他点的曲线坐标和对应的点坐标不一致。\"]},\"63\":{\"h\":\"方法2\",\"t\":[\"为了解决方法1存在的问题，我们人为的在两个点之间加入两个控制点，这样在startPoint，endPoint之间的贝塞尔曲线首尾点的坐标必定落在起点和终点上（思路来自这里）。\",\"所以，两个控制点的坐标为：\",\"val controlPoint1X = (startPoint.x + endPoint.x) / 2 val controlPoint1Y = startPoint.y val controlPoint2X = (startPoint.x + endPoint.x) / 2 val controlPoint2Y = endPoint.y \",\"这样绘制出来的曲线比较符合我们的要求。\",\"所以，最终贝塞尔曲线path计算方法如下：\",\"var bezierPath = Path() bezierPath.moveTo(pointList.first().x, -pointList.first().y) pointList.forEachIndexed { index, startPoint -> when (index) { pointList.lastIndex -> { //在绘制P(n-1) ~ P(n)点的贝塞尔曲线时，已经绘制到了P(n)点，所以此处不用再绘制 } else -> { val endPoint = pointList[index + 1] bezierPath.cubicTo( (startPoint.x + endPoint.x) / 2, -startPoint.y, //为了解决view坐标原点在左上角而做的特殊处理，下同 (startPoint.x + endPoint.x) / 2, -endPoint.y, endPoint.x, -endPoint.y ) } } } \",\"我们可以使用Paint.setShader(Shader shader)方法，在绘制Path的时候绘制渐变背景。\",\"渐变背景使用Shader实现。\",\"为了确保绘制效果，我们需要在Path计算完成后，将其闭合，以确保绘制的背景在我们需要的范围内：\",\" val shadowPaint = Paint(Paint.ANTI_ALIAS_FLAG) shadowPaint.style = Paint.Style.FILL val shader = LinearGradient(0F, 0F, 0F, 500F, Color.GREEN, Color.TRANSPARENT, Shader.TileMode.CLAMP) shadowPaint.shader = shader val shadowPath = Path(path) shadowPath.lineTo(endPoint.x, 800F) shadowPath.lineTo(startPoint.x, 800F) shadowPath.lineTo(startPoint.x, startPoint.y) shadowPath.close() canvas.drawPath(shadowPath, shadowPaint) \",\"为了让Path看起来是从起点慢慢绘制到终点去的，我们可以先计算path的总长度，然后结合ValueAnimator实时获得对应长度的path并绘制：\",\"var mValueAnimator = ValueAnimator.ofFloat(0f, 1f) mValueAnimator.duration = 10000 mValueAnimator.repeatCount = ValueAnimator.INFINITE mValueAnimator.interpolator = AccelerateDecelerateInterpolator() mValueAnimator.addUpdateListener { animation -> //获取从0-1的变化值 progress = animation.animatedValue as Float //不断刷新绘图，实现路径绘制 invalidate() } mValueAnimator.start() \",\"然后在onDraw()方法中绘制对应的path：\",\"var mPathMeasure: PathMeasure = PathMeasure(bezierPath, false) val totalPathLength = mPathMeasure.length //获取path总长度 // 按照进度绘制贝塞尔曲线 val stopD = progress * totalPathLength mPathMeasure.getSegment(0F, stopD, dstPath, true) //按照长度比例截取对应的path并赋值给dstPath //bezier anim canvas.drawPath(dstPath, bezierPaint) //绘制对应的path \",\"使用canvas绘制坐标时，需要注意android的坐标原点位于屏幕左上角。所以在绘制曲线图时可以先将坐标原点向下平移一段距离，再绘制对应坐标（可以绘制实际的y坐标负值）\",\"在拼接贝塞尔曲线的path时候注意，path.moveTo()方法会将path切断\",\"https://wenku.baidu.com/view/c790f8d46bec0975f565e211.htmlhttps://blog.csdn.net/laizuling/article/details/51162011\"]},\"64\":{\"h\":\"Android自定义View实现联系人列表\",\"t\":[\"LetterIndex.java extends View\",\"ContactsListView.java extends RecyclerView #分析\",\"联系人列表有两个要点 \",\"字母导航栏 通过自定义View画出26个字母，设置滑动监听事件，根据上下滑动的距离判断当前选中的字母，并相应更新界面。\",\"列表中的字母标题 针对item中的联系人姓名首字母对应的tag作比较，若与前一个相同则不显示title，否则显示。\",\"事件联动 \",\"当滑动字母导航栏时，除了处理本身的变化外，还要留出接口，以便其他控件获取当前选中的字母。\",\"联系人列表滑动时，除了处理本身变化外，同样要留出接口以便获取当前置顶的item对应的字母\",\"字母导航栏要留出方法，以便其他控件指定选中的字母，并更新界面\",\"ContactsListView.java 重写该类主要是为了实现ItemDecoration根据不同的item变化，同时可以从xml布局文件中获取ItemDecoration的自定义属性。 主要代码：\",\" public ContactsListView(Context context) { this(context, null, 0); } public ContactsListView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public ContactsListView(Context context, @Nullable AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); mTypeArray = context.obtainStyledAttributes(attrs, R.styleable.MyRecyclerDecoration); mContext = context; } \",\"故而在其内部自定义了一个继承自ItemDecoratio得静态内部类Decorationn类：\",\"public Decoration(List<String> data){ //获取要显示的联系人数据对应的英文tag集合 //初始化各种自定义属性 //例如颜色：mColorLetterText = mTypeArray.getColor(R.styleable.MyRecyclerDecoration_color_letter_text, 0xff152648); } @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state){ //画出各个导航title } @Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) { //画出置顶的导航title } @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { //判断是否画出导航title super.getItemOffsets(outRect, view, parent, state); int position = ((RecyclerView.LayoutParams) (view.getLayoutParams())).getViewAdapterPosition(); if (position != -1) { String text = mDatas.get(position).substring(0, 1).toUpperCase(); if (position == 0) { outRect.set(0, mTitleHeight, 0, 0); } else if (text != null && !text.equals(mDatas.get(position - 1).substring(0, 1).toUpperCase())) { outRect.set(0, mTitleHeight, 0, 0); } else { outRect.set(0, 0, 0, 0); } } } private void drawText(Canvas canvas, float left, float right, View child, String text) { //画出文字 } \",\"LetterIndex.java 该类用来画出字母导航栏，并且提供方法获取/设置当前选中的字母\",\" public interface onIndexClickListener { void onIndexClick(int chooseId); void onActionUp(); } public void setOnIndexClickListener(onIndexClickListener listener) { this.mClickListener = listener; } public void setChooseId(int chooseId) { if (chooseId >= 0 && chooseId < mIndexTexts.length) { mChooseId = chooseId; invalidate(); } } \",\"然后重写onTouchEvent(MotionEvent event)方法，在ACTION_DOWN、ACTION_MOVE、ACTION_UP时调用对应的方法即可。\",\"重写onDraw()方法，画出对应的界面\",\" @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int height = getHeight() - getPaddingTop() - getPaddingBottom(); float width = getWidth(); //childHeight 是每一个字母所在单元的高度 float childHeight = (float) height / mIndexTexts.length; //如果被点击了，就画出背景 if (isClick) { mPaint.setColor(mColorIndexBg); canvas.drawRect(0, 0, width, height, mPaint); } Rect bounds = new Rect(); mPaint.setTextSize(mSizeText); mPaint.setTextAlign(Paint.Align.CENTER); for (int i = 0; i < mIndexTexts.length; i++) { String text = mIndexTexts[i]; mPaint.setColor(mColorText); //在被选中的字后面画一个圆，并改变字的颜色 if (i == mChooseId) { mPaint.setColor(mColorChooseTextBg); canvas.drawCircle(width / 2, childHeight / 2 + i * childHeight, mSizeText / 2 + 2, mPaint); mPaint.setColor(mColorChooseText); } mPaint.getTextBounds(text, 0, text.length(), bounds); //bounds里面保存着要画的字的一些属性，如x，y，centerX，centerY等， //要注意 canvas.drawText（text,x,y,mpaint）中y并不是text的最低端，而是baseline。 float x = width / 2; float y = -bounds.centerY() + childHeight / 2 + i * childHeight; canvas.drawText(text, x, y, mPaint); } } \",\"源代码在我的Github，点这里可以找到。\",\"预览.gif\"]},\"65\":{\"h\":\"Android自定义view的一些知识点\",\"t\":[\"View的绘制分为3部分：\",\"measure\",\"测量，决定了View的测量宽、高。几乎所有情况下都等同于View的最终宽、高（如果View需要多次measure才能确定大小，或者重写了layout()方法，并修改了传入的值的话则不会相等）。\",\"layout\",\"布局，决定View的四个顶点坐标和实际的宽、高。\",\"draw\",\"绘制，决定了View的具体显示内容。\",\"其中通过ViewRootImpl类的performTraversals()依次调用performXXX()方法。\",\"MeasureSpec是一个32位int值，高2位表示SpecMode，低30位表示SpecSize。\",\"SpecMode有3种可能值：\",\"UNSPECIFIED 父容器没有限定View大小，可以是任意需要的大小\",\"EXACTLY 父类指定了View的具体大小，View的最终大小就是这个值(match_parent或者具体数值)\",\"AT_MOST View可以是这个值以内的任意大小(wrap_content)\",\"我们指定的View的LayoutParams和父容器（DecorView则是窗口的尺寸，普通View是父容器的MeasureSpec）一起决定了View的MeasureSpec，进而决定了View的宽高。\",\"SpecSize决定于父容器的尺寸、以及View的margin和padding。\",\"final类型的measure()方法调用onMeasure()方法。\",\"public final void measure(int widthMeasureSpec, int heightMeasureSpec){ if (forceLayout || needsLayout) { int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex < 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } } } \",\"在onMeasure()调用了setMeasuredDimension()方法设置了View宽、高的测量值。\",\"protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } public static int getDefaultSize(int size, int measureSpec) { int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: result = size;//返回getSuggestedMinimumWidth/Height的大小 break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize;//返回测量大小 break; } return result; } \",\"getSuggestedMinimumXXX()的值：\",\"如果View没有背景，则返回的是View的android:miniWidth指定的值；\",\"如果View有背景，则返回的是背景的minimumWidth的值和android:miniWidth指定的值中最大的一个值。\",\"protected int getSuggestedMinimumWidth() { return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); } protected int getSuggestedMinimumHeight() { return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight()); } \",\"由此，我们知道，如果直接继承自View的控件必须重写onMeasure()方法，设置wrap_content时候控件的大小。这是因为：\",\"wrap_content对应的specMode是AT_MOST模式，其宽高等于specSize。\",\"根据ViewGroup的getChildMeasureSpec()方法，我们知道此时的specSize是父容器目前可以用的大小，即这种情况下wrap_content的效果和match_parent的效果是一样的。\",\"要避免这种情况，就需要重写onMeasure()方法，在里面专门指定wrap_content时View对应的大小。\",\"由于View的绘制和Activity的生命周期不同步，所以在onCreate()/onStart()/onResume()中都无法有效获取View的宽高。使用以下方式则可以正常获取View的宽高：\",\"Activity/View#onWindowFocusChanged()\",\"当前的Window获取或失去焦点的时候调用，此时View已经初始化完毕，可以获取宽、高。\",\"Activity窗口焦点变化(onPause/onResume)时会被调用多次。\",\"View#post(runnable)\",\"该runnable在view的消息队列尾部，被执行时View已经初始化好了，可以在这里获取宽高。\",\"ViewTreeObserver\",\"注册onGlobalLayoutListener，当View树的状态变更，或者View树内部View可见性发生变化就会被回调。\",\"当View树的状态变更可能被调用多次。\",\"View#measure()\",\"手动调用measure()方法获取宽高。\",\"绘制过程分为以下几步：\",\"绘制背景 background.draw(canvas);\",\"绘制自身 onDraw(canvas);\",\"绘制children dispatchDraw(canvas);\",\"绘制装饰 onDrawForeground(canvas);\",\"setWillNotDraw()表示当前的ViewGroup不需要绘制任何内容，系统会对此进行优化（默认启用）。如果ViewGroup需要绘制内容时，则需要手动关闭这个标志。\",\"public void setWillNotDraw(boolean willNotDraw) { setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK); } \",\"android自定义view时两个图形重叠部分的绘制方式,一定要调用canvas.saveLayer() ，否则不生效。\",\" //这个步骤十分重要，将当前画布保存为新的一层 int save = canvas.saveLayer(0,0,mWidth,mHeight,null,Canvas.ALL_SAVE_FLAG); Paint paint = new Paint(); paint.setColor(mBackgroundColor); RectF backgroundRectF = new RectF(0, 0, mWidth, mHeight); canvas.drawRoundRect(backgroundRectF, mRadius, mRadius, paint); paint.setColor(mForwardColor); //设置二者重叠部分的绘制方式 paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); RectF progressRectF = new RectF(0, 0, mWidth * mProgress, mHeight); canvas.drawRect(progressRectF,paint); //restore to canvas canvas.restoreToCount(save); \",\"paint.setXfermode()可以设置的值参考下图：\",\"参考自【原】使用Xfermode正确的绘制出遮罩效果 - sky0014 - 博客园 \",\"以其宽度为例，在onMeasure(int widthMeasureSpec, int heightMeasureSpec)方法中：\",\"int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); if (widthMode == MeasureSpec.EXACTLY) { mWidth = widthSize; } else { mWidth = 100; if (widthMode == MeasureSpec.AT_MOST) { mWidth = Math.min(mWidth, widthSize); } } \",\"《Android开发艺术探索》\"]},\"66\":{\"h\":\"Android自定义透明背景的Dialog\",\"t\":[\"通过自定义Dialog类，使用Style、AnimationDrawable等实现一个透明背景的、带进度更新的弹窗。\",\"主要涉及Style自定义以及AnimationDrawable的使用。\",\"布局文件\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <LinearLayout xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" android:layout_width=\\\"wrap_content\\\" android:layout_height=\\\"wrap_content\\\" android:gravity=\\\"center\\\" android:background=\\\"@drawable/dialog_bg\\\"> <ImageView android:id=\\\"@+id/image\\\" android:layout_width=\\\"250dp\\\" android:layout_height=\\\"250dp\\\" /> </LinearLayout> \",\"资源文件\",\"1）下载对应进度条的图片资源，放到drawable目录下\",\"2）在drawable下新建dialog_progress.xml\",\"<animation-list xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" android:oneshot=\\\"false\\\"> <item android:drawable=\\\"@drawable/progress_1\\\" //资源文件 android:duration=\\\"300\\\" /> //持续时间ms <item android:drawable=\\\"@drawable/progress_2\\\" android:duration=\\\"300\\\" /> ... </animation-list> \",\"3）dialog圆角背景（非必须）\",\"<shape xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\"> <solid android:color=\\\"#6fb6d4\\\" /> <corners android:radius=\\\"500dp\\\" /> </shape> \",\"4）自定义dialog的style\",\"windowBackground使背景透明\",\"backgroundDimEnabled则可以去除半透明遮罩效果\",\" <style name=\\\"diyDialogStyle\\\" parent=\\\"@android:style/Theme.Dialog\\\" > <item name=\\\"android:windowBackground\\\">@android:color/transparent</item><!--背景透明--> <item name=\\\"android:backgroundDimEnabled\\\">false</item><!--半透明，模糊--> </style> \",\"DIYDialog.java\",\"继承自Dialog.java ，并用构造函数调用initView()方法初始化dialog样式，有其他需求可以再自己实现。\",\"//初始化view、控件 View view = View.inflate(context, R.layout.layout_dialog, null); ImageView imageView = view.findViewById(R.id.image); imageView.setBackgroundResource(R.drawable.dialog_progress); //填充布局 setContentView(view); //实现动画 AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getBackground(); animationDrawable.run(); \",\"github源码路径\"]},\"67\":{\"h\":\"Android运行时权限\",\"t\":[\"本文介绍了Android运行时权限的一些处理流程。\",\"Android运行时权限是Android6之后出现的处理权限的新方式，此前开发者只需要应用需要的权限在AndroidManifest.xml文件中声明即可，现在则需要在使用到对应权限时检测是否有该权限并作出相应处理。\"]},\"68\":{\"h\":\"一般流程\",\"t\":[\"在AndroidManifest.xml中声明所需权限\",\"在使用之前检查是否有该权限checkSelfPermission(),如果有则继续相应操作\",\"如果没有权限则检测是否需要向用户解释为什么需要该权限ActivityCompat.shouldShowRequestPermissionRationale()，再决定如何申请权限requestPermissions()\",\"需要说明的是，shouldShowRequestPermissionRationale()在第一次申请该权限时会返回false，第二次申请时返回true；\",\"但是如果用户选择了不再提醒 则会一直返回false。所以如果判断当前并非第一次申请该权限，并且返回结果为false，就说明用户选择了不再提示，一般就需要提示用户到设置中开启对应权限。\",\"申请权限的结果在onRequestPermissionsResult()方法中返回，根据用户对权限的处理结果决定接下来的操作\"]},\"69\":{\"h\":\"代码\",\"t\":[\"onCreate()方法中调用对应方法\",\"mSharedPreferences = getSharedPreferences(packageName, Context.MODE_PRIVATE) checkCameraDeviceAndPremissions() \",\"checkCameraDeviceAndPremissions()具体内容\",\"private fun checkCameraDeviceAndPremissions() { ... //[2]每次使用之前检测是否有改权限 if (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { safeRequestCameraPermission() } else { safeOpenCamera(cameraId) } } \",\"对申请结果进行处理：\",\"override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) { when (requestCode) { //[4]处理请求权限的结果 REQUEST_CAMERA -> { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { safeOpenCamera(cameraId) } else { var noCameraPermissionDialog = AlertDialog.Builder(this@MainActivity) .setTitle(\\\"警告⚠️\\\") .setMessage(\\\"没有相机权限，不可继续！\\\\n请赋予相机权限\\\") .setCancelable(false) .setPositiveButton(\\\"Yes\\\") { _, _ -> safeRequestCameraPermission() } .setNegativeButton(\\\"No\\\") { _, _ -> finish() } .create() noCameraPermissionDialog.show() } } } } \",\"safeRequestCameraPermission()的内容，这里才是处理申请权限的相关代码\",\"private fun safeRequestCameraPermission() { //[3]检测是否需要解释为什么需要改权限 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) { /** * 第一次请求时为false * 第二次请求时为true，需要解释为什么需要这个权限 * 若用户选择了不再提示则一直为false * 综上，如果不是第一次请求该权限，并且返回值为false，那么可以判断用户选择了不再提示 */ //向用户解释为什么需要改权限 var noCameraDialog = AlertDialog.Builder(this@MainActivity) .setTitle(\\\"提示️\\\") .setMessage(\\\"本应用正常运行需要相机权限，点击确认开始赋予权限\\\") .setCancelable(false) .setPositiveButton(\\\"Yes\\\") { _, _ -> //用户同意后开始申请权限 doRequestCameraPermission() } .create() noCameraDialog.show() } else { Log.d(\\\"TAG\\\", \\\"count \\\" + mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, 0)) if (mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, 0) > 1) { //TODO 用户拒绝了赋予权限，并且选择了“不再提醒”，提示用户到设置中开启 } else { doRequestCameraPermission() } } } private fun doRequestCameraPermission() { //每次申请权限时更新计数器 var count = mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, 0) + 1 mSharedPreferences.edit().putInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, count).apply() requestPermissions(arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA) } \",\"样例代码: Github\"]},\"70\":{\"h\":\"Android通过Hook启动未注册Activity\",\"t\":[\"hook是钩子的意思，hook的过程是通过反射、代理等改变系统原有的行为以达到自己的目的。\",\"本文主要是通过hook android 中的ActivityManagerService和Handler.CallBack，欺骗系统调起activity的过程，在调用startActivity时将targetIntent通过proxy伪装为proxyIntent，等到通过系统验证，正式启动activity时，再讲proxyIntent恢复为targetIntent，从而实现调用未在AndroidManifest.xml中注册的activity。\",\"需要注意，本方法只在Api<26下有效。具体原因见后面。\"]},\"71\":{\"h\":\"1.新建Activity等\",\"t\":[\"IndexActivity.java用于启动targetIntent\",\" ((Button)findViewById(R.id.btn1)).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //启动未在AndroidManifest.xml注册的activity mContext.startActivity(new Intent(mContext,TargetActivity.class)); } }); \",\"TargetActivity.java 和ProxyActivity.java 分别设置对应页面布局setContentView(R.layout.activity_xxx);\",\"HookApplication.java 用于调用hook方法\",\"public class HookApplication extends Application { @Override public void onCreate() { super.onCreate(); Utils.hookAms(this); Utils.hookHandle(); } } \",\"在AndroidManifest.xml中注册IndexActivity和ProxyActivity，Application使用HookApplication。\"]},\"72\":{\"h\":\"2.Utils.java实现hook具体逻辑\",\"t\":[\"Utils.hookAms() 实现拦截targetIntent并发起proxyIntent，欺骗系统对activity是否已注册的验证，其中proxyIntent通过proxyIntent.putExtra(TARGET_KEY, targetIntent); 方法携带targetIntent。\",\"//hookAms()核心代码 Class hookActivityManagerNative = Class.forName(\\\"android.app.ActivityManagerNative\\\"); //在api>26时无此变量：gDefault，该方法失效 Field gDefault = hookActivityManagerNative.getDeclaredField(\\\"gDefault\\\"); gDefault.setAccessible(true); Object object = gDefault.get(null); Class hookSingleton = Class.forName(\\\"android.util.Singleton\\\"); Field mInstance = hookSingleton.getDeclaredField(\\\"mInstance\\\"); mInstance.setAccessible(true); Object oldAms = mInstance.get(object); Class hookIActivityManagerService = Class.forName(\\\"android.app.IActivityManager\\\"); Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[]{hookIActivityManagerService}, new MAmsInvocationHandler(context,oldAms)); //将原有的ActivityManagerService替换为我们自定义的 mInstance.set(object,proxy); \",\"在MAmsInvocationHandler 里面实现targetIntent和proxy的转换\",\"//MAmsInvocationHandler核心代码 public class MAmsInvocationHandler implements InvocationHandler{ public static final String TARGET_KEY = \\\"targetIntent\\\"; ... public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (\\\"startActivity\\\".equals(method.getName())) { int index = 0; Intent targetIntent = null; for (int i = 0; i < args.length; i++) { if (args[i] instanceof Intent) { index = i; targetIntent = (Intent) args[i]; break; } } if (targetIntent != null) { Intent proxyIntent = new Intent(mContext, ProxyActivity.class); proxyIntent.putExtra(TARGET_KEY, targetIntent); args[index] = proxyIntent; } } return method.invoke(mOldAms,args); } } \",\"至此，已经对activity.startActivity做了拦截，所有的targetIntent都会被拦截，存储在proxyIntent中，以通过系统的检查。\",\"接下来，通过系统检查后，hookHandle()通过重写Handler.CallBack，对启动proxyIntent事件做拦截，使之启动targetIntent对应的Activity。\",\"//hookHandle()核心代码 Class activityThreadCls = Class.forName(\\\"android.app.ActivityThread\\\"); Method currentActivityThread = activityThreadCls.getDeclaredMethod(\\\"currentActivityThread\\\"); currentActivityThread.setAccessible(true); Object activityThread = currentActivityThread.invoke(null); Field mH = activityThreadCls.getDeclaredField(\\\"mH\\\"); mH.setAccessible(true); Handler handler = (Handler) mH.get(activityThread); Field callBack = Handler.class.getDeclaredField(\\\"mCallback\\\"); callBack.setAccessible(true); callBack.set(handler, new ActivityThreadHandlerCallBack(handler)); \",\"其中ActivityThreadHandlerCallBack 将返回我们自定义的CallBack以替换系统的，实现启动targetIntent而非proxyIntent。\",\"//ActivityThreadHandlerCallBack核心代码 public class ActivityThreadHandlerCallBack implements Handler.Callback{ @Override public boolean handleMessage(Message msg) { if (msg.what == 100) { handleLaunchActivity(msg); } mHandler.handleMessage(msg); return true; } //主要代码，在这里将proxyIntent转化为targetIntent private void handleLaunchActivity(Message msg) { Object object = msg.obj; try { Field intent = object.getClass().getDeclaredField(\\\"intent\\\"); intent.setAccessible(true); Intent proxyIntent = (Intent) intent.get(object); Intent targetIntent = proxyIntent.getParcelableExtra(MAmsInvocationHandler.TARGET_KEY); if (targetIntent != null) { proxyIntent.setComponent(targetIntent.getComponent()); } } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } \",\"到这里，就实现了启动通过已经注册了的ProxyActivity启动未注册TargetActivity的全过程。\",\"主要思想是找到系统实现该过程的逻辑，在对应地方通过反射获取到对应变量，插入自己的逻辑，从而达到目的。\",\"上面涉及到的代码路径：\",\"github源代码路径\",\"参考了几篇文章，其中较为完整的一篇如下：\",\"Android插件化系列第（一）篇---Hook技术之Activity的启动过程拦截\"]},\"73\":{\"h\":\"Android阅读笔记\"},\"74\":{\"h\":\"layout_weight\",\"t\":[\"layout_weight 重要性，默认的是0,0等级最高，要显示，数字越大重要性越低。\",\"例：a，b的宽度为0，layout_weight分别为1、2，则a，b宽度分别为父容器的2/3、1/3。\"]},\"75\":{\"h\":\"PendingIntent\",\"t\":[\"PendingIntent是封装后的intent，有intent执行所需的context，所以即使要执行intent的activity已经消失或者还没生成，其他activity依然可以通过PendingIntent执行intent。\",\"PendingIntent is a description of an Intent and target action to perform with it. Instances of this class are created with getActivity(Context, int, Intent, int), getActivities(Context, int, Intent[], int), getBroadcast(Context, int, Intent, int), and getService(Context, int, Intent, int); the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.\",\"也就是把自己要执行的intent和执行所需的context封装后给别人，请别人在适当的时候执行。\"]},\"76\":{\"h\":\"android模拟器访问电脑localhost\",\"t\":[\"电脑localhost或者127.0.0.1访问本地网址。\",\"模拟器访问localhost会默认访问手机的本地网址，要访问电脑的本地网址则需要访问10.0.2.2:8080，记得加上对应的端口。\"]},\"77\":{\"h\":\"获取屏幕画面\",\"t\":[\"View decor = MainActivity.this.getWindow().getDecorView(); decor.setDrawingCacheEnabled(true); imageView.setImageBitmap(decor.getDrawingCache()); \"]},\"78\":{\"h\":\"获取网络信息，请求网络\",\"t\":[\"需要请求权限\",\" <uses-permission android:name=\\\"android.permission.INTERNET\\\" /> <uses-permission android:name=\\\"android.permission.ACCESS_NETWORK_STATE\\\" /> \",\"java代码如下：\",\" private void chackNetWork(Context context) { boolean isNetAvailable = false; ConnectivityManager manager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); if (manager.getActiveNetworkInfo() != null) { isNetAvailable = manager.getActiveNetworkInfo().isAvailable(); } if (!isNetAvailable) { Toast.makeText(this, \\\"open network\\\", Toast.LENGTH_SHORT).show(); Intent intent = new Intent(); intent.setAction(Settings.ACTION_NETWORK_OPERATOR_SETTINGS); context.startActivity(intent); } } \",\"LiveData可以在数据有变化的时候调用订阅者并执行指定方法。\",\"Transformations有两个转化LiveData的方法：map()和switchMap()。\",\"map()可以将一个LiveData经过处理转化为另外一个LiveData。\",\"而switchMap()则可以根据不同的需要切换不同的LiveData。\",\"val live = MutableLiveData<String>() val d : LiveData<String> = map(live){ \\\"this is $it\\\" } val e = switchMap(live) { return@switchMap when (it) { \\\"a\\\" -> MutableLiveData<String>(\\\"a\\\") \\\"b\\\" -> MutableLiveData(\\\"b\\\") else -> MutableLiveData(\\\"else\\\") } } \",\"此外，LiveData的子类MediatorLiveData可以添加多个监听项，每个项目改变都会回调对应的onChange()方法。\",\"val mediatorLiveData = MediatorLiveData<String>() mediatorLiveData.addSource(d) { update(it, e.value) } mediatorLiveData.addSource(e) { update(d.value, it) } fun update(a: String? = \\\"\\\", b: String? = \\\"\\\") { //do sth } \",\"【译】LiveData 使用详解\"]},\"79\":{\"h\":\"AppWidget的使用之PendingIntent\",\"t\":[\"这几天学习 AppWidget ，很简单的组件却花费了不少功夫，今天对 PendingIntent 的用法做了一些简单的整理。\",\"PendingIntent\",\"PandingIntent 就像是一个设计好的处理预案，当达到某个特定条件时，便会调用该 Intent 所指定动作（打开服务，Activity或者发送广播）。\",\"这里使用该方法在 AppWidget 里面为按钮添加监听事件，当按钮被点击的时候触发相应的动作\",\"AppWidget 和应用程序不再同一个进程当中，而是在 HomeScreen 上面执行,所以不能直接为 AppWidget 中的 Button 添加监听事件，需要用 remoteViews.setPendingIntent(R.id.widget_button,pendingIntent);意思是当按下按钮的时候 pendingIntent 中的 Intent 就会执行\",\"PendingIntent 当某个事件出现之后才会执行\",\"RemoteViews对象 代表了一系列的 View 对象，和主程序不在同一个进程为 AppWidget 控件绑定处理器\",\"流程概述：\",\"添加 appwidget_provider_info.xml 在 res/xml 下新建 appwidget_provider_info.xml\",\"描述 AppWidget 的基本信息如最小高度、宽度等，还有就是该挂件的布局文件\",\"在 res/layout 下面为该挂件设置具体的布局样式\",\"向 AppWidget 的布局文件中添加一个 Button\",\"向 AppWidget 的布局文件中添加一个 TextView\",\"新建 MyAppWidget.java 继承自 AppWidgetProvider\",\"在该类的 onUpdate() 方法中为 Button 设置、添加监听事件\",\"建立一个 Intent 对象\",\"用该 Intent 对象创建一个 PendingIntent 对象\",\"创建一个 RemoteViews 对象\",\"用该 RemoveViews 对象为 按钮绑定事件处理器\",\"更新按钮\",\"注册事件\",\"备注：要是为 AppWidget 中的 Button 设置的事件是打开一个 TargetActivity ，还需要添加一个 TargetActivity 类和对应的布局文件\",\"以下是代码\",\"appwidget_provider_info.xml\",\"这个布局文件是 AppWidget 的信息\",\"描述了 AppWidget 的最小高，最小宽以及它的布局文件\",\"<appwidget-provider android:minHeight=\\\"200dp\\\" android:minWidth=\\\"300dp\\\" android:initialLayout=\\\"@layout/app_widget\\\" xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" > </appwidget-provider> \",\"app_widget.xml\",\"这个布局文件是 Widget 在桌面上显示的样式\",\"定义了 AppWidget 中各个组件及其样式\",\"其中 Button 用来响应点击事件，加入 TargetActivity\",\"<LinearLayout xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" android:layout_width=\\\"200dp\\\" android:layout_height=\\\"200dp\\\" android:orientation=\\\"vertical\\\"> <TextView android:layout_width=\\\"match_parent\\\" android:layout_height=\\\"wrap_content\\\" android:text=\\\"hello,world!\\\"/> <Button android:id=\\\"@+id/app_widget_btn\\\" android:layout_width=\\\"200dp\\\" android:layout_height=\\\"150dp\\\" android:background=\\\"#ff00ff\\\" android:text=\\\"this is my app widget button\\\"/> </LinearLayout> \",\"target_activity.xml\",\"<LinearLayout xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" android:layout_width=\\\"match_parent\\\" android:layout_height=\\\"match_parent\\\"> <TextView android:layout_width=\\\"match_parent\\\" android:layout_height=\\\"wrap_content\\\" android:textSize=\\\"50sp\\\" android:background=\\\"#00ff00\\\" android:text=\\\"\\\\n hello,welcome to target activity!\\\"/> </LinearLayout> \",\"MyAppWidget.java\",\"主要是修改了 update() 方法：\",\"定义了一个预先设定的动作—- Intent 对象；\",\"利用该 Intent 读写，创建一个 PendingIntent 对象；\",\"创建一个 RemoteView 对象，并为按钮绑定监听事件\",\"刷新 AppWidget。\",\"public class MyAppWidget extends AppWidgetProvider { @Override public void onReceive(Context context, Intent intent) { // TODO Auto-generated method stub super.onReceive(context, intent); } @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { // TODO Auto-generated method stub super.onUpdate(context, appWidgetManager, appWidgetIds); //appWidgetIds 每一次向屏幕添加 AppWidget 的时候都会增加一个唯一的 appWidget 的 Id for(int i = 0; i < appWidgetIds.length;i++){ //创建一个 Intent 对象 Intent intent = new Intent(context,TargetActivity.class); //创建一个 PendingIntent 对象 PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0); // remoteViews 代表 AppWidget 上所有的控件 RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget); //为按钮绑定事件处理器 /* * 参1，指定被绑定处理器的控件id * 参2，指定事件发生时会被执行的 PendingIntent */ remoteViews.setOnClickPendingIntent(R.id.app_widget_btn,pendingIntent); //更新 AppWidget ，参1是用于指定被更新 appWidget 的ID appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews); } } @Override public void onDeleted(Context context, int[] appWidgetIds) { // TODO Auto-generated method stub super.onDeleted(context, appWidgetIds); } @Override public void onEnabled(Context context) { // TODO Auto-generated method stub super.onEnabled(context); } @Override public void onDisabled(Context context) { // TODO Auto-generated method stub super.onDisabled(context); } } \",\"TargetActivity.java\",\"public class TargetActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.target_activity); } } \",\"AndroidManifest.xml\",\"在 AndroidManifest.xml 中注册 TargetActivity 和 MyAppWidget\",\"<application> ... <activity android:name=\\\".TargetActivity\\\"> </activity> <!-- 注意这里注册了一个 MyAppWidget 接收数据--> <receiver android:name=\\\".MyAppWidget\\\"> <intent-filter> <action android:name=\\\"android.appwidget.action.APPWIDGET_UPDATE\\\" /> </intent-filter> <meta-data android:name=\\\"android.appwidget.provider\\\" android:resource=\\\"@xml/appwidget_provider_info\\\"/> </receiver> </application> \"]},\"80\":{\"h\":\"AsyncTask源码解析\",\"t\":[\"这是AsyncTask源码的简单分析，主要基于《Android开发艺术探索》一书的内容。\",\"AsyncTask是Android中多线程处理方式之一（其余为1.HandlerThread、2.IntentService以及普通的线程Thread）。\",\"AsyncTask本质是线程池和Handler的包装类，适合实时更新后台任务进度的工作，特别耗时的工作应当交给线程池处理。\",\"AsyncTask常用方法：\",\"onPreExecute()\",\"doInBackground()\",\"onProgressUpdate()\",\"onPostExecute()\",\"AsyncTask有一下限制：\",\"AsyncTask对象必须在主线程（UI线程，下同）创建\",\"AsyncTask的execute()必须在主线程调用，且只能被调用一次\",\"不能直接调用其4种常用方法（见上）\",\"继承自AsyncTask，重写对应方法。（注意如果需要更新进度，要在doInBackground()方法中调用publishProgress()方法）\",\"在UI线程 实例化AsyncTask对象，并调用其execute()方法，传入参数开始执行。\",\"在execute(params)执行后，将参数params传入mWorker.call()方法\",\"通过exec.execute(mFuture)将其压入SerialExecutor线程池中排队，并在THREAD_POOL_EXECUTOR.execute(mActive)真正执行。\",\"创建对象（代码有节略，下同）\",\"// Creates a new asynchronous task. This constructor must be invoked on the UI thread. //注意这里的要求，必须在ui线程 public AsyncTask(@Nullable Looper callbackLooper) { mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler()//此处创建InternalHandler用于在UI线程处理消息 : new Handler(callbackLooper); mWorker = new WorkerRunnable<Params, Result>() { public Result call() throws Exception { try { result = doInBackground(mParams);//注意这里会调用doInBackground()方法，后台线程 } catch (Throwable tr) { mCancelled.set(true); throw tr; } finally { postResult(result);//此处发送msg到mHandler那里接受处理 } return result; } }; mFuture = new FutureTask<Result>(mWorker) {//这里将mWorker传了进去 @Override protected void done() { } }; } \",\"再看FutureTask\",\"public FutureTask(Callable<V> callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; //将mWorker当做了他的callable this.state = NEW; // ensure visibility of callable } public void run() { try { Callable<V> c = callable; if (c != null && state == NEW) { result = c.call(); //会在这里回调mWorker的call()方法，即前文所说的doInBackgroud()之类的方法 } } finally { } } \",\"在主线程调用execute()方法\",\"@MainThread public final AsyncTask<Params, Progress, Result> execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } \",\"这里调用方法如下：\",\"@MainThread public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { //此处限制execute()只能被执行一次 switch (mStatus) { case RUNNING: throw new IllegalStateException(\\\"Cannot execute task:\\\" + \\\" the task is already running.\\\"); case FINISHED: throw new IllegalStateException(\\\"Cannot execute task:\\\" + \\\" the task has already been executed \\\" + \\\"(a task can be executed only once)\\\"); } } mStatus = Status.RUNNING; onPreExecute(); //开始前准备工作 mWorker.mParams = params; //将参数传入mWorker，并一并传入mFuture中 exec.execute(mFuture);//将准备好参数、执行时间的mFuture排队放入串行线程池中，等待执行 return this; } \",\"这里调用了常用方法之一onPreExecute();\",\"mWorker和mFuture的关系前文已经描述了，在看一下exec.execute(mFuture)执行了什么：\",\"exec是execute()传入的，对应于sDefaultExecutor，再查下去\",\" /** * An {@link Executor} that executes tasks one at a time in serial * order. This serialization is global to a particular process. */ public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; \",\"再看看SerialExecutor这个线程池\",\"//SerialExecutor主要的作用是将这些线程放到线程池中，并按照串行的顺序依次调用 private static class SerialExecutor implements Executor { final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>(); Runnable mActive; public synchronized void execute(final Runnable r) { //offer() Inserts the specified element at the end of this deque. //将r插入到线程池中 mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { //等到当前的执行完了，就调用下一个 scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive);//在这里面才是真正的执行线程的内容 } } } \",\"再仔细看一下THREAD_POOL_EXECUTOR\",\"ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; //Executes the given task sometime in the future. The task //may execute in a new thread or in an existing pooled thread. ThreadPoolExector.executr() \",\"以上介绍了线程和线程池部分的内容，接下来看一下在主线程和后台线程之间是如何依靠handler机制来传递消息的。\",\"关于构造函数，由于我们开发者只能接触到AsyncTask()这个构造函数，所以mHandler=getMainHandler()\",\"public AsyncTask() { this((Looper) null); } //@hide，普通开发者不可见 public AsyncTask(@Nullable Looper callbackLooper) { mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); ...... } private static Handler getMainHandler() { synchronized (AsyncTask.class) { if (sHandler == null) { sHandler = new InternalHandler(Looper.getMainLooper()); } return sHandler;//sHandler是一个类变量，取的是主线程的looper,所以限制了AsyncTask只能在主线程实例化 } } \",\"再看一下InternalHandler类\",\"private static class InternalHandler extends Handler { public InternalHandler(Looper looper) { super(looper); } @SuppressWarnings({\\\"unchecked\\\", \\\"RawUseOfParameterizedType\\\"}) @Override public void handleMessage(Message msg) { //在这里处理后台线程发过来的消息，UI线程 AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } \",\"例如，在doInBackground()方法中可以使用publishProgress()在后台更新进度，即是使用了handler发送消息。\",\"@WorkerThread protected final void publishProgress(Progress... values) { if (!isCancelled()) { getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult<Progress>(this, values)).sendToTarget(); } } \",\"最后，AsyncTask的finish()\",\"private void finish(Result result) { //可见，最后会根据情况调用onCancelled()或者onPostExecute() if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } \"]},\"81\":{\"h\":\"Compose屏幕适配\",\"t\":[\"一种Compose中屏幕适配的解决方案，灵感参考头条屏幕适配、AndroidAutoSize等，以设计稿宽度和屏幕水平方法大小为准，等比拉伸控件大小。\",\"后文附有本方案的Kotlin语言实现，使用只需要两个步骤即可：\",\"// 1 初始化 class MainApp : Application() { override fun onCreate() { super.onCreate() SizeEtx.init(this, 375) // 375为设计稿宽度 } } // 2 使用 size(width = 9.composeDp, height = 16.composeDp) \",\"假设如下变量：设计稿总宽度dpx，控件在设计稿中的大小n，屏幕的实际水平dp大小rdp，以及我们需要求得的控件在设备中的dp值m。\",\"那么我们不难得到以下方程：\",\"n / dpx = m / rdp \",\"也就可以推导出：\",\"m = n * (rdp / dpx) \",\"上述值中，只有屏幕水平dp值rdp还是未知的，又根据**（density 在每个设备上都是固定的，DPI / 160 = density，屏幕的总 px 宽度wpx / density = 屏幕的总 dp 宽度rdp）**可知：\",\"rdp = wpx / density \",\"所以，我们可以推导出：\",\"m = n * (rdp / dpx) = n * ( wpx / density ) / dpx = n * wpx / (density * dpx) \",\"到这里，等式后面的所有数据都为已知或者在app运行时可知，由此我们可以计算出设计稿中的控件在Compose中对应的dp大小。\",\"下面是以上思路的kotlin实现：\",\"import android.content.Context import android.content.res.Configuration import android.content.res.Resources import android.graphics.Point import android.os.Build import android.view.WindowManager import androidx.compose.ui.unit.Dp /** * @author : jixiaoyong * @description ：Compose 屏幕适配方案 * * 根据设计稿宽度（设计稿宽度对应设备水平方向）和设计稿对应物体大小，计算实际应该填写的dp * * 使用： * 在Application onCreate()方法中执行 * SizeEtx.init(this, 375) * 其中375位设计稿屏幕宽度，然后在代码中使用width(315.composeDp)作为大小单位即可， * 其中315为设计稿中的控件大小 * * 计算方式为： * wpx 屏幕实际像素宽度 * dpx 设计稿屏幕宽度 * n 控件设计稿中的宽度（dp、px都可，与dpx单位保持一致） * m 控件在app中对应的dp * rpx 控件在屏幕中应该展示的像素大小 * 已知条件：dp = px / density * （density 在每个设备上都是固定的，DPI / 160 = density，屏幕的总 px 宽度 / density = 屏幕的总 dp 宽度） * * DisplayMetrics#density 就是上述的density * DisplayMetrics#densityDpi 就是上述的dpi * * 综上得出如下结论(以竖屏情况下屏幕宽度为例)： * 屏幕宽度总dp ： rdp = wpx / density * m / rdp = n / dpx * 那么，m = (rdp / dpx) * n * 其中(rdp / dpx)被我们当做设计稿中控件大小与设备中控件dp大小之间的缩放系数：dpWidthScale * 所以：m = dpWidthScale * n * * @email : jixiaoyong1995@gmail.com * @date : 2021/8/2 */ class SizeEtx private constructor(context: Context, dpx: Int) { init { val density = Resources.getSystem().displayMetrics.density var wpx = Resources.getSystem().displayMetrics.widthPixels dpWidthScale = wpx.toFloat() / (dpx * density) dpHeightScale = getScreenRealHeightPx(context).toFloat() / (dpx * density) pxWidthScale = wpx.toFloat() / dpx.toFloat() // 以下数据为Redmi Note 5 的测试数据 // \\\"getScreenRealHeight ${getScreenRealHeightPx(context)}\\\".logd() // 2160,实际设备高度为2160 // \\\"Resources.getSystem().displayMetrics.heightPixels ${Resources.getSystem().displayMetrics.heightPixels}\\\".logd() // 2033,实际设备高度为2160 // \\\"Resources.getSystem().displayMetrics.density ${Resources.getSystem().displayMetrics.density}\\\".logd() // 2.7 // \\\"Resources.getSystem().displayMetrics.densityDpi ${Resources.getSystem().displayMetrics.densityDpi}\\\".logd() // 432 } /** * 获得屏幕真实高度（包含底部导航栏） */ private fun getScreenRealHeightPx(context: Context): Int { val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager val display = windowManager.defaultDisplay val outPoint = Point() if (Build.VERSION.SDK_INT >= 19) { // 可能有虚拟按键的情况 display.getRealSize(outPoint) } else { // 不可能有虚拟按键 display.getSize(outPoint) } // 手机屏幕真实高度 return outPoint.y } companion object { /** * 初始化大小适配工具类 * @param context * @param dpx 设计稿中的屏幕宽度，例如375，在使用到本工具的所有地方，都应该以此宽度为准来获取其他控件的大小 */ fun init(context: Context, dpx: Int) { SizeEtx(context, dpx) } var dpWidthScale = 1.0f var dpHeightScale = 1.0f var pxWidthScale = 1.0f var pxHeightScale = 1.0f } } // Compose 屏幕适配方案 /** * 获取Compose中对应的dp，输入值为设计稿中对应的控件大小 */ inline val Number.composeDp: Dp get() { val isPortrait = isPortrait() return Dp(this.toFloat() * if (isPortrait) SizeEtx.dpWidthScale else SizeEtx.dpHeightScale) } /** * 获取Compose中对应的px，输入值为设计稿中对应的控件大小 */ inline val Number.composePx: Int get() { val isPortrait = isPortrait() return (this.toFloat() * if (isPortrait) SizeEtx.pxWidthScale else SizeEtx.pxHeightScale).toInt() } // 是否竖屏 fun isPortrait() = Resources.getSystem().configuration.orientation == Configuration.ORIENTATION_PORTRAIT \",\"AndroidAutoSize\",\"一种极低成本的Android屏幕适配方式\"]},\"82\":{\"h\":\"Dagger 2 从0到1之旅\",\"t\":[\"Dagger 2是Google维护的一款可用于Java和Android的依赖注入框架。\",\"本文主要是简单梳理Dagger 2中各个注解的作用，以及其简单用法，不涉及具体项目应用。\",\"先解释几个概念：\",\"依赖注入：是一个对象（或静态方法）给另一个对象提供依赖的技术。\",\"**依赖**是可以使用的对象（Service），而把依赖提供给使用该依赖的对象（Client）的过程叫做注入。\",\"例如，下面这段代码中Service就是Client的依赖。：\",\"class Service class Client(){ init { val service = Service() } } \",\"但是如果每个依赖都这样写的话，如果Service类的构造方法有变更，就需要同时也更改Client对应的方法，这样深耦合的代码显然不是我们需要的。\",\"Dagger 2 就是为了帮助我们解决这个问题，在使用它之后，Client类的代码只需要这样写成类似下面这样（示例代码）：\",\"class Client{ lateinit var service: Service init { //TODO 某个将Service依赖注入的方法 magicFun() val newService = service//使用Service的实例service } } \",\"可以看到，这时Service的实例化过程被移到了Client的外部某处，这样如果Service构造方法有更新时，我们只需要统一去修改magicFun()中对应的代码即可。\",\"那么这一切Dagger 2到底是如何实现的呢？\"]},\"83\":{\"h\":\"@Inject\",\"t\":[\"首先需要请出第一个主角——@Inject。\",\"在Dagger 2中，@Inject主要做两件事❶标记依赖类的构造方法；❷标记需要框架自动实例化的对象：\",\"class Service @Inject constructor()//❶标记依赖类的构造方法 class Client{ @Inject lateinit var service: Service//❷标记需要框架自动实例化的对象 ... } \",\"这样Dagger 2 就知道了有个对象需要它来帮助我们注入，同时也知道了有一个构造方法来实例化Service对象。但这时如何将二者联系起来呢？\"]},\"84\":{\"h\":\"@Component\",\"t\":[\"这就要提到第二个主角——@Component。\",\"@Component标记的类是将一个类和他的依赖联系在一起的桥梁，通常是一个抽象类或者接口：\",\"@Component interface ClientComponent{ fun inject(client: Client) } \",\"至此，Client和Service通过ClientComponent联系在一起，在使用时只需要将Client的引用传入即可：\",\" init { //方式❶ DaggerClientComponent.create().inject(this) //方式❷ DaggerClientComponent.builder().build().inject(this) val newService = service } \",\"以上完整的代码可以参考这里,若无法显示可点击这里查看：\",\"到目前为止，对于我们自己定义的类，我们只需要使用@Inject标记其构造方法，然后再在使用该类的时候使用@Inject标记该对象，在需要使用该对象的地方通过@Component类传入使用该依赖的类的引用即可。\",\"但是很显然实际开发中，不是所有的Service类都可以被我们随意修改，如果Service类是第三方提供的类，显然我们是无法用@Inject修饰其构造函数的。\"]},\"85\":{\"h\":\"@Module和@Provides\",\"t\":[\"为了解决第三方依赖的问题，我们要引入另外两个主角——@Module和@Provides。\",\"@Provides用来提供一个方法，我们可以在其内部实例化并返回Service类，这样子当用到Service的时候，@Component类只需要找到@Provides提供的这个方法，并获取到他实例化好的Service对象注入到Client中就可以了。\",\"@Module则是提供一个类（注意是类，而非接口），像一个袋子一样把@Provides提供的方法“装”到一起，打包提供给@Component类。\",\"@Module class ClientModule{ @Provides fun getService() = Service() } @Component(modules = [ClientModule::class])//Component可以有多个Module类 interface ClientComponent{ fun inject(client: Client) } \",\"上述代码中的@Component(modules = [ClientModule::class])将装有可以产生依赖的@Provides方法的“大袋子”@Module和“桥梁”@Component关联到了一起。\",\"@Component在产生依赖的时候会先到@Module类中的@Provides方法中查找；如果找不到才会再到@Inject中查找。（也就是说，此时Service类的@Inject构造方法其实是失效了的，完全可以没有@Inject注解——第三方类即是如此）。\",\"上述完整代码如下,若无法显示可点击这里查看：\",\"解决了第三方依赖引用的问题，还有一个非常重要的问题——我们使用的绝大多数类肯定不止一个构造方法，那么假设依赖类Service现在有两个构造方法，我们需要分别这两个构造方法，这种情况又该怎么处理呢？\",\"class Service @Inject constructor(var string: String = \\\"default\\\") \",\"很明显，这时候@Inject注解已经没用了，一个类只能有一个构造方法被@Inject修饰，否则会报错：错误: Types may only contain one @Inject constructor。\",\"去掉@Inject后Service类变成如下：\",\"class Service(var string: String = \\\"default\\\") \",\"尝试在@Module中添加另外一个@Provides方法使用另外一个带参构造函数：\",\"@Module class ClientModule{ @Provides fun getService() = Service() @Provides fun getServiceWithArgs() = Service(\\\"Args\\\") } \",\"运行时发现会出错，因为有两个方法都可以提供Service，@Component产生了迷失，不知道用哪一个好，导致错误。\"]},\"86\":{\"h\":\"@Named和@Qualifier\",\"t\":[\"为了解决多个构造函数导致的问题，这时就需要第五个主角**@Named以及幕后英雄@Qualifier**\",\"首先，上述问题的解决方案是在另外一个方法上加一个注解@Named，表示他是一个特殊的方法：\",\" @Provides @Named(\\\"Args\\\") fun getServiceWithArgs() = Service(\\\"Args\\\") \",\"当在Client中想使用这个方法的依赖时：\",\" //@field:是kotlin中注解字段特别需要的，在Java中可以直接写成@Named(\\\"Args\\\") @Inject @field:Named(\\\"Args\\\") lateinit var service: Service \",\"查看@Named源码：\",\"@Qualifier @Documented @Retention(RUNTIME) public @interface Named { /** The name. */ String value() default \\\"\\\"; } \",\"发现@Qualifier才是他实现标识限定符注解（Identifies qualifier annotations）的力量之源。查看@Qualifier注解可以知道，我们也可以自定义基于@Qualifier的注解来实现和@Named完全一致的功能。\",\"@Qualifier @MustBeDocumented @kotlin.annotation.Retention(AnnotationRetention.RUNTIME) annotation class YourQualifierName(//YourQualifierName可以是任意你喜欢的名字 /** The name. */ val value: String = \\\"\\\" ) \",\"之后我们就可以使用@YourQualifierName替代@Named实现标识不同注解的作用，从而支持有多个构造函数的Service类的初始化。\",\"上述完整代码如下,若无法显示可点击这里查看：：\",\"@Component可以有多个@Module，他们之间的关系可以用下图表示：\"]},\"87\":{\"h\":\"@Singleton和@Scope\",\"t\":[\"在实际开发中，我们需要有的类只能有一个实例，从而在不同的地方共享一些数据——即单例，这种情况就需要另外一个角色@Singleton和他的幕后英雄@Scope。\",\"@Singleton是用来标记类在其范围内只能被实例化一次。\",\"@Scope @Documented @Retention(RUNTIME) public @interface Singleton {} \",\"通过查看其源码可以知道其背后是@Scope在起作用，@Scope的作用是限定其修饰的类的范围，适用于有可注入的构造函数并且包含控制类型实例如何重用的类。没有@Scope修饰的实例在构造完毕后就会失去控制，不再关心后续的发展（then forgets it），而@Scope修饰的类会在实例构造完毕后，继续保留一遍下一次可能的复用，当有多个线程可以访问该实例时，他的实现应该是线程安全的（it‘s implementation should be thread safe）。\",\"此外@Component应该和他所包含的@Module的@Provides的@Scope范围一致：\",\"@Singleton @Component(modules = [ClientModule::class]) interface ClientComponent{ fun inject(client: Client) } @Module class ClientModule{ @Provides fun getService() = Service() @Singleton @Provides @Choose(\\\"Args\\\") fun getServiceWithArgs() = Service(\\\"Args\\\") } \",\"此外两个关系为**dependencies**的@Component可以分别拥有相同名称的@Inject、@Module、@Provides而不会被merge，两者可以相互访问。\",\"而**subcomponents**则不能和@Component有以上相同的项。\",\"Subcomponent从它的父类访问所有依赖\",\"@Component只能访问在基类@Component接口暴露的公共性的依赖\",\"——Subcomponents和Component Dependencies——Sinyuk Blog\",\"他们之间的关系可以表示为下图：\",\"android-cn：依赖注入—— Github\",\"Dependency Injection ——wikipedia\",\"Elye的Dagger 2 系列\",\"Dagger 2 官方手册\",\"Android - Dagger2使用详解——简书\",\"Subcomponents和Component Dependencies——Sinyuk Blog\"]},\"88\":{\"h\":\"Dagger 2 ❤️ Android\",\"t\":[\"上篇文章介绍了Dagger 2 的基本使用，本文跟随官方文档实践一下Dagger 2 在Android中的使用，可以看做是官方文档的不完全翻译。\",\"本文有关Dagger 2的使用分为Activity和Fragment两部分，二者的使用几乎没有差别，最后介绍一下在Google官方Demo中学到的一个小技巧，可以将几乎所有的和Dagger 2的逻辑放到一份代码里面，对Android工程的影响极小。\",\"首先要添加相关依赖（Kotlin环境）：\",\"apply plugin: 'kotlin-kapt'//引用该插件 implementation \\\"com.google.dagger:dagger:$rootProject.dagger2Version\\\" implementation \\\"com.google.dagger:dagger-android-support:$rootProject.dagger2Version\\\"//Android特需 kapt \\\"com.google.dagger:dagger-compiler:$rootProject.dagger2Version\\\"//注意如果是kotlin语言，这里需要时#kapt# \"]},\"89\":{\"h\":\"Application范围内的@Component\",\"t\":[\"首先创建整个应用程序使用的@Component，并将AndroidInjectionModule加入其中，实现Inject注入入口：\",\"@Component(modules = [AndroidInjectionModule::class, MainActivityModule::class]) interface AppComponent { fun inject(application: MainApplication) } \",\"AppComponent的范围是整个应用程序都有效。\"]},\"90\":{\"h\":\"创建单个Activity的@Subcomponent\",\"t\":[\"创建某个Activity专属的@Subcomponent，用于提供AndroidInjector.Builder。\",\"@Subcomponent interface MainActivitySubComponent : AndroidInjector<MainActivity> { @Subcomponent.Builder abstract class Builder : AndroidInjector.Builder<MainActivity>() } \"]},\"91\":{\"h\":\"创建单个Activity的@Module\",\"t\":[\"创建属于整个Activity的@Module，注意这里要指明@subcomponents为刚刚创建的MainActivitySubComponent。\",\"@Module(includes = [MainActivityModule.InnerModule::class], subcomponents = [MainActivitySubComponent::class]) class MainActivityModule { @Provides fun bindWaitForInjectClass() = WaitForInjectClass() @Module abstract class InnerModule { @Binds @IntoMap @ClassKey(MainActivity::class) abstract fun bindInjectorFactory(builder: MainActivitySubComponent.Builder): AndroidInjector.Factory<*>//注意这里是 Factory<*> } } class WaitForInjectClass //一个供依赖注入的类 \",\"可以看到在MainActivityModule中提供了一个方法利用刚刚MainActivitySubComponent中提供的MainActivitySubComponent.Builder实例生成了一个AndroidInjector.Factory，而这个Factory就是我们后面要将MainActivityModule中的依赖实例通过AppComponent传递给MainActivity实例的关键。\",\"此外还可以看到提供该Factory的方法是放到了另外一个抽象类里面然后再导入MainActivityModule中的，这是因为该方法的注解@Binds要求方法是抽象的，而MainActivityModule要是需要给Activity提供依赖实例所必须的@Provides又要求类不能是抽象的，否则就要求该方法是静态的。权衡之下我觉得这种方式是比较能接受的，当然也不排除有其他更优雅的解决方案，欢迎提Issue告知。\",\"然后，将MainActivityModule加入到应用程序的@Component——AppComponent中。\"]},\"92\":{\"h\":\"使Application继承自 HasActivityInjector\",\"t\":[\"使当前MainApplication继承自HasActivityInjector，该接口只有一个方法：\",\"/** Returns an {@link AndroidInjector} of {@link Activity}s. */ AndroidInjector<Activity> activityInjector(); \",\"这个类是用来为相应的Activity提供一个AndroidInjector。由于我们已经在AppComponent中包括了AndroidInjectionModule，所以Dagger 2已经可以自动为我们注入DispatchingAndroidInjector依赖，所以接下来的代码如下：\",\"class MainApplication : HasActivityInjector, Application() { override fun onCreate() { super.onCreate() DaggerAppComponent.create().inject(this) } @Inject lateinit var dispatchActivityInjector: DispatchingAndroidInjector<Activity> override fun activityInjector() = dispatchActivityInjector//返回Dagger 2为我们注入的dispatchActivityInjector对象 } \",\"在onCreate()方法中传入当前Application的依赖。\"]},\"93\":{\"h\":\"在Activity中使用自动注入依赖\",\"t\":[\"做完了以上所有内容，我们只需要在Activity中添加如下代码就可以实现自动注入：\",\"class MainActivity : AppCompatActivity() { @Inject lateinit var waitForInjectClass: WaitForInjectClass override fun onCreate(savedInstanceState: Bundle?) { AndroidInjection.inject(this)//注意这里，在super()之前调用 super.onCreate(savedInstanceState) setContentView(R.layout.activity_dagger2_x_android_main) Log.d(\\\"TAG\\\", \\\"The Class is $waitForInjectClass\\\") } } \",\"以上所有代码如下，或者也可以在这里找到：\"]},\"94\":{\"h\":\"这一切是怎么实现的呢？\",\"t\":[\"在Android程序运行时，AndroidInjection.inject()从Application中的activityInjector()方法获取到 DispatchingAndroidInjector<Activity> ，然后将Activity传入inject(Activity)。\",\"DispatchingAndroidInjector 通过AppComponent找到我们在MainActivityModule提供的对应的AndroidInjector.Factory，然后创建了 AndroidInjector ——这就是我们当前Activity对应的MainActivitySubComponent。\",\"接下来便按照之前的逻辑，从MainActivitySubComponent中查找提供waitForInjectClass的实例方法完成注入。\",\"Dagger 2在Fragment的使用和在Activity中的使用十分相似。\",\"通过之前的代码我们可以知道，其基本的原理依旧是利用@Component和@subcomponent，@Module之间的关联关系将Application和Activity等的依赖注入通过AndroidInjector关联起来的：\",\"MainActivitySubComponent通过将MainActivityModule加入到AppComponent之中，然后当MainActivity之中需要使用到MainActivitySubComponent时，又通过AndroidInjector从AppComponent中拿到MainActivityModule中的AndroidInjector.Factory，通过该Factory和MainActivitySubComponent中的Builder产生关联，从而获取到了MainActivitySubComponent的实例供Activity使用。\",\"在Fragment中我们也可以这样处理，只不过由于Fragment的特性，他的@Module不仅可以交给Application的@Component，也可以交给其他Fragment或者Activity的@Component，让其实现HasFragmentInjector即可，这取决于我们想要给Fragment绑定的依赖。\",\"具体的实现一般分为下面几步：\",\"创建Application的@Component并添加AndroidInjectionModule\",\"创建实现了AndroidInjector<MainFragment>的MainFragmentSubComponent，其内部有方法提供AndroidInjector.Builder<MainFragment>\",\"创建包含了提供AndroidInjector.Factory<*>的抽象方法的MainFragmentModule，指定其subcomponents为MainFragmentSubComponent；\",\"将MainFragmentSubComponent加入到想要加入的类的@Component中，比如AppComponent类\",\"在Application（如果上一步是Activity，则本步也是Activity等）中参照在Activity实现的步骤实现HasFragmentInjector\",\"上述完整的代码如下，或者也可以在这里找到：\",\"关于Fragment加入到Activity的Demo在官方文档有，这里就不再赘述了，其实只要掌握原理，其他用法的完全可以触类旁通。\",\"通过观察上面的两份代码，我们发现虽然这Dagger 2已经替我们做了好多事情，我们只需要在需要使用依赖注入的类中使用诸如AndroidInjection.inject(this)这样的代码就可以了，但是如果Activity、Fragment类过多的时候，这样的重复性工作仍然是个不小的工作量，万一有某处遗忘了便会导致出错。\",\"这时就可以用到我在Google官方示例代码中学到的一个小技巧了(针对本文中的例子做了一些修改)，或者你也可以到这里查看源码：\",\"Dagger 2 官方文档 Android篇\",\"Google官方示例代码——GithubBrowserSample\"]},\"95\":{\"h\":\"Dart event loop\",\"t\":[\"本文基于Dart 2.17\",\"Dart App中所有的代码都在一个isolate中运行（各个isolate之间的代码运行时是隔离的），一个isolate有自己的heap，维持有一个消息队列event_loop，处理两种消息：\",\"event queue 执行用户点击、屏幕刷新、绘制，一般的Future、IO、Stream流等，每次执行完毕都会先检查执行micro task queue中的任务，直到其为空再执行下一个event queue\",\"microTask queue 优先执行，一般执行跑完即弃的小任务，如Dart内部的微任务\",\"上述两种event会在普通的Dart同步方法执行完毕后执行，无论是microTask还是普通的event，他们都是concurrency并行执行（也就是说实际上还是上一个执行完毕，再执行另外一个），所以如果这些event中存在耗时长的方法，依旧会阻塞其他方法的执行，可能导致UI卡顿等情况。\",\"在代码执行的过程中，各种事件（如用户点击、屏幕刷新、future、microtask等）都会被当做一个个event放入到event queue中，然后不停的从event loop取出事件并执行：\",\"dart_event_loop\",\"他们的执行顺序如下：\",\"dart_event_loop_sequeue\",\"可以从下述例子详细看一下代码执行的时候各个方法执行过程：\",\"dart_test_queue_code\",\"dart_test_queue_output\",\"本文根据Dart SDK源码分析一下event loop的实现。\",\"代码参考：https://gist.github.com/jixiaoyong/ac811902db42a51cf97e3290788ade4a\",\"同步方法包括普通的方法，以及一下几种会按照同步方法立即执行的方式：\",\"Future.sync(() => print(\\\"Hello, I am future created by Future.sync\\\")); Future.forEach( [1, 2, 3], (element) => print(\\\"Hello, I am future($element) created by Future.forEach\\\")); Future.doWhile(() async { if (repeatCounter++ < 3) { print(\\\"repeat ($repeatCounter/3) inner Future.doWhile\\\"); await Future.delayed(const Duration(seconds: 1)); return true; } return false; }); \",\"microtask会在同步方法执行完毕之后立即被执行，一般用来执行“即抛型”的方法，不应当执行耗时方法。microtask列表会一直执行，直到event loop中没有micro task了，才会去执行Future等普通的event。\",\"scheduleMicrotask(() { print('Hello, world! I am a microtask.'); }); Future.microtask( () => print(\\\"Hello, I am microtask created by Future.microtask\\\")); Future.value(1).then((value) { print(\\\"Hello, I am future created by Future.value\\\"); }); Future.error(Exception(\\\"Hello, I am future created by Future.error\\\")) .onError((error, stackTrace) => print(error)); \",\"Future.value([FutureOr<T>? value]) 比较特殊，如果value 是future，那么他会在value执行完毕后返回他的值，如果value不是future，他就会立即执行属于microtask\"]},\"96\":{\"h\":\"代码分析\",\"t\":[\"让我们看一下上述方法的具体实现：\",\"// -> sdk\\\\lib\\\\async\\\\future.dart factory Future.microtask(FutureOr<T> computation()) { _Future<T> result = new _Future<T>(); scheduleMicrotask(() { try { result._complete(computation()); } catch (e, s) { _completeWithErrorCallback(result, e, s); } }); return result; } \",\"可以看出，Future.microtask本质还是调用scheduleMicrotask实现的，其实现如下：\",\"// -> sdk\\\\lib\\\\async\\\\schedule_microtask.dart @pragma('vm:entry-point', 'call') void scheduleMicrotask(void Function() callback) { _Zone currentZone = Zone._current; if (identical(_rootZone, currentZone)) { // No need to bind the callback. We know that the root's scheduleMicrotask // will be invoked in the root zone. _rootScheduleMicrotask(null, null, _rootZone, callback); return; } _ZoneFunction implementation = currentZone._scheduleMicrotask; if (identical(_rootZone, implementation.zone) && _rootZone.inSameErrorZone(currentZone)) { _rootScheduleMicrotask( null, null, currentZone, currentZone.registerCallback(callback)); return; } Zone.current.scheduleMicrotask(Zone.current.bindCallbackGuarded(callback)); } \",\"Zone.scheduleMicrotask()最后调用的是_RootZone的同名方法：\",\"// -> sdk\\\\lib\\\\async\\\\zone.dart class _RootZone extends _Zone { void scheduleMicrotask(void f()) { _rootScheduleMicrotask(null, null, this, f); } } void _rootScheduleMicrotask( Zone? self, ZoneDelegate? parent, Zone zone, void f()) { if (!identical(_rootZone, zone)) { bool hasErrorHandler = !_rootZone.inSameErrorZone(zone); if (hasErrorHandler) { f = zone.bindCallbackGuarded(f); } else { f = zone.bindCallback(f); } } _scheduleAsyncCallback(f); } \"]},\"97\":{\"h\":\"_RootZone._scheduleAsyncCallback\",\"t\":[\"这里调用了_RootZone._scheduleAsyncCallback方法，将传入的callback当做microtask执行。\",\"// -> sdk\\\\lib\\\\async\\\\schedule_microtask.dart /// Schedules a callback to be called as a microtask. /// /// The microtask is called after all other currently scheduled /// microtasks, but as part of the current system event. void _scheduleAsyncCallback(_AsyncCallback callback) { _AsyncCallbackEntry newEntry = new _AsyncCallbackEntry(callback); _AsyncCallbackEntry? lastCallback = _lastCallback; if (lastCallback == null) { _nextCallback = _lastCallback = newEntry; if (!_isInCallbackLoop) { _AsyncRun._scheduleImmediate(_startMicrotaskLoop); } } else { lastCallback.next = newEntry; _lastCallback = newEntry; } } \"]},\"98\":{\"h\":\"_RootZone._startMicrotaskLoop\",\"t\":[\"这里面的_startMicrotaskLoop方法是实际上处理microtask的地方：\",\"// -> sdk\\\\lib\\\\async\\\\schedule_microtask.dart /// Whether we are currently inside the callback loop. /// /// If we are inside the loop, we never need to schedule the loop, /// even if adding a first element. bool _isInCallbackLoop = false; void _microtaskLoop() { for (var entry = _nextCallback; entry != null; entry = _nextCallback) { _lastPriorityCallback = null; var next = entry.next; _nextCallback = next; if (next == null) _lastCallback = null; (entry.callback)(); } } void _startMicrotaskLoop() { _isInCallbackLoop = true; try { // Moved to separate function because try-finally prevents // good optimization. _microtaskLoop(); } finally { _lastPriorityCallback = null; _isInCallbackLoop = false; if (_nextCallback != null) { _AsyncRun._scheduleImmediate(_startMicrotaskLoop); } } } \",\"而_AsyncRun._scheduleImmediate方法则是触发处理microtask的方法：\",\"// -> sdk\\\\lib\\\\async\\\\schedule_microtask.dart class _AsyncRun { /// Schedule the given callback before any other event in the event-loop. external static void _scheduleImmediate(void Function() callback); } \"]},\"99\":{\"h\":\"_AsyncRun._scheduleImmediate\",\"t\":[\"_AsyncRun._scheduleImmediate方法的实现在schedule_microtask_patch.dart中：\",\"// -> sdk/lib/_internal/vm/lib/schedule_microtask_patch.dart @patch class _AsyncRun { @patch static void _scheduleImmediate(void callback()) { final closure = _ScheduleImmediate._closure; if (closure == null) { throw new UnsupportedError(\\\"Microtasks are not supported\\\"); } closure(callback); } } typedef void _ScheduleImmediateClosure(void callback()); class _ScheduleImmediate { static _ScheduleImmediateClosure? _closure; } @pragma(\\\"vm:entry-point\\\", \\\"call\\\") void _setScheduleImmediateClosure(_ScheduleImmediateClosure closure) { _ScheduleImmediate._closure = closure; } @pragma(\\\"vm:entry-point\\\", \\\"call\\\") void _ensureScheduleImmediate() { _AsyncRun._scheduleImmediate(_startMicrotaskLoop); } \"]},\"100\":{\"h\":\"_ScheduleImmediateClosure\",\"t\":[\"可以看到，microtask实际上是使用_ScheduleImmediateClosure调用的，关于他主要有两个方法：\",\"_setScheduleImmediateClosure\",\"_ensureScheduleImmediate\",\"让我们先看一下第一个方法_setScheduleImmediateClosure：\",\"// -> runtime\\\\bin\\\\dartutils.cc // PrepareAsyncLibrary方法会在Dart虚拟机启动的时候被调用 Dart_Handle DartUtils::PrepareAsyncLibrary(Dart_Handle async_lib, Dart_Handle isolate_lib) { Dart_Handle schedule_immediate_closure = Dart_Invoke( isolate_lib, NewString(\\\"_getIsolateScheduleImmediateClosure\\\"), 0, NULL); RETURN_IF_ERROR(schedule_immediate_closure); Dart_Handle args[1]; args[0] = schedule_immediate_closure; return Dart_Invoke(async_lib, NewString(\\\"_setScheduleImmediateClosure\\\"), 1, args); } \",\"这里主要调用了Dart中的_getIsolateScheduleImmediateClosure方法创建了schedule_immediate_closure，然后通过_setScheduleImmediateClosure返回：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\isolate_patch.dart /// The embedder can execute this function to get hold of /// [_isolateScheduleImmediate] above. @pragma(\\\"vm:entry-point\\\", \\\"call\\\") Function _getIsolateScheduleImmediateClosure() { return _isolateScheduleImmediate; } /// The closure that should be used as scheduleImmediateClosure, when the VM /// is responsible for the event loop. void _isolateScheduleImmediate(void callback()) { assert((_pendingImmediateCallback == null) || (_pendingImmediateCallback == callback)); _pendingImmediateCallback = callback; } /// The callback that has been registered through `scheduleImmediate`. _ImmediateCallback? _pendingImmediateCallback; \",\"可以看到，这个方法会将传递进来的callback赋值给_pendingImmediateCallback。\",\"而结合上面的代码，_ensureScheduleImmediate 方法主要也是用来触发_ScheduleImmediateClosure执行回调事件。\",\"到目前为止，我们能确定的是：\",\"在Dart VM启动的时候，会创建一个_ScheduleImmediateClosure并保存在_pendingImmediateCallback;\",\"当有新的microtask加入的时候，会触发_startMicrotaskLoop方法在_microtaskLoop()中实际处理一个microtask（这里的_startMicrotaskLoop触发的实际是通过_AsyncRun._scheduleImmediate(_startMicrotaskLoop)将其使用_pendingImmediateCallback 包裹之后执行的）。\"]},\"101\":{\"h\":\"_pendingImmediateCallback\",\"t\":[\"现在的问题是，这个_pendingImmediateCallback 什么时候会被安排执行呢？\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\isolate_patch.dart @pragma(\\\"vm:entry-point\\\", \\\"call\\\") void _runPendingImmediateCallback() { final callback = _pendingImmediateCallback; if (callback != null) { _pendingImmediateCallback = null; callback(); } } @pragma(\\\"vm:entry-point\\\") class _RawReceivePortImpl implements RawReceivePort { // Called from the VM to retrieve the handler and handle a message. @pragma(\\\"vm:entry-point\\\", \\\"call\\\") static _handleMessage(int id, var message) { final handler = _portMap[id]?['handler']; if (handler == null) { return null; } // TODO(floitsch): this relies on the fact that any exception aborts the // VM. Once we have non-fatal global exceptions we need to catch errors // so that we can run the immediate callbacks. handler(message); _runPendingImmediateCallback(); return handler; } } \",\"注意这里的关键代码，在_handleMessage方法中，会先执行RawReceivePort原本的handler内容，然后，执行_runPendingImmediateCallback()。\",\"在_runPendingImmediateCallback则会执行_pendingImmediateCallback的内容，也就是前面的_startMicrotaskLoop，处理event loop中的micro task。\",\"这也就证明了我们之前说的“microtask会在同步方法之后立即执行，并在每次普通的event loop执行完毕之后，都会检查并执行event loop中的microtask，之后才继续执行普通event”。\",\"在下面的分析中，我们也还可以看到，在event每次处理Timer事件之后，都会检查执行micro task。\",\"除了下面列出来的使用Future或者Timer等创建的方法外，屏幕点击、刷新等事件也在此类event中。\",\"当前event loop中没有micro task之后，就会执行一次此类普通event，然后再检查一次event loop，如果有micro task就执行micro task直到清空micro task，否则继续执行下一个普通event，直到event loop列表为空，退出app。\",\"先看几种会触发此类事件的方法：\",\"Future.delayed(const Duration(seconds: 1), () { print(\\\"Hello, I am future\\\"); }); Future.any([ Future(() { return \\\"I am Future run immediately Future.any\\\"; }), Future.delayed(const Duration(seconds: 1), () { return \\\"I am Future run delay, will be discard Future.any\\\"; }) ]).then((value) => print(value)); Future.wait([ Future(() { return \\\"I am Future run immediately Future.wait 1/2\\\"; }), Future.delayed(const Duration(seconds: 1), () { return \\\"I am Future run delay Future.wait 2/2\\\"; }) ]).then((value) => print(value)); \",\"以及Timer\",\"Timer.periodic(const Duration(seconds: 1), (timer) { print(\\\"Hello, I am running inner(${timer.tick}/2) Timer.periodic\\\"); if (timer.tick == 2) { timer.cancel(); } }); Timer.run(() { print( \\\"Hello, I will run asynchronously as soon as possible with Timer.run\\\"); }); Timer(Duration(seconds: 1), () { print(\\\"Hello, I will run asynchronously after 1 second with Timer\\\"); }); \"]},\"102\":{\"h\":\"代码分析\",\"t\":[\"我们依次看一下上述几个方法的具体实现：\",\"// -> sdk\\\\lib\\\\async\\\\future.dart factory Future.delayed(Duration duration, [FutureOr<T> computation()?]) { if (computation == null && !typeAcceptsNull<T>()) { throw ArgumentError.value( null, \\\"computation\\\", \\\"The type parameter is not nullable\\\"); } _Future<T> result = new _Future<T>(); new Timer(duration, () { if (computation == null) { result._complete(null as T); } else { try { result._complete(computation()); } catch (e, s) { _completeWithErrorCallback(result, e, s); } } }); return result; } static Future<T> any<T>(Iterable<Future<T>> futures) { var completer = new Completer<T>.sync(); void onValue(T value) { if (!completer.isCompleted) completer.complete(value); } void onError(Object error, StackTrace stack) { if (!completer.isCompleted) completer.completeError(error, stack); } for (var future in futures) { // 一旦有一个future执行完毕，就立即返回结果，并丢弃掉后续future的返回 future.then(onValue, onError: onError); } return completer.future; } @pragma(\\\"vm:recognized\\\", \\\"other\\\") static Future<List<T>> wait<T>(Iterable<Future<T>> futures, {bool eagerError = false, void cleanUp(T successValue)?}) { // This is a VM recognised method, and the _future variable is deliberately // allocated in a specific slot in the closure context for stack unwinding. final _Future<List<T>> _future = _Future<List<T>>(); List<T?>? values; // Collects the values. Set to null on error. int remaining = 0; // How many futures are we waiting for. late Object error; // The first error from a future. late StackTrace stackTrace; // The stackTrace that came with the error. // Handle an error from any of the futures. void handleError(Object theError, StackTrace theStackTrace) { remaining--; List<T?>? valueList = values; if (valueList != null) { if (cleanUp != null) { for (var value in valueList) { if (value != null) { // Ensure errors from cleanUp are uncaught. T cleanUpValue = value; new Future.sync(() { cleanUp(cleanUpValue); }); } } } values = null; if (remaining == 0 || eagerError) { _future._completeError(theError, theStackTrace); } else { error = theError; stackTrace = theStackTrace; } } else if (remaining == 0 && !eagerError) { _future._completeError(error, stackTrace); } } try { // As each future completes, put its value into the corresponding // position in the list of values. for (var future in futures) { int pos = remaining; // 在这里依次执行future future.then((T value) { remaining--; List<T?>? valueList = values; if (valueList != null) { valueList[pos] = value; if (remaining == 0) { _future._completeWithValue(List<T>.from(valueList)); } } else { if (cleanUp != null && value != null) { // Ensure errors from cleanUp are uncaught. new Future.sync(() { cleanUp(value); }); } if (remaining == 0 && !eagerError) { // If eagerError is false, and valueList is null, then // error and stackTrace have been set in handleError above. _future._completeError(error, stackTrace); } } }, onError: handleError); // Increment the 'remaining' after the call to 'then'. // If that call throws, we don't expect any future callback from // the future, and we also don't increment remaining. remaining++; } if (remaining == 0) { return _future.._completeWithValue(<T>[]); } values = new List<T?>.filled(remaining, null); } catch (e, st) { // The error must have been thrown while iterating over the futures // list, or while installing a callback handler on the future. // This is a breach of the `Future` protocol, but we try to handle it // gracefully. if (remaining == 0 || eagerError) { // Throw a new Future.error. // Don't just call `_future._completeError` since that would propagate // the error too eagerly, not giving the callers time to install // error handlers. // Also, don't use `_asyncCompleteError` since that one doesn't give // zones the chance to intercept the error. return new Future.error(e, st); } else { // Don't allocate a list for values, thus indicating that there was an // error. // Set error to the caught exception. error = e; stackTrace = st; } } return _future; } \",\"可以看到，除了Future.wait和Future.any这两个处理Future集合的方法外，Future.delayed 这个方法内部是实际上是通过Timer实现**的。\"]},\"103\":{\"h\":\"Future.then\",\"t\":[\"在看Timer实现之前，先看一下Futrue.then的实现,他对应的实现是_Future.then：\",\"// -> sdk\\\\lib\\\\async\\\\future_impl.dart class _Future<T> implements Future<T> { // Register callbacks to be called when this future completes. // // When this future completes with a value, the [onValue] callback will be called with that value. // If this future is already completed, the callback will not be called immediately, // but will be scheduled in a later microtask Future<R> then<R>(FutureOr<R> f(T value), {Function? onError}) { Zone currentZone = Zone.current; if (identical(currentZone, _rootZone)) { if (onError != null && onError is! Function(Object, StackTrace) && onError is! Function(Object)) { throw ArgumentError.value( onError, \\\"onError\\\", \\\"Error handler must accept one Object or one Object and a StackTrace\\\" \\\" as arguments, and return a value of the returned future's type\\\"); } } else { f = currentZone.registerUnaryCallback<FutureOr<R>, T>(f); if (onError != null) { // This call also checks that onError is assignable to one of: // dynamic Function(Object) // dynamic Function(Object, StackTrace) onError = _registerErrorHandler(onError, currentZone); } } _Future<R> result = new _Future<R>(); _addListener(new _FutureListener<T, R>.then(result, f, onError)); // 返回创建好的Future return result; } } \",\"_Futrue.then只是对传入的回调的进行了包装，实际上是通过_Future._addListener()实现具体的逻辑：\",\"// -> sdk\\\\lib\\\\async\\\\future_impl.dart bool get _mayComplete => (_state & _completionStateMask) == _stateIncomplete; bool get _isPendingComplete => (_state & _statePendingComplete) != 0; bool get _mayAddListener => _state <= (_statePendingComplete | _stateIgnoreError); void _addListener(_FutureListener listener) { assert(listener._nextListener == null); // 如果是待完成的或者忽略错误的,将当前listener添加到链表头部； // 在后文处理结果的时候，会从链表尾部开始读取 if (_mayAddListener) { listener._nextListener = _resultOrListeners; _resultOrListeners = listener; } else { if (_isChained) { // Delegate listeners to chained source future. // If the source is complete, instead copy its values and // drop the chaining. _Future source = _chainSource; if (!source._isComplete) { // 如果依赖于source，那么就添加为source的listener source._addListener(listener); return; } _cloneResult(source); } assert(_isComplete); // Handle late listeners asynchronously. _zone.scheduleMicrotask(() { // Propagates the value/error of [source] to its [listeners] _propagateToListeners(this, listener); }); } } \",\"在_Future._addListener(_FutureListener listener)中基本上做了如下判断：\",\"如果Future是延迟完成的，就添加监听。\",\"如果Future已经完成了，就加入到micro task中，安排执行listener回调（_propagateToListeners(this, listener)）。\",\"具体可以参考Flutter之Future原理解析。\"]},\"104\":{\"h\":\"Timer\",\"t\":[\"我们再看一下Timer的实现：\",\"// -> sdk\\\\lib\\\\async\\\\timer.dart // Timer.run static void run(void Function() callback) { new Timer(Duration.zero, callback); } factory Timer(Duration duration, void Function() callback) { if (Zone.current == Zone.root) { // No need to bind the callback. We know that the root's timer will // be invoked in the root zone. return Zone.current.createTimer(duration, callback); } return Zone.current .createTimer(duration, Zone.current.bindCallbackGuarded(callback)); } factory Timer.periodic(Duration duration, void callback(Timer timer)) { if (Zone.current == Zone.root) { // No need to bind the callback. We know that the root's timer will // be invoked in the root zone. return Zone.current.createPeriodicTimer(duration, callback); } var boundCallback = Zone.current.bindUnaryCallbackGuarded<Timer>(callback); return Zone.current.createPeriodicTimer(duration, boundCallback); } \"]},\"105\":{\"h\":\"创建Timer\",\"t\":[\"可以看到，Timer的创建实际上是Zone通过两种方式创建的：\",\"// -> sdk\\\\lib\\\\async\\\\zone.dart abstract class Zone { /// Creates a [Timer] where the callback is executed in this zone. Timer createTimer(Duration duration, void Function() callback); /// Creates a periodic [Timer] where the callback is executed in this zone. Timer createPeriodicTimer(Duration period, void callback(Timer timer)); } \",\"Zone是抽象类，他的实现是_RootZone：\",\"// -> sdk\\\\lib\\\\async\\\\zone.dart class _RootZone extends _Zone { Timer createTimer(Duration duration, void f()) { return Timer._createTimer(duration, f); } Timer createPeriodicTimer(Duration duration, void f(Timer timer)) { return Timer._createPeriodicTimer(duration, f); } } \",\"可以看到这里实际上是调用了Timer中对应的私有方法：\",\"// -> sdk\\\\lib\\\\async\\\\timer.dart external static Timer _createTimer( Duration duration, void Function() callback); external static Timer _createPeriodicTimer( Duration duration, void callback(Timer timer)); \",\"他们的具体实现在timer_patch.dart中：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_patch.dart @patch class Timer { @patch static Timer _createTimer(Duration duration, void callback()) { final factory = VMLibraryHooks.timerFactory; if (factory == null) { throw new UnsupportedError(\\\"Timer interface not supported.\\\"); } int milliseconds = duration.inMilliseconds; if (milliseconds < 0) milliseconds = 0; return factory(milliseconds, (_) { callback(); }, false); } @patch static Timer _createPeriodicTimer( Duration duration, void callback(Timer timer)) { final factory = VMLibraryHooks.timerFactory; if (factory == null) { throw new UnsupportedError(\\\"Timer interface not supported.\\\"); } int milliseconds = duration.inMilliseconds; if (milliseconds < 0) milliseconds = 0; return factory(milliseconds, callback, true); } } \",\"可以看到，无论是单次的还是循环的Timer都是使用VMLibraryHooks.timerFactory创建的：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_impl.dart @pragma(\\\"vm:entry-point\\\", \\\"call\\\") _setupHooks() { VMLibraryHooks.timerFactory = _Timer._factory; } // The Timer factory registered with the dart:async library by the embedder. static Timer _factory( int milliSeconds, void callback(Timer timer), bool repeating) { if (repeating) { return new _Timer.periodic(milliSeconds, callback); } return new _Timer(milliSeconds, callback); } factory _Timer(int milliSeconds, void callback(Timer timer)) { return _createTimer(callback, milliSeconds, false); } factory _Timer.periodic(int milliSeconds, void callback(Timer timer)) { return _createTimer(callback, milliSeconds, true); } \",\"最终都是调用的_Timer._createTimer方法：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_impl.dart static _Timer _createTimer( void callback(Timer timer), int milliSeconds, bool repeating) { // Negative timeouts are treated as if 0 timeout. if (milliSeconds < 0) { milliSeconds = 0; } // Add one because DateTime.now() is assumed to round down // to nearest millisecond, not up, so that time + duration is before // duration milliseconds from now. Using microsecond timers like // Stopwatch allows detecting that the timer fires early. int now = VMLibraryHooks.timerMillisecondClock(); int wakeupTime = (milliSeconds == 0) ? now : (now + 1 + milliSeconds); _Timer timer = new _Timer._internal(callback, wakeupTime, milliSeconds, repeating); // Enqueue this newly created timer in the appropriate structure and // notify if necessary. timer._enqueue(); return timer; } \",\"在创建timer的时候，先获取了当前的时间戳，然后计算出timer的唤醒时间wakeupTime ，最后调用_Timer._internal创建timer。\",\"_Timer._internal只是简单创建了Timer:\",\"_Timer._internal( this._callback, this._wakeupTime, this._milliSeconds, this._repeating) : _id = _nextId(); \",\"在创建根据需要创建好Timer之后，使用_Timer._enqueue方法把Timer放入到相应的队列中。\"]},\"106\":{\"h\":\"timer._enqueue\",\"t\":[\"主要看一下timer._enqueue()方法的实现：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_impl.dart // Timers are ordered by wakeup time. Timers with a timeout value of > 0 do // end up on the TimerHeap. Timers with a timeout of 0 are queued in a list. static final _heap = new _TimerHeap(); static _Timer? _firstZeroTimer; static _Timer _lastZeroTimer = _sentinelTimer; // Adds a timer to the heap or timer list. Timers with the same wakeup time // are enqueued in order and notified in FIFO order. void _enqueue() { if (_milliSeconds == 0) { if (_firstZeroTimer == null) { _lastZeroTimer = this; _firstZeroTimer = this; } else { _lastZeroTimer._indexOrNext = this; _lastZeroTimer = this; } // Every zero timer gets its own event. _notifyZeroHandler(); } else { _heap.add(this); if (_heap.isFirst(this)) { _notifyEventHandler(); } } } \",\"可以看到无论是单次还是循环的Timer最后都是使用_Timer._internal创建的，然后再使用_Timer._enqueue()方法将timer添加到heap或者timer list中：\",\"如果Timer的_milliSeconds为0，则会被添加到_lastZeroTimer中（并将上一个timer的_indexOrNext指向自己），并在_notifyZeroHandler()方法发送_ZERO_EVENT事件（最终会触发_Timer._handleMessage ）；\",\"否则则将其加入到_heap中，如果他是第一个timer，就通过_notifyEventHandler()启动处理Timer的event handler（这个线程会在合适的时间唤起Timer执行_Timer._handleMessage方法）。\",\"在具体分析整个过程之前，我们先看一下几个属性的创建过程：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_impl.dart class _Timer implements Timer { static _RawReceivePortImpl? _receivePort; static SendPort? _sendPort; // Tell the event handler to wake this isolate at a specific time. static void _scheduleWakeup(int wakeupTime) { if (!_receivePortActive) { _createTimerHandler(); } VMLibraryHooks.eventHandlerSendData(null, _sendPort!, wakeupTime); _scheduledWakeupTime = wakeupTime; } // Enqueue one message for each zero timer. To be able to distinguish from // EventHandler messages we send a _ZERO_EVENT instead of a _TIMEOUT_EVENT. static void _notifyZeroHandler() { if (!_receivePortActive) { _createTimerHandler(); } _sendPort!.send(_ZERO_EVENT); } // Create a receive port and register a message handler for the timer // events. static void _createTimerHandler() { var receivePort = _receivePort; if (receivePort == null) { assert(_sendPort == null); final port = _RawReceivePortImpl('Timer'); port.handler = _handleMessage; _sendPort = port.sendPort; _receivePort = port; _scheduledWakeupTime = 0; } else { receivePort._setActive(true); } _receivePortActive = true; } } \",\"从上面代码我们可以看到：\",\"_sendPort是_receivePort对应的sendPort，后者的handler是_handleMessage()方法\",\"无论是_notifyEventHandler()还是 _notifyZeroHandler()都会保证_createTimerHandler()被调用过。\"]},\"107\":{\"h\":\"_milliSeconds == 0\",\"t\":[\"先看一下_milliSeconds为0的情况：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_impl.dart // Enqueue one message for each zero timer. To be able to distinguish from // EventHandler messages we send a _ZERO_EVENT instead of a _TIMEOUT_EVENT. static void _notifyZeroHandler() { if (!_receivePortActive) { _createTimerHandler(); } _sendPort!.send(_ZERO_EVENT); } \",\"按照上面的分析，_sendPort!.send(_ZERO_EVENT)发送的消息，通过MessageHandler::PostMessage处理，最后调用_receivePort的handler也就是在_handleMessage(msg)方法中执行。\"]},\"108\":{\"h\":\"_milliSeconds ≠ 0\",\"t\":[\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_impl.dart static void _notifyEventHandler() { if (_handlingCallbacks) { // While we are already handling callbacks we will not notify the event // handler. _handleTimeout will call _notifyEventHandler once all pending // timers are processed. return; } // If there are no pending timers. Close down the receive port. if ((_firstZeroTimer == null) && _heap.isEmpty) { // No pending timers: Close the receive port and let the event handler // know. if (_sendPort != null) { _cancelWakeup(); _shutdownTimerHandler(); } return; } else if (_heap.isEmpty) { // Only zero timers are left. Cancel any scheduled wakeups. _cancelWakeup(); return; } // Only send a message if the requested wakeup time differs from the // already scheduled wakeup time. var wakeupTime = _heap.first._wakeupTime; if ((_scheduledWakeupTime == 0) || (wakeupTime != _scheduledWakeupTime)) { _scheduleWakeup(wakeupTime); } } // Tell the event handler to wake this isolate at a specific time. static void _scheduleWakeup(int wakeupTime) { if (!_receivePortActive) { _createTimerHandler(); } VMLibraryHooks.eventHandlerSendData(null, _sendPort!, wakeupTime); _scheduledWakeupTime = wakeupTime; } \",\"可见，当_milliSeconds ≠ 0的时候，会将其加入到_heap中，如果当前的timer是_heap中第一个，则调用_notifyEventHandler()告诉event handler在指定的时间唤起isolate。\",\"这里主要的实现是VMLibraryHooks.eventHandlerSendData，他的实现如下：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\bin\\\\common_patch.dart @pragma(\\\"vm:entry-point\\\", \\\"call\\\") _setupHooks() { VMLibraryHooks.eventHandlerSendData = _EventHandler._sendData; VMLibraryHooks.timerMillisecondClock = _EventHandler._timerMillisecondClock; } // -> sdk\\\\lib\\\\_internal\\\\vm\\\\bin\\\\eventhandler_patch.dart @patch class _EventHandler { @patch @pragma(\\\"vm:external-name\\\", \\\"EventHandler_SendData\\\") external static void _sendData(Object? sender, SendPort sendPort, int data); @pragma(\\\"vm:external-name\\\", \\\"EventHandler_TimerMillisecondClock\\\") external static int _timerMillisecondClock(); } // -> runtime\\\\bin\\\\eventhandler.cc /* * Send data to the EventHandler thread to register for a given instance * args[0] a ReceivePort args[1] with a notification event args[2]. */ void FUNCTION_NAME(EventHandler_SendData)(Dart_NativeArguments args) { // Get the id out of the send port. If the handle is not a send port // we will get an error and propagate that out. Dart_Handle handle = Dart_GetNativeArgument(args, 1); Dart_Port dart_port; handle = Dart_SendPortGetId(handle, &dart_port); if (Dart_IsError(handle)) { Dart_PropagateError(handle); UNREACHABLE(); } Dart_Handle sender = Dart_GetNativeArgument(args, 0); intptr_t id; if (Dart_IsNull(sender)) { id = kTimerId; } else { Socket* socket = Socket::GetSocketIdNativeField(sender); ASSERT(dart_port != ILLEGAL_PORT); socket->set_port(dart_port); socket->Retain(); // inc refcount before sending to the eventhandler. id = reinterpret_cast<intptr_t>(socket); } int64_t data = DartUtils::GetIntegerValue(Dart_GetNativeArgument(args, 2)); event_handler->SendData(id, dart_port, data); } \",\"他的实现在native层的EventHander中名为event handler的子线程中通过异步IO执行任务：\",\"// -> class EventHandler { public: EventHandler() {} void SendData(intptr_t id, Dart_Port dart_port, int64_t data) { delegate_.SendData(id, dart_port, data); } } \",\"不同的系统实现不同，对于Android来说：\",\"// -> runtime\\\\bin\\\\eventhandler_android.cc void EventHandlerImplementation::SendData(intptr_t id, Dart_Port dart_port, int64_t data) { WakeupHandler(id, dart_port, data); } void EventHandlerImplementation::WakeupHandler(intptr_t id, Dart_Port dart_port, int64_t data) { InterruptMessage msg; msg.id = id; msg.dart_port = dart_port; msg.data = data; // WriteToBlocking will write up to 512 bytes atomically, and since our msg // is smaller than 512, we don't need a thread lock. // See: http://linux.die.net/man/7/pipe, section 'Pipe_buf'. ASSERT(kInterruptMessageSize < PIPE_BUF); intptr_t result = FDUtils::WriteToBlocking(interrupt_fds_[1], &msg, kInterruptMessageSize); if (result != kInterruptMessageSize) { if (result == -1) { perror(\\\"Interrupt message failure:\\\"); } FATAL1(\\\"Interrupt message failure. Wrote %\\\" Pd \\\" bytes.\\\", result); } } \",\"然后系统会在时间到了之后，会调用EventHandlerImplementation::HandleEvents通过_send_port发送消息，并触发_receivePort的hander也就是_handleMessage方法处理消息。\"]},\"109\":{\"h\":\"_handleMessage\",\"t\":[\"无论是_milliSeconds == 0 的时候_sendPort!.send(_ZERO_EVENT);，还是_milliSeconds != 0 通过EventHandler发送_TIMEOUT_EVENT消息，最终都会使用_handleMessage处理消息：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_impl.dart static void _handleMessage(msg) { List<_Timer> pendingTimers; if (msg == _ZERO_EVENT) { pendingTimers = _queueFromZeroEvent(); assert(pendingTimers.length > 0); } else { assert(msg == _TIMEOUT_EVENT); _scheduledWakeupTime = 0; // Consumed the last scheduled wakeup now. pendingTimers = _queueFromTimeoutEvent(); } _runTimers(pendingTimers); // Notify the event handler or shutdown the port if no more pending // timers are present. _notifyEventHandler(); } \",\"在_handleMessage中按照msg的类型取出对应的pendingTimers然后再_runTimers中执行，在执行完毕或者遇到错误时，调用_notifyEventHandler()通知event handler或者关闭TimerHandler：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\timer_impl.dart static void _runTimers(List<_Timer> pendingTimers) { // If there are no pending timers currently reset the id space before we // have a chance to enqueue new timers. if (_heap.isEmpty && (_firstZeroTimer == null)) { _idCount = 0; } // Fast exit if no pending timers. if (pendingTimers.length == 0) { return; } // Trigger all of the pending timers. New timers added as part of the // callbacks will be enqueued now and notified in the next spin at the // earliest. _handlingCallbacks = true; var i = 0; try { // 在这里遍历处理所有的pendingTimers for (; i < pendingTimers.length; i++) { // Next pending timer. var timer = pendingTimers[i]; timer._indexOrNext = null; // One of the timers in the pending_timers list can cancel // one of the later timers which will set the callback to // null. Or the pending zero timer has been canceled earlier. var callback = timer._callback; if (callback != null) { if (!timer._repeating) { // Mark timer as inactive. timer._callback = null; } else if (timer._milliSeconds > 0) { var ms = timer._milliSeconds; int overdue = VMLibraryHooks.timerMillisecondClock() - timer._wakeupTime; if (overdue > ms) { int missedTicks = overdue ~/ ms; timer._wakeupTime += missedTicks * ms; timer._tick += missedTicks; } } timer._tick += 1; callback(timer); // Re-insert repeating timer if not canceled. if (timer._repeating && (timer._callback != null)) { timer._advanceWakeupTime(); timer._enqueue(); } // 每次执行完event之后，都要执行没有被执行的micro task // Execute pending micro tasks. _runPendingImmediateCallback(); } } } finally { _handlingCallbacks = false; // Re-queue timers we didn't get to. for (i++; i < pendingTimers.length; i++) { var timer = pendingTimers[i]; timer._enqueue(); } _notifyEventHandler(); } } \",\"这里可以看到，这里依次遍历传入的pendingTimers，并在每次执行完event后，去检查执行一下micro task。\",\"根据创建Timer的时候_milliSeconds是否等于0：会分别使用MessageHandler执行或者在名为event handler的IO线程通过isolate中的MessageHandler来执行任务；最后都会触发Timer的_handleMessage方法在_runTimers方法中执行callback。\",\"综上，dart中的方法总共有3种，按照优先级从前到后依次是：\",\"普通的同步方法\",\"micro task\",\"其他event：部分Future、Timer、点击事件、屏幕刷新等\",\"在方法执行的时候：\",\"先执行完毕所有的同步方法；\",\"然后判断是否有micro task，有的话就立即执行；\",\"否则，就执行普通的event，每次执行完一个event就执行一次步骤2；\",\"直到当前app中既没有micro task也没有普通的event，退出app。\",\"dart sdk\",\"The Event Loop and Dart\",\"Flutter之Future原理解析 - 掘金\",\"Flutter之Timer原理解析 - 掘金\",\"Dart 官网\"]},\"110\":{\"h\":\"Dart 读取文件过程分析\",\"t\":[\"Dart读取文件时，先在Dart代码创建File引用，通过与IOService跨Isolate通信（先通过IO Service而发送请求到native端，等到native执行完操作之后再回调结果）从而实现对文件的读写。\",\"实现一个简单的读取文件的代码如下：\",\"import 'dart:io'; main() { var filePath = r\\\"G:/21996.1.210529-1541.co_release_CLIENT_CONSUMER_x64FRE_en-us.iso\\\"; var file = File(filePath); var startTime = printCurrentTimeMs(\\\"start run file.readAsBytes\\\"); file.readAsBytes().then((value) { printCurrentTimeMs(\\\"file.readAsBytes() finish\\\", lastTimeMs: startTime, suffix: \\\"\\\\nfile.readAsBytes() result:${value.length}\\\"); }); printCurrentTimeMs(\\\"finish run file.readAsBytes\\\"); } int printCurrentTimeMs(String prefix, {String? suffix, int? lastTimeMs}) { var currentTimeMs = DateTime.now().millisecondsSinceEpoch; var timeElapseString = lastTimeMs == null ? \\\"\\\" : \\\", time elapse:${currentTimeMs - lastTimeMs}ms \\\"; print( \\\"$prefix current time($currentTimeMs)$timeElapseString${suffix ?? \\\"\\\"}\\\"); return currentTimeMs; } \",\"整个过程如下：\"]},\"111\":{\"h\":\"Dart端发起文件读写请求\",\"t\":[\"其中file.readAsBytes() 是具体执行读取文件的地方，他的定义如下：\",\"// -> sdk\\\\lib\\\\io\\\\file_impl.dart Future<Uint8List> readAsBytes(); \",\"在我们创建File时，实际上创建的是_File （class _File extends FileSystemEntity implements File）对象：\",\"// -> sdk\\\\lib\\\\io\\\\file_impl.dart // abstract class File implements FileSystemEntity @pragma(\\\"vm:entry-point\\\") factory File(String path) { final IOOverrides? overrides = IOOverrides.current; if (overrides == null) { return new _File(path); } return overrides.createFile(path); } \",\"_File 是File 的实现类，所以file.readAsBytes()实际调用的是_File 实现的方法：\",\"// -> sdk\\\\lib\\\\io\\\\file_impl.dart // Read the file in blocks of size 64k. const int _blockSize = 64 * 1024; class _File extends FileSystemEntity implements File { Future<Uint8List> readAsBytes() { Future<Uint8List> readDataChunked(RandomAccessFile file) { // 分段读取文件，每次只读取_blockSize大小的内容 var builder = new BytesBuilder(copy: false); var completer = new Completer<Uint8List>(); void read() { // 每次只异步读取一部分文本 file.read(_blockSize).then((data) { if (data.length > 0) { builder.add(data); read(); } else { completer.complete(builder.takeBytes()); } }, onError: completer.completeError); } read(); return completer.future; } return open().then((file) { return file.length().then((length) { if (length == 0) { // May be character device, try to read it in chunks. return readDataChunked(file); } return file.read(length); }).whenComplete(file.close); }); } } \",\"可以看到，无论是普通的文件格式，还是character device，最后都是调用了_RandomAccessFile的open()和read(int bytes)方法异步读取文件。\",\"设备文件分为Block Device Driver和Character Device Drive两类。 Character Device Driver又被称为字符设备或裸设备raw devices; Block Device Driver通常成为块设备。 而Block Device Driver是以固定大小长度来传送转移资料 ； Character Device Driver是以不定长度的字元传送资料。 https://www.cnblogs.com/qlee/archive/2011/07/27/2118406.html#:~:text=Character\",\"// -> flutter\\\\bin\\\\cache\\\\pkg\\\\sky_engine\\\\lib\\\\io\\\\file_impl.dart class _RandomAccessFile implements RandomAccessFile { final String path; bool _asyncDispatched = false; // 读取文件的信息 late _FileResourceInfo _resourceInfo; // 对文件的操作引用 _RandomAccessFileOps _ops; @pragma(\\\"vm:entry-point\\\") _RandomAccessFile(int pointer, this.path) : _ops = new _RandomAccessFileOps(pointer) { _resourceInfo = new _FileResourceInfo(this); _maybeConnectHandler(); } // 异步读取文件 Future<Uint8List> read(int bytes) { // TODO(40614): Remove once non-nullability is sound. ArgumentError.checkNotNull(bytes, \\\"bytes\\\"); // 异步读取文件，实际上是将发送指令到IO Service，然后等待返回结果 return _dispatch(_IOService.fileRead, [null, bytes]).then((response) { if (_isErrorResponse(response)) { throw _exceptionFromResponse(response, \\\"read failed\\\", path); } _resourceInfo.addRead(response[1].length); // 读取的文件内容 Uint8List result = response[1]; return result; }); } // 同步读取文件 Uint8List readSync(int bytes) { // TODO(40614): Remove once non-nullability is sound. ArgumentError.checkNotNull(bytes, \\\"bytes\\\"); _checkAvailable(); // 同步读取文件是对文件直接操作 var result = _ops.read(bytes); if (result is OSError) { throw new FileSystemException(\\\"readSync failed\\\", path, result); } _resourceInfo.addRead(result.length); return result; } Future<RandomAccessFile> open({FileMode mode = FileMode.read}) { // FileMode https://github.com/dart-lang/sdk/blob/main/sdk/lib/io/io_service.dart if (mode != FileMode.read && mode != FileMode.write && mode != FileMode.append && mode != FileMode.writeOnly && mode != FileMode.writeOnlyAppend) { return new Future.error( new ArgumentError('Invalid file mode for this operation')); } return _dispatchWithNamespace( // 请求操作为“打开文件”，参数为：null，文件路径，操作文件的mode _IOService.fileOpen, [null, _rawPath, mode._mode]).then((response) { if (_isErrorResponse(response)) { throw _exceptionFromResponse(response, \\\"Cannot open file\\\", path); } // 从IO Service那里异步获得文件句柄response和path return new _RandomAccessFile(response, path); }); } } \",\"在_RandomAccessFile中，除了同步读写文件是对返回的文件引用直接操作外，很多操作都能看到通过_dispatch()方法与IO Service通信，让我们看一下这个方法的实现：\",\"// -> sdk\\\\lib\\\\io\\\\file_impl.dart // _RandomAccessFile Future _dispatch(int request, List data, {bool markClosed = false}) { if (closed) { return new Future.error(new FileSystemException(\\\"File closed\\\", path)); } if (_asyncDispatched) { var msg = \\\"An async operation is currently pending\\\"; return new Future.error(new FileSystemException(msg, path)); } if (markClosed) { // Set closed to true to ensure that no more async requests can be issued // for this file. closed = true; } _asyncDispatched = true; data[0] = _pointer(); // 主要代码在这里，通过_IOService的_dispatch发送指令 return **_IOService._dispatch**(request, data).whenComplete(() { _asyncDispatched = false; }); } // open create之类的操作会调用这个方法，不过最后也是调用_IOService._dispatch(request, data)通信 static Future _dispatchWithNamespace(int request, List data) { data[0] = _namespacePointer(); // 与IO Service进行异步通信，request标记请求操作的类型，data则是数据 return **_IOService._dispatch**(request, data); } \",\"查阅_IOService的源码后发现这是个external 方法.\",\"external static Future _dispatch(int request, List data); \",\"An external function is connected to its body by an implementation-specific mechanism. Attempting to invoke an external function that has not been connected to its body will throw a NoSuchMethodError or some subclass thereof. ****https://github.com/dart-lang/sdk/issues/4300\",\"根据external的定义，_dispatch方法在不同的机器上面实现不同。我们只看和app相关的实现（在sdk\\\\lib\\\\_internal\\\\vm目录下，vm同级目录还有js等实现），具体的实现如下：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\bin\\\\io_service_patch.dart // _IOService class _IOService { // 用于向IO Service发送消息 static _IOServicePorts _servicePorts = new _IOServicePorts(); // We use a static variable here to hold onto the last result of // calling the IO Service frome the native. static RawReceivePort? _receivePort; // the other side(other isolate) will send message back with the _replyToPort static late SendPort _replyToPort; // a map holding the registered callbacks for each received message. static HashMap<int, Completer> _messageMap = new HashMap<int, Completer>(); static int _id = 0; /// [request] IO操作的类型，具体值在[sdk/lib/io/io_service.dart]中的_IOService类中定义 /// 主要有对文件、目录、网络进行操作的请求 /// [data] 对应的数据，如果是文件，则是文件路径，如果是目录，则是目录路径等等 @patch static Future _dispatch(int request, List data) { int id; do { // create a special id to identify the request. id = _getNextId(); } while (_messageMap.containsKey(id)); // 通过_servicePorts获取一个新的SendPort以便向IOService发送消息， // 这个SendPort是IO Service返回给dart用来向他发消息的 final SendPort servicePort = _servicePorts._getPort(id); _ensureInitialize(); final Completer completer = new Completer(); _messageMap[id] = completer; try { // 向IOService发送消息，当request执行完毕之后， // 会调用_replyToPort触发在root zone的回调_receivePort!.handler **servicePort**.send(<dynamic>[id, **_replyToPort**, request, data]); } catch (error) { _messageMap.remove(id)!.complete(error); if (_messageMap.length == 0) { _finalize(); } } return completer.future; } static void _ensureInitialize() { if (_receivePort == null) { _receivePort = new RawReceivePort(null, 'IO Service'); // 其他地方可以使用_replyToPort来发消息触发_receivePort 执行handler方法 _replyToPort = _receivePort!.sendPort; _receivePort!.handler = (data) { // 在这里处理IOService执行完方法返回的数据 assert(data is List && data.length == 2); // data[0]就是我们在_dispatch方法中获取的id， // 将处理结果data[1]通过Completer.complete返回 _messageMap.remove(data[0])!.complete(data[1]); // 释放这个触发这个回调的SendPort _servicePorts._returnPort(data[0]); if (_messageMap.length == 0) { _finalize(); } }; } } ... } \",\"可以看到，最后是通过RawReceivePort/SendPort进行跨Isolate通信。\",\"_IOService使用_servicePorts对native层发送消息触发IO操作，然后使用_receivePort监听，当IO操作完成时会通过_replyToPort 回调结果，会在 _receivePort!.handler方法中根据当时请求的id找到Completer将结果传递回去。\",\"这样当时我们在 file.readAsBytes()时获取到的Future便会收到回调，从而完成文件操作的流程。\",\" file.readAsBytes().then((value) { printCurrentTimeMs(\\\"file.readAsBytes() finish\\\", lastTimeMs: startTime, suffix: \\\"\\\\nfile.readAsBytes() result:${value.length}\\\"); }); \",\"下面是到目前为止涉及到的类关系示意图：\"]},\"112\":{\"h\":\"IO Service中转\",\"t\":[\"那么，这个IO Service是做什么的，他又是如何实现与dart中的调用方双向通信，以及执行调用方需要的功能呢？\",\"位于sdk\\\\lib\\\\_internal\\\\vm\\\\bin\\\\io_service_patch.dart的_IOService是一个中转站，向上承接来自Dart代码的IO请求指令（先行返回Future），向下将这些指令转发至Native层的IO Service，并监听回调，当native层处理完这些IO指令之后，将结果通过Future返回给Dart调用方。\",\"让我们再看一下他的具体实现：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\bin\\\\io_service_patch.dart // _IOService class _IOService { // 用于向IO Service发送消息 static _IOServicePorts _servicePorts = new _IOServicePorts(); // We use a static variable here to hold onto the last result of // calling the IO Service frome the native. static RawReceivePort? _receivePort; // the other side(other isolate) will send message back with the _replyToPort static late SendPort _replyToPort; // a map holding the registered callbacks for each received message. static HashMap<int, Completer> _messageMap = new HashMap<int, Completer>(); static int _id = 0; /// [request] IO操作的类型，具体值在[sdk/lib/io/io_service.dart]中的_IOService类中定义 /// 主要有对文件、目录、网络进行操作的请求 /// [data] 对应的数据，如果是文件，则是文件路径，如果是目录，则是目录路径等等 @patch static Future _dispatch(int request, List data) { int id; do { // create a special id to identify the request. id = _getNextId(); } while (_messageMap.containsKey(id)); // 通过_servicePorts获取一个新的SendPort以便向IOService发送消息， // 这个SendPort是IO Service返回给dart用来向他发消息的 final SendPort **servicePort** = _servicePorts.**_getPort(id);** _ensureInitialize(); final Completer completer = new Completer(); _messageMap[id] = completer; try { // 向IOService发送消息，当request执行完毕之后， // 会调用_replyToPort触发在root zone的回调_receivePort!.handler **servicePort**.send(<dynamic>[id, **_replyToPort**, request, data]); } catch (error) { _messageMap.remove(id)!.complete(error); if (_messageMap.length == 0) { _finalize(); } } return completer.future; } static void _ensureInitialize() { if (_receivePort == null) { _receivePort = new RawReceivePort(null, 'IO Service'); // 其他地方可以使用_replyToPort来发消息触发_receivePort 执行handler方法 _replyToPort = _receivePort!.sendPort; _receivePort!.handler = (data) { // 在这里处理IOService执行完方法返回的数据 assert(data is List && data.length == 2); // data[0]就是我们在_dispatch方法中获取的id， // 将处理结果data[1]通过Completer.complete返回 _messageMap.remove(data[0])!.complete(data[1]); // 释放这个触发这个回调的SendPort _servicePorts._returnPort(data[0]); if (_messageMap.length == 0) { _finalize(); } }; } } ... } \",\"可以看到：\",\"_IOService持有_IOServicePorts _servicePorts以便获取SendPort servicePort和native层通信，\",\"在之前的代码分析中，我们已经知道_IOService还在_ensureInitialize()中监听着RawReceivePort? _receivePort的回调，\",\"这样当_IOService在_dispatch()方法中将_replyToPort（_receivePort的SendPort）传递给servicePort后，一旦native通过_replyToPort发送处理结果，_IOService立马可以收到并通过Completer.complete返回给Dart中的调用方。\",\"上述这些步骤能够实施的关键，在于Dart层的_IOService如何与native层的_IOService关联起来呢？\",\"让我们来分析一下SendPort servicePort的获取过程：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\bin\\\\io_service_patch.dart class _IOService { // 用于向IO Service发送消息 static _IOServicePorts _servicePorts = new _IOServicePorts(); ... } class _IOServicePorts { // We limit the number of IO Service ports per isolate so that we don't // spawn too many threads all at once, which can crash the VM on Windows. static const int maxPorts = 32; List<SendPort> _ports = <SendPort>[]; List<SendPort> _freePorts = <SendPort>[]; Map<int, SendPort> _usedPorts = new HashMap<int, SendPort>(); _IOServicePorts(); SendPort _getPort(int forRequestId) { if (_freePorts.isEmpty && _usedPorts.length < maxPorts) { // 如果没有可用的SendPort,就新建SendPort用于远程服务通信 final SendPort port = **_newServicePort()**; _ports.add(port); _freePorts.add(port); } if (!_freePorts.isEmpty) { // 有空闲SendPort，使用 final SendPort port = _freePorts.removeLast(); assert(!_usedPorts.containsKey(forRequestId)); _usedPorts[forRequestId] = port; return port; } // We have already allocated the max number of ports. Re-use an // existing one. final SendPort port = _ports[forRequestId % maxPorts]; _usedPorts[forRequestId] = port; return port; } // 释放掉占用的port void _returnPort(int forRequestId) { final SendPort port = _usedPorts.remove(forRequestId)!; if (!_usedPorts.values.contains(port)) { _freePorts.add(port); } } @pragma(\\\"vm:external-name\\\", \\\"IOService_NewServicePort\\\") external static SendPort _newServicePort(); } \",\"可以看到这里最后的关键方法是SendPort _newServicePort()，这是一个external方法，在native实现。\"]},\"113\":{\"h\":\"Native处理Dart的指令\"},\"114\":{\"h\":\"IOService_NewServicePort\",\"t\":[\"SendPort是由_newServicePort()方法创建的，这是一个external方法，他的native层实现名称是IOService_NewServicePort：\",\"// -> runtime\\\\bin\\\\io_service.cc void FUNCTION_NAME(IOService_NewServicePort)(Dart_NativeArguments args) { Dart_SetReturnValue(args, Dart_Null()); // 创建一个新的native port Dart_Port service_port = **IOService::GetServicePort();** if (service_port != ILLEGAL_PORT) { // 【注意】这里根据service_port创建了Dart里面的SendPort对象 // Return a send port for the service port. Dart_Handle send_port = Dart_NewSendPort(service_port); // 将当前IOService对应的send_port返回给调用方 Dart_SetReturnValue(args, send_port); } } Dart_Port IOService::GetServicePort() { // 注意这里的参数 // 分别是 native port的名称，收到native port以后得回调方法，是否同时处理 return **Dart_NewNativePort(\\\"IOService\\\", IOServiceCallback, true);** } // -> runtime\\\\include\\\\dart_api.h /** * Returns a new SendPort with the provided port id. * * \\\\param port_id The destination port. * * \\\\return A new SendPort if no errors occurs. Otherwise returns * an error handle. */ DART_EXPORT Dart_Handle Dart_NewSendPort(Dart_Port port_id); \",\"注意，在Dart层的_IOService的SendPort _newServicePort() 方法最后再这里调用了IOService_NewServicePort。\",\"这里主要有3个步骤：\",\"使用Dart_NewNativePort(\\\"IOService\\\", IOServiceCallback, true);创建Dart_Port\",\"使用Dart_NewSendPort将Dart_Port转化为Dart_Handle（也就是Dart中的SendPort）\",\"返回上面创建好的Dart_Handle，Dart代码拿到返回的Dart_Handle也就是SendPort servicePort之后，就可以和native层的IO Service同通信。\",\"接下来我们看一下前2步分别是怎么实现的：\"]},\"115\":{\"h\":\"Dart_NewNativePort\",\"t\":[\"再看一下Dart_NewNativePort的调用参数：\",\"Dart_NewNativePort(\\\"IOService\\\", IOServiceCallback, true); // -> runtime\\\\include\\\\dart_native_api.h // Creates a new native port. When messages are received on this // native port, then they will be dispatched to the provided native // message handler. DART_EXPORT Dart_Port Dart_NewNativePort(const char* name, Dart_NativeMessageHandler handler, bool handle_concurrently); \",\"IOServiceCallback\",\"Dart_NewNativePort总共有3个参数，Dart_NativeMessageHandler handler是当这个Dart_Port收到消息的时候，会被回调的方法，也就是我们通过Dart端的_IOService.dispatch方法的**servicePort**.send(<dynamic>[id, **_replyToPort**, request, data]);语句执行向native发送IO指令时，在native这里真正负责执行的方法：\",\"// -> runtime\\\\bin\\\\io_service.cc void IOServiceCallback(Dart_Port dest_port_id, Dart_CObject* message) { Dart_Port reply_port_id = ILLEGAL_PORT; CObject* response = CObject::IllegalArgumentError(); CObjectArray request(message); // 这里的参数顺序，与Dart层的_IOService(sdk\\\\lib\\\\_internal\\\\vm\\\\bin\\\\io_service_patch.dart)的_dispatch()中的 // **servicePort**.send(<dynamic>[id, **_replyToPort**, request, data]); // 代码中的参数顺序一致 if ((message->type == Dart_CObject_kArray) && (request.Length() == 4) && request[0]->IsInt32() && request[1]->IsSendPort() && request[2]->IsInt32() && request[3]->IsArray()) { CObjectInt32 message_id(request[0]); CObjectSendPort **reply_port**(request[1]); CObjectInt32 request_id(request[2]); CObjectArray data(request[3]); **reply_port_id** = **reply_port**.Value(); // 这里解析完收到的参数后，回去执行对应的文件操作 switch (request_id.Value()) { **IO_SERVICE_REQUEST_LIST(CASE_REQUEST);** default: UNREACHABLE(); } } CObjectArray result(CObject::NewArray(2)); result.SetAt(0, request[0]); // response在上面的IO_SERVICE_REQUEST_LIST执行完毕后就会被赋值 result.SetAt(1, **response**); ASSERT(reply_port_id != ILLEGAL_PORT); **Dart_PostCObject(reply_port_id, result.AsApiCObject());** } #define **CASE_REQUEST**(type, method, id) \\\\ case IOService::k##type##method##Request: \\\\ response = type::method##Request(data); \\\\ break; \",\"IOService具体的执行是在IO_SERVICE_REQUEST_LIST根据解析到的参数执行对应的方法：\",\"// -> runtime\\\\bin\\\\io_service.h // This list must be kept in sync with the list in sdk/lib/io/io_service.dart #define IO_SERVICE_REQUEST_LIST(V) \\\\ V(File, Exists, 0) \\\\ V(File, Create, 1) \\\\ V(File, Delete, 2) \\\\ V(File, Rename, 3) \\\\ V(File, Copy, 4) \\\\ V(File, Open, 5) \\\\ V(File, ResolveSymbolicLinks, 6) \\\\ V(File, Close, 7) \\\\ V(File, Position, 8) \\\\ V(File, SetPosition, 9) \\\\ V(File, Truncate, 10) \\\\ V(File, Length, 11) \\\\ V(File, LengthFromPath, 12) \\\\ V(File, LastAccessed, 13) \\\\ V(File, SetLastAccessed, 14) \\\\ V(File, LastModified, 15) \\\\ V(File, SetLastModified, 16) \\\\ V(File, Flush, 17) \\\\ V(File, ReadByte, 18) \\\\ V(File, WriteByte, 19) \\\\ V(File, Read, 20) \\\\ V(File, ReadInto, 21) \\\\ V(File, WriteFrom, 22) \\\\ V(File, CreateLink, 23) \\\\ V(File, DeleteLink, 24) \\\\ V(File, RenameLink, 25) \\\\ V(File, LinkTarget, 26) \\\\ V(File, Type, 27) \\\\ V(File, Identical, 28) \\\\ V(File, Stat, 29) \\\\ V(File, Lock, 30) \\\\ V(Socket, Lookup, 31) \\\\ V(Socket, ListInterfaces, 32) \\\\ V(Socket, ReverseLookup, 33) \\\\ V(Directory, Create, 34) \\\\ V(Directory, Delete, 35) \\\\ V(Directory, Exists, 36) \\\\ V(Directory, CreateTemp, 37) \\\\ V(Directory, ListStart, 38) \\\\ V(Directory, ListNext, 39) \\\\ V(Directory, ListStop, 40) \\\\ V(Directory, Rename, 41) \\\\ V(SSLFilter, ProcessFilter, 42) \",\"通过上述代码，可以得知，IOService主要处理的方法有四类：\",\"File\",\"Directory\",\"Socket\",\"SSLFilter\",\"在IOServiceCallback方法中，我们注意到，程序最后执行的结果是通过Dart_PostCObject返回的，来看一下他是怎么实现的：\",\"// -> runtime\\\\vm\\\\native_api_impl.cc static bool PostCObjectHelper(Dart_Port port_id, Dart_CObject* message) { AllocOnlyStackZone zone; std::unique_ptr<Message> msg = WriteApiMessage( zone.GetZone(), message, port_id, Message::kNormalPriority); if (msg == nullptr) { return false; } // Post the message at the given port. return **PortMap::PostMessage(std::move(msg));** } DART_EXPORT bool Dart_PostCObject(Dart_Port port_id, Dart_CObject* message) { return PostCObjectHelper(port_id, message); } // -> runtime\\\\vm\\\\port.cc bool PortMap::PostMessage(std::unique_ptr<Message> message, bool before_events) { MutexLocker ml(mutex_); if (ports_ == nullptr) { return false; } auto it = ports_->TryLookup(message->dest_port()); if (it == ports_->end()) { // Ownership of external data remains with the poster. message->DropFinalizers(); return false; } MessageHandler* handler = (*it).handler; ASSERT(handler != nullptr); **handler->PostMessage(std::move(message), before_events);** return true; } // -> runtime\\\\vm\\\\message_handler.cc void MessageHandler::PostMessage(std::unique_ptr<Message> message, bool before_events) { Message::Priority saved_priority; { MonitorLocker ml(&monitor_); if (FLAG_trace_isolates) { Isolate* source_isolate = Isolate::Current(); if (source_isolate != nullptr) { OS::PrintErr( \\\"[>] Posting message:\\\\n\\\" \\\"\\\\tlen: %\\\" Pd \\\"\\\\n\\\\tsource: (%\\\" Pd64 \\\") %s\\\\n\\\\tdest: %s\\\\n\\\" \\\"\\\\tdest_port: %\\\" Pd64 \\\"\\\\n\\\", message->Size(), static_cast<int64_t>(source_isolate->main_port()), source_isolate->name(), name(), message->dest_port()); } else { OS::PrintErr( \\\"[>] Posting message:\\\\n\\\" \\\"\\\\tlen: %\\\" Pd \\\"\\\\n\\\\tsource: <native code>\\\\n\\\" \\\"\\\\tdest: %s\\\\n\\\" \\\"\\\\tdest_port: %\\\" Pd64 \\\"\\\\n\\\", message->Size(), name(), message->dest_port()); } } saved_priority = message->priority(); // **将Message加入到MessageQueue中** if (message->IsOOB()) { oob_queue_->Enqueue(std::move(message), before_events); } else { queue_->Enqueue(std::move(message), before_events); } if (paused_for_messages_) { ml.Notify(); } if (pool_ != nullptr && !task_running_) { ASSERT(!delete_me_); task_running_ = true; const bool launched_successfully = pool_->Run<MessageHandlerTask>(this); ASSERT(launched_successfully); } } // Invoke any custom message notification. MessageNotify(saved_priority); } \",\"上述代码最后将结果包装成了Message打包进MessageHandler的消息队列中，这样便可以在Dart端通过消息分发接收到结果。\",\"Dart_NewNativePort\",\"再来看一下Dart_NewNativePort的实现如下：\",\"// -> runtime\\\\vm\\\\native_api_impl.cc DART_EXPORT Dart_Port Dart_NewNativePort(const char* name, Dart_NativeMessageHandler handler, bool handle_concurrently) { if (name == NULL) { name = \\\"<UnnamedNativePort>\\\"; } if (handler == NULL) { OS::PrintErr(\\\"%s expects argument 'handler' to be non-null.\\\\n\\\", CURRENT_FUNC); return ILLEGAL_PORT; } // 此方法位于sdk/runtime/vm/dart.cc // Used to Indicate that a Dart API call is active. if (!Dart::SetActiveApiCall()) { return ILLEGAL_PORT; } // 【注意，这里切换了isolate，退出当前isolate,直到Dart_NewNativePort执行完毕再切换回当前isolate】 // Start the native port without a current isolate. // 这里的实现可以参考https://github.com/dart-lang/sdk/blob/d437877c500c77d6e08372ba2dbda9c598f5bd8e/runtime/vm/dart_api_impl.cc **IsolateLeaveScope saver(Isolate::Current());** // 执行完IsolateLeaveScope 后，会切换出当前isolate直到下面的 return port_id;执行完毕，但是在此期间，下面的代码依旧是在当前isolate所在的IOThread也即系统线程下进行的 NativeMessageHandler* nmh = **new NativeMessageHandler(name, handler);** // 创建一个Dart_Port并且添加到PortMap中 Dart_Port port_id = **PortMap::CreatePort(nmh);** if (port_id != ILLEGAL_PORT) { // 激活这个端口 PortMap::SetPortState(port_id, PortMap::kLivePort); // 在Dart线程池中执行，在这里Run()中的代码会在一个新的线程中执行 if (!**nmh->Run**(**Dart::thread_pool()**, NULL, NULL, 0)) { // 执行完毕之后，在之前调用本方法的环境，回调handler，关闭Dart_Port PortMap::ClosePort(port_id); port_id = ILLEGAL_PORT; } } Dart::ResetActiveApiCall(); return port_id; // 上面IsolateLeaveScope saver对象在构造方法中退出了调用方法的分支，执行到这里后saver对象被回收，执行析构函数，又将Isolate切换回来 } \",\"主要的流程有：\",\"切换退出当前isolate\",\"创建NativeMessageHandler nmh包裹要处理的回调\",\"根据上面创建的nmh创建Dart_Port port_id\",\"执行**nmh->Run()**方法将nmh放到线程池中运行\",\"当nmh执行完毕回调后，关闭Dart_Port port_id\",\"也就是说，在Dart中向Native发送指令时，通过Dart的_IOService._dispatch()方法中执行_servicePorts._getPort(id);向Native层的IOService获取用于通信的SendPort servicePort时，会先通过Dart_NewNativePort创建一个NativeMessageHandler（会压入消息栈中），然后创建一个对应的Dart_Port port_id并返回给Dart用来触发消息。\",\"让我们挨个分析一下：\",\"1.退出当前isolate\",\"见 IsolateLeaveScope\",\"2.创建NativeMessageHandler nmh包裹要处理的回调\",\"3.根据上面创建的nmh创建Dart_Port port_id\",\"看一下PortMap::CreatePort的实现：\",\"// -> runtime\\\\vm\\\\port.cc Dart_Port PortMap::CreatePort(MessageHandler* handler) { ASSERT(handler != NULL); MutexLocker ml(mutex_); if (ports_ == nullptr) { return ILLEGAL_PORT; } #if defined(DEBUG) handler->CheckAccess(); #endif // 不停的遍历，直到找到一个可用的port（类型为int64_t） const Dart_Port port = AllocatePort(); // 获取到的port 只能通过isolate_entry访问 // The MessageHandler::ports_ is only accessed by [PortMap], it is guarded // by the [PortMap::mutex_] we already hold. MessageHandler::PortSetEntry isolate_entry; isolate_entry.port = port; handler->ports_.Insert(isolate_entry); Entry entry; entry.port = port; entry.handler = handler; entry.state = kNewPort; ports_->Insert(entry); if (FLAG_trace_isolates) { OS::PrintErr( \\\"[+] Opening port: \\\\n\\\" \\\"\\\\thandler: %s\\\\n\\\" \\\"\\\\tport: %\\\" Pd64 \\\"\\\\n\\\", handler->name(), entry.port); } return entry.port; } Dart_Port PortMap::AllocatePort() { Dart_Port result; ASSERT(mutex_->IsOwnedByCurrentThread()); // Keep getting new values while we have an illegal port number or the port // number is already in use. do { // Ensure port ids are representable in JavaScript for the benefit of // vm-service clients such as Observatory. const Dart_Port kMask1 = 0xFFFFFFFFFFFFF; // Ensure port ids are never valid object pointers so that reinterpreting // an object pointer as a port id never produces a used port id. const Dart_Port kMask2 = 0x3; result = (prng_->NextUInt64() & kMask1) | kMask2; // The two special marker ports are used for the hashset implementation and // cannot be used as actual ports. if (result == PortSet<Entry>::kFreePort || result == PortSet<Entry>::kDeletedPort) { continue; } ASSERT(!static_cast<ObjectPtr>(static_cast<uword>(result))->IsWellFormed()); } while (ports_->Contains(result)); ASSERT(result != 0); ASSERT(!ports_->Contains(result)); return result; } \",\"4.执行**nmh->Run()**方法将nmh放到线程池中运行\",\" // -> runtime\\\\vm\\\\message_handler.cc ThreadPool* pool_; bool MessageHandler::Run(ThreadPool* pool, StartCallback start_callback, EndCallback end_callback, CallbackData data) { MonitorLocker ml(&monitor_); if (FLAG_trace_isolates) { OS::PrintErr( \\\"[+] Starting message handler:\\\\n\\\" \\\"\\\\thandler: %s\\\\n\\\", name()); } ASSERT(pool_ == NULL); ASSERT(!delete_me_); pool_ = pool; start_callback_ = start_callback; end_callback_ = end_callback; callback_data_ = data; task_running_ = true; // 在Dart VM Thread的线程池中执行MessageHandler,会是一个新的线程 bool result = pool_->Run<MessageHandlerTask>(this); if (!result) { pool_ = nullptr; start_callback_ = nullptr; end_callback_ = nullptr; callback_data_ = 0; task_running_ = false; } return result; } // 会在“线程池”运行的时候执行对应的MessageHandler回调 class MessageHandlerTask : public ThreadPool::Task { public: explicit MessageHandlerTask(MessageHandler* handler) : handler_(handler) { ASSERT(handler != NULL); } virtual void Run() { ASSERT(handler_ != NULL); // 执行具体的逻辑 handler_->TaskCallback(); } private: MessageHandler* handler_; DISALLOW_COPY_AND_ASSIGN(MessageHandlerTask); }; // -> runtime\\\\include\\\\dart_api.h // A port is used to send or receive inter-isolate messages typedef int64_t Dart_Port; // -> runtime\\\\vm\\\\thread_pool.h // Runs a task on the thread pool. template <typename T, typename... Args> bool Run(Args&&... args) { return RunImpl(std::unique_ptr<Task>(new T(std::forward<Args>(args)...))); } // -> runtime\\\\vm\\\\thread_pool.cc bool ThreadPool::RunImpl(std::unique_ptr<Task> task) { Worker* new_worker = nullptr; { MonitorLocker ml(&pool_monitor_); if (shutting_down_) { return false; } // 创建新的Worker new_worker = ScheduleTaskLocked(&ml, std::move(task)); } if (new_worker != nullptr) { // 在线程中执行task new_worker->StartThread(); } return true; } // -> runtime\\\\vm\\\\thread_pool.cc // 创建一个Worker ThreadPool::Worker* ThreadPool::ScheduleTaskLocked(MonitorLocker* ml, std::unique_ptr<Task> task) { // Enqueue the new task. tasks_.Append(task.release()); pending_tasks_++; ASSERT(pending_tasks_ >= 1); // Notify existing idle worker (if available). if (count_idle_ >= pending_tasks_) { ASSERT(!idle_workers_.IsEmpty()); ml->Notify(); return nullptr; } // If we have maxed out the number of threads running, we will not start a // new one. if (max_pool_size_ > 0 && (count_idle_ + count_running_) >= max_pool_size_) { if (!idle_workers_.IsEmpty()) { ml->Notify(); } return nullptr; } // Otherwise start a new worker. auto new_worker = new Worker(this); idle_workers_.Append(new_worker); count_idle_++; return new_worker; } // 新建的Woker和ThreadPool绑定 ThreadPool::Worker::Worker(ThreadPool* pool) : pool_(pool), join_id_(OSThread::kInvalidThreadJoinId) {} // new_worker->StartThread();会调用下面的方法 void ThreadPool::Worker::StartThread() { int result = OSThread::Start(\\\"DartWorker\\\", &Worker::Main, reinterpret_cast<uword>(this)); if (result != 0) { FATAL1(\\\"Could not start worker thread: result = %d.\\\", result); } } // OSThread::Start每个端不一样，我们选择Android端的实现 // -> runtime\\\\vm\\\\os_thread_android.cc int OSThread::Start(const char* name, ThreadStartFunction function, uword parameter) { pthread_attr_t attr; int result = pthread_attr_init(&attr); RETURN_ON_PTHREAD_FAILURE(result); result = pthread_attr_setstacksize(&attr, OSThread::GetMaxStackSize()); RETURN_ON_PTHREAD_FAILURE(result); ThreadStartData* data = new ThreadStartData(name, function, parameter); // 声明系统线程类型 pthread_t tid; // 调用系统创建线程的函数 https://blog.csdn.net/liangxanhai/article/details/7767430 // pthread_create参数含义：1. &tid 指向线程的指针，2. &attr 新建线程的属性 3. ThreadStart线程要执行的方法指针 4. data传给参数ThreadStart的参数 // 成功执行线程则返回0 result = pthread_create(&tid, &attr, ThreadStart, data); RETURN_ON_PTHREAD_FAILURE(result); result = pthread_attr_destroy(&attr); RETURN_ON_PTHREAD_FAILURE(result); return 0; } // Dispatch to the thread start function provided by the caller. This trampoline // is used to ensure that the thread is properly destroyed if the thread just // exits. static void* ThreadStart(void* data_ptr) { if (FLAG_worker_thread_priority != kMinInt) { if (setpriority(PRIO_PROCESS, gettid(), FLAG_worker_thread_priority) == -1) { FATAL2(\\\"Setting thread priority to %d failed: errno = %d\\\\n\\\", FLAG_worker_thread_priority, errno); } } ThreadStartData* data = reinterpret_cast<ThreadStartData*>(data_ptr); const char* name = data->name(); OSThread::ThreadStartFunction function = data->function(); uword parameter = data->parameter(); delete data; // Set the thread name. There is 16 bytes limit on the name (including \\\\0). // pthread_setname_np ignores names that are too long rather than truncating. char truncated_name[16]; snprintf(truncated_name, ARRAY_SIZE(truncated_name), \\\"%s\\\", name); pthread_setname_np(pthread_self(), truncated_name); // 创建一个系统线程的包装类OSThread和新建的系统线程绑定 // Create new OSThread object and set as TLS for new thread. OSThread* thread = OSThread::CreateOSThread(); if (thread != NULL) { // 将线程切换到新创建的系统线程 OSThread::SetCurrent(thread); thread->set_name(name); UnblockSIGPROF(); // Call the supplied thread start function handing it its parameters. // 执行创建ThreadStartData时传入的方法，也就是ThreadPool::Worker::Main(uword args) function(parameter); } return NULL; OSThread* OSThread::CreateOSThread() { ASSERT(thread_list_lock_ != NULL); MutexLocker ml(thread_list_lock_); if (!creation_enabled_) { return NULL; } OSThread* os_thread = new OSThread(); AddThreadToListLocked(os_thread); return os_thread; } \",\"在创建了新的系统线程后，会执行下面的方法：\",\"// -> runtime\\\\vm\\\\thread_pool.cc void ThreadPool::Worker::Main(uword args) { // Call the thread start hook here to notify the embedder that the // thread pool thread has started. Dart_ThreadStartCallback start_cb = Dart::thread_start_callback(); if (start_cb != nullptr) { start_cb(); } OSThread* os_thread = OSThread::Current(); ASSERT(os_thread != nullptr); Worker* worker = reinterpret_cast<Worker*>(args); ThreadPool* pool = worker->pool_; // 将Worker和系统线程绑定 os_thread->owning_thread_pool_worker_ = worker; worker->os_thread_ = os_thread; // Once the worker quits it needs to be joined. worker->join_id_ = OSThread::GetCurrentThreadJoinId(os_thread); #if defined(DEBUG) { MonitorLocker ml(&pool->pool_monitor_); ASSERT(pool->idle_workers_.ContainsForDebugging(worker)); } #endif pool->WorkerLoop(worker); worker->os_thread_ = nullptr; os_thread->owning_thread_pool_worker_ = nullptr; // Call the thread exit hook here to notify the embedder that the // thread pool thread is exiting. Dart_ThreadExitCallback exit_cb = Dart::thread_exit_callback(); if (exit_cb != nullptr) { exit_cb(); } } // -> runtime\\\\vm\\\\os_thread.h // OSThread // The ThreadPool::Worker which owns this OSThread. If this OSThread was not // started by a ThreadPool it will be nullptr. This TLS value is not // protected and should only be read/written by the OSThread itself. void* owning_thread_pool_worker_ = nullptr; // thread_list_lock_ cannot have a static lifetime because the order in which // destructors run is undefined. At the moment this lock cannot be deleted // either since otherwise, if a thread only begins to run after we have // started to run TLS destructors for a call to exit(), there will be a race // on its deletion in CreateOSThread(). static Mutex* thread_list_lock_; \"]},\"116\":{\"h\":\"Dart_NewSendPort\",\"t\":[\"看一下Dart_NewSendPort如何将创建好的Dart_Port service_port转变为Dart的SendPort的：\",\"// -> runtime\\\\vm\\\\dart_api_impl.cc DART_EXPORT Dart_Handle Dart_NewSendPort(Dart_Port port_id) { DARTSCOPE(Thread::Current()); CHECK_CALLBACK_STATE(T); if (port_id == ILLEGAL_PORT) { return Api::NewError(\\\"%s: illegal port_id %\\\" Pd64 \\\".\\\", CURRENT_FUNC, port_id); } return Api::NewHandle(T, SendPort::New(port_id)); } // -> runtime\\\\vm\\\\object.cc SendPortPtr SendPort::New(Dart_Port id, Heap::Space space) { return New(id, Isolate::Current()->origin_id(), space); } SendPortPtr SendPort::New(Dart_Port id, Dart_Port origin_id, Heap::Space space) { ASSERT(id != ILLEGAL_PORT); // 创建新的SendPort并将Dart_Port id和当前的isolate id与之绑定 SendPort& result = SendPort::Handle(); { ObjectPtr raw = Object::Allocate(SendPort::kClassId, SendPort::InstanceSize(), space, SendPort::ContainsCompressedPointers()); NoSafepointScope no_safepoint; result ^= raw; result.StoreNonPointer(&result.untag()->id_, id); result.StoreNonPointer(&result.untag()->origin_id_, origin_id); } return result.ptr(); } \",\"到这里我们发现，Dart_NewNativePort将要处理的事件handler封装起来，最后在非当前isolate的线程中执行。\",\"从上面的分析中，我们可以知道，在Dart中通过File进行文件操作，其实是通过Dart中的_IOService进行消息中转，将用户的IO指令发送到Native层的IOService中；\",\"IOService通过一些列操作，得到一个SendPort servicePort，与此同时对应的IO操作已经压入消息栈中等待触发在单独的线程中执行；\",\"之后在_IOService中servicePort将用户需要的IO操作和与自己通信的_replyToPort = _receivePort!.sendPort; 通过send方法触发IOServiceCallback执行对应的IO操作，并且在最后调用Dart_PostCObject方法将结果压入消息栈中，这会触发Dart层_IOService的_receivePort!.handler回调事件，然后根据事件失败或者成功，使用Completer通过Event loop一步步将事件上报，最终回调用户需要的命令。\",\"09、Flutter FFI Dart Native API_又吹风_Bassy的博客-CSDN博客\",\"快手-开眼快创 Flutter 实践 | w4lle's Notes\"]},\"117\":{\"h\":\"Flutter APP绘制过程简析\",\"t\":[\"本文基于Flutter 3.0\",\"Flutter App基于Dart语言编写，提供了一套简单易用的API，可以让开发者在Flutter中快速开发出一个精美的APP。那么在Flutter中是如何绘制一个APP呢，runApp是怎么将我们编写的Widget等添加到手机上的呢？本文简单从Widget,Element,RenderObjet三者的关系来梳理一下Flutter的绘制过程。\",\"让我们运行一个“最”简单的Flutter App，分析一下在这个过程中涉及到的Widget、Element、RenderObject这三个tree的关系。\",\"main() { runApp(const Center( // Center非必须，为了让文本居中显得更清晰 child: Text( \\\"Hello center text!\\\", textDirection: TextDirection.ltr, // 文本方向 ), )); } \",\"上述代码的效果如下：\",\"flutter_run_app_hello_center_text\",\"让我们使用Flutter DevTools看一下实际生成的Widget Details Tree\",\"[root] >renderObject:RenderView#a00a5 Center alignment:Alignment.center widthFactor:null heightFactor:null >renderObject:RenderPositionedBox#94e0d Text \\\"Hello center text!\\\" textAlign:null textDirection:ltr locale:null softWrap:null overflow:null textScaleFactor:null maxLines:null textWidthBasis:null textHeightBehavior:null RichText textDirection:ltr softWrap:wrapping at box width maxLines:unlimited text:\\\"Hello center text!\\\" renderObject:RenderParagraph#71aa1 \",\"可以看到，除了我们在代码里面添加的Center和Text这两个Widget之外，还多出来好几个Widget/RenderObject，当我们仔细查看具体的Widget，可以看到其内部还有XXXElement，BuildOwner之类的字段：\",\"Center alignment:Alignment.center widthFactor:null heightFactor:null renderObject:RenderPositionedBox#94e0d >_parent:RenderObjectToWidgetElement _debugReassembleConfig:null _notificationTree:null >_slot:Object _depth:2 >_widget:Center >_owner:BuildOwner >_lifecycleState:_ElementLifecycle >_debugForgottenChildrenWithGlobalKey:_HashSet _inheritedWidgets:null _dependencies:null _hadUnsatisfiedDependencies:true _dirty:false _inDirtyList:false _debugBuiltOnce:false _debugA1lowIgnoredCallsToMarkNeedsBuild:false _debugDoingBuild:false >_ancestorRenderObjectElement:RenderObjectToWidgetElement >_child:StatelessElement \",\"上述涉及到的几个类彼此之间到底是什么关系，我们的“Hello center text!”又是怎样才显示到屏幕上的，让我们接下来一个一个分析一下：\",\"在执行runApp的时候主要执行了三步\",\"// -> \\\\lib\\\\src\\\\widgets\\\\binding.dart void runApp(Widget app) { // 创建render tree的根节点RenderView WidgetsFlutterBinding.ensureInitialized() // 将我们的app widget绑定到RenderView ..scheduleAttachRootWidget(app) // 安排屏幕帧绘制 ..scheduleWarmUpFrame(); } \"]},\"118\":{\"h\":\"WidgetsFlutterBinding.ensureInitialized()\",\"t\":[\"创建RenderView具体的逻辑在WidgetsFlutterBinding.ensureInitialized方法中：\",\"// -> \\\\lib\\\\src\\\\widgets\\\\binding.dart class WidgetsFlutterBinding extends BindingBase with GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding._instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance; } } \",\"在ensureInitialized方法中，如果WidgetsBinding._instance为null则会先用构造方法创建，因为WidgetsFlutterBinding继承自BindingBase，所以实际上执行下方的方法：\",\"// -> lib\\\\src\\\\foundation\\\\binding.dart abstract class BindingBase { BindingBase() { initInstances(); initServiceExtensions(); } @protected @mustCallSuper void initInstances() { } } \",\"这里主要做了2件事，我们关注initInstances()方法，这个方法的主要逻辑都在他的子类中，也就是之前WidgetsFlutterBinding混合的几个BindingBase子类中，我们关注和屏幕渲染有关的RendererBinding：\",\"// -> lib\\\\src\\\\rendering\\\\binding.dart /// The glue between the render tree and the Flutter engine. mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable { @override void initInstances() { super.initInstances(); _instance = this; // 这里创建了PipelineOwner，用来管理rendering pipeline也就是我们app中所有的RenderObject _pipelineOwner = PipelineOwner( onNeedVisualUpdate: ensureVisualUpdate, onSemanticsOwnerCreated: _handleSemanticsOwnerCreated, onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed, ); platformDispatcher ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; // 注意这里创建了RenderView initRenderView(); _handleSemanticsEnabledChanged(); assert(renderView != null); addPersistentFrameCallback(_handlePersistentFrameCallback); initMouseTracker(); if (kIsWeb) { addPostFrameCallback(_handleWebFirstFrame); } } /// Creates a [RenderView] object to be the root of the /// [RenderObject] rendering tree, and initializes it so that it /// will be rendered when the next frame is requested. /// /// Called automatically when the binding is created. void initRenderView() { renderView = RenderView(configuration: createViewConfiguration(), window: window); renderView.prepareInitialFrame(); } set renderView(RenderView value) { assert(value != null); // 注意这里，将renderView设置为_pipeline的根节点 _pipelineOwner.rootNode = value; } } \",\"我们主要关注两件事：\",\"创建了用于管理渲染管道的PipelineOwner _pipelineOwner\",\"Pipeline是用来管理rendering tree，其内部持有我们的renderView作为rootNode，同时维护了_nodesNeedingLayout，_nodesNeedingCompositingBitsUpdate，_nodesNeedingPaint，_nodesNeedingSemantics四个列表，当flutter framework每次需要往屏幕上绘制内容时会依次遍历这四个列表，将RenderObject绘制到屏幕上面。\",\"创建了rendering tree的根节点renderView ，并将其设置为_pipelineOwner的根节点\"]},\"119\":{\"h\":\"..scheduleAttachRootWidget(app)\",\"t\":[\"此方法是WidgetsFlutterBinding的另外一个混合类WidgetsBinding负责具体实现：\",\"WidgetsBinding的scheduleAttachRootWidget 方法最后调用了attachRootWidget(Widget rootWidget) ：\",\"// -> lib\\\\src\\\\widgets\\\\binding.dart /// The glue between the widgets layer and the Flutter engine. mixin WidgetsBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding { // 将rootWidget绑定到renderViewElement void attachRootWidget(Widget rootWidget) { final bool isBootstrapFrame = renderViewElement == null; _readyToProduceFrames = true; // 用于将rootWidget绑定到renderView上面 _renderViewElement = RenderObjectToWidgetAdapter<RenderBox>( container: renderView, debugShortDescription: '[root]', child: rootWidget, ) // 在此创建或者使用已有的RenderObjectToWidgetElement，并作为根Element // 并将RenderObjectToWidgetAdapter和RenderView与之绑定 // 这里的_buildOwner在WidgetsBinding.initInstances方法创建，用于管理widget框架的类 .attachToRenderTree(buildOwner!, renderViewElement as RenderObjectToWidgetElement<RenderBox>?); if (isBootstrapFrame) { // 如果是启动框架，就安排更新帧 SchedulerBinding.instance.ensureVisualUpdate(); } } } \",\"这里主要有3步：\",\"创建RenderObjectToWidgetAdapter包装RenderView\",\"在attachToRenderTree方法中创建RenderObjectToWidgetElement并mount到element tree中（widget tree实际上并不存在，而是通过element tree管理）\",\"需要的话安排一次frame（刷新页面）\",\"还需要注意一个新的角色buildOwner，这个对象全局唯一（一般由parent传给child），在WidgetsBinding.initInstances方法创建，用来管理与Widget tree相关的类，实际上就是通过管理Element的插入，移除，更新来间接管理Widget tree（对应我们在之前遇到的用来管理rendering tree的pipelineOwner ，这两个Owner管理着我们所说的Flutter的Widget/Element/RenderObject“三”个tree）。\"]},\"120\":{\"h\":\"RenderObjectToWidgetAdapter\",\"t\":[\"前面我们知道renderView其实是一个RenderObject，所以这里为他创建了一个对应的Widget——RenderObjectToWidgetAdapter，其主要作用是将rootWidget（也就是我们最开始写的Center Widget及其child）绑定到之前生成的renderView上面，并将renderView作为自己对应的RenderObject。\",\"// -> lib\\\\src\\\\widgets\\\\binding.dart class RenderObjectToWidgetAdapter<T extends RenderObject> extends RenderObjectWidget { /// Creates a bridge from a [RenderObject] to an [Element] tree. /// /// Used by [WidgetsBinding] to attach the root widget to the [RenderView]. RenderObjectToWidgetAdapter({ this.child, required this.container, this.debugShortDescription, }) : // 注意这里用container也就是RenderView创建了一个GlobalObjectKey， // 在RenderObjectToWidgetElementmount的时候会用到 super(key: GlobalObjectKey(container)); @override RenderObjectToWidgetElement<T> createElement() => RenderObjectToWidgetElement<T>(this); @override RenderObjectWithChildMixin<T> createRenderObject(BuildContext context) => container; } \",\"RenderObjectToWidgetAdapter.createRenderObject 返回的就是container 也就是我们的RenderView。\"]},\"121\":{\"h\":\"attachToRenderTree\",\"t\":[\"// -> lib\\\\src\\\\widgets\\\\binding.dart class RenderObjectToWidgetAdapter<T extends RenderObject> extends RenderObjectWidget { RenderObjectToWidgetElement<T> attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement<T>? element ]) { if (element == null) { owner.lockState(() { // 创建RenderObjectToWidgetElement，并将RenderObjectToWidgetAdapter与之绑定 element = createElement(); assert(element != null); // 创建好Element之后，将BuildOwner与之绑定 element!.assignOwner(owner); }); owner.buildScope(element!, () { // 这里最终会通过updateChild方法将rootWidget对应的Element插入到 // RenderObjectToWidgetElement下面,在rootWidget中第一个RenderObjectElement // 的mount方法中，通过attachRenderObject(newSlot)将自己的renderObject绑定到renderView element!.mount(null, null); }); } else { element._newWidget = this; element.markNeedsBuild(); } return element!; } } \",\"RenderObjectToWidgetAdapter在attachToRenderTree 方法中，创建对应的RenderObjectToWidgetElement 与自己绑定，并且同时也将rootWidget和之前创建的rendering tree的根节点renderView绑定。\",\"|— RenderObjectToWidgetAdapter —|— RenderObjectToWidgetElement —|— RenderView —| \",\"我们再来看一下RenderObjectToWidgetElement调用的父类RenderObjectElement.mount方法:\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart abstract class RenderObjectElement extends Element { @override void mount(Element? parent, Object? newSlot) { super.mount(parent, newSlot); // 本例中这里实际上获取到的是RenderView _renderObject = (widget as RenderObjectWidget).createRenderObject(this); // 将RenderView绑定到指定newSlot(这里是null)中 attachRenderObject(newSlot); _dirty = false; } @override void attachRenderObject(Object? newSlot) { assert(_ancestorRenderObjectElement == null); _slot = newSlot; // 这里因为RenderView是根节点，所以_ancestorRenderObjectElement和parentDataElement都为null // 但是对于RenderView下级的节点，比如本例中的Center Widget，他对应的祖先节点就是持有RenderView // 的RenderObjectToWidgetElement，所以这里会将CenterWidget的RenderPositionedBox // 作为RenderView的child _ancestorRenderObjectElement = _findAncestorRenderObjectElement(); _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot); final ParentDataElement<ParentData>? parentDataElement = _findAncestorParentDataElement(); if (parentDataElement != null) _updateParentData(parentDataElement.widget as ParentDataWidget<ParentData>); } } \",\"此外，还会调用的Element.mount方法：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart // Element的方法： void mount(Element? parent, Object? newSlot) { _parent = parent; _slot = newSlot; _lifecycleState = _ElementLifecycle.active; _depth = _parent != null ? _parent!.depth + 1 : 1; if (parent != null) { // Only assign ownership if the parent is non-null. If parent is null // (the root node), the owner should have already been assigned. // See RootRenderObjectElement.assignOwner(). _owner = parent.owner; } assert(owner != null); // 这里将RenderObjectToWidgetElement注册到owner中，key是创建RenderObjectToWidgetAdapter时候创建的GlobalObjectKey final Key? key = widget.key; if (key is GlobalKey) { owner!._registerGlobalKey(key, this); } _updateInheritance(); attachNotificationTree(); } \",\"可以看到，这里将RenderObjectToWidgetElement 注册到了BuildOwner中\",\"在RenderObjectToWidgetElement的mount方法执行时，除了调用父类的mount方法外，还会触发_rebuild() 方法：\",\"class RenderObjectToWidgetElement<T extends RenderObject> extends RootRenderObjectElement {{ Element? _child; void _rebuild() { try { // 在这里分析可知,这里的widget即`RenderObjectToWidgetElement` 的widget，也就是 // `RenderObjectToWidgetAdapter`，他的child也就是rootWidget // 所以updateChild传入的值分别是null，RenderObjectToWidgetAdapter.child // 会创建rootWidget对应的element并将其作为当前element的child _child = updateChild(_child, (widget as RenderObjectToWidgetAdapter<T>).child, _rootChildSlot); } catch (exception, stack) { ... } } \",\"在_rebuild方法中，我们可以看到，在WidgetsBinding.attachRootWidget方法中给RenderObjectToWidgetAdapter作为child参数传入的rootWidget（也即我们示例中的CenterWidget），在这里被传入了RenderView对应的RenderObjectToWidgetElement的child中（这里的过程我们下面Center一节再分析），从而将其插入到Flutter的渲染树中。\",\"这样RenderView（RenderObject）就有了对应的Widget和Element，并且有了自己的child。\"]},\"122\":{\"h\":\"..scheduleWarmUpFrame()\",\"t\":[\"这个方法则是尽快安排一个frame以便在屏幕下次刷新的时候显示app的内容（在app启动之后的第一次！！！），这样我们的app启动了，我们写的内容也能正常显示到屏幕上。\",\"通过上述分析，我们可以得知，runApp方法执行之后，创建了RenderView对象，并将其作为整个Flutter APP的RenderObject rendering tree的根节点（后续所有的Widget创建的RenderObject都是在RenderView的下层），并且初始化它以便在下一帧的时候对其进行渲染。\",\"分析完了runApp，我们再来看一下刚刚提到的几个类，以及他们是如何添加到我们的flutter app中的。\",\"先看一下在最顶层的RenderView：\",\"↓[root] >renderObject:RenderView#a00a5 parent:null _debugReassembleConfig:null _notificationTree:nul1 slot:null depth:1 _widget:RenderObjectToWidgetAdapter >_owner:BuildOwner _lifecycleState:_ElementLifecycle _debugForgottenChildrenWithGlobalKey:_HashSet _inheritedWidgets:nul1 _dependencies:null _hadUnsatisfiedDependencies:false _dirty:false _inDirtyList:false _debugBuiltOnce:false _debugA1lowIgnoredCallsToMarkNeedsBuild:false _debugDoingBuild:false _ancestorRenderObjectElement:null _child:SingleChildRenderObjectElement _newWidget:null \",\"查阅源码可知，RenderView是RenderObject，一般情况下是Flutter的根View，表示整个rendering tree的output surface，处理引导着render pipeline。\",\"RenderView有且仅有一个RenderBox类型的child，他会强制将child的size改为RenderView初始化时候的入参configuration的值（一般是当前window也就是手机屏幕的逻辑像素size）。\",\"上节我们说道，Center Widget通过RenderObjectToWidgetElement.updateChild（最终调用Element同名方法）方法插入到渲染树中，下面我们详细分析一下这个过程：\",\"在updateChild中，因为child==null，而newWidget也就是Center不为null，所以直接使用inflateWidget(newWidget, newSlot)创建新的Element并作为RenderObjectToWidgetElement的_child，而作为第一次创建的Center，在Element.inflateWidget方法中大概会执行下面几步：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart // Element的inflateWidget方法： final Element newChild = newWidget.createElement(); newChild.mount(this, newSlot); return newChild; \",\"也就是这里先执行了Center.createElement方法创建Element，然后调用此Element.mount方法将Element添加到Element tree。\",\"让我们再看一下Center的Widget Details Tree：\",\"Center alignment:Alignment.center widthFactor:null heightFactor:null renderObject:RenderPositionedBox#94e0d >_parent:RenderObjectToWidgetElement _debugReassembleConfig:null _notificationTree:null >_slot:Object _depth:2 >_widget:Center >_owner:BuildOwner >_lifecycleState:_ElementLifecycle >_debugForgottenChildrenWithGlobalKey:_HashSet _inheritedWidgets:null _dependencies:null _hadUnsatisfiedDependencies:true _dirty:false _inDirtyList:false _debugBuiltOnce:false _debugA1lowIgnoredCallsToMarkNeedsBuild:false _debugDoingBuild:false >_ancestorRenderObjectElement:RenderObjectToWidgetElement >_child:StatelessElement \",\"可以看到Center的_parent和_ancestorRenderObjectElement是RenderObjectToWidgetElement，_depth是2，这个和我们最初的分析一致，因为Center（其实严格来说，是Center Widget的（或子级的）RenderObject）是RenderView的child。\",\"我们接下来主要关注一下几个属性：\",\"alignment: Alignment.center\",\"renderObject: RenderPositionedBox\",\"_widget: Center\",\"_child: StatelessElement\",\"先看一下Center的源码：\",\"// -> lib\\\\src\\\\widgets\\\\basic.dart class Center extends Align { /// Creates a widget that centers its child. const Center({ Key? key, double? widthFactor, double? heightFactor, Widget? child }) : super(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child); } \",\"Center代码十分简单，主要的逻辑在他的父类Align中：\",\"// -> lib\\\\src\\\\widgets\\\\basic.dart class Align extends SingleChildRenderObjectWidget { const Align({ Key? key, // 这里alignment默认是居中 this.alignment = Alignment.center, this.widthFactor, this.heightFactor, Widget? child, }) : super(key: key, child: child); @override RenderPositionedBox createRenderObject(BuildContext context) { // Center的父类可以创建自己的RenderObject return RenderPositionedBox( alignment: alignment, widthFactor: widthFactor, heightFactor: heightFactor, textDirection: Directionality.maybeOf(context), ); } @override void updateRenderObject(BuildContext context, RenderPositionedBox renderObject) { renderObject ..alignment = alignment ..widthFactor = widthFactor ..heightFactor = heightFactor ..textDirection = Directionality.maybeOf(context); } } \",\"Align其实是一个SingleChildRenderObjectWidget ,对应的Element是SingleChildRenderObjectElement，他创建的RenderObject是RenderPositionedBox 。\",\"SingleChildRenderObjectElement 是一个RenderObjectElement 也就意味着他在rendering tree有一个关联的RenderObject负责layout，painting以及hit-test。\",\"回到我们的Center Widget中：\"]},\"123\":{\"h\":\"alignment: Alignment.center\",\"t\":[\"Alignment.center是在创建Center的时候默认设置的对齐方式\"]},\"124\":{\"h\":\"renderObject: RenderPositionedBox\",\"t\":[\"RenderPositionedBox是Center Widget对应的RenderObject，在SingleChildRenderObjectWidget.mount 的时候创建。其本身并不在屏幕上绘制肉眼可见的内容，而是将child按照指定的对齐方式进行定位。\",\"RenderPositionedBox 的继承关系：RenderPositionedBox → RenderAligningShiftedBox → RenderShiftedBox → RenderBox → RenderObject\",\"RenderPositionedBox可以按照给定的AlignmentGeometry定位child。在本例中，他的几个属性如下：\",\"alignment: Alignment.center\",\"_owner: PipelineOwner\",\"_parent: RenderView\",\"_child: RenderParagraph\",\"前三个属性含义很明显，这里我们注意到他的_child并不是我们预期的Text，这个原因我们后面再分析。\"]},\"125\":{\"h\":\"_widget: Center\",\"t\":[\"其实通过上述的分析，我们应该已经知道，我们在Widget Details Tree中看到的Center其实是Center Widget对应的Element，也就是SingleChildRenderObjectElement 。\",\"其继承关系：SingleChildRenderObjectElement → RenderObjectElement → Element\",\"根据Element的定义，这里的Widget是在Widget创建SingleChildRenderObjectElement的时候传入的：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart Element(Widget widget) : assert(widget != null), _widget = widget; // -> lib\\\\src\\\\widgets\\\\framework.dart abstract class SingleChildRenderObjectWidget extends RenderObjectWidget { /// Abstract const constructor. This constructor enables subclasses to provide /// const constructors so that they can be used in const expressions. const SingleChildRenderObjectWidget({ Key? key, this.child }) : super(key: key); /// The widget below this widget in the tree. /// /// {@macro flutter.widgets.ProxyWidget.child} final Widget? child; @override SingleChildRenderObjectElement createElement() => SingleChildRenderObjectElement(this); } \",\"然后这个Element在上述WidgetsBinding.attachRootWidget步骤中通过一系列操作，最终在RenderObjectToWidgetElement的updateChild方法被创建并被BuildOwner 插入到tree中。\",\"这里的_widget才真正对应着我们在runApp里面传入的Center Widget，他的child也正是我们的Text。\",\"Center alignment:Alignment.center widthFactor:null heightFactor:null >renderObject:RenderPositionedBox#6e802 >_parent:RenderObjectToWidgetElement _debugReassembleConfig:null _notificationTree:null _slot:Object denth:2 _ [[[widget:Center]]] //注意这里 key:null location:_Location [[[child:Text]]] //注意这里 key:null >_location:_Location data:'Hello center text!' textSpan:null style:null strutStyle:null textAlign:null >textDirection:TextDirection locale:null softWrap:null overflow:null textScaleFactor:null maxLines:null semanticsLabel:null textWidthBasis:null textHeightBehavior:null >alignment:Alignment widthFactor:null heightFactor:nul1 >_owner:BuildOwner \"]},\"126\":{\"h\":\"_child: StatelessElement\",\"t\":[\"Center对应的Element的_child是一个StatelessElement，按照我们上一步的分析，StatelessElement应该是Text Widget创建，事实也确实如此：\",\"↓_child: StatelessElement >_parent: SingleChildRenderObjectElement debugReassembleConfig： null _notificationTree: null slot: null depth: 3 >_widget: Text >_owner: BuildOwner >_lifecycleState: _ElementLifecycle >_debugForgottenChildrenWithGlobalKey: _HashSet _inheritedWidgets: null dependencies: null _hadUnsatisfiedDependencies: true _dirty: false _inDirtyList: false debugBuiltOnce: false _debugAllowIgnoredCallsToMarkNeedsBuild: false >_child: MultichildRenderObjectElement debugDoingBuild: false \",\"让我们分析一下这个_child的赋值过程：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart class SingleChildRenderObjectElement extends RenderObjectElement { @override void mount(Element? parent, Object? newSlot) { super.mount(parent, newSlot); _child = updateChild(_child, (widget as SingleChildRenderObjectWidget).child, null); } } \",\"在Center对应的Element——SingleChildRenderObjectElement 在mount的时候，同时也会更新child（本例中Center的child是Text），这里调用的是Element的updateChild方法，他的逻辑如下：\",\"| | **newWidget == null** | **newWidget != null** | | :-----------------: | :--------------------- | :---------------------- | | **child == null** | Returns null. | Returns new [Element]. | | **child != null** | Old child is removed, returns null. | Old child updated if possible, returns child or new [Element]. | \",\"updateChild的逻辑分为4种情况：其余情况都比较简单，只有newWidget != null或者child != null的时候需要判断一下，如果可以更新就更新否则就创建新的Element，可以分为下面这几种情况：\",\"child.widget == newWidget：两个是同一个对象，就只更新child的slot\",\"Widget.canUpdate(child.widget, newWidget)：二者的runtimeType和key一样，就调用child.update(newWidget)更新child._widget，必要时更新child的slot\",\"否则创建新的element并替代\",\"到这里跟Center插入到render tree的步骤一样，将Text插入到了tree中。\",\"接下来我们分析一下Text是如何被加入Widget Details Tree的。\",\"其继承关系：Text → StatelessWidget → Widget\",\"Text是StatelessWidget，他的内容比较简单，主要的逻辑都在build方法中：\",\"// -> \\\\lib\\\\src\\\\widgets\\\\text.dart class Text extends StatelessWidget { const Text( String this.data, { Key? key, ... }) : textSpan = null, super(key: key); @override Widget build(BuildContext context) { final DefaultTextStyle defaultTextStyle = DefaultTextStyle.of(context); TextStyle? effectiveTextStyle = style; if (style == null || style!.inherit) effectiveTextStyle = defaultTextStyle.style.merge(style); if (MediaQuery.boldTextOverride(context)) effectiveTextStyle = effectiveTextStyle!.merge(const TextStyle(fontWeight: FontWeight.bold)); // 注意这里返回了RichText Widget result = RichText( textAlign: textAlign ?? defaultTextStyle.textAlign ?? TextAlign.start, textDirection: textDirection, // RichText uses Directionality.of to obtain a default if this is null. ... text: TextSpan( style: effectiveTextStyle, text: data, children: textSpan != null ? <InlineSpan>[textSpan!] : null, ), ); ... return result; } } \",\"同样，作为StatelessWidget，他也创建了一个StatelessElement ：\",\"其继承关系：StatelessElement → ComponentElement → Element\",\"按照之前的分析，Text插入到tree中执行的方法分别是Text.createElement和Text对应的Element——StatelessElement.mount方法：\",\"Text是StatelessWidget的子类，他的主要逻辑都在StatelessWidget：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart abstract class StatelessWidget extends Widget { const StatelessWidget({ Key? key }) : super(key: key); @override StatelessElement createElement() => StatelessElement(this); @protected Widget build(BuildContext context); } \",\"可以看到其createElement创建的是StatelessElement，也就是说Text插入到Center过程主要在StatelessElement中。\",\"StatelessElement.mount方法主要逻辑在ComponentElement中，这个方法除了调用Element同名方法外，还调用了ComponentElement._firstBuild() → Element.rebuild() → ComponentElement.performRebuild() ：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart // ComponentElement类中的方法 void performRebuild() { Widget? built; try { // 这里调用Element对应的Widget的build方法创建Widget，也就是RichText built = build(); } catch (e, stack) { ... } finally { // We delay marking the element as clean until after calling build() so // that attempts to markNeedsBuild() during build() will be ignored. _dirty = false; assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(false)); } // 将上述创建的Widget：built经过处理后赋值给Element的_child try { _child = updateChild(_child, built, slot); assert(_child != null); } catch (e, stack) { built = ErrorWidget.builder(...); _child = updateChild(null, built, slot); } } \",\"这里的主要有两个步骤：\",\"调用ComponentElement.build方法，生产Widget（本例中，间接调用了Text的build方法）\",\"调用ComponentElement.updateChild方法，更新child（最终执行的是Element同名方法逻辑）\",\"到目前为止，我们的Widget/Element/RenderObject tree如下（第四级RichText下面再分析）：\",\"**Widget**: RenderObjectToWidgetAdapter → Center → Text → *RichText* **Element**: RenderObjectToWidgetElement → SingleChildRenderObjectElement → StatelessElement → *MultiChildRenderObjectElement* **RenderObject**: RenderView → RenderPositionedBox → [X] → *RenderParagraph* 注： 1. 这里的[X]实际上不存在，只是为了和Text对应表示这里本应该有一个对应的RenderObject 2. 最后一列*RichText*对应的节点目前还没有分析到，此处仅做提前展示 \",\"不难看出，在从定往下数第三层也就是Text对应的这一级中，RenderObject tree这里并没有对应的对象，在上面的分析中，我们也看到了StatelessWidget本身并没有创建RenderObject的方法。实际上，Widget分为多个种类，只有RenderObject类及其子类才会创建RenderObject：\",\"Untitled\"]},\"127\":{\"h\":\"RichText\",\"t\":[\"终于到了我们这个app真正在屏幕上显示的内容这里了，上面我们分析到，Text作为StatelessWidget，本身并不会产生可以在屏幕上绘制的RenderObject，而是通过他的build方法返回一个可以产生RenderObject的Widget，在本例中，这个Widget就是RichText：\",\"// -> lib\\\\src\\\\widgets\\\\basic.dart class RichText extends MultiChildRenderObjectWidget { @override RenderParagraph createRenderObject(BuildContext context) { assert(textDirection != null || debugCheckHasDirectionality(context)); return RenderParagraph(text, textAlign: textAlign, textDirection: textDirection ?? Directionality.of(context), softWrap: softWrap, overflow: overflow, textScaleFactor: textScaleFactor, maxLines: maxLines, strutStyle: strutStyle, textWidthBasis: textWidthBasis, textHeightBehavior: textHeightBehavior, locale: locale ?? Localizations.maybeLocaleOf(context), ); } } \",\"RichText继承自MultiChildRenderObjectWidget ，如上节分析的，是一种RenderObjectWidget，它创建了真正在屏幕上渲染的RenderObject——RenderParagraph：\",\"// -> lib\\\\src\\\\rendering\\\\paragraph.dart class RenderParagraph extends RenderBox with ContainerRenderObjectMixin<RenderBox, TextParentData>, RenderBoxContainerDefaultsMixin<RenderBox, TextParentData>, RelayoutWhenSystemFontsChangeMixin {} \",\"上面说道，Text本身作为StatelessWidget并不产生RenderObject，那么这里的RenderParagraph是如何找到并插入到rendering tree中的呢？\",\"带着这个疑问，我们看一下MultiChildRenderObjectWidget 创建的MultiChildRenderObjectElement ：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart class MultiChildRenderObjectElement extends RenderObjectElement { @override void mount(Element? parent, Object? newSlot) { super.mount(parent, newSlot); final MultiChildRenderObjectWidget multiChildRenderObjectWidget = widget as MultiChildRenderObjectWidget; // 本例中不涉及children final List<Element> children = List<Element>.filled(multiChildRenderObjectWidget.children.length, _NullElement.instance); Element? previousChild; for (int i = 0; i < children.length; i += 1) { final Element newChild = inflateWidget(multiChildRenderObjectWidget.children[i], IndexedSlot<Element?>(i, previousChild)); children[i] = newChild; previousChild = newChild; } _children = children; } } \",\"这里可以看到，在MultiChildRenderObjectElement的mount方法中：\",\"调用父类mount方法\",\"遍历了所有的children将其插入到MultiChildRenderObjectElement中。\",\"在前面的Text源码中，我们注意到给只给RichText.text赋值了，RichText的textSpan和children都是null，所以后面对children的处理在本例中不涉及，让我们看一下super.mount(parent, newSlot)方法：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart abstract class RenderObjectElement extends Element { @override void mount(Element? parent, Object? newSlot) { super.mount(parent, newSlot); // 这里调用对应的RenderObjectWidget创建_renderObject _renderObject = (widget as RenderObjectWidget).createRenderObject(this); // 将其绑定到rendering tree中 attachRenderObject(newSlot); _dirty = false; } } \",\"这里主要有2步：\",\"通过widget.createRenderObject 创建_renderObject，本例中就是用RichText创建了RenderParagraph\",\"调用RenderObjectElement.attachRenderObject方法将_renderObject插入到rendering tree\",\"让我们看一下attachRenderObject的实现：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart // RenderObjectElement类的方法 @override void attachRenderObject(Object? newSlot) { assert(_ancestorRenderObjectElement == null); _slot = newSlot; // 向上遍历，找到父级节点中最近的RenderObjectElement _ancestorRenderObjectElement = _findAncestorRenderObjectElement(); // 将renderObject插入 _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot); final ParentDataElement<ParentData>? parentDataElement = _findAncestorParentDataElement(); if (parentDataElement != null) _updateParentData(parentDataElement.widget as ParentDataWidget<ParentData>); } RenderObjectElement? _findAncestorRenderObjectElement() { Element? ancestor = _parent; while (ancestor != null && ancestor is! RenderObjectElement) ancestor = ancestor._parent; return ancestor as RenderObjectElement?; } \",\"可以看到，在attachRenderObject方法中插入的方式很简单：先在当前tree中向上找到父级中离得最近的RenderObjectElement，在本例中是Center这个Widget对应的SingleChildRenderObjectElement（注意不是创建RichText的Text），然后调用其insertRenderObjectChild方法将当前的RenderParagraph插入到rendering tree中：\",\"// -> lib\\\\src\\\\widgets\\\\framework.dart class SingleChildRenderObjectElement extends RenderObjectElement { @override void insertRenderObjectChild(RenderObject child, Object? slot) { final RenderObjectWithChildMixin<RenderObject> renderObject = this.renderObject as RenderObjectWithChildMixin<RenderObject>; renderObject.child = child; } } \",\"在SingleChildRenderObjectElement的insertRenderObjectChild方法中先是查找当前Element持有的renderObject,然后将我们传入的RichText的RenderObject——RenderParagraph赋值给renderObject.child。\",\"到这里，我们的所有Widget在Element的组织下，将对于的RenderObject添加到Rendering Tree中，他们的关系如下：\",\"**Widget**: RenderObjectToWidgetAdapter → Center → Text → RichText **Element**: RenderObjectToWidgetElement → SingleChildRenderObjectElement → StatelessElement → MultiChildRenderObjectElement **RenderObject**: RenderView → RenderPositionedBox → RenderParagraph \",\"这样，当屏幕刷新的时候，这些内容便绘制在屏幕上面。\",\"在runApp方法中，WidgetsFlutterBinding作为将flutter framework绑定到flutter engine的粘合剂：\",\"在ensureInitialized方法中创建了_pipelineOwner（管理rendering tree）、renderView和buildOwner（通过管理Element tree间接管理widget tree），并将renderView设置为_pipelineOwner的根节点。\",\"在scheduleAttachRootWidget方法中，为renderView创建并绑定了对应的Widget（RenderObjectToWidgetAdapter）和Element（RenderObjectToWidgetElement）。然后通过RenderObjectToWidgetElement.mount方法，将之前创建的buildOwner与自己绑定。\",\"并且将我们在runApp传入的WidgetrootWidget（也就是本例中的Center Widget）对应的Element添加为RenderObjectToWidgetElement的子节点。并依此将Text、Text内部的RichText等对应的Element都加入到Element tree中，直到遍历完整个Widget tree。\",\"在scheduleWarmUpFrame方法中安排在下一次屏幕刷新的时候将我们的内容展示在屏幕上面。\",\"下面是我们这个“最”简单的Flutter App的结构示意：\",\"Flutter - Dart API docs\",\"Flutter, what are Widgets, RenderObjects and Elements? - Norbert Kozsir | Flutter Europe\",\"Flutter Widgets Explained | Understand How Flutter Works!\",\"深入浅出 Flutter Framework 之 PipelineOwner\"]},\"128\":{\"h\":\"Flutter UI 绘制与InheritedWidget解析\",\"t\":[\"Flutter的Widget分为StatefulWidget和StatelessWidget ，二者都继承自Widget。\",\"此外还有一种用来传输数据的Widget——InheritedWidget，与上述两者不太一样的是，他的继承关系是：InheritedWidget→ProxyWidget →Widget 。\",\"Flutter的渲染流程如图：\",\"flutter_widget_element_renderobject_relationship\",\"可以简单理解为， Widget是配置信息，Element代表在树中详细的位置，而RenderObject则是实际渲染的对象。\",\"StatelessWidget和StatefulWidget在创建之后就不会再变化，而StatefulWidget因为有State，所以可以在State调用setState()方法之后，重新执行State的build()方法，从而更新界面。\",\"如果Widget是const的，那么他就不会被rebuild。\",\"以StatefulWidget为例：\",\"flutter_render_flow_chart\",\"调用setState()方法，会调用对应的Element的markNeedsBuild() 方法，通过BuildOwner的scheduleBuildFor(Element element) 方法将当前Element标记为dirty，以便在下次屏幕刷新时安排rebuilt 。\",\"下一帧屏幕刷新，调用BuildOwner的buildScope(Element context, [ VoidCallback? callback ]) 方法。这个方法会遍历_dirtyElements 中所有dirty的element执行element.rebuild(); 方法，在其内部调用了Element的performRebuild() 方法。\",\"Element的performRebuild() 方法因各个Element的实现而异：\",\"StatelessElement 、InheritedElement：与父类ComponentElement 保持一致\",\"StatefulElement ：判断有需要时调用state.didChangeDependencies(); ，其余与父类ComponentElement 保持一致\",\"而ComponentElement 的performRebuild() 主要做了2件事： （1）built = build(); ；（2）_child = updateChild(_child, built, slot);\",\"在这其中build()：\",\"StatelessElement:build() => widget.build(this);\",\"StatefulElement : build() => state.build(this);\",\"InheritedElement :build() => widget.child;\",\"updateChild 会判断以下几种情况：\",\"newWidget == null\",\"newWidget != null\",\"child == null\",\"return null\",\"return new Element\",\"child != null\",\"remove old child, return null\",\"Old child updated if possible, returns child or new Element\",\"其中，old child updated 的时候调用的是child.update(newWidget); 方法会触发Widget的rebuild() 。\",\"这样就完成了一次Rebuild。\",\"InheritedWidget是持有状态的Widget，他的子Widget可以通过他来获取这些状态。\",\"一般来说，InheritedWidget持有的状态是final的，如果要更新状态，就需要在其外部包裹一个StatefulWidget，通过StatefulWidget的State.setState()来触发InheritedWidget重建（实际上InheritedElement没有重新创建），从而更新那些依赖了InheritedWidget的子Widget。\",\"下图是一个被StatefulWidget包裹的InheritedWidget在setSate(){}方法执行后的流程图：\",\"flutter_render_flow_chart_with_inheritedwidget\",\"当外层StatefulWidget的Element执行到updateChild(child,build,solt);会调用InheritedElement的update() 方法。\",\"这个方法内部会调用updated(oldWidget) 方法，在内部通过notifyClients(oldWidget); 方法，通知原先的InheritedElement的_dependents ，将其标记为dirty，准备rebuild。\",\"在此之后，update()方法还会将当前Element标记为dirty，通过调用rebuild(); 执行performRebuild();\",\"在performRebuild()方法中：\",\"built = build(); 中的build方法：build() => widget.child; 实际上取了widget的child。\",\"然后执行_child = updateChild(_child, built, slot); 这个过程与普通Widget一致。\",\"需要注意的是，updateChild 中，如果子Widget不是const （或者被InheritedWidget外层的widget/state之类的持有）就会被认为built!=_child 从而导致InheritedWidget的子Widget重建。导致的结果就是：虽然InheritedWidget的确只标记了那些依赖了他的Widget，但是由于直接子Widget要重建，所以还是所有的非const Widget都重建了。\"]},\"129\":{\"h\":\"InheritedWidget的获取方式\",\"t\":[\"T? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>({ Object? aspect }); 获取指定类型的InheritedWidget，并且将自己注册到此Widget，以便当该Widget变化的时候，自己也能rebuilt 。复杂度O(1) 。\",\"T? findAncestorWidgetOfExactType<T extends Widget>(); 只获取指定类型的Widget ，包括InheritedWidget ，仅获取该Widget执行一些操作，通常用在interaction event handlers 之类中。复杂度(O(N) 。\"]},\"130\":{\"h\":\"代码示例\",\"t\":[\"根据上述理论，创建一个InheritedWidget来传递数据：\",\"1、AppColor.dart 一个持有color 的InheritedWidget。\",\"class AppColor extends InheritedWidget { final Color color; final Widget child; Function(Color)? onColorChanged; AppColor({ required this.color, required this.child, this.onColorChanged, }) : super(child: child); @override bool updateShouldNotify(covariant AppColor oldWidget) => color != oldWidget.color; static AppColor? of(BuildContext context) { return context.dependOnInheritedWidgetOfExactType<AppColor>(); } } \",\"2、定义一些类，使用或未使用到InheritedWidget：\",\"class NoName extends StatelessWidget { const NoName({ Key? key, }) : super(key: key); @override Widget build(BuildContext context) { print(\\\"NoName build ${this.hashCode}\\\"); return Column( children: [ Column( children: [ // 这里AppColor的_dependents会加入ColorfulContainer(dependencies: [AppColor]) // 因为他用了context.dependOnInheritedWidgetOfExactType<AppColor>(); // 会将自己注册到AppColor ColorfulContainer(), ChangeStateButton(), Text(\\\"This Text Should Not Rebuild\\\"), ], ) ], ); } } class ColorfulContainer extends StatelessWidget { ColorfulContainer({Key? key}) : super(key: key); Widget build(BuildContext context) { var appColor = AppColor.of(context); print( \\\"_ColorfulContainerState appColor?.color:${appColor?.color} appColor:${appColor.hashCode}\\\"); return Container( color: appColor?.color, height: 100, child: Text(\\\"hello color ${appColor?.color}\\\"), ); } } class ChangeStateButton extends StatefulWidget { @override State<ChangeStateButton> createState() => _ChangeStateButtonState(); } class _ChangeStateButtonState extends State<ChangeStateButton> { @override Widget build(BuildContext context) { return MaterialButton( onPressed: () { // 注意下面这个方法，只是查找到InheritedWidget的引用，并没有注册依赖 // 所以当InheritedWidget变化的时候并不会触发此控件重建 // 因为每次onColorChanged时AppColor都会重建，所以需要在这里获取最新的 var appColor = context.findAncestorWidgetOfExactType<AppColor>(); print( \\\"_ChangeStateButtonState appColor?.color:${appColor?.color} appColor:${appColor.hashCode}\\\"); var color = appColor?.color; var newColor = color == Colors.teal ? Colors.blueAccent : Colors.teal; appColor?.onColorChanged?.call(newColor); print( \\\"_ChangeStateButtonState onPressed appColor?.color:${appColor?.color} appColor:${appColor.hashCode}\\\"); }, child: Text(\\\"Change State Button, Shlould NOT Rebuild\\\"), ); } } \",\"3、接下来实现一种基础的使用InheritedWidget的方法，这种方法会在InheritedWidget更新的时候，rebuilt InheritedWidget下面的所有子类，无论他们是否使用到了InheritedWidget（原因是上面说到的Flutter rebuild的机制导致的，实际上InheritedWidget本身只标记了ColorfulContainer为dirty）。\",\"class AlwaysRebuildWidget extends StatefulWidget { final Color color; AlwaysRebuildWidget({Key? key, required this.color}) : super(key: key); @override State<AlwaysRebuildWidget> createState() => _AlwaysRebuildWidgetState(); } class _AlwaysRebuildWidgetState extends State<AlwaysRebuildWidget> { late Color _color; var child = NoName(); @override void initState() { super.initState(); _color = widget.color; } @override Widget build(BuildContext context) { // 这种写法，AppColor的_dependents也只有1个. ColorfulContainer(dependencies: [AppColor]) // 所以每次setState引起AlwaysRebuildWidget重新绘制，引起AppColor重新创建，本应该会重建ColorfulContainer // 但是因为build方法重新执行了一次，所以AppColor和整个NoName都被重建， print(\\\"AlwaysRebuildWidget build${widget.hashCode}\\\"); return AppColor( color: _color, onColorChanged: (color) { setState(() { _color = color; }); }, // 这种写法，AppColor在updateChild的时候会判断widget.child与_child.widget的NoName不一致 // （这是因为，AppColor在notifyClients的时候修改了NoName的child之一ColorfulContainer为dirty） // 从而会更新NoName，导致NoName下面所有的子Widget全部重新绘制 child: NoName()); // 按照上面分析的逻辑，在这里加上const，那么依旧用的是之前的NoName，就不会repaint整个的NoName了 // child: const NoName()); } } \",\"4、接下来实现一种使用InheritedWidget的方法，当InheritedWidget更新的时候，只会更新那些在InheritedWidget这里注册依赖了的Widget。\",\"class SelectiveRebuildWidget extends StatefulWidget { final Widget child; final Color color; SelectiveRebuildWidget({Key? key, required this.child, required this.color}) : super(key: key) {} @override State<SelectiveRebuildWidget> createState() => _SelectiveRebuildWidgetState(); } class _SelectiveRebuildWidgetState extends State<SelectiveRebuildWidget> { late Color _color; @override void initState() { super.initState(); _color = widget.color; } @override Widget build(BuildContext context) { print( \\\"SelectiveRebuildWidget build${widget.child.hashCode} ${widget.hashCode}\\\"); return AppColor( color: _color, onColorChanged: (color) { setState(() { _color = color; }); }, // 这里的AppColor的_dependents只有1个. ColorfulContainer(dependencies: [AppColor]) // 因为setState不会重新创建SelectiveRebuildWidget，所以widget.child也没有被重新 // 创建（但是重新绘制了，导致AppColor也重新绘制） // 所以AppColor的child还是之前的，按照InheritedWidget的规则，只有ColorfulContainer重新绘制了 child: widget.child, ); } } \",\"Using Inherited Widget In Flutter\",\"【Flutter学习】之Widget数据共享之InheritedWidget 梁飞宇\",\"InheritedWidget confusion\",\"Managing Flutter Application State With InheritedWidgets\",\"Does using const in the widget tree improve performance?\",\"StatefulWidget\"]},\"131\":{\"h\":\"Flutter Expanded VS Flexible\",\"t\":[\"在Flutter中，当需要填充容器（Row, Column, or Flex）剩余空间的时候，可以使用Expanded或Flexible，本文对这二者的差异做一分析。\",\"Expanded 比较容易理解，他会强制child改变大小，占据容器的剩余空间，如果有多个Expanded的话，会按照他们的flex占比来分配每个child可以占据的空间大小。\",\"Flexible 稍微特殊一些，有时候看起来似乎他的child占据的大小既不全是父布局的剩余空间，也不全是刚刚包裹child内容的大小。\",\"让我们看一下Flexible的源码：\",\"const Flexible({ Key? key, this.flex = 1, this.fit = FlexFit.loose, required Widget child, }) : super(key: key, child: child); \",\"可以看到，默认情况下他使用的fit模式是FlexFit.loose，查阅文档定义可知：\",\"FlexFit.loose：The child can be at most as large as the available space (but is allowed to be smaller). FlexFit.tight：The child is forced to fill the available space. \",\"也就是说，默认情况下，Flexible的child最大可以是父容器分配给Flexible的大小（假设为MaxSzie）。\",\"但是，如果child的大小比这个MaxSzie要小的话，那么允许child按照自己的大小来显示。\",\"而如果Flexible的fit是FlexFit.tight的话，就会强制child大小为MaxSzie，效果和Expanded一致，实际上Expanded就是FlexFit.tight模式的Flexible：\",\"class Expanded extends Flexible { /// Creates a widget that expands a child of a [Row], [Column], or [Flex] /// so that the child fills the available space along the flex widget's /// main axis. const Expanded({ Key? key, int flex = 1, required Widget child, }) : super(key: key, flex: flex, fit: FlexFit.tight, child: child); } \",\"对于上述的结论，我们可以从下面的代码中得到证实：\",\"Untitled\",\"main() => runApp(MaterialApp(home: BodyWidget())); class BodyWidget extends StatefulWidget { @override State<StatefulWidget> createState() { return _BodyState(); } } class _BodyState extends State<BodyWidget> { @override Widget build(BuildContext context) { final double width = MediaQuery.of(context).size.width; final int count = 100; return Material( child: Container( color: Colors.grey.shade200, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Row( mainAxisSize: MainAxisSize.max, children: [ Container( color: Colors.teal, child: Text( 'Container Text ', )), Flexible( child: Container( color: Colors.blue, child: Text(' Text.Flexible Text.Flexible Text.Flexible.')), ), Flexible( child: Container( color: Colors.yellow, child: Text('Flexible Text.')), ), Flexible( child: Container( color: Colors.lightGreen, child: Text('Flexible.')), ), ], ), SizedBox( height: 80, width: width, child: ListView.builder( itemBuilder: (context, index) { return SizedBox( width: width / count, child: Column( mainAxisSize: MainAxisSize.max, children: [ Container( width: 1, height: index % 5 == 0 ? 30 : 20, color: Colors.purple, ), if (index % 5 == 0) Flexible( child: Text( '$index', style: const TextStyle(fontSize: 5), ), ), ], ), ); }, itemCount: count, scrollDirection: Axis.horizontal, ), ), ], ), ), ); } } \",\"Expanded和Flexible默认情况下都会按照flex占据父容器剩余的可用空间，但是不同的是，Expanded会强制child改变大小为父容器分配的大小，而Flexible则会告诉child，最大只能是父容器分配的大小，要是child想要小一些的话，也可以按照child的大小显示。\",\"如果改变Flexible的fit为FlexFit.tight的话，Expanded和Flexible没有差别。\"]},\"132\":{\"h\":\"Flutter Widget简单入门\",\"t\":[\"Flutter是Google提出的跨平台开发框架，使用Dart语言，支持Android，IOS系统。Flutter一个重要的概念即是——“万物皆控件（Widget）”，像Padding,Center等都是Widget。\",\"Widget和Android中的View很相似但又有不同，Widget一旦生成便“一成不变”，直到下一次因为Widget更改或者state更新而被重新创建（Flutter’s framework creates a new tree of widget instances.），而View则只会被drawn一次，直到invalidate方法被调用。\",\"本文主要记录一下Flutter中两个重要的控件：StatelessWidget和StatefulWidget，以及Flutter开发的一些基础知识。\",\"Flutter以Dart开发，其工程基本的结构如下：\",\"android\",\"ios\",\"lib \",\"main.dart\",\"pubspec.yaml //Flutter工程的配置信息\",\"Flutter项目启动后会首先加载/lib/main.dart中的main()方法。 一个标准的material app的main.dart内容如下：\",\"import 'package:flutter/material.dart'; import './product_manager.dart'; main() => runApp(MyApp());//在main()方法中调用了material的runApp()方法，里面传入了要展示的Widget——APP的界面，相当于Android的setContentView() class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( theme: ThemeData( primarySwatch: Colors.deepOrange ), home: Scaffold(//脚手架，一个预制的APP界面结构，也可以使用自定义Widget appBar: AppBar( title: Text(\\\"EasyList\\\"), ), body: ProductManager(\\\"Test\\\"),//这里是自定义的控件，布局信息主要在这里展示 ), ); } } \",\"StatelessWidget和StateFulWidget区别在于：前者一旦创建，状态便不会再更改，而后者则可以动态改变State从而使flutter改变其状态。但是两者都会在每一帧被rebuild。\"]},\"133\":{\"h\":\"StatelessWidget\",\"t\":[\"A StatelessWidget is just what it sounds like—a widget with no state information.\",\"StatelessWidget一旦创建便不会更改，其状态只和构造函数中的参数有关。下面是一个StatelessWidget示例，一般只需要重写其build()方法，返回要展示的控件即可：\",\"class MyWidget extends StatelessWidget { @override Widget build(BuildContext context) { return CustomerWidget();//在这里构建一个页面并返回 } } \"]},\"134\":{\"h\":\"StatefulWidget\",\"t\":[\"StatefulWidget has a State object that stores state data across frames and restores it.\",\"StatefulWidget可以通过动态更改其包含的State，从而使flutter在下一次更新界面时依据state更新StateWidget，本质上还是更新了一个可以在多帧之间存活的State，在下一帧更新控件。\",\"下面是一个StatefulWidget的示例:\",\"class ProductManager extends StatefulWidget { @override State<StatefulWidget> createState() { return ProductManagerState(); } } class ProductManagerState extends State<ProductManager> { @override Widget build(BuildContext context) { return CustomerWidget(); } } \",\"可以注意到StatefulWidget重写了createState()，而该方法返回了自定义的ProductManagerState类对象，在该类中build()方法实现和StatelessWidget中的方法类似，返回要展示的页面控件。\",\"两者的不同之处在于，StatefulWidget中可以调用setState()，更改其相应的state，以便告诉flutter在下一次rebuild的时候更新UI。\",\"StatelessWidget要想实现动态更新其内容，可以在其外部包裹一层StatefulWidget，通过StatefulWidget更改状态state，将更改后的state传给StatelessWidget，从而间接更新了StatelessWidget的状态。\",\"可以通过对该方法就行包装，使得在StatelessWidget控件中调用StatefulWidget控件的setState()方法，达到刷新页面的效果：\",\"// StatefulWidget void aFun(){ setState(() { // update UI }); } AStatelessWidget(aFun);// 将该方法传入StatelessWidget中 // StatelessWidget final Function aFun AStatelessWidget(this.aFun);// 接收传入的方法 aFun();// 执行该方法，从而实现调用StatelessWidget中的方法也可以刷新UI \"]},\"135\":{\"h\":\"Intent\",\"t\":[\"Android的Intent有两个主要作用：\",\"Activity间跳转\",\"组件间传递数据\",\"Flutter对此相应：\",\"使用Navigator和Routes实现在同一个“Activity”中不同的界面间（ “screen” or “page”）跳转（push，pop），Navigator类似于Android中的Activity栈。\",\"通过Android原生Intent组件获取到其他App传来的数据，然后中通过下面的方法实现Android和Flutter交互：\",\"示例代码：\",\" //Android MethodChannel(getFlutterView(), \\\"app.channel.shared.data\\\") .setMethodCallHandler(MethodChannel.MethodCallHandler() { @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) { if (methodCall.method.contentEquals(\\\"getSharedText\\\")) { result.success(sharedText); sharedText = null; } } }); //Flutter class _SampleAppPageState extends State<SampleAppPage> { static const platform = const MethodChannel('app.channel.shared.data'); String dataShared = \\\"No data\\\"; @override void initState() { super.initState(); getSharedText(); } @override Widget build(BuildContext context) { return Scaffold(body: Center(child: Text(dataShared))); } getSharedText() async { var sharedData = await platform.invokeMethod(\\\"getSharedText\\\"); if (sharedData != null) { setState(() { dataShared = sharedData; }); } } } \"]},\"136\":{\"h\":\"线程\",\"t\":[\"Flutter是单线程的，他的线程和Android的UI线程绑定，在进行网络请求，IO操作等时，可以使用sync/await 在执行完耗时操作后，再去更新state刷新UI。\",\"Since Flutter is single threaded and runs an event loop (like Node.js), you don’t have to worry about thread management or spawning background threads. If you’re doing I/O-bound work, such as disk access or a network call, then you can safely use async/await and you’re all set.\",\"loadData() async { String dataURL = \\\"https://jsonplaceholder.typicode.com/posts\\\"; http.Response response = await http.get(dataURL); setState(() { widgets = json.decode(response.body); }); } \",\"而如果有特别频繁的cpu计算以至于能导致UI挂起，可以考虑使用Isolates利用CPU多核心处理任务，但是这样就不能和主线程共享数据，通过ReceivePort，SendPort等传递数据。\",\"Isolates(隔离) are separate execution threads that do not share any memory with the main execution memory heap. This means you can’t access variables from the main thread, or update your UI by calling setState(). Unlike Android threads, Isolates are true to their name, and cannot share memory (in the form of static fields, for example).\"]},\"137\":{\"h\":\"本地资源\",\"t\":[\"截止Flutter beta 2 仍然不能直接访问Android assets或者其他本地资源，但是Android可以访问flutter的assets资源：\",\"val flutterAssetStream = assetManager.open(\\\"flutter_assets/assets/my_flutter_asset.png\\\") \",\"通过Channel，flutter可以间接访问Android资源，反之亦然。\",\"主要是通过Channel完成，可以称之为隧道。主要是MethodChannel和MessageChannel两种，第一种是调用方法，第二种是传递信息。首先通信的双方是Flutter和本地操作系统或者应用，而且方法的调用和消息的方法可以从任何一方发起，类似RPC（远程过程调用）。\",\"作者：黄马\",\"链接：掘金 https://juejin.im/post/5b35a75e51882574ea3a25e3\",\"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\"]},\"138\":{\"h\":\"生命周期\",\"t\":[\"Flutter生命周期没有Android中那么“重要”，可以重写 didChangeAppLifecycleState() 监听。\",\"inactive — 应用处于非活动状态，不接受输入。iOS\",\"paused — 应用在后台运行，不可见，不接受输入。类似Android的onPause()\",\"resumed — 应用可见，并接受输入。类似Android的onPostResume()\",\"suspending — 应用请求暂停。类似Android的onStop()\"]},\"139\":{\"h\":\"布局\",\"t\":[\"Flutter有布局Widget如：\",\"Column 列\",\"Row 行\",\"Stack 左上角堆积，类似FrameLayout\"]},\"140\":{\"h\":\"点击事件\",\"t\":[\"FLutter中的“onClick()”: onPressed,onTap等等。\",\"添加点击事件,在Widget外面添加一个GestureDetectorWidget：\",\"GestureDetector( child: Padding( padding: EdgeInsets.all(10.0), child: Text(\\\"Row $i\\\")), onTap: () { print('row tapped'); }, ); \",\"Flutter Tutorial for Beginners - Build iOS and Android Apps with Google's Flutter & Dart\",\"Flutter for android\",\"Flutter 访问本地资源\"]},\"141\":{\"h\":\"Flutter中的异常处理\",\"t\":[\"FLutter中的错误不会导致应用程序奔溃，只会终止执行出错代码之后的逻辑，在导致Widget.build()返回为null的错误会导致Widget构建失败，并返回红底黄字的错误原因Widget（在Release模式则会显示为灰底区域）；一般来说，Flutter中的错误都会被FlutterError.onError捕获并处理；对于异步方法产生异常等Flutter框架没有捕获的情况，会交由当前代码所在的Zone处理（这些异常可以使用runZonedGuarded捕获并处理）。\",\"为什么 flutter 触发异常的时候不会崩溃？ 这个和 flutter 的消息循环机制有关，任务分两种，一个是微任务 microtask，一个是事件 event，他们有自己的队列，每个任务是相互独立的，一旦某个任务触发异常，也就是导致这个任务后续代码无法执行，并不会影响其他任务执行\",\"本文基于Flutter (Channel stable, 2.2.3)\",\"Flutter中的错误处理分为以下几种：\"]},\"142\":{\"h\":\"try...catch\",\"t\":[\"对于普通的错误，可以通过try...catch来捕获：\",\" try { var list = [1, 2]; var three = list[3]; } on RangeError catch (e) { print(\\\"这里是捕获RangeError类型的异常 $e\\\"); } catch (e) { print(\\\"这里是兜底的捕获异常 $e\\\"); } finally { print(\\\"这里是无论如何都会执行的代码\\\"); } \",\"对于，异步异常，可以使用await等待其执行完毕，将其变为同步任务，否则无法则捕获。\"]},\"143\":{\"h\":\"ErrorWidget.builder\",\"t\":[\"当在Widget构建过程中出现错误，导致build()方法返回null，Flutter框架会调用ErrorWidget.builder返回一个Widget替代出错的Widget。\",\"默认情况下，debug模式返回的是红底黄字的错误提示，而release模式返回的是灰色Widget。\",\"可以在RunApp方法中替换这个默认的错误界面：\",\"runApp(MaterialApp( home: Scaffold( appBar: AppBar(), body: BodyWidget(), ), builder: (context, widget) { // Widget在Build时出错的话，展示此Widget， // 如果不定义的话，debug下为红底黄字错误信息，release会显示为灰色布局 // errorDetails在release模式下为空 ErrorWidget.builder = (FlutterErrorDetails errorDetails) { return MainErrorWidget(widget, errorDetails); }; return widget ?? Container(); }, )); \",\"上述代码中的MainErrorWidget是一个自定义的展示错误信息的页面。\",\"MainErrorWidget的一种实现方式\",\"class MainErrorWidget extends StatelessWidget { Widget? parentWidget; FlutterErrorDetails errorDetails; MainErrorWidget(this.parentWidget, this.errorDetails); @override Widget build(BuildContext context) { print(\\\"3. 布局出现错误，展示错误页面,此处错误在release中也会调用FlutterError.onError\\\"); Widget error = Card( child: SingleChildScrollView( child: Container( padding: const EdgeInsets.all(20), color: Colors.green, child: Text( '布局出现错误，以下是错误信息:\\\\n$errorDetails', style: TextStyle(fontSize: 10, color: Colors.white), ), ), ), ); if (parentWidget is Scaffold || parentWidget is Navigator) { debugPrint( \\\"widget${parentWidget?.key?.toString()} ($parentWidget) is Scaffold ${parentWidget is Scaffold} or Navigator ${parentWidget is Navigator}\\\"); // error = Container(child: error); } return error; } } \",\"需要注意的是，错误Widget在Debug和Release模式下有一些区别：\",\"Debug模式下ErrorWidget.builder会返回错误详细信息FlutterErrorDetails ，Release下则不会；\",\"Debug模式下，Widget等出错会打印Exception caught by widgets library ... 等提示并输出错误堆栈信息，但是Release模式下不会；\",\"Debug模式下，出错不会调用FlutterError.onError，Release模式下会。\"]},\"144\":{\"h\":\"FlutterError.onError\",\"t\":[\"上述几种情况都没有处理的，被Flutter框架引起的异常，会在这里被处理。\",\"在Flutter 2.2.3中，Debug模式下如onPressed中的未捕获错误等都会被Widget等捕获，而不会走到这里来，在Release模式下则会调用FlutterError.onError。\",\"在这里可以对错误进行处理，比如输出到控制台、交给Zone统一处理、直接结束掉APP等：\",\"FlutterError.dumpErrorToConsole(details); 输出到控制台\",\"exit(1); 退出APP\",\"Zone.current.handleUncaughtError(details.exception, details.stack); 交给Zone统一处理\",\"defaultOnError?.call(details); 自己处理完异常后，也要把异常向上抛 【推荐】，其中defaultOnError 可以预先缓存final defaultOnError = FlutterError.onError;\"]},\"145\":{\"h\":\"runZonedGuarded(onError)\",\"t\":[\"上述几种情况都没有处理的异常，会被发送到这里处理，可以类比为Android中的Thread.UncaughtExceptionHandler。\",\"runZonedGuarded(() async { runApp(...); }, (Object error, StackTrace stack) { // 没有被Flutter捕获的错误,全局未捕获异常处理,类似于Android的Thread.UncaughtExceptionHandler /// 比如异步的方法 print(\\\"2. runZonedGuarded.onError $error\\\"); }); \",\"Zone可以理解为一个沙盒，其中的代码出错，包括异步的都可以捕获到。但是如果是另外一个沙盒中的错误则无法处理。\",\"Flutter 官网异常处理\",\"Flutter异常处理\"]},\"146\":{\"h\":\"Flutter动画分析之AnimatedWidget&ImplicitlyAnimatedWidget\",\"t\":[\"本文讨论的 Flutter 动画主要限定在: 随着每一帧的变化，修改 Flutter Widget 的大小、颜色、位置等属性，使之看起来从一种状态渐变为另外一种状态 这一范围。\",\"在之前的文章中，我们将 Flutter 中动画的实现分为 底层实现 和 封装好的 Widget 两大部分，目前已经分析了底层实现的部分：\",\"AnimationController\",\"Tween&Curve\",\"而 Flutter 封装好的动画 Widget 主要分为两大类：\",\"Flutter中与动画有关的Widget\",\"ImplicitlyAnimatedWidget 隐式动画，关于动画的开始、停止等都封装在 Widget 内部，只要 Widget 前后传入的值不同 便可以自动从 old 渐变到 new，内置的这些类主要以 AnimatedFoo 命名。\",\"AnimatedWidget，显式动画，需要使用者自己创建 Animation（一般是 AnimationController）并通过其 主动管理动画，此类 Widget 主要是监听 AnimationController 的值并刷新 Widget 的内容。\",\"此类 Widget 主要有三种使用方式：\",\"继承 AnimatedWidget\",\"使用 AnimatedBuilder\",\"使用各种内置的 AnimatedWidget 子类，一般以 FooTransition 命名。\",\"对于 Flutter 中这些与动画有关的类如何选择，Flutter 官方给了一张图：\",\"如何实现Flutter中的动画\",\"简单来说，Flutter 有一些内置的动画，在要写动画的时候，可以依次考虑（实现程度由易到难）：\",\"AnimatedFoo 参考文章，设置新的状态，这些控件会自动从之前的状态切换到新状态\",\"TweenAnimationBuilder 参考文章，将任意属性在 Tween 指定的范围变化，和上面的 AnimatedFoo 都是属于Implicitly animated widgets（隐式动画，由系统控件控制动画）。\",\"FooTranslation\",\"AnimatedBuilder / AnimatedWidget\",\"CustomPainter\",\"本文将对 Flutter 内置封装好的动画相关的 Widget 的实现和用法进行简单分析。\",\"按照上述分析，Flutter 中的动画 Widget 可以大体分为 隐式动画 和 显式动画 两种。\"]},\"147\":{\"h\":\"ImplicitlyAnimatedWidget\",\"t\":[\"ImplicitlyAnimatedWidgets (and their subclasses) automatically animate changes in their properties whenever they change.\",\"隐式动画内部持有 AnimationController 以管理动画，默认没有动画，当使用不同的值重新构建 Widget 的时候，会执行动画，使用者只能设置 Duration 和 Curve，如果想要更深入的控制动画（比如暂停动画）则应该使用 AnimatedWidget。\",\"ImplicitlyAnimatedWidget 主要分为 2 大类：\",\"TweenAnimationBuilder，which animates any property expressed by a Tween to a specified target value.\",\"AnimatedFoo \",\"AnimatedAlign, which is an implicitly animated version of Align.\",\"AnimatedContainer, which is an implicitly animated version of Container.\",\"AnimatedDefaultTextStyle, which is an implicitly animated version of DefaultTextStyle.\",\"AnimatedScale, which is an implicitly animated version of Transform.scale.\",\"AnimatedRotation, which is an implicitly animated version of Transform.rotate.\",\"AnimatedSlide, which implicitly animates the position of a widget relative to its normal position.\",\"AnimatedOpacity, which is an implicitly animated version of Opacity.\",\"AnimatedPadding, which is an implicitly animated version of Padding.\",\"AnimatedPhysicalModel, which is an implicitly animated version of PhysicalModel.\",\"AnimatedPositioned, which is an implicitly animated version of Positioned.\",\"AnimatedPositionedDirectional, which is an implicitly animated version of PositionedDirectional.\",\"AnimatedTheme, which is an implicitly animated version of Theme.\",\"AnimatedCrossFade, which cross-fades between two given children and animates itself between their sizes.\",\"AnimatedSize, which automatically transitions its size over a given duration.\",\"AnimatedSwitcher, which fades from one widget to another.\",\"我们简单分析一下 ImplicitlyAnimatedWidget 和 TweenAnimationBuilder：\",\"abstract class ImplicitlyAnimatedWidget extends StatefulWidget { const ImplicitlyAnimatedWidget({ Key? key, this.curve = Curves.linear, required this.duration, this.onEnd, }) : super(key: key); /// The curve to apply when animating the parameters of this container. final Curve curve; /// The duration over which to animate the parameters of this container. final Duration duration; /// Called every time an animation completes. /// /// This can be useful to trigger additional actions (e.g. another animation) /// at the end of the current animation. final VoidCallback? onEnd; @override ImplicitlyAnimatedWidgetState<ImplicitlyAnimatedWidget> createState(); } \",\"ImplicitlyAnimatedWidget.createState()必须返回 ImplicitlyAnimatedWidgetState 或者 AnimatedWidgetBaseState 及其子类。\",\"ImplicitlyAnimatedWidget 作为 StatefulWidget，它的主要逻辑在 ImplicitlyAnimatedWidgetState 中：\",\"abstract class ImplicitlyAnimatedWidgetState<T extends ImplicitlyAnimatedWidget> extends State<T> with SingleTickerProviderStateMixin<T> { // 隐式动画内部维护着自己的AnimationController AnimationController get controller => _controller; late final AnimationController _controller = AnimationController( duration: widget.duration, debugLabel: kDebugMode ? widget.toStringShort() : null, vsync: this, ); // 驱动此隐式动画的animation Animation<double> get animation => _animation; late Animation<double> _animation = _createCurve(); CurvedAnimation _createCurve() { return CurvedAnimation(parent: _controller, curve: widget.curve); } } \",\"ImplicitlyAnimatedWidgetState 中，根据传入的 Duration 和 Curve ，创建并持有了 AnimationController 和 Animation<double> 用于驱动隐式动画。\"]},\"148\":{\"h\":\"initState\",\"t\":[\"在ImplicitlyAnimatedWidgetState.initState方法中:\",\"监听_controller的状态，当AnimationStatus.completed时回调ImplicitlyAnimatedWidget.onEnd方法；\",\"此外还调用了_constructTweens()遍历 Tween，并调用由子类实现的forEachTween()方法（子类在此方法内部，获取到对应的 Tween，比如 Padding，从而在监听到_controller变化并触发 rebuilt 时使用Animatable.evaluate()方法获取并显示最新的属性，实现动画效果）；\",\"最后还调用了didUpdateTweens()方法通知子类 Tweens 发生变化了。\"]},\"149\":{\"h\":\"_constructTweens\",\"t\":[\"_constructTweens()方法会创建一个 TweenVisitor<dynamic>并传给子类 forEachTween()方法，子类可以使用其获取对应的 Tween 对象。\",\"_constructTweens()则在此过程中，使用_shouldAnimateTween()得知了子类中是否有 Tween 可以开始动画——shouldStartAnimation。\",\" bool _constructTweens() { bool shouldStartAnimation = false; // forEachTween方法由子类实现 forEachTween((Tween<dynamic>? tween, dynamic targetValue, TweenConstructor<dynamic> constructor) { if (targetValue != null) { tween ??= constructor(targetValue); // 判断targetValue是否不等于Tween.end if (_shouldAnimateTween(tween, targetValue)) shouldStartAnimation = true; } else { tween = null; } return tween; }); return shouldStartAnimation; } bool _shouldAnimateTween(Tween<dynamic> tween, dynamic targetValue) { return targetValue != (tween.end ?? tween.begin); } \"]},\"150\":{\"h\":\"didUpdateWidget\",\"t\":[\"当 ImplicitlyAnimatedWidget 被重新创建时，会调用 ImplicitlyAnimatedWidgetState.didUpdateWidget 方法。\",\"在此方法中，除了检查并更新 Curve、Duration、Tween 之外，最重要的是使用 AnimationController.forward()开启了动画。也就是说——“ImplicitlyAnimatedWidget 第一次插入 Widget Tree 时没有动画，当再次被更新时会触发动画”。\",\" void didUpdateWidget(T oldWidget) { super.didUpdateWidget(oldWidget); // 如果Curve变化则创建新的CurveAnimation if (widget.curve != oldWidget.curve) { (_animation as CurvedAnimation).dispose(); _animation = _createCurve(); } // 更新duration _controller.duration = widget.duration; if (_constructTweens()) { // 如果Tween可以开始，则更新其begin和end值 forEachTween((Tween<dynamic>? tween, dynamic targetValue, TweenConstructor<dynamic> constructor) { _updateTween(tween, targetValue); return tween; }); // 当Widget更新后，开始动画 _controller ..value = 0.0 ..forward(); didUpdateTweens(); } } \"]},\"151\":{\"h\":\"forEachTween\",\"t\":[\"子类必须实现此方法，使用传入的 TweenVisitor 创建自己对应的 Tween。\",\"void forEachTween(TweenVisitor<dynamic> visitor); \"]},\"152\":{\"h\":\"didUpdateTweens\",\"t\":[\"当 Tween 变化时会调用此方法通知子类，子类（可选）可以实现此方法。\",\"到目前为止，我们的 AnimationController 已经控制动画开始执行，但是因为没有监听 AnimationController.value 的变化，所以还不能自动触发 ImplicitlyAnimatedWidgetState.build()方法。\",\"为了实现动画效果，子类可以选择自己主动监听 AnimationController；或者，继承 AnimatedWidgetBaseState：\",\"abstract class AnimatedWidgetBaseState<T extends ImplicitlyAnimatedWidget> extends ImplicitlyAnimatedWidgetState<T> { @override void initState() { super.initState(); // 注意此处监听了AnimationController的变化并自动触发setState controller.addListener(_handleAnimationChanged); } void _handleAnimationChanged() { setState(() { /* The animation ticked. Rebuild with new animation value */ }); } } \",\"ImplicitlyAnimatedWidget 的子类主要实现 AnimatedWidgetBaseState/ImplicitlyAnimatedWidgetState 的forEachTween()和build()方法即可。前者用于生成 Widget 所需的 Tween；后者则使用生成的 Tween<T>的evaluate(animation)方法计算对应的属性并展示。\",\"以 AnimatedPadding 为例，它继承自 ImplicitlyAnimatedWidget，创建的_AnimatedPaddingState 继承自 AnimatedWidgetBaseState<AnimatedPadding>：\",\"class _AnimatedPaddingState extends AnimatedWidgetBaseState<AnimatedPadding> { EdgeInsetsGeometryTween? _padding; @override void forEachTween(TweenVisitor<dynamic> visitor) { // 创建所需要的Tween _padding = visitor(_padding, widget.padding, (dynamic value) => EdgeInsetsGeometryTween(begin: value as EdgeInsetsGeometry)) as EdgeInsetsGeometryTween?; } // 当AnimationController监听的Ticker时执行setState触发rebuilt @override Widget build(BuildContext context) { return Padding( // 使用CurveAnimation计算当前对应的padding值 padding: _padding! .evaluate(animation) .clamp(EdgeInsets.zero, EdgeInsetsGeometry.infinity), child: widget.child, ); } // ... } \",\"上述分析是继承 ImplicitlyAnimatedWidget 实现隐式动画的常用流程，Flutter 中内置的 AnimatedFoo 动画都是类似实现。\"]},\"153\":{\"h\":\"TweenAnimationBuilder\",\"t\":[\"ImplicitlyAnimatedWidget 的子类（以 AnimatedFoo 命名的一众子类）提供了常见的动画效果，但是如果有特殊的动画效果需要实现，除了直接继承 ImplicitlyAnimatedWidget 之外，还可以使用 TweenAnimationBuilder 并传入 Tween 来实现：\",\" return TweenAnimationBuilder<double>( tween: Tween<double>(begin: 0, end: targetValue), duration: const Duration(seconds: 1), builder: (BuildContext context, double size, Widget? child) { return IconButton( ... ); }, child: const Icon(Icons.aspect_ratio), ); \",\"当 Widget 首次 build 的时候就会触发动画从 Tween.begin 过渡到 Tween.end；当再次提供一个有新 end 的 Tween 也可以随时触发新动画（新动画从动画当前值开始）。\",\"需要注意：\",\"传入到 TweenAnimationBuilder 中的 Tween 被其持有（可能修改）,所以不应当再操作它；\",\"当动画执行完毕会调用 TweenAnimationBuilder.onEnd 方法；\",\"为了性能，应当将不需要每次更新的 subtree 传入到 TweenAnimationBuilder.child 中避免重绘。\",\"和其他 ImplicitlyAnimatedWidget 的子类一样，TweenAnimationBuilder 的主要逻辑也在继承自 AnimatedWidgetBaseState 的_TweenAnimationBuilderState 中：\",\"class _TweenAnimationBuilderState<T extends Object?> extends AnimatedWidgetBaseState<TweenAnimationBuilder<T>> { Tween<T>? _currentTween; @override void initState() { // 内部持有使用者传入的Tween _currentTween = widget.tween; _currentTween!.begin ??= _currentTween!.end; super.initState(); if (_currentTween!.begin != _currentTween!.end) { // 如果Tween有效则开始动画 controller.forward(); } } @override void forEachTween(TweenVisitor<dynamic> visitor) { assert( widget.tween.end != null, 'Tween provided to TweenAnimationBuilder must have non-null Tween.end value.', ); _currentTween = visitor(_currentTween, widget.tween.end, (dynamic value) { assert(false); throw StateError('Constructor will never be called because null is never provided as current tween.'); }) as Tween<T>?; } @override Widget build(BuildContext context) { // 使用者实现builder创建对应的Widget return widget.builder(context, _currentTween!.evaluate(animation), widget.child); } } \",\"使用时需要注意，只有传入 TweenAnimationBuilder 的 Tween 是一个新的、并且 end 值和之前不一样的才会触发动画。如果 end 值一样则无动画、如果不是新的则 builder 的内容只会突然变化为 end 值对应状态而无动画。\"]},\"154\":{\"h\":\"AnimatedWidget\",\"t\":[\"之前分析的 TweenAnimationBuilder 以及 ImplicitlyAnimatedWidget 的其他子类，基本上都只能定义动画的 Tween、Duration、Curve 等，动画的开始结束动都由这些 Widget 内部控制。\",\"如果需要手动主动控制动画，可以选择使用 显式动画 —— AnimatedWidget 及其子类：\",\"其同样也分为 2 大类：\",\"AnimatedBuilder, which is useful for complex animation use cases and a notable exception to the naming scheme of AnimatedWidget subclasses.\",\"FooTransition 子类 \",\"AlignTransition, which is an animated version of Align.\",\"DecoratedBoxTransition, which is an animated version of DecoratedBox.\",\"DefaultTextStyleTransition, which is an animated version of DefaultTextStyle.\",\"PositionedTransition, which is an animated version of Positioned.\",\"RelativePositionedTransition, which is an animated version of Positioned.\",\"RotationTransition, which animates the rotation of a widget.\",\"ScaleTransition, which animates the scale of a widget.\",\"SizeTransition, which animates its own size.\",\"SlideTransition, which animates the position of a widget relative to its normal position.\",\"FadeTransition, which is an animated version of Opacity.\",\"AnimatedModalBarrier, which is an animated version of ModalBarrier.\",\"AnimatedWidget 比 ImplicitlyAnimatedWidget 简单许多，其接受一个 Listenable 对象，在_AnimatedState 中监听其并触发 rebuilt。\",\"abstract class AnimatedWidget extends StatefulWidget { const AnimatedWidget({ Key? key, required this.listenable, }) : assert(listenable != null), super(key: key); // Commonly an [Animation] or a [ChangeNotifier]. final Listenable listenable; // 提供了build方法供子类根据不同的状态创建Widget @protected Widget build(BuildContext context); } \",\"AnimatedWidget.listenable通常是 AnimationController，当然也可以是其他实现 Listenable 的类（including ChangeNotifier and ValueNotifier）。\"]},\"155\":{\"h\":\"_AnimatedState\",\"t\":[\"AnimatedWidget 的主要逻辑在对应的_AnimatedState 中：\",\"class _AnimatedState extends State<AnimatedWidget> { @override void initState() { super.initState(); // 监听listenable，调用setState从而触发rebuilt widget.listenable.addListener(_handleChange); } @override void didUpdateWidget(AnimatedWidget oldWidget) { super.didUpdateWidget(oldWidget); // 如果listenable改变了则重写添加listener if (widget.listenable != oldWidget.listenable) { oldWidget.listenable.removeListener(_handleChange); widget.listenable.addListener(_handleChange); } } @override void dispose() { widget.listenable.removeListener(_handleChange); super.dispose(); } void _handleChange() { setState(() { // The listenable's state is our build state, and it changed already. }); } // 注意这里使用了子类实现的Widget.build方法创建Widget @override Widget build(BuildContext context) => widget.build(context); } \",\"可以看到，相对于隐式动画 ImplicitlyAnimatedWidget，显示动画 AnimatedWidget 的逻辑要简单的多，只是监听传入的 Listenable 并触发 rebuilt 即可。对于动画的控制则由 Listenable（通常是 AnimationController）处理。\",\"也就是说，显示动画 AnimatedWidget 只是替子类做了监听/移除监听 Listenable 的值变化，并触发 rebuilt 的工作，如何获取变化的值，以及展示对应的 Widget 则需要子类自己处理。\",\"他的子类 FooTransition 实现逻辑也比较简单，只需要在在 Widget.build 根据不同的状态创建创建不同属性的 Widget 即可：\",\"class RotationTransition extends AnimatedWidget { const RotationTransition({ Key? key, required Animation<double> turns, this.alignment = Alignment.center, this.filterQuality, this.child, }) : assert(turns != null), // AnimatedWidget会监听turns的值变化，自动触发rebuilt， // 从而调用此build()方法更新Widget super(key: key, listenable: turns); Animation<double> get turns => listenable as Animation<double>; final FilterQuality? filterQuality; final Alignment alignment; final Widget? child; @override Widget build(BuildContext context) { return Transform.rotate( // 这里根据turns的值计算当前的角度 angle: turns.value * math.pi * 2.0, alignment: alignment, filterQuality: filterQuality, child: child, ); } } \"]},\"156\":{\"h\":\"AnimatedBuilder\",\"t\":[\"一般来说，Flutter 内置的以 FooTransition 命名的 AnimatedWidget 的子类可以满足基本的需求，但是如果想要实现更复杂的效果，除了直接继承 AnimatedWidget 之外，还可以使用 AnimatedBuilder 实现丰富的动画：\",\"AnimatedBuilder( animation: _controller, child: Container( ... ), builder: (BuildContext context, Widget? child) { return Transform.rotate( angle: _controller.value * 2.0 * math.pi, child: child, ); }, ) \",\"而 AnimatedBuilder 的实现也比较简单：\",\"class AnimatedBuilder extends AnimatedWidget { /// Creates an animated builder. /// /// The [animation] and [builder] arguments must not be null. const AnimatedBuilder({ Key? key, required Listenable animation, required this.builder, this.child, }) : assert(animation != null), assert(builder != null), super(key: key, listenable: animation); /// Called every time the animation changes value. final TransitionBuilder builder; /// The child widget to pass to the [builder]. /// /// 可选，如果AnimatedBuilder要创建的一部分内容和动画无关，为了优化性能， /// 可以将其传给child，并在builder中直接复用 final Widget? child; @override Widget build(BuildContext context) { return builder(context, child); } } \",\"ImplicitlyAnimatedWidget 隐式动画，内部创建并监听 AnimationController 以维护动画，控制动画的开始和结束，用户可以通过传入 Duration、Curve、Tween 等决定动画的时长、曲线、开始和结束值等，当动画相关的属性变化时，隐式动画会自动播放，使用者不可以直接控制动画。 Flutter 内置的隐式动画为 TweenAnimationBuilder 和 AnimatedFoo。\",\"AnimatedWidget 显式动画，接受 Listenable（通常是 AnimationController）并监听其值变化，以触发 Widget 重新 build，其子类中一般会监听 Listenable 的值并计算设置 Widget 对应的属性。使用者需要负责创建、控制 Listenable 从而控制动画播放。Flutter 内置的显式动画为 AnimatedBuilder 和 FooTransition。\",\"在使用Flutter实现Widget动画时，可以按照以下顺序选择实现方式：\",\"AnimatedFoo，选择内置的隐式动画，以实现当Padding、Alignment等属性变化时自动渐变到新值的动画效果。\",\"TweenAnimationBuilder/继承ImplicitlyAnimatedWidget，当上一步无法满足需求时，可以考虑进一步自定义实现隐式动画。\",\"FooTransition，如果不止要展示动画，还希望能够控制动画开始、结束，就使用内置的显式动画结合自己创建的AnimationController实现动画。\",\"AnimationBuilder/AnimatedWidget，如果没有满足条件的内置显式动画，可以使用自定义实现显式动画。\",\"CustomPainter，如果上述方法仍然无法满足动画需求，可以考虑使用CustomPainter自己绘制动画。\",\"动画效果介绍 flutter.cn\",\"ImplicitlyAnimatedWidget\",\"AnimatedWidget\"]},\"157\":{\"h\":\"Flutter动画分析之AnimationController\",\"t\":[\"本文讨论的 Flutter 动画主要限定在: 随着每一帧的变化，修改 Flutter Widget 的大小、颜色、位置等属性，使之看起来从一种状态渐变为另外一种状态 这一范围。\",\"Flutter 中关于动画的类有很多，为了便于分析，将其分为两大类：\",\"Flutter 框架底层实现动画的各个类，比如 AnimationController、Ticker、Tween、Curve 等\",\"基于底层实现，提供进一步封装的 Flutter 动画相关的 Widget 类，比如 AnimatedWidget、ImplicitlyAnimatedWidget 和他们的子类。\",\"他们的关系如下：\",\"AnimationController 通过 Ticker 监听 Flutter 屏幕帧刷新：\",\"Flutter中AnimationController与Ticker关系\",\"每一帧刷新后，AnimationController 监听并根据 Duration 等计算出当前的 Animation.value； 此外也可以通过 Tween 将 double 类型转化为其他的类型比如 Offset 等； 上述两种方式中 value 都是随着时间线性变化，而 Curve 可以与 CurveTween、AnimationController 等结合使 value 实现非线性的变化。\",\"Flutter各种动画底层类关系\",\"当随着时间变化，计算出当前的 Animation.value 时，便可以根据此值修改 Flutter Widget 的各个属性，从而实现动画的视觉效果。\",\"Flutter中与动画有关的Widget\",\"从上图可以看到，Flutter 提供的动画 Widget 主要分为两大类：\",\"ImplicitlyAnimatedWidget 隐式动画，关于动画的开始、停止等都封装在 Widget 内部，只要 Widget 前后传入的值不同便可以自动从 old 渐变到 new，内置的这些类主要以 AnimatedFoo 命名。\",\"AnimatedWidget，显式动画，需要使用者自己创建 Animation（一般是 AnimationController）并通过其管理动画，此类 Widget 主要是监听 AnimationController 的值并刷新 Widget 的内容。\",\"此类 Widget 主要有三种使用方式：\",\"继承 AnimatedWidget\",\"使用 AnimatedBuilder\",\"使用各种内置的 AnimatedWidget 子类，一般以 FooTransition 命名。\",\"对于 Flutter 中这些与动画有关的类如何选择，Flutter 官方给了一张图：\",\"如何实现Flutter中的动画\",\"简单来说，Flutter 有一些内置的动画，在要写动画的时候，可以依次考虑（实现程度由易到难）：\",\"AnimatedFoo 参考文章，设置新的状态，这些控件会自动从之前的状态切换到新状态\",\"TweenAnimationBuilder 参考文章，将任意属性在 Tween 指定的范围变化，和上面的 AnimatedFoo 都是属于Implicitly animated widgets（隐式动画，由系统控件控制动画）。\",\"FooTranslation\",\"AnimatedBuilder / AnimatedWidget\",\"CustomPainter\",\"本文主要分析 AnimationController 及其相关类。\",\"AnimationController 是 Flutter 中动画的基石，它继承自 Animation，根据不同的方法调用创建对应的 Simulation 并开始监听传入的 Ticker；\",\"每当 Flutter 中帧刷新时，从_simulation 中获取当前 Animation._value 并对 listener 发出通知；\",\"这样需要使用 Animation.value 的各个 Widget 便可以根据其值修改自身属性，实现动画视觉效果。\"]},\"158\":{\"h\":\"Animation\",\"t\":[\"根据上述分析，我们首先来看一下 Animation 类：\",\"An animation with a value of type T\",\"Animation 主要的作用是持有 value 和 status，并允许其他对象监听二者的变化。\",\"abstract class Animation<T> extends Listenable implements ValueListenable<T> { /// The current value of the animation. T get value; /// The current status of this animation. AnimationStatus get status; } \",\"Animation 继承自 Listenable，实现 ValueListenable 接口，其他类可以通过 addListener/removeListener 或者 addStatusListener/removeStatusListener 监听 Animation 的 value 或者 status 变化。\",\"Animation 共有 4 种状态：dismissed、forward、reverse、completed。\",\"除此之外，Animation.drive 方法可以创建一个新的将传入的 Animatable 应用到自身的 Animation。\",\" @optionalTypeArgs Animation<U> drive<U>(Animatable<U> child) { assert(this is Animation<double>); // 通过Animatable.transform将此Animation.value的值从double转化为U return child.animate(this as Animation<double>); } \",\"也就是说，提供了将 Animation<double> 转化为 Animation<U> 类型的方法。\"]},\"159\":{\"h\":\"其他子类\",\"t\":[\"除了后面要详细分析的 AnimationController 之外，Animation 还有如下子类：\",\"class\",\"说明\",\"AlwaysStoppedAnimation\",\"永远停留在指定值的 animation\",\"ProxyAnimation\",\"代理 Animation，适用于动画可能会变化的情况，先使用 ProxyAnimation 应用一个 Animation，然后再修改为其他 Animation（不用手动添加移除 listener）\",\"ReverseAnimation\",\"返回和当前 animation 反方向的 Animation\",\"CurvedAnimation\",\"可以为传入的 animation 使用 Curve 的 animation，适用于将原先线性变化的 Animation 改为非线性的\",\"TrainHoppingAnimation\",\"监听传入的两个 Animation<double>，当第二个 Animation 的值超过第一个 Animation 的值时自动切换到第二个并回调 onSwitchedTrain。如果一开始两个 Animation 就在同一个值，则切换到第二个并不会调用 onSwitchedTrain。\",\"CompoundAnimation\",\"可以组合多个 Animation<T>的接口，当 Animation<T> next 处于运动状态时返回 next 的状态，否则返回 Animation<T> first 的状态。\",\"对于上述的 CompoundAnimation，子类只需重写 double get value 方法即可，其有三个子类：\",\"AnimationMean 返回 first 和 next 值和的二分之一，值为 double\",\"AnimationMax<T extends num> 返回 first 和 next 中最大值\",\"AnimationMin<T extends num> 返回 first 和 next 中最小值\"]},\"160\":{\"h\":\"AnimationController\",\"t\":[\"A controller for an animation.\",\"尽管有各种子类，但 Animation 最常用的子类是 AnimationController，使用者可以用它来控制、监听动画、创建其他动画。\",\"class AnimationController extends Animation<double> with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin { } \"]},\"161\":{\"h\":\"构造方法\",\"t\":[\"AnimationController 有两种构造方法，这两种构造方法主要会初始化以下变量：\",\"double value 当前值\",\"Duration? duration,reverseDuration 动画正向、反向运行的时长，初始化时可以为 null，但在实际开始动画之前，至少保证 duration 不为 null\",\"double lowerBound,double upperBound 当 value 触达此值时，animation 分别被认为是 dismissed、completed\",\"Ticker? _ticker 由构造方法中必传的 TickerProvider vsync 创建\",\"他的两个构造方法分别是：\",\"AnimationController()\",\"默认构造方法，double lowerBound,double upperBound 默认分别为 0.0，1.0\",\"AnimationController.unbounded()\",\"不限制 value 值的构造方法，double lowerBound,double upperBound 默认分别为 double.negativeInfinity，double.infinity。适用于没有预设编辑的物理模拟动画。\",\"在这两个构造方法内部，都会通过_ticker = vsync.createTicker(_tick)创建_ticker，并保证当_ticker 回调时执行AnimationController._tick()方法。\",\"这里的 TickerProvider 主要有 2 种：\",\"SingleTickerProviderStateMixin 适用于 State 中只有一个 AnimationController 的情况，性能更好\",\"TickerProviderStateMixin 适用于 State 生命周期内有多个 AnimationController 的情况\",\"除了从 Animation 继承的方法外，AnimationController 还提供了如下方法，用于操纵动画：\",\"操纵从double? from正向/反向开始动画：\",\"TickerFuture forward({ double? from })\",\"TickerFuture reverse({ double? from })\",\"操纵正向/反向开始朝向double target开始动画，此类动画还可以改变Duration和Curve：\",\"TickerFuture animateTo(double target, { Duration? duration, Curve curve = Curves.linear })\",\"TickerFuture animateBack(double target, { Duration? duration, Curve curve = Curves.linear })\",\"上述四种方法，内部都是通过 AnimationController._animateToInternal()方法实现，而此方法内部又是执行 AnimationController._startSimulation()，除此之外，还有以下几类方法内部也是基于_startSimulation()方法实现，主要区别在于不同方法方法创建了不同的 Simulation：\",\"TickerFuture repeat({ double? min, double? max, bool reverse = false, Duration? period })\",\"TickerFuture fling({ double velocity = 1.0, SpringDescription? springDescription, AnimationBehavior? animationBehavior })\",\"TickerFuture animateWith(Simulation simulation)\"]},\"162\":{\"h\":\"_startSimulation\",\"t\":[\"AnimationController._startSimulation()方法是其实现动画的基石，其内部主要是开启了_ticker 并发出通知：\",\"TickerFuture _startSimulation(Simulation simulation) { assert(simulation != null); assert(!isAnimating); _simulation = simulation; _lastElapsedDuration = Duration.zero; _value = simulation.x(0.0).clamp(lowerBound, upperBound); // 开始ticker final TickerFuture result = _ticker!.start(); _status = (_direction == _AnimationDirection.forward) ? AnimationStatus.forward : AnimationStatus.reverse; _checkStatusChanged(); return result; } \",\"_ticker.start()方法最终通过SchedulerBinding.instance.scheduleFrameCallback()方法监听 Flutter Framework 的帧刷新，并回调 AnimationController._tick 方法\"]},\"163\":{\"h\":\"_tick\",\"t\":[\"在此方法内部根据当前时间和_simulation 获取_value 并发出通知。\",\" void _tick(Duration elapsed) { _lastElapsedDuration = elapsed; final double elapsedInSeconds = elapsed.inMicroseconds.toDouble() / Duration.microsecondsPerSecond; assert(elapsedInSeconds >= 0.0); // 通过_simulation获取当前动画的_value _value = _simulation!.x(elapsedInSeconds).clamp(lowerBound, upperBound); // 如果动画已经结束了，就停止监听 if (_simulation!.isDone(elapsedInSeconds)) { _status = (_direction == _AnimationDirection.forward) ? AnimationStatus.completed : AnimationStatus.dismissed; stop(canceled: false); } notifyListeners(); _checkStatusChanged(); } \"]},\"164\":{\"h\":\"其他方法\",\"t\":[\"void resync(TickerProvider vsync) 使用 vsync 重新创建新的_ticker\",\"void stop({ bool canceled = true }) 停止动画，不会触发通知，默认标记动画为 canceled\",\"void dispose() 释放资源，动画被标记为 canceled\"]},\"165\":{\"h\":\"Simulation\",\"t\":[\"从上面的分析中，我们看到 Simulation 在 AnimationController 动画中也起到很重要的作用：Simulation 主要是在一维空间对物理进行位置、速度等建模。\",\"abstract class Simulation { /// Initializes the [tolerance] field for subclasses. Simulation({ this.tolerance = Tolerance.defaultTolerance }); // 指定时间的位置 double x(double time); // 指定时间的速度 double dx(double time); /// Whether the simulation is \\\"done\\\" at the given time. bool isDone(double time); // 公差，如果两个数值相差小于等于此值则认为二者相等，用于isDone中 Tolerance tolerance; @override String toString() => objectRuntimeType(this, 'Simulation'); } \",\"在 AnimationController 中常用的子类有以下两种：\"]},\"166\":{\"h\":\"_InterpolationSimulation\",\"t\":[\"_InterpolationSimulation(this._begin, this._end, Duration duration, this._curve, double scale){...} \",\"其 x()方法中除了 t 为 0.0 或 1.0 的情况外，其余时候依靠 Curve（默认为 Curves.linear）计算值。\",\" double x(double timeInSeconds) { final double t = (timeInSeconds / _durationInSeconds).clamp(0.0, 1.0); if (t == 0.0) return _begin; else if (t == 1.0) return _end; else return _begin + (_end - _begin) * _curve.transform(t); } \"]},\"167\":{\"h\":\"_RepeatingSimulation\",\"t\":[\"_RepeatingSimulation(double initialValue, this.min, this.max, this.reverse, Duration period, this.directionSetter){} \",\"没有 Curve，其 double x(double timeInSeconds)方法可以自动判断是否需要反向并修改方向（会触发 status 改变通知）：\",\" double x(double timeInSeconds) { assert(timeInSeconds >= 0.0); final double totalTimeInSeconds = timeInSeconds + _initialT; final double t = (totalTimeInSeconds / _periodInSeconds) % 1.0; final bool isPlayingReverse = (totalTimeInSeconds ~/ _periodInSeconds).isOdd; if (reverse && isPlayingReverse) { directionSetter(_AnimationDirection.reverse); return ui.lerpDouble(max, min, t)!; } else { directionSetter(_AnimationDirection.forward); return ui.lerpDouble(min, max, t)!; } } \",\"此外比较特殊的是他的 isDone 方法一致返回 false，表示不会主动结束动画。\"]},\"168\":{\"h\":\"SpringSimulation\",\"t\":[\"用于 fling 方法，创建弹性的模拟\",\"经过上述分析，应该能了解 Flutter 动画中 AnimationController 的作用：\",\"AnimationController 通过传入的 TickerProvider 创建并监听 Ticker，确保 Ticker 收到系统帧回调时触发 AnimationController._tick 方法；\",\"提供 forward，reverse，animateTo，animateBack，repeat，fling，animateWith 等方法创建不同的 Simulation 并开启 Ticker，从而可以通过 SchedulerBinding.instance.scheduleFrameCallback 监听 Flutter 每一帧刷新。\",\"并且在 animateTo，animateBack 方法中可以使用 Curve 实现非线性变化。\",\"当 Flutter 帧刷新时，_tick 方法中通过_simulation 结合时间，lowerBound 和 upperBound 等获取当前值_value 和状态_status 并发出通知。\",\"使用者可以通过 AnimationController 继承自父类 Animation 的 addListener/removeListener、addStatusListener/removeStatusListener 监听动画的值和状态\",\"使用者可以从父类 Animation<double>继承的Animation<U> drive<U>(Animatable<U> child)方法使用 Animatable<U>从 Animation<double>的 animation 创建一个新的Animation<U>，从而可以得到可以随时间变化过渡的 Offset、Size 等动画。\",\"stop 方法可以停止动画\",\"动画效果介绍 flutter.cn\",\"Animation api.flutter.dev\",\"AnimationController api.flutter.dev\",\"TickerProvider api.flutter.dev\",\"SingleTickerProviderStateMixin api.flutter.dev\"]},\"169\":{\"h\":\"Flutter动画分析之Hero\",\"t\":[\"Flutter 中的 Hero 动画是指可以在切换页面时自动跨页面实现 Widget 放大缩小、位移的动画，在用户看起来好像是当前页面的 Widget“飞”入到另外一个页面，底层基于 Overlay 实现。\",\"本文对其原理和应用做一简单分析，主要是对官方介绍的理解与分析，感兴趣的可以直接阅读官方文档。\"]},\"170\":{\"h\":\"简单使用 Standard hero animations\",\"t\":[\"详细的代码可以从simple_hero_animation.dart获取。\",\"Hero 动画的使用比较简单：\",\"分别在两个 Flutter 页面将需要实现 Hero 动画的 Widget（一般是图片）作为 Hero 控件的 child\",\"为这两个 Hero 指定同一个 tag\",\"Hero 底层基于 Overlay 实现，所有 Hero.child 可以使用 Position 等适用于 Stack.child 的属性\",\"这里要注意：\",\"这两个 Page 要是相邻的页面，否则 Hero 动画不会生效\",\"同一个页面，不能有多个 Hero.tag 相同的 Hero 控件\",\"Hero 动画默认只支持大小（size）和位置（location）变化，所以 Hero.child 不建议有其他变化（Don't rotate your heroes）\",\"按照上述的要求，我们再 FirstHeroPage 中添加第一个 Hero Widget：\",\"Align( alignment: Alignment.bottomLeft, child: Hero( // 注意这里的tag要和下一个页面的Hero.tag一致 tag: \\\"HeroTag\\\", // child是Hero动画会作用的地方 child: HeroChildWidget( size: const Size.square(100), name: \\\"First\\\", onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) { return const SecondHeroPage(); })); }, )), ) \",\"然后在要跳转到的第二个页面 SecondHeroPage 添加目标 Hero：\",\" Align( alignment: Alignment.topCenter, child: Hero( // 这里的tag与上一个页面的Hero.tag一致 tag: \\\"HeroTag\\\", child: HeroChildWidget( size: const Size.square(200), name: \\\"Second\\\", onTap: () { Navigator.pop(context); }, )), ) \",\"这样，当从 FirstHeroPage 跳转到 SecondHeroPage 的时候，Hero 动画作用于 Hero.child，看起来好像是前一个页面的 HeroChildWidget 逐渐从 Alignment.bottomLeft 移动到 Alignment.topCenter，并且大小也从 100 逐渐变为 200。\",\"Simple Hero Animation\"]},\"171\":{\"h\":\"原理分析\",\"t\":[\"那么 Hero 动画是如何实现这个效果的呢？\",\"Flutter 中 Page 之间的跳转由 Navigator 管理，在 Navigator 管理的所有 Flutter Page 的上层有一个叠加层 Overlay，在 Z 轴方向上处于所有 Page 上层，其内部的 widget 可以被独立管理。\",\"以当前 Page 为 A，要跳转的 Page 为 B：\",\"那么当从 A 跳转到 B 时，Hero 动画框架会先隐藏 A 中的 Hero.child 并用相同大小的（不可见）组件占位；\",\"与此同时，Hero 动画框架读取要跳转去的 B 中的 Hero.child 并据此创建 Widget，将其大小和位置与为 A 中 Hero.child 对齐，放入到 Overlay 中。同时计算器过渡到 B 中的 Hero.child 位置和大小的路径动画，并执行；\",\"这也是为什么在上一步我们简单的 Hero 动画中，A 向 B 页面切换时过渡的 Widget 中文字虽然是Second，但是样式看起来和页面中的文字样式不一样，这是因为Overlay（可视为一个特殊的 Stack）上的组件是单独管理的，没有使用我们的 Material 样式。 要解决这个问题也很简单，在 Hero.child 中添加Material组件使其应用样式即可。\",\"当 B 创建好之后，Hero 动画正在运行中，所以 B 中的 Hero.child 也会被相同大小的（不可见）组件占位；\",\"当 Hero 动画播放完毕之后，位于 Overlay 中的 Widget 被移除，A 和 B 中的 Hero.child 也正常显示。\",\"如果又从 B 返回 A 则上述步骤又会反向（A、B 中 Hero.child 换位）执行一次。\",\"下图是 Flutter 官方对 Hero 动画执行的解释，刚好处于由 A 到 B 过渡的过程，可以看到 A、B 页面中的 Widget 都被移除，只有根据目标 Page——B 中的 Hero.child 创建的位于 Overlay 的 Destination hero 控件在从 A 中对应的位置和大小过渡到 B 中对应的位置和大小：\",\"Hero动画进行中的图解\"]},\"172\":{\"h\":\"进阶使用 Radial hero animations\",\"t\":[\"默认实现的 Hero 动画只支持大小和位移变化，通过使用 Radial Transformation（径向转化）可以实现由圆变为正方形的过渡动画。\",\"径向过渡 是由圆形变成正方形的过渡动画。 —— flutter.cn 官网\",\"径向动画的本质还是 Hero 动画，只不过在 Hero 动画之上做了一层由 ClipOval 和 ClipRect 组成的裁剪遮罩，通过二者的配合，导致其重叠部分的内容看起来好像在 Hero 动画播放的时候在圆和正方形之间切换。\",\"官方的实现为radial_hero_animation_animate_rectclip，但是为了便于理解径向动画的原理，我们在之前的 Hero 动画的简单使用代码基础上进行修改。\",\"详细的代码可以从advanced_hero_animation.dart获取。\",\"相对于之前的，我们主要将 HeroChildWidget 类修改为 HeroClippedChildWidget 类：\",\"const Size maxClipOvalDiameter = Size.square(200); const Size minClipOvalDiameter = Size.square(100); class HeroClippedChildWidget extends StatelessWidget { const HeroClippedChildWidget( {Key? key, required this.size, required this.name, required this.onTap}) : super(key: key); final Size size; final String name; final VoidCallback onTap; @override Widget build(BuildContext context) { // 与圆内切的正方形边长s = 圆半径 * 根号2 = 直径 * 根号2 / 2 var clipRectSize = maxClipOvalDiameter.width * math.sqrt2 / 2; return SizedBox( height: size.height, width: size.width, child: GestureDetector( onTap: onTap, // 当Hero动画变到最小时，ClipOval与ClipRect相交部分是ClipOval形状 child: ClipOval( child: Center( // 当Hero动画变到最大时，ClipOval与ClipRect相交部分是ClipRect形状 child: ClipRect( child: SizedBox( height: clipRectSize, width: clipRectSize, child: Container( color: Colors.blueAccent, child: Center( child: Text(name), ), ), ), ), ), ), ), ); } } \",\"其中，FirstHeroPage 的 HeroClippedChildWidget.minClipOvalDiameter，SecondHeroPage 中则为 maxClipOvalDiameter。\",\"其效果如图：\",\"advanced_hero\",\"实际上根据此方式，我们也可以监听 Hero.child 的大小、位置变化从而推测出 Hero 动画的进度和方向（是从 from 到 to，还是相反），从而实现更丰富的动画效果。\",\"比如监听进度从而实现旋转：https://github.com/jixiaoyong/flutter_custom_widget/blob/master/lib/widgets/animation_hero_child.dart\"]},\"173\":{\"h\":\"原理分析\",\"t\":[\"此类能够实现切换的同时修改 Hero.child 的样式，主要在于 ClipOval 和 ClipRect 的组合效果：\",\"Radial hero animations的示意图\",\"ClipRect 的大小固定为var clipRectSize = maxClipOvalDiameter.width * math.sqrt2 / 2，而 ClipOval 的大小则随着 Hero 动画的变化而变化，始终与 HeroClippedChildWidget 保持一致。\",\"假设从页面 A 到 B 切换时 Hero.child 会从小变大，那么：\",\"刚刚从页面 A 切换时，位于 Overlay 的 HeroClippedChildWidget/ClipOval 大小为 minClipOvalDiameter（也就是 100*100），此时 ClipRect 的大小 clipRectSize（也就是 200/2*根号 2 约等于 141）大于 ClipOval 的大小，所以他们的相交处为 ClipOval，故而 HeroClippedChildWidget 显示为直径为 100 的圆。\",\"当刚刚完整切换到页面 B，Hero 动画将要结束时，位于 Overlay 的 HeroClippedChildWidget/ClipOval 大小为 maxClipOvalDiameter（也就是 200*200），此时 ClipRect 的大小 clipRectSize（依旧是 141）小于 ClipOval 的大小，所以他们的相交处为 ClipRect，故而 HeroClippedChildWidget 显示为边长约为 141 的正方形。\",\"在二者的过渡阶段，就是 ClipOval 注解从小于 ClipRect 变化为大于 ClipRect 的过程，他们相交的区域也从圆变为圆角，再变为正方形。\"]},\"174\":{\"h\":\"其他属性\",\"t\":[\"此外，Hero 还有几个属性可以供我们自定义：\",\"flightShuttleBuilder 替换页面切换时的默认过渡 Widget。比如从页面 A 切换到 B 时，默认是使用 B 中的 Hero.child，如果此值不为 null 则会展示 flightShuttleBuilder 返回的 Widget。\",\"placeholderBuilder 当 Hero 动画开始，页面 A、B 中 Hero.child 隐藏时，会展示 placeholderBuilder 返回的内容或者为空（默认）\",\"createRectTween 定义 Hero 动画的过渡组件动画渐变的方式，MaterialApp 默认使用 MaterialRectArcTween()，此外还有 MaterialRectCenterArcTween()（可以等比例缩放）、MaterialPointArcTween()。\",\"示意图如下：\",\"flutter.cn官网Hero示意图\"]},\"175\":{\"h\":\"Hero\",\"t\":[\"Hero 是一个 StatefulWidget，除了之前提到的各个属性之外，还提供了_allHeroesFor()方法供 HeroController 调用，用于查找指定 Context 下所有的 Hero Widget，并在检测到有重复 Hero.tag 时报错。\",\"class Hero extends StatefulWidget{ const Hero({ Key? key, required this.tag,// 每个页面不能有多个相同tag的Hero this.createRectTween,// 定义Hero过渡Widget切换方式 this.flightShuttleBuilder,// 替换默认的过渡Widget this.placeholderBuilder,// 在Hero动画开始时占位 this.transitionOnUserGestures = false,// 是否同步手势 required this.child,// 要实现Hero动画的Widget }) : super(key: key); // 返回一个Key为Hero.tag的map static Map<Object, _HeroState> _allHeroesFor( BuildContext context, bool isUserGestureTransition, NavigatorState navigator, ) { ... } } \"]},\"176\":{\"h\":\"_HeroState\",\"t\":[\"_HeroState 主要是提供 startFlight/endFlight 供 HeroController->_HeroFlight->_HeroFlightManifest 调用；以及根据初始化以及开始/技术 Flight 动画后状态的变化而更改 Hero.child 在屏幕上面（对应页面上原先 Hero Widget 所处位置的区域）的显示效果。\",\" void startFlight({ bool shouldIncludedChildInPlaceholder = false }) { _shouldIncludeChild = shouldIncludedChildInPlaceholder; assert(mounted); final RenderBox box = context.findRenderObject()! as RenderBox; assert(box != null && box.hasSize); setState(() { _placeholderSize = box.size; }); } void endFlight({ bool keepPlaceholder = false }) { if (keepPlaceholder || _placeholderSize == null) return; _placeholderSize = null; if (mounted) { // Tell the widget to rebuild if it's mounted. _placeholderSize has already // been updated. setState(() {}); } } \",\"可以看出，startFlight/endFlight 方法主要影响的是_placeholderSize 的值，并引发 rebuild：\",\" Widget build(BuildContext context) { assert( context.findAncestorWidgetOfExactType<Hero>() == null, 'A Hero widget cannot be the descendant of another Hero widget.', ); // _placeholderSize不为null则展示占位Widget final bool showPlaceholder = _placeholderSize != null; if (showPlaceholder && widget.placeholderBuilder != null) { // 如果有指定占位Widget，并且需要展示 return widget.placeholderBuilder!(context, _placeholderSize!, widget.child); } if (showPlaceholder && !_shouldIncludeChild) { // 在Hero动画执行时，默认是用相同大小的SizeBox占位 return SizedBox( width: _placeholderSize!.width, height: _placeholderSize!.height, ); } return SizedBox( width: _placeholderSize?.width, height: _placeholderSize?.height, child: Offstage( offstage: showPlaceholder, child: TickerMode( enabled: !showPlaceholder, // 只有动画未开始/结束时才会展示child child: KeyedSubtree(key: _key, child: widget.child), ), ), ); } \",\"可以看到，Hero 和_HeroState 主要是提供了操纵、统计当前 Page 的 Hero Widget 以及控制其 Hero.child 及占位 Widget 的显示与否，那么在哪里发起和结束 Hero 动画，以及绘制过渡 Widget 的呢？\"]},\"177\":{\"h\":\"_HeroFlightManifest\",\"t\":[\"“_HeroFlightManifest：Everything known about a hero flight that's to be started or diverted.”\",\"_HeroFlightManifest 是一个数据类，主要封装了fromHero/toHero两个_HeroState，并提供 Hero Widget 的位置信息 Rect；此外还封装了过渡动画相关的get animation和createHeroRectTween方法。\",\"class _HeroFlightManifest { _HeroFlightManifest({ required this.type, required this.overlay, required this.navigatorSize, required this.fromRoute, required this.toRoute, required this.fromHero, required this.toHero, required this.createRectTween, required this.shuttleBuilder, required this.isUserGestureTransition, required this.isDiverted, }) : assert(fromHero.widget.tag == toHero.widget.tag); late final Rect fromHeroLocation = _boundingBoxFor(fromHero.context, fromRoute.subtreeContext); late final Rect toHeroLocation = _boundingBoxFor(toHero.context, toRoute.subtreeContext); static Rect _boundingBoxFor(BuildContext context, BuildContext? ancestorContext) { // 从context中找到对应的RenderObject并转化得到其在ancestorContext坐标系中的Rect } // 过渡动画相关 Tween<Rect?> createHeroRectTween({ required Rect? begin, required Rect? end }) { final CreateRectTween? createRectTween = toHero.widget.createRectTween ?? this.createRectTween; return createRectTween?.call(begin, end) ?? RectTween(begin: begin, end: end); } Animation<double> get animation { return CurvedAnimation( // push 和 pop 采用不同的animation parent: (type == HeroFlightDirection.push) ? toRoute.animation! : fromRoute.animation!, curve: Curves.fastOutSlowIn, reverseCurve: isDiverted ? null : Curves.fastOutSlowIn.flipped, ); } } \"]},\"178\":{\"h\":\"HeroController\",\"t\":[\"HeroController 真正在路由切换时操作 Hero 动画。\",\"无论是 CupertinoApp 还是 MaterialApp 都提供了创建 HeroController 的静态方法，在他们对应的 State.initState 方法中创建。\",\"CupertinoTabView 也创建有自己的 HeroController。\",\"以 MaterialApp 为例：\",\" // MaterialApp类 static HeroController createMaterialHeroController() { return HeroController( createRectTween: (Rect? begin, Rect? end) { return MaterialRectArcTween(begin: begin, end: end); }, ); } \",\"在_MaterialAppState 中创建并持有 HeroController：\",\"class _MaterialAppState extends State<MaterialApp> { late HeroController _heroController; @override void initState() { super.initState(); _heroController = MaterialApp.createMaterialHeroController(); } @override Widget build(BuildContext context) { // 创建WidgetsApp Widget result = _buildWidgetApp(context); ... return ScrollConfiguration( behavior: widget.scrollBehavior ?? const MaterialScrollBehavior(), // 注意这里将_heroController传给HeroControllerScope child: HeroControllerScope( controller: _heroController, child: result, ), ); } } \",\"HeroControllerScope 是一个 InheritedWidget，经过上述代码，MaterialApp 内部可以通过HeroControllerScope.of()方法获取到 HeroController。\",\"而在 WidgetsApp 中创建的 Navigator 对应的NavigatorState._updateHeroController方法中会使用其获取 HeroController,并通过HeroController._navigator = this及NavigatorState._updateEffectiveObservers()方法与之绑定。\",\"这样当 Navigator 切换页面时，各个时间都会通知到 HeroController,执行其 didPush/didPop/didRemove/didReplace/didStartUserGesture/didStopUserGesture 等方法，从而触发/终止 Hero 动画。\",\"class HeroController extends NavigatorObserver { HeroController({ this.createRectTween }); final CreateRectTween? createRectTween; // 当前位于Overlay中的所有Hero动画，key是Hero.tag final Map<Object, _HeroFlight> _flights = <Object, _HeroFlight>{}; // 从父类NavigatorObserver继承 NavigatorState? _navigator } \"]},\"179\":{\"h\":\"_maybeStartHeroTransition\",\"t\":[\"HeroController 从 NavigatorObserver 继承到的方法中，除了 didStopUserGesture 都会执行 HeroController._maybeStartHeroTransition 方法：\",\" // If we're transitioning between different page routes, start a hero transition // after the toRoute has been laid out with its animation's value at 1.0. void _maybeStartHeroTransition( Route<dynamic>? fromRoute, Route<dynamic>? toRoute, HeroFlightDirection flightType, bool isUserGestureTransition, ) { if (toRoute != fromRoute && toRoute is PageRoute<dynamic> && fromRoute is PageRoute<dynamic>) { final PageRoute<dynamic> from = fromRoute; final PageRoute<dynamic> to = toRoute; // A user gesture may have already completed the pop, or we might be the initial route switch (flightType) { case HeroFlightDirection.pop: if (from.animation!.value == 0.0) { return; } break; case HeroFlightDirection.push: if (to.animation!.value == 1.0) { return; } break; } // 对于pop事件，如果maintainState为true，那么我们立即得知hero动画的目标尺寸 // 因为这表示上一个页面还存在，不需要重新layout if (isUserGestureTransition && flightType == HeroFlightDirection.pop && to.maintainState) { _startHeroTransition(from, to, flightType, isUserGestureTransition); } else { // 否则应该等到下一帧、to页面layout之后再开始 // Putting a route offstage changes its animation value to 1.0. Once this // frame completes, we'll know where the heroes in the `to` route are // going to end up, and the `to` route will go back onstage. to.offstage = to.animation!.value == 0.0; WidgetsBinding.instance.addPostFrameCallback((Duration value) { _startHeroTransition(from, to, flightType, isUserGestureTransition); }); } } } \"]},\"180\":{\"h\":\"_startHeroTransition\",\"t\":[\"当上述条件满足之后，便可以开始执行 Hero 动画。\",\" // Find the matching pairs of heroes in from and to and either start or a new // hero flight, or divert an existing one. void _startHeroTransition( PageRoute<dynamic> from, PageRoute<dynamic> to, HeroFlightDirection flightType, bool isUserGestureTransition, ) { // If the `to` route was offstage, then we're implicitly restoring its // animation value back to what it was before it was \\\"moved\\\" offstage. to.offstage = false; final NavigatorState? navigator = this.navigator; // 注意这里获取到了OverlayState，用来放置Hero过渡动画 final OverlayState? overlay = navigator?.overlay; // If the navigator or the overlay was removed before this end-of-frame // callback was called, then don't actually start a transition, and we don' // t have to worry about any Hero widget we might have hidden in a previous // flight, or ongoing flights. if (navigator == null || overlay == null) return; final RenderObject? navigatorRenderObject = navigator.context.findRenderObject(); if (navigatorRenderObject is! RenderBox) { assert(false, 'Navigator $navigator has an invalid RenderObject type ${navigatorRenderObject.runtimeType}.'); return; } assert(navigatorRenderObject.hasSize); // At this point, the toHeroes may have been built and laid out for the first time. // // If `fromSubtreeContext` is null, call endFlight on all toHeroes, for good measure. // If `toSubtreeContext` is null abort existingFlights. final BuildContext? fromSubtreeContext = from.subtreeContext; final Map<Object, _HeroState> fromHeroes = fromSubtreeContext != null ? Hero._allHeroesFor(fromSubtreeContext, isUserGestureTransition, navigator) : const <Object, _HeroState>{}; final BuildContext? toSubtreeContext = to.subtreeContext; final Map<Object, _HeroState> toHeroes = toSubtreeContext != null ? Hero._allHeroesFor(toSubtreeContext, isUserGestureTransition, navigator) : const <Object, _HeroState>{}; for (final MapEntry<Object, _HeroState> fromHeroEntry in fromHeroes.entries) { final Object tag = fromHeroEntry.key; final _HeroState fromHero = fromHeroEntry.value; final _HeroState? toHero = toHeroes[tag]; final _HeroFlight? existingFlight = _flights[tag]; final _HeroFlightManifest? manifest = toHero == null ? null : _HeroFlightManifest( type: flightType, overlay: overlay, navigatorSize: navigatorRenderObject.size, fromRoute: from, toRoute: to, fromHero: fromHero, toHero: toHero, createRectTween: createRectTween, // 优先使用toHero、fromHero指定的flightShuttleBuilder，没有的话 // 使用默认的shuttleBuilder，也就是toHero.child shuttleBuilder: toHero.widget.flightShuttleBuilder ?? fromHero.widget.flightShuttleBuilder ?? _defaultHeroFlightShuttleBuilder, isUserGestureTransition: isUserGestureTransition, isDiverted: existingFlight != null, ); // Only proceed with a valid manifest. Otherwise abort the existing // flight, and call endFlight when this for loop finishes. if (manifest != null && manifest.isValid) { toHeroes.remove(tag); if (existingFlight != null) { // 如果已经存在Hero过渡动画，则将其转到新的方向 existingFlight.divert(manifest); } else { // 开始全新的Hero过渡动画 _flights[tag] = _HeroFlight(_handleFlightEnded)..start(manifest); } } else { existingFlight?.abort(); } } // The remaining entries in toHeroes are those failed to participate in a // new flight (for not having a valid manifest). // // This can happen in a route pop transition when a fromHero is no longer // mounted, or kept alive by the [KeepAlive] mechanism but no longer visible. // TODO(LongCatIsLooong): resume aborted flights: https://github.com/flutter/flutter/issues/72947 for (final _HeroState toHero in toHeroes.values) toHero.endFlight(); } void _handleFlightEnded(_HeroFlight flight) { _flights.remove(flight.manifest.tag); } Widget _defaultHeroFlightShuttleBuilder( BuildContext flightContext, Animation<double> animation, HeroFlightDirection flightDirection, BuildContext fromHeroContext, BuildContext toHeroContext, ) { final Hero toHero = toHeroContext.widget as Hero; return toHero.child; } \"]},\"181\":{\"h\":\"_HeroFlight\",\"t\":[\"经过上面的分析，最终是在_HeroFlight 方法中真正执行 Hero 动画：\",\"class _HeroFlight { // The simple case: we're either starting a push or a pop animation. void start(_HeroFlightManifest initialManifest) { assert(!_aborted); assert(() { final Animation<double> initial = initialManifest.animation; assert(initial != null); final HeroFlightDirection type = initialManifest.type; assert(type != null); switch (type) { case HeroFlightDirection.pop: return initial.value == 1.0 && initialManifest.isUserGestureTransition // During user gesture transitions, the animation controller isn't // driving the reverse transition, but should still be in a previously // completed stage with the initial value at 1.0. ? initial.status == AnimationStatus.completed : initial.status == AnimationStatus.reverse; case HeroFlightDirection.push: return initial.value == 0.0 && initial.status == AnimationStatus.forward; } }()); manifest = initialManifest; final bool shouldIncludeChildInPlaceholder; switch (manifest.type) { case HeroFlightDirection.pop: _proxyAnimation.parent = ReverseAnimation(manifest.animation); shouldIncludeChildInPlaceholder = false; break; case HeroFlightDirection.push: _proxyAnimation.parent = manifest.animation; shouldIncludeChildInPlaceholder = true; break; } heroRectTween = manifest.createHeroRectTween(begin: manifest.fromHeroLocation, end: manifest.toHeroLocation); // 执行_HeroState.startFlight方法，移除Hero.child，展示占位Widget manifest.fromHero.startFlight(shouldIncludedChildInPlaceholder: shouldIncludeChildInPlaceholder); manifest.toHero.startFlight(); // 在overlay上添加过渡组件_buildOverlay manifest.overlay.insert(overlayEntry = OverlayEntry(builder: _buildOverlay)); // 监听动画进度，以便实时改变过渡组件_buildOverlay的样式 _proxyAnimation.addListener(onTick); } } \",\"Hero 动画实际播放的过渡动画内容，由_HeroFlight._buildOverlay 根据动画进度创建：\",\" // The OverlayEntry WidgetBuilder callback for the hero's overlay. Widget _buildOverlay(BuildContext context) { assert(manifest != null); // 默认是toHero.child shuttle ??= manifest.shuttleBuilder( context, manifest.animation, manifest.type, manifest.fromHero.context, manifest.toHero.context, ); assert(shuttle != null); return AnimatedBuilder( // 监听动画进度 animation: _proxyAnimation, child: shuttle, builder: (BuildContext context, Widget? child) { final Rect rect = heroRectTween.evaluate(_proxyAnimation)!; final RelativeRect offsets = RelativeRect.fromSize(rect, manifest.navigatorSize); // 这里根据动画的进度更改shuttle的位置和大小、透明度 // Overlay本质上是一个特殊的Stack，所以这里使用Positioned定位 return Positioned( top: offsets.top, right: offsets.right, bottom: offsets.bottom, left: offsets.left, child: IgnorePointer( child: RepaintBoundary( child: FadeTransition( opacity: _heroOpacity, child: child, ), ), ), ); }, ); } \",\"Flutter 中 Hero 动画是基于 Overlay 实现的，监听 Navigator 路由变化，从而在不同 Flutter 页面切换时触发的、表现为 Hero.child 从当前页面“飞”到目标页面对应位置，并伴随着位置、大小、透明度等变化的动画。\",\"MaterialApp 或者 CupertinoApp 对应的State.initState方法中创建 HeroController，并通过 HeroControllerScope 提供给前面创建的 WidgetsApp 内部创建的 Navigator 并绑定；这样当路由变化时 HeroController 收到通知并在HeroState._startHeroTransition方法中通过Hero._allHeroesFor方法获取到当前页和目标页面的 Hero 动画组件，将其 Animation、Tween、Rect、_HeroState 等封装到_HeroFlightManifest 中，传递给_HeroFlight.start执行动画，并在_HeroFlight.onTick方法监听处理动画进度，从而导致_HeroFlight._buildOverlay创建的过渡 Widget 位置、大小、透明度等变化，产生 Hero Widget“飞入”的视觉效果。\",\"主动画 (Hero animations)\",\"Hero class\",\"Overlay class\",\"radial_hero_animation_animate_rectclip\"]},\"182\":{\"h\":\"Flutter动画分析之Tween&Curve\",\"t\":[\"在上篇文章中，我们分析了 Flutter 中主要由AnimationController控制动画的开始、结束，但是默认情况下其只能产生线性变化的 double 类型的 value，如果想随时间变化，让 Widget 产生 Size、Offset 等属性的变化，亦或者控制这些值变化的速度快慢，这时候就需要用到 Tween 和 Curve 了。\",\"下图是 Tween/Curve/AnimationController 等类的关系简单示意：\",\"Flutter各种动画底层类关系\",\"如上图所示：\",\"Tween 和 CurveTween 都继承自 Animatable，可以按照给定的 Animation<double>生产 T 类型的值，从而可以从 AnimationController 中衍生出其他类型的 Animation；\",\"而 Curve 继承自 ParametricCurve，除了之前文章中分析的传入 AnimationController.animateTo 和 AnimationController.animateBack 中从而作用于其创建的_InterpolationSimulation.x()方法之外，也可以被传入 CurveTween 或 CurvedAnimation 中，将 Curve 应用于 AnimationController。\",\"上述关于 Tween 和 CurveTween 和 AnimationController 作用的方式，其实现都是依赖于 Animation<T> Animatable.animate(Animation<double> parent) 方法，根据传入的 Animation<double>（一般会是 AnimationController 对象）创建新的 Animation<T>（实际上是继承自 Animation 的_AnimatedEvaluation，其 Animation.value 取自 Animatable.evaluate(Animation<double>)）。\"]},\"183\":{\"h\":\"Animatable\",\"t\":[\"An object that can produce a value of type T given an Animation<double> as input.\",\"Animatable 根据传入的Animation<double>对象创建 T 类型的对象，也就是说其将 Animation 产生的 double 类型“转化”为 T 类型，从而使得 Flutter 支持更加丰富的动画。\",\"一般情况下这个Animation<double>的值范围是[0.0,1.0]，但是也可能超出此范围。\",\"而这一切都通过他的animate方法实现：\",\" Animation<T> animate(Animation<double> parent) { return _AnimatedEvaluation<T>(parent, this); } \",\"在此方法中，将接收 Animation<double>对象作为parent，将自身作为_evaluatable属性创建了 Animation 的子类_AnimatedEvaluation 并返回：\",\"class _AnimatedEvaluation<T> extends Animation<T> with AnimationWithParentMixin<double> { _AnimatedEvaluation(this.parent, this._evaluatable); @override final Animation<double> parent; final Animatable<T> _evaluatable; // 主要逻辑，在这里调用Animatable.evaluate，最终调用transform(animation.value)方法获取Animation对应的值 @override T get value => _evaluatable.evaluate(parent); ... } \",\"再看一下 Animatable 的源码：\",\"T evaluate(Animation<double> animation) => transform(animation.value); T transform(double t); \",\"其evaluate方法内部通过其唯一的抽象方法transform方法实现，Animatable 的各个子类也只需要实现transform方法即可。\",\"除了上述与 Animation 有关的三个方法外，Animatable 还有一个链接两个 Animatable 的方法——Animatable.chain()：\",\" Animatable<T> chain(Animatable<double> parent) { return _ChainedEvaluation<T>(parent, this); } \",\"与 Animatable.animate 方法类似，不同的是此方法返回的是 Animatable<T>的子类——_ChainedEvaluation\",\"class _ChainedEvaluation<T> extends Animatable<T> { _ChainedEvaluation(this._parent, this._evaluatable); final Animatable<double> _parent; final Animatable<T> _evaluatable; // 关键方法，将parent.transform方法返回值传入Animatable _evaluatable.transform方法中并返回 @override T transform(double t) { return _evaluatable.transform(_parent.transform(t)); } } \",\"可以此方法作用是结合两个 Animatable 的效果。\",\"Animatable 的主要作用是根据传入的 Animation 创建对应的 T 类型的值；其主要的子类有 Tween、CurveTween、TweenSequence。\",\"TweenSequence 的作用于_chainedEvaluation 类似，只不过它可以将多个 Animatable 按照所占比重 weight 在 Animatable.transform 中应用。\"]},\"184\":{\"h\":\"Tween\",\"t\":[\"A linear interpolation (插值) between a beginning and ending value.\",\"Tween 是 Animatable 的主要子类之一，作用根据传入的 Animation（通常是 AnimationController）是在传入的begin 和 end 值之间创建线性的插值。\",\"class Tween<T extends Object?> extends Animatable<T> { // begin和end可以为空，但是必须在实际使用到之前赋非null值 Tween({this.begin,this.end,}); // 这两个值可以随时修改 T? begin; T? end; @override T transform(double t) { if (t == 0.0) return begin as T; if (t == 1.0) return end as T; return lerp(t); } @protected T lerp(double t) { // 默认是按照当前的进度线性计算返回的值 return (begin as dynamic) + ((end as dynamic) - (begin as dynamic)) * t as T; } } \",\"从 Tween 的源码可以看到，它实现了父类 Animatable.transform 方法，并在 t 在(0.0,1.0)之间时调用 Tween.lerp 方法获取对应的值，默认线性的在 T 上应用加减乘运算，并返回结果。Tween 的子类只需要重写 Tween.lerp 方法而非 Animatable.transform 方法。\",\"这也就要求：\",\"支持 lerp 静态方法的类通常有对应的 Tween 子类，一般以 FooTween 命名，比如 ColorTween 就是借助 Color.lerp 方法实现：\",\"class ColorTween extends Tween<Color?> { // 如果需要渐变透明，请传入null而非Color.transparent，后者实际是黑色透明，会导致渐变为黑色 ColorTween({ Color? begin, Color? end }) : super(begin: begin, end: end); @override Color? lerp(double t) => Color.lerp(begin, end, t); } \",\"Tween<T> 的类型 T 必须支持+-*三种运算，并且返回值还是 T；\",\"对于 int 来说，因为 int*double=num 而非 int，有对应的特殊类：\",\"IntTween，使用 double.round 实现近似线性插值\",\"StepTween，使用 double.floor 确保结果永远不会大于使用 Tween<double>的值\",\"在使用时，如果 Tween 确定不会变化，就可以将其保存在static final对象中以便在需要的地方共享同一个对象，而非在 State.build 方法中实时创建。\"]},\"185\":{\"h\":\"CurveTween\",\"t\":[\"CurveTween 继承自 Animatable<double>，常见的用法是传入AnimationController.drive方法中获取一个新的 Animation<double>:\",\"class CurveTween extends Animatable<double> { /// Creates a curve tween. /// /// The [curve] argument must not be null. CurveTween({ required this.curve }) : assert(curve != null); /// The curve to use when transforming the value of the animation. Curve curve; @override double transform(double t) { if (t == 0.0 || t == 1.0) { assert(curve.transform(t).round() == t); return t; } return curve.transform(t); } @override String toString() => '${objectRuntimeType(this, 'CurveTween')}(curve: $curve)'; } \",\"Tween 和 CurveTween 的主要区别在于，Tween 需要 T?类型的 begin 和 end 来创建线性插值，而 CurveTween 则需要 Curve 以便为 Animation<double>创建（非）线性插值。\"]},\"186\":{\"h\":\"Curve\",\"t\":[\"ParametricCurve<T>是 Curve 的父类，其提供 ParametricCurve.transform 方法将 double t（在[0.0,1.0]之间）转化为曲线在 t 处对应的值 T t：\",\"abstract class ParametricCurve<T> { T transform(double t) { assert(t != null); assert(t >= 0.0 && t <= 1.0, 'parametric value $t is outside of [0, 1] range.'); return transformInternal(t); } @protected T transformInternal(double t) { throw UnimplementedError(); } } \",\"从其源码可以看出，ParametricCurve.transform 主要是检查入参是否合规，其主要逻辑在 ParametricCurve.transformInternal 中，一般子类只需要实现后者即可。\",\"Curve 继承自 ParametricCurve<double>，也就是说它只能产生 double 类型的插值：\",\"abstract class Curve extends ParametricCurve<double> { /// Abstract const constructor to enable subclasses to provide /// const constructors so that they can be used in const expressions. const Curve(); @override double transform(double t) { if (t == 0.0 || t == 1.0) { // 这里当t为0.0或者1.0的时候直接返回t，避免了double运算后产生误差 return t; } return super.transform(t); } // 返回一个新的与之相反的curve Curve get flipped => FlippedCurve(this); } \",\"Curve 重写了父类的 transform 方法以规范对 double t 的处理，但还是建议子类只需要实现 ParametricCurve.transformInternal 方法。\",\"我们以 Curve 的子类_Linear 为例，查看实现 Curve 的过程：\",\"class _Linear extends Curve { const _Linear._(); @override double transformInternal(double t) => t; } \",\"总的来说，Curve 及其子类定义了一个曲线（可能是线性变化，也可能不是），并提供了double Curve.transform(double t)供使用者获取指定时间 double t 时曲线上对应的值 double。\",\"Flutter 为我们预置了很多丰富的 Curve，可以在这里预览：Curves。\",\"经过上述分析，我们可以知道，无论是 Tween 还是 CurveTween，作为 Animatable，他们提供了Animation<T> Animatable.animatee(Animation<double> parent)方法，可以返回一个新的，相当于使用Animatable<T>.transform(double parent.value)计算Animation<T>.value的，Animation<T>。\",\"而 Curve，只能通过double transform(double t)计算曲线在 t 位置的值的类，一般可以在 CurveTween、CurveAnimation 的构造方法或者 AnimationController 的 animateTo/animateBack 方法中，以便产生非线性的动画。\",\"Animatable api.flutter.dev\",\"Tween api.flutter.dev\",\"CurveTween api.flutter.dev\",\"Curve api.flutter.dev\",\"Curves api.flutter.dev\"]},\"187\":{\"h\":\"Flutter图片加载方案分析之Image\",\"t\":[\"Flutter 默认提供了Image用于从网络、文件等加载图片，并且使用ImageCache统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了flutter_cached_network_image、extended_image等基于 Flutter 原生的解决方案，以及power_image等基于混合开发的解决方案。\",\"本文对 Flutter 中的 Image 加载过程、原理做一简单分析。\",\"首先，简单梳理一下图片从加载到展示的过程。\"]},\"188\":{\"h\":\"Image\",\"t\":[\"A widget that displays an image.\",\"在查看 Image 具体实现之前，先了解几个基础方法：\",\"ImageConfiguration createLocalImageConfiguration(BuildContext context, { Size? size }) ：创建 ImageConfiguration，一般用于 state.didChangeDependencies 等依赖变化时会调用的地方，其创建的 ImageConfiguration 对象会传入 BoxPainter.paint 或者 ImageProvider.resolver 方法中以用来获取 ImageStream。\",\"Future<void> precacheImage(...) 预先加载 image 到 ImageCache 中，以便 Image、BoxDecoration、FadeInImage 等能够更快地加载 image。\",\"Image 是 Flutter 中用于展示图片的 Widget，主要有如下用法：\",\"Image.new, for obtaining an image from an ImageProvider.\",\"Image.asset, for obtaining an image from an AssetBundle using a key.\",\"Image.network, for obtaining an image from a URL.\",\"Image.file, for obtaining an image from a File.\",\"Image.memory, for obtaining an image from a Uint8List.\",\"支持的格式有：JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP，以及依赖于特定设备的格式（Flutter 会尝试使用平台 API 解析未知格式）。\",\"通过指定cacheWidth和cacheHeight可以让引擎按照指定大小解码图片，可以降低 ImageCache 占用的内存。\",\"Image(...)构造函数中只有一个必传项ImageProvider image用于获取图片，其余四种构造方法也都是在此方法的基础上分别指定了各自的 ImageProvider，以Image.network为例：\",\"Image.network( String src, { Key? key, double scale = 1.0, ..., int? cacheWidth, int? cacheHeight, }) : image = ResizeImage.resizeIfNeeded(cacheWidth, cacheHeight, NetworkImage(src, scale: scale, headers: headers)), ... super(key: key); \",\"上述代码中的 ResizeImage，NetworkImage 等都继承自 ImageProvider，ImageProvider.resolve方法创建并返回 ImageStream 供 Image 使用，内部通过ImageProvider.resolveStreamForKey方法从 ImageCache 或者子类指定的途径（比如 NetworkImage 会从网络）加载图片（并保存到 ImageCache）。\"]},\"189\":{\"h\":\"_ImageState\",\"t\":[\"Image是 StatefulWidget ，处理 image 的主要逻辑在 _ImageState 中：其混入了WidgetsBindingObserver以便监听系统生命周期；在内部通过监听ImageStream获得ImageInfo并最终在_ImageState.build方法中创建RawImage；RawImage 是一个LeafRenderObjectWidget，会创建RenderImage并在RenderImage.paint根据之前获取的信息调用DecorationImagePainter.paintImage方法通过canvas.drawImageRect绘制图片。\"]},\"190\":{\"h\":\"_resolveImage\",\"t\":[\"当依赖变化（didChangeDependencies()）、Widget 变化（didUpdateWidget(Image oldWidget)）、以及热更新（reassemble()）时，_ImageState 会执行_resolveImage()方法通过 ImageProvider 获取 ImageStream：\",\"void _resolveImage() { // ScrollAwareImageProvider用于防止在快速滑动的时候加载图片 final ScrollAwareImageProvider provider = ScrollAwareImageProvider<Object>( context: _scrollAwareContext, imageProvider: widget.image,// 用户/构造方法指定的ImageProvider ); // 通过ImageProvider获取ImageStream final ImageStream newStream = provider.resolve(createLocalImageConfiguration( context, size: widget.width != null && widget.height != null ? Size(widget.width!, widget.height!) : null, )); assert(newStream != null); _updateSourceStream(newStream); } \",\"我们还可以注意到，当在_resolveImage()中获取到 ImageStream 之后，会通过_updateSourceStream()更新 ImageStream。\"]},\"191\":{\"h\":\"_updateSourceStream\",\"t\":[\"在此方法中，先是更新了ImageStream? _imageStream 对象，然后根据_isListeningToStream的值执行_imageStream!.addListener(_getListener())更新 ImageStream 的 Listener：\",\"ImageStreamListener _getListener({bool recreateListener = false}) { if(_imageStreamListener == null || recreateListener) { _lastException = null; _lastStack = null; _imageStreamListener = ImageStreamListener( _handleImageFrame,// 图片加载成功，使用获得的imageInfo更新RawImage onChunk: widget.loadingBuilder == null ? null : _handleImageChunk,// 展示loading动画 onError: widget.errorBuilder != null || kDebugMode ? (Object error, StackTrace? stackTrace) { ... } : null,// 展示加载失败 ); } return _imageStreamListener!; } \",\"可以看到，在 ImageStreamListener 中，根据 ImageStream 的不同状态分别更新 Image 的显示。\"]},\"192\":{\"h\":\"_handleImageFrame\",\"t\":[\"_handleImageFrame()方法使用 ImageStream 中返回的ImageInfo，调用setState方法更新_ImageState 中的ImageInfo? **_imageInfo**属性，从而刷新 Image 展示。\",\"void _handleImageFrame(ImageInfo imageInfo, bool synchronousCall) { setState(() { _replaceImage(info: imageInfo);// 在这里刷新imageInfo，触发重建 _loadingProgress = null; _lastException = null; _lastStack = null; _frameNumber = _frameNumber == null ? 0 : _frameNumber! + 1; _wasSynchronouslyLoaded = _wasSynchronouslyLoaded | synchronousCall; }); } void _replaceImage({required ImageInfo? info}) { _imageInfo?.dispose(); _imageInfo = info; } \",\"ImageInfo类内部持有ui.Image和其对应的scale，以及一个获取图片像素大小的sizeBytes方法。\",\"// ImageInfo: a [dart:ui.Image] object with its corresponding scale. ImageInfo({ required this.image, this.scale = 1.0, this.debugLabel }) int get sizeBytes => image.height * image.width * 4; \"]},\"193\":{\"h\":\"build\",\"t\":[\"上面分析了_ImageState 如何监听使用 ImageProvider 获取到的 ImageStream，从中获取 ImageInfo 更新自己的 ImageInfo? _imageInfo 属性，那么这个属性是如何影响到我们的 Image 展示图片的呢，关键就在 build 方法中：\",\"Widget build(BuildContext context) { if (_lastException != null) { if (widget.errorBuilder != null) return widget.errorBuilder!(context, _lastException!, _lastStack); if (kDebugMode) return _debugBuildErrorWidget(context, _lastException!); } // 注意_ImageState内部其实是使用ui.Image _imageInfo?.image创建了RawImage来展示图片 Widget result = RawImage( // Do not clone the image, because RawImage is a stateless wrapper. // The image will be disposed by this state object when it is not needed // anymore, such as when it is unmounted or when the image stream pushes // a new image. image: _imageInfo?.image,// 这里会在ImageStream获取到ImageInfo之后更新 debugImageLabel: _imageInfo?.debugLabel, width: widget.width, height: widget.height, scale: _imageInfo?.scale ?? 1.0, color: widget.color, opacity: widget.opacity, colorBlendMode: widget.colorBlendMode, fit: widget.fit, alignment: widget.alignment, repeat: widget.repeat, centerSlice: widget.centerSlice, matchTextDirection: widget.matchTextDirection, invertColors: _invertColors, isAntiAlias: widget.isAntiAlias, filterQuality: widget.filterQuality, ); if (!widget.excludeFromSemantics) { result = Semantics( container: widget.semanticLabel != null, image: true, label: widget.semanticLabel ?? '', child: result, ); } if (widget.frameBuilder != null) result = widget.frameBuilder!(context, result, _frameNumber, _wasSynchronouslyLoaded); if (widget.loadingBuilder != null) // 如果有loadingBuilder就包裹result，所以注意进度为100%时要切换回图片， // 否则会一直显示进度，而非加载的图片 result = widget.loadingBuilder!(context, result, _loadingProgress); return result; } \",\"ImageInfo.image 是ui.Image对象，是原始的 image 像素，通过RawImage传入到Canvas.drawImageRect或者Canvas.drawImageNine绘制图片。\"]},\"194\":{\"h\":\"RawImage\",\"t\":[\"A widget that displays a [dart:ui.Image] directly.\",\"RawImage 继承自 LeafRenderWidget，可以直接展示ui.Image的内容，后者是解码的图片数据的不透明句柄（Opaque handle to raw decoded image data (pixels)）、是对_Image类的封装、对外提供宽高以及Image.toByteData（将ui.Image对象转化为ByteData，ByteData 可以直接传入Canvas.drawImageRect方法第一个参数）。\",\"RawImage 主要逻辑就是创建/更新 RenderImage 的时候将从_ImageState.build方法获得的ui.Image? image 的 clone 传入（其实就是使用ui.Image? image对应的_Image _image 新建了一个 ui.Image，每一个 ui.Image 都是_image 的一个句柄，只有当没有 ui.Image 指向_image 时后者才会真正的 dispose）。\"]},\"195\":{\"h\":\"RenderImage\",\"t\":[\"An image in the render tree.\",\"RenderImage 作为一个 RenderBox，在从 RawImage 那里拿到ui.Image? _image之后，然后在其RenderImage.paint方法中，会调用paintImage方法绘制_image代表的图片。\",\"ui.Image实际是ui._Image的包装类，它的width、height、toByteData等方法最终都是调用ui._Image对应的实现。\",\"paintImage 方法是位于 lib\\\\src\\\\painting\\\\decoration_image.dart 的全局方法，在其内部调用 canvas 绘制_image 对应的图片。\",\"至此，我们可以看到，在Image中，根据构造方法的不同创建了不同的ImageProvider对象作为Image.image参数；\",\"然后在 _ImageState 中，使用ImageProvider.resolve方法创建并更新ImageStream? _imageStream，并且监听ImageStream以便在图片加载成功之后获取ImageInfo? _imageInfo；\",\"这个ImageInfo是对ui.Image的封装类，在_ImageState.build方法中被传入RawImage，后者则创建了RenderImage并最终将 ui.Image 的内容绘制在屏幕上面。\",\"到目前为止，我们大体梳理了图片展示的这部分流程，此外，还有一部分同样重要的流程——图片的获取与缓存。\"]},\"196\":{\"h\":\"ImageProvider\",\"t\":[\"ImageProvider 是获取图片资源的基类，其他类可以调用ImageProvider.resolve方法获取 ImageStream ，此方法会调用ImageCache.putIfAbsent优先从 ImageCache 中获取，如果没有则调用ImageProvider.load方法获取并缓存到 ImageCache 中。\",\"其子类一般只需要重写ImageProvider的ImageStreamCompleter load(T key, DecoderCallback decode)和Future<T> obtainKey(ImageConfiguration configuration)方法即可。\",\"以NetworkImage加载网络图片的过程为例：\",\"我们通过NetworkImage()方法获取的实际是network_image.NetworkImage对象。\",\"当_ImageState._resolveImage()方法调用ImageProvider.resolve方法时，内部会调用ImageProvider.resolveStreamForKey方法，在其内部会执行：\",\"通过ImageProvider.obtainKey获取图片对应的 key\",\"执行PaintingBinding.*instance*!.imageCache!.putIfAbsent(key,() =>load(key, PaintingBinding.*instance*!.instantiateImageCodec),onError: handleError,)方法，优先从 imageCache 中获取缓存的图片，没有的话执行ImageProvider.load方法获取图片。\",\"对于network_image.NetworkImage对象，他的obtainKey()和load()方法实现如下：\",\"class NetworkImage extends image_provider.ImageProvider<image_provider.NetworkImage> implements image_provider.NetworkImage { const NetworkImage(this.url, { this.scale = 1.0, this.headers }) @override Future<NetworkImage> obtainKey(image_provider.ImageConfiguration configuration) { // 注意这里的key是NetworkImage对象，也就是说网络图片加载的url，scale， // header等一致的话才会被认为命中缓存 return SynchronousFuture<NetworkImage>(this); } @override ImageStreamCompleter load(image_provider.NetworkImage key, image_provider.DecoderCallback decode) { // Ownership of this controller is handed off to [_loadAsync]; it is that // method's responsibility to close the controller's stream when the image // has been loaded or an error is thrown. final StreamController<ImageChunkEvent> chunkEvents = StreamController<ImageChunkEvent>(); return MultiFrameImageStreamCompleter( codec: _loadAsync(key as NetworkImage, chunkEvents, decode),// 真正从网络加载图片的方法 chunkEvents: chunkEvents.stream, scale: key.scale, debugLabel: key.url, informationCollector: () => <DiagnosticsNode>[ DiagnosticsProperty<image_provider.ImageProvider>('Image provider', this), DiagnosticsProperty<image_provider.NetworkImage>('Image key', key), ], ); } } \",\"在这其中，network_image.NetworkImage._loadAsync()方法才是真正使用HttpClient从网上获取图片资源的方法（实际上 AssetBundleImageProvider、FileImage 和 MemoryImage 等一众 ImageProvider 等都约定俗成在_loadAsync 中执行真正获取图片的逻辑），返回值 Future<ui.Codec>和 ui.Image 的关系如下：\",\"Future<ui.Image> decodeImageFromList(Uint8List bytes) async { final ui.Codec codec = await PaintingBinding.instance.instantiateImageCodec(bytes); final ui.FrameInfo frameInfo = await codec.getNextFrame(); return frameInfo.image; } \"]},\"197\":{\"h\":\"ImageCache\",\"t\":[\"Class for caching images.\",\"在上面方分析 ImageProvider 的时候，我们注意到，每次通过ImageProvider.resolveStreamForKey方法获取 ImageStream 时，都会调用PaintingBinding.instance!.imageCache.putIfAbsent方法优先获取Image 对象的缓存，这就涉及到和 Image 缓存有关的类——ImageCache。\",\"ImageCache 对象全局唯一，使用 LRU 算法最多缓存1000 张或者最大 100MB 图片，可以分别使用maximumSize和maximumSizeBytes修改配置。\",\"其内部维持有三个 Map：\",\"Map<Object, PendingImage> _pendingImages 正在加载中的图片，可能可能同时也是_liveImage（对应的 ImageStream 已经被监听了）。\",\"Map<Object, _CachedImage> _cache 缓存的图片，maximumSize 和 maximumSizeBytes 限制针对的是_cache。\",\"Map<Object, _LiveImage> _liveImages 正在使用的图片，他的 ImageStreamCompleters 至少有一个 listener，可能同时在_pendingImages（所以这里的_LiveImage 的sizeBytes可能为 null）或者_liveImages中。\",\"_CachedImage和_LiveImage都继承自_CachedImageBase，其内部持有ImageStreamCompleter，图片的 handlerImageStreamCompleterHandle，以及图片大小sizeBytes。\",\"ImageCacheStatus处理 ImageCache 缓存的图片状态：\",\"pending，还没有加载完成的 image，如果被监听的话，还会是live的\",\"keepAlive，图片会被ImageCache._cache保存。可能是 live 的，但不会 pending 的。\",\"live，图片会一直被持有，除非ImageStreamCompleter没有 listener 了。可能是 pending 的，也可能是 keepAlive 的\",\"untracked，不会被缓存的图片（上述三值都为 false）。\",\"可以使用ImageCache.statusForKey或者ImageProvider.obtainCacheStatus获取图片状态ImageCacheStatus。\",\"此外，ImageCache还提供ImageCache.evict方法从缓存中清除指定图片。\"]},\"198\":{\"h\":\"putIfAbsent\",\"t\":[\"当 ImageProvider 调用ImageCache.putIfAbsent方法获取 ImageStreamCompleter 时，会依次尝试从_pendingImages 、_cache 、_liveImages 中读取，如果都没有则会尝试执行传入的 loader 方法获取。\",\" ImageStreamCompleter? putIfAbsent(Object key, ImageStreamCompleter Function() loader, { ImageErrorListener? onError }) { ImageStreamCompleter? result = _pendingImages[key]?.completer; // Nothing needs to be done because the image hasn't loaded yet. // 1. 如果图片还在加载中，就直接返回 if (result != null) { return result; } // Remove the provider from the list so that we can move it to the // recently used position below. // Don't use _touch here, which would trigger a check on cache size that is // not needed since this is just moving an existing cache entry to the head. final _CachedImage? image = _cache.remove(key); if (image != null) { // The image might have been keptAlive but had no listeners (so not live). // Make sure the cache starts tracking it as live again. // 2. 如果_cache中已经有了，就将其加入_liveImages并返回 _trackLiveImage( key, image.completer, image.sizeBytes, ); _cache[key] = image; return image.completer; } // 3. 如果_liveImages中已经有了，而cache中没有，就加入_cache， // 此时会检测大小和数量（这种属于图片刚下载完，或者已有缓存被清理） final _LiveImage? liveImage = _liveImages[key]; if (liveImage != null) { _touch( key, _CachedImage( liveImage.completer, sizeBytes: liveImage.sizeBytes, ), timelineTask, ); if (!kReleaseMode) { timelineTask!.finish(arguments: <String, dynamic>{'result': 'keepAlive'}); } return liveImage.completer; } // 4.1 如果_pendingImages、_cacheImages、_liveImages中都没有，就去下载 // 并加入到_liveImages中，此时_LiveImage.sizeBytes为null // 注意这里只是加入到_liveImages中追踪，并未使用_cache， // 故而也【不受其最大数量和最大总大小约束】 try { result = loader(); _trackLiveImage(key, result, null); } catch (error, stackTrace) { ... } // If we're doing tracing, we need to make sure that we don't try to finish // the trace entry multiple times if we get re-entrant calls from a multi- // frame provider here. bool listenedOnce = false; // We shouldn't use the _pendingImages map if the cache is disabled, but we // will have to listen to the image at least once so we don't leak it in // the live image tracking. // If the cache is disabled, this variable will be set. _PendingImage? untrackedPendingImage; // 图片加载过程中的回调 void listener(ImageInfo? info, bool syncCall) { int? sizeBytes; if (info != null) { sizeBytes = info.sizeBytes; info.dispose(); } final _CachedImage image = _CachedImage( result!, sizeBytes: sizeBytes, ); _trackLiveImage(key, result, sizeBytes); // Only touch if the cache was enabled when resolve was initially called. // 4.2 图片加载成功，如果有缓存，就将此图片加入_cache中，此时会检测大小和数量 // 并且这里的sizeBytes是图片实际大小 if (untrackedPendingImage == null) { _touch(key, image, listenerTask); } else { image.dispose(); } final _PendingImage? pendingImage = untrackedPendingImage ?? _pendingImages.remove(key); if (pendingImage != null) { pendingImage.removeListener(); } listenedOnce = true; } final ImageStreamListener streamListener = ImageStreamListener(listener); if (maximumSize > 0 && maximumSizeBytes > 0) { _pendingImages[key] = _PendingImage(result, streamListener); } else { untrackedPendingImage = _PendingImage(result, streamListener); } // Listener is removed in [_PendingImage.removeListener]. result.addListener(streamListener); return result; } \",\"经过上述分析可以知道，当_cache、_liveImages、_pendingImages中都没有指定图片时，会从网络下载（或者磁盘、asset等），而在图片完全加载完成之前，_pendingImages中下载图片所占大小是没有被ImageCache追踪的，也就是说ImageCache._cache的最大个数和总大小限制都不会管理这部分图片；故而面对大量高清大图加载的场景（比如，五列1:1网格加载平均大小几Mb的网络图片），如果快速滑动会导致_pendingImages急速增大，这样下载中且还未完全下载的图片所占用的内存会逐渐累计，从而导致Flutter APP内存暴增，页面卡顿等（本地资源不容易出现是因为从load到图片加载完成间隔比较短，而网络图片由于网速等导致_pendingImages中会累计很多正在下载中的图片，会比较明显）。\",\"那些在Flutter中加载图片并且完全采用ImageCache管理图片内存的图片加载框架比如Image/ExtendedImage/CachedNetworkImage等都存在此问题；阿里的PowerImage由于将图片下载这个过程交给了原生成熟的图片加载库处理，使得ImageCache只管理已经加载完成的图片，从而避免了上述情况。\",\"可以看到，以从网络加载图片为例，Flutter 原生提供的 Image 只有内存中的 ImageCache 一级缓存，如果 ImageCache 没有指定的图片（首次加载或者缓存被清空）则会再次从网络加载，这会导致多图列表的时候图片被频繁的回收/重新下载，从而影响用户体验。\",\"为了解决上述问题，涌现了很多第三方图片加载控件：\",\"extended_image 对官方 Image 的二次开发，增加了磁盘缓存。\",\"flutter_cached_network_image 使用sqflite 数据库管理缓存的网络图片加载库，增加了磁盘缓存。\",\"power_image 使用于混合项目的图片加载库，提供ffi和texture两种图片展示方式，依赖于原生图片加载库（比如Glide）加载图片、管理缓存。\",\"简单总结一下 Flutter 原生 Image 组件加载图片的流程：\",\"flutter_image_class_structure.png\",\"简单来说如下：\",\"用户通过 Image Widget 的各个构造方法创建指定的 ImageProvider；\",\"在_ImageState 中使用ImageProvider.resolve(ImageConfiguration)获取并监听 ImageStream（listener 为 ImageStreamListener）；\",\"ImageProvider 会按照传入的 ImageConfiguration 生成的 key 在 ImageCache 中查找对应的缓存，没有的话则先加载再缓存；\",\"当 ImageProvider 成功加载图片时，ImageStreamListener 获得 ImageInfo 时，并触发_ImageState.build()方法将ui.Image _imageInfo?.image传入 RawImage 中；\",\"作为一个 LeafRenderObjectWidget，RawImage 创建 RenderImage 并传入ui.Image? image?.clone()作为RenderImage.image，此后再在RenderImage.paint方法中调用系统的paintImage()方法通过canvas.drawImageRect绘制图片内容。\",\"Image_api.flutter.dev京东在Flutter加载大量图片导致的内存溢出的优化实践\"]},\"199\":{\"h\":\"Flutter图片加载方案分析之extended_image\",\"t\":[\"Flutter 默认提供了Image用于从网络、文件等加载图片，并且使用ImageCache统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了flutter_cached_network_image、extended_image等基于 Flutter 原生的解决方案，以及power_image等基于混合开发的解决方案。\",\"本文对 extended_image 加载过程、原理做一简单分析。\",\"extended_image是基于官方 Image 的拓展组件，支持加载以及失败显示，缓存网络图片，缩放拖拽图片，图片浏览(微信掘金效果)，滑动退出页面(微信掘金效果)，编辑图片(裁剪旋转翻转)，保存，绘制自定义效果等功能。\",\"本文主要对其加载缓存网络图片的流程做一分析，因为这个库是官方 Image 的拓展，所以我们会在之前对 Image 的分析基础上进行对比分析。\",\"extended_image 的架构图如下：\",\"extended_image_class_structure\",\"因为 extended_image 的定位是官方 Image 的拓展版，所以大部分使用方式和官方类似。\"]},\"200\":{\"h\":\"ExtendedImage\",\"t\":[\"他的构造函数分别是：\",\"ExtendedImage\",\"ExtendedImage.asset\",\"ExtendedImage.file\",\"ExtendedImage.memory\",\"ExtendedImage.network\",\"同样是在构造函数中指定并创建 ImageProvider，不过 extented_image 库的 ImageProvider 都是继承自官方 ImageProvider 并且混入了ExtendedImageProvider的子类。以ExtendedImage.network为例，创建的 ImageProvider 类型是ExtendedNetworkImageProvider。\",\"其余的步骤和我们之前分析的官方 Image 组件类似，在 _ExtendedImageState 中使用 ImageProvider 获取并监听 ImageStream，当成功加载图片之后获得ImageInfo? _imageInfo并刷新页面，在_ExtendedImageState.build方法中，虽然 extended_image 增加了一些特有的加载中、加载失败、手势等封装，但最后还是使用ImageInfo.image创建ExtendedRawImage以展示图片内容。\",\"如此可见，在从网络加载图片这部分内容来看，ExtendedImage 和 Image 的主要不同在于ExtendedNetworkImageProvider的实现：\"]},\"201\":{\"h\":\"ExtendedNetworkImageProvider\",\"t\":[\"这部分内容的代码在extended_image_library中。\",\"ExtendedNetworkImageProvider 继承自ImageProvider，混入了ExtendedImageProvider，后者提供了get imageCache/instantiateImageCodec/resolveStreamForKey等一系列通用方法。\",\"下面是 ExtendedNetworkImageProvider 的源码：\",\"abstract class ExtendedNetworkImageProvider extends ImageProvider<ExtendedNetworkImageProvider> with ExtendedImageProvider<ExtendedNetworkImageProvider> { factory ExtendedNetworkImageProvider( String url, { double scale, Map<String, String>? headers, bool cache, int retries, Duration? timeLimit, Duration timeRetry, CancellationToken? cancelToken, String? cacheKey, bool printError, bool cacheRawData, String? imageCacheName, Duration? cacheMaxAge, }) = network_image.ExtendedNetworkImageProvider } \",\"ExtendedNetworkImageProvider 是个抽象类，他的逻辑在network_image.ExtendedNetworkImageProvider中：\",\"import 'extended_network_image_provider.dart' as image_provider; class ExtendedNetworkImageProvider extends ImageProvider<image_provider.ExtendedNetworkImageProvider> with ExtendedImageProvider<image_provider.ExtendedNetworkImageProvider> implements image_provider.ExtendedNetworkImageProvider { // 此方法获取的图片会被ImageProvider缓存到ImageCache中 @override ImageStreamCompleter load( image_provider.ExtendedNetworkImageProvider key, DecoderCallback decode) { final StreamController<ImageChunkEvent> chunkEvents = StreamController<ImageChunkEvent>(); return MultiFrameImageStreamCompleter( codec: _loadAsync(// 调用_loadAsync方法加载图片 key as ExtendedNetworkImageProvider, chunkEvents, decode, ), scale: key.scale, chunkEvents: chunkEvents.stream, informationCollector: () { ... }, ); } Future<ui.Codec> _loadAsync( ExtendedNetworkImageProvider key, StreamController<ImageChunkEvent> chunkEvents, DecoderCallback decode, ) async { assert(key == this); final String md5Key = cacheKey ?? keyToMd5(key.url); ui.Codec? result; if (cache) { try { // 如果需要缓存图片，就调用_loadCache优先从缓存中读取，没有的话先从网络下载， // 成功之后再缓存到本地缓存文件目录 final Uint8List? data = await _loadCache( key, chunkEvents, md5Key, ); if (data != null) { // 解析加载的图片信息 result = await instantiateImageCodec(data, decode); } } catch (e) { if (printError) { print(e); } } } if (result == null) { try { // 如果不需要缓存或者从缓存中读取/下载失败了，就从网络加载 final Uint8List? data = await _loadNetwork( key, chunkEvents, ); if (data != null) { result = await instantiateImageCodec(data, decode); } } catch (e) { if (printError) { print(e); } } } // 如果还是失败，就展示失败信息 if (result == null) { //result = await ui.instantiateImageCodec(kTransparentImage); return Future<ui.Codec>.error(StateError('Failed to load $url.')); } return result; } } \",\"从上述代码可以看到，如果需要缓存时，除了 ImageCache 本身的缓存外，ExtendedNetworkImageProvider 还会执行_loadCache尝试从本地文件中读取缓存：\",\"Future<Uint8List?> _loadCache( ExtendedNetworkImageProvider key, StreamController<ImageChunkEvent>? chunkEvents, String md5Key, ) async { final Directory _cacheImagesDirectory = Directory( join((await getTemporaryDirectory()).path, cacheImageFolderName)); Uint8List? data; // 1. 先尝试从缓存文件中读取图片 if (_cacheImagesDirectory.existsSync()) { final File cacheFlie = File(join(_cacheImagesDirectory.path, md5Key)); if (cacheFlie.existsSync()) { if (key.cacheMaxAge != null) { final DateTime now = DateTime.now(); final FileStat fs = cacheFlie.statSync(); if (now.subtract(key.cacheMaxAge!).isAfter(fs.changed)) { cacheFlie.deleteSync(recursive: true); } else { data = await cacheFlie.readAsBytes(); } } else { data = await cacheFlie.readAsBytes(); } } } // create folder else { await _cacheImagesDirectory.create(); } // load from network if (data == null) { // 2.1 缓存不存在或者读取失败，先仅从网络加载图片 data = await _loadNetwork( key, chunkEvents, ); if (data != null) { // cache image file // 2.2 如果从网络成功加载图片，则将图片写入文件缓存 await File(join(_cacheImagesDirectory.path, md5Key)).writeAsBytes(data); } } return data; } \",\"上述代码中执行到的ExtendedNetworkImageProvider._loadNetwork()方法只会使用HttpClient从网络中下载图片并返回。\"]},\"202\":{\"h\":\"ExtendedImageProvider\",\"t\":[\"此外，之前提到的ExtendedImageProvider为 extended_image 库中的 ImageProvider 提供了一些通用的方法：\",\"/// The cached raw image data 缓存图片原始数据，而不必每次都使用ui.Image.toByteData()获取 Map<ExtendedImageProvider<dynamic>, Uint8List> rawImageDataMap = <ExtendedImageProvider<dynamic>, Uint8List>{}; /// The imageCaches to store custom ImageCache，缓存ImageCache /// 可以指定一个 ImageCache 来缓存一些图片。这样可以一起处理它们，不会影响其他的图片缓存. Map<String, ImageCache> imageCaches = <String, ImageCache>{}; mixin ExtendedImageProvider<T extends Object> on ImageProvider<T> { bool get cacheRawData; String? get imageCacheName; ImageCache get imageCache { if (imageCacheName != null) { return imageCaches.putIfAbsent(imageCacheName!, () => ImageCache()); } else { return PaintingBinding.instance.imageCache; } } } \",\"此外，还改动了ExtendedImageProvider.resolveStreamForKey方法以使用指定的 ImageCache。\",\"void resolveStreamForKey( ImageConfiguration configuration, ImageStream stream, T key, ImageErrorListener handleError, ) { // This is an unusual edge case where someone has told us that they found // the image we want before getting to this method. We should avoid calling // load again, but still update the image cache with LRU information. if (stream.completer != null) { final ImageStreamCompleter? completer = imageCache.putIfAbsent( key, () => stream.completer!, onError: handleError, ); assert(identical(completer, stream.completer)); return; } final ImageStreamCompleter? completer = imageCache.putIfAbsent( key, () => load(key, PaintingBinding.instance.instantiateImageCodec), onError: handleError, ); if (completer != null) { stream.setCompleter(completer); } } \",\"综上所见，ExtendedImageProvider 的主要作用是借助rawImageDataMap提供了缓存图片原始数据的功能，此外还提供了一个 ImageCache 分组的方法，以便对一部分图片缓存统一处理。\",\"仅就从网络加载图片而言，extended_image 和 Flutter 官方 Image 组件的主要区别在于：在 ImageCache 之外，多了一层本地磁盘缓存，如果这二者都未命中缓存则从网络下载图片。\",\"除此之外，extended_image 本身还提供了诸如图片缩放拖拽、滑动退出等图片操作常用的“大而全”的功能。这部分见仁见智，如果 APP 需求刚好需要用到这些功能的话，extended_image 是个不错的选择，但是如果只是想解决图片缓存问题的话，可能会显得有些臃肿。\",\"另外一个常用的图片库flutter_cached_network_image则是借助flutter_cache_manager实现缓存网络图片的功能，相对比较轻量。\",\"上述两种库都是基于 Flutter Image 组件实现图片加载、缓存，阿里巴巴出品的power_image则是一款为 Flutter-Native 混合项目开发的图片加载库，借助 Texture 和 ffi 通过 Native 端已有的图片加载库完成图片加载、缓存的功能，Flutter 端只负责展示（以及 ImageCache 缓存）。\",\"extended_image\",\"extended_image_library\"]},\"203\":{\"h\":\"Flutter图片加载方案分析之power_image\",\"t\":[\"Flutter 默认提供了Image用于从网络、文件等加载图片，并且使用ImageCache统一管理图片缓存，但有时候并不能满足使用需求（比如网络图片没有磁盘缓存，导致每次 ImageCache 清除缓存之后又要从网络下载），所以又出现了flutter_cached_network_image、extended_image等基于 Flutter 原生的解决方案，以及power_image等基于混合开发的解决方案。\",\"本文对 Alibaba 中的 power_image 加载过程、原理做一简单分析。\",\"power_image是阿里巴巴出品的 Flutter 混合开发图片加载库，通过texture和ffi技术借助原生图片加载库加载图片、Flutter 端展示图片。\",\"无论是 Flutter Image 组件，还是第三方的extende_image、flutter_cached_nework_image都是在 Flutter 端加载解析图片，这些方案对一般纯 Flutter 开发的 APP 来说基本可以满足要求，但是对于大多数混合开发的 APP 来说，这些方案会在 Flutter 和 Native 同时存在两份图片资源造成内存浪费，此外根据贝壳的分析，Flutter 端解决方案存在图片内存释放时机（Flutter 引擎持有的 SkImage 释放时机）以及超大图内存峰值等问题。\",\"而power_image能够较好的解决上述问题，其整体架构如下：\",\"类结构图:\",\"架构图:\",\"power_image可以大体划分为Flutter 端图片展示和Native 图片加载两部分，下面分别分析。\"]},\"204\":{\"h\":\"PowerImage\",\"t\":[\"PowerImage继承自StatefulWidget，提供多种创建方式：既可以使用预设的PowerImage.network、PowerImage.file等构造函数从网络、文件等获取图片；也可以使用PowerImage.type、PowerImage.options等自定义通道获取图片并展示；或者使用PowerImage()完全自定义。\",\"除了PowerImage()构造函数之外，上述其余构造函数都根据传入的String? renderingType指定了 PowerImage 特定的PowerImageProvider image属性（是ffi还是texture）用于获取图片。\"]},\"205\":{\"h\":\"PowerImageState\",\"t\":[\"class PowerImageState extends State<PowerImage> { @override Widget build(BuildContext context) { ImageErrorWidgetBuilder? errorWidgetBuilder = widget.errorBuilder; errorWidgetBuilder ??= (...) { return SizedBox(...); }; if (widget.image.runtimeType == PowerTextureImageProvider) { return PowerTextureImage( provider: widget.image as PowerTextureImageProvider, ...); } else if (widget.image.runtimeType == PowerExternalImageProvider) { return PowerExternalImage( provider: widget.image as PowerExternalImageProvider, ... ); } return ImageExt( image: widget.image, imageBuilder: widget.imageBuilder, ... ); } } \",\"在 PowerImageState 的build()方法中，根据不同的PowerImageProvider image类型会返回不同的 Widget：\",\"image是 PowerTextureImageProvider 类型：采用 texture 模式展示图片，返回**PowerTextureImage，最终会返回经过封装的Texture**对象。\",\"image是**PowerExternalImageProvider类型：采用 ffi 模式展示图片，返回PowerExternalImage，最终返回的是RawImage**对象，和使用 Flutter Image 展示图片的流程一致。\",\"其他类型，按照自定义的规则展示。\",\"让我们来分别看一下**PowerTextureImage和PowerExternalImage**的实现：\"]},\"206\":{\"h\":\"PowerTextureImage\",\"t\":[\"class PowerTextureImage extends StatefulWidget { const PowerTextureImage({...}):super(key: key); final PowerTextureImageProvider provider; @override PowerTextureState createState() { return PowerTextureState(); } } class PowerTextureState extends State<PowerTextureImage> { @override Widget build(BuildContext context) { return ImageExt( // 这里的provider实际上创建的是一个虚假的ui.Image? dummy image: widget.provider, frameBuilder: widget.frameBuilder, errorBuilder: widget.errorBuilder, width: widget.width, height: widget.height, fit: widget.fit, alignment: widget.alignment, // 注意，这里会创建一个封装的Texture，真正展示图片内容 imageBuilder: buildImage, semanticLabel: widget.semanticLabel, excludeFromSemantics: widget.excludeFromSemantics, ); } Widget buildImage(BuildContext context, ImageInfo? imageInfo) { if (imageInfo == null || imageInfo is! PowerTextureImageInfo) { return SizedBox( width: widget.width, height: widget.height, ); } PowerTextureImageInfo textureImageInfo = imageInfo; return ClipRect( child: SizedBox( child: FittedBox( fit: widget.fit ?? BoxFit.contain, alignment: widget.alignment, child: SizedBox( width: textureImageInfo.width?.toDouble() ?? widget.width, height: textureImageInfo.height?.toDouble() ?? widget.height, child: Texture( // 注意，这里的textureId是从provider创建的ImageInfo中获取的 textureId: textureImageInfo.textureId!, ), ), ), width: widget.width, height: widget.height, ), ); } } \"]},\"207\":{\"h\":\"PowerExternalImage\",\"t\":[\"class PowerExternalImage extends StatefulWidget { const PowerExternalImage({...}):super(key: key); final PowerExternalImageProvider provider; @override PowerExteralState createState() => PowerExteralState(); } class PowerExteralState extends State<PowerExternalImage> { @override Widget build(BuildContext context) { return ImageExt( frameBuilder: widget.frameBuilder, errorBuilder: widget.errorBuilder, // provider会根据Native数据创建含有对应的ui.Image的 // ImageInfo，展示对应图片 image: widget.provider, width: widget.width, height: widget.height, fit: widget.fit, alignment: widget.alignment, semanticLabel: widget.semanticLabel, excludeFromSemantics: widget.excludeFromSemantics, ); } } \",\"通过对比**PowerTextureImage和PowerExternalImage**的源码可以发现，二者最终还是创建了 ImageExt 对象，只不过 PowerTextureImage 中 ImageExt.imageBuilder 返回了 Texture，而 PowerExternalImage 中 ImageExt.imageBuilder 为 null。\",\"再根据下面的_ImageExtState.build源码可以确定，当使用 PowerTextureImage 时 PowerImage 创建的是封装了的 Texture，而 PowerExternalImage 时则会使用 PowerExternalImageProvider 创建的 ImageInfo 创建 RawImage，这实际上与 Flutter 原有的 Image 组件一致。\",\"// _ImageExtState.build @override Widget build(BuildContext context) { ... Widget result; if (widget.imageBuilder != null) { result = widget.imageBuilder!(context, _imageInfo); } else { result = RawImage( image: _imageInfo?.image, ... ); } ... return result; } \",\"通过上面的分析，可以知道，PowerImage使用从PowerImageProvider 获取的 ImageInfo 来展示图片，采用**texture**方案时，使用 ImageInfo 中的 textureId 并返回 Texture 对象展示图片；而使用 ffi 方案时，会使用 ImageInfo 中的ui.Image image对象传入 RawIamge 展示图片（这部分与 Flutter Image 组件逻辑一致）。\"]},\"208\":{\"h\":\"PowerImageProvider\",\"t\":[\"PowerImageProvider 继承自ImageProviderExt -> ImageProvider，是power_image的关键类之一，主要实现通过 Flutter/Native 跨端通信从 Native 获取/释放图片资源等，创建供ImageExt使用的ImageInfo。\",\"相对于 Flutter 官方的 ImageProvider，除了修改部分类为 power_image 对应的类之外，PowerImageProvider主要有以下几点改变：\",\"工厂方法PowerImageProvider.options生产PowerImageProvider：根据传入的PowerImageRequestOptions中PowerImageRequestOptions.renderingType的值，分别创建对应的PowerExternalImageProvider或者PowerTextureImageProvider。\",\"重写_loadAsync方法，调用 Native 图片库加载图片，并根据返回值调用子类 createImageInfo 方法创建 PowerImageInfo。\"]},\"209\":{\"h\":\"_loadAsync\",\"t\":[\"通过重写_loadAsync方法，PowerImageProvider 实现了不同的子类分别创建 PowerImageInfo 展示图片、统一让 ImageCache 管理图片。\",\"Future<ImageInfo> _loadAsync( PowerImageProvider key, DecoderCallback? decode) async { try { // 跨端通信获取图片资源，后面再详细分析 PowerImageCompleter powerImageCompleter = PowerImageLoader.instance.loadImage(options); Map map = await powerImageCompleter.completer!.future; bool? success = map['success']; // remove multiFrame image cache On Last Listener Removed bool? isMultiFrame = map['_multiFrame']; if (isMultiFrame == true) { _completer! .addOnLastListenerRemovedCallback(() { scheduleMicrotask(() { PaintingBinding.instance!.imageCache!.evict(key); }); }); } _completer = null; if (success != true) { // The network may be only temporarily unavailable, or the file will be // added on the server later. Avoid having future calls to resolve // fail to check the network again. final PowerImageLoadException exception = PowerImageLoadException(nativeResult: map); PowerImageMonitor.instance().anErrorOccurred(exception); throw exception; } // 创建ImageInfo return createImageInfo(map); } catch (e) { // Depending on where the exception was thrown, the image cache may not // have had a chance to track the key in the cache at all. // Schedule a microtask to give the cache a chance to add the key. scheduleMicrotask(() { PaintingBinding.instance!.imageCache!.evict(key); }); rethrow; } finally { // chunkEvents.close(); } } \",\"在上面的分析中，我们得知，texture和ffi方案分别使用 ImageProvider 提供的 PowerImageInfo 中的int? textureId和ui.Image image展示图片，让我们分别看一下他们是如何获取的：\"]},\"210\":{\"h\":\"PowerTextureImageProvider\",\"t\":[\"class PowerTextureImageProvider extends PowerImageProvider { PowerTextureImageProvider(PowerImageRequestOptions options) : super(options); @override FutureOr<ImageInfo> createImageInfo(Map map) { int? textureId = map['textureId']; int? width = map['width']; int? height = map['height']; return PowerTextureImageInfo.create( textureId: textureId, width: width, height: height); } @override void dispose() { PowerImageLoader.instance.releaseImageRequest(options); super.dispose(); } } class PowerTextureImageInfo extends PowerImageInfo { static ui.Image? dummy; final int? textureId; // 此方法使用一个通用的ui.Image? dummy创建PowerTextureImageInfo // 以便让ImageCache能够管理texture创建的图片 static FutureOr<PowerTextureImageInfo> create( {int? textureId, int? width, int? height}) async { if (dummy != null) { return PowerTextureImageInfo( textureId: textureId, width: width, height: height, image: dummy!.clone()); } dummy = await _createImage(1, 1); return PowerTextureImageInfo( textureId: textureId, width: width, height: height, image: dummy!.clone()); } } Future<ui.Image> _createImage(int width, int height) async { final Completer<ui.Image> completer = Completer<ui.Image>(); ui.decodeImageFromPixels(// 使用指定的Uint8List创建ui.Image Uint8List.fromList( List<int>.filled(width * height * 4, 0, growable: false)), width, height, ui.PixelFormat.rgba8888, (ui.Image image) { completer.complete(image); }, ); return completer.future; } \"]},\"211\":{\"h\":\"PowerExternalImageProvider\",\"t\":[\"class PowerExternalImageProvider extends PowerImageProvider { PowerExternalImageProvider(PowerImageRequestOptions options) : super(options); @override FutureOr<ImageInfo> createImageInfo(Map map) { Completer<ImageInfo> completer = Completer<ImageInfo>(); int handle = map['handle']; int length = map['length']; int width = map['width']; int height = map['height']; int? rowBytes = map['rowBytes']; ui.PixelFormat pixelFormat = ui.PixelFormat.values[map['flutterPixelFormat'] ?? 0]; // 获取图片在内存中的指针 Pointer<Uint8> pointer = Pointer<Uint8>.fromAddress(handle); // 获取对应内存中的数据 Uint8List pixels = pointer.asTypedList(length); // 根据内存中的数据创建ui.Image，这里会发生内存拷贝，大图片会出现内存峰值偏高 ui.decodeImageFromPixels(pixels, width, height, pixelFormat, (ui.Image image) { ImageInfo imageInfo = PowerImageInfo(image: image); completer.complete(imageInfo); //释放platform_image PowerImageLoader.instance.releaseImageRequest(options); }, rowBytes: rowBytes); return completer.future; } } \",\"从上述代码可以看到：\",\"texture 方案采用的 PowerTextureImageProvider 创建的 ImageInfo 对应的 ui.Image image 一个共享的占位符，并不能真正真正绘制内容，实际上图片信息在对应的PowerTextureImageInfo.textureId中；\",\"ffi 方案创建的 ImageInfo 则根据 native 内存中的图片数据创建了对应的 ui.Image，与 Flutter 默认的 ImageProvider 提供的 ImageInfo 一样可以被 RawImage 正常使用。\",\"这里需要注意，虽然 texture 和 ffi 都采用了ImageCache来管理图片缓存，甚至 ffi 的内存也在Flutter侧管理，但是PowerImage本身不会出现我们之前在Flutter Image中分析的加载大量高清网图会出现的内存爆炸，这是因为虽然在ImageCache.putIfAbsent方法中_pendingImages同样保存了加载中的图片，但是实际这些图片加载过程中的内存由Native端图片加载库管理，而非Flutter，所以只要Native端图片加载库比较成熟，就可以避免这个问题。\",\"到目前为止，我们分析了 PowerImage 根据 PowerImageProvider 获取的 ImageInfo 分别采用 ffi 和 texture 两种方案展示图片的过程。\",\"接下来分析一下之前提到的 PowerImageProvider._loadAsync 方法中使用 PowerImageLoader 获取图片的过程。整个过程可以分为 flutter 端发起请求/处理回调、native 端接收请求/返回结果两部分，在这过程中 Flutter 和 Native 使用 MethodChannel（发送获取释放图片指令） 和 EventChannel（接收图片成功加载的事件）进行通信。\",\"在上面分析PowerImageProvider._loadAsync方法时，我们注意到其中使用了**PowerImageLoader**获取图片信息 PowerImageCompleter：\",\"// PowerImageProvider._loadAsync 省略部分代码 Future<ImageInfo> _loadAsync( PowerImageProvider key, DecoderCallback? decode) async { try { PowerImageCompleter powerImageCompleter = PowerImageLoader.instance.loadImage(options); Map map = await powerImageCompleter.completer!.future; } return createImageInfo(map); } \",\"这里是使用 PowerImageLoader 的单例加载图片，看一下具体的实现：\",\"class PowerImageLoader { // 保存发起的图片请求 static Map<String?, PowerImageCompleter> completers = <String?, PowerImageCompleter>{}; PowerImageChannel channel = PowerImageChannel(); static PowerImageLoader instance = PowerImageLoader._(); PowerImageLoader._() { channel.impl = PowerImagePlatformChannel(); } // 初始化PowerImageChannel等，需要在加载图片之前（比如runApp之前执行） void setup(PowerImageSetupOptions? options) { _globalRenderType = options?.globalRenderType ?? defaultGlobalRenderType; PowerImageMonitor.instance().errorCallback = options?.errorCallback; PowerImageMonitor.instance().errorCallbackSamplingRate = options?.errorCallbackSamplingRate; channel.setup(); } PowerImageCompleter loadImage(PowerImageRequestOptions options,) { PowerImageRequest request = PowerImageRequest.create(options);// 创建PowerImageRequest // 发起图片请求 channel.startImageRequests(<PowerImageRequest>[request]); // 使用completers记录下刚刚发起的请求 PowerImageCompleter completer = PowerImageCompleter(); completer.request = request; completer.completer = Completer<Map>(); completers[request.uniqueKey()] = completer; return completer; } // 当上面loadImage发起的图片加载完成之后，会调用此方法，从completers中取回对应的请求，调用完成 void onImageComplete(Map<dynamic, dynamic> map) async { String? uniqueKey = map['uniqueKey']; PowerImageCompleter? completer = completers.remove(uniqueKey); //todo null case completer?.completer?.complete(map); } } \",\"首先创建了 PowerImageRequest 对象：\",\"class PowerImageRequest { PowerImageRequest.create(PowerImageRequestOptions options) : imageWidth = options.imageWidth, imageHeight = options.imageHeight, imageType = options.imageType, renderingType = options.renderingType, src = options.src; } \",\"其中：\",\"imageType表示获取图片的方式（比如network，nativeAsset，file，asset等）；\",\"renderingType表示图片渲染方式，比如external（即 ffi 方案）、texture。\",\"然后通过PowerImageChannel发送请求（实际的执行的类是PowerImagePlatformChannel）：\",\"class PowerImagePlatformChannel extends PowerImageChannelImpl { StreamSubscription? _subscription; PowerImagePlatformChannel() { eventHandlers['onReceiveImageEvent'] = (Map<dynamic, dynamic> event) { // 将onReceiveImageEvent放到eventHandlers中， // 上述PowerImageLoader发起的请求完成后会执行下述代码 PowerImageLoader.instance.onImageComplete(event); }; } @override void setup() { // 监听回调方法，监听Native端发送的图片加载结束事件 startListening(); } StreamSubscription? startListening() { _subscription ??= eventChannel.receiveBroadcastStream().listen(onEvent); return _subscription; } Map<String, EventHandler?> eventHandlers = <String, EventHandler?>{}; // 处理Native端发送的事件 void onEvent(dynamic val) { assert(val is Map<dynamic, dynamic>); final Map<dynamic, dynamic> event = val; String? eventName = event['eventName']; EventHandler? eventHandler = eventHandlers[eventName!]; if (eventHandler != null) { eventHandler(event); } else { //TODO 发来了不认识的事件,需要处理一下 } } void registerEventHandler(String eventName, EventHandler eventHandler) { assert(eventName.isNotEmpty); eventHandlers[eventName] = eventHandler; } void unregisterEventHandler(String eventName) { eventHandlers[eventName] = null; } @visibleForTesting final MethodChannel methodChannel = const MethodChannel('power_image/method'); @visibleForTesting EventChannel eventChannel = const EventChannel('power_image/event'); // 主动发送请求到Native端 @override void startImageRequests(List<PowerImageRequest> requests) async { await methodChannel.invokeListMethod( 'startImageRequests', encodeRequests(requests)); } @override void releaseImageRequests(List<PowerImageRequest> requests) async { await methodChannel.invokeListMethod( 'releaseImageRequests', encodeRequests(requests)); } } \",\"小结一下：\",\"使用PowerImageLoader.setup注册 MethodChannel 和 EventChannel\",\"使用PowerImageLoader.loadImage向 Native 发起请求加载图片，将请求保存到PowerImageLoader.completers中并返回给调用者\",\"当 Native 端处理完请求之后会回调 PowerImagePlatformChannel 中注册的 EventChannel，然后会执行PowerImageLoader.instance.onImageComplete(event)方法，使用返回的图片信息，从PowerImageLoader.completers找出并完成之前的请求\",\"以上分析为 Flutter 端向 Native 端发起请求的过程，下面以 Android 端为例分析一下 Native 端的处理过程：\",\"首先是在 PowerImagePlugin 中向 Flutter 引擎注册对应的方法。\",\"public class PowerImagePlugin implements FlutterPlugin, MethodCallHandler { @Override public void onAttachedToEngine(FlutterPluginBinding flutterPluginBinding) { if(sContext == null){ sContext = flutterPluginBinding.getApplicationContext(); } // 注册与Flutter端对应的方法 methodChannel = new MethodChannel( flutterPluginBinding.getBinaryMessenger(), \\\"power_image/method\\\"); methodChannel.setMethodCallHandler(this); eventChannel = new EventChannel( flutterPluginBinding.getBinaryMessenger(), \\\"power_image/event\\\"); eventChannel.setStreamHandler(PowerImageEventSink.getInstance()); PowerImageRequestManager.getInstance() .configWithTextureRegistry(flutterPluginBinding.getTextureRegistry()); PowerImageDispatcher.getInstance().prepare(); } } \",\"当 Flutter 端向 Native 发送消息时，Flutter 引擎会调用PowerImagePlugin.onMethodCall方法：\",\" // PowerImagePlugin.onMethodCall @Override public void onMethodCall(MethodCall call, Result result) { if (\\\"startImageRequests\\\".equals(call.method)) { if (call.arguments instanceof List) { List arguments = (List) call.arguments; // 将请求结果返回，只是根据传参创建请求并保存， // 将请求信息返回给Flutter端 List results = PowerImageRequestManager.getInstance() .configRequestsWithArguments(arguments); result.success(results); // 开始真正执行请求，找到上一步创建的请求PowerImageBaseRequest // 并执行PowerImageBaseRequest.startLoading PowerImageRequestManager.getInstance().startLoadingWithArguments(arguments); } else { throw new IllegalArgumentException(\\\"startImageRequests require List arguments\\\"); } } else if (\\\"releaseImageRequests\\\".equals(call.method)) { if (call.arguments instanceof List) { List arguments = (List) call.arguments; // 立即执行释放请求 List results = PowerImageRequestManager.getInstance().releaseRequestsWithArguments(arguments); result.success(results); } else { throw new IllegalArgumentException(\\\"stopImageRequests require List arguments\\\"); } } else { result.notImplemented(); } } \",\"对于不同的调用请求：\",\"startImageRequests：先根据请求参数创建好请求并返回给 Flutter 调用方；然后通过 PowerImageRequestManager 真正执行请求（最终会通过PowerImagePlugin.PowerImageEventSink.getInstance().sendImageStateEvent向 Flutter 通知结果）。\",\"releaseImageRequests：立即从PowerImageRequestManager.requests中去除对应的请求并尝试终止任务，并向 Flutter 返回结果。\",\"下面着重分析一下执行图片请求的逻辑（startImageRequests的情况）：\",\"public class PowerImageRequestManager { private Map<String, PowerImageBaseRequest> requests; private WeakReference<TextureRegistry> textureRegistryWrf; public List<Map<String, Object>> configRequestsWithArguments(List<Map<String, Object>> list) { List<Map<String, Object>> results = new ArrayList<>(); if (list == null || list.isEmpty()) { return results; } for (int i = 0; i < list.size(); i++) { Map<String, Object> arguments = list.get(i); String renderType = (String) arguments.get(\\\"renderingType\\\"); PowerImageBaseRequest request; if (RENDER_TYPE_EXTERNAL.equals(renderType)) {// ffi方案 request = new PowerImageExternalRequest(arguments); } else if (RENDER_TYPE_TEXTURE.equals(renderType)) {// texture方案 request = new PowerImageTextureRequest(arguments, textureRegistryWrf.get()); } else { continue; } // 保存创建的请求 requests.put(request.requestId, request); boolean success = request.configTask(); Map<String, Object> requestInfo = request.encode(); requestInfo.put(\\\"success\\\", success); results.add(requestInfo); } return results; } public void startLoadingWithArguments(List arguments) { if (arguments == null || arguments.isEmpty()) { return; } for (int i = 0; i < arguments.size(); i++) { Map arg = (Map) arguments.get(i); String requestId = (String) arg.get(\\\"uniqueKey\\\"); // 找出在configRequestsWithArguments方法中创建的请求并执行 PowerImageBaseRequest request = requests.get(requestId); request.startLoading(); } } } \",\"可见对于ffi和texture方案，分别涉及到**PowerImageExternalRequest和PowerImageTextureRequest两个类。他们都继承自PowerImageBaseRequest**类，其startLoading方法会调用performLoadImage方法：\",\"public abstract class PowerImageBaseRequest { private void performLoadImage() { // 获取图片 PowerImageLoader.getInstance().handleRequest( imageRequestConfig, new PowerImageLoaderProtocol.PowerImageResponse() { @Override public void onResult(PowerImageResult result) { // 加载到图片之后进行解析 PowerImageBaseRequest.this.onLoadResult(result); } } ); } } \",\"在PowerImageBaseRequest.performLoadImage方法中：\",\"会先通过PowerImageLoader.getInstance().handleRequest方法获取图片；\",\"然后调用PowerImageBaseRequest.this.onLoadResult方法也就是PowerImageExternalRequest和PowerImageTextureRequest的onLoadResult()方法。\",\"在他们的onLoadResult(final PowerImageResult result)方法中，入参 PowerImageResult 持有 FlutterImage 对象，后者持有加载的图片的 Drawable，他们根据各自的特点对图片进行处理后（ffi获取 Drawable 的 bitmap 对象，<>如果图片不是ARGB_8888则会发生一次 Bitmap 拷贝>；texture使用 Bitmap 绘制到 Canvas 上面），通过PowerImageBaseRequest.onLoadSuccess()方法或者PowerImageBaseRequest.onLoadFailed返回结果。\",\"其中:\",\"PowerImageExternalRequest 从获取到的图片生成 Bitmap 并返回其指针、宽高、大小等属性返回；\",\"PowerImageTextureRequest 则将图片绘制到Surface中并返回textureId等信息。\",\"而对于PowerImageLoader.getInstance().handleRequest()，这里面的各个 PowerImageLoaderProtocol 由 Native 端通过PowerImageLoader.getInstance().registerImageLoader注册具体的实现，handleRequest()方法正是调用他们获取图片。\",\"public class PowerImageLoader implements PowerImageLoaderProtocol { private final Map<String, PowerImageLoaderProtocol> imageLoaders; private PowerImageLoader() { imageLoaders = new HashMap<>(); } private static class Holder { private final static PowerImageLoader instance = new PowerImageLoader(); } public static PowerImageLoader getInstance() { return PowerImageLoader.Holder.instance; } // 在Android中调用此方法，注册获取\\\"network\\\"、\\\"nativeAsset\\\"、\\\"asset\\\"、\\\"file\\\"等图片的实现 public void registerImageLoader(PowerImageLoaderProtocol loader, String imageType) { imageLoaders.put(imageType, loader); } // 此方法调用上面registerImageLoader方法注册的ImageLoader获取图片 @Override public void handleRequest(PowerImageRequestConfig request, PowerImageResponse response) { PowerImageLoaderProtocol imageLoader = imageLoaders.get(request.imageType); if (imageLoader == null) { throw new IllegalStateException(\\\"PowerImageLoader for \\\" + request.imageType + \\\" has not been registered.\\\"); } imageLoader.handleRequest(request, response); } } \",\"上面提到，power_image默认的**PowerImageLoaderProtocol**有以下几种类：\\\"network\\\"、\\\"nativeAsset\\\"、\\\"asset\\\"、\\\"file\\\"，这些都需要使用者在 Native 端注册才能正常使用。\",\"以\\\"network\\\"为例,在MainActivity.onCreate方法中：\",\"class MainActivity: FlutterActivity() { override fun onCreate(savedInstanceState: Bundle?) { ... PowerImageLoader.getInstance().registerImageLoader( PowerImageNetworkLoader(this.applic ationContext), \\\"network\\\" ) } } \",\"PowerImageNetworkLoader继承自PowerImageLoaderProtocol，图片的加载逻辑在其handleRequest方法中：\",\"class PowerImageNetworkLoader(private val context: Context) : PowerImageLoaderProtocol { override fun handleRequest(request: PowerImageRequestConfig, response: PowerImageResponse) { // 使用Glide加载图片Drawable Glide.with(context).asDrawable().load(request.srcString()) .listener(object : RequestListener<Drawable> { override fun onLoadFailed(e: GlideException?,model: Any, target: Target<Drawable>,isFirstResource: Boolean): Boolean { response.onResult(PowerImageResult.genFailRet(\\\"Native加载失败: \\\" + if (e != null) e.message else \\\"null\\\")) return true } override fun onResourceReady(resource: Drawable,model: Any target:Target<Drawable>,dataSource: DataSource,isFirstResource:Boolean ): Boolean { if (resource is GifDrawable) { // 动图 // 加载成功，调用回调 response.onResult( PowerImageResult.genSucRet( GlideMultiFrameImage( resource as GifDrawable, false ) ) ) } else { if (resource is BitmapDrawable) {// 普通图片 response.onResult( PowerImageResult.genSucRet( FlutterSingleFrameImage( resource as BitmapDrawable ) ) ) } else { response.onResult(PowerImageResult.genFailRet(\\\"Native加载失败: resource : $resource\\\")) } } return true } }).submit( if (request.width <= 0) Target.SIZE_ORIGINAL else request.width, if (request.height <= 0) Target.SIZE_ORIGINAL else request.height ) } } \",\"这样，当 Flutter 端向 Native 发送消息时：\",\"Flutter 引擎会调用PowerImagePlugin.onMethodCall方法，先创建对应的请求**PowerImageBaseRequest**；\",\"然后PowerImageRequestManager.getInstance().startLoadingWithArguments执行刚刚上一步创建的请求，此方法内部执行PowerImageBaseRequest.startLoading()方法；\",\"在**PowerImageBaseRequest类内部，其startLoading方法会调用performLoadImage方法，后者又会调用PowerImageLoader.getInstance().handleRequest()方法请求加载图片**，并指定回调方法为PowerImageBaseRequest.onLoadResult(result)；\",\"PowerImageLoader.handleRequest方法内部通过请求的imageType找到 Native 端（比如 Android 在MainActivity.onCreate中注册的）PowerImageLoaderProtocol imageLoader，并执行其handleRequest方法处理加载图片请求；\",\"PowerImageLoaderProtocol.handleRequest()方法中调用原生的图片加载库获取 Drawable 并生成 PowerImageResult 回调PowerImageResponse.onResult方法，此方法会回调PowerImageBaseRequest.this.onLoadResult(result) ；\",\"在**PowerImageTextureRequest或者PowerImageExternalRequest**的onLoadResult方法中对获取到的PowerImageResult进行处理之后回调PowerImageBaseRequest的onLoadSuccess()或者onLoadFailed(final String errMsg)方法返回图片请求结果。\",\"power_image 是一个利用原生库加载/管理图片的比较适用于 Flutter/Native 混合开发的图片加载库，提供了 texture 和 ffi 两种加载图片的方式。\",\"其中，texture 方案实际使用 Texture 组件展示图片；而 ffi 方案则只有图片获取在 Native 端，当使用ui.decodeImageFromPixels方法从 Bitmap 内存指针创建ui.Image之后（根据阿里的描述，这里会发生一次内存拷贝，实际代码可以参考这里），剩下按照和 Flutter Image 类似的步骤展示图片。\",\"根据官方的说法：\",\"Texture 适用于日常场景，优先选择；\",\"FFI 更适用于 \",\"flutter <= 1.23.0-18.1.pre 版本中，在模拟器上显示图片\",\"获取 ui.Image 图片数据\",\"flutter 侧解码，解码前的数据拷贝影响较小。\",\"此外，根据官方power_image/issues/17的说法，“在 2.5.3 上 ffi 性能已经跟 texture不相上下了”，而且 textrue 方案在 Android 上较大尺寸可能会 crash（flutter/flutter#92397），所以更推荐使用 ffi 方案。\",\"https://github.com/alibaba/power_image\",\"Flutter 图片库高燃新登场\",\"闲鱼 Flutter 图片框架架构演进（超详细）\",\"Flutter 图片内存优化实践\",\"https://github.com/alibaba/power_image/issues/17\",\"ui.decodeImageFromPixels分析\"]},\"212\":{\"h\":\"Flutter滑动分析之NestedScrollView\",\"t\":[\"Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：\",\"基于 RenderBox 的 box protocol 实现的，主要基于 Size 实现布局。常见的有SingleChildScrollView。\",\"基于 RenderSliver 的 sliver protocol 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自ScrollView的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。\",\"上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。\",\"本文只对 NestedScrollView 的源码实现做一简单分析：它是如何实现联动滚动效果，有什么优势和限制。\",\"官方对其定义是：“A scrolling view inside of which can be nested other scrolling views, with their scroll positions being intrinsically linked.”。\",\"顾名思义，NestedScrollView 是一个可以在内部嵌套其他 scrolling views 的滑动 View，按照所处位置的不同，使用headerSliverBuilder提供 header 部分的 scrolling views（限制只能是可以产生 RenderSliver 的 widget），而使用body提供在填充 header 之下所有区域的 widget（限制只能是产生 RenderBox 的 widget）。\",\"下面是一个 NestedScrollView 经典的使用方式：\",\" Widget build(BuildContext context) { var _tabBar = TabBar( isScrollable: true, tabs: tabs .map((e) => Tab( child: Container( height: double.infinity, child: Center(child: Text(\\\"Tab$e\\\")), ), )) .toList(), ); return Scaffold( body: DefaultTabController(// 此处的controller是给TabBar和TabBarView使用的 length: tabs.length, child: NestedScrollView( headerSliverBuilder: (context, innerScroll) { return [// 必须是能够产生RenderSliver的Widget SliverAppBar( pinned: true, toolbarHeight: 0, expandedHeight: 200, bottom: _tabBar,//在这里传入TabBar ), ]; }, body: TabBarView(// body必须是能产生RenderBox的widget children: tabs .map((e) => ListView(// 这里的列表滑动和header的滑动联动 children: List.generate( 100, (index) => SizedBox( height: 80, child: Text(\\\"Hello TabBarView $e $index\\\"))), )) .toList()), )), ); } \",\"在这个例子中，NestedScrollView 包括了 headerSliverBuilder 创建的 header 部分，以及 header 下面的 body 部分，二者的滑动效果联动在一起，好像是同一个 scrolling view。比如，当向上滑动 TabBarView 中列表时，会先向上滑动 header 内容，等到 header 无需再滑动才会向上滑动列表。而如果没有 NestedScrollView 的话，ListView 和 header 的滑动是独立的两个事件。\",\"NestedScrollView 本质上还是对 CustomScrollView（的子类_NestedScrollViewCustomScrollView）的进一步封装。\",\"它借助于_NestedScrollCoordinator 的_outerController 和_innerController 这两个分别传入_NestedScrollViewCustomScrollView（header 和 body 其实是他的 slivers，其最大滑动范围为 header 的 scrollExtent） 和 body 中的 scrolling view（其最大滑动范围为内部滑动视图最大滑动范围之和） 的 ScrollController，创建并应用_NestedScrollPosition；当用户滑动等事件发生，通过_NestedScrollViewCustomScrollView 的_NestedScrollPosition 接收外部所有的滑动事件全部归集到_NestedScrollCoordinator （比如 applyUserOffset 方法）统一处理，按照 ScrollPhysics 等分别修改 header 和 body 的 ScrollPosition，从而实现了这两处滑动事件的联动。\",\"所以，在分析 NestedScrollView 的时候，主要涉及到以下类：\",\"NestedScrollViewState：是 NestedScrollView 真正执行逻辑的类，将_NestedScrollCoordinator、_NestedScrollViewCustomScrollView、ScrollController 等组装在一起，对外暴露操纵_NestedScrollCoordinator 的方法\",\"_NestedScrollViewCustomScrollView：继承自 CustomScrollView，主要作用是创建自定义的 NestedScrollViewViewport，后者又创建了 RenderNestedScrollViewViewport 主要用途是更新 SliverOverlapAbsorberHandle\",\"_NestedScrollCoordinator：处理_NestedScrollPosition 转发过来的滑动事件，将其分发给 header（其实是容纳 header 和 body 的_NestedScrollViewCustomScrollView）和 body。\",\"_NestedScrollController：给_NestedScrollCoordinator 的 inner 和 outer 的 ScrollController，内部创建_NestedScrollPosition。\",\"_NestedScrollPosition：给_NestedScrollCoordinator 的 inner 和 outer 的 ScrollPosition，会将 animateTo、jumpTo、pointerScroll、updateCanDrag、hold、drag 等和滑动有关的事件转发给_NestedScrollCoordinator 统一处理。\",\"其余辅助类\",\"下面对这些类逐一分析：\"]},\"213\":{\"h\":\"NestedScrollViewState\",\"t\":[\"NestedScrollView 是 StatefulWidget，其主要逻辑都在创建的 State——NestedScrollViewState 中。\",\"class NestedScrollView extends StatefulWidget { List<Widget> _buildSlivers(BuildContext context, ScrollController innerController, bool bodyIsScrolled) { // _buildSlivers的主轴尺寸为header的scrollExtent+viewport主轴尺寸，所以创建好的viewport滑动范围 // 为header的滑动scrollExtent return <Widget>[ ...headerSliverBuilder(context, bodyIsScrolled),// header部分 SliverFillRemaining(//body部分，其尺寸为所处的viewport的主轴尺寸 child: PrimaryScrollController( controller: innerController, child: body,// SliverFillRemaining只能容纳可以产生RenderBox的widget ), ), ]; } @override NestedScrollViewState createState() => NestedScrollViewState(); } \",\"NestedScrollView._buildSlivers 方法将 headerSliverBuilder 创建的 header 和 body 放到一个列表中，会被 NestedScrollViewState 传入到自定义的 CustomScrollView——_NestedScrollViewCustomScrollView 中。\",\"需要注意 SliverFillRemaining 默认会创建_SliverFillRemainingWithScrollable，后者创建的 RenderObject 是_SliverFillRemainingWithScrollable。在 RenderSliverFillRemainingWithScrollable.performLayout 方法会使用他所处 viewport 主轴方向的尺寸作为自己的 scrollExtent。\",\" void performLayout() { final SliverConstraints constraints = this.constraints; final double extent = constraints.remainingPaintExtent - math.min(constraints.overlap, 0.0); if (child != null) child!.layout(constraints.asBoxConstraints( minExtent: extent, maxExtent: extent, )); final double paintedChildSize = calculatePaintOffset(constraints, from: 0.0, to: extent); assert(paintedChildSize.isFinite); assert(paintedChildSize >= 0.0); geometry = SliverGeometry( scrollExtent: constraints.viewportMainAxisExtent,// 这里使用的是viewport的主轴尺寸 paintExtent: paintedChildSize, maxPaintExtent: paintedChildSize, hasVisualOverflow: extent > constraints.remainingPaintExtent || constraints.scrollOffset > 0.0, ); if (child != null) setChildParentData(child!, constraints, geometry!); } \",\"也就是说无论 inner scrolling view 的尺寸如何，它（下面称其为 body）占用的 scrollExtent 都是所处的 viewport 的主轴尺寸 mainAxisExtent；再加上 headerSliverBuilder 方法创建的 header，导致_NestedScrollViewCustomScrollView 所创建的 viewport 的最大可滑动范围_maxScrollExtent（其值等于 header+body 的 scrollExtent）一定大于 viewport 的主轴方向尺寸 mainAxisExtent，从而计算出_NestedScrollViewCustomScrollView 的 ScrollPosition 的最大滑动范围（maxScrollExtent）为:\",\"_outScrollPosition.maxScrollExtent = viewport._maxScrollExtent - viewport.mainAxisExtent = (body.scrollExtent + header.scrollExtent) - viewport.mainAxisExtent = (viewport.mainAxisExtent + header.scrollExtent) - viewport.mainAxisExtent = header.scrollExtent \",\"所以，无论 NestedScrollView 的 body 内容尺寸如何，它为 header+body 分配的尺寸只比 viewport 的尺寸多出一个 header 的尺寸。这个也是 NestedScrollView 实现协调 header 和 body 滑动的基础。\",\"让我们再看一下 NestedScrollViewState 的实现：\",\"NestedScrollViewState 中一个重要的属性就是_NestedScrollCoordinator? _coordinator，它在initState()方法中初始化。\",\"class NestedScrollViewState extends State<NestedScrollView> { // inner和outer controller都来自_coordinator ScrollController get innerController => _coordinator!._innerController; ScrollController get outerController => _coordinator!._outerController; _NestedScrollCoordinator? _coordinator; void initState() { super.initState(); _coordinator = _NestedScrollCoordinator( this, widget.controller,// 注意这里传入了widget处获取的controller _handleHasScrolledBodyChanged, widget.floatHeaderSlivers, ); } } \",\"能注意到，_NestedScrollCoordinator 中持有了 widget.controller，并且还会在 didChangeDependencies、didUpdateWidget 方法被调用时通过_NestedScrollCoordinator.setParent 方法更新，主要有两个作用：1. 获取 initialScrollOffset；2. 通过_outerPosition?.setParent 使得 widget.controller 可以监听 outerPosition 的变化。\",\"然后，在 NestedScrollViewState.build 方法中，会创建_NestedScrollViewCustomScrollView 对象：\",\"将_coordinator!._outerController 作为其 controller，这样会创建，_outerPosition,后者会将_NestedScrollViewCustomScrollView 的事件转发给_coordinator,这样其接管了外层的滑动事件；\",\"此外在 NestedScrollView._buildSlivers 方法中创建的 header 和 body 作为_NestedScrollViewCustomScrollView 也就是 CustomScrollView 的 slivers。\",\"这也是创建 header 的NestedScrollView.headerSliverBuilder 只接受可以创建 RenderSliver 的 widget的原因。\",\" @override Widget build(BuildContext context) { final ScrollPhysics scrollPhysics = widget.physics?.applyTo(const ClampingScrollPhysics()) ?? widget.scrollBehavior?.getScrollPhysics(context).applyTo(const ClampingScrollPhysics()) ?? const ClampingScrollPhysics(); return _InheritedNestedScrollView( state: this, child: Builder( builder: (BuildContext context) { _lastHasScrolledBody = _coordinator!.hasScrolledBody; return _NestedScrollViewCustomScrollView( dragStartBehavior: widget.dragStartBehavior, scrollDirection: widget.scrollDirection, reverse: widget.reverse, physics: scrollPhysics, scrollBehavior: widget.scrollBehavior ?? ScrollConfiguration.of(context).copyWith(scrollbars: false), // 注意这里使用的从_coordinator获取的_outerController controller: _coordinator!._outerController, // 这里将header和body传入slivers， // _NestedScrollViewCustomScrollView创建的viewport是继承自 // Viewport的NestedScrollViewViewport，其只接受可以创建 // RenderSliver的widget slivers: widget._buildSlivers( context, _coordinator!._innerController, _lastHasScrolledBody!, ), handle: _absorberHandle, clipBehavior: widget.clipBehavior, restorationId: widget.restorationId, ); }, ), ); } \",\"_NestedScrollViewCustomScrollView 继承自 CustomScrollView，主要作用是创建继承自 Viewport 的 NestedScrollViewViewport，而后者又主要负责创建和更新继承自 RenderViewport 的 RenderNestedScrollViewViewport——其在内部更新和维护 SliverOverlapAbsorberHandle。\",\"SliverOverlapAbsorberHandle: Handle to provide to a SliverOverlapAbsorber, a SliverOverlapInjector, and an NestedScrollViewViewport, to shift overlap in a NestedScrollView.\",\"到目前位置，UI 展示部分的内容已经完成，我们的 NestedScrollView 可以将 header 和 body 显示在屏幕上面，但是如果要联动处理在 header 和 body 上面的滑动事件，还需要_NestedScrollCoordinator、_NestedScrollController 和_NestedScrollPosition 的配合。\"]},\"214\":{\"h\":\"_NestedScrollController\",\"t\":[\"_NestedScrollController 继承自 ScrollController，其逻辑比较简单，主要添加了两项功能：\"]},\"215\":{\"h\":\"创建_NestedScrollPosition\",\"t\":[\"创建_NestedScrollPosition 的逻辑比较简单，主要是将 coordinator 也一并传入。\",\" ScrollPosition createScrollPosition( ScrollPhysics physics, ScrollContext context, ScrollPosition? oldPosition, ) { return _NestedScrollPosition( coordinator: coordinator, physics: physics, context: context, initialPixels: initialScrollOffset, oldPosition: oldPosition, debugLabel: debugLabel, ); } \"]},\"216\":{\"h\":\"在 ScrollPosition 变化时通知 coordinator\",\"t\":[\"在 attach(ScrollPosition position)中调用_scheduleUpdateShadow()和_NestedScrollCoordinator 的 updateParent、updateCanDrag，对传入的 ScrollPosition 添加回调_scheduleUpdateShadow()。\",\"在 detach(ScrollPosition position)中调用_scheduleUpdateShadow()，对传入的 ScrollPosition 移除回调_scheduleUpdateShadow()。\",\"而这个_scheduleUpdateShadow()方法主要作用是异步执行 coordinator.updateShadow()更新 NestedScrollView，实现滑动效果。\",\" void _scheduleUpdateShadow() { // We do this asynchronously for attach() so that the new position has had // time to be initialized, and we do it asynchronously for detach() and from // the position change notifications because those happen synchronously // during a frame, at a time where it's too late to call setState. Since the // result is usually animated, the lag incurred is no big deal. SchedulerBinding.instance.addPostFrameCallback( (Duration timeStamp) { coordinator.updateShadow(); }, ); } \"]},\"217\":{\"h\":\"_NestedScrollPosition\",\"t\":[\"在 inner scrolling widget 和 outer viewport 都使用_NestedScrollPosition，它追踪这些 viewport 使用的 offset，并且内部持有_NestedScrollCoordinator，所以此 class 上触发 activities 时，可以推迟或者影响 coordinator。\",\"class _NestedScrollPosition extends ScrollPosition implements ScrollActivityDelegate { final _NestedScrollCoordinator coordinator; // 协调inner和outer滑动事件 // 是在NestedScrollView中传给_NestedScrollViewCustomScrollView的ScrollController ScrollController? _parent; void setParent(ScrollController? value) { _parent?.detach(this); _parent = value; _parent?.attach(this);// 将此ScrollPosition和_parent绑定 } } \"]},\"218\":{\"h\":\"setParent\",\"t\":[\"_NestedScrollPosition.setParent 中，将自己和传入的 ScrollController 绑定在一起：\",\"将自身加入 ScrollController._positions\",\"ScrollController 监听自身变化时执行 notifyListeners 通知监听者\"]},\"219\":{\"h\":\"absorb\",\"t\":[\"在 absorb 方法中将 activity 的 delegate 更新为当前 ScrollPosition：\",\" @override void absorb(ScrollPosition other) { super.absorb(other); // 部分activity会使用此来操作scroll view activity!.updateDelegate(this); } \"]},\"220\":{\"h\":\"applyClampedDragUpdate\",\"t\":[\"此方法返回的是没有使用的 delta，此方法不会主动创建 overscroll/underscroll，如果当前 ScrollPosition 在范围内，则不会发送 overscroll/underscroll；如果已经超出范围，则只会“减轻”这种情况，而不会“加重”。\",\"之所以不会 overscroll，是因为 min 和 max 的取值限定了他们的范围，以一个垂直方向向下布局的滑动列表为例：\",\"delat < 0，即向上滑动，范围是 min：-double.infinity ~ max： 0（overscroll 时）或者 maxScrollExtent 和 pixels 中最大值（只能滑到最大范围）。\",\"也就是说，向上滑动时，如果已经在顶部出现 overscroll（此时 pixels 应该为负值），那么最多滑动到 0（也就是恢复到初始位置），没有顶部 overscroll 时（此时 pixels 为正值，可能在 maxScrollExtent 范围内，也可能超出范围，即底部出现 overscroll），那么此时最多向上滑动 maxScrollExtent 和 pixels，也就是说要么不能超范围，要是超了范围，就不能再超了。\",\"而最小滑动范围为-double.infinity，无论 pixels 正负，当其 delta 为负时，其值都只会增大，取值-double.infinity 是为了将 pixels 包含在内。\",\"delta > 0，即向下滑动，范围是 min：minScrollExtent 和 pixels 最小值 ~ double.infinity。\",\"也就是说，向下滑动最小到初始位置，最大值不限定（因为此时可能 offset 已经由于某种原因超过 maxScrollExtent 了）。\",\" // Returns the amount of delta that was not used. // Positive delta means going down (exposing stuff above), negative delta // going up (exposing stuff below). double applyClampedDragUpdate(double delta) { assert(delta != 0.0); // If we are going towards the maxScrollExtent (negative scroll offset), // then the furthest we can be in the minScrollExtent direction is negative // infinity. For example, if we are already overscrolled, then scrolling to // reduce the overscroll should not disallow the overscroll. // // If we are going towards the minScrollExtent (positive scroll offset), // then the furthest we can be in the minScrollExtent direction is wherever // we are now, if we are already overscrolled (in which case pixels is less // than the minScrollExtent), or the minScrollExtent if we are not. // // In other words, we cannot, via applyClampedDragUpdate, _enter_ an // overscroll situation. // // An overscroll situation might be nonetheless entered via several means. // One is if the physics allow it, via applyFullDragUpdate (see below). An // overscroll situation can also be forced, e.g. if the scroll position is // artificially set using the scroll controller. // delat < 0，即向上滑动，范围是 min：-double.infinity ~ max： 0 //（overscroll时）或者 maxScrollExtent和pixels中最大值（只能滑到最大范围） // delta > 0，即向下滑动，范围是 min：minScrollExtent和pixels最小值 ~ // double.infinity（也就是说，向下滑动最小到初始位置，最大值不限定 // [因为此时可能offset已经由于某种原因超过maxScrollExtent了]） final double min = delta < 0.0 ? -double.infinity// 向上滑动 : math.min(minScrollExtent, pixels);// 向下滑动 // The logic for max is equivalent but on the other side. // 这里的逻辑是，如果向下滑动，那么max为无限大； // 如果向上滑动并且已经overscroll了，那么max是0（即恢复初始位置），否则为maxScrollExtent即最大滑动范围 final double max = delta > 0.0 ? double.infinity// 向下滑动 // If pixels < 0.0, then we are currently in overscroll. The max should be // 0.0, representing the end of the overscrolled portion. // pixels比maxScrollExtent大可能是由于jumpTo等情况，此时max为pixels表示不能继续滑动超出此值 : pixels < 0.0 ? 0.0 : math.max(maxScrollExtent, pixels);// 向上滑动 final double oldPixels = pixels; //newPixels是可以应用到ScrollPosition的pixels，其范围： // 1. delta为负，即向上滑动，pixels - delta = pixels + |delta| > pixels， // 1.1 当pixels小于0也就是存在overscroll时，其范围是pixels + |delta|~0， // 此时overscroll偏移量为pixels + |delta|，newPixels在pixels + |delta|~0之间，【不会再加深越界】 // 1.2 当pixels大于等于0也就是不存在overscroll时，其范围是pixels + |delta|~maxScrollExtent // 此时，newPixels在pixels + |delta|~maxScrollExtent之间，最大为maxScrollExtent【newPixels不会越界】 // 2. delta为正，即向下滑动，pixels - delta = pixels - |delta| < pixels // 2.1 当pixels小于0也就是存在overscroll时，pixels - delta = pixels - |delta| < pixels， // 其范围是（pixels和minScrollExtent较小值）~double.infinity，也就是delta不会 // 被应用，newPixels会等于pixels，如果已经越界了，【不会再加深越界】 // 2.2 当pixels大于等于0也就是不存在overscroll时，其范围是minScrollExtent~double.infinity， // newPixels会在minScrollExtent和pixels之间，【newPixels的值不会越界】 final double newPixels = (pixels - delta).clamp(min, max); final double clampedDelta = newPixels - pixels;// 对比ScrollPosition变化的值 // position的pixels为0且向下滑动时这里clampedDelta为0，不执行剩余步骤 if (clampedDelta == 0.0) return delta; // 返回超出界限的值overscroll，如果为0表示可以任意超出界限，不为0表示不可以应用到 //ScrollPosition上的值，根据physics而不同 final double overscroll = physics.applyBoundaryConditions(this, newPixels); // 减去了overscroll，所以这里actualNewPixels是真正可以应用的pixels final double actualNewPixels = newPixels - overscroll; // offset表示经过上述计算之后，ScrollPosition实际将要产生的变化 final double offset = actualNewPixels - oldPixels; if (offset != 0.0) { // 根据physics的不同，这里offset可能会导致ScrollPosition内部视觉上出现越界现象，此时overscroll为0， // 或者没有越界内容，overscroll为0或者应用了delta之后会出现的越界值 forcePixels(actualNewPixels);//更新pixels didUpdateScrollPositionBy(offset);// 发出ScrollUpdateNotification通知 } // delta为负时，offset为正值；delta为正值时，offset为负值。总之delta绝对值减少了。 return delta + offset; } \"]},\"221\":{\"h\":\"applyFullDragUpdate\",\"t\":[\"此方法在满足 overscroll 条件时，会应用 overscroll，并发出 OverscrollNotification 通知。\",\" double applyFullDragUpdate(double delta) { assert(delta != 0.0); final double oldPixels = pixels; // Apply friction: final double newPixels = pixels - physics.applyPhysicsToUserOffset( this, delta, ); if (oldPixels == newPixels)// 应用delta之后没有变化，返回 return 0.0; // delta must have been so small we dropped it during floating point addition // Check for overscroll: // 按照physics的规则，如果可以overscroll则返回0，下面的actualNewPixels会展示出越界的效果 // 否则返回不能消耗的delta，会发出overscroll通知 final double overscroll = physics.applyBoundaryConditions(this, newPixels); // 如果physics允许越界返回overscroll是0，则这里actualNewPixels最终是越界的pixels final double actualNewPixels = newPixels - overscroll; if (actualNewPixels != oldPixels) { forcePixels(actualNewPixels);// 更新当前ScrollPosition的pixels值 didUpdateScrollPositionBy(actualNewPixels - oldPixels); } if (overscroll != 0.0) { // 发出overscroll的OverscrollNotification通知，然后会有地方处理overscroll // 比如Android会触发在ScrollableState.build方法中的_configuration.buildOverscrollIndicator // 对应的ScrollBehavior.buildViewportChrome创建蓝色波纹效果 didOverscrollBy(overscroll); return overscroll; } return 0.0; } \"]},\"222\":{\"h\":\"applyClampedPointerSignalUpdate\",\"t\":[\"applyClampedPointerSignalUpdate 方法返回未使用的 delta，不考虑 ScrollPhysics 的影响。\"]},\"223\":{\"h\":\"applyNewDimensions()\",\"t\":[\"此方法是_outerScrollPosition 接管 body 滑动事件的关键，也是body 中 scrolling view 使用了自己的 ScrollController 之后 NestedScrollView 就无法协调 header 和 body 滑动的原因。\",\"在默认的 ScrollController 中，createScrollPosition()方法创建的是 ScrollPositionWithSingleContext，当 content 或者 viewport 的尺寸变化之后会调用其 applyNewDimensions()方法：\",\" // ScrollPositionWithSingleContext类 void applyNewDimensions() { super.applyNewDimensions(); // 此处的context一般是ScrollableState context.setCanDrag(physics.shouldAcceptUserOffset(this)); } \",\"最后会调用 ScrollableState 的 setCanDrag 方法：\",\" // ScrollableState类 // 识别用户手势的属性，用于RawGestureDetector.gestures Map<Type, GestureRecognizerFactory> _gestureRecognizers = const <Type, GestureRecognizerFactory>{}; @override @protected void setCanDrag(bool value) { if (value == _lastCanDrag && (!value || widget.axis == _lastAxisDirection)) return; if (!value) { _gestureRecognizers = const <Type, GestureRecognizerFactory>{}; // 其他方法 } else { // 更新_gestureRecognizers的方法 } } \",\"可见_gestureRecognizers 默认为空，只有主动调用 ScrollableState.setCanDrag(true)之后滑动视图中的 Scrollable 才能识别手势并处理。\",\"而在_NesetedScrollPosition 的方法中，并没有调用，而是：\",\" // _NestedScrollPosition类 @override void applyNewDimensions() { super.applyNewDimensions(); coordinator.updateCanDrag(); } // _NestedScrollCoordinator类 void updateCanDrag() { if (!_outerPosition!.haveDimensions) return; double maxInnerExtent = 0.0; for (final _NestedScrollPosition position in _innerPositions) { if (!position.haveDimensions) return; maxInnerExtent = math.max( maxInnerExtent, position.maxScrollExtent - position.minScrollExtent, ); } // 注意这里只给_outerPosition调用了updateCanDrag方法 _outerPosition!.updateCanDrag(maxInnerExtent); } \",\"从上述代码分析可知，如果使用默认的_NestedScrollController 创建的_NestedScrollPosition，最后只有_outerPosition 更新了_gestureRecognizers 可以识别手势，而使用_innerScrollPosition 的 body 内部的 scrolling view 无法识别手势。\",\"所以，当没有给 body 中的 scrolling view 主动设置 ScrollController 时，无论是在 header 还是 body 的手势事件都会由 ScrollPosition 来转发给_NestedScrollCoordinator 统一协调处理；而如果给 body 中的 scrolling view 主动设置 ScrollController，由于 ScrollController 默认创建的 ScrollPositionWithSingleContext 会按照实际情况更新_gestureRecognizers，从而当用户手势在 body 中 scrolling view 的范围时，手势事件会被其捕获并内部消耗，而非转发到_NestedScrollCoordinator 处理，所以就会使 NestedScrollView 失效。\",\"此外还持有了_NestedScrollCoordinator，在 animateTo/jumpTo/pointerScroll/applyNewDimensions/hold/drag 等与滑动相关的方法被调用时执行_NestedScrollCoordinator 中对应的方法，这样就将 outer viewport 和 inner scrolling view 的滑动事件都归集到_NestedScrollCoordinator 统一处理。\"]},\"224\":{\"h\":\"_NestedScrollCoordinator\",\"t\":[\"为了与_NestedScrollPosition 保持一致，方便接收其转发的事件，_NestedScrollCoordinator 也实现了 ScrollActivityDelegate 接口：\",\"class _NestedScrollCoordinator implements ScrollActivityDelegate, ScrollHoldController { final NestedScrollViewState _state;// 用于获取NestedScrollView的ScrollController ScrollController? _parent;// 用户传入的NestedScrollView的ScrollController final bool _floatHeaderSlivers;// header是否悬浮，是的话向“下”滑动时会先将header滑动出来 // 分别应用于outer（即_NestedScrollViewCustomScrollView）和inner（即body中的 // scrolling view）的ScrollController late _NestedScrollController _outerController; late _NestedScrollController _innerController; } \"]},\"225\":{\"h\":\"beginActivity\",\"t\":[\"beginActivity 用来对 outer 和 inner 应用 ScrollActivity，在 goIdle/goBallistic/animateTo/jumpTo/pointerScroll/drag/hold 等与滑动有关的方法中都有直接或间接的调用。\",\"其中 outer activity 是直接指定的，而 inner activity 则是根据 innerActivityGetter 和 inner position 动态计算。\",\" void beginActivity(ScrollActivity newOuterActivity, _NestedScrollActivityGetter innerActivityGetter) { _outerPosition!.beginActivity(newOuterActivity);// outer直接应用ScrollActivity bool scrolling = newOuterActivity.isScrolling; for (final _NestedScrollPosition position in _innerPositions) { // 依次遍历inner scrolling view计算对应的newInnerActivity final ScrollActivity newInnerActivity = innerActivityGetter(position); position.beginActivity(newInnerActivity); scrolling = scrolling && newInnerActivity.isScrolling; } _currentDrag?.dispose(); _currentDrag = null; if (!scrolling) // 如果都没有滑动，就表示当前NestedScrollView停止 updateUserScrollDirection(ScrollDirection.idle); } \",\"此方法的一种使用方式如下：\",\" void goBallistic(double velocity) { beginActivity( createOuterBallisticScrollActivity(velocity),// 创建outer activity (_NestedScrollPosition position) {// 根据position创建inner activity return createInnerBallisticScrollActivity( position, velocity, ); }, ); } \",\"创建 outer scroll activity 的方法：\",\" ScrollActivity createOuterBallisticScrollActivity(double velocity) { // This function creates a ballistic scroll for the outer scrollable. // // It assumes that the outer scrollable can't be overscrolled, and sets up a // ballistic scroll over the combined space of the innerPositions and the // outerPosition. // First we must pick a representative inner position that we will care // about. This is somewhat arbitrary. Ideally we'd pick the one that is \\\"in // the center\\\" but there isn't currently a good way to do that so we // arbitrarily pick the one that is the furthest away from the infinity we // are heading towards. _NestedScrollPosition? innerPosition; if (velocity != 0.0) {// 选择在正方向上离我们最远的inner position for (final _NestedScrollPosition position in _innerPositions) { if (innerPosition != null) { if (velocity > 0.0) { if (innerPosition.pixels < position.pixels) continue; } else { assert(velocity < 0.0); if (innerPosition.pixels > position.pixels) continue; } } innerPosition = position; } } if (innerPosition == null) {// 这里表示只有outer或者velocity为0 // It's either just us or a velocity=0 situation. return _outerPosition!.createBallisticScrollActivity( _outerPosition!.physics.createBallisticSimulation( _outerPosition!, velocity, ), mode: _NestedBallisticScrollActivityMode.independent, ); } // 这里表示NestedScrollView中存在inner和outer scrolling view，且velocity不为0 // 在innerPosition和outerPosition组合的space之上设置overscroll final _NestedScrollMetrics metrics = _getMetrics(innerPosition, velocity); return _outerPosition!.createBallisticScrollActivity( _outerPosition!.physics.createBallisticSimulation(metrics, velocity), mode: _NestedBallisticScrollActivityMode.outer, metrics: metrics, ); } \",\"可见在计算 outer scroll activity 的时候，需判断 body 内是不是有 inner scrolling view：\",\"没有，按照正常创建 BallisticScrollActivity 的流程创建\",\"有，将 inner 的 space 也计入，然后以此计算 BallisticScrollActivity\",\"创建 inner scroll activity 的方法：\",\" ScrollActivity createInnerBallisticScrollActivity(_NestedScrollPosition position, double velocity) { return position.createBallisticScrollActivity( position.physics.createBallisticSimulation( _getMetrics(position, velocity), velocity, ), mode: _NestedBallisticScrollActivityMode.inner, ); } \"]},\"226\":{\"h\":\"applyUserOffset\",\"t\":[\"applyUserOffset() 是_NestedScrollCoordinator 的重点，也是 NestedScrollView 能够实现协调 inner 和 outer 滑动事件的关键。\",\"在看 applyUserOffset() 方法之前，先看一下 drag()方法，在此方法中创建 ScrollDragController 时 delegate 传入的是_NestedScrollCoordinator。\",\"当用户操作屏幕发生 drag 事件时，手势事件会被 ScrollableState 中的 RawGestureDetector 识别到：\",\"drag 开始时调用_handleDragStart，通过_NestedScrollPosition 转发调用_NestedScrollCoordinator.drag方法创建了ScrollDragController drag\",\" // 此方法在ScrollableState中被RawGestureDetector通过 // ScrollableState._handleDragStart -> _NestedScrollPosition.drag // -> _NestedScrollCoordinator.drag链路调用 Drag drag(DragStartDetails details, VoidCallback dragCancelCallback) { final ScrollDragController drag = ScrollDragController( delegate: this, details: details, onDragCanceled: dragCancelCallback, ); beginActivity( DragScrollActivity(_outerPosition!, drag), (_NestedScrollPosition position) => DragScrollActivity(position, drag), ); assert(_currentDrag == null); _currentDrag = drag; return drag; } \",\"drag 开始时更新时_handleDragUpdate，内部调用ScrollDragController.update,在 update 方法内部执行了delegate.applyUserOffset，此处的delegate就是我们之前传入的_NestedScrollCoordinator\",\"根据上述分析，在用户滑动屏幕时，会执行_NestedScrollCoordinator.applyUserOffset方法：\",\" @override void applyUserOffset(double delta) { // 更新scroll方向 updateUserScrollDirection( delta > 0.0 ? ScrollDirection.forward : ScrollDirection.reverse, ); assert(delta != 0.0); if (_innerPositions.isEmpty) { // 如果没有inner（body内部没有scrolling view），就由outer完全处理滑动事件 _outerPosition!.applyFullDragUpdate(delta); } else if (delta < 0.0) { // Dragging \\\"up\\\" // 先恢复inner overscroll，然后是outer view，以便header内容尽快scroll out double outerDelta = delta; for (final _NestedScrollPosition position in _innerPositions) { if (position.pixels < 0.0) { // This inner position is in overscroll. // 先从overscrolled恢复并返回剩余没有使用的delta // 因为delta是负值，如果“消耗”掉了一部分，那么potentialOuterDelta会比delta大 final double potentialOuterDelta = position.applyClampedDragUpdate(delta); // In case there are multiple positions in varying states of // overscroll, the first to 'reach' the outer view above takes // precedence.此处outerDelta为剩余没有消耗的delta outerDelta = math.max(outerDelta, potentialOuterDelta); } } if (outerDelta != 0.0) { // 如果还有剩下的，让outer view消耗 // delta < 0;所以如果outer有underscroll则会先恢复到0然后返回（现有限制下不会出现 // 此情况），否则最多可以向上滑动到maxScrollExtent final double innerDelta = _outerPosition!.applyClampedDragUpdate( outerDelta, ); if (innerDelta != 0.0) { // 还有剩下的，让inner开始滑动 // 这里吧剩下的innerDelta完全给了inner scroll position的applyFullDragUpdate方法 // inner会先向上滑动，如果physics支持underscroll会执行underscroll，否则最多滑动 // 到maxScrollExtent，然后发出overscroll的通知，让Scrollable绘制蓝色波纹（Android） for (final _NestedScrollPosition position in _innerPositions) position.applyFullDragUpdate(innerDelta); } } } else { // Dragging \\\"down\\\" - delta is positive double innerDelta = delta; // Apply delta to the outer header first if it is configured to float. if (_floatHeaderSlivers) // _floatHeaderSlivers为true，先让outer复现出来，最多向下滑动到minScrollExtent // 也就是恢复原位 innerDelta = _outerPosition!.applyClampedDragUpdate(delta); if (innerDelta != 0.0) { // Apply the innerDelta, if we have not floated in the outer scrollable, // any leftover delta after this will be passed on to the outer // scrollable by the outerDelta. double outerDelta = 0.0; // it will go positive if it changes final List<double> overscrolls = <double>[]; final List<_NestedScrollPosition> innerPositions = _innerPositions.toList(); // inner scrolling view先消耗delta for (final _NestedScrollPosition position in innerPositions) { // 向下滑动inner scrolling view // 如果inner physics不支持overscroll，则执行完innerDelta之后，最多会返回未执行的overscroll // 如果支持，则会消耗完innerDelta，这里的overscroll为0 final double overscroll = position.applyClampedDragUpdate(innerDelta); outerDelta = math.max(outerDelta, overscroll); overscrolls.add(overscroll);// 保存没有被使用的overscroll } if (outerDelta != 0.0) // 在此处，即使设置了outer的physics为BouncingScrollPhysics，因为当ScrollPosition的 // offset为0时，applyClampedDragUpdate不会主动从0变为负值，所以无法应用underscroll效果 // 此处outerDelta-=overscroll的结果是outerDelta是outer消耗的那一部分内容 outerDelta -= _outerPosition!.applyClampedDragUpdate(outerDelta); // 这里outerDelta是剩下的delta // Now deal with any overscroll 最后交给inner处理overscroll for (int i = 0; i < innerPositions.length; ++i) { // 此处的remainingDelta是未执行的overscroll减去了outer消耗的内容 final double remainingDelta = overscrolls[i] - outerDelta; if (remainingDelta > 0.0) // 如果还有剩下的overscroll，与physics等结合计算之后，继续消耗（之前在 // applyClampedDragUpdate无法消耗，在这里也消耗不了，不过可以发送overscroll // 的通知，让Scrollable知道之后做出蓝色波纹（Android机型）等效果） innerPositions[i].applyFullDragUpdate(remainingDelta); } } } } \",\"分析为何 inner 有 scrolling view 时，NestedScrollView.physics 为 BouncingScrollPhysics()不生效：\",\"从上述代码我们看到，可以产生 overscroll 效果的 applyFullDragUpdate 只有在 inner 中没有 scrolling view 的时候才会被_outerPosition 应用，其他两个场景都只有 inner position 应用。\",\"而其余场景中，_outerPosition 和 inner position 都应用的是 applyClampedDragUpdate 方法：\",\"向下滑动 delta 大于 0，代码会执行到outerDelta -= _outerPosition!.applyClampedDragUpdate(outerDelta)，因为此时限制了 applyClampedDragUpdate 中的 newPixels 范围为（当 ScrollPosition 的 pixels 等于 0 时）minScrollExtent~double.infinity，所以 clampedDelta = newPixels - pixels 等于 minScrollExtent（也就是 0），跳过剩余步骤直接返回了 delta。所以没有执行 BouncingScrollPhysics()逻辑\",\"向上滑动 delta 小于 0，代码会执行final double innerDelta = _outerPosition!.applyClampedDragUpdate(outerDelta,);，在此方法中，如果有 overscroll 则会先恢复到 0，否则最多上划到 maxScrollExtent，所以也不会执行 BouncingScrollPhysics()逻辑\",\"通过上述步骤，NestedScrollView 将 header 和 body 的滚动事件进行组合、分发。\",\"NestedScrollView 将 header 和 body 中可滑动 view（inner）的滑动事件组合起来：向上滑动时，先等达到 header 最大滑动范围之后，再将滑动分配给 inner 消耗；当向下滑动时，一般先恢复 inner 的 overscroll（如果_floatHeaderSlivers 为 true，会先尝试下滑 header），尝试将其恢复至 offset 为 0 的状态，再尝试将 header 向下滑动到初始位置，最后如果有 overscroll，会尝试应用到 inner 上面。\",\"CustomScrollView 也支持在同一个页面内嵌套多个滑动列表并关联（在其 slivers 中传入多个 SliverList,SliverGrid 等），但是 CustomScrollView 不支持普通的滑动 view，比如 ListView 等，这些滑动布局会内部消耗掉滑动事件，从而无法与 CustomScrollView 内其余 sliver 正常联动。\",\"NestedScrollView 内部通过 NestedScrollViewState.build()创建继承自 CustomScrollView 的_NestedScrollViewCustomScrollView。\",\"通过 NestedScrollView._buildSlivers()将 NestedScrollView.headerSliverBuilder 返回的 sliver 列表（下称 header）和被 SliverFillRemaining 包裹的 body 组合在一起，使得在_NestedScrollViewCustomScrollView 中创建的 viewport 的创建的_NestedScrollCoordinator.outerPosition 的_maxScrollExtent 为 NestedScrollView 的 header 的主轴尺寸，而_NestedScrollCoordinator._innerPositions 的_maxScrollExtent 则是与 body 实际内容一致。\",\"_NestedScrollViewCustomScrollView 的 ScrollController 是_NestedScrollCoordinator._outerController，其创建了_NestedScrollCoordinator.outerPosition，所以整个 NestedScrollView 的滑动事件都会通过_NestedScrollCoordinator._outerController 转到给_NestedScrollCoordinator.applyUserOffset 方法。\",\"在_NestedScrollCoordinator.applyUserOffset 方法中，根据滑动方向的不同，依次协调_NestedScrollCoordinator.outerPosition 和_NestedScrollCoordinator._innerPositions 处理用户 drag 等产生的 delta，修改这两个 ScrollPosition 的值，从而实现 header 和 body 的滑动联动。\",\"NestedScrollView_api.flutter.dev\"]},\"227\":{\"h\":\"Flutter滑动分析之Scrollview\",\"t\":[\"Flutter 中的 scrollable widget 根据实现方式的不同，可以分为两大类：\",\"基于 RenderBox 的 box protocol 实现的，主要基于 Size 实现布局。常见的有 SingleChildScrollView。\",\"基于 RenderSliver 的 sliver protocol 实现的，主要基于 SliverGeometry 实现布局。比如 CustomScrollView 及其子类 ListView、GridView 等继承自 ScrollView 的 Widget，以及基于 CustomScrollView 的 NestedScrollView、基于 Viewport 等的 PageView、TabBarView 等直接对 SliverFillViewport 等进行封装的 Widget。\",\"上述所有的 scrollable widget 其底层逻辑依然是对 Scrollable 的封装，其内部处理了 ScrollController、ScrollPosition（viewport 的 offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理 scrollable view 的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出 ScrollNotification）、RawGestureDetector（手势识别）等等一系列与 scroll 有关的逻辑，从而使得其他 scrollable view 能够比较方便的实现 scroll 效果。\",\"上回我们对 SingleChildScrollView 的实现做了简单分析（见《Flutter 滑动分析之 SingleChildScrollView》），本文将对另外一种遵循 sliver protocol 的 ScrollView 做一分析。\",\"官方对 ScrollView 的定义是：“A widget that scrolls”。\",\"其主要由三部分组成：\",\"一个ScrollWidget，监听用户手势，实现 scrolling 的交互设计\",\"一个viewport widget，根据传入的 shrinkwrap 值的 true/false 分别会是 ShrinkWrappingViewport 或者 Viewport。通过根据传入的 ViewportOffset 不同而值展示 slivers 的一部分内容来实现滑动的视觉设计效果。\",\"一个或多个slivers，可以被组合起来创建各种 scrolling effects（比如 list，grids，expanding header 等）的 widget，是真正显示在屏幕上的 widget。\",\"由于默认的 ScrollView 创建的 viewport 的 slivers 属性只接受能创建 RenderSliver 的 Widget，所以 ScrollView 的List<Widget> buildSlivers(BuildContext context)方法只能返回 SliverXXX 之类（比如 SliverList）可以创建 RenderSliver 的 Widget。\",\"ScrollView 是一个抽象类，它主要的作用是将上面提到的三部分组合起来，为（遵从 sliver protocol 的）scrollable widget 封装屏蔽掉滑动底层细节，提供像buildSlivers之类的方法方便子类能够快速实现一个 scrollable widget。\",\"abstract class ScrollView extends StatelessWidget{}\",\"ScrollView 继承自 StatelessWidget，他的主要逻辑在 build 方法中：\",\" Widget build(BuildContext context) { // 这里创建slivers final List<Widget> slivers = buildSlivers(context); final AxisDirection axisDirection = getDirection(context); // scrollController要么使用最近的PrimaryScrollController，要么使用自己的controller final ScrollController? scrollController = primary ? PrimaryScrollController.of(context) : controller; // 这里是主要创建Scrollable的地方 final Scrollable scrollable = Scrollable( dragStartBehavior: dragStartBehavior, axisDirection: axisDirection, controller: scrollController, physics: physics, scrollBehavior: scrollBehavior, semanticChildCount: semanticChildCount, restorationId: restorationId, viewportBuilder: (BuildContext context, ViewportOffset offset) { // 在这里创建viewport，使用我们创建好的slivers填充viewport // 并传入Scrollable.ScrollPosition作为这里的入参offset，在viewport中 // 会监听offset的变化来重新绘制slivers从而实现滑动效果 return buildViewport(context, offset, axisDirection, slivers); }, ); final Widget scrollableResult = primary && scrollController != null ? PrimaryScrollController.none(child: scrollable) : scrollable; // 这里是处理当scrollable view滑动时隐藏键盘的逻辑 if (keyboardDismissBehavior == ScrollViewKeyboardDismissBehavior.onDrag) { return NotificationListener<ScrollUpdateNotification>( child: scrollableResult, onNotification: (ScrollUpdateNotification notification) { final FocusScopeNode focusScope = FocusScope.of(context); if (notification.dragDetails != null && focusScope.hasFocus) { focusScope.unfocus(); } return false; }, ); } else { return scrollableResult; } } \",\"通过上述代码，我们可以验证之前的判断：ScrollView 本身是对 Scrollable、viewport、slivers 的封装。具体的处理滑动手势、更新 ScrollPosition、发送 ScrollNotification 等等都在 Scrollable 中处理了，ScrollView 的子类只需要按照要求提供 slivers（通过 buildSlivers 方法）和其他一些必须的信息即可。\",\"上面的代码中还分别调用了 buildViewport 和 buildSlivers 方法，接下来我们逐一分析一下他们的源码。\"]},\"228\":{\"h\":\"Widget buildViewport()\",\"t\":[\"buildViewport 方法顾名思义，是用来创建 viewport 的。在 ScrollView 中默认会按照 shrinkWrap 的不同创建两种 viewport，他的子类也可以根据需要重写此方法以返回自己的 viewport。\",\" Widget buildViewport( BuildContext context, ViewportOffset offset, AxisDirection axisDirection, List<Widget> slivers, ) { assert(() { switch (axisDirection) { case AxisDirection.up: case AxisDirection.down: // 如果是上述两种AxisDirection说明Axis是Axis.vertical的，那么就 // 需要判断是否此widget是否有Directionality可以用来判断文本布局方向 // 如果没法判断则抛出FlutterError，否则返回true return debugCheckHasDirectionality( context, why: 'to determine the cross-axis direction of the scroll view', hint: 'Vertical scroll views create Viewport widgets that try to determine their cross axis direction ' 'from the ambient Directionality.', ); // 如果getDirection()能得出下面两种AxisDirection说明Axis是 // Axis.horizontal的，并且已经得知文本方向，所以直接返回true case AxisDirection.left: case AxisDirection.right: return true; } }()); // 经过上述检查，到这里widget的文本方向（TextDirection）一定已经确定了 // 这里根据shrinkWrap的不同分别创建两种viewport if (shrinkWrap) { return ShrinkWrappingViewport( axisDirection: axisDirection, offset: offset, slivers: slivers, clipBehavior: clipBehavior, ); } return Viewport( axisDirection: axisDirection, offset: offset, slivers: slivers, cacheExtent: cacheExtent, center: center, anchor: anchor, clipBehavior: clipBehavior, ); } \",\"可以看到，在 buildViewport()方法中，显示在 debug 模式下检查确保 widget 已经确定了文本方向（TextDirection 是 rtl 还是 ltr）；然后根据 shrinkWrap 的不同分别创建 ShrinkWrappingViewport 或者 Viewport，他们会根据 offset 的变化展示不同部分的 slivers。\",\"ShrinkWrappingViewport 和 Viewport 都是继承自 MultiChildRenderObjectWidget 的 widget，主要逻辑是分别创建对应的 RenderObject：RenderShrinkWrappingViewport 和 RenderViewport，而这两者又都继承自 RenderViewportBase。\",\"class Viewport extends MultiChildRenderObjectWidget { @override RenderViewport createRenderObject(BuildContext context) { return RenderViewport(...); } @override void updateRenderObject(BuildContext context, RenderViewport renderObject) { renderObject...; } @override MultiChildRenderObjectElement createElement() => _ViewportElement(this); } \",\"class ShrinkWrappingViewport extends MultiChildRenderObjectWidget { @override RenderShrinkWrappingViewport createRenderObject(BuildContext context) { return RenderShrinkWrappingViewport(...); } @override void updateRenderObject(BuildContext context, RenderShrinkWrappingViewport renderObject) { renderObject...; } } \"]},\"229\":{\"h\":\"RenderViewportBase\",\"t\":[\"abstract class RenderViewportBase<ParentDataClass extends ContainerParentDataMixin<RenderSliver>> extends RenderBox with ContainerRenderObjectMixin<RenderSliver, ParentDataClass> implements RenderAbstractViewport {}\",\"RenderViewportBase 继承自 RenderBox，混入了 ContainerRenderObjectMixin<RenderSliver, ParentDataClass>类，本身不持有 children，但提供了在 RenderBox 中容纳 RenderSliver 的一些通用方法：\",\"自动添加监听_offset 的方法，在其变化时执行 markNeedsLayout()方法实现滑动效果\",\"提供按照_offset 的值 layout、paint 持有的 children 的方法\",\"通过 hitTestChildren 实现 children 的 hit test\"]},\"230\":{\"h\":\"校验 children 类型是否为 RenderSliver\",\"t\":[\"在 RenderViewportBase 混入的 ContainerRenderObjectMixin<RenderSliver, ParentDataClass>的 debugValidateChild()方法中会检验 child 的类型是否为指定的 ChildType（在 RenderViewportBase 中 ChildType 为 RenderSliver），如果不是则会抛出 FlutterError，这也是 ScrollView 默认 Viewport 只支持可以创建 RenderSliver 的 Widget 的原因。\",\"mixin ContainerRenderObjectMixin<ChildType extends RenderObject, ParentDataType extends ContainerParentDataMixin<ChildType>> on RenderObject { bool debugValidateChild(RenderObject child) { assert(() { if (child is! ChildType) {// 此处会校验child的类型 throw FlutterError.fromParts(<DiagnosticsNode>[ ... ]); } return true; }()); return true; } } \",\"可见 ContainerRenderObjectMixin 提供了检测 child 类型的方法，那么它是在什么时候被调用的呢？\",\"无论是 Viewport 还是 ShrinkWrappingViewport 都继承自 MultiChildRenderObjectWidget，其会创建 MultiChildRenderObjectElement。\",\"MultiChildRenderObjectElement.insertRenderObjectChild()添加 child 中的 RenderObject 时都会先检查一下 child 的类型：\",\"class MultiChildRenderObjectElement extends RenderObjectElement { @override void insertRenderObjectChild(RenderObject child, IndexedSlot<Element?> slot) { final ContainerRenderObjectMixin<RenderObject, ContainerParentDataMixin<RenderObject>> renderObject = this.renderObject; // 注意这里调用MultiChildRenderObjectElement持有的RenderObject的 // debugValidateChild方法校验child类型 assert(renderObject.debugValidateChild(child)); renderObject.insert(child, after: slot.value?.renderObject); assert(renderObject == this.renderObject); } } \",\"而因为不管是 RenderShrinkWrappingViewport 还是 RenderViewport 都是继承自 RenderViewportBase，也就会执行ContainerRenderObjectMixin<RenderSliver, ParentDataClass>.debugValidateChild(child)方法,校验 child 类型是否为 RenderSliver，所以会在其slivers中直接传入 box widget 则会报错“A RenderViewport expected a child of type RenderSliver but received a child of type RenderXXX.”\"]},\"231\":{\"h\":\"RenderViewport\",\"t\":[\"class RenderViewport extends RenderViewportBase<SliverPhysicalContainerParentData> {}\",\"RenderViewport 是 Flutter 滑动机制的主力，他通过监听offset的变化展示children的一部分来实现滑动的视觉效果,他会占据父级给的最大空间（大小由父级指定）。\",\"其内部持有一个双向的 slivers 列表children，以在 zero scroll offset 的center为锚点：\",\"slivers 列表中在 center 之前的 Slivers 按照列表反方向，沿着 axisDirection 的反方向展示。\",\"slivers 列表中在 center 之后的 Slivers 按照列表的方向，沿着 axisDirection 的方向展示。\",\"比如一个 axisDirection 为 AxisDirection.down，children 列表为[\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"center\\\", \\\"5\\\", \\\"6\\\", \\\"7\\\"]，center 为“center”，那么默认会展示[\\\"center\\\", \\\"5\\\", \\\"6\\\", \\\"7\\\"]，当手指向下滑动的时候，会依次展示出“3”、“2”、“1”，等完全下拉之后，展示内容为：[\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"center\\\", \\\"5\\\", \\\"6\\\", \\\"7\\\"]。\"]},\"232\":{\"h\":\"RenderShrinkWrappingViewport\",\"t\":[\"class RenderShrinkWrappingViewport extends RenderViewportBase<SliverLogicalContainerParentData>{}\",\"RenderShrinkWrappingViewport 通过监听offset的变化展示children的一部分来实现滑动的视觉效果,与 Viewport 不同的是，他会 shrinkWrap（收缩包装）自己以便在主轴上匹配 children 的 size（大小由 RenderShrinkWrappingViewport 根据 children 计算而来），比较耗费性能（特别是当 item 可能会通过折叠展开等方式改变尺寸时）。\"]},\"233\":{\"h\":\"List<Widget> buildSlivers()\",\"t\":[\"ScrollView 的 buildSlivers 方法是抽象方法，由子类根据需要实现，一般子类也只需要重写此方法即可。\",\" /// Build the list of widgets to place inside the viewport. /// /// Subclasses should override this method to build the slivers for the inside /// of the viewport. @protected List<Widget> buildSlivers(BuildContext context); \",\"CustomScrollView 就是继承自 ScrollView：\",\"class CustomScrollView extends ScrollView { /// Creates a [ScrollView] that creates custom scroll effects using slivers. /// /// See the [ScrollView] constructor for more details on these arguments. const CustomScrollView({ ... }) : super( ... ); /// The slivers to place inside the viewport. final List<Widget> slivers; @override List<Widget> buildSlivers(BuildContext context) => slivers; } \",\"可以看到 CustomScrollView 的实现比较简单，主要逻辑是将传入的参数slivers作为List<Widget> buildSlivers(BuildContext context)的返回值。这导致我们在使用 CustomScrollView 的时候，需要传入 SliverList、SliverAppBar 等这些继承自 SliverMultiBoxAdaptorWidget 能创建 RenderSliver 的 Widget，而不是普通的 box widget。\",\"ScrollView 的子类借助 SliverMultiBoxAdaptorWidget 及其子类可以实现对 item 的懒加载从而避免创建无法通过 viewport 可见的 children（这种类型的传参一般都需传入 SliverChildDelegate 的子类），从而优化性能。\",\"而根据 shrinkWrap 的不同，分别使用 Viewport 和 ShrinkWrappingViewport 创建 viewport，从而分别实现按照父级指定 size 或按照子级计算 size（比较耗性能）。\",\"ScrollView 是 Flutter 中基于 sliver protocol 的 scrollable widget 的父类，因为 viewport 的限制只接受创建 RenderSliver 的 widget 作为其直接子类。其子类则通过 SliverMultiBoxAdaptorWidget 及其子类实现加载 box widget。\",\"以下类都是基于 ScrollView 实现的 scrollable widget：\",\"CustomScrollView\",\"BoxScrollView\",\"ListView\",\"GridView\",\"ScrollView_api.flutter.dev\"]},\"234\":{\"h\":\"Flutter滑动分析之SingleChildScrollView\",\"t\":[\"Flutter中的scrollable widget根据实现方式的不同，可以分为两大类：\",\"基于RenderBox的box protocol实现的，主要基于Size实现布局。常见的有SingleChildScrollView。\",\"基于RenderSliver的sliver protocol实现的，主要基于SliverGeometry实现布局。比如CustomScrollView及其子类ListView、GridView等继承自ScrollView的Widget，以及基于CustomScrollView的NestedScrollView、基于Viewport等的PageView、TabBarView等直接对SliverFillViewport等进行封装的Widget。\",\"上述所有的scrollable widget其底层逻辑依然是对Scrollable的封装，其内部处理了ScrollController、ScrollPosition（viewport的offset）、ViewportBuilder（容纳滚动内容的容器）、ScrollPhysics（管理scrollable view的物理属性，比如是否可以滚动或弹性滚动等）、ScrollActivity（对外发出ScrollNotification）、RawGestureDetector（手势识别）等等一系列与scroll有关的逻辑，从而使得其他scrollable view能够比较方便的实现scroll效果。\",\"本文只对SingleChildScrollView的源码实现做一简单分析：它是如何实现滚动效果，有什么优势和限制。\",\"官方对其定义是：“A box in which a single widget can be scrolled”。明确表明，SingleChildScrollView是遵守box protocol的widget，在其内部也只能有一个box widget。\",\"下面是一个SingleChildScrollView的简单使用：\",\"SingleChildScrollView( child: Column( children: List.generate( 20, (index) => SizedBox( height: 50, child: Center(child: Text(\\\"item $index\\\")), )), ), ) \",\"在这个例子中，SingleChildScrollView中容纳了一个叫Column的child，如果Column的高度无法在屏幕中完全展示，就SingleChildScrollView就会保证用户可以上下滑动，从而展示对应的内容；否则如果能够完全显示，则内容无法滑动。\"]},\"235\":{\"h\":\"SingleChildScrollView\",\"t\":[\"class SingleChildScrollView extends StatelessWidget {}\",\"作为一个StatelessWidget，SingleChildScrollView的主要逻辑在他的build()方法中：\",\" Widget build(BuildContext context) { final AxisDirection axisDirection = _getDirection(context); Widget? contents = child; if (padding != null) contents = Padding(padding: padding!, child: contents); // 这里scrollController如果没有指定或者primary为true的话会使用上级最近的 // PrimaryScrollController final ScrollController? scrollController = primary ? PrimaryScrollController.of(context) : controller; // 正如我们之前所说，SingleChildScrollView实现其实也就是对Scrollable的 // 进一步封装，提供一些自己特有的内容，比如_SingleChildViewport Widget scrollable = Scrollable( dragStartBehavior: dragStartBehavior, axisDirection: axisDirection, controller: scrollController, physics: physics, restorationId: restorationId, viewportBuilder: (BuildContext context, ViewportOffset offset) { // 这里使用了自定义的Viewport来实现布局逻辑 return _SingleChildViewport( axisDirection: axisDirection, offset: offset,// offset就是Scrollable处理的ScrollPosition clipBehavior: clipBehavior, child: contents,// 就是我们传入的child ); }, ); // 这里处理了滑动时键盘隐藏的问题 if (keyboardDismissBehavior == ScrollViewKeyboardDismissBehavior.onDrag) { scrollable = NotificationListener<ScrollUpdateNotification>( child: scrollable, onNotification: (ScrollUpdateNotification notification) { final FocusScopeNode focusNode = FocusScope.of(context); if (notification.dragDetails != null && focusNode.hasFocus) { focusNode.unfocus(); } return false; }, ); } return primary && scrollController != null ? PrimaryScrollController.none(child: scrollable) : scrollable; } \",\"可以看到，正如之前所言，SingleChildScrollView是依赖于封装Scrollable实现滑动效果。我们注意到在Scrollable.viewportBuilder中传入的是_SingleChildViewport，这个类处理了Scrollable传入的ScrollPosition也即这里的ViewportOffset：\"]},\"236\":{\"h\":\"_SingleChildViewport\",\"t\":[\"_SingleChildViewport继承自SingleChildRenderObjectWidget，主要逻辑是创建和更新RenderObject——_RenderSingleChildViewport。\",\"class _SingleChildViewport extends SingleChildRenderObjectWidget { @override _RenderSingleChildViewport createRenderObject(BuildContext context) { return _RenderSingleChildViewport( axisDirection: axisDirection, offset: offset,// 此处的offset是来自于Scrollable的ScrollPosition clipBehavior: clipBehavior, ); } @override void updateRenderObject(BuildContext context, _RenderSingleChildViewport renderObject) { // Order dependency: The offset setter reads the axis direction. renderObject ..axisDirection = axisDirection ..offset = offset// 此处的offset是来自于Scrollable的ScrollPosition ..clipBehavior = clipBehavior; } } \",\"可见处理offset以便更新content实现滑动效果的主要逻辑在_RenderSingleChildViewport这个RenderObject中。\"]},\"237\":{\"h\":\"_RenderSingleChildViewport\",\"t\":[\"先看一下_RenderSingleChildViewport的继承关系：class _RenderSingleChildViewport extends RenderBox with RenderObjectWithChildMixin<RenderBox> implements RenderAbstractViewport{}\",\"由上述代码可知，_RenderSingleChildViewport：\",\"是RenderBox，也就是说其内部lay out遵守box protocol\",\"RenderObjectWithChildMixin<RenderBox>，RenderObjectWithChildMixin为RenderObject提供一套管理单个child的模式，它的泛型指定了child的类型只能是RenderBox，这也就是为什么我们之前说SingleChildScrollView的child只能是box widget。\",\"实现了RenderAbstractViewport接口，这个接口表示render object是内部比实际要大，提供了一些方法供ScrollPosition和其他viewport调用，来获取一些使此viewport在屏幕上可见的信息。\",\"在修改axisDirection、offset、cacheExtent等三个属性的时候会触发markNeedsLayout()方法重新进行lay out； 在修改clipBehavior属性的时候只会触发markNeedsPaint()和markNeedsSemanticsUpdate()方法。\",\"此外，在每次设置offset的时候，都会对齐添加监听，这样当Scrollable中由于用户手势或者通过ScrollController调用jumpTo/animateTo等方法修改了ScrollPosition的时候，都会使得Scrollab的viewport也就是我们这里的_RenderSingleChildViewport收到通知、从而进行对应处理：\",\" set offset(ViewportOffset value) { assert(value != null); if (value == _offset) return; if (attached) // 先移除已有的监听 _offset.removeListener(_hasScrolled); _offset = value; if (attached) // 再为新的offset添加监听 _offset.addListener(_hasScrolled); markNeedsLayout(); } void _hasScrolled() { markNeedsPaint(); markNeedsSemanticsUpdate(); } \",\"除了上述在修改offset的时候添加/移除监听，在attach/detach方法中也有对应操作：\",\" @override void attach(PipelineOwner owner) { super.attach(owner); _offset.addListener(_hasScrolled); } @override void detach() { _offset.removeListener(_hasScrolled); super.detach(); } \",\"从上面的分析我们也可以看出，除了设置修改axisDirection、offset、cacheExtent等属性的时候会触发layout外，其余时候只会触发重新paint。\"]},\"238\":{\"h\":\"layout\",\"t\":[\"一般来说Flutter Widget要展示在屏幕上需要经历build、layout、paint三步，在分析SingleChildScrollView如何根据offset的变化实现scroll效果之前，我们先看一下他是如何实现layout的。\",\" void performLayout() { final BoxConstraints constraints = this.constraints; if (child == null) { size = constraints.smallest;// 如果child为空，则按照父级的最小尺寸来 } else { // 如果有child，就不限制主轴方向的尺寸，让child进行layout（会得到最大的主轴尺寸） child!.layout(_getInnerConstraints(constraints), parentUsesSize: true); // 在父级约束范围内尽可能满足child的尺寸 size = constraints.constrain(child!.size); } // 使用_viewportExtent作为offset的viewport范围 offset.applyViewportDimension(_viewportExtent); // 更新viewport的内容content的大小范围 offset.applyContentDimensions(_minScrollExtent, _maxScrollExtent); } // 只有横轴方向的约束，没有主轴方向的约束 BoxConstraints _getInnerConstraints(BoxConstraints constraints) { switch (axis) { case Axis.horizontal: // 如果是水平布局，就只限制高度，不限制宽度 return constraints.heightConstraints(); case Axis.vertical: // 如果是垂直布局，就只限制宽度，不限制高度 return constraints.widthConstraints(); } } \",\"可以看到在SingleChildScrollView先让child在主轴方向尽可能自由布局，取得其最大值，然后自身在满足父级约束的情况下应用child的size：如果child.size在父级约束内就直接应用，负责采用父级的约束。\",\"这样最终的效果就是我们的SingleChildScrollView在child不超过父级约束的时候只占据child的内容，当child的内容大于父级约束时，SingleChildScrollView自身的尺寸是父级给定的最大尺寸，而child本身在主轴方向上的尺寸是大于SingleChildScrollView的尺寸。这样也为我们后续通过监听offset修改显示部分child的内容实现滑动效果提供了可能。\",\"这也告诉我们SingleChildScrollView的父级需要指定指定主轴方向约束，否则会出现异常。 比如在Column中直接使用SingleChildScrollView就会在内容过长的时候发生overflowed错误并且无法滑动SingleChildScrollView，这是因为SingleChildScrollView和child都按照最长的尺寸布局，并且这个尺寸超过了父级约束。 在SingleChildScrollView外层添加Expanded作为父级，相当于给他指定了一个约束（占据剩余空间），所以可以解决这个问题。\",\"之后，又根据_viewportExtent以及_minScrollExtent/_maxScrollExtent分别设置了viewport和content的范围，让我们看一下这三个值的来历：\",\" double get _viewportExtent { assert(hasSize); switch (axis) { case Axis.horizontal: return size.width; case Axis.vertical: return size.height; } } \",\"可以看到，_viewportExtent是取值主轴方向的size大小，也就是SingleChildScrollView的尺寸。\",\" double get _minScrollExtent { assert(hasSize); return 0.0; } double get _maxScrollExtent { assert(hasSize); if (child == null) return 0.0; switch (axis) { case Axis.horizontal: return math.max(0.0, child!.size.width - size.width); case Axis.vertical: return math.max(0.0, child!.size.height - size.height); } } \",\"_minScrollExtent默认返回0.0； _maxScrollExtent返回的是主轴方向上child减去SingleChildScrollView之后的尺寸和0.0之间的最大值，换言之，如果child比SingleChildScrollView尺寸大，_maxScrollExtent就是多出来的那一部分，也就是我们可以滑动的范围，否则为0.0，也就是SingleChildScrollView不可滑动。\"]},\"239\":{\"h\":\"paint\",\"t\":[\"到目前为止，我们的SingleChildScrollView顺利得到了尺寸，假设child尺寸大于SingleChildScrollView的最大尺寸，那么当用户滑动屏幕导致offset改变的时候，又是如何实现滑动效果的呢？\",\"先看一个属性：\",\" // offset.pixels表示child沿着与轴方向axis direction相反的方法offset的pixels // 比如axis direction是down的话，手指向上滑动屏幕此值增大，否则减小 Offset get _paintOffset => _paintOffsetForPosition(offset.pixels); // 根据position计算出child实际在SingleChildScrollView中的offset // 以child的左上角在SingleChildScrollView左上角为0.0，向上为负，向下为正 Offset _paintOffsetForPosition(double position) { assert(axisDirection != null); switch (axisDirection) { case AxisDirection.up: return Offset(0.0, position - child!.size.height + size.height); case AxisDirection.down: return Offset(0.0, -position); case AxisDirection.left: return Offset(position - child!.size.width + size.width, 0.0); case AxisDirection.right: return Offset(-position, 0.0); } } \",\"可以看出，_paintOffset是根据ScrollPosition计算出来的真正的child和SingleChildScrollView的偏移offset。\",\" @override void paint(PaintingContext context, Offset offset) { if (child != null) { final Offset paintOffset = _paintOffset; void paintContents(PaintingContext context, Offset offset) { // 可以看到这里，除了父级传入的offset外，还应用了ScrollPosition改变而变化的 // paintOffset。这样每次Scrollable修改ScrollPosition之后都会触发paint // 方法，使用新的paintOffset绘制child context.paintChild(child!, offset + paintOffset); } if (_shouldClipAtPaintOffset(paintOffset) && clipBehavior != Clip.none) { _clipRectLayer.layer = context.pushClipRect( needsCompositing, offset, Offset.zero & size, paintContents, clipBehavior: clipBehavior, oldLayer: _clipRectLayer.layer, ); } else { _clipRectLayer.layer = null; paintContents(context, offset); } } } \",\"到此为止，我们可以得出以下结论：\",\"_RenderSingleChildViewport接收传入的child，并监听传入的Offset，当其变化时执行markNeedPaint()； 其先让child在主轴方向尽可能大的进行layout，然后自身在父级约束条件下尽可能满足child size，这样当child比父级给的约束大时，child保持自身大小，而viewport的size则在父级给的最大尺寸内展示一部分child内容； 当Offset变化时，按照Offset.pixels计算出对应的paintOffset，重新绘制child，展示另外一部分child的内容，从而实现滑动效果。\"]},\"240\":{\"h\":\"hitTest\",\"t\":[\"_RenderSingleChildViewport将hitTest直接转发给了child：\",\" @override bool hitTestChildren(BoxHitTestResult result, { required Offset position }) { if (child != null) { return result.addWithPaintOffset( offset: _paintOffset, position: position, hitTest: (BoxHitTestResult result, Offset transformed) { assert(transformed == position + -_paintOffset); return child!.hitTest(result, position: transformed); }, ); } return false; } \",\"至此，SingleChildScrollView基于Scrollable、ScrollPosition和_RenderSingleChildView完成了支持内部单个box widget的滑动效果。\",\"相对于使用Sliver实现滑动效果的Widget来说，SingleChildScrollView使用简单，使用的是box protocol，适用于child通常是完全可见的，但是在某些特殊场景（比如竖屏变为横屏等）下可能显示不全的情况，SingleChildScrollView可以保证在父级无法完整显示child的时候使其支持滑动。 SingleChildScrollView使用起来也比较方便。\",\"但是，正如上面分析的，无论content是否可见，SingleChildScrollView都会将其layout/paint（也就是说会将所有内容全部加载），这样如果content超出viewport的部分比较多就会非常耗费性能。\",\"对于这种情况，就应该考虑使用ListView/GridView/CustomScrollView等基于sliver protocol的scrollable widget。在shrinkWrap属性为false的情况下，viewport会只创建屏幕可见部分 + viewport前后缓存区域的内容，在content滑出这部分区域时dispose，当其再次滑入时再recreate，从而保证性能。\"]},\"241\":{\"h\":\"为Column的children安全应用spacedAround，center等效果\",\"t\":[\"想要给Column的children设置spacedAround效果，又需要保证在父级空间不足时能够完整显示所有children的内容的话，就需要结合SingleChildScrollView（空间不足时可滑动）、LayoutBuilder（获取父级约束信息）、ConstrainedBox（设置Column约束）来实现：\",\"child: LayoutBuilder(// 获取父级约束信息 builder: (BuildContext context, BoxConstraints viewportConstraints) { return SingleChildScrollView(// 父级空间不足时可以滚动 child: ConstrainedBox( constraints: BoxConstraints( // 这里指定最小高度为父级高度，所以空间足够时Column可以按需分布children， // 空间不足时则将children一个个依次排列（互相之间space为0） minHeight: viewportConstraints.maxHeight, ), child: Column( mainAxisSize: MainAxisSize.min,// 默认主轴尺寸尽可能的小 mainAxisAlignment: MainAxisAlignment.spaceAround, children: <Widget>[ Container( // A fixed-height child. color: const Color(0xffeeee00), // Yellow height: 120.0, alignment: Alignment.center, child: const Text('Fixed Height Content'), ), Container( // Another fixed-height child. color: const Color(0xff008000), // Green height: 120.0, alignment: Alignment.center, child: const Text('Fixed Height Content'), ), ], ), ), ); }, ) \",\"这里使用ConstrainedBox确保了Column主轴方向最小尺寸是父级大小：\",\"当父级尺寸大于Column的children尺寸时，多出的空隙由Column按照MainAxisAlignment.spaceAround原则分配，由于SingleChildScrollView的child尺寸和父级一致，所需不会滑动；\",\"当父级尺寸小于Column的children尺寸时，Column的尺寸为children的尺寸之和（相互之间没有间隙），此时SingleChildScrollView的child尺寸大于父级尺寸，所以可以上下滑动，保证了Column的children可以完全显示。\"]},\"242\":{\"h\":\"为Column的children安全应用Expanded、Space等效果\",\"t\":[\"在一些场景下，需要用到Expanded、Space等填充Column剩余的空间以展示某些内容，比如一直位于屏幕下方的版权信息，但是当Column的children尺寸大于父级尺寸时，又会导致children内容无法完整显示，如果直接在Column上加一个SingleChildScrollView作为父级，又会因为SingleChildScrollView给child在主轴方向的尺寸无限制，而Expanded又要求占据所有剩余空间从而导致出错。\",\"此时可以在上面例子的基础上增加IntrinsicHeight/InstrinsicWidth来解决此问题：\",\"LayoutBuilder(// 获取父级约束信息 builder: (BuildContext context, BoxConstraints viewportConstraints) { return SingleChildScrollView(// 保证child超出父级限制时可以滑动 child: ConstrainedBox( constraints: BoxConstraints( // 这里指定最小高度为父级高度，所以空间足够时Column可以按需分布children， // 空间不足时则将children一个个依次排列（互相之间space为0） minHeight: viewportConstraints.maxHeight, ), child: IntrinsicHeight( // 当minHeight:viewportConstraints.maxHeight比Column想要的大时， // 那么Column采用viewportConstraints.maxHeight的值 // 否则Column按照自己的内容大小来 child: Column( children: <Widget>[ Container( // A fixed-height child. color: const Color(0xffeeee00), // Yellow height: 320.0, alignment: Alignment.center, child: const Text('Fixed Height Content'), ), Expanded( // A flexible child that will grow to fit the viewport but // still be at least as big as necessary to fit its contents. child: Container( color: const Color(0xffee0000), // Red height: 120.0, alignment: Alignment.center, child: const Text('Flexible Content'), ), ), ], ), ), ), ); }, ) \",\"在上面例子中，作为SingleChildScrollView子级的Column内部能够使用Expanded的关键在于InstrinsicHeight：它的定义是“一个将child调整为child固有高度的widget”，也就是说，当child可能有无限的高度时，与其无限拓展，它更希望将自己size定位一个更加合理的固有高度（Expanded、Spacer等非RenderObjectWidget本身没有高度，所以在这里不会被计算）。\",\"那么，当父级指定的最小约束minHeight大于InstrinsicHeight.child的最大固有高度时，child将按照父级的最小高度设置； 当父级指定的最大约束是double.infinity无限大时，InstrinsicHeight会强制其child的大小为固有高度。\",\"但是需要注意的是，IntrinsicHeight/InstrinsicWidth因为至少需要对child进行两次layout（一次获取intrinsic dimensions，一次真正的执行layout），所以会比较耗费性能。因此应当保证Column子级数量尽可能少，并且可以使用SizeBox给child指定大小以减轻计算intrinsic dimensions的压力。\",\"SingleChildScrollView作为遵守box protocol的scrollable widget，使用简单，适用于页面内容通常为全部可见，但特殊情况下可能无法完整显示因而需要支持滚动的情况。\",\"其child只支持可以生成RenderBox的Widget，会一次性创建所有child内容，在其内部使用ListView等时需要开启shrinkWrap从而导致其懒创建item失效，比较耗费性能。\",\"因此，如果是大量item、child内容超出viewport部分时，应当考虑使用基于Sliver的ListView/GridView/CustomScrollView等。\",\"SingleChildScrollView_api.flutter.dev\"]},\"243\":{\"h\":\"Hello World\",\"t\":[\"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\"]},\"244\":{\"h\":\"Quick Start\"},\"245\":{\"h\":\"Create a new post\",\"t\":[\"$ hexo new \\\"My New Post\\\" \",\"More info: Writing\"]},\"246\":{\"h\":\"Run server\",\"t\":[\"$ hexo server \",\"More info: Server\"]},\"247\":{\"h\":\"Generate static files\",\"t\":[\"$ hexo generate \",\"More info: Generating\"]},\"248\":{\"h\":\"Deploy to remote sites\",\"t\":[\"$ hexo deploy \",\"More info: Deployment\"]},\"249\":{\"h\":\"JVM内存分配\",\"t\":[\"本笔记基于《深入理解Java虚拟机：JVM高级特性与最佳实践》及部分在线博客整理。\",\"JVM：java virtual machine，一个java程序（进程）拥有一个jvm实例\",\"JVM区域总体分两类，heap区和非heap区:\",\"heap区：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。非heap区：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(Java虚拟机栈)、Local Method Statck(本地方 法栈)。\"]},\"250\":{\"h\":\"1.head\",\"t\":[\"堆，所有线程共享，存放所有对象实例、数组，GC主要场所，会OOM\",\"分类\",\"1.新生代\",\"eden 刚刚创建的对象优先\",\"s1 经历几次GC\",\"s2 经历几次GC\",\"2.老年代\",\"存活时间长的老年对象\",\"大对象，如数组，大String...\"]},\"251\":{\"h\":\"2.stack\",\"t\":[\"栈，线程私有，存放基本数据和对象的引用，LIFO，会OOM，StackOverflow\"]},\"252\":{\"h\":\"java virtual machine stack\",\"t\":[\"线程请求的栈深度大于JVM允许的深度会导致Stack Overflow 在编译期完成内存分配，如果虚拟机栈可以动态扩展，但是当拓展时无法申请到足够内存时会导致OutOfMemory\",\"stack frame\",\"stack frame：栈帧，每执行一个方法就会产生一个栈帧并压入栈中\",\"局部变量表\",\"基本数据类型\",\"对象引用\",\"returnAddress 类型,指向了一条字节码指令的位置\",\"操作数栈\",\"动态链接\",\"方法出口等\"]},\"253\":{\"h\":\"native method stack\",\"t\":[\"与java虚拟机栈作用类似，不过native method stack是为native方法服务。 jvm可以自由实现它，甚至在sun HotSpot VM中将他与虚拟机栈合并 会OOM，stackOverflow\"]},\"254\":{\"h\":\"3.method area\",\"t\":[\"方法区，线程共享，存放类信息，常量，静态变量，即时编译器编译后的代码，会OOM\",\"运行时常量池\",\"类加载后，编译器生成的各种字面量和符号引用会放到方法区的运行时常量池中，会OOMString.intern()，有该string对象则返回，无则创建并返回\",\"String.intern()方法的注意事项：\",\"JDK1.6及以下：将首次出现的对象实例复制到永久代，返回其引用\",\"JDK1.7及以上：只会记录下首次出现的实例的引用，返回其引用\",\"所以：\",\"String s2 = \\\"java\\\"; System.out.println(s2.intern() == s2); \",\"在JDK1.6及以下输出false，在JDK1.7及以上输出true\",\"此外，由于String类是final的，每次new String(\\\"str\\\")会产生两个对象：一个是字符串str本身，一个是值为str的字符串。\",\"以String s = \\\"Hello\\\";为例，解释几个概念：\",\"字面量 源码中表示具体的值，如Hello\",\"符号引用 用来指代某种值得符号，如s\",\"直接引用 可以定位到内存中的（类、对象、方法、变量）等的具体地址\"]},\"255\":{\"h\":\"4.program count\",\"t\":[\"程序计数器，线程私有，占用内存小，当做当前线程执行字节码的行号指示器。\",\"若执行java方法，计数器记录的是正在执行的虚拟机字节码指令的位置\",\"若执行的是native方法，则计数器为空undefined。\",\"此内存区域是唯一一个在java虚拟机规范字没有规定任何OOMError的区域\",\"以Sun HotSpot VM 为例\"]},\"256\":{\"h\":\"1.java堆溢出\",\"t\":[\"对象过多导致head内存溢出\",\"是内存泄漏memory leak，定位泄露对象\",\"是内存溢出memory overflow，检查虚拟机堆参数是否可以调大；去除非必须的生命周期长的对象\"]},\"257\":{\"h\":\"2.虚拟机栈和本地方法栈溢出\",\"t\":[\"单线程，Stack Overflow\",\"单线程下，栈帧过大或者虚拟机栈容量太小，当内存无法分配时都会导致Stack Overflow异常\",\"多线程，\",\"多线程时，每个线程栈分配的内存越大，越容易尝试内存溢出OOM\",\"原因：虚拟机最大内存一定的情况下，去掉共享的Head和MethodArea占的内存，剩下的内存/单个线程最大栈内存=最大线程数量，当单个线程最大栈内存增加时，可以产生的线程数就会越少\"]},\"258\":{\"h\":\"3.运行时常量池溢出\",\"t\":[\"运行时常量池属于方法区，当常量过多时会导致OOM，可以用String.intern()方法尝试\"]},\"259\":{\"h\":\"4.方法区溢出\",\"t\":[\"经常动态生成大量Class的应用，如Spring等框架，需要注意OOM\"]},\"260\":{\"h\":\"5.本地直接内存溢出\",\"t\":[\"原生方法直接操作物理内存时导致物理内存不够，产生OOM\",\"JVM中GC会根据不同情况采取以下一系列算法组合进行内存回收\"]},\"261\":{\"h\":\"回收算法\"},\"262\":{\"h\":\"1.复制算法\",\"t\":[\"原理：内存一分为二，只使用一半；GC时将存活对象复制到另一半内存，剩下的则清空\",\"优缺点：1.无STW，但不适合对象过多的情况；2.内存利用效率低\"]},\"263\":{\"h\":\"2.标记清除法\",\"t\":[\"原理：从GC Roots开始遍历，可达标记存活，不可达则未标记\",\"java中，GC Roots可以是以下几种：\",\"虚拟机栈（栈帧中的本地变量表）中引用的对象\",\"方法区中的类静态属性引用的对象\",\"方法区中常量引用的对象\",\"本地方法栈中JNI引用的对象\",\"优缺点：1.要StopTheWorld防止标记的时候新new的对象未被标记而出错；\",\"2.清除对象后内存不连续，会有一定的浪费\"]},\"264\":{\"h\":\"3.标记压缩法\",\"t\":[\"原理：类似【标记清除法】，但会对标记进行压缩，如a->b->c，会被压缩为a->c，具体试讲所有存活的对象都向一端移动，直接清理掉端边界外的内存\",\"优缺点：1.也要StopTheWorld\"]},\"265\":{\"h\":\"4.引用计数算法\",\"t\":[\"原理：引用+1，不引用-1，为0则删除，但是会有相互循环引用的问题，java未使用\",\"优缺点：相互循环使用： a = b b = a 除此之外再没有用到a，b的地方，但是由于a，b的引用不为0所以无法被回收，导致内存浪费\"]},\"266\":{\"h\":\"回收过程\",\"t\":[\"一个不可达对象在“死缓”到“执行死刑”前至少经历两个标记过程\",\"第一次标记，筛选：是否有必要执行finalize()方法，若是则放到F-Queue队列中【触发】该方法，但不保证执行完该方法。\",\"可以在finlize()方法中自救一次：在该方法中将自身this赋值给其他变量，这样在第二次标记时会被移出即将回收集合；但是由于finlize()方法只会被调用一次，所以只能自救一次。并不推荐该方法，该方法所有可以做的工作，可以用try...finally或者其他方法更好的实现\",\"第二次标记，若finalize()方法以及调用过，或者为重写该方法，则“没必要执行”，可以回收\"]},\"267\":{\"h\":\"对象引用\"},\"268\":{\"h\":\"强引用StrongReference\",\"t\":[\"People p = new People();哪怕抛出OOM也不会被GC回收的对象\"]},\"269\":{\"h\":\"软引用SoftReference\",\"t\":[\"SoftReference sf = new SoftReference(p);只要有足够内存就不会被GC回收，若内存不够则会被GC回收，常用作服务器缓存\"]},\"270\":{\"h\":\"弱引用WeakReference\",\"t\":[\"在下次GC回收之前都存在，用作android等内存紧张的设备中的缓存\"]},\"271\":{\"h\":\"虚引用PhantomReference\",\"t\":[\"无法影响其生存时间，也无法通过虚引用获取其实例，设置虚引用只是为了在对象被GC回收时获取系统通知\"]},\"272\":{\"h\":\"JVM类加载机制之ClassLoader\",\"t\":[\"本文为《一看你就懂，超详细java中的ClassLoader详解 - CSDN博客》阅读笔记\",\"JVM有三种类加载器：\",\"BootStrap ClassLoader 启动类加载器，加载核心类库，主要加载核心类库，%JRE_HOME%\\\\lib下的rt.jar、resources.jar、charsets.jar和class等。\",\"Extention ClassLoader 扩展类加载器，加载目录%JRE_HOME%\\\\lib\\\\ext目录下的jar包和class文件。\",\"App ClassLoader 应用程序加载器，加载当前应用的classpath的所有类。\",\"除以上三种外，还有用户自定义的类加载器。\",\"每个类由加载它的类加载器和类本身确定其唯一性。也就是说，类加载器不同，类肯定不同。\",\"在加载类时，通过**“双亲委托”机制，依次从1** -> 3向上查询，再从3->1依次返回结果：\",\"调用findLoadedClass(className) 查询是否已经加载该类\",\"调用父加载器的loadClass(className,false)，若父加载器为空，则调用BootStrap ClassLoader\",\"如果还是没有加载到该类，调用findClass(className)\",\"这样子保证了每个类都是先经过最顶端的类加载器BootStrap ClassLoader，如果没有加载到再依次经过Extention ClassLoader、App ClassLoader 加载，确保如String等关键类不会被自定义的ClassLoader加载而导致异常。\",\"protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先，检测是否已经加载 Class<?> c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { //父加载器不为空则调用父加载器的loadClass c = parent.loadClass(name, false); } else { //父加载器为空则调用Bootstrap Classloader c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //父加载器没有找到，则调用findclass c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //调用resolveClass() resolveClass(c); } return c; } } \",\"AppClassLoader和ExtClassLoader都继承自URLClassLoader\",\"AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader的父加载器为null，故而会调用BootStrap ClassLoader\",\"ClassLoader如果没有指定父加载器，则默认的父加载器为AppClassLoader，自定义ClassLoader也是如此。\",\"自定义ClassLoader一般步骤：\",\"继承自ClassLoader\",\"重写findClass()\",\"在findClass()方法中调用并返回defineClass()\",\"class MClasLoader:ClassLoader(){ override fun findClass(name: String?): Class<*> { var sysDir = System.getProperty(\\\"user.dir\\\") var classPath = \\\"$sysDir/src/main/res/$name.class\\\" var classFile = File(classPath) //【注意】这里一次只读取一个字节，否则会报错java.lang.ClassFormatError: // Extra bytes at the end of class file TestClass var bytes = ByteArray(1) var fileInputStream = FileInputStream(classFile) var len = -1 var byteBuffer = ByteOutputStream() while (true) { len = fileInputStream.read(bytes) if (len > 0) { byteBuffer.write(bytes) } else { break } } var byteArr = byteBuffer.toByteArray() return defineClass(name,byteArr,0,byteArr.size) } } fun main(args: Array<String>) { var clazz = MClasLoader().loadClass(\\\"TestClass\\\") var say = clazz.getDeclaredMethod(\\\"say\\\",String::class.java) say.invoke(clazz.newInstance(),\\\"hello world\\\") print(MClasLoader().parent) } \",\"而defineClass()则将一个字节数组转化为一个类的实例（Converts an array of bytes into an instance of class with an optional ProtectionDomain）\",\"每个线程都有一个ClassLoader：contextClassLoader，通过将其设置为自定义的ClassLoader可以在加载类的时候做一些特殊的事情。\",\" Thread.currentThread().contextClassLoader = MClasLoader() var clazz = Class.forName(\\\"TestClass\\\", true, Thread.currentThread().contextClassLoader) var say = clazz.getDeclaredMethod(\\\"say\\\",String::class.java) say.invoke(clazz.newInstance(),\\\"hello world\\\") println(Thread.currentThread().contextClassLoader ) println(Thread.currentThread().contextClassLoader.parent ) \",\"结果为：\",\"hello world MClasLoader@1d44bcfa sun.misc.Launcher$AppClassLoader@18b4aac2 \"]},\"273\":{\"h\":\"JVM类加载机制解析\",\"t\":[\"本文介绍了java虚拟机类加载机制。\",\"JVM类加载一共7步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的1,2,3步，在实际中有可能从其中间某一步开始。\",\"类加载机制一般分为三部分：加载Loading -> 连接Linking -> 初始化Initializing\",\"JVM Class Loader\",\"其中加载、验证、准备和初始化发生的顺序是确定的，但解析可以在初始化之后开始（java动态绑定）\",\"java绑定分为静态绑定和动态绑定：\",\"静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。\",\"动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。\",\"http://blog.csdn.net/ns_code/article/details/17881581\"]},\"274\":{\"h\":\"**I.Loading **\",\"t\":[\"加载，JVM将文件（class，jar，zip，网络等）中的二进制字节流保存到虚拟机方法区和堆中,并用该二进制表示形式创建类或者接口的过程。\",\"Loading is the process of finding the binary representation of a class or interface type with a particular name and creating a class or interface from that binary representation\",\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html (英文文档若无特殊说明都是引用官方文档，下同)\",\"用类全限定名获取类的二进制字节流\",\"将字节流中静态存储结构转化为方法区的运行时数据结构\",\"在堆中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口。\",\"（这句话存疑 ，有人说在堆中 ,也有人说在方法区 ,官方文档未相关描述\",\"2019/01/12 更新 Class对象没有明确规定实在JAVA堆中，对应HotSpot虚拟机来说，该对象在方法区中）\",\"类加载的地方是开发人员可控性最强的地方。除了可以使用系统的ClassLoader外还可以自定义ClassLoader（后文详述）。\",\"类加载根据加载的类不同分为两种：\",\"非数组类 使用系统/自定义的类加载器完成加载\",\"数组类 数组类不通过类加载器创建，而是通过JVM直接创建，但是数组类的元素类型要通过类加载器创建\",\"数组类的元素加载，根据数组元素的类型不同，分为两类：\",\"引用类 通过普通类加载器加载，并将数组用该类加载器标识\",\"非引用类 将数组与引导类加载器标识\",\"数组类的可见性与其元素类的可见性一致。\"]},\"275\":{\"h\":\"**II.Linking **\",\"t\":[\"连接，是将类或者接口组合到java虚拟机运行状态的过程，这样他就可以被运行。\",\"Linking is the process of taking a class or interface and combining(组合) it into the run-time state of the Java Virtual Machine so that it can be executed(运行)\",\"连接一般分为3部分：验证Verification 、准备Preparation 、解析Resolution 。\",\"Linking a class or interface involves(包括) verifying and preparing(验证和准备) that class or interface, its direct(直接) superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.\"]},\"276\":{\"h\":\"Verification\",\"t\":[\"验证，保证class文件中的字节流信息符合虚拟机的要求。\",\"Verification(§4.10) ensures that the binary representation(二进制格式) of a class or interface is structurally correct(结构正确) (§4.9). Verification may cause additional classes and interfaces to be loaded (§5.3) but need not cause them to be verified or prepared.\",\"验证内容包括：\",\"文件格式验证，验证字节流符合class文件格式规范；\",\"元数据验证\",\"字节码验证\",\"符号引用验证\"]},\"277\":{\"h\":\"**Preparation **\",\"t\":[\"准备，在方法区对类变量分配内存，初始化为默认值（“零值”）。\",\"比如：static int i = 5；在这一步只会进行到i = 0 ，而i = 5要在初始化那一步才进行；\",\"但是如果是final修饰的常量，则在此分配具体值。\",\"Preparation involves creating the static fields for a class or interface and initializing such fields to their default values (§2.3, §2.4). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (§5.5), not preparation.\",\"准备工作可能在创建之后的任何时候发生，但是必须在初始化之前完成。\"]},\"278\":{\"h\":\"Resolution\",\"t\":[\"解析，是在运行时常量池中动态确定符号引用的具体值的过程。\",\"每个栈帧frame都有一个当前方法到运行时常量池 的引用，用来支持方法代码(method code)的动态链接（dynamic linking）。\",\"method code：要被执行的方法以及通过符号引用的变量。\",\"Each frame (§2.6) contains a reference to the run-time constant pool (§2.5.5) for the type of the current method to support dynamic linking of the method code.\",\"动态链接将符号引用（symbolic references）转化为具体方法的调用（concrete method references）即直接引用，根据需要加载类来解析未定义的符号，将变量访问转化为运行时内存（runtime location）。\",\"This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.\",\"方法和变量的这种后期绑定,使得方法使用的其他类的更改不太可能破坏这个代码。\",\"直接引用可以直接定位到内存中某一段地址；符号引用则与JVM内存无管\",\"解析分为：\",\"类，接口解析\",\"字段解析\",\"类方法解析\",\"接口方法解析\"]},\"279\":{\"h\":\"III.Initialization\",\"t\":[\"初始化 ，Initialization of a class or interface consists of executing its class or interface initialization method（执行类，接口的构造方法clinit()）\",\"类或接口在被初始化之前，必须先被连接linked（ verified, prepared, and optionally（可选） resolved.）。\",\"初始化有且只有以下五种情况：\",\"new、读取/设置类（只有直接定义其的类才会，子类等不受影响）的静态变量（final修饰的常量除外）、执行静态方法\",\"java.lang.reflect反射调用类\",\"初始化时，如果父类未初始化，先触发父类的初始化（接口类除外）\",\"虚拟机等启动时执行主类的main()方法时，需要先初始化主类\",\"JDK1.7 动态支持时，如果java.lang.invoke.MethodHandle实例最后解析结果REF_get/put/invokeStatic的方法句柄对应的类未被初始化时，需要先初始化对应的类\",\"以上5种称为对一个类的主动引用，其余不会触发初始化，称为被动引用\",\"clinit() ,有类变量赋值，静态语句块会由编译器合并为clinit()方法,分为两种：\",\"类 父类的clinit()方法会先于子类执行\",\"接口 接口clinit()方法无需调用父类接口的clinit()方法；接口的实现类也无需执行接口的clinit()方法\",\"clinit() 是线程安全的，在同一个类加载器中，多个线程的中只会有一个线程执行一次clinit()，其余线程阻塞等待\",\"clinit()和init()不同如下：\",\"init是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法（是在new对象的时候初始化非静态变量）；\",\"而clinit是类构造器方法，也就是在jvm进行类加载—–验证—-解析—–初始化，中的初始化阶段jvm会调用clinit方法（是在JVM初始化类的时候初始化静态变量）。\",\"http://blog.csdn.net/u013309870/article/details/72975536\",\"如果类没有静态赋值、静态语句块等则不会有clinit()方法。\",\"clinit()先于init()执行。\",\"Java Virtual Machine Specification Chapter 5. Loading, Linking, and Initializing\",\"Chapter 2. The Structure of the Java Virtual Machine\",\"【深入Java虚拟机】之四：类加载机制\",\"JVM类加载机制详解（一）JVM类加载过程\",\"Jvm系列3—类的加载 - Gityuan博客 | 袁辉辉博客 \",\"类加载机制 - 深入理解 Java 虚拟机 - 极客学院Wiki \",\"深入理解Java类型信息(Class对象)与反射机制 - CSDN博客\",\"深入理解jvm--Java中init和clinit区别完全解析 - CSDN博客\"]},\"280\":{\"h\":\"Java笔记之HashMap保存数据\",\"t\":[\"Photo by **Pixabay **from Pexels\",\"HashMap使用由Node<K,V>（继承自Map.Entry<K,V>）组成的数组table保存数据。\",\"在table中保存数据时根据key的hashCode计算到一个随机保存位置（但都在table数组的大小范围内），当存储的数据总量超过加载系数loadFactor规定的阈值时则对table进行扩容。\",\"transient Node<K,V>[] table;//实际保存键值对的数组 transient Set<Map.Entry<K,V>> entrySet;//Holds cached entrySet().用来遍历HashMap transient int size;//本HashMap实际保存的键值对个数 transient int modCount;//HashMap修改的次数，每次修改HashMap都会叠加， //用来在遍历的过程中检查HashMap是否被改动过来，如果有则抛出异常ConcurrentModificationException int threshold;//是否扩容的阈值 final float loadFactor;//加载系数,默认0.75f \",\"loadFactor：默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下：\",\"如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；\",\"相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\",\"https://tech.meituan.com/2016/06/24/java-hashmap.html\",\"每个Node包含了以下信息：\",\"Node<K,V> implements Map.Entry<K,V>{ final int hash; final K key; V value; Node<K,V> next; } \",\"在执行hashMap.put(\\\"k\\\", \\\"v\\\");时，会先计算key的hash值\",\"static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); //这里原始hash值(32位)的高位和地位进行按位异或（不同为，相同为0）， //增加了随机性，避免因为hashCode计算得到的hash值（低位相同概率高） //计算索引时（见下文↓）一直取低位值而可能导致的索引一直的重复问题。 } \",\"使用HashMap保存数据时：\",\"使用hash(Object key)计算key的hash值\",\"通过hash值计算value应该保存的位置i\",\"i = (table.length - 1) & hash //由于table.length限定为2的n次方，所以上面的等式相当于给table.length取余数 //即i永远<=table.length \",\"在此时会判断是否需要扩容(只有table为空，或者当前存储的数据总数size大于阈值threshold时才会扩容resize())\",\"threshold = capacity * loadFactor 阈值 = 容量 * 负载系数（默认为0.75） \",\"接下来会插入数据\",\"指定位置为空（没有hash冲突），或已有key相同的值：则直接插入value\",\"已经存在值并且数量大于8：则将链表转化为红黑树（JDK1.8），否则以链表形式保存数据\",\"在移除数据时，如果红黑树数量小于6：则将红黑树转化为链表\",\"在JDK1.7中，数据以数组或链表形式保存，JDK1.8中则新增了红黑树。\",\"发生hash冲突时，JDK1.7采用采用头插法，可能会产生逆序和环形链表；JDK1.8采用尾插法，直接插入链表或红黑树尾部。\",\"具体JDK1.7与1.8对比查看这里\",\"使用HashMap获取数据时:\",\"计算key的hash值\",\"查找对应位置的node\",\"null：返回null\",\"node不为空且key一致：返回该node\",\"node不为空且key不一致：\",\"如果是链表：遍历链表查找是否存在与key一致的node\",\"如果是树：遍历树查找是否存在与key一致的node\",\"使用HashMap移除数据时:\",\"其大体过程与get(Object key)类似，遍历找到对应的node并删除。\",\"一个key对应的索引index是由这个key的hash()值对HashMap的数组长度length的余数：\",\"index = hash % length; \",\"又有**在Length为2n**时：\",\"hash % 2n = hash & ( 2n - 1)\",\"hash % 2n = hash - (hash / 2n) * 2n = hash - (hash>>n) * 2n = hash & ( 2n - 1)\",\"而HashMap的长度Length又只能是2n，所以：\",\"index = (length - 1) & hash; \",\"当table为空或者长度超过加载因子DEFAULT_LOAD_FACTOR规定的容量(默认容量为16，加载因子为0.75)时会自动扩容。\",\"当table[index]为空时，直接新建Node并保存到table[index]中。\",\"当table[index]不为空时：\",\"如果是同一个key则覆盖旧的值\",\"如果是不同的key则先尝试以链表保存数据\",\"如果是不同的key，并且链表长度超过MIN_TREEIFY_CAPACITY规定的长度（默认64），则将链表转化为红黑树(JDK1.8新增)\",\"在第一节我们可以看到，HashMap的很多变量都被标记为transient，这表示在Serializable序列化时不主动去序列化这些值，那这样岂不是没法反序列化这些数据了？\",\"其实在后面我们可以看到，HashMap在writeObject()方法中主动保存了部分数据（原因是默认的Serializable由于不同JVM实现对同一对象如String的HashCode不一定一致，会导致严重的问题——HashMap基于hash值保存数据）：\",\"private void writeObject(java.io.ObjectOutputStream s) throws IOException { int buckets = capacity();//容量 // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size);//保存size internalWriteEntries(s);//保存table数据 } /** * table不为空则返回table长度 * 否则threshold不为空则返回threshold * 否则返回默认的DEFAULT_INITIAL_CAPACITY */ final int capacity() { return (table != null) ? table.length : (threshold > 0) ? threshold : DEFAULT_INITIAL_CAPACITY; } \",\"并在readObject()恢复了这些值。\",\"位运算\",\"符号\",\"计算\",\"按位与\",\"&\",\"相同为1，不同为0\",\"按位或\",\"|\",\"有1则1\",\"按位异或\",\"^\",\"相同为0，不同位1\",\"按位取反\",\"~\",\"左移\",\"<<\",\"相当于乘以2n\",\"右移\",\">>\",\"相当于除以2n\",\"无符号右移\",\">>>\",\"HashCode计算扰动分析-关于hashMap的一些按位与计算的问题？ - 胖君的回答 - 知乎 \",\"一文读懂Java之HashMap索引位置计算\",\"hashMap在jdk1.7与jdk1.8中的原理及不同\",\"真实面试题之：Hashmap的结构，1.7和1.8有哪些区别\",\"Java 8系列之重新认识HashMap\",\"java.util.HashMap源码要点浅析\",\"Why HashMap.Entry is transient?\",\"Java中HashMap关键字transient的疑惑\"]},\"281\":{\"h\":\"Java笔记之匿名内部类和final\",\"t\":[\"先说结论：\",\"由于JAVA匿名内部类的实现并不是真正的闭包，而是在生成内部类的时候将局部变量的引用拷贝了一份到内部类中。如果不将这个外部类设置为final的话，外部类或者内部类修改这个局部变量后，另外一处使用的仍然是修改前的值，这样就会产生问题，而如果将其修改为final则保证了局部变量与内部类使用的值是一致的。\",\"不对，仍然是要求final的。\",\"只不过编译器判断该局部变量不会再被修改时（effectively final 事实上的final），可以省略。\",\"Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared final or be effectively final (§4.12.4), or a compile-time error occurs where the use is attempted.\",\"Any local variable used but not declared in an inner class must be definitely assigned (§16 (Definite Assignment)) before the body of the inner class, or a compile-time error occurs.\",\"https://docs.oracle.com/javase/specs/jls/se13/html/jls-8.html#jls-8.1.3\",\"因为全局变量是通过传入内部类的**外部类引用this$0**来引用的(而非直接复制全局变量的值)，这样内部类和外部类持有的是同一个全部变量，自然不会存在两处更新不同步的问题。\",\"public class Test { public static void main(String[] args) { OutClass outClass = new OutClass(); outClass.outMethod(); } } // 外部类 class OutClass { //全局变量 public AnObj anObj = new AnObj(5); public void outMethod() { //局部变量 final AnObj anObj1 = new AnObj(6); //匿名内部类 Inner o = new Inner() { public void doSth() { //内部类访问外部类的全部变量和局部变量 int value = anObj1.getI() + anObj.getI(); System.out.println(\\\"inner:\\\" + value); } }; o.doSth(); } } //下面这两个类无需关注 interface Inner { public void doSth(); } class AnObj { private int i; public AnObj(int i) { this.i = i; } public int getI() { return i; } } \",\"编译后如下：\",\"//OutClass.class class OutClass { public AnObj anObj = new AnObj(5); OutClass() { } public void outMethod() { //可以看到，在编译之后，将外部类的引用和局部变量作为内部类的参数传入到内部类中 new 1(this, new AnObj(6)).doSth(); } } \",\"再看看内部类OutClass$1\",\"//OutClass$1.class class OutClass$1 implements Inner { final /* synthetic */ OutClass this$0;//这个是外部类的引用 final /* synthetic */ AnObj val$anObj1;//这个引用指向局部变量引用指向的内存空间 OutClass$1(OutClass this$0, AnObj anObj) { this.this$0 = this$0; this.val$anObj1 = anObj; } public void doSth() { //在这里可以看出，内部类通过局部变量的备份引用访问的this.val$anObj1.getI()， //所以如果内部类所处的方法，修改了这个局部变量（假设将这个引用指向了另外一个AnObj对象）， //但这里的this.val$anObj1指向的仍然是旧的AnObj对象，从而出现了对“同一个局部变量”在内部类和内部类外部分别有不同值的问题，所以需要final来限制对局部变量的更改 System.out.println(\\\"inner:\\\" + (this.val$anObj1.getI() + this.this$0.anObj.getI())); //但是再看外部类的全局变量，在内部类中仍然是通过外部类的引用this.this$0来引用anObj的，所以无论何时，内部类中的外部类全局变量都是最新的，所做的更改也会实时更新到外部类中，所以不需要final } } \",\"https://www.runoob.com/w3cnote/inner-lambda-final.html\",\"Why are only final variables accessible in anonymous class?--stackoverflow\",\"java为什么匿名内部类的参数引用时final？ - 胖君的回答 - 知乎\"]},\"282\":{\"h\":\"Java笔记之计算Java对象的大小及其应用\",\"t\":[\"注意 除非特殊说明，以下所说的计算Java对象大小，不涉及该对象所持有的对象本身的大小，只计算该Java对象本身的大小（其中引用类型对象大小只计算为4 bytes），如果要遍历计算Java对象大小（包含其持有对象的大小）可以参考这篇文章 Sizeof for Java\",\"一个Java对象在内存中的大小包括以下(以64位JVM启用压缩为例，综合这里和这里的信息整理)：\",\"分类\",\"大小（byte）\",\"备注\",\"对象头\",\"8\",\"保存对象的 class 信息、ID、在虚拟机中的状态\",\"Oop指针\",\"4\",\"数据区\",\"对象实际包含的数据,引用类型大小为4 bytes\",\"数组长度\",\"4\",\"只有数组对象才有\",\"8比特对齐\",\"将对象总大小对齐到8字节所需的填充\",\"此外，如果是（非静态）内部类的话，由于他默认持有外部类的引用，所以会比普通类的对象多4个byte。\",\"https://stackoverflow.com/a/12193259/8389461\",\"可以参照这张图\",\"图片来自https://www.jianshu.com/p/9d729c9c94c4\",\"其中，数据区占用的大小如下：\",\"（图片来自于android-memories）\",\"Size of data from speakerdeck.com\",\"#示例\",\"根据Romain Guy在SpeakerDeck中的说法：\",\"一个空的class占用了4+8=12个byte的内存，再加上8比特对齐，实际占用大小为16比特。\",\"class Empty{ } \",\"占用大小：\",\"Allocation\",\"Size in bytes\",\"dlmalloc 引用\",\"4\",\"Object overhead（对象头）\",\"8\",\"Total = 4 + 8 =12 bytes\",\"经过8-byte aligned后： total = 16 bytes\",\"https://speakerdeck.com/romainguy/android-memories?slide=34\",\"此外还有包含了数据的对象大小计算方式如下：\",\"图片来自https://speakerdeck.com/romainguy/android-memories?slide=42\",\"对于数组的大小计算（参考一个Java对象到底占用多大内存？和romainguy/android-memories，后者关于数组大小的计算中width&padding = 8 的意义存疑）:\",\"按照开头的公式：数组大小 = 8 对象头 + 4 Oop指针 + 4 数组大小标记length + 数组数据占用大小 + 8比特对齐 \",\"// arr0大小 = 8 + 4 + 4 + 0 + 8比特对齐(0) = 16 bytes int arr0 = new int[0]; // arr1大小 = 8 + 4 + 4 + 4*1 + 8比特对齐(4) = 16 + 4 = 20 + 8比特对齐(4) = 24 bytes int arr1 = new int[1]; // arr1大小 = 8 + 4 + 4 + 4*10 + 8比特对齐(0) = 16 + 40 = 56 + 8比特对齐(0) = 56 bytes int arra10 = new int[10]; \",\"具体的如何计算Java中Object大小，可以参考stackoverflow的这个回答（这里有一份Github上面的实现源码）\",\"可以参考文章：\",\"聊聊JVM（三）两种计算Java对象大小的方法\",\"准确计算Java中对象的大小\",\"一个Java对象到底占用多大内存？\",\"这里提供一个实例（参考自这里）：\",\"Sizeof.java\",\"import java.lang.instrument.Instrumentation; final public class Sizeof { private static Instrumentation instrumentation; public static void premain(String args, Instrumentation inst) { instrumentation = inst; } public static long sizeof(Object o) { return instrumentation.getObjectSize(o); } } \",\"Makefile\",\"//Makefile文件 .POSIX: .PHONY: all clean all: javac *.java jar -cfm Sizeof.jar META-INF/MANIFEST.MF Sizeof.class java -ea -javaagent:Sizeof.jar Main clean: rm -f *.class *.jar \",\"在使用时先新建一个Java类，在其中调用sizeof()方法：\",\"public class Main { public static void main(String[] args) { System.out.println(Sizeof.sizeof(new int[0])); } } \",\"可以用如下命令：\",\" javac *.java //编译当前目录下的java文件 jar -cfm Sizeof.jar META-INF/MANIFEST.MF Sizeof.class //将Sizeof.class打包为Sizeof.jar java -ea -javaagent:Sizeof.jar Main //输出sizeOf计算结果 \"]},\"283\":{\"h\":\"String 最长为65534\",\"t\":[\"String s = “”;中，在编译期最多可以有65534个字符\",\"原因是，Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示，常量池中的所有字面量几乎都是通过CONSTANT_Utf8_info描述的。\",\"这里面的u2 length表明了该类型存储数据的长度，而u2是无符号的16位整数，因此理论上允许的的最大长度是2^16=65536。而 Java class 文件是使用一种变体UTF-8格式来存放字符的，null 值使用两个字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。\",\"CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes[length]; } \",\"所以，在Java中，所有需要保存在常量池中的数据，长度最大不能超过65535，这当然也包括字符串的定义\",\"上面提到的这种String长度的限制是编译期的限制，也就是使用String s= “”;这种字面值方式定义的时候才会有的限制。\",\"String在运行期有没有限制呢，答案是有的，就是我们前文提到的那个Integer.MAX_VALUE ，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）\",\"https://blog.csdn.net/u013380694/article/details/102739636\",\"一个String对象,占用大小（JDK1.8）为24 bytes（不计算持有的char数组占用的大小）：\",\"/** The value is used for character storage. */ private final char value[]; //一个数组对象的引用，占用4 bytes /** Cache the hash code for the string */ private int hash; // Default to 0 //一个int类型，占用4 bytes \",\"再加上在64位JVM中，一个对象具有12 bytes的对象头+引用，要求对齐到8的倍数(来源2.1. Objects, References and Wrapper Classes)，所以一个String对象的大小是：\",\"size = ( 12 对象头 + 4 value + 4 hash ) + 4 8byte对齐 = 24 bytes \"]},\"284\":{\"h\":\"枚举类enum\"},\"285\":{\"h\":\"枚举类大小的计算\",\"t\":[\"枚举类中的每个枚举都是该枚举类的一个对象。\",\"enum EnumClazz{ Day,Hour,Minute,Second } \",\"当我们用javap查看其编译后的字节码可以看到：\",\"//javac EnumClazz.java //javap EnumClazz.class final class EnumClazz extends java.lang.Enum<EnumClazz> { public static final EnumClazz Day; public static final EnumClazz Hour; public static final EnumClazz Minute; public static final EnumClazz Second; public static EnumClazz[] values(); public static EnumClazz valueOf(java.lang.String); static {}; } \",\"简单计算一下这个EnumClazz的大小（不含引用对象的大小）：\",\"enumClassSize = 8 + 4 + 4*4 + 4 = 32 bytes 对象头 + 引用 + 枚举类值的引用类型 * 4个 + 4 数组引用类型 \",\"然后，我们再看一下每个枚举类的值（以EnumClazz.Day为例）的大小：\",\"enum类的每个值实际上都继承自java.lang.Enum类：\",\"public abstract class Enum<E extends Enum<E>> implements Comparable<E>, Serializable { //枚举值名称 private final String name; //枚举值次序，从0开始 private final int ordinal; } \",\"由此，我们可以计算EnumClazz.Day的大小：\",\"daySize = 8 + 4 + 4 + 4 + 8比特对齐(4) = 20 + 4 = 24 bytes 对象头 + Oop引用 + name + ordinal + 8比特对齐 \",\"也就是说，本例中每一个枚举类值占用24 bytes，由此可以计算出EnumClazz实际占用的大小应该是：\",\"realSize = enumClassSize + daySize * 4 = 128 bytes \"]},\"286\":{\"h\":\"Android中是否应该使用枚举\",\"t\":[\"关于Android中使用枚举和常量所占用的大小对比RomainGuy有下图的对比。\",\"https://speakerdeck.com/romainguy/android-memories?slide=67\",\"关于是否应该在Android中使用枚举类，可以参考下文：\",\"https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/\",\"https://stackoverflow.com/a/29972028/8389461\",\"总结起来其结论就是：\",\"当需要用到枚举类的特性时，比如非连续判断，方法重载等时就使用枚举，否则就使用占用内存更小的常量类。\"]},\"287\":{\"h\":\"SparseArray&ArrayMap VS HashMap\",\"t\":[\"HashMap的数据是经过包装后保存在HashMap.Node<K,V>数组中。\",\"下面是HashMap的结构：\",\"public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable { transient Node<K,V>[] table; //4+ bytes，保存HashMap的键值对等信息 transient Set<Map.Entry<K,V>> entrySet; //4+ bytes transient int size; //4 bytes transient int modCount; //4 bytes int threshold; //4 bytes final float loadFactor; //4 bytes //继承自AbstractMap transient Set<K> keySet; //4+ bytes transient Collection<V> values; //4+ bytes } \",\"再看看Android提供的android.util.SparseArray类(具体分析可参考：SparseArray 的使用及实现原理)\",\"public class SparseArray<E> implements Cloneable { private boolean mGarbage = false; //4 bytes private int[] mKeys; //4+ bytes private Object[] mValues; //4+ bytes private int mSize; //4 bytes } \",\"再结合官方的描述，SparseArray类很明显要比HashMap占用更少的内存：\",\"将KEY和VALUE直接保存在数组中，避免了将其包装为一个Node对象的开销\",\"由于SparseArray类的key是int类型而非被自动装箱后的Integer对象，所以当同样使用int类型的key保存数据时，SparseArray类的key要占用更少的内存。\",\"SparseArray is intended to be more memory-efficient than a HashMap, because it avoids auto-boxing keys and its data structure doesn't rely on an extra entry object for each mapping.\",\"https://developer.android.google.cn/reference/android/util/SparseArray\",\"但是，SparseArray有以下局限性：\",\"在每次put/get/remove的时候都需要使用二分法(ContainerHelpers.binarySearch(mKeys, mSize, key))查找是否已经存在KEY对应的值（有的话查找其位置）\",\"在添加和删除item的时候都需要在数组中增删条目（耗时，尽管为了优化性能，SparseArray在删除时只是将对于的值标记为DELETED，在下次更新该KEY对于的值时直接覆盖，或者在GC时删除）。\",\" private static final Object DELETED = new Object();\",\"HashMap的删除涉及到数组、链表和红黑树（JDK1.8）\",\"在容纳数百个项目时性能会比HashMap小大约50%。\",\"每当需要增长数组或获取数组大小或获取条目值时，都必须执行垃圾回收GC。\",\"此外，还有以下可以替换HashMap的(数据来自这里)：\",\"SparseArray <Integer, Object> SparseBooleanArray <Integer, Boolean> SparseIntArray <Integer, Integer> SparseLongArray <Integer, Long> LongSparseArray <Long, Object> LongSparseLongArray <Long, Long> //this is not a public class //but can be copied from Android source code \",\"此外，还有android.util.ArrayMap其特性与SparseArray类似（两者占用内存小，但是慢并且最好不要用来存储大容量的数据），只不过它支持key值为其他类型，占用内存大小在SparseArray和HashMap之间(参考这里)，此外ArrayMap的API和HashMap类似。\",\"根据Romain Guy的计算：\",\"保存1000个int对象的SparseArray 占用大小为：8072 bytes\",\"保存1000个对象的HashMap<Integer,Integer> 占用大小为：64136 bytes\",\"几乎相差8倍！\",\"综上，当要保存的数据量比较小（小于几千个）的时候，如果KEY是基本类型，推荐使用SparseArray及其衍生类以节省内存，如果KEY是其他类型则使用ArrayMap;否则使用HashMap更加高效。\",\"除文章中罗列的链接外：\",\"https://blog.csdn.net/u013380694/article/details/102739636\",\"Sizeof for Java -- javaworld.com\",\"RomainGuy-Android Memories（推荐）\",\"SparseArray vs HashMap\",\"Android内存优化（使用SparseArray和ArrayMap代替HashMap）\",\"SparseArray 的使用及实现原理\",\"SparseArray -- developer.android.google.cn\"]},\"288\":{\"h\":\"Java笔记之ThreadLocal\",\"t\":[\"ThreadLocal是Thread中用来保存线程私有变量的数据结构。\",\"一个ThreadLocal只能保存一个值，有set/get/remove方法。\",\"在Thread有一个threadLocals（ThreadLocal.ThreadLocalMap）变量，该变量是一个定制的Hash Map，用来保存线程私有的数据（类型为ThreadLocal<?> Key, Object Value）。\",\"一个Thread可以有多个ThreadLocal变量\",\"不同Thread可以通过一个ThreadLocal变量分别保存不同的变量而互不影响。\",\"如果不同的Thread使用的ThreadLocal变量保存的是同一个引用类型的对象（假设为obj），无论这些Thread使用的是同一个ThreadLocal对象还是完全不同的ThreadLocal对象，只要obj指向的对象改变，其余线程中的ThreadLocal对象也会访问到obj的最新值。\",\"当我们新建一个ThreadLocal并为之赋值时\",\"// 方式1. ThreadLocal threadLocal = new ThreadLocal(); threadLocal.set(\\\"value\\\"); //方式2. ThreadLocal threadLocal2 = new ThreadLocal(){ @Override protected Object initialValue() { return \\\"initial value\\\"; } }; \",\"这个时候就会调用set()方法（方式1）或者setInitialValue()方法（方式2）。\",\" public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t);//注意这里获取到是线程本身的threadLocals对象 if (map != null) map.set(this, value);//ThreadLocal对象只是在Thread所属的threadLocals中充当一个key， //所以即使在其他线程执行threadLocal.set(value); //也只是更新该线程本身的threadLocal对应的value，而不会影响其他线程分毫！！！（好精巧的设计） else createMap(t, value); } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } \",\"可以看到这两个方法到最后都相当于调用了Thread对象的threadLocals的set(ThreadLocal<?> key, Object value)方法，这个方法最终以ThreadLocal对象为KEY，将数据保存到了Thread对象自己的threadLocals中。\",\"private Entry[] table; private void set(ThreadLocal<?> key, Object value) { Entry[] tab = table; //其他逻辑... tab[i] = new Entry(key, value); } \",\"所以即使是同一个ThreadLocal对象，在不同的线程中进行set/get/remove都只是更新了本线程中ThreadLocal对象对应的值。\",\" //MainThread final ThreadLocal threadLocal = new ThreadLocal(); threadLocal.set(\\\"THREAD-Main-\\\"+Thread.currentThread().getName()); System.out.println(\\\"THREAD-Main-BEFORE：\\\"+threadLocal.get());//THREAD-Main-BEFORE：THREAD-Main-main new Thread(new Runnable() { public void run() { threadLocal.set(\\\"THREAD-1-\\\"+Thread.currentThread().getName()); System.out.println(\\\"THREAD-1：\\\"+threadLocal.get());//THREAD-1：THREAD-1-Thread-0 } }).start(); new Thread(new Runnable() { public void run() { System.out.println(\\\"THREAD-2：\\\"+threadLocal.get());//THREAD-2：null //本线程中threadLocal没有赋值，所以为null } }).start(); //MainThread System.out.println(\\\"THREAD-Main-AFTER：\\\"+threadLocal.get());//THREAD-Main-AFTER：THREAD-Main-main //其他线程对threadLocal对象的操作不会影响本线程 //但是如果threadLocal保存的是一个引用类型的对象，并且这个对象在其他线程被更改，那么本线程获取到的也会是变更后的值 } \",\"在ThreadLocal.ThreadLocalMap中，最终用来保存ThreadLocal以及对应值的是一个Entry数组：\",\"static class Entry extends WeakReference<ThreadLocal<?>> { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal<?> k, Object v) { super(k);//对ThreadLocal对象的弱引用 value = v; } } \",\"从上面的代码可以看到，Entry对ThreadLocal是弱引用，按照“强软弱虚”引用的等级来划分，每次GC的时候，如果这个ThreadLocal对象没有被引用，就会被回收掉，这时如果该Thread还在运行，那么threadLocals中保存的ThreadLocal<?> k已经被回收了，但是Object v对象仍然保存在threadLocals中但是没有办法再访问到，造成内存泄漏。\",\"解决方法参考：\",\"使用ThreadLocal时会发生内存泄漏的前提条件：\",\"①ThreadLocal引用被设置为null，且后面没有set，get,remove操作。\",\"②线程一直运行，不停止。（线程池）\",\"③触发了垃圾回收。（Minor GC或Full GC）\",\"我们看到ThreadLocal出现内存泄漏条件还是很苛刻的，所以我们只要破坏其中一个条件就可以避免内存泄漏，单但为了更好的避免这种情况的发生我们使用ThreadLocal时遵守以下两个小原则:\",\"①ThreadLocal申明为private static final。 Private与final 尽可能不让他人修改变更引用， Static 表示为类属性，只有在程序结束才会被回收。\",\"②ThreadLocal使用后务必调用remove方法。 最简单有效的方法是使用后将其移除。\",\"版权声明：本文为CSDN博主「pony-zi」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/zzg1229059735/article/details/82715741\",\"现在我们知道了，所谓的通过ThreadLocal实现线程本地变量与其他线程隔离，是在创建ThreadLocal的时候，保存的就是属于当前线程的独立的变量，并且之后的修改也不会（无法）修改到其他线程中对应的值，但如果ThreadLocal本身保存的都是同一个对象，则这个对象在所有的线程中还是共享的。\",\"Android线程管理之ThreadLocal理解及应用场景\",\"ThreadLocal深入分析（Jdk 1.8）\"]},\"289\":{\"h\":\"Java中三种常用的排序方法\",\"t\":[\"今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。 以下示例皆为从小到大的排序\",\"每一次比较都可能要交换元素。 冒泡排序的思想是： 每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。 在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。 依次类推，总共遍历n-1轮，即可完成排序。 具体代码如下：\",\" void bubble(int[] arr){ int temp; for (int i = 0; i < arr.length - 1; i++) { for (int j = 0; j < arr.length - i - 1; j++) { if (arr[j] > arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } System.out.println(\\\"\\\\n--bubble :\\\"); for (int i = 0; i < arr.length; i++) { System.out.print(arr[i] + \\\" \\\"); } } \",\"每次比较的时候不交换 选择排序的思想： 每次比较的时候找到的两个数中的较大值并记下其位置，等到当前一轮的遍历完成之后，将最后一个未排序元素与这一轮遍历找到的最大值交换 最多交换n-1次 代码如下：\",\" void select(int[] arr){ for (int i = 0; i < arr.length; i++) { int maxIndex = 0; int temp = 0; for (int j = 1; j < arr.length - i; j++) { if (arr[maxIndex] < arr[j]) { maxIndex = j; } } temp = arr[maxIndex]; arr[maxIndex] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp; } System.out.println(\\\"\\\\n--select :\\\"); for (int i = 0; i < arr.length; i++) { System.out.print(arr[i] + \\\" \\\"); } } \",\"插入排序法思想： 将待排序的元素分为有序和无序两种，刚开始排序的时候假设只有第一个元素是有序的，其余n-1个元素都是无序的； 排序开始的时，将无序部分的一个元素（a）与有序部分的最后一个元素（b）进行比较，如果a<b，则将a与b交换，再将a与下一个有序元素进行比较；否则，将a加到b后面，作为有序部分的最后一个元素。 接着再从无序部分取出一个元素与有序部分的元素依次比较，直达所有元素都为有序元素。 遍历n-1次 代码如下：\",\" void insertSort(int[] arr){ for (int i = 1; i < arr.length; i++) { int instertValue = arr[i]; for (int j = i - 1; j >= 0; j--) { if (instertValue < arr[j]) { arr[j+1] = arr[j]; arr[j] = instertValue; }else { break; } } } /* 第二种表示形式 for (int i = 1; i < arr.length; i++) { int instertVal = arr[i]; int index = i - 1; while (index >= 0 && instertVal < arr[index]) { arr[index + 1] = arr[index]; index--; } arr[index + 1] = instertVal; } */ System.out.println(\\\"\\\\n--insertSort :\\\"); for (int i = 0; i < arr.length; i++) { System.out.print(arr[i] + \\\" \\\"); } } \"]},\"290\":{\"h\":\"Java中的泛型\",\"t\":[\"Java中的泛型实现了参数类型化的概念。\",\"主要有以下形式：\",\"class OneClazz<T>{ T t; <Y> void fun(){} } \",\"本文主要记录Java泛型一些比较特殊的知识点。\",\"泛型在Java SE5被引入，可以在类和方法中，将类型作为类型参数传入。\",\"泛型类型参数会在实际运行时被擦除到他的第一个边界。如<T>会被擦除为Objet，而<T extends ClazzA>则会被擦除为ClazzA。\"]},\"291\":{\"h\":\"不能有泛型数组\",\"t\":[\"这是因为Java中Object[]默认为所有数组的父类，如下代码虽然在编译期不会报错，但是在运行时会被检查出objArr指向的数组实际类型（String）和要赋予的类型（Integer）不一致而报错。\",\"也就是说，数组只能存放定义的实际类型以及他们的子类型。\",\"Object[] objArr = new String[10]; objArr[0] = 1; \",\"但是，如果支持泛型数组：由于泛型类型参数会在运行时被擦除，导致即使到了运行时也无法发现这个错误，从而会导致错误。\",\"如下，加入支持泛型参数，则objArr1中实际保存的类型（Map<String,Integer>），在编译的时候由于objArr1和objArr2都是Object类型的数组，编译通过；在运行的时候，由于Map中的泛型参数类型已经被擦除，也无法区分objArr1和objArr2中实际指向的两个Map<K,V>数组，也是合法的，这样原本定义的是Map<String,Integer>数组，却可以保存任何类似的Map，而这本来是不允许的。\",\"Object[] objArr1 = new Map<String,Integer>[10]; Object[] objArr2 = new Map<Double,Integer>[10]; objArr1[0] = objArr2[0]; \",\"Collections 类通过一种别扭的方法绕过了这个问题，在 Collections 类编译时会产生类型未检查转换的警告。\",\"ArrayList具体实现的构造函数如下：\",\"class ArrayList<V>{ private V[] backingArray; public ArrayList(){ backingArray = (V[])new Object()[DEFAULT_SIZE]; } } \",\"为何这些代码在访问 backingArray时没有产生 ArrayStoreException呢？无论如何，都不能将 Object数组赋给 String数组。因为泛型是通过擦除实现的，backingArray的类型实际上就是 Object[]，因为 Object代替了 V。\",\"这意味着：实际上这个类期望 backingArray是一个 Object数组，但是编译器要进行额外的类型检查，以确保它包含 V类型的对象。\",\"来源：https://www.ibm.com/developerworks/cn/java/j-jtp01255.html\",\"由于泛型的类型在运行时会被擦除，所以将类型检查放到了编译期。\",\"List<Clazz> 泛型列表只能保存指定泛型类型T的数据，而不能保存其子类。\",\"class Fruit{} class Apple extends Fruit{} class Jonathan extends Apple{} //编译时报错，类型不兼容 List<Fruit> fruits = new ArrayList<Apple>(); \",\"但是能保存Fruit的容器应该也要能安全的保存Apple，为了实现这一点，类似于数组中Object[] arr = Apple[]的向上转型，可以使用?引入协变。\"]},\"292\":{\"h\":\"协变\",\"t\":[\"List<? extends T> 可以合法的指向一个List< SubT>，这个过程会完成自动向上转型，成为可以持有某个诸如T或者T的子类的List，但是编译器不知道这个类具体是什么，所以拒绝向其中传递任何类型对象，即使Object也不行。\",\"可以这么想，<? extends T>表示的是T的子类，那么List<? extends T> 保存的便是T的某个子类，所以不能保存Object或者T等类型，又由于列表不能保存不同的类型，所以也不能保存任何T的子类,即容器将数组在运行时才会有的类型检查放到了编译期（原因是运行时类型会被擦除）。\",\"List<? extends Fruit> fruits = new ArrayList<Apple>();//可以安全的应用 fruits2.add(new Apple());//编译时报错，类型转化错误 fruits2.add(new Fruit());//编译时报错 \"]},\"293\":{\"h\":\"逆变\",\"t\":[\"List<? super T>主动声明通配符?的超类型为T,即List保存的是T的某个父类，那么List也可以安全的保存T或者T的子类。\",\"void fun(List<? super Apple> apples){ apples.add(new Apple()); apples.add(new Jonathan()); apples.add(new Fruit());//error 类型错误 } \",\"java为什么不支持泛型数组？ - ylxfc的回答 - 知乎\",\"Oracle Java 泛型原理\",\"Java 理论和实践-了解泛型-识别和避免学习使用泛型过程中的陷阱\",\"Java泛型（二） 协变与逆变\",\"《Java编程思想 第4版》\"]},\"294\":{\"h\":\"Java创建线程安全的单例Singleton\",\"t\":[\"在编码中常常会用到单例，来确保类有一个唯一的对象，一般情况下将构造方法私有化既可以实现，但当考虑到多线程时事情会变得有些复杂，本文讨论的正是几种多线程的情况下实现单例的方法。\",\"私有化构造方法，对外提供一个公有、静态的方法，在其内部判断类对象是否已经存在，否的话生成类对象再返回。\",\"class ASingleton{ private static ASingleton as; private void ASinleton() { System.out.print(\\\"ASingleton init!\\\\n\\\"); } public static ASingleton getInstance() { if(as == null) { //tag1 as = new ASingleton(); //tag2 } return as; } } \",\"但是，在考虑多线程时，由于java代码是一行行进行的，假设有两个线程t1、t2，当as为null的时候t1执行到tag1位置，判断为true，于是准备执行tag2，就在此时，cup调度t2开始执行tag1，此时t1尚未执行tag2，所以在t2中tag1判断为true,t2也开始执行tag2生成一个新对象,这样当t1再次执行tag2时就会再生成一个新对象，这样就同时存在多个类的对象。\",\"对上面的代码稍作优化,可以看到使用了synchronized，对判断是否需要初始化进行了同步锁，这样当线程t1访问时，语句被锁定，t2运行到这里时，只能等t1运行完这段语句并释放之后，才能继续访问，此时as已经被赋予了对象，所以不会再继续新建，这样就保证了单例。\",\"class ASingleton { private static ASingleton as; private void ASinleton() { System.out.print(\\\"ASingleton init!\\\\n\\\"); } public static ASingleton getInstance() { synchronized (ASingleton.class) { if (as == null) { as = new ASingleton(); } } return as; } } \",\"但是这样也存在一个问题，每个线程每次获取单例都要进入同步锁，这样累计下来必然影响效率。\",\"那么在判断as为null后，对as的初始化进行同步锁呢？\",\"public static ASingleton getInstance() { if (as == null) { synchronized (ASingleton.class) { if (as == null) { //tag1 as = new ASingleton(); //tag2 } } } return as; } \",\"这样子，当判断as为null时，才会进行初始化，同时由于初始化过程加锁，所以t1和t2无法同时访问初始化语句tag2，也保证了只能创建一个单例。\",\"看起来很完美，但是由于java语言的特性，在该段代码编译为汇编语言时，上述方法会被编译为类似下面的过程：\",\"1.判断as是否为null 2.令as = ASingleton() //注意此时只是为as分配了内存，并未执行ASingleton的构造方法 3.开始执行ASingleton构造方法，as有了初始化的值 4.返回as \",\"那么，当t1执行到语句2，而t2开始执行语句1时，此时由于as已经分配了内存不为null，所以t2直接执行语句4，此时t2获取到的是一个没有执行构造方法的ASingleton对象，显然这样十分危险。在线程复杂的情况下很容易出现问题。\",\"下面提供了两个结局思路，为简便起见，将其简单分为“饿汉模式”和“懒汉模式”（其实上述方法也可分为这两个模式，but，who cares...）。\",\"饿汉模式，即在声明的时候就将对象初始化。\",\"这样实现单例的原理是类的静态变量全局唯一。\",\"class ASingleton { private static ASingleton as = new ASingleton(); private void ASinleton() { System.out.print(\\\"ASingleton init!\\\\n\\\"); } public static ASingleton getInstance() { return as; } } \",\"但是这样仍然有个问题，可能在用到ASingleton类的时候，并不需要立即获取到其单例，在这种情况下，饿汉模式仍然有浪费资源的嫌疑。\",\"懒汉模式，只有要用到该实例时，才获取该单例。\",\"这次我们用到的时静态内部类，静态内部类与类的静态变量不同，只有明确调用静态内部类的时候才会初始化静态内部类。\",\" class ASingletonFactory{ static class ASingleton { public static ASingleton as = new ASingleton(); private void ASinleton() { System.out.print(\\\"ASingleton init!\\\\n\\\"); } } public static ASingleton getInstance() { return ASingleton.as; } } \",\"嗯，至此已经完成了java实现单例的绝大部分方法，但其实还有一张更加简洁的方法，那就是用enmu实现。\",\"由于枚举类型的对象是唯一的，所以是实现单例的较优选择。\",\"enum SingletonEnum{ INSTANCE; public void dosth(){ } } \",\"但是，android开发者要注意，枚举占用的内存是普通单例的两倍多，所以，并不推荐在android中使用。\",\"关于枚举的更详细资料，参阅(深入理解Java枚举类型(enum))[http://blog.csdn.net/javazejian/article/details/71333103#t7]\"]},\"295\":{\"h\":\"Java反射简单应用\",\"t\":[\"反射，用来在运行时获取给定类的构造函数，变量，方法，并对其作以修改，而不必在编译时获取该类。\",\"Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.\",\"--https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html\",\"定义一个待反射的类ATestClass.java\",\"package cf.android666.reflect; public class ATestClass { public String name; private int age; public ATestClass() { // TODO Auto-generated constructor stub } private void init(String name, int age) { this.name = name; this.age = age; } public String getAge() { // TODO Auto-generated method stub return \\\" age: \\\" + age; } } \",\"在TestReflect.java中反射\",\"//核心代码 public static void main(String[] args){ //注意这里需要是完整的类名，包括包名 Class<?> clazz = Class.forName(\\\"cf.android666.reflect.ATestClass\\\"); ATestClass aTestClsObj=(ATestClass) clazz.newInstance(); //反射获取变量 Field mName = clazz.getDeclaredField(\\\"name\\\"); mName.setAccessible(true); mName.set(aTestClsObj, \\\"aReflect\\\"); System.out.println(aTestClsObj.name); //反射获取方法 Method mInit= clazz.getDeclaredMethod(\\\"init\\\", String.class,int.class); mInit.setAccessible(true);//解除私有限定，让我们在用反射时访问私有变量 mInit.invoke(aTestClsObj, \\\"aInitName\\\",66); System.out.println(aTestClsObj.name + aTestClsObj.getAge()); } \",\"反射的用法较为简单\",\"通过Class.froName() 获取Class对象clazz ，获取要反射的Class对象aTestClsObj\",\"通过clazz 获取要反射Class的变量、方法\",\"通过aTestClsObj 操作这些变量，方法\",\"其中需要注意的有\",\"f.setAccessible(true); 方法可以解除private 限制，进而可以操作类的私有变量，方法\",\"clazz.getXXX() 方法获取全部公有变量、方法 ，包括父类或接口的xx，clazz.getDeclaredXXX() 方法获取全部 变量、方法，包括私有的，实现接口的方法，但是不包括父类的\"]},\"296\":{\"h\":\"Java实现AES加密解密应用\",\"t\":[\"最近手机中涉及到用户账户密码保存的问题，选用AES加密算法进行加密后，再通过SharedPreferences保存在手机端。\",\"本文主要介绍AES的加密、解密用法。\",\"初始化秘钥\",\" private static final String AES = \\\"AES\\\"; private static final String PASSWPRD = \\\"123456\\\"; public static SecretKeySpec initKey(){ SecretKeySpec key = null; try { KeyGenerator kg = KeyGenerator.getInstance(AES); kg.init(128,new SecureRandom(PASSWPRD.getBytes()));//通过这种算法，每次生成的key都是一样的 //也可以kg.init(128),这样每次生成的key都不一样 SecretKey securityKey = kg.generateKey(); byte[] encodedKey = securityKey.getEncoded(); key = new SecretKeySpec(encodedKey, AES);//AES也可以替换为\\\"AES/CBC/PKCS5PADDING\\\" } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return key; } \",\"加密\",\"//核心代码 //source是要加密的内容 Cipher cipher = Cipher.getInstance(AES);//创建密码器 byte[] byteContent = source.getBytes(\\\"utf-8\\\"); cipher.init(Cipher.ENCRYPT_MODE, key);//创建密码器 byte[] result = cipher.doFinal(byteContent);//加密 \",\"解密\",\"//核心代码 Cipher cipher = Cipher.getInstance(AES); cipher.init(Cipher.DECRYPT_MODE, key); byte[] result = cipher.doFinal(source); \",\"加密和解密的结果都是二进制的，无法直接转化为字符串，所以还需要将二进制与十六进制互转\",\" public static String parseByte2HexStr(byte buf[]) { StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i < buf.length; i++) { String hex = Integer.toHexString(buf[i] & 0xff); if (hex.length() == 1) { hex = '0' + hex; } stringBuffer.append(hex.toUpperCase()); } return stringBuffer.toString(); } public static byte[] parseHexStr2Byte(String hexStr){ if (hexStr.length() < 1) { return null; } byte[] result = new byte[hexStr.length() / 2]; for (int i = 0; i < hexStr.length() / 2; i++) { int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16); int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16); result[i] = (byte) (high * 16 + low); } return result; } \",\"这样就可以在初始化一个key后，对文本进行加密和解密\",\"//初始化key SecretKeySpec key = initKey(); //加密文本并转化为16进制，方便保存 String eStr = parseByte2HexStr(encrypt(resource,key)); //将加密16进制文本转为二进制，进行解密 String dStr = decrypt(parseHexStr2Byte(estr)); \",\"JAVA实现AES加密 - CSDN博客\",\"源码github链接\"]},\"297\":{\"h\":\"Java并发编程笔记\",\"t\":[\"cThread.join()方法使当前线程阻塞，直到子线程cThread执行完毕后，当前线程才会恢复运行。\",\"实现原理：\",\" join()方法调用了join(0)\",\"public final void join() throws InterruptedException { join(0); } \",\" join(long millis)是一个同步方法，最后会通过调用wait()方法挂起当前线程（即调用线程），直到其他线程调用子线程cThread的notify()或者notifyAll()方法\",\"public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis < 0) { throw new IllegalArgumentException(\\\"timeout value is negative\\\"); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay <= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } } \",\"子线程run()执行完毕后，系统在关闭该子线程前，会调用其exit()方法，继而在ThreadGroup.threadTerminated(Thread t)中唤醒被阻塞的调用线程。\",\"/** * This method is called by the system to give a Thread * a chance to clean up before it actually exits. */ private void exit() { if (group != null) { group.threadTerminated(this);//提心ThreadGroup当前线程已经被终止 group = null; } //其他代码 …… } // ThreadGroup void threadTerminated(Thread t) { synchronized (this) { remove(t); if (nthreads == 0) {//线程组线程数为0时 notifyAll();//唤醒所有等待中的线程 } if (daemon && (nthreads == 0) && (nUnstartedThreads == 0) && (ngroups == 0)) { destroy(); } } } \",\"先了解两个概念：\",\"锁池：某个Thread调用某个对象的同步方法（synchronized），但还没获取到该对象的锁时，会进入锁池和其他类似的线程一起竞争该对象的锁。\",\"等待池：当某个Thread调用某个对象的wait()方法释放掉该对象的锁进入阻塞后（waiting on this object's monitor），会进入等待池。等待池中的线程不会竞争该对象的锁。\",\"notify()方法会从等待池中唤醒一个指定线程，该线程可以再次回到锁池竞争该对象的锁，但可能会导致死锁（如果唯一唤醒的线程阻塞了并依赖其他线程唤醒，但其他线程都在等待池无法竞争锁，导致死锁）。\",\"notifyAll()方法则会唤醒所有在等待池中的线程，之后他们都可以回到锁池竞争该对象的锁。\",\"Java Thread的join() 之刨根问底\",\"java中的notify和notifyAll有什么区别？ - 大王叫我来巡山的回答 - 知乎\"]},\"298\":{\"h\":\"Java注解\",\"t\":[\"注解，是描述Java代码的代码，它能够被编译器解析，向编译器、虚拟机说明一些事情，就像java中给程序员看的注释一样。\",\"Android应用开发这方面比较火的是Butter Knife ,本文讲述如何自定义注解替换findViewById()。\",\"实现注解（annotation）的思路：通过反射获取到类中使用注解的变量，方法，再调用不同的方法对这些变量，方法进行处理以达到目的。\",\"主要涉及三方面：\",\"定义一个注解类\",\"定义一个注解帮助类\",\"使用注解\",\"java语言有四个预留的注解，用来生成其他自定义的注解：\",\"@Target\",\"说明注解所能修饰的范围。其值一般为ElementType.xxx，主要有：\",\"CONSTRUCTOR 描述构造器\",\"FIELD 描述域\",\"LOCAL_VARIABLE 描述局部变量\",\"METHOD 描述方法\",\"PACKAGE 描述包\",\"PARAMETER 描述参数\",\"TYPE 描述类，接口，enum声明\",\"@Retention\",\"说明注解存活的生命周期,其值一般为RetentionPolicy.xxx，主要有\",\"SOURCE 仅源文件有效，被编译器丢弃\",\"CLASS 在class文件中有效，可能被虚拟机忽略\",\"RUNTIME 在运行时有效，在class被装载时被获取\",\"@Documented\",\"用于描述其它类型的annotation应该被作为被标注的程序成员的公共API\",\"表示是否将注解信息添加在java文档中。有该注解则会被Javadoc工具文档化\",\"是一个标记注解，没有值\",\"@Inherited\",\"表示该标记会被标记的class的子类继承，在查找该注解时，如果当前类没有，会自动向上到其父类中查找，直到该注解类型被找到或是查找完了Object类还未找到\",\"是一个标记注解，没有值\",\"注解不能继承其他注解或接口\",\"java中常见的内建注解：\",\"@Override 重写父类方法\",\"@Deprecated 不赞成使用的api\",\"@SuppressWarnings() 忽略指定警告\",\"参数如下：\",\"参数\",\"含义\",\"deprecation\",\"使用了过时的类或方法时的警告\",\"unchecked\",\"执行了未检查的转换时的警告\",\"fallthrough\",\"当Switch程序块进入进入下一个case而没有Break时的警告\",\"path\",\"在类路径、源文件路径等有不存在路径时的警告\",\"serial\",\"当可序列化的类缺少serialVersionUID定义时的警告\",\"finally\",\"任意finally子句不能正常完成时的警告\",\"all\",\"以上所有情况的警告\"]},\"299\":{\"h\":\"注解类\",\"t\":[\"@Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface BindView { //注解参数只可以为public或者默认 //如果注解中的值不是value，那么在进行注解的时候，需要给出对应的值的名字 //如@ViewInject(id = R.id.buy) int value(); //注解元素必须有明确的值，要不在定义注解时指定默认值，要不在使用注解时指定 public int age() default 18;//指定默认值 } \",\"注解参数支持数据类型如下：\",\"1.所有基本数据类型（int,float,boolean,byte,double,char,long,short) 2.String类型 3.Class类型 4.enum类型 5.Annotation类型 6.以上所有类型的数组\"]},\"300\":{\"h\":\"注解帮助类\",\"t\":[\"主要提供使用注解的方法，代码中的注解替换为真正要实现的逻辑，为注解和使用注解的类搭建一个桥梁。\",\"//核心方法如下 public static void bindViews(Activity activity) { //获取到使用注解的类 Class<? extends Activity> clazz = activity.getClass(); //获取该类中的所有域变量 Field[] fields = clazz.getDeclaredFields(); //通过遍历，将使用到注解的变量初始化 for (Field field : fields) { //获取注解对象 BindView bindView = field.getAnnotation(BindView.class); if (bindView != null) { //获取注解的值 int viewId = bindView.value(); if (viewId != -1) { try { //注解要实现的逻辑，此处为替代clazz中的findViewById()方法，注意getMethod()是获取该类及其实现的接口中所有的public方法 Method findViewById = clazz.getMethod(\\\"findViewById\\\", int.class); findViewById.setAccessible(true); Object o = findViewById.invoke(activity, viewId); //修改要注解的类，到此注解目的达到 field.setAccessible(true); field.set(activity,o); } catch (Exception e) { e.printStackTrace(); } } } } } \"]},\"301\":{\"h\":\"使用注解\",\"t\":[\"在类中通过@xxx() 使用注解，并通过帮助类真正实现注解逻辑\",\"//标记注解 @BindView(R.id.text) private TextView textView; //调用帮助类方法 AnnotationUtils.bindViews(ASampleActivity.this); //使用初始化之后的变量 textView.setText(\\\"hello annotation\\\"); \",\"Java核心技术点之注解 - ImportNew\",\"java注解--gityuan\"]},\"302\":{\"h\":\"Java笔记之YYYY格式化日期\",\"t\":[\"最近看到一个帖子，表示有人以\\\"YYYY-MM-dd\\\"格式化日期时，在2019-12-30时出现2020-12-30的BUG。\",\"本文来简单分析一下为什么会出现这个情况。\",\"根据JDK文档关于日期的定义，y表示的是我们日常使用的年份，而Y表示的是Week year。\",\"先了解几个知识点：\",\"Week year表示的是这个周所属的年份。\",\"A week year is in sync with a WEEK_OF_YEAR cycle. All weeks between the first and last weeks (inclusive) have the same week year value. Therefore, the first and last days of a week year may have different calendar year values.\",\"来源：https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html#week_year\",\"指的是这一年所有的周，从第01周开始到该年最后一周。\",\"要注意这个周不一定是自然周，所包含的日期也不一定全部都是当年的日期。\",\"Values calculated for the WEEK_OF_YEAR field range from 1 to 53. The first week of a calendar year is the earliest seven day period starting on getFirstDayOfWeek() that contains at least getMinimalDaysInFirstWeek() days from that year.\",\"根据这份JDK文档，当 getFirstDayOfWeek() is MONDAY（2） and getMinimalDaysInFirstWeek() is 4时，JAVA判断周日期的标准与ISO_8601兼容：\",\"第01周有几个相互等效且兼容的描述：\",\"一年中第一个星期四的星期（正式的ISO定义），\",\"1月4日这一周，\",\"起始年份中大部分（四天或以上）的第一周，以及\",\"从12月29日至1月4日的星期一开始的一周。\",\"来源：https://en.wikipedia.org/wiki/ISO_8601\",\"按照JAVA文档中的定义，每年最开始的几天和最后的几天的Week year不一定是当年的年份值，而是受到每年的第01周/最后一周的影响。\",\"JAVA中判断周主要受到Calendar对象的getFirstDayOfWeek()和getMinimalDaysInFirstWeek()这两个本地值的影响。\",\"其中：\",\"getFirstDayOfWeek() 指定一周的第一天，比如, 美国一周从SUNDAY 开始,法国则是MONDAY 。\",\"getMinimalDaysInFirstWeek() 一年第一周所需最小的天数。比如1表示只要包含第一天就算该年的第一周，而7表示只有完整的一周都在该年才算该年的第一周。\",\"注意：真正影响我们格式化日期结果的是SimpleDateFormat中的calendar对象对应的值。\",\"而通过打印这个simpleDateFormat.calendar，我们看到：\",\"//JDK1.7 minimalDaysInFirstWeek:1 firstDayOfWeek:1 //SUNDAY \",\"所以可以得出结论，JAVA默认只要次年的1月1日在在这个跨年周，那么本周所有日期的Week year都是次年的（JDK1.7）。\",\"有了以上知识，我们再看看2019-12-30以YYYY格式化为什么会出现问题：\",\"先看一下这些日期对应的星期：\",\"周日\",\"周一\",\"周二\",\"周三\",\"周四\",\"周五\",\"周六\",\"29\",\"30\",\"31\",\"1\",\"2\",\"3\",\"4\",\"首先根据JDK默认的第01周的定义，2020-01-01所在的周为2020的第一周，所以2019-12-29到2020-01-04都属于是2020年的第01周。\",\"再根据YYYY表示的是Week year的结论，可以知道，当使用YYYY格式化时，2019-12-29到2020-01-04都会得到2020。\",\"val calendar = Calendar.getInstance() val simpleDateFormat = SimpleDateFormat(\\\"YYYY yyyy MM dd\\\") calendar.set(2019, 12-1, 29) println(simpleDateFormat.format(calendar.time)) //output DATE:2019 12 29 minimalDaysInFirstWeek:1 firstDayOfWeek:1 YYYY yyyy MM dd 2020 2019 12 29 \",\"而如果我们把第一周最小天数minimalDaysInFirstWeek改为5天，那么很明显这一周属于2020年的天数（从周日到周一，只有1号到4号4天）不够5天，所以这一周被划归为2019年的第53周，2019-12-29到2020-01-04的week year都是属于2019。\",\"val calendar = Calendar.getInstance() val simpleDateFormat = SimpleDateFormat(\\\"YYYY yyyy MM dd\\\") calendar.set(2019, 12-1, 29) simpleDateFormat.calendar.minimalDaysInFirstWeek = 5 println(simpleDateFormat.format(calendar.time)) //output DATE:2019 12 29 minimalDaysInFirstWeek:5 firstDayOfWeek:1 YYYY yyyy MM dd 2019 2019 12 29 \",\"再比如下面这个示例中的2010-12-26。\",\"按照JDK1.7默认算法，一周从周日（2010-12-26）开始，并且当年的1月1日（2011-01-01）所在周为该年第一周，所以2010-12-26到2011-01-01都被划到了2011年的第一周。\",\"但如果按照ISO_8601的标准，一周从周一开始，并且起始年份包含的天数至少要有4天：\",\"则很明显2010-12-26属于2010年的51周，而2010-12-27到2011-01-02都属于2010年的第52周（属于2020年的只有2天，不满足第一周的条件）。\",\"周一\",\"周二\",\"周三\",\"周四\",\"周五\",\"周六\",\"周日\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"1\",\"2\",\"结合以上结论，我们可以看到，在JAVA中（JDK1.7）：\",\"“YYYY” 表示Week year\",\"每年最开始的几天和最后的几天的Week year不一定是当年的值，而是受到当年的第一周/最后一周的影响。\",\"JAVA周的判断与simpleDateFormat.calendar.minimalDaysInFirstWeek和simpleDateFormat.calendar.firstDayOfWeek有关。\",\"而这两个值都属于本地化值，在国内可以简单理解为一年1月1日所在的周就是当年的第一周。\",\"我们可以通过修改minimalDaysInFirstWeek和firstDayOfWeek来更改YYYY格式化的值。\",\"JDK中日期格式化的参数及含义（来自https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#month）：\",\"Letter\",\"Date or Time Component\",\"Presentation\",\"Examples\",\"G\",\"Era designator\",\"Text\",\"AD\",\"y\",\"Year\",\"Year\",\"1996; 96\",\"Y\",\"Week year\",\"Year\",\"2009; 09\",\"M\",\"Month in year\",\"Month\",\"July; Jul; 07\",\"w\",\"Week in year\",\"Number\",\"27\",\"W\",\"Week in month\",\"Number\",\"2\",\"D\",\"Day in year\",\"Number\",\"189\",\"d\",\"Day in month\",\"Number\",\"10\",\"F\",\"Day of week in month\",\"Number\",\"2\",\"E\",\"Day name in week\",\"Text\",\"Tuesday; Tue\",\"u\",\"Day number of week (1 = Monday, ..., 7 = Sunday)\",\"Number\",\"1\",\"a\",\"Am/pm marker\",\"Text\",\"PM\",\"H\",\"Hour in day (0-23)\",\"Number\",\"0\",\"k\",\"Hour in day (1-24)\",\"Number\",\"24\",\"K\",\"Hour in am/pm (0-11)\",\"Number\",\"0\",\"h\",\"Hour in am/pm (1-12)\",\"Number\",\"12\",\"m\",\"Minute in hour\",\"Number\",\"30\",\"s\",\"Second in minute\",\"Number\",\"55\",\"S\",\"Millisecond\",\"Number\",\"978\",\"z\",\"Time zone\",\"General time zone\",\"Pacific Standard Time; PST; GMT-08:00\",\"Z\",\"Time zone\",\"RFC 822 time zone\",\"-0800\",\"X\",\"Time zone\",\"ISO 8601 time zone\",\"-08; -0800; -08:00\",\"感谢这篇文章，让我推翻了上一次的结论，发现了真正的原因：JAVA中的SimpleDateFormat yyyy和YYYY的区别\",\"GregorianCalenda jdk1.7\",\"在线显示本周是一年第几周的网站：What's the Current Week Number?\"]},\"303\":{\"h\":\"Java笔记之序列化与反序列化：Serializable、Externalizable和Parcelable\",\"t\":[\"Photo by Pixabay from Pexels\",\"序列化：指将Java对象转化为字节流以便在网络、文件中保存、传输。\",\"反序列化：指的是从字节流中恢复Java对象。\",\"本文主要讨论Android和Java中实现序列化的4种方式，并探讨一下其实现原理。\",\"Android & Java中实现序列化的方式有：\",\"android.os.Parcelable Android平台特有，需要自己实现具体细节，性能消耗小，只能在内存中存在\",\"java.io.Serializable 实现简单，只需要实现Serializable接口即可，可以输出到文件、网络等\",\"java.io.Externalizable 需要自己实现具体细节\",\"Twitter Serial Twitter出品的高性能序列化方案，它力求帮助开发者实现高性能和高可控的序列化过程。（本文不详细介绍，可以参考这篇文章）\",\"Serializable接口没有任何方法，只是一个标记——表示这个类可以用来序列化/反序列化（由ObjectOutputStream/ObjectInputStream实现具体细节）。\",\"一个类没有实现Serializable接口，或者包含没有实现Serializable接口的变量，则会序列化失败NotSerializableException。\"]},\"304\":{\"h\":\"serialVersionUID\",\"t\":[\"使用serialVersionUID标记当前Serializable的版本。\",\"如果没有指定，系统会自动用对象的hashCode()指定serialVersionUID，该值会在类发生改变时变化，从而导致反序列化失败。\",\"而如果serialVersionUID一致，即使类结构有变化，也会反序列化（给新增的变量默认值），所以最好赋予一个默认的值。\",\"//可以手动指定，也可以随机数，只要保持一致即可，如果不一致则会使反序列化失败 ANY-ACCESS-MODIFIER static final long serialVersionUID = 1L; \"]},\"305\":{\"h\":\"readResolve()\",\"t\":[\"如果class实现了readResolve()方法，会在反序列化时用到并返回这里提供的对象（反序列化得到的对象会被丢弃）。\",\"// 1. 反序列化 SerializableClass serializableClass = (SerializableClass) objectInputStream.readObject(); // 2.readObject()内部调用了readObject0(false): private Object readObject0(boolean unshared) throws IOException { // ... try { switch (tc) { // 这里匹配了TC_NULL,TC_REFERENCE,TC_CLASS,TC_CLASSDESC, // TC_PROXYCLASSDESC,TC_STRING,TC_LONGSTRING,TC_ARRAY,TC_ENUM // TC_EXCEPTION,TC_BLOCKDATA,TC_BLOCKDATALONG,TC_ENDBLOCKDATA等等类型 case TC_OBJECT://如果是OBECJT类型，就调用下面的方法👇 return checkResolve(readOrdinaryObject(unshared)); // ... default: throw new StreamCorruptedException( String.format(\\\"invalid type code: %02X\\\", tc)); } } finally { depth--; bin.setBlockDataMode(oldMode); } } // 3. 在这里会检测是否存在readResolve()方法，有的话就返回从readResolve()获取的对象 private Object readOrdinaryObject(boolean unshared) throws IOException { // ... Object obj; // ... // 看这里，如果hasReadResolveMethod()为真则执行invokeReadResolve()并返回其结果 if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) { Object rep = desc.invokeReadResolve(obj); if (unshared && rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } handles.setObject(passHandle, obj = rep); } } return obj; } // Invokes the readResolve method of the represented serializable class and returns the result. Object invokeReadResolve(Object obj) throws IOException, UnsupportedOperationException{} \",\"通过这个特性我们可以确保在反序列化的时候也能实现单例：\",\"private Object readResolve() throws ObjectStreamException { return this;//返回单例本身，而非新建的对象 } \",\"但是根据下面的说法，要实现可以序列化的单例最简单安全的，还是使用枚举：\",\"事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域则都必须声明为transient的。否则，利用readResolve()方法实现的单例也会遭受到攻击。\",\"实现可序列化最简单安全的方式是采用枚举的形式，应该尽可能采用这种方式。如果采用readResolve实现的话，要确保该类的所有实例域都为基本类型，或者是transient的。\",\"77.单例模式，枚举类型优先于readResolve\"]},\"306\":{\"h\":\"自定义序列化过程\",\"t\":[\"如果想要自己处理序列化的过程，可以实现下面的方法：\",\"private void writeObject(java.io.ObjectOutputStream out) throws IOException private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException; private void readObjectNoData() throws ObjectStreamException; \",\"其中，可以使用下面的方法实现读/写该类自身的属性（All non-static and non-transient fields of the current class, include private），然后在调用诸如out.writeObject(string);等方法保存其他变量。\",\"The method does not need to concern itself with the state belonging to its superclasses or subclasses.\",\"in.defaultReadObject(); out.defaultWriteObject(); \",\"readObjectNoData方法主要用在序列化流和我们要反序列化的类不一致时初始化一些必要的状态。\",\"这种情况可能出现在接收方使用了一个与发送方不同版本的类。接收方的版本多扩展了一些字段，而发送方的版本没有这些字段。还有一种可能就是序列化流被篡改了。这时，无论是恶意的流还是不完整的流，都可以用 readObjectNoData 方法来将序列化得到的对象初始化到正确的状态。 作者：福尔马林 链接：https://juejin.im/post/5d7206c5f265da03ab427181\",\"此外，还可以使用ObjectOutputStream的putFields()和ObjectInputStream的readFields()写入/读取变量。使用这种方法可以加密/解密部分变量，或者在序列化的时候只处理部分变量。\",\"具体使用方法见如下：\",\"注意：putFields()/readFields()方法分别不能与defaultWriteObject/defaultReadObject一起使用；\",\"putFields.put()之后必须调用out.writeFields()方法\",\"并且，没有在putFields()中加入的数据，在readObject中只能获取到该类型的默认值\",\"//这段示例代码来自 https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html private void writeObject(ObjectOutputStream out) { try { PutField putFields = out.putFields(); System.out.println(\\\"原密码：\\\" + password); password = \\\"encryption\\\";//模拟加密 putFields.put(\\\"password\\\", password); System.out.println(\\\"加密后的密码：\\\" + password); out.writeFields();// putFields.put()之后必须调用本方法 } catch (IOException e) { e.printStackTrace(); } } private void readObject(ObjectInputStream in) { try { GetField readFields = in.readFields(); Object object = readFields.get(\\\"password\\\", \\\"\\\"); System.out.println(\\\"要解密的字符串：\\\" + object.toString()); password = \\\"pass\\\";//模拟解密,需要获得本地的密钥 } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } // 执行反序列化结果： // 原密码：pass // 加密后的密码：encryption // 要解密的字符串：encryption // 最后反序列化后的password为pass \"]},\"307\":{\"h\":\"父类未继承Serializable的类的序列化\",\"t\":[\"如果一个类实现了序列化，但他的父类没有实现序列化，那么父类必须要有一个公开的无参构造函数，否则反序列化时会出错。\",\"此时反序列化时，父类的变量值（public, protected, and (if accessible) package fields）都会是默认的值或者是在父类无参构造函数中初始化的值（即使这些值在子类对象中已经被修改了）。\",\"要想使得这些值也可以支持序列化，可以通过writeObject/readObject自己处理这些值的序列化。\",\"反之，如果一个类实现了Serializable接口，那么他的子类也自动支持序列化与反序列化。\"]},\"308\":{\"h\":\"实现\",\"t\":[\"下面是使用Serializable实现序列化与反序列化的简单示例：\",\"/** * author: jixiaoyong * email: jixiaoyong1995@gmail.com * website: https://jixiaoyong.github.io * date: 12/24/19 * description: 演示序列化功能 */ class SerializableClass implements Serializable { private int anInt = 10; public long aLong = 100L; public transient String aTransient = \\\"transient filed cannot be serialized\\\"; public static String A_STATIC_FILED = \\\"static filed belong to class not object, cannot be serialized\\\"; public static void main(String[] args) { SerializableClass clazz = new SerializableClass(); File file = new File(\\\"ObjectOutputFile\\\"); try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file))) { //write object to byte sequences objectOutputStream.writeObject(clazz); //chang the object filed clazz.aLong = 666L; // A_STATIC_FILED belong to the class, so you can see it has the value read form // the JVM rather the object you serialized before when you deserializes it. SerializableClass.A_STATIC_FILED = \\\"Change the static filed!\\\"; SerializableClass serializableClass = (SerializableClass) objectInputStream.readObject(); System.out.println(serializableClass); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } @Override public String toString() { return \\\"SerializableClass{\\\" + \\\"anInt=\\\" + anInt + \\\", aLong=\\\" + aLong + \\\", aTransient='\\\" + aTransient + '\\\\'' + \\\", A_STATIC_FILED='\\\" + A_STATIC_FILED + '\\\\'' + '}'; } } // output: // SerializableClass{anInt=10, aLong=100, aTransient='null', A_STATIC_FILED='Change the static filed!'} \"]},\"309\":{\"h\":\"多次序列化同一个对象\",\"t\":[\"返序列化读取的过程在readResolve()方法一节已经涉及到了，我们在看一下保存的部分，这里会有一个有意思的现象：\",\"Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。\",\"https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html\",\"这会导致一个问题：当使用同一个ObjectOutputStream对象序列化同一个序列化对象时，即使在第一次序列化并保存后修改了这个对象的部分属性，当再次序列化时保存的只是前一个对象的引用——也就是说将完全相同一个对象保存了两次，第二次做的修改在序列化的时候并没有保存。\",\"我们写个简单的DEMO验证一下：\",\"private static void readAndwriteObject2(SerializableClass clazz) { File file = new File(\\\"ObjectOutputFile\\\" + System.currentTimeMillis()); try ( ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file)); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file)) ) { // 第一次序列化 objectOutputStream.writeObject(clazz); objectOutputStream.flush(); clazz.aLong = 9344L;//在这里修改了部分属性 // 第二次序列化 objectOutputStream.writeObject(clazz); objectOutputStream.flush(); // 反序列化，读取之前序列化的两个对象 SerializableClass serializableClass = (SerializableClass) objectInputStream.readObject(); System.out.println(serializableClass); SerializableClass serializableClass1 = (SerializableClass) objectInputStream.readObject(); System.out.println(serializableClass1); System.out.println(\\\"serializableClass == serializableClass1: \\\" + (serializableClass == serializableClass1)); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } // output // SerializableClass{anInt=10, aLong=100, aaLong=100, aTransient='null', A_STATIC_FILED='static filed belong to class not object, cannot be serialized'} // SerializableClass{anInt=10, aLong=100, aaLong=100, aTransient='null', A_STATIC_FILED='static filed belong to class not object, cannot be serialized'} // serializableClass == serializableClass1: true //可以看到两次获取的是完全相同的对象 \",\"这是为什么呢，我们可以在源码中看到原因：\",\"// 序列化时，我们会调用ObjectOutputStream的writeObject方法 public final void writeObject(Object obj) throws IOException { if (enableOverride) { writeObjectOverride(obj); return; } try { writeObject0(obj, false);//注意这里，第二个参数unshared是false } catch (IOException ex) { if (depth == 0) { writeFatalException(ex); } throw ex; } } /** obj -> wire handle map */ private final HandleTable handles; private void writeObject0(Object obj, boolean unshared)throws IOException{ // ... if ((obj = subs.lookup(obj)) == null) { writeNull(); return; } else if (!unshared && (h = handles.lookup(obj)) != -1) { // 可以看到这里，如果unshared为false的话， // 就会去找这个对象是否已经被序列化过了，是的话就直接写入引用, // 而不是再次序列化 writeHandle(h); return; } else if (obj instanceof Class) { writeClass((Class) obj, unshared); return; } else if (obj instanceof ObjectStreamClass) { writeClassDesc((ObjectStreamClass) obj, unshared); return; } } } /** * Writes given object handle to stream. */ private void writeHandle(int handle) throws IOException { bout.writeByte(TC_REFERENCE); bout.writeInt(baseWireHandle + handle); } \",\"为了避免这种情况，在保存同一个对象时要注意使用不同的ObjectOutputStream对象，或者可以使用writeUnshared方法。\",\"// Writes an \\\"unshared\\\" object to the ObjectOutputStream. public void writeUnshared(Object obj) throws IOException { try { writeObject0(obj, true); } catch (IOException ex) { if (depth == 0) { writeFatalException(ex); } throw ex; } } \"]},\"310\":{\"h\":\"优缺点\",\"t\":[\"简单，只需要实现接口\",\"序列化的字节流可以在文件、网络中传递，可以持久化保存\",\"性能差，序列化过程大量使用反射和临时变量\",\"Externalizable继承自Serializable。\",\"用户需要通过writeExternal(ObjectOutput out)和readExternal(ObjectInput in)实现序列化与反序列化的细节，并且需要一个明确实现的**public no-arg constructor**\"]},\"311\":{\"h\":\"实现\",\"t\":[\"class NewClass implements Externalizable { public int anInt = 0; public String string = \\\"string\\\"; public static Long aLong = 10L; public transient float aFloat = 10F; public NewClass(){} @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeInt(anInt); out.writeObject(string); out.writeLong(aLong); out.writeFloat(aFloat); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { anInt = in.readInt(); string = (String) in.readObject(); aLong = in.readLong(); aFloat = in.readFloat(); } @Override public String toString() { return \\\"NewClass{\\\" + \\\"anInt=\\\" + anInt + \\\", string='\\\" + string + '\\\\'' + \\\", aFloat=\\\" + aFloat + \\\", aLong=\\\" + aLong + '}'; } } \"]},\"312\":{\"h\":\"原理\",\"t\":[\"看源码可以知道，如果检测到当前对象是Externalizable时，就会去调用该对象的writeExternal方法。\",\"public interface Externalizable extends java.io.Serializable // writeObject0 方法中： if (obj instanceof String) { writeString((String) obj, unshared); } else if (cl.isArray()) { writeArray(obj, desc, unshared); } else if (obj instanceof Enum) { writeEnum((Enum<?>) obj, desc, unshared); } else if (obj instanceof Serializable) { writeOrdinaryObject(obj, desc, unshared);//如果是Serializable就执行这个 } // writeOrdinaryObject方法中： if (desc.isExternalizable() && !desc.isProxy()) { writeExternalData((Externalizable) obj);//如果是Externalizable就执行这个 } else { writeSerialData(obj, desc); } // writeExternalData方法中 // Writes externalizable data of given object by invoking its writeExternal() method. if (protocol == PROTOCOL_VERSION_1) { obj.writeExternal(this); } else { bout.setBlockDataMode(true); obj.writeExternal(this); bout.setBlockDataMode(false); bout.writeByte(TC_ENDBLOCKDATA); } \"]},\"313\":{\"h\":\"优缺点\",\"t\":[\"比Serializable麻烦，序列化与反序列化都需要用户自己实现\",\"灵活，可以自定义要参与到序列化与反序列化的变量\",\"Parcelable是Android为了解决Serializable性能问题而推出的,主要用在Android的Intent或线程间通信中。\",\"Parcelable通过Parcel传输到IBinder中，从而实现跨进程传输。\",\"对于kotlin语言来说，Android Studio自动生成的Parcelable代码不会处理val变量（因为这些变量不会变化）\",\"此外，Parcelable在反序列化时，调用parcel.readParcelable(classLoader)传入的是ClassLoader。\"]},\"314\":{\"h\":\"实现\",\"t\":[\"下面是一个Parcelable的实现：\",\"class AParcelable() : Parcelable { var i = 10 // 从Parcel中恢复数据，必须按照写入的顺序读取 constructor(parcel: Parcel) : this() { i = parcel.readInt() } // 将变量写入到Parcel中，必须与读取的顺序对应 override fun writeToParcel(parcel: Parcel, flags: Int) { parcel.writeInt(i) } // 文件描述，一般默认为0 // 如果这个对象的writeToParcel方法的输出中有特殊的对象则传递对应的描述代码 // 如：如果包含一个文件描述符FileDescriptor，就要返回CONTENTS_FILE_DESCRIPTOR // https://developer.android.google.cn/reference/android/os/Parcelable.html#CONTENTS_FILE_DESCRIPTOR override fun describeContents(): Int { return 0 } // 必须有这个变量，用来从Parcel中创建Parcelable类 // 在JAVA中是public static final Creator<Book> CREATOR = new Creator<Book>() {...} companion object CREATOR : Parcelable.Creator<AParcelable> { override fun createFromParcel(parcel: Parcel): AParcelable { return AParcelable(parcel) } // Create a new array of the Parcelable class. // Returns an array of the Parcelable class, with every entry // initialized to null. override fun newArray(size: Int): Array<AParcelable?> { return arrayOfNulls(size) } } } \"]},\"315\":{\"h\":\"原理\",\"t\":[\"原理参考这篇文章Parcelable源码分析\"]},\"316\":{\"h\":\"优缺点\",\"t\":[\"性能好，Parcelable接口比Serializable接口效率更高，性能方面高出10多倍 [^Parcelable源码分析]:\",\"较复杂，需要自己实现对象的序列化内容\",\"一般需要持久化保存数据或在网络间传输时推荐使用Serializable或者Externalizable。\",\"在Android中Activity之间等传递对象，以及跨进程传递对象等时使用Parcelable以节省性能。\",\"Android之序列化详解\",\"Java 序列化的高级认识\",\"【原创】（译）Java 序列化魔法方法及使用示例\",\"What is Serialization? Everything You Need to Know About Java Serialization Explained With Example\",\"java序列化，看这篇就够了\",\"Java之Serializable/Externalizable序列化和反序列化\",\"77.单例模式，枚举类型优先于readResolve\",\"Pareclable实现原理：Parcelable最强解析\",\"Parcelable使用：详细介绍Android中Parcelable的原理和使用方法\",\"Parcelable源码分析\"]},\"317\":{\"h\":\"Java线程安全与volatile和synchronize\",\"t\":[\"Java多线程编码中，保证线程安全的实质是保证对数据操作的原子性，即一个线程对数据的操作能够及时的更新到其他使用该数据的线程中，这样就可以避免多个线程因为操作的数据值不一致而产生错误。\",\"线程、主内存、工作内存三者交互关系——深入理解JAVA虚拟机\",\"由于Java内存模型（JMM）规定，所有线程公用的数据保存在主内存中，而线程在使用时先从主内存中取到线程私有的工作内存中，之后再在使用完毕后同步到主内存中，在这过程中，如果其他线程也用到了该数据则可能会出现问题，因此在线程操作数据时需要考虑线程并发时操作数据的同步问题。\",\"volatile和synchronize因此而生。\",\"volatile修饰的变量有两个特性：\",\"变量对所有线程可见 普通变量则需要等线程操作完毕，将结果从工作内存写入到主内存中才可以被其他线程可见，volatile修饰的变量会在修改后通知其他线程该变量已经被更改，从而让其他线程再去主内存中读取最新的值\",\"禁止指令重排优化\",\"volatile修饰的变量执行效率和普通变量差别不大，其写操作因为要插入内存屏障，所以会稍微慢一些\",\"需要注意的是：\",\"由于Java运算的具体实现并非原子性的，故而虽然volatile修饰的变量在所有线程可见，但是并发下并不线程安全。\",\"Java代码编译成class文件后可以看到，类似c = c + 1这样的语句，会被分为：读取c的值；计算c+1的值；将结果赋予c这几步来完成。所以在此期间如果有其他的线程访问这段代码，就会发生冲突。\",\"Java会通过指令重排来优化代码\",\"指令重排 指对于变量的赋值会在定义该变量和使用该变量的值之间的任意位置执行，不一定和代码中的顺序一致\",\"volatile修饰的变量则会插入内存屏障，从而实现屏蔽指令重排的效果\",\"synchronize实现的原理是锁定指定的对象（如果没有指定则锁定对应的类对象或class对象），然后阻塞其他线程进入（获取到该锁的线程可以多次重入）。\",\"由于Java的线程实现是映射到系统线程的，阻塞和唤醒需要由系统内核完成，会消耗大量的时间，因此synchronize是重量级操作。\",\"JMM的设计是围绕着原子性、可见性、有序性三个特征进行的。\",\"原子性 JVM中的read,load,assign,use,store,write操作和synchronize\",\"可见性 一个线程更改了共享变量的值时，其余线程能够立即得知这个更改。通过synchronize，final和volatile保证。\",\"final要保证可见性的前提是要被安全的构建出来，避免**“this引用逃逸”**\",\"this引用逃逸 对象还没有被构造完成，他的this引用就已经被发布出去了。\",\"在构造函数中生成内部类，由于内部类自动持有外部类的this引用，如果有对象在内部类语句之后构造，则就有可能发生“内部类访问这个对象时，该对象还没有构造完毕”的情况。\",\"有序性 通过synchronize,volatile保证。\",\"线程从内部观察时有序（线程内是串行的语义），线程外部观察是无序（由指令重排、工作内存与主内存同步延迟导致）\",\"实现线程安全有以下几种方法：\"]},\"318\":{\"h\":\"互斥同步（阻塞同步）\",\"t\":[\"互斥同步的思想是：多个线程使用同一个共享数据时，保证同一时刻只能被一个线程使用\",\"有两种途径：\",\"synchronize （原生语法层），优先使用\",\"ReentrantLock 重入锁（API层），功能有：1.等待可中断（可以放弃等待）2.公平锁 多个线程申请锁时必须按照申请时间顺序获得锁 3.锁绑定多个条件\"]},\"319\":{\"h\":\"非阻塞同步\",\"t\":[\"减少了阻塞/唤醒的耗时，在操作时进行CAS（比较并交换），在冲突发生的时候不断尝试执行所需操作，直到执行成功。\",\"但是有一个逻辑漏洞：如果在第一次操作失败到第二次再次尝试操作之间，其他线程对齐进行了操作但是该数据最终没有被变化，当第二次再次尝试时，其实已经被其他线程访问过了。\"]},\"320\":{\"h\":\"无同步方案\",\"t\":[\"保证线程安全，不一定需要同步，当线程操作的数据不是共享数据时，即使不同步也是线程安全的。\",\"可重入代码 指在代码执行的过程中，如果中断其运行并运行其他的线程，当再次返回继续执行该代码时不会影响到其执行结果的代码。这种代码一般没有用到堆中的公用资源。\",\"线程本地存储 共享数据值存在于同一个线程中，如每个线程的ThreadLocal对象\",\"JDK1.6以后，在HotSpot虚拟机上实现了许多锁优化技术：\",\"自旋锁\",\"实现阻塞同步时，阻塞和唤醒会很耗时，为了避免这种情况，可以先对其进行忙循环，如果还不行再去执行阻塞操作\",\"自适应自旋 由JVM智能决定自旋次数\",\"锁消除\",\"JVM会自动取出不必要的锁\",\"锁粗化\",\"如果一段代码中有连续的锁，则JVM会将这些锁合并为一个大锁\",\"轻量级锁\",\"轻量级锁消耗比传统锁机制小，会优先尝试使用轻量级锁，如果不行，在升级为互斥锁\",\"大多数情况下会减少消耗，但如果存在锁竞争，则除了互斥锁的开销外，还有轻量级锁的开销\",\"偏向锁\",\"在无竞争的情况下消除同步\",\"乐观锁\",\"读取数据时默认该对象不会被其他对象更改而不加锁，每次写数据时对比当前值与持有值是否一致，一致时才去更新数据\",\"《深入理解Java虚拟机——JVM高级特性与最佳实践》 周志明\",\"this引用逃逸——蜡笔小勋\"]},\"321\":{\"h\":\"Kotlin学习笔记1\",\"t\":[\"这是我在学习Bennyhuo（ github ）的kotlin入门视频时的一些笔记，比较偏基础，用于查缺补漏。\",\"xx.map() & xx.flatMap()\",\"xx.flatMap()用于返回可迭代的数组，而xx.map()则是任何可迭代数据都有的用来遍历的方法。\",\" var arr = arrayListOf<String>(\\\"a c v de fb s e gf d\\\") arr.flatMap { it.split(\\\" \\\") }.map{ print(\\\"${it.toUpperCase()}\\\") } \",\"enum class 枚举类型\",\"分为有参和无参，枚举变量以,分隔，如果enum还有方法或者伴生对象，则最后一个变量后为;，否则可为,、;或者没有。\",\"enum class City{ UK,USA,EU; //以下为非必须代码，仅表示可以有这些功能 fun say(){...} companion object{ fun fun1(s:String):City{ return valueOf(s.toUpperCase()) } } } \",\"​ 有参的情况如下\",\"enum class Country(val aName:String){ CHINA(\\\"中国\\\"), JAPAN(\\\"日本\\\"), USA(\\\"美国\\\"), UK(\\\"英国\\\"); } \",\"​ 使用：通过enum的valueOf()方法获取枚举对象实例\",\"var s = \\\"uk\\\" var city = City.valueOf(s.toUpperCase()) //或者通过伴生对象： var city = City.fun1(s) \",\"companion object伴生对象\",\"在类的定义，可以直接用类名.方法名()调用，相当于java中的静态方法\",\"一个类中只能有一个伴生对象\",\"class xxx{ ... companion object{ fun parse(x: String): Country { return valueOf(x.toUpperCase()) } ... } } \",\"object修饰的类\",\"等同于只有一个实例的类，相当于java中的静态类，所有方法可以直接用类名调用\",\"object ClassName{ fun(){...} } \",\"fun ClassName.funName()为类添加新的方法\",\"对于不能直接修改的类，有需要对其增加一个方法，可以自定义一个ClassName.funName()的方法来达到这个目的。\",\"private fun Country.sayNum() { //this引用的是country对象 var num = when (this) { CHINA -> 1 JAPAN -> 2 USA -> 3 UK -> 4 } } \",\"​ 在使用时可以通过Country的对象调用syaNum()方法\",\"data class 数据类\",\"可以有方法，方便复制。\",\"必须至少有一个参数，并且参数都需要用var/val修饰\",\"data class dataClass(var name: String, val age :Int) \",\"文件读取 \",\"resource目录下的文件读取\",\" var input = File(ClassLoader.getSystemResource(\\\"input\\\").path).readText() \",\"与RxJava结合\",\"统计文本中字母个数，基于RxJava 1.2.1\",\" Observable.from(input.toCharArray().asIterable()) .filter { !it.isWhitespace() } .groupBy { it } .map{ o ->o.count().subscribe{ print(\\\"${o.key}-> $it ,\\\") } } .subscribe() \"]},\"322\":{\"h\":\"Kotlin学习笔记2\",\"t\":[\"把递归通过编译器转化为迭代，从而避免Stack Overflow\",\"“以时间换取空间”\",\"普通递归：\",\"调用函数之后，还需要使用其返回值供自己使用，即自身返回值依赖于下一级函数，一般是调用自身的代码后面，还有其他的代码要执行。\",\"fun fun1(n: Int): BigInteger { if (n == 0) return BigInteger.valueOf(1L) return n.toBigInteger().times(fun1(n - 1)) } \",\"尾递归：\",\"调用自身之后，无需再返回当前函数,将处理结果以其他形式返回。\",\"普通递归和尾递归都存在栈溢出风险（未优化前，例子中的函数计算10000到100000的阶乘时会溢出），kotlin提供了一种尾递归优化的方法——tailrec，使得编译器在编译时将递归转化为迭代，从而避免栈溢出。\",\"data class Result(var value: BigInteger = BigInteger.valueOf(1L)) //尾递归，tailrec为kotlin中优化关键字 tailrec fun fun2(n: Int, m: Result) { if (n == 0) { m.value = m.value.times(BigInteger.valueOf(1L)) return } else { m.value = m.value.times(n.toBigInteger()) fun2(n-1,m) } } \",\"本例中传入fun2()的Result实例保存了计算结果\",\"密封类的所有子类必须在一个文件(xx.kt)中，他的子类是有限的，所以当when()的时候不需要else。\",\"某种意义上他们像是一种enum class，只不过他的子类可以有多个实例。\",\"Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.\",\"//sealed class sealed class Player{ class Play(var arg:String) : Player() object Stop : Player() } class p2():Player() \",\"@Throws(RemoteException::class) fun getBookList():List<Book> \",\"out 协变，使用子类泛型的对象可以赋值给使用父类泛型的对象，相当于extend，用于方法的返回值（生产者）时使用\",\"in 逆变，使用父类泛型的对象可以赋值给使用子类泛型的对象，相当于super，用于方法的参数（消费者）时使用\",\"不变，当泛型即当消费者，又当生产者时，不用in或者out\",\"fun main(args: Array<String>) { val from = arrayOf(1,2,4) val to = arrayOf(Any()) copyArray(from,to) } fun copyArray(from: Array<out Any>, to: Array<in Int>) { //这里的from被out修饰，只能作为生产者调用get之类的方法，不能作为消费者调用set之类的方法 //... } \",\"你对类型参数一无所知，但仍然希望以安全的方式使用它。\",\"安全的使用，则表示该类Group<T>满足\",\"1.子类至少接收和父类一样范围的参数 >= ---> 父类入参为Noting 不能安全写入\",\"2.子类最多返回和父类一样范围的参数 <= ---> 父类出参为Any? 可以安全读取\",\"则有以下三种实现方式\",\"in-out-star-projection-approaches\",\"其中：\",\"Group<in Noting> 的fetch()方法一直返回Any?\",\"Group<out Any?> 的T需要与实际的Group的T保持一致，否则会报错\",\"Group<*> 既能insert正确返回对应的类型，也不用实时修改\",\"object TClass { fun readIn(group: Group<in Nothing>) { val d = group.fetch() } fun readOut(group: Group<out Animal>) { val d = group.fetch() } fun read(group: Group<*>) { val d = group.fetch() } } interface Group<T : Dog> { fun insert(member: T): Unit fun fetch(): T } \",\"委托是将重复出现的代码放到一个地方。\",\"委托示意图\",\"类委托 ：\",\"interface Interface { fun a() } class A : Interface class B(a: Interface) : Interface by a \",\"这样B便可以将Interface中方法的实现委托给类A的对象a\",\"委托属性：\",\"将同一类型的属性的get、set方法放到一个地方实现，可以在加入其它操作\",\"class Delegate { var name: String = \\\"\\\" operator fun getValue(clazz: Any?, property: KProperty<*>): String { println(\\\"get()\\\")//其它操作 return name } operator fun setValue(clazz: Any?, property: KProperty<*>, t: String) { println(\\\" set()\\\") name = t } } class ClassA { var name: String by Delegate() var age: String by Delegate() } \",\"委托类的初始化函数：\",\"fun <T> delegate(initializer: () -> T) = Delegate(initializer) class MyClass1 { var name: String by delegate { println(\\\"MyClass1.name init\\\") \\\"MyClass1\\\" } } class Delegate<T>(initializer: () -> T) { operator fun getValue(myClass1: T, property: KProperty<*>): String { println(\\\"$className get()\\\") return name } operator fun setValue(myClass1: T, property: KProperty<*>, t: String) { println(\\\"$className set()\\\") name = t } var name: String = \\\"\\\" var className = initializer() } \",\"Map委托：\",\"将类的属性名称和map中的key一一对应，从而将对于value赋值给属性\",\"class ClassB(map: Map<String, Any>) { val name: String by map val age: Int by map } fun main() { val map = mapOf(\\\"name\\\" to \\\"shany\\\", \\\"age\\\" to 18) val b = ClassB(map) print(b.name)//shayn print(b.age)//18 } \",\"veroable\",\"可以拦截赋值操作\",\"class ClassB() { var name:String by Delegates.vetoable(\\\"ThisIsInitialValue\\\"){ property, oldValue, newValue -> return@vetoable false //返回true允许更改值，false不允许更改 } } \",\"需要满足三个条件：\",\"成员函数或拓展函数\",\"只有一个参数\",\"infix声明\",\"infix fun String.div(string: String):String{ return this.replace(string,\\\"\\\") } 使用： val s = \\\"bababbaab\\\" div \\\"a\\\" \",\"inline修饰的函数在被调用时将字节码动态插入到被到调用的地方。\",\"inline修饰的函数的lambda参数如果运行在该函数内部的*子函数/其他环境*，则不允许这个lambda函数非局部返回（因为没有办法从该 子函数/其他环境 中直接退出lambda所在的外层函数），对于这种lambda函数需要添加**crossinline**修饰。\",\"//**非局部返回**指从lambda2中执行return语句，推出的是整个func() inline fun func1(crossinline lambda1:()->Unit, lambda2:()->Unit){ val f = Runnable { lambda1()//不可以调用非局部返回，所以用crossinline修饰 } lambda2()//可以调用非局部返回 } \",\"Kotlin也存在Java泛型所具有的类型擦除问题，为了优化该问题，inline函数可以结合reified实现实体化类型参数\",\"inline fun <reified T> isInstanceOf(value: Any) = value is T //在这里仍然可以知道T是什么类型的，所以可以执行value is T print(isInstanceOf<String>(\\\"\\\"))//true \",\"**原理:**内联函数会直接被插入到被调用的地方，而reified修饰的类型参数会保证将用户调用时写的类型String同时也写入到被调用的地方，如此便没有发生类型擦除。\",\"协程可以看做是一个轻量级的thread，他运行在线程当中，由用户控制，没有上下文切换的开销。\",\"在Android中使用协程，特别是在IO操作及网络请求等需要根据耗时操作更新界面的需求时，可以将IO操作和界面操作串行，避免切换线程、回调嵌套等导致代码可读性查的问题。\",\"如配合支持协程的retrofit，我们可以将网络请求简化如下：\",\" launch(Dispatchers.Main) { //这里是主线程 showProgressOnMainThread() val repos = withContext(Dispatchers.IO) { //这里是UI线程 retrofitApi.getRepos(\\\"jixiaoyong\\\").string() } //这里是主线程 updateUIOnMainThread(repos) } \",\"kotlin协程需要单独添加依赖：\",\"implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2' implementation \\\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2\\\" //Android可以再添加这个依赖，会有一些特殊方法 \",\"一个父协程总是等待所有的子协程执行结束， 父协程被取消的时候，所有它的子协程也会被递归的取消。\"]},\"323\":{\"h\":\"协程中 runBlocking 与 coroutineScope 的区别\",\"t\":[\"相同点：\",\"依次执行内部代码，如果代码1是启动协程，那么启动该子协程后，继续执行代码1后面的代码直到最后一行（类似启动新线程，不会阻塞当前线程），然后再等待所有内部协程结束，才会退出。\",\"不同点：\",\"runBlocking：会运行一个新的协程线程，并阻塞其所在线程,直到其内部所有协程/子协程执行完毕才会退出。设计用来以阻塞的方式执行协程代码，不应该在协程中使用。\",\"coroutineScope：不会阻塞其所在线程，要在协程中使用，当其内部所有协程/子协程执行完毕才会退出。设计用来执行并行操作，一旦有子协程失败，则其他子协程都会被取消，整个代码块执行失败。\"]},\"324\":{\"h\":\"协程的思维导图\",\"t\":[\"需要说明的是\",\"Dispatchers.Unconfined 非受限，不会限定协程运行的线程，而是随环境切换\",\" launch(Dispatchers.Unconfined) { // main thread withContext(newSingleThreadContext(\\\"hello\\\")){ //hello thread } //hello thread } \"]},\"325\":{\"h\":\"协程局部变量\",\"t\":[\"通过ThreadLocal、ThreadContextElement，配合asContextElement(\\\"value\\\")方法实现。和协程所在的线程没有关系。\",\"直接修改ThreadLocal的值，会在切换协程的时候失效（会被改为切换到的协程所使用的的值），当再次切回本协程时，被重置为上一个通过asContextElement(\\\"value\\\")方法更新的值或者null（如果没有指定）。\",\"原理：启动和恢复时保存ThreadLocal在当前线程的值，并修改为 value，挂起和结束时修改当前线程ThreadLocal的值为之前保存的值\",\"—— Kotlin Coroutines(协程) 完全解析（五），协程的并发\",\"val threadLocal = ThreadLocal<String?>() // 声明线程局部变量 fun main() = runBlocking<Unit> { threadLocal.set(\\\"main\\\") printValue(1) // main async (Dispatchers.Default + threadLocal.asContextElement(value = \\\"launch\\\")) { printValue(2) // launch threadLocal.set(\\\"hello\\\") // threadLocal.asContextElement(\\\"hello\\\") //如果使用这个方法更新，则 printValue(4) 会打印 hello printValue(3) // hello yield() printValue(4)// launch }.await() printValue(5) // main } fun printValue(number: Int){ println(\\\"$number: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\\\") } \"]},\"326\":{\"h\":\"在Android中使用\",\"t\":[\"Kotlin官方推荐一下两种方式：\",\"1. CoroutineScope class Activity : CoroutineScope by CoroutineScope(Dispatchers.Default) { // 继续运行…… 2. MainScope class Activity { private val mainScope = MainScope() fun destroy() { mainScope.cancel() } // 继续运行…… \",\"Star-Projections and How They Work\",\"Kotlin的独门秘籍Reified实化类型参数(下篇)\",\"Kotlin 协程官网\",\"Kotlin Coroutines(协程) 完全解析（五），协程的并发\"]},\"327\":{\"h\":\"Kotlin学习笔记3\",\"t\":[\"本文为笔记性质，尚未成文，待整理\",\"lazy方式创建一个序列，只有在访问的时候才生产对应的项目\",\"fun foo(): Sequence<Int> = sequence{ for (i in 1..3) { Thread.sleep(1000)//会阻塞调用线程 yield(i)//生产一个项目 } } \",\"使用Flow流在不阻塞主线程的情况下，延迟生产多个值并返回\",\"当流在一个可取消的挂起函数（例如 delay）中挂起的时候取消，否则不能取消。\",\"//flow 构建器中的代码直到流被收集的时候才运行，并且每次collect都会被启动 fun foo(): Flow<Int> = flow { // 流构建器 for (i in 1..3) { delay(100) // 假装我们在这里做了一些有用的事情，这里可以被取消 emit(i) // 发送下一个值 } } fun main() = runBlocking<Unit> { // 启动并发的协程以验证主线程并未阻塞 launch { for (k in 1..3) { println(\\\"I'm not blocked $k\\\") delay(100) } } // 收集这个流 foo().collect { value -> println(value) } } \",\"flowOf 构建器定义了一个发射固定值集的流。\",\"使用 .asFlow() 扩展函数，可以将各种集合与序列转换为流。\",\"可以使用操作符转换流，就像使用集合与序列一样。 过渡操作符应用于上游流，并返回下游流。 这些操作符也是冷操作符，就像流一样。这类操作符（map、fliter...）本身不是挂起函数，但是可以调用挂起函数suspend。它运行的速度很快，返回新的转换流的定义。\",\"在流转换操作符中，最通用的一种称为 transform。它可以用来模仿简单的转换，例如 map 与 filter，以及实施更复杂的转换。 使用 transform 操作符，我们可以 发射 任意值任意次\",\"限长过渡操作符（例如 take）在流触及相应限制的时候会将它的执行取消。\",\"fun numbers(): Flow<Int> = flow { try { emit(1) emit(2) println(\\\"This line will not execute\\\") emit(3) } finally { println(\\\"Finally in numbers\\\") } } fun main() = runBlocking<Unit> { numbers() .take(2) // 只获取前两个 .collect { value -> println(value) } } \",\"流构造器中的协程上下文默认和collect的协程上下文一致，如果强行转换上下文会出错。\",\"而使用flowOn()则可以指定流创建的协程上下文：\",\"fun foo(): Flow<Int> = flow { for (i in 1..3) { Thread.sleep(100) // 假装我们以消耗 CPU 的方式进行计算 log(\\\"Emitting $i\\\") emit(i) // 发射下一个值 } }.flowOn(Dispatchers.Default) // 在流构建器中改变消耗 CPU 代码上下文的正确方式 \",\"如果flow的生产和收集很消耗时间时，可以用buffer()函数将buffer()之前的代码在一个单独的协程运行，collect则在调用协程运行，这样将flow的构建、收集由串行转化为并行可以节约时间（如果构建运行的快，则会挂起直到collect赶上来）。\",\"It will use two coroutines for execution of the code. A coroutine Q that calls this code is going to execute collect, and the code before buffer will be executed in a separate new coroutine P concurrently with Q\",\" foo() .buffer() // buffer emissions, don't wait .collect { value -> delay(300) // pretend we are processing it for 300 ms println(value) } \",\"conflate operator can be used to skip intermediate values when a collector is too slow to process them.\",\"当collect比构建慢的时候，就只会请求最新的值，而跳过中间生产的这些值。\",\"比如，构建器生产了1，2，... ,100这些数，而collect读取的慢，第一次读的时候是1，等处理完再读取的时候构建器生产的是5，那么collect就读取5，中间的2，3，4都会被丢弃。\",\"Conflation is one way to speed up processing when both the emitter and collector are slow 。 The other way is to cancel a slow collector and restart it every time a new value is emitted.\",\"collectLatest可以保证每次都获取最新的值，如果collect比生产慢，那么当新的值生产出来时，collect会被取消，并且去处理最新的值。\",\"fun foo(): Flow<Int> = flow { for (i in 1..3) { delay(100) // pretend we are asynchronously waiting 100 ms emit(i) // emit next value } } fun main() = runBlocking<Unit> { val time = measureTimeMillis { foo() .collectLatest { value -> // cancel & restart on the latest value println(\\\"Collecting $value\\\") delay(300) // pretend we are processing it for 300 ms println(\\\"Done $value\\\") } } println(\\\"Collected in $time ms\\\") } //output Collecting 1 Collecting 2 Collecting 3 Done 3 Collected in 694 ms \",\"zip将两个流“压缩”为一个流：\",\" val number = (1..3).asFlow() val strs = flowOf(\\\"one\\\", \\\"two\\\", \\\"three\\\") number.zip(strs) { a, b -> \\\"$a -> $b\\\" }.collect{ println(\\\"$it\\\") } // output 1 -> one 2 -> two 3 -> three \",\"当 flow 表示变量或操作的最新值时(参见关于合并的相关章节) ，可能需要执行依赖于相应流的最新值的计算，并在任何上游流发出值时重新计算它。 相应的操作符族称为联合操作符 combine。即每个构建值发生变化时都会触发collect。\",\"val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms val strs = flowOf(\\\"one\\\", \\\"two\\\", \\\"three\\\").onEach { delay(400) } // strings every 400 ms val startTime = System.currentTimeMillis() // remember the start time nums.combine(strs) { a, b -> \\\"$a -> $b\\\" } // compose a single string with \\\"combine\\\" .collect { value -> // collect and print println(\\\"$value at ${System.currentTimeMillis() - startTime} ms from start\\\") } //output 1 -> one at 452 ms from start 2 -> one at 651 ms from start 2 -> two at 854 ms from start 3 -> two at 952 ms from start 3 -> three at 1256 ms from start \",\"flatMapConcat 可以将flow的内容“抹平”（即假设原先为Array<Array<Int>>，则押平后为：Array<Int>）。串行执行，即先执行代码块，然后对其flatMapConcat，然后collect，之后再执行下一轮的Flow项目。\",\"flatMapMerge 按顺序调用它的代码块 ，但是同时收集结果流，这相当于首先执行一个顺序映射 ，然后对结果调用 flattonmerge。并行执行，先依次对Flow项目调用代码块，然后哪个值先出来，就先对其调用 flatMapMerge，然后collect。\",\"flatMapLatest 类似 collectLatest ，每次新值出来就会取消还没有处理结束的旧流的操作。\",\"流的异常有如下捕获方式：\",\"try/catch block\",\"透明捕获 catch ，只会捕获发送在他之前的异常\"]},\"328\":{\"h\":\"声明式捕获 将collect的主要逻辑放到onEach中，保证onEach在catch之前\",\"t\":[\"foo() .onEach { value -> check(value <= 1) { \\\"Collected value\\\" } println(value) } .catch { e -> println(\\\"Caught e\\\") } .collect() \",\"try/finally\",\"onCompletion()\",\"foo() .onCompletion { println(\\\"Done\\\") } .collect { value -> println(value) } \",\"而且他还可以判断是否是异常退出。但是只是判断，并不会处理、拦截异常，并且只能处理上游的异常。\",\" foo() .onCompletion { cause -> if (cause != null) println(\\\"Flow completed exceptionally\\\") } .catch { cause -> println(\\\"Caught exception\\\") } .collect { value -> println(value) } \",\"collect后的代码只有在collect执行完后才能执行，而launchIn可以指定其在单独的协程程序中启动流的集合，从而不会阻塞当前协程。\",\"Channel 类似于BlockingQueue。但他的操作是挂起的。 Channel提供了在协程之间传递多个值的方法\",\"send 发送 缓存区已满或不存在时调用方会被挂起\",\"channel.receive() 接收\",\"channel.close() 关闭通道，表示没有更多的元素进入通道\",\"CoroutineScope.produce Launches new coroutine to produce a stream of values by sending them to a channel and returns a reference to the coroutine as a ReceiveChannel. This resulting object can be used to receive elements produced by this coroutine. 在新的协程中生产并返回了一个ReceiveChannel<T>对象。\",\"ReceiveChannel<E>.consumeEach 遍历ReceiveChannel的item执行指定action，并在块执行完毕后消耗掉这个ReceiveChannel（调用cancel()）。\",\"ReceiveChannel.cancel() 取消接收来自这个通道的剩余元素，关闭通道并从中删除所有缓存的元素。\",\"tickerChannel 定时返回Unit的channel：\",\" val tickerChannel = ticker(delayMillis = 1000, initialDelayMillis = 0) // 创建计时器通道 repeat(10) { println(tickerChannel.receive())// 每隔1s会打印一个kotlin.Unit } tickerChannel.cancel() // 表明不再需要更多的元素 \",\"Flow是用来异步返回多个值，其内部操作可以挂起\",\"Channel 用来在协程之间传递多个值（transfer a stream of values）\",\"Sequence 用来逐个在item中延迟执行完整操作，相比于list等整体执行完毕才进行下一级操作的“弓”字型，Sequence多级操作是逐个item依次完整执行多级操作的“几”字型。\",\"管道指：1.一个协程在流中开始生产无穷多个元素 2.另一个或多个协程消费这些流\",\"import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking { val numbers = produceNumbers() // 从 1 开始生产整数 val squares = square(numbers) // 对整数做平方 for (i in 1..5) println(squares.receive()) // 打印前 5 个数字 println(\\\"Done!\\\") // 我们的操作已经结束了 coroutineContext.cancelChildren() // 取消子协程 } fun CoroutineScope.produceNumbers() = produce<Int> { var x = 1 while (true) send(x++) // 从 1 开始的无限的整数流 } fun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce { for (x in numbers) send(x * x) } \",\"没有缓冲的通道： 如果发送先被调用，则它将被挂起直到接收被调用， 如果接收先被调用，它将被挂起直到发送被调用。\",\"带缓冲的通道： Channel() 工厂函数与 produce 建造器通过一个可选的参数 capacity 来指定 缓冲区大小 。缓冲允许发送者在被挂起前发送多个元素， 就像 BlockingQueue 有指定的容量一样，当缓冲区被占满的时候将会引起阻塞。\",\"val channel = Channel<Int>(4) // 启动带缓冲的通道 \",\"发送和接收操作是 公平的 并且尊重调用它们的多个协程。它们遵守先进先出原则。\",\"计时器通道是一种特别的会合通道，每次经过特定的延迟都会从该通道进行消费并产生 Unit 。如果在间隔还没到的时候调用tickerChannel.receive()则会返回null。产生的间隔由TickerModel控制\",\"val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0,mode = TickerMode.FIXED_PERIOD) //创建计时器通道 mode默认为TickerMode.FIXED_PERIOD tickerChannel.receive() //第一次调用立马返回Unit \",\"coroutineContext.cancelChildren() // 取消所有的子协程来让主协程结束\"]},\"329\":{\"h\":\"异常的传播\",\"t\":[\"协程构建器有两种风格：自动的传播异常（launch 以及 actor） 或者将它们暴露给用户（async 以及 produce）。 前者对待异常是不处理的，类似于 Java 的 Thread.uncaughtExceptionHandler， 而后者依赖用户来最终消耗异常，比如说，通过 await 或 receive\",\"CoroutineExceptionHandler 仅在预计不会由用户处理的异常上调用， 所以在 async 构建器中注册它没有任何效果。\",\"协程内部使用 CancellationException 来进行取消，这个异常会被所有的处理者忽略，所以那些可以被 catch 代码块捕获的异常仅仅应该被用来作为额外调试信息的资源。\",\"如果协程遇到除 CancellationException 以外的异常，它将取消具有该异常的父协程。 这种行为不能被覆盖，且它被用来提供一个稳定的协程层次结构来进行结构化并发而无需依赖 CoroutineExceptionHandler 的实现。 且当所有的子协程被终止的时候，原本的异常被父协程所处理。\",\"应该将CoroutineExceptionHandler 总是被设置在由 GlobalScope 启动的协程中。将异常处理者设置在 runBlocking 主作用域内启动的协程中是没有意义的，尽管子协程已经设置了异常处理者， 但是主协程也总是会被取消的。\",\"异常被抛出后，所有同级的子协程都会被关闭，然后异常传递给父协程，直到异常被处理。\",\"一个协程的多个子协程抛出异常将会发生什么？ 通常的规则是“第一个异常赢得了胜利“。\"]},\"330\":{\"h\":\"监督\",\"t\":[\"普通的取消 是一种双向机制，在协程的整个层次结构之间传播。\",\"SupervisorJob 它类似于常规的 Job， 但他的取消只会向下传播\",\"val supervisor = SupervisorJob()with(CoroutineScope(coroutineContext + supervisor)) { } supervisor取消的话，会取消掉所有子协程 \"]},\"331\":{\"h\":\"监督作业\",\"t\":[\"SupervisorJob 可以被用于这些目的。它类似于常规的 Job，唯一的不同是：SupervisorJob 的取消只会向下传播。这是非常容易从示例中观察到的：\"]},\"332\":{\"h\":\"监督作用域\",\"t\":[\"对于作用域的并发，supervisorScope 可以被用来替代 coroutineScope 来实现相同的目的。它只会单向的传播并且当子作业自身执行失败的时候将它们全部取消。它也会在所有的子作业执行结束前等待， 就像 coroutineScope 所做的那样。\"]},\"333\":{\"h\":\"监督协程中的异常\",\"t\":[\"常规的作业和监督作业之间的另一个重要区别是异常处理。 每一个子作业应该通过异常处理机制处理自身的异常。 这种差异来自于子作业的执行失败不会传播给它的父作业的事实。\"]},\"334\":{\"h\":\"协程的线程安全\",\"t\":[\"使用线程安全的数据结构\",\"var counter = AtomicInteger() withContext(Dispatchers.Default) { counter.incrementAndGet() } \",\"以细粒度限制线程\",\"以粗粒度限制线程\",\"2、3都是保证将对共享变量的操作限制在同一个线程中，从而保证线程安全。\",\"互斥\",\"类似于线程的锁，协程的 Mutex 的lock和unlock方法可以保证同一时间只有一个协程访问指定代码。Mutex不会阻塞线程。\",\"Actors\",\"一个 actor 是由协程、 被限制并封装到该协程中的状态以及一个与其它协程通信的 通道 组合而成的一个实体。\",\"// 这个函数启动一个新的计数器 actor fun CoroutineScope.counterActor() = actor<CounterMsg> { var counter = 0 // actor 状态 for (msg in channel) { // 即将到来消息的迭代器 when (msg) { is IncCounter -> counter++ is GetCounter -> msg.response.complete(counter) } } } //1.要递增状态时 counter.send(IncCounter) //2.要获取当前状态时 // 发送一条消息以用来从一个 actor 中获取计数值 val response = CompletableDeferred<Int>() counter.send(GetCounter(response)) println(\\\"Counter = ${response.await()}\\\") \",\"CompletableDeferred 通信原语表示未来可知（可传达）的单个值 。\",\"在使用时，由于actor 是一个协程， SendChannel .send() 方法会在通道缓存满的时候挂起调用方，从而最终保证了counter++方法是依次执行的，不会产生并发问题。\",\"actor 在高负载下比锁更有效，因为在这种情况下它总是有工作要做，而且根本不需要切换到不同的上下文。\",\"注意，actor 协程构建器是一个双重的 produce 协程构建器。一个 actor 与它接收消息的通道相关联，而一个 producer 与它发送元素的通道相关联。\",\"select 表达式允许我们使用其 onReceive 子句 同时 从两个生产者接收数据：\",\"suspend fun selectFizzBuzz(fizz: ReceiveChannel<String>, buzz: ReceiveChannel<String>) { select<Unit> { // <Unit> 意味着该 select 表达式不返回任何结果 fizz.onReceive { value -> // 这是第一个 select 子句 println(\\\"fizz -> '$value'\\\") } buzz.onReceive { value -> // 这是第二个 select 子句 println(\\\"buzz -> '$value'\\\") } } } \",\"onReceiveOrNull 可以允许为空，这样可以在关闭通道时执行特定操作\",\"onSend 子句 发送消息\",\"fun CoroutineScope.produceNumbers(side: SendChannel<Int>) = produce<Int> { for (num in 1..10) { // 生产从 1 到 10 的 10 个数值 delay(100) // 延迟 100 毫秒 select<Unit> { onSend(num) {} // 发送到主通道 side.onSend(num) {} // 或者发送到 side 通道 } } } \",\"Select延迟值可以使用 onAwait 子句查询\",\"Kotlin的独门秘籍Reified实化类型参数(下篇)\",\"Kotlin 协程 中文官网--异步流\"]},\"335\":{\"h\":\"Kotlin笔记之Flow\",\"t\":[\"Flow是Kotlin协程库中的库，用于异步返回多个值，官方介绍是参考RxJava等响应式流实现的，但是“拥有尽可能简单的设计， 对 Kotlin 以及挂起友好且遵从结构化并发”。本文主要参考Flow中文文档，梳理了学习过程中的要点和理解，以便日后查验。\",\"对于异步返回多个值的需求，集合（如List等）只能一次性返回多个值，而序列（ Sequence ）只支持阻塞代码，Flow则支持挂起函数异步返回多个值。\"]},\"336\":{\"h\":\"创建Flow\",\"t\":[\"flow{...}\",\"fun simple(): Flow<Int> = flow<Int> { for (i in 1..3) { delay(100) // 假装我们异步等待了 100 毫秒，也可以用Thread.sleep()但是会阻塞当前线程 emit(i) // 发射下一个值 } } \",\".asFlow()\",\"fun simple(): Flow<Int> = (1..10).asFlow() \",\"flowOf{}\",\"fun simple(): Flow<Int> = flowOf(1, 2, 3, 4, 5) \",\"因为流只会在被收集的时候才会被启动（指执行类似flow{...}中的内容），所以上述simple()在被调用时会尽快返回且不等待，所以无需suspend修饰。\"]},\"337\":{\"h\":\"流的收集/末端流操作符\",\"t\":[\"collect{...} 收集emit发送的值\",\"配合onEach{}可以将collect中执行的代码放到onEach中。\",\"collectLatest{...} 收集emit发送的值，但每次新的emit到来时，取消之前的收集器，创建新的收集器（用新的值执行{...}中的代码）\",\"launchIn 指定在单独的协程中启动流的收集，这样就可以立即继续进一步执行代码，不会挂起后面的协程代码。\",\"single() 只接受flow发送的一个值，0个或多个都会报错\",\"first{...} 查找符合条件的第一个值\",\"reduce() 求和\",\"fold(initial,{...}) 在初始值initial的基础上求和\",\"toList、toSet\"]},\"338\":{\"h\":\"过渡流操作符\",\"t\":[\"过渡操作符应用于上游流，并返回下游流。就像流一样。这类操作符本身不是挂起函数。它运行的速度很快，返回新的转换流的定义。\",\"map{}\",\"filter{}\",\"take(n) 限长操作符，只取前n个发射的值\"]},\"339\":{\"h\":\"流上下文\",\"t\":[\"流默认运行在收集器提供的上下文中，但是可以通过flowOn 更改：\",\"fun simple(): Flow<Int> = flow { ... }.flowOn(Dispatchers.Default) // 在流构建器中改变消耗 CPU 代码上下文的正确方式 \"]},\"340\":{\"h\":\"展平流\",\"t\":[\"将嵌套有Flow的Flow（如Flow<Flow<String>>）展平为单个流（如Flow<String>）。\",\"flatMapConcat 将收集到的流交给{...}处理后，等待内部流处理完毕后，再去请求下一个流\",\"flatMapMerge 先顺序收集所有流，再同时收集结果流\",\"flatMapLatest{...} 类似于collectLatest{...}，在新流发出的时候，立即取消{...}中所有的代码\",\"flattenConcat 依次展平流\",\"flattenMerge{...} 并发拼接，先执行{...}中的方法，再执行collect等方法，顺序会乱。\"]},\"341\":{\"h\":\"异常处理\",\"t\":[\"try/catch\",\"fun simple(): Flow<Int> = flow { for (i in 1..3) { println(\\\"Emitting $i\\\") emit(i) // 发射下一个值 } } fun main() = runBlocking<Unit> { try { simple().collect { value -> println(value) check(value <= 1) { \\\"Collected $value\\\" } } } catch (e: Throwable) { println(\\\"Caught $e\\\") } } \",\"catch()\",\"透明捕获：只捕获上游异常，其之后的异常不会被处理。\",\"simple() .catch { e -> emit(\\\"Caught $e\\\") } // 发射一个异常 .collect { value -> println(value) //此处如有异常，不会被catch捕获 } \",\"声明式捕获：将collect的代码移动到onEach中，将其放到catch之前，从而使其被catch捕获。\",\"simple() .onEach { value -> check(value <= 1) { \\\"Collected $value\\\" } //此处异常会被catch捕获 println(value) } .catch { e -> println(\\\"Caught $e\\\") } .collect() \"]},\"342\":{\"h\":\"流取消\",\"t\":[\"flow { ... } 创建的流的繁忙循环默认可以取消\",\"其他流如果需要取消，可以添加 .onEach { currentCoroutineContext().ensureActive() } 或者.cancellable()\"]},\"343\":{\"h\":\"流完成\",\"t\":[\"命令式\",\" try { simple().collect { value -> println(value) } } finally { println(\\\"Done\\\") //监听流完成 } \",\"声明式\",\"simple() .onCompletion { println(\\\"Done\\\") } //监听流完成，在collect执行结束后才执行 .collect { value -> println(value) } \",\"onCompletion的可空参数 Throwable 可以用于确定流收集是正常完成（为null）还是有异常发生。他不会处理异常。\"]},\"344\":{\"h\":\"其余操作\",\"t\":[\"buffer() 缓冲发射项，收集完成后再传给下一步\",\"conflate() 合并发射项，会丢弃来不及处理的中间值，只获取并处理最新的值\",\"zip() 合并两个流的值,两个流中的值一一对应\",\"例如(1,2,3) 3s发射一次,(a,b,c) 4s发射一次直接拼接，合并之后为 (1a,2b,3c)\",\"combine() 结合两个流的值，任意一个流中的值发生变化都会触发执行计算\",\"例如(1,2,3) 3s发射一次,(a,b,c) 4s发射一次直接拼接，合并之后为 (1a,2a,2b,3b,3c)\",\"Kotlin Flow 中文文档\"]},\"345\":{\"h\":\"Lambda表达式在kotlin中的应用\",\"t\":[\"普通写法：\",\"定义一个接口OnClickListener\",\"interface ClickListener{ fun onClick(view: View) } \",\"定义方法SetOnClickListener\",\"fun setOnCLickListener(listener: ClickListener){ this.listener = listener; } \",\"定义的方法和Java中写法类似，在使用该方法时也类似：\",\"var testInterface = TestInterface() testInterface.setOnCLickListener(object : TestInterface.ClickListener{ override fun onClick(view: View) { TODO(\\\"not implemented\\\") //To change body of created functions use File | Settings | File Templates. } }) \",\"lambda写法：\",\"定义只需要一步：\",\"//在初始化的时初始化listener class AClass(var listener : (uri:String) -> Unit){...} //或者直接定义这个变量 listener:((uri : String)-> Unit)? = null //在需要用到方法时，listener的方法，比如onClickListener(){} listener.invoke(agrs) \",\"使用起来也更加简洁：\",\"var t = TestInterface{ uri: String -> print(uri) }//获取对象的同时初始化listener \",\"方法最后一个参数是lambda表达式时，lambda表达式的方法{}可以放到()的后面，如果只有这一个参数时，()也可以省略\",\"当方法只有一个参数时，可以省略参数，还用it代替：\",\"testInterface.setNewOnClickListener { print(it) } \",\"甚至更加简洁，如果要执行的方法和listener定义的方法返回值类型相同，可以直接引用该方法：\",\"testInterface.setNewOnClickListener(::print) \",\"lambda在Java8中引进，可以很好的替代匿名内部类，使代码更加简洁。\",\"lambda表达式形式如下：\",\"val sum = { x: Int, y: Int -> x + y } \",\"lambda 表达式总是被大括号括着， 完整语法形式的参数声明放在大括号内，并有可选的类型标注， 函数体跟在一个 -> 符号之后。如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。\",\"kotlincn.net高阶函数和lambda表达式\",\"使用lambda的形式如下() -> {},()内是参数，{}是函数具体的行为。\",\"//Java 8方式： new Thread( () -> System.out.println(\\\"In Java8, Lambda expression rocks !!\\\") ).start(); \",\"这个例子来自importNew.com,Java8 lambda表达式10个示例\",\"xx.map()\",\"凡是可迭代的数据都可以使用map()函数\",\"var args: Array<String> = arrayOf() args.map { print(it) } \",\"还可以更简洁：\",\"args.map(::print) //::print表示引用该方法 \",\"xx.flatMap()\",\"返回可迭代的数组，可以和xx.map()一起使用\",\"args.flatMap { it.split(\\\" \\\") //把字符串按照\\\" \\\"切割 }.map{ print(\\\"${it.toUpperCase()}\\\") } \"]},\"346\":{\"h\":\"LeetCode笔记--重建二叉树\",\"t\":[\"二叉树的遍历根据根节点与左右子节点的遍历顺序的不同分为三种：\",\"前序遍历\",\"根左右：先遍历根节点，再左子树，再右子树（先从根节点开始，记录左节点直到没有）\",\"第一个为根节点\",\"中序遍历\",\"左根右：先左子树，再根子树，再右子树（从树的最左边的节点开始遍历）\",\"后序遍历\",\"左右根：先左子树，后右子树，再根节点\",\"最后一个为根节点\",\"在遍历的时候，当父节点只有一个子节点时，依然要遵循以上三种遍历的先后顺序（没有该子节点则不写内容），以保证某一侧的子树（“左边的子树”或“右边的子树”）所有节点都被完全遍历，之后才可以根据遍历的规则切换到下一子树。\",\"如如下子树：\",\" G / \\\\ D M / \\\\ / \\\\ A F H Z / E \",\"前序遍历：GDAFEMHZ\",\"中序遍历：ADEFGHMZ\",\"后续遍历：AEFDHZMG\",\"一般都是给定中序排序，再加上一个前序排序、后续排序来逆向生成二叉树。\",\"根据之前的知识，此类题的解答思路一般为：\",\"先根据前序排序、后续排序的特点，找到根节点，之后再根据找到的根节点将中序排序分为左、右子树两个部分。这样循环直到整个树的每个节点都被遍历完毕，完整的二叉树也会被建立起来。\",\"我们以下面这个二叉树为例：\",\" 1 / \\\\ 2 3 / \\\\ 4 5 \",\"使用代码表示如下：\",\"fun main() { val preorder = intArrayOf(1,2,3,4,5)//前序遍历 val inorder = intArrayOf(2,1,4,3,5)//中序遍历 val tree = buildTree(preorder, inorder) print(tree) } fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? { var tree : TreeNode? = null if (preorder.isNotEmpty()) { val root = preorder[0]//获取根节点 val indexOfRoot = inorder.indexOf(root)//获取中序排序中根节点的坐标 tree = TreeNode(root) //根据根节点坐标，将二叉树分为左、右两个子树 val leftTree = inorder.copyOfRange(0, indexOfRoot) val rightTree = inorder.copyOfRange(indexOfRoot + 1, inorder.size) //将前序排序也分为左右两个子树的前序排序 val leftPreOrder = preorder.copyOfRange(1, preorder.size).filter { leftTree.contains(it) }.toIntArray() val rightPreOrder = preorder.copyOfRange(1, preorder.size).filter { rightTree.contains(it) }.toIntArray() //再次分别循环分析左右两个子树的结构 tree.left = buildTree(leftPreOrder, leftTree) tree.right = buildTree(rightPreOrder, rightTree) } return tree } class TreeNode(var `val`: Int) { var left: TreeNode? = null var right: TreeNode? = null } \",\"https://www.jianshu.com/p/9e8922486154\",\"【直观算法】二叉树遍历算法总结\",\"知道中序和后序遍历，画二叉树和写出前序遍历 \",\"leetcode-重建二叉树\"]},\"347\":{\"h\":\"Linux下配置Git，使用AndroidStudio同步工程到Github\",\"t\":[\"这篇文章介绍了如何在 linux 环境下安装和配置 git 与 github ，并且使用 Android Studio 将本地的项目同步到 github 上面。\",\"sudo apt-gat install git \",\"创建 Github 账号\",\"生成 ssh key\",\"ssh-keygen -t rsa -C \\\"your_email@youremail.com \",\"在 github 上面添加 ssh key\",\"进入 Account Settings –> SSH Keys –> Add SSH Key 添加 SSH Keys ： 名字起一个容易识别的名字，key 是生成的 /home/username/.ssh/id_rsa.pub. 中的内容，直接粘贴到指定位置就行\",\"测试 ssh key 是否成功\",\"ssh -T git@github.com \",\"提示如You’ve successfully authenticated, but GitHub does not provide shell access则说明成功连接 github\",\"配置 Github\",\"git config --global user.name \\\"your name\\\" //配置用户名 git config --global user.email \\\"your email\\\" //配置email \",\"启动android studio\",\"进入android studio/bin，终端输入./studio.sh\",\"选择 VCS ---> Import into Version Control --> Share Project on Github\",\"第一次进入会要求输入 github 的账号和密码 按照要求输入即可 此后还会要求你输入一个本地密码，当下次同步的时候需要输入 之后就进入到选择同步的仓库，新建一个仓库，开始同步就可以了\",\"到这里就顺利的在 Android Studio 上面将工程同步到 Github 上面了\",\"以下为原文提到的其他方法，摘录如下，以备后用：\",\"第一步： 进入要所要上传文件的目录\",\"输入命令 git init\",\"第二步： 创建一个本地仓库 origin\",\"使用命令\",\"git remote add origin git@github.com:yourName/yourRepo.git \",\"youname是你的GitHub的用户名，yourRepo是你要上传到GitHub的仓库\",\"第三步： 比如你要添加一个文件xxx到本地仓库，使用命令 git add xxx，可以使用 git add . 自动判断添加哪些文件\",\"然后把这个添加提交到本地的仓库，使用命令 git commit -m说明这次的提交\",\"最后把本地仓库origin提交到远程的GitHub仓库，使用命令 git push origin master\",\"第一步： 到GitHub的某个仓库，然后复制右边的有个HTTPS clone url\",\"第二步： 回到要存放的目录下，使用命令 git clone https://github.com/chenguolin/scrapy.git，这里的url只是一个例子\",\"第三步： 如果本地的版本不是最新的，可以使用命令 git fetch origin，origin是本地仓库\",\"第四步： 把更新的内容合并到本地分支，可以使用命令 git merge origin/master\",\"如果你不想手动去合并，那么你可以使用：git pull <本地仓库> master // 这个命令可以拉去最新版本并自动合并\",\"创建\",\"1 创建一个本地分支： git branch <新分支名字>\",\"2 将本地分支同步到GitHub上面： git push <本地仓库名> <新分支名>\",\"3 切换到新建立的分支： git checkout <新分支名>\",\"4 为你的分支加入一个新的远程端： git remote add <远程端名字> <地址>\",\"5 查看当前仓库有几个分支: git branch\",\"删除\",\"1 从本地删除一个分支： git branch -d <分支名称>\",\"2 同步到GitHub上面删除这个分支： git push <本地仓库名> :<GitHub端分支>\",\"这篇文章是我今天在 linux 下安装 git ，上传工程到 github 上面时的步骤的总结，大部分内容都参考/摘录自下面这篇文章，感谢原作者的分享，原文信息及链接如下：\",\"Linux下Git和GitHub使用方法总结\\n[日期：2014-03-07] 来源：Linux社区 作者：chenguolinhttp://www.linuxidc.com/Linux/2014-03/97821.htm\"]},\"348\":{\"h\":\"Linux下配置JDK和AndroidStudio开发环境\",\"t\":[\"到官网下载 jdk\",\"下载到的 JDK 文件解压\",\"管理员权限进入 etc/environment 写入以下代码\",\"JAVA_HOME=\\\"JDK主目录的绝对路径\\\" \",\"打开终端执行以下命令：\",\"sudo update-alternatives --install /usr/bin/java java JDK主目录的绝对路径/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac JDK主目录的绝对路径/bin/javac 300 \",\"到这里 JDK 的环境就配置好了\",\"进入 android studio/bin 目录下，打开终端，\",\"输入 ./studio.sh\",\"到这里，就可以正常运行 android studio 了\"]},\"349\":{\"h\":\"Linux常用命令\",\"t\":[\"cp拷贝，rm删除，mv移动。\",\"-r表示递归 -f强制，无提示\",\"cp [-r] fromFilePath toFilePath rm [-r] fromFilePath toFilePath mv [-r] fromFilePath toFilePath \",\"cd - 返回上次所在目录 cd ~ 切换到当前用户home路径下 cd . 当前路径 cd .. 上层路径 cd ../linux 切换到同一级的linux目录 \",\"mkdir dirName 创建文件夹 touch fileName 创建文件 \",\"Linux文件和目录名字除了“/”都合法，但是尽量不要用正则表达式之类的符号，因为有可能会在进行正则匹配时造成误删等问题\",\"假设当前目录有文件f1,f2,f3和f[123] 执行：rm f[123]本来是希望删除f[123],但是由于正则匹配，会先删除f1,f2,f3这三个文件。\",\"file fileName 查看文件格式信息 cat fileName 以文本格式查看文件全部内容 less fileName 以分页形式查看文件内容，Q键退出 \",\"/home 当前用户主目录，root用户为/root /bin、/usr/bin 常用的可执行文件，root用户为/sbin /media、/mnt 用户硬件挂载点 /etc 系统的配置文件，所有用户可见，root用户可以更改 /boot 系统内核，开机必备文件 /dev 系统的所有设备文件，如硬盘、光驱等 /var和/srv 系统运行时的用户数据 /proc 内存中的状态信息 /lib、/usr/lib、/usr/local/lib 库文件 /temp 临时文件，所有用户可见 /usr 程序相关文件unix system resource \"]},\"350\":{\"h\":\"ls\",\"t\":[\"ls 展示当前目录下文件信息：\",\"ls [-alhd] l \",\"l展示目录下的文件列表，a 展示所有文件（包括隐藏文件）， h 展示带单位的文件大小， d展示当前目录本身信息\"]},\"351\":{\"h\":\"chmod\",\"t\":[\"chmod 更改权限\",\"chmod [-R] mode fileName \",\"mode组成如下：[范围] [操作] [权限]\",\"范围：u用户、g群组、o其他、a以上所有（ugo）\",\"操作：+ 增加、- 减去、= 等于\",\"权限：r 读权限4、 w 写权限2、 x 执行权限1 、无权限 0\",\"权限验证 ： root用户可以访问任何用户文件，不受权限限制；普通用户需要验证权限\",\"要读取文件夹中的内容，也需要执行权限x\"]},\"352\":{\"h\":\"文件权限与umask\",\"t\":[\"Linux创建新项目时默认的权限分别是：\",\"文件夹 777 文件 666 \",\"但是，经过umask（此处为0022）遮盖后，变成了755 ，644，这才是真正创建后的结果\",\"可以通过umask查看umask的值，一般只去其后3位，遮盖的原则是从原先的权限中减去umask中的权限：\",\"原始权限 ： r w x 7 umask ： - w x 3 结 果 ： r - - 4 \"]},\"353\":{\"h\":\"查看、管理当前用户信息\",\"t\":[\"users 和whoami输出当前用户名\",\"增、删、改用户：\",\"useradd / userdel / usermod username group群组管理也类似 groupadd / groupmod ... \",\"其中userdel -r username在删除用户时，也会删除用户对应的主目录home\",\"groups 查看用户所在群组，其中第一个是主要群组，其余是次要群组。\",\"主要群组 在用户创建新的文件时，文件群组权限一项默认为该群组\",\"who 、w可以查看用户相关信息\",\"id 查看某人或者自己相关的UID、GID\",\"finger [-s] username 查看用户相关信息 -s 仅显示用户账号、全名、登录时间 \",\"GID 系统 <500 ，用户 >500\"]},\"354\":{\"h\":\"改密码\",\"t\":[\"passwd username \"]},\"355\":{\"h\":\"文件打包、压缩和解压缩\",\"t\":[\".gz 压缩后格式，.tar 打包后格式，tar.gz先打包后压缩的格式（常用）\"]},\"356\":{\"h\":\"gzip\",\"t\":[\"gzip压缩会删除源文件,\",\"gzip [-cdtv#] filename \",\"# 压缩等级\",\"v 显示压缩前后压缩比\",\"t 校验是否是gzip压缩的文件\",\"c 压缩文件并输出到屏幕\",\"d 解压文件\",\"使用:\",\"gizp file 将file压缩成file.gz，会删除file gzip -c file > file.gz 压缩文件file并输出到file.gz \"]},\"357\":{\"h\":\"tar\",\"t\":[\"打包，在压缩文件夹时，一般为了效率都会先打包，在压缩，由此形成的格式一般是类似*.tar.gz*的后缀。\",\"打包 tar [-jcv] -f outFileName.tar inDirPath 解包 tar [-jxv] -f inFileName.tar -C outputPath \",\"c 建立打包文档\",\"x 解包 -C 输出目录\",\"t 查看打包文件的内容\",\"j / z 使用bz2 / gzip 压缩、解压\",\"v 输出信息\",\"f 后面紧跟要操作的文件\",\"bash是用户和内容交互的桥梁 用户 ↔ bash ↔ Unix内核\",\"env 查看环境变量\",\"type 查看类型\",\"which 查看指令的位置\",\"clear 、 cls 清屏\",\"bash shell 设置\"]},\"358\":{\"h\":\"自定义变量\",\"t\":[\"key=value 增加一个值为value的变量key\",\"其中，如果value有空格的话需要用引号包住：\",\"双引号 可以用$KEY 引用其他KEY的值 单引号 内容是纯文本 \",\"echo $KEY​ 可以输出KEY的值\",\"set 查看所有变量\",\"set | grep HIST 查看shell命令历史 set | grep PSI 提示符前面的内容，username-MBP:dirpath username$ \"]},\"359\":{\"h\":\"别名配置\",\"t\":[\"alias 查看所有别名\",\"alias newCmd=oldCmd使用newCmd表示oldCmd\",\"unalias newCmd 删除别名\",\"如:alias cls=clear,执行cls就等于执行clear\"]},\"360\":{\"h\":\"环境变量\",\"t\":[\"export KEY=VALUE 将值为VALUE的KEY添加到环境变量（本次shell有效）\",\"此外还可以写到一些文件中，在开机、登录、注销登录时调用执行——自动执行脚本**shell startup scripts**\"]},\"361\":{\"h\":\"shell startup scripts\",\"t\":[\"开机时执行：\",\"/etc/profile\",\"/ect/profile.d/*.sh\",\"~/.bash_profile , ~/.bash_login , ~/.profile这三个只要其中一个成功执行了，后面的就不会执行，~/.bash_profile会执行~/.bashrc\",\"/etc/.bashrc\",\"未登录时会执行：\",\"~/.bashrc\",\"/etc/bashrc\",\"/etc/profile.d/*.sh\",\"注销时执行~/bash_logout\",\"在修改了以上文件后，可以使用source path_to_file或者重新登录使其立即生效\",\"代码编号\",\"名称\",\"代码\",\"作用对象\",\"0\",\"标准输入\",\"stdin\",\"键盘等\",\"1\",\"标准输出\",\"stdout\",\"屏幕等\",\"2\",\"标准错误\",\"stderr\",\"屏幕等\",\"定向\",\"<和<< 输入和 追加输入\",\"> 和>> 输出 和追加输出\",\"使用：ls -al | >> result.txt将ls的内容追加输出到result.txt文件中。\",\"|叫做管道，可以将前者的标准输出当做后者的输入。\",\"cmd0 && cmd1 前者执行成功才会执行后者；\",\"cmd0 || cmd1 前者执行失败才会执行后者。\",\"查询内容\",\"grep [-cinv] 'key' filename \",\"c 计算次数\",\"i 忽略大小写\",\"n 行号\",\"v 显示没有该字符的行号\",\"'key' 可以是正则表达式\",\"--color=auto 对查找到的文本显示颜色\",\"排序，默认以第一列排序\",\"sort [-fbknrtu] filename \",\"f 忽略大小写\",\"b忽略最前面的空格（要是排序不生效时可以试一下，推荐）\",\"k 以第几列为标准排序，默认第一列\",\"n 以数组排序\",\"r 逆序\",\"t 待排序的文件的分隔符，默认是tab\",\"M 以英文月份排序\",\"统计字符数\",\"wc [lwm] filename \",\"l 行\",\"w 词\",\"m 字符\"]},\"362\":{\"h\":\"OKHttpUtils分析\",\"t\":[\"本文是对张鸿洋的OKHttp辅助类okhttputils简要分析，以便学习如何封装常见工具的思想，建议配合源码食用。\",\"主要涉及类：\",\"OkHttpUtils\",\"OkHttpRequestBuilder\",\"OkHttpRequest\",\"RequestCall\",\"Callback\",\"OkHttp是可以用于Android和Java的Http框架，经典的使用分为3步：\",\"//1. 创建一个OkHttpClient客户端，在这里配置网络超时等全局配置 OkHttpClient okHttpClient = new OkHttpClient(); //2. 创建一个网络请求，每个Http访问对应一个Request，详细配置了访问的URL，类型，参数等信息 Request request = new Request .Builder() .url(\\\"https://www.baidu.com\\\") .build(); //3. 使用OkHttpClient客户端创建Call并执行该网络请求，分为阻塞和异步两种方式，异步会有对应回调 okHttpClient.newCall(request) .enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { } }); \",\"虽然整体的逻辑已经很简单了，但是在实际使用的时候，不可能对每个网络请求都写一次上述代码，所以就需要对齐进行必要的封装以简化网络请求流程。\",\"okhttputils就做到了这一点，并且将上述第二步常见网络请求的过程也加入链式调用中，使用起来更加连贯：\",\"//1. 全局配置唯一的OkHttpClient OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(10000L, TimeUnit.MILLISECONDS) .readTimeout(10000L, TimeUnit.MILLISECONDS) .build(); OkHttpUtils.initClient(okHttpClient); //2.在需要网络请求的时候，执行对应代码 OkHttpUtils.get() .url(\\\"http://www.baidu.com\\\") .build() .execute(new com.zhy.http.okhttp.callback.Callback() { //回调方法 }); \",\"其中9~10行相当于OKHttp步骤2创建网络请求，11~14则就是步骤3执行网络请求的过程。\",\"每次使用网络请求时只需要选择get、post等方法获取并配置相应builder，然后选择execute执行即可。\",\"那么okhttputils是如何实现这一点的呢？\",\"首先看看OkHttpUtils的结构：\",\"可以看到大体上可以将其分为3个部分：\",\"OkHttpClient相关\",\"网络请求相关信息\",\"与具体执行网络请求有关的方法\"]},\"363\":{\"h\":\"OkHttpClient相关\",\"t\":[\"我们先来看第一部分，OkHttpUtils本质上只是对OkHttpClient的方法进行了一次封装，所以其肯定要持有OkHttpClient对象，一般来说一个APP只需要一个OkHttpClient对象即可，所以可以看到OkHttpUtils做了双重锁定的单例处理：\",\"public static OkHttpUtils initClient(OkHttpClient okHttpClient) { if (mInstance == null) { synchronized (OkHttpUtils.class) { if (mInstance == null) { mInstance = new OkHttpUtils(okHttpClient); } } } return mInstance; } \",\"这样我们在第一次使用OkHttpUtils的时候初始化的OkHttpClient便会被保存到这里，之后的使用中就不需要再去反复创建了。\",\"此外在OkHttpUtils的结构中可以注意到有一个mPlatform的变量，他会根据当前是Android还是其他平台的不同被初始化为Android主线程或者普通线程池，这个我们在后面回调网络请求状态的时候会用到。\",\"private Platform mPlatform = findPlatform(); private static Platform findPlatform() { try { Class.forName(\\\"android.os.Build\\\"); if (Build.VERSION.SDK_INT != 0) { return new Android(); } } catch (ClassNotFoundException ignored) { } return new Platform(); } \"]},\"364\":{\"h\":\"网络请求相关信息\",\"t\":[\"有了OkHttpClient对象之后，下一步便是创建一个适当的网络请求。\",\"在OkHttpUtils中使用的是OkHttpRequestBuilder <T extends OkHttpRequestBuilder>的子类来收集、配置相关的一些属性。\",\"在该类中，定义了一系列网络请求基本的参数：\",\"protected String url; protected Object tag; protected Map<String, String> headers; protected Map<String, String> params; protected int id; \",\"此外还有一个抽象方法，用来创建执行网络请求的RequestCall。\",\"public abstract RequestCall build(); \",\"这个方法在其子类中的实现一般是调用OkHttpRequest子类的build方法，可以看到OkHttpRequestBuilder只是将网络请求的相关参数传递到OkHttpRequest中。\",\"//com.zhy.http.okhttp.builder.GetBuilder @Override public RequestCall build() { if (params != null) { url = appendParams(url, params); } return new GetRequest(url, tag, params, headers,id).build(); } \",\"在OkHttpRequest中，利用上述的参数可以并通过generateRequest(Callback callback)方法创建Request。\",\"//com.zhy.http.okhttp.request.OkHttpRequest protected OkHttpRequest(String url, Object tag, Map<String, String> params, Map<String, String> headers,int id) { this.url = url; this.tag = tag; this.params = params; this.headers = headers; this.id = id ; if (url == null) { Exceptions.illegalArgument(\\\"url can not be null.\\\"); } initBuilder();//初始化okhttp3.Request.Builder用于生成Request } public Request generateRequest(Callback callback) { RequestBody requestBody = buildRequestBody(); RequestBody wrappedRequestBody = wrapRequestBody(requestBody, callback);//用于更新下载进度等，为okhttp3.Callback增加更多功能 Request request = buildRequest(wrappedRequestBody);//在子类中使用okhttp3.Request.Builder对象生成对应的Request return request; } \",\"这里的抽象方法wrapRequestBody()，buildRequest()的实现，也是OkHttpRequest各个子类主要的不同点。\",\"Callback是在okhttp3.Callback的基础上增加了before，progress和对请求结果的处理等的回调。\",\"OkHttpRequest类的build方法则只是将其自身传递给okhttp3.Call的封装类RequestCall，创建并返回该类的对象：\",\"//com.zhy.http.okhttp.request.OkHttpRequest public RequestCall build() { return new RequestCall(this); } \"]},\"365\":{\"h\":\"执行网络请求\",\"t\":[\"RequestCall类则是对okhttp3.Call类的进一步封装，对外提供更多的接口：开始、取消网络请求cancel(),readTimeOut()…等接口。\",\"当执行RequestCall的execute方法时：\",\"//com.zhy.http.okhttp.request.RequestCall public void execute(Callback callback) { buildCall(callback);//创建okhttp3.Call对象，其所用的Request对象来自于okHttpRequest.generateRequest(callback) if (callback != null) { callback.onBefore(request, getOkHttpRequest().getId()); } OkHttpUtils.getInstance().execute(this, callback); } \",\"可以看其最后只是将RequestCall和callback传递给了OkHttpUtils类的execute方法，也就是说，最终还是调用了okhttp3.Call的enqueue()方法，在这里执行了真正的网络请求：\",\"//com.zhy.http.okhttp.OkHttpUtils public void execute(final RequestCall requestCall, Callback callback) { if (callback == null) callback = Callback.CALLBACK_DEFAULT; final Callback finalCallback = callback; final int id = requestCall.getOkHttpRequest().getId(); requestCall.getCall().enqueue(new okhttp3.Callback() { @Override public void onFailure(Call call, final IOException e) { sendFailResultCallback(call, e, finalCallback, id); } @Override public void onResponse(final Call call, final Response response) { try { if (call.isCanceled()) { sendFailResultCallback(call, new IOException(\\\"Canceled!\\\"), finalCallback, id); return; } if (!finalCallback.validateReponse(response, id)) { sendFailResultCallback(call, new IOException(\\\"request failed , reponse's code is : \\\" + response.code()), finalCallback, id); return; } Object o = finalCallback.parseNetworkResponse(response, id); sendSuccessResultCallback(o, finalCallback, id); } catch (Exception e) { sendFailResultCallback(call, e, finalCallback, id); } finally { if (response.body() != null) response.body().close(); } } }); } \",\"而网络请求的回调，则是在本文最开始的mPlatform提供的线程中进行。这样保证了在Android中，onBefore、onAfter、inProgress等回调能够在UI线程进行。\",\"public void sendSuccessResultCallback(final Object object, final Callback callback, final int id) { if (callback == null) return; mPlatform.execute(new Runnable() { @Override public void run() { callback.onResponse(object, id); callback.onAfter(id); } }); } \",\"在本文中，okhttputils将初始化OkHttpClient的动作提取出来，这样同一个应用只需要在最开始的时候配置一下诸如网络超时、cookie等既可。\",\"在具体的实现中，通过OkHttpRequestBuilder收集网络请求的属性并传递给OkHttpRequest，在其子类中按照不同的需要实现生成Request的方法。\",\"OkHttpRequestBuilder的build()方法会生成RequestCall对象，RequestCall对象的execute()方法会调用OkHttpRequestBuilder对象的generateRequest()方法产生Request，并据此产生Call对象，最后通过该Call对象的enqueue方法执行网络请求。\"]},\"366\":{\"h\":\"Python自动创建发布hexo文章并同步github\",\"t\":[\"环境 linux(deepin)\",\"python 2.7\",\"这是一个Python脚本，用于实现hexo文章创建、生成网页并预览、发布到对应xxx.github.io博客的全过程。\"]},\"367\":{\"h\":\"使用时需要根据自己的项目更新main.py的一下变量：\",\"t\":[\"hexo_url = 'your_path/hexo/blog'\",\"【必需】本地hexo博客路径\",\"hexo_public_dir = 'your_path/hexo/blog/public'\",\"【必需】本地hexo博客输出路径\",\"hexo_post_dir = 'your_path/hexo/blog/source/_posts'\",\"【可选】本地hexo博客文章源文件路径\",\"git_dir = 'your_path/xxx.github.io'\",\"【必需】博客要同步的git工程路径\",\"git_backup_dir = 'your_path/xxx.github.io/blog/backup/sources/_posts'\",\"【可选】本路径用于备份post源文件到github\",\"hexo.py 中的post()方法中webbrowser.open('http://jixiaoyong.github.io/blog/')中的博客地址，发布完后默认打开该网页。（后期也可以改为post()参数传入，这样只需要更改main.py就行）\"]},\"368\":{\"h\":\"运行 main.py 文件\",\"t\":[\"在Linux命令行输入如下命令，并回车，根据提示操作即可。\",\"python main.py \",\"​ Windows下可以运行start.cmd脚本（待实现）\",\"//start.cmd脚本内容 python main.py cmd \",\"操作过程提示及说明如下：（渣英语请忽略...）\",\"input yout file name 输入要发布的文章名称xxx（当前版本暂不支持中文）\",\"输入回车会自动创建xxx.md文件并打开（需要系统支持该格式）\",\"are you finish your post 输入y或n，选择是否用hexo编译文章\",\"y:编译文章 n:不编译文章，退出命令行\",\"post or not 输入y或n，选择是否发布文章到网站,可以在打开的页面预览后做决定\",\"y:发布文章 n:不发布文章，退出命令行\",\"update post 《xxx》 提示开始发布文章，自动打开网页，并保存源文件\",\"源代码已经上传github\",\"增加文件名中文支持\",\"增加图片自动上传、替换为github链接(2018/2/2已实现)\"]},\"369\":{\"h\":\"Python入门知识\",\"t\":[\"基于Python3.x\",\"Python文件默认格式.py\",\"首行默认以下命令：\",\"#!/usr/bin/python # -*- coding: UTF-8 -*- \",\"数字\",\"整数int 1，2，3\",\"长整数long 1112L\",\"浮点数float （小数）1.23，3.14\",\"复数complex 3.14j\",\"字符串\",\"'abc'，\\\"abc\\\"，'''abc‘’‘\",\"'x'和\\\"x\\\" 区别不大\",\"'''abc‘’‘ 文本可以跨行\",\"字符串前面加r或者R表示字符串内部不需要转义，否则要用\\\\ 转义\",\"支持a[0]取值\",\"布尔值\",\"True 和False\",\"布尔值可以用and、or和not运算\",\"空值\",\"None\",\"变量\",\"命名规则：开头aA_，其后可以包含aA_1\",\"常量\",\"不能变的变量\",\"列表list\",\"[1,2,3,3]\",\"插入list.insert(1,'vaule')\",\"删除list.pop() / list.pop(1)\",\"**元组tuple **\",\"(1,2,3,3)\",\"与列表类似，但是一旦初始化就不能再修改\",\"字典dict\",\"键值对，读取快，相当于java的map\",\"set\",\"set([1,2,3])\",\"键的集合，不能有重复的，相当于java的set\",\"if ... : ... elif ... : ... else : ...\",\"for x in xs : ...\",\"while x : ...\",\"def fun(n) return n \",\"return\",\"可以没有return，默认返回None\",\"可以return 多个值，实际上返回的是一个tuple\",\"pass\",\"不想执行任何语句，但是为了符合语法规范，可以用pass当做占位符\",\"def fun() pass \",\"抛出异常\",\"raise TypeError('an error') \",\"其中TypeError需要继承自error或者Exception\",\"参数\",\"位置参数\",\"def fun(arg) pass \",\"默认参数\",\"def fun(arg0,arg1 = 1) pass \",\"注意 默认参数必须是参数中后面的几位；默认值必须不可变，如int，string等\",\"可变参数\",\"def fun(arg,*args) pass \",\"*args 表示参数个数可变，可以输入list/tuple等，或者依次输入多个参数，用逗号分隔\",\"关键词参数\",\"def fun(arg,**keywords) if 'city' in kw: pass \",\"**keywords 表示接受关键词作为参数传入，可以传入dict，或者依次输入多个关键词参数\",\"命名关键词参数\",\"def fun0(args,*，name,age) pass def fun1(arg.*args,name,age)#如果命名关键词前面有可变参数，则不用*分隔 pass \",\"限制输入的关键字，限制只有name和age作为关键词参数\",\"#使用时 sys.fun() import sys #使用时直接fun() from xxFile import fun form sys import * form sys import fun \",\"定义类\",\"class AClass(object): '''doc for AClass you can use this by AClass.__doc__''' def __init__(self): #默认的初始化方法 pass def aFun(self): pass #创建类对象 a = AClass() #调用方法 a.aFun() \",\"所有的类方法必须至少有一个参数，推荐命名为self，系统会自动传入类对象，无需手动传入。\",\"继承\",\"class Father(object): def __init__(self): print(\\\"father\\\") def say(self): print(\\\"i am f\\\") class Child(Father): def __init__(self): #子类方法不会自己调用父类方法，需要手动调用 super(Child,self).__init__() #调用父类方法2： #Father.__init__(self) print(\\\"child\\\") def say(self): print('i am c') def go(self,where): print('go to %s'%where) c = Child() #father child c.say() #i am c c.go('home') #go ro home \",\"子类继承父类，则需要在子类定义时传入父类\",\"子类如果有与父类同名方法，则优先调用子类方法，除非子类特别调用父类的方法\"]},\"370\":{\"h\":\"Python爬取gityuan所有文章列表\",\"t\":[\"更新内容：\",\"爬取gityuan.com网站所有文章列表并输出json\",\"汇总信息输出config.json为后面的客户端做准备\",\"更新文件：\",\"spider_main.py\",\"html_output.py\",\"gityuan_urls.py\",\"html_downloader.py\",\"spider_main.py\",\"作为入口类，主要增加了初始化所有URL，以及便利这些URL的功能。\",\"sp = SpiderMain() gityuan = gityuan_urls.GitYuanUrls() gityuan_urls = gityuan.get_urls(17) file_name = 'gityuan_page_' sp.craw(gityuan_urls,file_name) \",\"其craw()方法修改如下：\",\"from time import sleep def craw(self, root_urls, file_name): #将所有有效链接全部加入 self.urls.add_new_urls(root_urls) i = 0 #循环遍历这些链接 while self.urls.has_next(): i = i + 1 new_url = self.urls.get_new_url() html_cont = self.downloader.download(new_url) new_url, new_data = self.parser.parse(new_url, html_cont) self.output.collect_data(new_data) new_file_name = file_name + ('%d.json'%i) self.output.output_html(new_file_name) #等待3s，防止太频繁访问被识别 sleep(3) #结束遍历，输出汇总信息 self.output.end(file_name,root_urls[0],i) \",\"html_output.py\",\"主要改动如下：\",\"output_html(self,file_name)方法增加一个file_name的参数，并在内部调用self.mkdir()方法生成output目录，方便同时输出多个文档\",\"mkdir()方法，创建文件\",\"end(self,file_name_start, url, num)方法，输出汇总文档，代码如下\",\" def end(self,file_name_start, url, num): self.mkdir() file_name = self.output_dir + 'config.json' file_out = open(file_name,'w') current_time = time.time() config_str = ('{\\\"url\\\":\\\"%s\\\",\\\"total\\\":\\\"%d\\\",\\\"update_time\\\":\\\"%d\\\",\\\"file_name\\\":\\\"%s\\\"}' % (url,num,current_time,file_name_start)) file_out.write(config_str) \",\"gityuan_urls.py\",\"主要代码如下，通过循环遍历获取所有文章列表信息\",\"class GitYuanUrls(object): \\\"\\\"\\\"docstring for GitYuanUrls\\\"\\\"\\\" def get_urls(self, num): urls = [] urls.append('http://www.gityuan.com') for x in xrange(1,num): url_ = ('http://www.gityuan.com/page%d/'%x) urls.append(url_) return urls \",\"html_downloader.py\",\"就在本文编辑的过程中，爬虫被识别，并且限制访问文件数量，所以对下载功能做了简单的伪装、增加超时处理。\",\"def download2(self, url): #升级版 if url is None: return None #伪装为浏览器 req_header = {'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36'} try: request = urllib2.Request(url,None,req_header) response = urllib2.urlopen(request,None,300) return response.read() except socket.timeout as e: #超时处理 print(type(e)) return None \",\"当前爬虫主体功能以及实现，可以爬取gityuan.com所有有效文章列表，可以满足客户端需求。但仍然存在以下问题：\",\"没有伪装，爬虫很容易被识别并被拒绝服务（就在刚刚写下这句话的时候，就发生了被限制访问，真*乌鸦嘴）。\",\"由于原网站特性，其置顶文章每页都有，会导致部分数据重复。\",\"未爬取具体文章内容。\",\"说明\",\"本文只为学术研究，其中涉及到的第三方网站及其所有资源均属原主所有。向gityuan大神致敬，欢迎访问其blog。\",\"github链接\",\"tag为gityuan_spider1.5\"]},\"371\":{\"h\":\"Python爬虫爬取gityuan.com数据并输出json\",\"t\":[\"本文基于Python2.7\",\"这篇文章基于我在慕课网上面学习Python简单爬虫写的内容，教程内容是爬取1000条百度百科的数据，但是教程中爬虫截止2018-01-27已经失效，刚好看到大神gityuan.com的内容，于是用Python实现爬取其网页内容并生成json数据。\",\"本文即上述过程整理。\",\"本文涉及源代码已上传github（点这里查看）。\",\"爬虫主要活动是：\",\"爬取目标网页内容\",\"对获取到的内容进行分析，获取有用数据\",\"将处理好的数据按格式输出\",\"此外还需要有一个专门管理爬虫活动的主类，故而文件结构如下：\",\"spider_main.py 入口类\",\"url_manager.py 管理要下载的链接\",\"html_downloader.py 下载网页内容\",\"html_paeser.py 对获取到的数据进行解析、加工\",\"html_out.py 输出格式化的数据\",\"目前只实现了爬取gityuan.com第一页内容并输出json，所以暂时不需要实现url_manager.py\",\"spider_main.py\",\"#导入用到的各个类 import html_downloader ... #定义入口类 class SpiderMain(object): def __init__(self): #初始化各个变量downloader、parser、output... self.downloader = html_downloader.HtmlDownloader() #略 def craw(self,root_url): html_cont = self.downloader.download(root_url) new_data = self.parser.parse(html_cont) self.output.collect_data(new_data) self.output.output_json() root_url = 'http://www.gityuan.com/' sp = SpiderMain() sp.craw(root_url) \",\"在__init__() 方法初始化各个变量；\",\"在craw()中分别实现下载、解析网页内容、输出加工数据\",\"html_download.py\",\"import urllib2 class HtmlDownLoader(object): def download(self,url): if url is None: return None respone = urllib2.urlopen(url,timeout=300) if respone.getcode() != 200: return None return respone.read() \",\"下载并返回网页内容，比较简单\",\"html_parser.py\",\"import urlparse from bs4 import BeautifulSoup #第三方包，需要单独下载 import re class HtmlParser(object): def parse(self,html_cont): if html_cont is None: return #用BeautifulSoup解析文档内容 soup = BeautifulSoup(html_cont,'html.parser') res_data = [] #数组 #获取所有的文章节点nodes post_div_nodes = soup.find_all('div',class_='post-preview') #遍历nodes，读取每一项内容并保存 for post_div_node in post_div_nodes: post_div_soup = BeautifulSoup(str(post_div_node)) post_info = {} #字典dict #判断URL是否是完整 url_ = post_div_soup.a['href'] if 'http://' not in url_: url_ = \\\"http://gityuan.com\\\" + url_ #保存数据 post_info['url'] = url_ post_info['title'] = post_div_soup.find('h2').get_text() post_info['summary'] = post_div_soup.find('div',class_='post-content-preview').get_text() res_data.append(post_info) return res_data \",\"这是爬虫功能的重点之一：对网页数据进行解析，由此数据才变为可用数据\",\"主要是通过第三方插件BeautifulSoup解析数据，并保存到数组res_data中，具体见代码中实现\",\"html_output.py\",\"import sys #下面两行代码解决编码问题，强制使用utf-8，而非默认的unicode编码 reload(sys) sys.setdefaultencoding('utf-8') class JsonOutput(object): def __init__(self): self.datas = [] def collect_data(self,new_data): if new_data is not None: self.datas.append(new_data) def output_json(self): #打开文件，并以json格式输出 fout = open('output.json','w') fout.write('{') fout.write(r'\\\"data\\\":[') for data in self.datas: for post_info in data: fout.write('{') fout.write('\\\"url\\\":\\\"%\\\",' % post_info['url']) fout.write('\\\"title\\\":\\\"%\\\",' % post_info['title']) fout.write('\\\"summary\\\":\\\"%\\\",' % post_info['summary']) fout.write('},') #为了符合json规范，最后一个输入空数据，无末尾逗号 fout.write(r'{}') fout.write(']}') \",\"本类也很重要，主要是数据存取，以及将解析好的数据格式化输出\",\"本文中代码经二次处理，不一定与源代码一致，但思路如此，以供参考。\"]},\"372\":{\"h\":\"Dart Isolate源码分析\",\"t\":[\"💡 本文基于Dart 2.17.1\",\"Isolate, an isolated Dart execution context.\",\"All Dart code runs in an isolate, and code can access classes and values only from the same isolate. Different isolates can communicate by sending values through ports (see ReceivePort, SendPort).\",\"In Dart an isolate has its own event loop, its own global fields, can run in parallel with other isolates and have their own live-cycle. — https://github.com/dart-lang/sdk/issues/36097#issuecomment-746510375\",\"The new isolate has its own memory and its own thread working in parallel with the main isolate.\",\"https://www.youtube.com/watch?v=NoVYI94MJio&ab_channel=Flutterly\",\"https://www.youtube.com/watch?v=NoVYI94MJio&ab_channel=Flutterly\",\"Isolate创建会占用内存，可以使用IsolateGroup来解决，并且目前为止Dart和Flutter都默认支持在使用Isolate.spawn创建新Isolate的时候使用IsolateGroup（Isolate.spwanUri创建的时候会创建单独的IsolateGroup和Isolate）。\",\"💡 在创建isolate的时候可以添加addOnExitListener 或者addErrorListener之类的监听，但是可能在执行添加代码的时候isolate就已经终止了而导致这些方法收不到回调。 为了避免这种情况，可以在创建isolate的时候指定他的状态为**paused**。\",\"与isolate有关的类有：\",\"Isolate 位置在sdk\\\\lib\\\\isolate\\\\isolate.dart。主要是Isolate 通用方法、属性的抽象描述，没有具体实现。\",\"Isolate 位置在sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\isolate_patch.dart，是app等平台对应的具体实现，部分方法调用了native层的Isolate实现。\",\"Isolate 位置在runtime\\\\vm\\\\isolate.h以及runtime\\\\vm\\\\isolate.cc中，是Isolate的native层实现。\",\"他们的关系大致如图：\",\"Untitled\"]},\"373\":{\"h\":\"创建新Isolate的方式:\",\"t\":[\"Isolate(``SendPort controlPort``, {this.pauseCapability, this.terminateCapability}); 这种方式创建一种能力受限的Isolate。The capabilities should be the subset of the capabilities that are available to the original isolate.本质上并没有在native层孵化一个新的Isolate。\",\"var newIsolate = Isolate(Isolate.current.controlPort); newIsolate.addOnExitListener(Isolate.current.controlPort); newIsolate.addErrorListener(Isolate.current.controlPort); Future.delayed(Duration(seconds: 1),(){ newIsolate.kill(); print(\\\"try kill new isolate\\\"); // after this，the dart code finish }); print(\\\"finish\\\"); \",\"Isolate.spawn(``void entryPoint(T message), T message,...) 创建一个和当前Isolate共享同一份代码的Isolate，并执行entryPoint方法，一般在message中传入SendPort以便从entryPoint中向来时的Isolate发送消息，新建的Isolate和当前Isolate在同一个IsolateGroup中。\",\"void spawnIsolate() { var receivePort = ReceivePort(); receivePort.listen((message) { print(\\\"receivePort(${Isolate.current.debugName}) received msg: $message\\\"); }); //创建一个和当前的isolate共享同一份代码的Isolate var isolate = Isolate.spawn((message) { print(\\\"Isolate initial function(${Isolate.current.debugName}) received msg: $message\\\"); (message as SendPort).send(\\\"HELLO_FORM_ISOLATE(${Isolate.current.debugName})\\\"); }, receivePort.sendPort,debugName: \\\"another_isolate\\\"); } \",\"Isolate.spawnUri（Uri uri,List<String> args,var message,...）* 指定的uri中创建并孵化一个isolate，执行uri对应的library中的main方法（0~2个入参），并传入无参、args或message作为参数\",\"var receivePort = ReceivePort(); receivePort.listen((message) { print(\\\"receivePort(${Isolate.current.debugName}) received msg: $message\\\"); }); // 创建一个和当前的isolate共享同一份代码的Isolate var isolate = await Isolate.spawnUri( Uri.file( r\\\"E:\\\\workspace\\\\others\\\\flutter_dart_source_code_analysis\\\\lib\\\\dart\\\\another_dart_file_to_spawn_uri.dart\\\"), [], receivePort.sendPort, debugName: \\\"another_isolate\\\"); Future.delayed(const Duration(seconds: 2), () { receivePort.close(); isolate.kill(priority: Isolate.immediate); print(\\\"try kill new isolate\\\"); }); \"]},\"374\":{\"h\":\"使用方法\"},\"375\":{\"h\":\"pause\",\"t\":[\"Capability pause([Capability? resumeCapability])，暂停Isolate，停止从*event loop queue* 中取（并处理）消息，但是依然可以往里面加入消息\",\"resumeCapability 是用来区分pause的，必须使用同一个*resumeCapability*来resume isolate。\",\"使用同一个*resumeCapability*多次pause，只需一次resume就可以恢复isolate\",\"使用不同*resumeCapability多次pause，必须使用对应的resumeCapability依次resume才可以恢复isolate （注意：这里也只需要使用当时pause isolate的resumeCapability* 依次调用resume即可，而不用保持次数一致，比如，有2个*resumeCapability ，*调用pause次数分别为a 1,b 2，那么要想resume isolate，也只需要分别使用a,b调用一次resume即可）\"]},\"376\":{\"h\":\"ping\",\"t\":[\"使用isolate往receivePort.sendPort发送response消息，即使isolate当前被pause也可以正常发送\",\"isolate.pause(); isolate.ping(receivePort.sendPort, response: \\\"is isolate resume?\\\");//receivePort依然可以收到消息 \",\"ping可以正常发送的原因是：\",\"// -> lib\\\\isolate\\\\isolate.dart // ping方法是一个external方法 external void ping(SendPort responsePort, {Object? response, int priority = immediate}); // -> sdk/lib/_internal/vm/lib/isolate_patch.dart @patch void ping(SendPort responsePort, {Object? response, int priority: immediate}) { var msg = new List<Object?>.filled(5, null) ..[0] = 0 // Make room for OOM message type. ..[1] = _PING ..[2] = responsePort ..[3] = priority ..[4] = response; _sendOOB(controlPort, msg); } @pragma(\\\"vm:external-name\\\", \\\"Isolate_sendOOB\\\") external static void _sendOOB(port, msg); // -> runtime/lib/isolate.cc // 创建了一个oob消息并压入oob_queue_ DEFINE_NATIVE_ENTRY(Isolate_sendOOB, 0, 2) { GET_NON_NULL_NATIVE_ARGUMENT(SendPort, port, arguments->NativeArgAt(0)); GET_NON_NULL_NATIVE_ARGUMENT(Array, msg, arguments->NativeArgAt(1)); // Make sure to route this request to the isolate library OOB mesage handler. msg.SetAt(0, Smi::Handle(Smi::New(Message::kIsolateLibOOBMsg))); // Ensure message writer (and it's resources, e.g. forwarding tables) are // cleaned up before handling interrupts. { PortMap::PostMessage(WriteMessage(/* can_send_any_object */ false, /* same_group */ false, msg, port.Id(), Message::kOOBPriority)); } // Drain interrupts before running so any IMMEDIATE operations on the current // isolate happen synchronously. const Error& error = Error::Handle(thread->HandleInterrupts()); if (!error.IsNull()) { Exceptions::PropagateError(error); UNREACHABLE(); } return Object::null(); } \",\"在MessageHandler中有两种MessageQueue：oob_queue_和queue_ ，前者优先级高，即使isolate被pause也会执行\",\"// -> runtime\\\\vm\\\\message_handler.h // 普通消息，暂停时不能处理 MessageQueue* queue_; // 优先消息，即使处理消息时，优先处理obb_queue消息，如果为空再去考虑处理普通消息 // 即使isolate被pause也可以被处理 MessageQueue* oob_queue_; \",\"像是ping/kill/pause/addOnExitListener/removeOnExitListener这些指令消息都是压入到obb_queue_中优先处理的。\",\"先看一下常用的几个方法是怎么实现的。\"]},\"377\":{\"h\":\"获取当前Isolate\",\"t\":[\"（sdk/lib/isolate/isolate.dart）Isolate.current →\",\"(sdk/lib/_internal/vm/lib/isolate_patch.dart) Isolate get current → Isolate._getCurrentIsolate() → _getPortAndCapabilitiesOfCurrentIsolate()\",\"（runtime/lib/isolate.cc）DEFINE_NATIVE_ENTRY(Isolate_getPortAndCapabilitiesOfCurrentIsolate, 0, 0)\",\"先看一下sdk/lib/_internal/vm/lib/isolate_patch.dart中的实现：\",\"// -> sdk/lib/_internal/vm/lib/isolate_patch.dart static final _currentIsolate = _getCurrentIsolate(); @patch static Isolate get current => _currentIsolate; static Isolate _getCurrentIsolate() { List portAndCapabilities = _getPortAndCapabilitiesOfCurrentIsolate(); // 这里的参数分别是SendPort，Capability，Capability return new Isolate(portAndCapabilities[0], pauseCapability: portAndCapabilities[1], terminateCapability: portAndCapabilities[2]); } @pragma(\\\"vm:external-name\\\", \\\"Isolate_getPortAndCapabilitiesOfCurrentIsolate\\\") external static List _getPortAndCapabilitiesOfCurrentIsolate(); \",\"可以看到，最后是根据native端返回的信息，新建了一个Isolate引用，但是因为_currentIsolate是static final的，所以只会被调用一次，确保了在Dart SDK中调用Isolate.current 时获取的是当前唯一的Isolate。\",\"让我们看一下在native中是如何找到当前的Isolate的：\",\"// -> \\\\runtime\\\\lib\\\\isolate.cc DEFINE_NATIVE_ENTRY(Isolate_getPortAndCapabilitiesOfCurrentIsolate, 0, 0) { const Array& result = Array::Handle(Array::New(3)); result.SetAt(0, SendPort::Handle(SendPort::New(isolate->main_port()))); result.SetAt( 1, Capability::Handle(Capability::New(isolate->pause_capability()))); result.SetAt( 2, Capability::Handle(Capability::New(isolate->terminate_capability()))); return result.ptr(); } \",\"可见是直接取的当前线程对应的isolate对应的值，经过包装再返回到调用方。\"]},\"378\":{\"h\":\"创建Isolate\",\"t\":[\"在Dart中创建Isolate有3种方式：\",\"Isolate(this.controlPort, {this.pauseCapability, this.terminateCapability});create anisolate，本质上只是将controlPort 等设置为传入的对象，并没有在native层新建Isolate\",\"Isolate.spawncreate and spawns an isolate\",\"Isolate.spawnUricreate and spawns an isolate\",\"这里分析一下后面两种方式，对比一下差异：\",\"// -> sdk\\\\lib\\\\isolate\\\\isolate.dart // Creates a new [Isolate] object with a restricted set of capabilities. Isolate(this.controlPort, {this.pauseCapability, this.terminateCapability}); /// Creates and spawns an isolate that shares the same code as the current /// isolate. external static Future<Isolate> spawn<T>( void entryPoint(T message), T message, {bool paused = false, bool errorsAreFatal = true, SendPort? onExit, SendPort? onError, @Since(\\\"2.3\\\") String? debugName}); /// Creates and spawns an isolate that runs the code from the library with /// the specified URI. /// /// The isolate starts executing the top-level `main` function of the library /// with the given URI. external static Future<Isolate> spawnUri( Uri uri, List<String> args, var message, {bool paused = false, SendPort? onExit, SendPort? onError, bool errorsAreFatal = true, bool? checked, Map<String, String>? environment, @Deprecated('The packages/ dir is not supported in Dart 2') Uri? packageRoot, Uri? packageConfig, bool automaticPackageResolution = false, @Since(\\\"2.3\\\") String? debugName}); \",\"对于APP等来说，上述Isolate.spawn和Isolate.spawnUri的实现都在vm下面的isolate_patch.dart中（js会返回_unsupported()）：\",\"// -> sdk\\\\lib\\\\_internal\\\\vm\\\\lib\\\\isolate_patch.dart @patch static Future<Isolate> spawn<T>(void entryPoint(T message), T message, {bool paused = false, bool errorsAreFatal = true, SendPort? onExit, SendPort? onError, String? debugName}) async { // `paused` isn't handled yet. // Check for the type of `entryPoint` on the spawning isolate to make // error-handling easier. if (entryPoint is! _UnaryFunction) { throw new ArgumentError(entryPoint); } // The VM will invoke [_startIsolate] with entryPoint as argument. // We do not inherit the package config settings from the parent isolate, // instead we use the values that were set on the command line. ... final RawReceivePort readyPort = new RawReceivePort(null, 'Isolate.spawn ready'); try { **_spawnFunction**(readyPort.sendPort, script.toString(), entryPoint, message, paused, errorsAreFatal, onExit, onError, packageConfig, debugName); return await **_spawnCommon**(readyPort); } catch (e, st) { readyPort.close(); return await new Future<Isolate>.error(e, st); } } @patch static Future<Isolate> spawnUri(Uri uri, List<String> args, var message, {bool paused = false, SendPort? onExit, SendPort? onError, bool errorsAreFatal = true, bool? checked, Map<String, String>? environment, Uri? packageRoot, Uri? packageConfig, bool automaticPackageResolution = false, String? debugName}) async { // Verify that no mutually exclusive arguments have been passed. ... // Resolve the uri against the current isolate's root Uri first. ... // The VM will invoke [_startIsolate] and not `main`. final packageConfigString = packageConfig?.toString(); final RawReceivePort readyPort = new RawReceivePort(null, 'Isolate.spawnUri ready'); try { **_spawnUri**( readyPort.sendPort, spawnedUri.toString(), args, message, paused, onExit, onError, errorsAreFatal, checked, null, /* environment */ packageConfigString, debugName); return await **_spawnCommon**(readyPort); } catch (e) { readyPort.close(); rethrow; } } // Isolate.spawn call @pragma(\\\"vm:external-name\\\", \\\"Isolate_spawnFunction\\\") external static void _spawnFunction( SendPort readyPort, String uri, Function topLevelFunction, var message, bool paused, bool errorsAreFatal, SendPort? onExit, SendPort? onError, String? packageConfig, String? debugName); // Isolate.spawnUri call @pragma(\\\"vm:external-name\\\", \\\"Isolate_spawnUri\\\") external static void _spawnUri( SendPort readyPort, String uri, List<String> args, var message, bool paused, SendPort? onExit, SendPort? onError, bool errorsAreFatal, bool? checked, List? environment, String? packageConfig, String? debugName); // 监听Isolate spawn状态，等成功之后将其处理后返回给Dart层的调用者 static Future<Isolate> _spawnCommon(RawReceivePort readyPort) { final completer = new Completer<Isolate>.sync(); readyPort.handler = (readyMessage) { readyPort.close(); if (readyMessage is List && readyMessage.length == 2) { SendPort controlPort = readyMessage[0]; List capabilities = readyMessage[1]; **completer.complete(new Isolate(controlPort, pauseCapability: capabilities[0], terminateCapability: capabilities[1]));** } else if (readyMessage is String) { // We encountered an error while starting the new isolate. completer.completeError(new IsolateSpawnException( 'Unable to spawn isolate: ${readyMessage}')); } else { // This shouldn't happen. completer.completeError(new IsolateSpawnException( \\\"Internal error: unexpected format for ready message: \\\" \\\"'${readyMessage}'\\\")); } }; return completer.future; } \",\"其实，根据上述的代码，不管是Isolate.spawnUri() 还是Isolate.spawn，都是先调用RawReceivePort获取RawReceivePort readyPort，最后都是调用了_spawnCommon(readyPort) 方法，最终通过new Isolate(controlPort, pauseCapability: capabilities[0], terminateCapability: capabilities[1])方法创建了新的Isolate 。\",\"这个方法的定义在sdk/lib/isolate/isolate.dart中：\",\"// -> sdk/lib/isolate/isolate.dart final SendPort controlPort; Isolate(this.controlPort, {this.pauseCapability, this.terminateCapability}); \",\"可以看到，在Dart中，我们拿到的Isolate主要是持有一个和native中对应SendPort。\",\"通过上面的分析：\",\"Isolate.spawn最后调用了_spawnFunction方法（native层实现为Isolate_spawnFunction）；\",\"Isolate.spawnUri最后调用了_spawnUri方法（native层实现为Isolate_spawnUri）。\",\"💡 new RawReceivePort()方法主要是创建一个不存在于_RawReceivePortImpl的static final _portMap = <int, Map<String, dynamic>>{}; 中的SendPort（具体实现在PortMap::CreatePort中）。\"]},\"379\":{\"h\":\"Isolate_spawnFunction\",\"t\":[\"Isolate.spawn最后调用了_spawnFunction方法，来看一下对应的Isolate_spawnFunction 的实现：\",\"// -> runtime\\\\lib\\\\isolate.cc DEFINE_NATIVE_ENTRY(Isolate_spawnFunction, 0, 10) { // 解析参数 ... // closure_tuple_handle对应我们在Dart中Isolate.spawn()中传入的entryPoint // 也就是isolate创建好以后执行的方法 std::unique_ptr<IsolateSpawnState> state(new IsolateSpawnState( port.Id(), isolate->origin_id(), String2UTF8(script_uri), closure_tuple_handle, &message_buffer, utf8_package_config, paused.value(), fatal_errors, on_exit_port, on_error_port, utf8_debug_name, **isolate->group()**)); // Since this is a call to Isolate.spawn, copy the parent isolate's code. state->isolate_flags()->copy_parent_code = true; **isolate->group()**->thread_pool()->Run<SpawnIsolateTask>(isolate, std::move(state)); return Object::null(); } \",\"可见，Isolate_spawnFunction方法中主要还是解析收到的各种参数，最后在当前isolate对应的IsolateGroup的线程池中执行SpawnIsolateTask：\"]},\"380\":{\"h\":\"SpawnIsolateTask\",\"t\":[\"// -> runtime\\\\lib\\\\isolate.cc class SpawnIsolateTask : public ThreadPool::Task { SpawnIsolateTask(Isolate* parent_isolate, std::unique_ptr<IsolateSpawnState> state) : parent_isolate_(parent_isolate), state_(std::move(state)) { parent_isolate->IncrementSpawnCount(); } void Run() override { const char* name = (state_->debug_name() == nullptr) ? state_->function_name() : state_->debug_name(); ASSERT(name != nullptr); auto group = state_->isolate_group(); if (group == nullptr) { RunHeavyweight(name); } else { RunLightweight(name); } } } \"]},\"381\":{\"h\":\"RunLightWeight\",\"t\":[\"因为这里我们的isolate→group不为空，所以走的是RunLightWeight:\",\"// -> runtime\\\\lib\\\\isolate.cc void RunLightweight(const char* name) { // The create isolate initialize callback is mandatory. auto initialize_callback = **Isolate::InitializeCallback();** if (initialize_callback == nullptr) { FailedSpawn( \\\"Lightweight isolate spawn is not supported by this Dart embedder\\\\n\\\", /*has_current_isolate=*/false); return; } char* error = nullptr; auto group = state_->isolate_group(); **Isolate* isolate = CreateWithinExistingIsolateGroup(group, name, &error);** parent_isolate_->DecrementSpawnCount(); parent_isolate_ = nullptr; if (isolate == nullptr) { FailedSpawn(error, /*has_current_isolate=*/false); free(error); return; } void* child_isolate_data = nullptr; **const bool success = initialize_callback(&child_isolate_data, &error);** if (!success) { FailedSpawn(error); Dart_ShutdownIsolate(); free(error); return; } **isolate->set_init_callback_data(child_isolate_data); // 注意这里的Run方法，在**RunHeavyweight方法的最后也调用了 // 到时候会一起分析一下 **Run(isolate);** } // -> runtime\\\\vm\\\\dart_api_impl.cc Isolate* CreateWithinExistingIsolateGroup(IsolateGroup* group, const char* name, char** error) { API_TIMELINE_DURATION(Thread::Current()); CHECK_NO_ISOLATE(Isolate::Current()); auto spawning_group = group; **Isolate* isolate =** reinterpret_cast<Isolate*>( **CreateIsolate**(spawning_group, /*is_new_group=*/false, name, /*isolate_data=*/nullptr, error)); if (isolate == nullptr) return nullptr; // 因为执行到这里的都有IsolateGroup，共享同一份代码 auto source = spawning_group->source(); ASSERT(isolate->source() == source); return isolate; } \",\"这里主要进行了2步：\",\"使用CreateWithinExistingIsolateGroup创建Isolate\",\"使用全局的initialize_callback （也就是Isolate::InitializeCallback()）初始化Isolate\"]},\"382\":{\"h\":\"Isolate::InitializeCallback()\",\"t\":[\"这其中的Isolate::InitializeCallback()是在Dart::Init的时候就已经设置了的：\",\"// -> runtime/bin/main.cc void main(int argc, char** argv) { ... // Initialize the Dart VM. Dart_InitializeParams init_params; init_params.version = DART_INITIALIZE_PARAMS_CURRENT_VERSION; init_params.vm_snapshot_data = vm_snapshot_data; init_params.vm_snapshot_instructions = vm_snapshot_instructions; **init_params.create_group = CreateIsolateGroupAndSetup;** **init_params.initialize_isolate = OnIsolateInitialize;** init_params.shutdown_isolate = OnIsolateShutdown; init_params.cleanup_isolate = DeleteIsolateData; init_params.cleanup_group = DeleteIsolateGroupData; init_params.file_open = DartUtils::OpenFile; init_params.file_read = DartUtils::ReadFile; init_params.file_write = DartUtils::WriteFile; init_params.file_close = DartUtils::CloseFile; init_params.entropy_source = DartUtils::EntropySource; error = Dart_Initialize(&init_params); } // -> runtime\\\\vm\\\\dart_api_impl.cc DART_EXPORT char* Dart_Initialize(Dart_InitializeParams* params) { if (params == NULL) { return Utils::StrDup( \\\"Dart_Initialize: \\\" \\\"Dart_InitializeParams is null.\\\"); } if (params->version != DART_INITIALIZE_PARAMS_CURRENT_VERSION) { return Utils::StrDup( \\\"Dart_Initialize: \\\" \\\"Invalid Dart_InitializeParams version.\\\"); } return Dart::Init(params); } // -> runtime\\\\vm\\\\dart.cc char* Dart::Init(const Dart_InitializeParams* params) { if (!init_state_.SetInitializing()) { return Utils::StrDup( \\\"Bad VM initialization state, \\\" \\\"already initialized or \\\" \\\"multiple threads initializing the VM.\\\"); } char* retval = DartInit(params); if (retval != NULL) { init_state_.ResetInitializing(); return retval; } init_state_.SetInitialized(); return NULL; } char* Dart::DartInit(const Dart_InitializeParams* params) { ... OSThread::Init(); Zone::Init(); IsolateGroup::Init(); Isolate::InitVM(); PortMap::Init(); Service::Init(); ... Thread::ExitIsolate(); // Unregister the VM isolate from this thread. **Isolate::SetCreateGroupCallback(params->create_group);** **Isolate::SetInitializeCallback_(params->initialize_isolate);** Isolate::SetShutdownCallback(params->shutdown_isolate); Isolate::SetCleanupCallback(params->cleanup_isolate); Isolate::SetGroupCleanupCallback(params->cleanup_group); Isolate::SetRegisterKernelBlobCallback(params->register_kernel_blob); Isolate::SetUnregisterKernelBlobCallback(params->unregister_kernel_blob); ... } \",\"也就是说，上文的Isolate::InitializeCallback()实际上就是OnIsolateInitialize，它的主要作用就是在isolate创建好之后进行统一的初始化操作，绑定一些数据：\",\"// -> runtime\\\\bin\\\\main.cc static bool OnIsolateInitialize(void** child_callback_data, char** error) { Dart_Isolate isolate = Dart_CurrentIsolate(); ASSERT(isolate != nullptr); auto isolate_group_data = reinterpret_cast<IsolateGroupData*>(Dart_CurrentIsolateGroupData()); auto isolate_data = new IsolateData(isolate_group_data); *child_callback_data = isolate_data; Dart_EnterScope(); const auto **script_uri** = isolate_group_data->script_url; const bool **isolate_run_app_snapshot** = isolate_group_data->RunFromAppSnapshot(); Dart_Handle **result** = SetupCoreLibraries(isolate, isolate_data, /*group_start=*/false, /*resolved_packages_config=*/nullptr); if (Dart_IsError(result)) goto failed; if (isolate_run_app_snapshot) { result = Loader::InitForSnapshot(script_uri, isolate_data); if (Dart_IsError(result)) goto failed; } else { result = DartUtils::ResolveScript(Dart_NewStringFromCString(script_uri)); if (Dart_IsError(result)) goto failed; if (isolate_group_data->kernel_buffer() != nullptr) { // Various core-library parts will send requests to the Loader to resolve // relative URIs and perform other related tasks. We need Loader to be // initialized for this to work because loading from Kernel binary // bypasses normal source code loading paths that initialize it. const char* resolved_script_uri = NULL; result = Dart_StringToCString(result, &resolved_script_uri); if (Dart_IsError(result)) goto failed; result = Loader::InitForSnapshot(resolved_script_uri, isolate_data); if (Dart_IsError(result)) goto failed; } } Dart_ExitScope(); return true; failed: *error = Utils::StrDup(Dart_GetError(result)); Dart_ExitScope(); return false; } \"]},\"383\":{\"h\":\"CreateWithinExistingIsolateGroup\",\"t\":[\"CreateWithinExistingIsolateGroup → CreateIsolate\",\"再看一下创建Isolate的具体方法，这个在不同的device上面不一样，我们只关注vm下面的实现：\",\"// -> runtime\\\\vm\\\\dart_api_impl.cc static Dart_Isolate CreateIsolate(IsolateGroup* group, bool is_new_group, const char* name, void* isolate_data, char** error) { **CHECK_NO_ISOLATE**(Isolate::Current()); auto source = group->source(); **Isolate* I = Dart::CreateIsolate(name, source->flags, group);** if (I == NULL) { if (error != NULL) { *error = Utils::StrDup(\\\"Isolate creation failed\\\"); } return reinterpret_cast<Dart_Isolate>(NULL); } Thread* T = Thread::Current(); bool success = false; { StackZone zone(T); // We enter an API scope here as InitializeIsolate could compile some // bootstrap library files which call out to a tag handler that may create // Api Handles when an error is encountered. T->EnterApiScope(); const Error& error_obj = Error::Handle( Z, **Dart::InitializeIsolate( source->snapshot_data, source->snapshot_instructions, source->kernel_buffer, source->kernel_buffer_size, is_new_group ? nullptr : group, isolate_data)**); if (error_obj.IsNull()) { #if defined(DEBUG) && !defined(DART_PRECOMPILED_RUNTIME) if (FLAG_check_function_fingerprints && !FLAG_precompiled_mode) { Library::CheckFunctionFingerprints(); } #endif // defined(DEBUG) && !defined(DART_PRECOMPILED_RUNTIME). success = true; } else if (error != NULL) { *error = Utils::StrDup(error_obj.ToErrorCString()); } // We exit the API scope entered above. T->ExitApiScope(); } if (success) { if (is_new_group) { group->heap()->InitGrowthControl(); } // A Thread structure has been associated to the thread, we do the // safepoint transition explicitly here instead of using the // TransitionXXX scope objects as the reverse transition happens // outside this scope in Dart_ShutdownIsolate/Dart_ExitIsolate. T->set_execution_state(Thread::kThreadInNative); T->EnterSafepoint(); if (error != NULL) { *error = NULL; } return Api::CastIsolate(I); } Dart::ShutdownIsolate(); return reinterpret_cast<Dart_Isolate>(NULL); } \",\"这里主要有两步：\",\"Dart::CreateIsolate创建了Isolate* I；\",\"然后调用Dart::InitializeIsolate初始化isolate。\",\"Dart::CreateIsolate：\",\"// -> runtime\\\\vm\\\\dart.cc Isolate* Dart::CreateIsolate(const char* name_prefix, const Dart_IsolateFlags& api_flags, IsolateGroup* isolate_group) { // Create a new isolate. Isolate* isolate = Isolate::InitIsolate(name_prefix, isolate_group, api_flags); return isolate; } \",\"💡 在Dart虚拟机启动（Dart::DartInit）的时候，也会调用Dart::InitIsolate创建虚拟机对应的Isolate，执行UI操作：vm_isolate_ = Isolate::InitIsolate(kVmIsolateName, group, api_flags, is_vm_isolate);\",\"在Isolate::InitIsolate方法中，先是用isolate_group创建了新的Isolate，然后将其与Thread，MessageHandler，SendPort等绑定：\",\"// -> runtime\\\\vm\\\\isolate.cc Isolate* Isolate::InitIsolate(const char* name_prefix, IsolateGroup* isolate_group, const Dart_IsolateFlags& api_flags, bool is_vm_isolate) { // 创建新的Isolate **Isolate* result = new Isolate(isolate_group, api_flags);** result->BuildName(name_prefix); if (!is_vm_isolate) { // vm isolate object store is initialized later, after null instance // is created (in Dart::Init). // Non-vm isolates need to have isolate object store initialized is that // exit_listeners have to be null-initialized as they will be used if // we fail to create isolate below, have to do low level shutdown. ASSERT(result->group()->object_store() != nullptr); result->isolate_object_store()->Init(); } ASSERT(result != nullptr); #if !defined(PRODUCT) // Initialize metrics. #define ISOLATE_METRIC_INIT(type, variable, name, unit) \\\\ result->metric_##variable##_.InitInstance(result, name, NULL, Metric::unit); ISOLATE_METRIC_LIST(ISOLATE_METRIC_INIT); #undef ISOLATE_METRIC_INIT #endif // !defined(PRODUCT) // First we ensure we enter the isolate. This will ensure we're participating // in any safepointing requests from this point on. Other threads requesting a // safepoint operation will therefore wait until we've stopped. // // Though the [result] isolate is still in a state where no memory has been // allocated, which means it's safe to GC the isolate group until here. // 创建一个Thread并和当前isolate绑定 if (!**Thread::EnterIsolate(result)**) { delete result; return nullptr; } // Setup the isolate message handler. MessageHandler* handler = new IsolateMessageHandler(result); ASSERT(handler != nullptr); // 在这里绑定了message handler **result->set_message_handler(handler);** **result->set_main_port(PortMap::CreatePort(result->message_handler()));** #if defined(DEBUG) // Verify that we are never reusing a live origin id. VerifyOriginId id_verifier(result->main_port()); Isolate::VisitIsolates(&id_verifier); #endif result->set_origin_id(result->main_port()); result->set_pause_capability(result->random()->NextUInt64()); result->set_terminate_capability(result->random()->NextUInt64()); #if !defined(PRODUCT) result->debugger_ = new Debugger(result); #endif // Now we register the isolate in the group. From this point on any GC would // traverse the isolate roots (before this point, the roots are only pointing // to vm-isolate objects, e.g. null) **isolate_group->RegisterIsolate(result);** if (ServiceIsolate::NameEquals(name_prefix)) { ASSERT(!ServiceIsolate::Exists()); ServiceIsolate::SetServiceIsolate(result); #if !defined(DART_PRECOMPILED_RUNTIME) } else if (KernelIsolate::NameEquals(name_prefix)) { ASSERT(!KernelIsolate::Exists()); KernelIsolate::SetKernelIsolate(result); #endif // !defined(DART_PRECOMPILED_RUNTIME) } if (FLAG_trace_isolates) { if (name_prefix == nullptr || strcmp(name_prefix, \\\"vm-isolate\\\") != 0) { OS::PrintErr( \\\"[+] Starting isolate:\\\\n\\\" \\\"\\\\tisolate: %s\\\\n\\\", result->name()); } } // Add to isolate list. Shutdown and delete the isolate on failure. if (!TryMarkIsolateReady(result)) { result->LowLevelShutdown(); Isolate::LowLevelCleanup(result); return nullptr; } return result; } \",\"Dart::InitializeIsolate\",\"这里主要是对isolate进行初始化，并在初始化完成后通知创建这个isolate的isolate。\",\"// -> runtime\\\\vm\\\\dart.cc ErrorPtr Dart::InitializeIsolate(const uint8_t* snapshot_data, const uint8_t* snapshot_instructions, const uint8_t* kernel_buffer, intptr_t kernel_buffer_size, IsolateGroup* source_isolate_group, void* isolate_data) { // Initialize the new isolate. Thread* T = Thread::Current(); Isolate* I = T->isolate(); auto IG = T->isolate_group(); #if defined(SUPPORT_TIMELINE) TimelineBeginEndScope tbes(T, Timeline::GetIsolateStream(), \\\"InitializeIsolate\\\"); tbes.SetNumArguments(1); tbes.CopyArgument(0, \\\"isolateName\\\", I->name()); #endif ASSERT(I != NULL); StackZone zone(T); HandleScope handle_scope(T); bool was_child_cloned_into_existing_isolate = false; if (source_isolate_group != nullptr) { // If a static field gets registered in [IsolateGroup::RegisterStaticField]: // // * before this block it will ignore this isolate. The [Clone] of the // initial field table will pick up the new value. // * after this block it will add the new static field to this isolate. { SafepointReadRwLocker reader(T, source_isolate_group->program_lock()); **I->set_field_table**(T, source_isolate_group->initial_field_table()->Clone(I)); **I->field_table()->MarkReadyToUse();** } was_child_cloned_into_existing_isolate = true; } else { const Error& error = Error::Handle( // 从IsolateGroup中引用一些通用的变量（常量等等） **InitIsolateFromSnapshot**(T, I, snapshot_data, snapshot_instructions, kernel_buffer, kernel_buffer_size)); if (!error.IsNull()) { return error.ptr(); } } Object::VerifyBuiltinVtables(); if (T->isolate()->origin_id() == 0) { DEBUG_ONLY(IG->heap()->Verify(kForbidMarked)); } #if defined(DART_PRECOMPILED_RUNTIME) const bool kIsAotRuntime = true; #else const bool kIsAotRuntime = false; #endif if (kIsAotRuntime || was_child_cloned_into_existing_isolate) { #if !defined(TARGET_ARCH_IA32) ASSERT(IG->object_store()->build_generic_method_extractor_code() != Code::null()); ASSERT(IG->object_store()->build_nongeneric_method_extractor_code() != Code::null()); #endif } else { #if !defined(TARGET_ARCH_IA32) if (I != Dart::vm_isolate()) { if (IG->object_store()->build_generic_method_extractor_code() != nullptr) { SafepointWriteRwLocker ml(T, IG->program_lock()); if (IG->object_store()->build_generic_method_extractor_code() != nullptr) { IG->object_store()->set_build_generic_method_extractor_code( Code::Handle( StubCode::GetBuildGenericMethodExtractorStub(nullptr))); } } if (IG->object_store()->build_nongeneric_method_extractor_code() != nullptr) { SafepointWriteRwLocker ml(T, IG->program_lock()); if (IG->object_store()->build_nongeneric_method_extractor_code() != nullptr) { IG->object_store()->set_build_nongeneric_method_extractor_code( Code::Handle( StubCode::GetBuildNonGenericMethodExtractorStub(nullptr))); } } } #endif // !defined(TARGET_ARCH_IA32) } I->set_ic_miss_code(StubCode::SwitchableCallMiss()); Error& error = Error::Handle(); if (snapshot_data == nullptr || kernel_buffer != nullptr) { error ^= IG->object_store()->PreallocateObjects(); if (!error.IsNull()) { return error.ptr(); } } const auto& out_of_memory = Object::Handle(IG->object_store()->out_of_memory()); error ^= I->isolate_object_store()->PreallocateObjects(out_of_memory); if (!error.IsNull()) { return error.ptr(); } if (!was_child_cloned_into_existing_isolate) { IG->heap()->InitGrowthControl(); } I->set_init_callback_data(isolate_data); if (FLAG_print_class_table) { IG->class_table()->Print(); } #if !defined(PRODUCT) ServiceIsolate::MaybeMakeServiceIsolate(I); if (!Isolate::IsSystemIsolate(I)) { I->message_handler()->set_should_pause_on_start( FLAG_pause_isolates_on_start); I->message_handler()->set_should_pause_on_exit(FLAG_pause_isolates_on_exit); } #endif // !defined(PRODUCT) ServiceIsolate::SendIsolateStartupMessage(); #if !defined(PRODUCT) I->debugger()->NotifyIsolateCreated(); #endif // Create tag table. I->set_tag_table(GrowableObjectArray::Handle(GrowableObjectArray::New())); // Set up default UserTag. const UserTag& default_tag = UserTag::Handle(UserTag::DefaultTag()); I->set_current_tag(default_tag); I->init_loaded_prefixes_set_storage(); return Error::null(); } \",\"可以看到，如果是调用Isolate.spawn()的话，先从当前isolate获取对应的Isolate Group，然后使用这个Isolate Group创建配置一个新的isolate，这样在同一个isolate group中的Isolate可以共享常量，heap等。\"]},\"384\":{\"h\":\"Isolate_spawnUri\",\"t\":[\"如果是使用Isolate.spawnUri()的话，就会通过Isolate_spawnUri来创建isolate。\",\"// -> runtime\\\\lib\\\\isolate.cc DEFINE_NATIVE_ENTRY(Isolate_spawnUri, 0, 12) { // 解析参数 ... // Canonicalize the uri with respect to the current isolate. const Library& root_lib = Library::Handle(isolate->group()->object_store()->root_library()); char* error = NULL; // 获取canonical_uri const char* **canonical_uri = CanonicalizeUri**(thread, root_lib, uri, &error); if (canonical_uri == NULL) { const String& msg = String::Handle(String::New(error)); ThrowIsolateSpawnException(msg); } const char* utf8_package_config = packageConfig.IsNull() ? NULL : String2UTF8(packageConfig); const char* utf8_debug_name = debugName.IsNull() ? NULL : String2UTF8(debugName); std::unique_ptr<IsolateSpawnState> state(new **IsolateSpawnState**( port.Id(), canonical_uri, utf8_package_config, &arguments_buffer, &message_buffer, paused.value(), fatal_errors, on_exit_port, // 注意下面这里的group=nullptr on_error_port, utf8_debug_name, **/*group=*/nullptr**)); // If we were passed a value then override the default flags state for // checked mode. if (!checked.IsNull()) { Dart_IsolateFlags* flags = state->isolate_flags(); flags->enable_asserts = checked.value(); } // Since this is a call to Isolate.spawnUri, don't copy the parent's code. state->isolate_flags()->copy_parent_code = false; isolate->group()->thread_pool()->**Run<SpawnIsolateTask>**(isolate, std::move(state)); return Object::null(); } \",\"可以看到Isolate_spawnUri还是执行了SpawnIsolateTask 。\"]},\"385\":{\"h\":\"SpawnIsolateTask\",\"t\":[\"在SpawnIsolateTask.Run方法中，因为spawnUri中IsolateSpawnState的IsolateGroup为nulltrp，所以这里执行的是RunHeavyweight(name)：\"]},\"386\":{\"h\":\"RunHeavyweight\",\"t\":[\"// -> class SpawnIsolateTask : public ThreadPool::Task { void Run() override { const char* name = (state_->debug_name() == nullptr) ? state_->function_name() : state_->debug_name(); ASSERT(name != nullptr); auto group = state_->isolate_group(); if (group == nullptr) { **RunHeavyweight(name);** } else { RunLightweight(name); } } void RunHeavyweight(const char* name) { // The create isolate group callback is mandatory. If not provided we // cannot spawn isolates. // 在Dart::DartInit中已经被设置，在Isolate创建时会被回调 **auto create_group_callback = Isolate::CreateGroupCallback();** if (create_group_callback == nullptr) { FailedSpawn(\\\"Isolate spawn is not supported by this Dart embedder\\\\n\\\"); return; } char* error = nullptr; // Make a copy of the state's isolate flags and hand it to the callback. Dart_IsolateFlags api_flags = *(state_->isolate_flags()); api_flags.is_system_isolate = false; // 创建isolate **Dart_Isolate isolate = (create_group_callback)(state_->script_url(), name, nullptr, state_->package_config(), &api_flags, parent_isolate_->init_callback_data(), &error);** parent_isolate_->DecrementSpawnCount(); parent_isolate_ = nullptr; if (isolate == nullptr) { FailedSpawn(error, /*has_current_isolate=*/false); free(error); return; } // 切换到指定的isolate Dart_EnterIsolate(isolate); // 这里也调用了Run方法 **Run(reinterpret_cast<Isolate*>(isolate));** } } \",\"主要创建Isolate的过程在Isolate::CreateGroupCallback();中，让我们看一下他是怎么来的：\"]},\"387\":{\"h\":\"Isolate::CreateGroupCallback()\",\"t\":[\"他和上述Isolate::InitializeCallback_的来源一致，都是在Dart_Initialize中配置的，此外，还使用了parent_isolate_->init_callback_data()。\",\"先看一下的CreateIsolateGroupAndSetup实现：\",\"// -> runtime\\\\bin\\\\main.cc static Dart_Isolate CreateIsolateGroupAndSetup(const char* script_uri, const char* main, const char* package_root, const char* package_config, Dart_IsolateFlags* flags, void* callback_data, char** error) { // The VM should never call the isolate helper with a NULL flags. ASSERT(flags != NULL); ASSERT(flags->version == DART_FLAGS_CURRENT_VERSION); ASSERT(package_root == nullptr); bool dontneed_safe = true; #if defined(DART_HOST_OS_LINUX) // This would also be true in Linux, except that Google3 overrides the default // ELF interpreter to one that apparently doesn't create proper mappings. dontneed_safe = false; #elif defined(DEBUG) // If the snapshot isn't file-backed, madvise(DONT_NEED) is destructive. if (Options::force_load_elf_from_memory()) { dontneed_safe = false; } #endif flags->snapshot_is_dontneed_safe = dontneed_safe; int exit_code = 0; #if !defined(EXCLUDE_CFE_AND_KERNEL_PLATFORM) if (strcmp(script_uri, DART_KERNEL_ISOLATE_NAME) == 0) { return **CreateAndSetupKernelIsolate**(script_uri, package_config, flags, error, &exit_code); } #endif // !defined(EXCLUDE_CFE_AND_KERNEL_PLATFORM) #if !defined(DART_PRECOMPILED_RUNTIME) if (strcmp(script_uri, DART_DEV_ISOLATE_NAME) == 0) { return **CreateAndSetupDartDevIsolate**(script_uri, package_config, flags, error, &exit_code); } #endif // !defined(DART_PRECOMPILED_RUNTIME) if (strcmp(script_uri, DART_VM_SERVICE_ISOLATE_NAME) == 0) { return **CreateAndSetupServiceIsolate**(script_uri, package_config, flags, error, &exit_code); } bool is_main_isolate = false; return **CreateIsolateGroupAndSetupHelper**(is_main_isolate, script_uri, main, package_config, flags, callback_data, error, &exit_code); } \",\"这里创建Isolate的时候，区分了几种情况：\",\"如果是kernel-service（DART_KERNEL_ISOLATE_NAME）就执行CreateAndSetupKernelIsolate\",\"如果是dartdev（DART_DEV_ISOLATE_NAME）就执行CreateAndSetupDartDevIsolate\",\"如果是vm-service（DART_VM_SERVICE_ISOLATE_NAME）就执行CreateAndSetupServiceIsolate\",\"如果以上都不满足，就执行CreateIsolateGroupAndSetupHelper\",\"显然,当我们在Dart代码中调用Isolate.spawnUri的时候，这里会执行的是CreateIsolateGroupAndSetupHelper：\",\"// -> runtime\\\\bin\\\\main.cc // 调用方 bool is_main_isolate = false; return CreateIsolateGroupAndSetupHelper(is_main_isolate, script_uri, main, package_config, flags, callback_data, error, &exit_code); // Returns newly created Isolate on success, NULL on failure. static Dart_Isolate CreateIsolateGroupAndSetupHelper( bool is_main_isolate, const char* script_uri, const char* name, const char* packages_config, Dart_IsolateFlags* flags, void* callback_data, char** error, int* exit_code) { ... // 根据是AOT还是JIT获取kernel_buffer，app_snapshot，isolate_run_app_snapshot等数据 #if defined(DART_PRECOMPILED_RUNTIME){ // AOT: All isolates need to be run from AOT compiled snapshots. } #else{ // JIT: Main isolate starts from the app snapshot, if any. Other isolates // use the core libraries snapshot. } // 创建isolate_group_data auto isolate_group_data = new IsolateGroupData( script_uri, packages_config, app_snapshot, isolate_run_app_snapshot); // copy_parent_code为true的话，这里的kernel_buffer为NULL if (kernel_buffer != NULL) { if (kernel_buffer_ptr) { isolate_group_data->SetKernelBufferAlreadyOwned( std::move(kernel_buffer_ptr), kernel_buffer_size); } else { isolate_group_data->SetKernelBufferNewlyOwned(kernel_buffer, kernel_buffer_size); } } Dart_Isolate isolate = NULL; IsolateData* isolate_data = nullptr; #if !defined(DART_PRECOMPILED_RUNTIME) if (!isolate_run_app_snapshot && (isolate_snapshot_data == NULL)) { const uint8_t* platform_kernel_buffer = NULL; intptr_t platform_kernel_buffer_size = 0; dfe.LoadPlatform(&platform_kernel_buffer, &platform_kernel_buffer_size); if (platform_kernel_buffer == NULL) { platform_kernel_buffer = kernel_buffer; platform_kernel_buffer_size = kernel_buffer_size; } if (platform_kernel_buffer == NULL) { #if defined(EXCLUDE_CFE_AND_KERNEL_PLATFORM) FATAL( \\\"Binary built with --exclude-kernel-service. Cannot run\\\" \\\" from source.\\\"); #else FATAL(\\\"platform_program cannot be NULL.\\\"); #endif // defined(EXCLUDE_CFE_AND_KERNEL_PLATFORM) } // TODO(sivachandra): When the platform program is unavailable, check if // application kernel binary is self contained or an incremental binary. // Isolate should be created only if it is a self contained kernel binary. isolate_data = new IsolateData(isolate_group_data); isolate = Dart_CreateIsolateGroupFromKernel( script_uri, name, platform_kernel_buffer, platform_kernel_buffer_size, flags, isolate_group_data, isolate_data, error); } else { isolate_data = new IsolateData(isolate_group_data); // Creates a new isolate. The new isolate becomes the current isolate. isolate = Dart_CreateIsolateGroup(script_uri, name, isolate_snapshot_data, isolate_snapshot_instructions, flags, isolate_group_data, isolate_data, error); } #else **isolate_data = new IsolateData**(isolate_group_data); // Creates a new isolate. The new isolate becomes the current isolate. **isolate = Dart_CreateIsolateGroup**(script_uri, name, isolate_snapshot_data, isolate_snapshot_instructions, flags, **isolate_group_data**, **isolate_data**, error); #endif // !defined(DART_PRECOMPILED_RUNTIME) Dart_Isolate created_isolate = NULL; if (isolate == NULL) { delete isolate_data; delete isolate_group_data; } else { **created_isolate = IsolateSetupHelper**( isolate, is_main_isolate, script_uri, packages_config, isolate_run_app_snapshot, flags, error, exit_code); } int64_t end = Dart_TimelineGetMicros(); Dart_TimelineEvent(\\\"CreateIsolateGroupAndSetupHelper\\\", start, end, Dart_Timeline_Event_Duration, 0, NULL, NULL); return created_isolate; } \",\"这里可以看到，CreateIsolateGroupAndSetupHelper按照是JIT还是AOT的编译方式，有不同的获取数据的方式，但不管哪种方式，最后都执行了一下三步：\",\"创建IsolateData* isolate_data 使用isolate_group_data创建IsolateData\",\"创建Dart_Isolate isolate 创建Dart_Isolate，将script_uri，isolate_data，和isolate_group_data等绑定\",\"创建并返回Dart_Isolate created_isolate包装isolate ，进行数据绑定，并将isolate标记为runnable\"]},\"388\":{\"h\":\"Dart_CreateIsolateGroup\",\"t\":[\"这里分析一下**Dart_CreateIsolateGroup的过程：**\",\"// --> runtime/vm/dart_api_impl.cc#L1371 DART_EXPORT Dart_Isolate Dart_CreateIsolateGroup(const char* script_uri, const char* name, const uint8_t* snapshot_data, const uint8_t* snapshot_instructions, Dart_IsolateFlags* flags, void* isolate_group_data, void* isolate_data, char** error) { API_TIMELINE_DURATION(Thread::Current()); Dart_IsolateFlags api_flags; if (flags == nullptr) { Isolate::FlagsInitialize(&api_flags); flags = &api_flags; } const char* non_null_name = name == nullptr ? \\\"isolate\\\" : name; std::unique_ptr<IsolateGroupSource> source( new IsolateGroupSource(script_uri, non_null_name, snapshot_data, snapshot_instructions, nullptr, -1, *flags)); // 创建Isolate Group auto group = new IsolateGroup(std::move(source), isolate_group_data, *flags); // 创建Isolate Group持有的Heap，由所有在这个Isolate Group下的isolate共享 group->CreateHeap( /*is_vm_isolate=*/false, IsServiceOrKernelIsolateName(non_null_name)); IsolateGroup::RegisterIsolateGroup(group); // 根据刚刚创建的Isolate Group创建Isolate Dart_Isolate isolate = CreateIsolate(group, /*is_new_group=*/true, non_null_name, isolate_data, error); if (isolate != nullptr) { group->set_initial_spawn_successful(); } return isolate; } \"]},\"389\":{\"h\":\"Run(Isolate* child)\",\"t\":[\"在上面的分析中，我们注意到，无论是RunHeavyweight(const char* name)还是RunLightweight(const char* name)方法，最后在创建了新的isolate之后，都执行了Run(Isolate* child)方法，在这里正式启动了isolate：\",\"// -> runtime\\\\lib\\\\isolate.cc void Run(Isolate* child) { if (!EnsureIsRunnable(child)) { Dart_ShutdownIsolate(); return; } state_->set_isolate(child); if (state_->origin_id() != ILLEGAL_PORT) { // origin_id is set to parent isolate main port id when spawning via // spawnFunction. child->set_origin_id(state_->origin_id()); } bool success = true; { auto thread = Thread::Current(); // TransitionNativeToVM is used to transition the safepoint state of a // thread from \\\"running native code\\\" to \\\"running vm code\\\" and ensures // that the state is reverted back to \\\"running native code\\\" when // exiting the scope/frame. TransitionNativeToVM transition(thread); // Create an empty zone and set is at the current zone for the Thread. StackZone zone(thread); // The class HandleScope is used to start a new handles scope in the // code. HandleScope hs(thread); success = **EnqueueEntrypointInvocationAndNotifySpawner**(thread); } if (!success) { state_ = nullptr; Dart_ShutdownIsolate(); return; } // All preconditions are met for this to always succeed. char* error = nullptr; // Lets the VM run message processing for the isolate. if (!**Dart_RunLoopAsync**(state_->errors_are_fatal(), state_->on_error_port(), state_->on_exit_port(), &error)) { FATAL(\\\"Dart_RunLoopAsync() failed: %s. Please file a Dart VM bug report.\\\", error); } } \",\"这里只是做了一些环境准备，然后在EnqueueEntrypointInvocationAndNotifySpawner方法中将isolate要运行的所有东西都准备好，然后再在Dart_RunLoopAsync方法中正式开始isolate处理event queue.\",\"EnqueueEntrypointInvocationAndNotifySpawner\",\"// -> runtime\\\\lib\\\\isolate.cc bool EnqueueEntrypointInvocationAndNotifySpawner(Thread* thread) { auto isolate = thread->isolate(); auto zone = thread->zone(); const bool is_spawn_uri = state_->is_spawn_uri(); // Step 1) Resolve the entrypoint function. // 查找isolate开始运行的第一个方法，比如Isolate.spawn的spawn或者Isolate.spawnUri的main方法 auto& entrypoint_closure = Closure::Handle(zone); if (state_->closure_tuple_handle() != nullptr) { const auto& result = Object::Handle( zone, ReadObjectGraphCopyMessage(thread, state_->closure_tuple_handle())); if (result.IsError()) { ReportError( \\\"Failed to deserialize the passed entrypoint to the new isolate.\\\"); return false; } entrypoint_closure = Closure::RawCast(result.ptr()); } else { const auto& result = Object::Handle(zone, state_->ResolveFunction()); if (result.IsError()) { ASSERT(is_spawn_uri); ReportError(\\\"Failed to resolve entrypoint function.\\\"); return false; } ASSERT(result.IsFunction()); auto& func = Function::Handle(zone, Function::Cast(result).ptr()); func = func.ImplicitClosureFunction(); entrypoint_closure = func.ImplicitStaticClosure(); } // Step 2) Enqueue delayed invocation of entrypoint callback. const auto& args_obj = Object::Handle(zone, state_->BuildArgs(thread)); if (args_obj.IsError()) { ReportError( \\\"Failed to deserialize the passed arguments to the new isolate.\\\"); return false; } ASSERT(args_obj.IsNull() || args_obj.IsInstance()); const auto& message_obj = Object::Handle(zone, state_->BuildMessage(thread)); if (message_obj.IsError()) { ReportError( \\\"Failed to deserialize the passed arguments to the new isolate.\\\"); return false; } ASSERT(message_obj.IsNull() || message_obj.IsInstance()); // 解析参数，分别是isolate初始运行方法，参数args、messgae、是否spawn_uri const Array& args = Array::Handle(zone, Array::New(4)); args.SetAt(0, entrypoint_closure); args.SetAt(1, args_obj); args.SetAt(2, message_obj); args.SetAt(3, is_spawn_uri ? Bool::True() : Bool::False()); const auto& lib = Library::Handle(zone, Library::IsolateLibrary()); const auto& entry_name = String::Handle(zone, String::New(\\\"_startIsolate\\\")); const auto& entry_point = Function::Handle(zone, lib.LookupLocalFunction(entry_name)); ASSERT(entry_point.IsFunction() && !entry_point.IsNull()); const auto& result = Object::Handle(zone, DartEntry::InvokeFunction(entry_point, args)); if (result.IsError()) { ReportError(\\\"Failed to enqueue delayed entrypoint invocation.\\\"); return false; } // Step 3) Pause the isolate if required & Notify parent isolate about // isolate creation. const auto& capabilities = Array::Handle(zone, Array::New(2)); auto& capability = Capability::Handle(zone); capability = Capability::New(isolate->pause_capability()); capabilities.SetAt(0, capability); capability = Capability::New(isolate->terminate_capability()); capabilities.SetAt(1, capability); const auto& send_port = SendPort::Handle(zone, SendPort::New(isolate->main_port())); const auto& message = Array::Handle(zone, Array::New(2)); message.SetAt(0, send_port); message.SetAt(1, capabilities); if (state_->paused()) { capability ^= capabilities.At(0); const bool added = isolate->AddResumeCapability(capability); ASSERT(added); isolate->message_handler()->increment_paused(); } { // If parent isolate died, we ignore the fact that we cannot notify it. // 创建一个新的Message并将其压入Isolate的父Isolate对应的MessageHandler的event queue中 PortMap::PostMessage(WriteMessage(/* can_send_any_object */ false, /* same_group */ false, message, state_->parent_port(), Message::kNormalPriority)); } return true; } \",\"这里主要做了3件事：\",\"查找isolate开始运行的第一个方法entrypoint，比如Isolate.spawn的entrypoint或者Isolate.spawnUri的main方法\",\"解析参数，分别是isolate初始运行方法，参数args、messgae、是否spawn_uri等等，将其与上一步找到的entrypoint结合\",\"（如果需要的话暂停创建好的isolate），并通知isolate的父isolate当前isolate创建成功（附带当前isolate的send_port）\",\"至此，Isolate的创建工作已经完成，在Dart_RunLoopAsync开始isolate处理消息：\",\"Dart_RunLoopAsync\",\"在这里主要是开始处理event loop。\",\"// -> runtime\\\\vm\\\\dart_api_impl.cc DART_EXPORT bool Dart_RunLoopAsync(bool errors_are_fatal, Dart_Port on_error_port, Dart_Port on_exit_port, char** error) { auto thread = Thread::Current(); auto isolate = thread->isolate(); CHECK_ISOLATE(isolate); *error = nullptr; if (thread->api_top_scope() != nullptr) { *error = Utils::StrDup(\\\"There must not be an active api scope.\\\"); return false; } if (!isolate->is_runnable()) { const char* error_msg = isolate->MakeRunnable(); if (error_msg != nullptr) { *error = Utils::StrDup(error_msg); return false; } } isolate->SetErrorsFatal(errors_are_fatal); if (on_error_port != ILLEGAL_PORT || on_exit_port != ILLEGAL_PORT) { auto thread = Thread::Current(); TransitionNativeToVM transition(thread); StackZone zone(thread); if (on_error_port != ILLEGAL_PORT) { const auto& port = SendPort::Handle(thread->zone(), SendPort::New(on_error_port)); isolate->AddErrorListener(port); } if (on_exit_port != ILLEGAL_PORT) { const auto& port = SendPort::Handle(thread->zone(), SendPort::New(on_exit_port)); isolate->AddExitListener(port, Instance::null_instance()); } } Dart_ExitIsolate(); **isolate->Run();** return true; } // -> runtime\\\\vm\\\\isolate.cc void Isolate::Run() { message_handler()->Run(group()->thread_pool(), nullptr, ShutdownIsolate, reinterpret_cast<uword>(this)); } \",\"Isolate::Run()实际上是开启了处理消息队列：\",\"// -> // Runs this message handler on the thread pool. // // Before processing messages, the optional StartFunction is run. // // A message handler will run until it terminates either normally or // abnormally. Normal termination occurs when the message handler // no longer has any live ports. Abnormal termination occurs when // HandleMessage() indicates that an error has occurred during // message processing. // Returns false if the handler terminated abnormally, otherwise it // returns true. bool MessageHandler::Run(ThreadPool* pool, StartCallback start_callback, EndCallback end_callback, CallbackData data) { MonitorLocker ml(&monitor_); if (FLAG_trace_isolates) { OS::PrintErr( \\\"[+] Starting message handler:\\\\n\\\" \\\"\\\\thandler: %s\\\\n\\\", name()); } ASSERT(pool_ == NULL); ASSERT(!delete_me_); pool_ = pool; start_callback_ = start_callback; end_callback_ = end_callback; callback_data_ = data; task_running_ = true; bool result = **pool_->Run<MessageHandlerTask>(this);** if (!result) { pool_ = nullptr; start_callback_ = nullptr; end_callback_ = nullptr; callback_data_ = 0; task_running_ = false; } return result; } // -> runtime\\\\vm\\\\thread_pool.h class ThreadPool { bool Run(Args&&... args) { return RunImpl(std::unique_ptr<Task>(new T(std::forward<Args>(args)...))); } ... } // -> runtime\\\\vm\\\\thread_pool.cc bool ThreadPool::RunImpl(std::unique_ptr<Task> task) { Worker* new_worker = nullptr; { MonitorLocker ml(&pool_monitor_); if (shutting_down_) { return false; } // 从线程池中获取task，如果有空闲的/达到最大数量就尝试复用（此时这里返回null） // 否则创建新的并返回 new_worker = **ScheduleTaskLocked**(&ml, std::move(task)); } if (new_worker != nullptr) { // 创建一个新的Worker在新的系统线程运行task new_worker->**StartThread()**; } return true; } void ThreadPool::Worker::StartThread() { // 创建一个新的系统线程，运行指定的代码， // android的实现在runtime\\\\vm\\\\os_thread_android.cc int result = OSThread::Start(\\\"DartWorker\\\", &**Worker::Main**, reinterpret_cast<uword>(this)); if (result != 0) { FATAL1(\\\"Could not start worker thread: result = %d.\\\", result); } } \",\"这里通过ThreadPool::ScheduleTaskLocked方法获取new_worker：\",\"如果已有的worker有空闲的或者已经达到最大数目了，就等待已有的worker执行任务\",\"否则就创建新的worker，并在新的线程运行\",\"在获取到worker之后，就执行MessageHandlerTask（见下文详细分析）。\",\"我们主要关注3点：\",\"ScheduleTaskLocked 分配Worker\",\"OSThread::Start中使用&Worker::Main 在新系统线程开启Worker循环\",\"MessageHandlerTask 执行具体的消息分发内容\"]},\"390\":{\"h\":\"ScheduleTaskLocked\",\"t\":[\"先详细看一下获取new_worker的ThreadPool::ScheduleTaskLocked方法：\",\"// -> runtime\\\\vm\\\\thread_pool.cc ThreadPool::Worker* ThreadPool::ScheduleTaskLocked(MonitorLocker* ml, std::unique_ptr<Task> task) { // Enqueue the new task. tasks_.Append(task.release()); pending_tasks_++; ASSERT(pending_tasks_ >= 1); // Notify existing idle worker (if available). if (count_idle_ >= pending_tasks_) { ASSERT(!idle_workers_.IsEmpty()); ml->Notify(); return nullptr; } // If we have maxed out the number of threads running, we will not start a // new one. if (max_pool_size_ > 0 && (count_idle_ + count_running_) >= max_pool_size_) { if (!idle_workers_.IsEmpty()) { ml->Notify(); } return nullptr; } // Otherwise start a new worker. auto new_worker = new Worker(this); idle_workers_.Append(new_worker); count_idle_++; return new_worker; } \",\"这里的逻辑是：\",\"将当前任务加入到tasks_队列中。\",\"如果空闲count_idle_ 的Worker比等待中的任务数pending_tasks_多，那就发送通知，使用已有的Worker处理任务。\",\"如果当前Worker数量已经最大了，那就将等待中的任务数pending_tasks_ 加一，等待有空闲的Worker处理任务。\",\"否则，就新建一个Worker（会对应创建一个新的系统线程）来处理任务。\"]},\"391\":{\"h\":\"& Worker::Main\",\"t\":[\"在ThreadPool::RunImpl(std::unique_ptr<Task> task)这里，StartThread的第二个参数，**&Worker::Main**启动了一个循环，不断的在任务队列tasks_中取出消息并执行：\",\"// -> runtime\\\\vm\\\\thread_pool.cc ThreadPool::Worker::Main(uword args){ Worker* worker = reinterpret_cast<Worker*>(args); ThreadPool* pool = worker->pool_; pool->WorkerLoop(worker); } void ThreadPool::WorkerLoop(Worker* worker) { WorkerList dead_workers_to_join; while (true) { MonitorLocker ml(&pool_monitor_); // worker会从task_取出一个task并运行 if (!tasks_.IsEmpty()) { IdleToRunningLocked(worker); while (!tasks_.IsEmpty()) { std::unique_ptr<Task> task(tasks_.RemoveFirst()); pending_tasks_--; MonitorLeaveScope mls(&ml); **task->Run();** ASSERT(Isolate::Current() == nullptr); task.reset(); } RunningToIdleLocked(worker); } if (running_workers_.IsEmpty()) { ASSERT(tasks_.IsEmpty()); OnEnterIdleLocked(&ml); if (!tasks_.IsEmpty()) { continue; } } if (shutting_down_) { ObtainDeadWorkersLocked(&dead_workers_to_join); IdleToDeadLocked(worker); break; } // Sleep until we get a new task, we time out or we're shutdown. const int64_t idle_start = OS::GetCurrentMonotonicMicros(); bool done = false; while (!done) { const auto result = ml.WaitMicros(ComputeTimeout(idle_start)); // We have to drain all pending tasks. if (!tasks_.IsEmpty()) break; if (shutting_down_ || result == Monitor::kTimedOut) { done = true; break; } } if (done) { ObtainDeadWorkersLocked(&dead_workers_to_join); IdleToDeadLocked(worker); break; } } // Before we transitioned to dead we obtained the list of previously died dead // workers, which we join here. Since every death of a worker will join // previously died workers, we keep the pending non-joined [dead_workers_] to // effectively 1. JoinDeadWorkersLocked(&dead_workers_to_join); } \",\"MessageHandlerTask\",\"无论是哪种Worker,最后都是执行的MessageHandlerTask：\",\"// -> runtime\\\\vm\\\\message_handler.cc class MessageHandlerTask : public ThreadPool::Task { public: explicit MessageHandlerTask(MessageHandler* handler) : handler_(handler) { ASSERT(handler != NULL); } virtual void Run() { ASSERT(handler_ != NULL); handler_->TaskCallback(); } void MessageHandler::TaskCallback() { ASSERT(Isolate::Current() == NULL); MessageStatus status = kOK; bool run_end_callback = false; bool delete_me = false; EndCallback end_callback = NULL; CallbackData callback_data = 0; { // We will occasionally release and reacquire this monitor in this // function. Whenever we reacquire the monitor we *must* process // all pending OOB messages, or we may miss a request for vm // shutdown. MonitorLocker ml(&monitor_); // This method is running on the message handler task. Which means no // other message handler tasks will be started until this one sets // [task_running_] to false. ASSERT(task_running_); #if !defined(PRODUCT) if (ShouldPauseOnStart(kOK)) { if (!is_paused_on_start()) { PausedOnStartLocked(&ml, true); } // More messages may have come in before we (re)acquired the monitor. status = HandleMessages(&ml, false, false); if (ShouldPauseOnStart(status)) { // Still paused. ASSERT(oob_queue_->IsEmpty()); task_running_ = false; // No task in queue. return; } else { PausedOnStartLocked(&ml, false); } } if (is_paused_on_exit()) { status = HandleMessages(&ml, false, false); if (ShouldPauseOnExit(status)) { // Still paused. ASSERT(oob_queue_->IsEmpty()); task_running_ = false; // No task in queue. return; } else { PausedOnExitLocked(&ml, false); } } #endif // !defined(PRODUCT) if (status == kOK) { if (start_callback_ != nullptr) { // Initialize the message handler by running its start function, // if we have one. For an isolate, this will run the isolate's // main() function. // // Release the monitor_ temporarily while we call the start callback. ml.Exit(); status = start_callback_(callback_data_); ASSERT(Isolate::Current() == NULL); start_callback_ = NULL; ml.Enter(); } // Handle any pending messages for this message handler. if (status != kShutdown) { status = HandleMessages(&ml, (status == kOK), true); } } // The isolate exits when it encounters an error or when it no // longer has live ports. if (status != kOK || !HasLivePorts()) { #if !defined(PRODUCT) if (ShouldPauseOnExit(status)) { if (FLAG_trace_service_pause_events) { OS::PrintErr( \\\"Isolate %s paused before exiting. \\\" \\\"Use the Observatory to release it.\\\\n\\\", name()); } PausedOnExitLocked(&ml, true); // More messages may have come in while we released the monitor. **status = HandleMessages(&ml, false, false);** if (ShouldPauseOnExit(status)) { // Still paused. ASSERT(oob_queue_->IsEmpty()); task_running_ = false; // No task in queue. return; } else { PausedOnExitLocked(&ml, false); } } #endif // !defined(PRODUCT) if (FLAG_trace_isolates) { if (status != kOK && thread() != NULL) { const Error& error = Error::Handle(thread()->sticky_error()); OS::PrintErr( \\\"[-] Stopping message handler (%s):\\\\n\\\" \\\"\\\\thandler: %s\\\\n\\\" \\\"\\\\terror: %s\\\\n\\\", MessageStatusString(status), name(), error.ToCString()); } else { OS::PrintErr( \\\"[-] Stopping message handler (%s):\\\\n\\\" \\\"\\\\thandler: %s\\\\n\\\", MessageStatusString(status), name()); } } pool_ = NULL; // Decide if we have a callback before releasing the monitor. end_callback = end_callback_; callback_data = callback_data_; run_end_callback = end_callback_ != NULL; delete_me = delete_me_; } // Clear task_running_ last. This allows other tasks to potentially start // for this message handler. ASSERT(oob_queue_->IsEmpty()); task_running_ = false; } // The handler may have been deleted by another thread here if it is a native // message handler. // Message handlers either use delete_me or end_callback but not both. ASSERT(!delete_me || !run_end_callback); if (run_end_callback) { ASSERT(end_callback != NULL); end_callback(callback_data); // The handler may have been deleted after this point. } if (delete_me) { delete this; } } \",\"可以看到，这里执行了MessageHandler::HandleMessages方法，来处理消息：\",\"// -> runtime\\\\vm\\\\message_handler.cc MessageHandler::MessageStatus MessageHandler::HandleMessages( MonitorLocker* ml, bool allow_normal_messages, bool allow_multiple_normal_messages) { ASSERT(monitor_.IsOwnedByCurrentThread()); // Scheduling of the mutator thread during the isolate start can cause this // thread to safepoint. // We want to avoid holding the message handler monitor during the safepoint // operation to avoid possible deadlocks, which can occur if other threads are // sending messages to this message handler. // // If isolate() returns nullptr [StartIsolateScope] does nothing. ml->Exit(); StartIsolateScope start_isolate(isolate()); ml->Enter(); auto idle_time_handler = isolate() != nullptr ? isolate()->group()->idle_time_handler() : nullptr; MessageStatus max_status = kOK; Message::Priority min_priority = ((allow_normal_messages && !paused()) ? Message::kNormalPriority : Message::kOOBPriority); std::unique_ptr<Message> **message = DequeueMessage(min_priority);** while (message != nullptr) { intptr_t message_len = message->Size(); if (FLAG_trace_isolates) { OS::PrintErr( \\\"[<] Handling message:\\\\n\\\" \\\"\\\\tlen: %\\\" Pd \\\"\\\\n\\\" \\\"\\\\thandler: %s\\\\n\\\" \\\"\\\\tport: %\\\" Pd64 \\\"\\\\n\\\", message_len, name(), message->dest_port()); } // Release the monitor_ temporarily while we handle the message. // The monitor was acquired in MessageHandler::TaskCallback(). ml->Exit(); Message::Priority saved_priority = message->priority(); Dart_Port saved_dest_port = message->dest_port(); MessageStatus status = kOK; { DisableIdleTimerScope disable_idle_timer(idle_time_handler); status = HandleMessage(std::move(message)); } if (status > max_status) { max_status = status; } ml->Enter(); if (FLAG_trace_isolates) { OS::PrintErr( \\\"[.] Message handled (%s):\\\\n\\\" \\\"\\\\tlen: %\\\" Pd \\\"\\\\n\\\" \\\"\\\\thandler: %s\\\\n\\\" \\\"\\\\tport: %\\\" Pd64 \\\"\\\\n\\\", MessageStatusString(status), message_len, name(), saved_dest_port); } // If we are shutting down, do not process any more messages. if (status == kShutdown) { ClearOOBQueue(); break; } // Remember time since the last message. Don't consider OOB messages so // using Observatory doesn't trigger additional idle tasks. if ((FLAG_idle_timeout_micros != 0) && (saved_priority == Message::kNormalPriority)) { if (idle_time_handler != nullptr) { idle_time_handler->UpdateStartIdleTime(); } } // Some callers want to process only one normal message and then quit. At // the same time it is OK to process multiple OOB messages. if ((saved_priority == Message::kNormalPriority) && !allow_multiple_normal_messages) { // We processed one normal message. Allow no more. allow_normal_messages = false; } // Reevaluate the minimum allowable priority. The paused state // may have changed as part of handling the message. We may also // have encountered an error during message processing. // // Even if we encounter an error, we still process pending OOB // messages so that we don't lose the message notification. min_priority = (((max_status == kOK) && allow_normal_messages && !paused()) ? Message::kNormalPriority : Message::kOOBPriority); message = DequeueMessage(min_priority); } return max_status; } \",\"MessageHandler::DequeueMessage则是按照优先级，依次从oob_queue_和queue_中获取消息：\",\"// -> runtime\\\\vm\\\\message_handler.cc std::unique_ptr<Message> MessageHandler::DequeueMessage( Message::Priority min_priority) { // TODO(turnidge): Add assert that monitor_ is held here. std::unique_ptr<Message> message = oob_queue_->Dequeue(); if ((message == nullptr) && (min_priority < Message::kOOBPriority)) { message = queue_->Dequeue(); } return message; } \",\"关于oob_queue_和queue_ 的区别如下：\",\"// -> class MessageHandler { MessageQueue* queue_; MessageQueue* oob_queue_; ... } // -> runtime\\\\vm\\\\message.h class Message { // A message processed at any interrupt point (stack overflow check) instead // of at the top of the message loop. Control messages from dart:isolate or // vm-service requests. bool IsOOB() const { return priority_ == Message::kOOBPriority; } } \",\"这里消息处理的步骤也启动了。\",\"总结一下，Dart_RunLoopAsync的主要功能是触发isolate的message_handler处理消息分发：\",\"Dart_RunLoopAsync → Isolate::Run() → message_handler()->Run() → pool_->Run<MessageHandlerTask>→ThreadPool::RunImpl\",\"在ThreadPool::RunImpl(std::unique_ptr<Task> task)这里主要触发了2步：\",\"ScheduleTaskLocked获取到new_worker\",\"new_worker调用ThreadPool::Worker::StartThread()方法开启循环\",\"然后根据是否创建了new_worker有两种情况：\",\"有new_worker，使用在OSThread::Start方法中创建了一个新的系统线程，执行ThreadPool::Worker::Main（这个方法的主要作用使用new_worker从线程池中的取出任务执行）\",\"没有new_worker，那么等待已有的Worker空闲时执行任务\",\"无论如何，这里的Worker要执行的任务都是在MessageHandler::Run方法中指定的MessageHandlerTask ，而这个任务的内容便是开启MessageHandler::HandleMessages 方法，按照优先级不断的依次从oob_queue_和queue_中获取消息并处理。\",\"Isolate是Dart代码运行的地方，拥有独立的event loop，和全局变量，在自己单独的线程运行。\",\"Isolate.spawn默认会创建在同一个IsolateGroup中的Isolate，他们之间共享Heap（这里会发生GC）和一个线程池。\",\"Isolate.spawnUri会从制定的Uri中创建一个新的IsolateGroup和对应的Isolate，并执行Uri中的main方法。\",\"Isolate内部维持一个Event Loop。\"]},\"392\":{\"h\":\"Dart VM\",\"t\":[\"本文是对Dart官方VM的介绍的总结摘要，推荐直接阅读官方原文。\",\"Dart VM is a collection of components for executing Dart code natively. Notably, it includes the following:\",\"Runtime System\",\"Object Model\",\"Garbage Collection\",\"Snapshots\",\"Core libraries’ native methods\",\"Development Experience components accessible via service protocol * Debugging * Profiling * Hot-reload\",\"Just-in-Time (JIT) and Ahead-of-Time (AOT) compilation pipelines\",\"Interpreter\",\"ARM simulators\",\"下图是runtime执行代码的示意图：\",\"isolate\",\"isolate中有两种Thread：\",\"一个mutator thread用来执行dart 代码\",\"多个helper thread 用来执行GC、JIT等\",\"此外，一个isolate有一个heap，用来存储所有的dart object（GC发生在这里）。\",\"一个OSThread一次只能进入一个isolate，当其进入之后，该isolate的mutator thread便和这个OSThread关联起来执行dart代码。当OSThread要进入一个isolate的时候，必须先退出当前关联的isolate。\",\"isolate的mutator thread可能在不同时间关联不同的OSThread，但同一时刻最多只能有一个OSThread。\",\"VM执行Dart代码有两种方式：JIT和AOT，不管哪一种都不会直接执行Dart源码，而是经过转化之后的Kernel Binary(also called dill files)which contain serialized Kernel ASTs。\",\"一般来说，从Dart source code到Dart VM执行分为下面几步：\",\"dart-to-kernel\",\"VM expects to be given Kernel binaries (also called dill files) which contain serialized Kernel ASTs. The task of translating Dart source into Kernel AST is handled by the common front-end (CFE) written in Dart and shared between different Dart tools (e.g. VM, dart2js, Dart Dev Compiler).\",\"Dart VM has multiple ways to execute the code, for example:\",\"from source or Kernel binary using JIT;\",\"from snapshots: \",\"from AOT snapshot;\",\"from AppJIT snapshot.\"]},\"393\":{\"h\":\"从Dart Source加载到VM中\",\"t\":[\"为了保证直接从源代码执行Dart的便利性，独立的dart可执行文件承载了一个称为内核服务（*kernel service）*的辅助isolate，它处理Dart源代码编译成内核的过程。然后，VM将运行产生的内核二进制文件（Kernel Binary）。\",\"kernel-service\",\"上图中，一个被称为kernel service的isolate使用CFE将Dart Source编译为为Kernel Binary然后交给main isolate执行。\",\"这并不是安排CFE和VM执行Dart Source的唯一方式，比如Flutter就将CFE（封装之后的）和VM分别置于两个设备上：\",\"flutter-cfe\",\"当热更新触发时，Flutter使用封装过的CFE以及一个Flutter独有的Kernel-to-Kernel转换，将修改过的Dart Source编译为Kernel Binary，然后推送到设备上面（比如手机）执行。\"]},\"394\":{\"h\":\"在VM中执行\",\"t\":[\"上面是Dart Source加载到VM的过程，下面是Dart代码在VM中执行的过程分析：\",\"1）当Kernel Binary加载到VM中之后，只会解析加载的类和库的基本信息。\",\"kernel-loaded-1\",\"2）当runtime实际用到的时候才会去获取完整的信息用来创建对象分配内存等：\",\"kernel-loaded-2\",\"此时，从Kernel Binary中读取出了class members，此时已经有足够的信息让runtime用来调用方法（successfully resolve and invoke methods）了，比如调用main方法，但是具体的方法体此时依旧还没有被反序列（deserialized）。\",\"3）在这个阶段，所有的function只是持有了一个真正要执行的方法体的placeholder指向LazyCompileStub，当runtime要执行的时候再创建并运行可执行代码。\",\"raw-function-lazy-compile\",\"这时候执行方法有两个阶段：\",\"unoptimized 默认执行时直接从Kernel Binary创建IL然后转化为machine code并运行\",\"optimized 在a阶段的热点代码会被从普通IL优化为SSA IL，然后转化为machine code运行，如果遇到优化失效的，再回退到a阶段执行代码（后面是否需要再走b阶段，需要重新判断）\"]},\"395\":{\"h\":\"unoptimized code\",\"t\":[\"这个阶段，从Kernel Binary生成Machine Code主要分为2步：\",\"（1）Kernel Binary → IL\",\"在这个阶段，从Kernel Binary中的AST中解析产生对应的control flow graph(CFG)。\",\"CFG由intermediate language(IL)组成，这个阶段使用的IL指令类似基于stack的虚拟机：他们从stack中读取操作数，执行操作，然后将结果push回这个stack中。\",\"unoptimized-compilation\",\"但并不是所有的方法都有对应的Dart/Kernel AST bodies（比如一些native方法或者artificial tear-off functions generated by Dart VM），这种情况下，他们凭空创建（in these cases IL is just created from the thin air）。\",\"(2) IL → Machine Code\",\"由一条IL对应生成多行machine language instruction\",\"在这个阶段不会进行优化，主要目的是快速创建出可执行代码（produce executable code quickly）\",\"内联缓存（inline caching）\",\"在这个阶段，编译器（unoptimizing compiler）不会尝试静态解析任何没有在Kernel Binary中解析的调用（any calls that were not resolved in Kernel binary），因此调用(MethodInvocation or PropertyGet AST nodes)被认为是完全动态的， VM使用内联缓存（inline caching）来实现动态调用。\",\"内联缓存的实现主要有：\",\"一个call site specific cache，将调用的类与方法映射在一起，如果receiver和已有的缓存类对应，那么就应该调用对应的方法，还有个计数器（invocation frequency counters）标记这个方法被调用多少次（对应下文的RawICData）\",\"一个共享的lookup stub，实现了方法调用的最快路径（method invocation fast path），在发生调用时通过lookup stub查询是否有entry与receiver的类匹配，有的话就用调用entry并增加frequency counter；否则就调用系统的runtime system helper兜底（如果成功运行了就更新上面的缓存，这样下次调用就不用再走runtime了）。\",\"inline-cache-1\"]},\"396\":{\"h\":\"optimized code\",\"t\":[\"虽然Unoptimizing compiler可以执行任意Dart代码，但是太慢了，所以在以上述方式执行代码的同时会记录以下信息：\",\"Inline cache收集在调用点的receiver类型（receiver types observed at callsites）\",\"和方法对应的execution counters以及basic blocks within functions追踪代码的热点区域（hot regions of the code）\",\"Optimized compilations 和Unoptimizing compiler开始的步骤类似：\",\"(1) Kernel Binary → unoptimized IL\",\"(2) unoptimized IL → SSA based IL → optimized IL\",\"当上述代码执行的时候，如果程序调用计数器（invocation frequency counters）到达某个阈值，这个方法就会被交给一个后台优化编译器（background optimizing compiler）来优化，将unoptimized IL转化为*SSA（static single assignment）*形式的IL。\",\"最后将SSA IL优化为optimized IL。\",\"(3) optimized IL → machine code\",\"在优化完成后，编译器会要求mutator thread进入safepoint并将优化后的代码绑定到方法上（attaches optimized code to the function）。\",\"safepoint的含义是，thread关联的state（比如heap，stack frame等）是一致的，并且可以在不中断线程的情况下访问或修改。通常意味着thread被暂停，或者在当前环境外（比如执行native代码）。\",\"optimizing-compilation\",\"上述这种基于乐观假设的优化，可能没法处理部分情况，从而回退到未优化的代码（deoptimization），然后再执行未优化过程（通常会丢弃优化后的代码，再判断是否有热点代码需要优化），主要有2种方式：\",\"eager deoptimization 在内联检查的时候，判断优化的条件是否满足，不满足的话就丢弃优化代码\",\"lazy deoptimization 全局分析指示在更改优化代码的内容时丢弃优化代码（之前优化的条件不满足了）。\",\"Snapshot's format is low level and optimized for fast startup，包含了要创建的object以及如何关联这些对象的说明信息（instructions）。\",\"VM可以将Heap/甚至是Heap中的object graph序列化成为snapshot，然后再从这个snapshot中重建对应的状态：\",\"snapshot\",\"最初的snapshot并不包含machine code，直到AOT compiler的出现。\",\"AOT compiler和snapshot-with-code使得VM可以在那些JIT受限的设备上运行：\",\"snapshot-with-code\",\"snapshot-with-code和普通的snapshot基本一致，唯一不同的是多出的machine code不需要deserizlization，事实上machine code在被分配到内存后可以立即成为heap的一部分（directly become part of the heap after it was mapped into memory）。\",\"AppJIT snapshot主要用于减少大型Dart application的JIT热身时间。\",\"AppJIT snapshots were introduced to reduce JIT warm up time for large Dart applications like dartanalyzeror dart2js. When these tools are used on small projects they spent as much time doing actual work as VM spends JIT compiling these apps.\",\"他的主要实现是：先用模拟数据在VM上运行，然后将其生成的code以及VM内部的数据结构序列化为AppJIT snapshot加载到VM中运行，只在正式的数据和模拟训练的配置无法匹配的时候执行JIT（execution profile on the real data does not match execution profile observed during training）。\",\"snapshot-appjit\",\"AOT与JIT各有优劣：\",\"AOT启动时间更短\",\"JIT峰值性能更优\",\"无法进行JIT意味着\",\"AOT snapshot must contain executable code for each and every function that could be invoked during application execution;\",\"the executable code must not rely on any speculative assumptions that could be violated during execution;\",\"为了满足上述要求， AOT汇编过程会进行全局静态分析以确定程序的哪些部分是可以从已知的entry point触达的，分配哪些类的实例，以及类型在程序中是如何应用的（which parts of the application are reachable from known set of entry points, instances of which classes are allocated and how types flow through the program）。\",\"AOT上述这些分析是保守的，可能在准确性上犯错，与之相比，JIT则在性能方面不行，因为JIT需要deoptimize兜底实现正确的行为。\",\"所以AOT将所有潜在的可触达的功能编译为native code，而无需投机性优化（All potentially reachable functions are then compiled to native code without any speculative optimizations）。\",\"aot\",\"从上图可以看出，AOT中，Kernel Binary先经过TFA收集变量、方法等信息，以此来移除不可达的方法，并devirtuablize method（确定虚拟方法的具体执行）。之后经过VM再移除一些不可达方法。\",\"Resulting snapshot can then be run using precompiled runtime, a special variant of the Dart VM which excludes components like JIT and dynamic code loading facilities.\"]},\"397\":{\"h\":\"Switchable Calls\",\"t\":[\"即使有全局和局部分析，AOT编译依然可能包含一些无法被非虚拟化（devirtualized）的call sites，为了解决这个问题，AOT编译出的代码和runtime会使用JIT中用到的内联缓存（Inline Caching）技术的拓展——switchable calls。\",\"sdk/index.md at main · dart-lang/sdk\",\"Dart VM 介绍\"]},\"398\":{\"h\":\"之前发布的几个App\",\"t\":[\"在之前学习android的过程中，跟着教程做了几个app，虽然随着使用的api的失效，大多数应用如今已经不能正常使用了，但是作为初入编程的一点点小纪念，还是为他们写一个索引文章，至少能够晚一些消寂于这广阔的数据海洋中。\",\"Posted on 2016-05-30\",\"NieceNews我制作的第二款APP，一个实时新闻软件。\",\"NiceNews\",\"Posted on 2016-07-16\",\"IWeather，我的第三个Android应用，一个天气预报APP。\",\"IWeather\",\"Posted on 2016-07-21\",\"2048，我的第四个Android应用，同时也是我的第一款游戏APP。\",\"2048\",\"Posted on 2016-07-24 |\",\"i看知乎，我的第五个Android应用。\",\"logo\",\"学习的过程需要不断的重复，更需要有条理的总结，我会把平时学习的心得体会，经验，以及无聊时瞎琢磨得出来的稀奇古怪的想法放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。\"]},\"399\":{\"h\":\"从Sunflower开始学习优雅的Jetpack架构\",\"t\":[\"Google大法NB！！！(破音)\",\"Jetpack是Google推出的一系列Android软件集合，\\\"使您可以更轻松地开发出色的 Android 应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上\\\"。\",\"Sunflower则是Google用来演示如何使用Jetpack进行Android开发的Demo，有着非常优雅的架构与十分简洁的代码，可以帮助我们很好地学习Jetpack以及MVVM思想。\",\"本文主要是结合Sunflower中的示例代码，分析Jetpack架构中各部分的作用，以及他们如何巧妙的搭配使用，方便指导日后对Jetpack的使用。\",\"本文中的大部分代码、示意图除非特殊注明外，皆来自Google的Sunflower工程或其他互联网资源，根据篇幅需要做了部分精简，所有权益归原作者所有。\",\"下图是Google Jetpack官网对Jetpack的介绍图： # 对Sunflower的整体分析 \",\"下图是Sunflower架构的简单示意图：\",\"可以看到，APP的界面有我的花园、植物目录和植物介绍三部分，这三者的切换逻辑通过实现。\",\"每个界面的XML中的布局信息（包括数据、事件（clickListener等），RecycleView的LayoutManager，Adapter等等）通过DataBinding与ViewModel中的可观察数据LiveData绑定在一起，只要数据库中的数据有更新，就会通过LiveData主动通知布局更新界面；同时DataBinding还通过与Adapter（这些继承自ListAdapter的Adapter实现了的作用）将ItemView的ViewModel与布局XML中绑定在一起，通过BindingAdapter对XML中的数据做预处理（加载imgUrl中的图片到ImageView等等）。\",\"在中指定这些DataBinding与之间以及ViewModel与数据库之间的逻辑关系，这些数据与操作都受着的影响。\",\"ViewModel的数据来源——Model在这里的实现是一个数据库。每个ViewModel有一个XXXViewModelFactory类，用来使用数据类XXXRepository类的实例创建对应的ViewModel。XXXViewModelFactory向Activity等屏蔽了ViewModel的具体实现。\",\"XXXRepository类的出现时为了将ViewModel与数据的具体实现解耦合，这样ViewModel只需要关心他要的操作而不必关系数据来源的具体实现。在本例中，XXXRepository类对应封装了这数据库AppDatabase中对两个表的操作。\",\"数据库使用实现，从底层开始依次分为表Entity，数据访问对象DAO和数据库DataBase三个层次。每个DAO对应一个包装类XXXRepository类供ViewModel使用。\",\"@Entity GardenPlanting //表，定义了存储的数据项及其格式 @Dao GardenPlantingDao //数据访问对象，定义了例如插入数据、查询数据等操作 GardenPlantingRepository //对DAO的封装，将数据的的具体实现与ViewModel对数据的操作解耦 @Database AppDatabase //数据库，包括表和对表的操作 \",\"则管理着一个从Json读取数据并加载到数据库中的后台任务SeedDatabaseWorker。\",\"首先看一下**View**部分，Sunflower只有简单的3个页面，全都是用Fragment实现，由Activity通过Navigation控制切换：\",\"GardenActivity 主页面，唯一的一个Activity\",\"GardenFragment 我的花园 界面，会显示用户在植物目录中选择并种植的植物信息\",\"PlantListFragment 植物目录 界面，所有的植物信息列表\",\"PlantDetailFragment 植物介绍 界面，当在“我的花园”或“植物列表”选择了某个植物后，会进入该界面显示植物详细介绍\"]},\"400\":{\"h\":\"Navigation控制界面切换\",\"t\":[\"先看一下Navigation的定义：\",\"Navigation是APP设计中的关键部分，可以用来定义用户从不同的界面切换、进入和推出的交互逻辑。\",\"和布局文件一样，我们可以在编译器的可视化界面中，直接预览、设计不同界面切换效果。他可以负责Fragment、Activity、Navigation graphs 与 subgraphs 以及Custom destination types，他们之间通过不同的action连接起来。\",\"通过官方文档可知，Navigation可以和AppBar，ToolBar等组合起来控制Fragment显示，此外可以通过ViewModel在绑定到同一个Activity的Fragment之间共享数据，或者也可以通过Bundle或Safe Args在两个Fragment之间传递数据。\",\"那么，在Sunflower中Navigation是怎么控制界面切换的呢？\",\"首先，在res/navigation/目录下面新建一个嵌套导航图(Nested navigation graphs),定义各个界面之前的切换关系：\",\"<navigation xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" xmlns:app=\\\"http://schemas.android.com/apk/res-auto\\\" xmlns:tools=\\\"http://schemas.android.com/tools\\\" app:startDestination=\\\"@+id/garden_fragment\\\"> //app:startDestination定义了在这个导航图中首次启动展示的界面 <fragment android:id=\\\"@+id/garden_fragment\\\" android:name=\\\"com.google.samples.apps.sunflower.GardenFragment\\\" android:label=\\\"@string/my_garden_title\\\" tools:layout=\\\"@layout/fragment_garden\\\"> //action定义了在各个界面的切换关系 <action android:id=\\\"@+id/action_garden_fragment_to_plant_detail_fragment\\\" app:destination=\\\"@id/plant_detail_fragment\\\" app:enterAnim=\\\"@anim/slide_in_right\\\"//enterAnim等指定执行action时的动画 .../> </fragment> <fragment ...> //argument定义了在切换界面时需要带的参数，需要androidx.navigation.safeargs的支持,具体见参考资料-Android Jetpack-Navigation 使用中参数的传递 <argument android:name=\\\"plantId\\\" app:argType=\\\"string\\\" />//参数类型小写 </fragment> </navigation> \",\"然后在Activity对应的XML中插入该导航：\",\"<LinearLayout ...> <fragment android:id=\\\"@+id/garden_nav_fragment\\\" android:name=\\\"androidx.navigation.fragment.NavHostFragment\\\" android:layout_width=\\\"match_parent\\\" android:layout_height=\\\"match_parent\\\" app:defaultNavHost=\\\"true\\\" app:navGraph=\\\"@navigation/nav_garden\\\" /> </LinearLayout> \",\"之后就可以在Activity或者Fragment中获取该导航的实力，用来切换界面了：\",\"//activity val navController = Navigation.findNavController(this, R.id.garden_nav_fragment) //fragment或其他地方 val direction = GardenFragmentDirections//嵌套导航图中Fragment自动生成的类 .ActionGardenFragmentToPlantDetailFragment(plantId) it.findNavController().navigate(direction) \"]},\"401\":{\"h\":\"DataBinding绑定布局和数据\",\"t\":[\"Navigation解决了不同的布局间交互的逻辑，DataBinding则充当布局View和数据（ViewModel、LiveData）之间的桥梁，将二者联系起来。\",\"从官网的表述中我们知道，DataBinding使用在XML中声明的方式（而非编程的方式），将布局中的组件捆绑到APP中使用到的数据上，这样当数据更新时，布局也会随之自动更新。\",\"DataBinding在XML中的形式如下：\",\"<layout xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" xmlns:app=\\\"http://schemas.android.com/apk/res-auto\\\"> <data> <variable name=\\\"viewmodel\\\" type=\\\"com.myapp.data.ViewModel\\\" /> </data> <ConstraintLayout... /> <!-- UI layout's root element --> </layout> \",\"需要注意的是原先的页面布局信息<ConstraintLayout... />包裹在<layout... />中，同时多了一个数据域<data... />，我们可以在其中定义一些变量<variable... />，并在布局中使用：\",\"<TextView android:text=\\\"@{viewmodel.userName}\\\" /> \",\"除了常见的android:text，android:onClick等通用的属性可以直接绑定外，我们还可以通过自定义Binding adapters支持更多形式的属性绑定：\",\"@BindingAdapter(\\\"app:goneUnless\\\") fun goneUnless(view: View, visible: Boolean) { view.visibility = if (visible) View.VISIBLE else View.GONE } \",\"上面的代码就支持了app:goneUnless的解析，我们只要在XML中为组件加上这个属性就可以实现相应的效果：\",\"<TextView android:text=\\\"@{viewmodel.userName}\\\" app:goneUnless=\\\"@{viewmodel.isGone}\\\"/> \",\"最后，我们需要在对应的Activity或Fragment中，用如下代码将布局与页面绑定到一起：\",\"//setContentView(R.layout.activity_main) val binding: ActivityMainBinding = DataBindingUtil.setContentView( this, R.layout.activity_main) binding.viewmodel = ... \",\"这里的ActivityMainBinding类是DataBinding根据XML文件的名字自动替我们生成的，规律是XML文件名+Binding的驼峰命名。\",\"在Sunflower中有类似的应用有很多处：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <!-- ~ Copyright 2018 Google LLC ... --> <layout xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" xmlns:app=\\\"http://schemas.android.com/apk/res-auto\\\" xmlns:tools=\\\"http://schemas.android.com/tools\\\"> <data> <variable name=\\\"hasPlantings\\\" type=\\\"boolean\\\" /> </data> <FrameLayout android:layout_width=\\\"match_parent\\\" android:layout_height=\\\"match_parent\\\"> <androidx.recyclerview.widget.RecyclerView android:id=\\\"@+id/garden_list\\\" app:isGone=\\\"@{!hasPlantings}\\\" app:layoutManager=\\\"androidx.recyclerview.widget.LinearLayoutManager\\\" tools:listitem=\\\"@layout/list_item_garden_planting\\\"/> </FrameLayout> </layout> \"]},\"402\":{\"h\":\"ViewModel管理数据与页面的交互\",\"t\":[\"DataBinding通过标记的形式将数据和组件绑定，在这个过程中他使用的数据则是来自于ViewModel的。在页面Activity(或Fragment)中，我们可以处理这两者之间的关系。\",\"ViewModel是设计用来以一种可以感知生命周期（lifecycle）的方式存储和管理与UI相关的数据，它可以允许数据在诸如屏幕旋转的变化中存活下来，也就是说VideModule的数据生命周期可能要比他附着的Activity或Fragment的生命周期长。\",\"同时，UI controller可以在Activity等不再需要数据时，自动调用ViewModel的onCleared()方法清除这些数据以避免内存泄漏。\",\"下图是ViewModel和Activity的生命周期对比： 此外，由于默认的获取ViewModel的方法只能调取无参构造函数，当需要向ViewModel传递参数时，就需要用到Factory工厂模式来创建ViewModel： \",\"val viewModel = ViewModelProviders.of(this, factory).get(GardenPlantingListViewModel::class.java) class PlantDetailViewModelFactory(args:Any) : ViewModelProvider.NewInstanceFactory() {...} \",\"还可以将ViewModel于LiveData结合，这样在Activity等地方对LiveData进行订阅后，当LiveData的值发生变化时Activity等可以及时得到通知，而做出相应变化。此外ViewModel与lifecycle的结合可以保证在Activity等生命周期结束后数据得到及时的清理。\"]},\"403\":{\"h\":\"Room保存数据\",\"t\":[\"Room持久性库在SQLite上提供了一个抽象层，以便在充分利用SQLite强大功能的同时，能够流畅的访问数据库。——Android Developers\",\"Room需要3个元素：\",\"Database 数据库，可以提供对表格的操作方法@DAO。是一个继承自RoomDatabase的抽象类。\",\"Entity 表格，规定了每个表格可以保存的数据格式。是一个普通类。\",\"Dao 数据访问结构（Data Access Object），定义了对表格@Entity中的数据的操作。是一个接口或者抽象类。\",\"此外，还可以对@DAO进行进一步的封装得到一个XXXRepository类，ViewModel通过这个XXXRepository类来操作数据，从而将其与数据的具体实现解耦。\"]},\"404\":{\"h\":\"WorkManager管理任务\",\"t\":[\"WorkManager用来管理即时或定时任务，官方定义是在指定约束条件成熟时可靠的在后台执行对应的任务。\",\"具体使用可以参考这个GIST。\",\"和他相关的有下面几个关键类：\",\"Worker 定义要执行的任务内容\",\"WorkRequest 代表一项单独的任务，明确具体要执行的任务内容（Worker）、任务的类型（WorkRequest.Builder的子类，决定任务一次性还是重复的）以及任务执行的条件（Constraints，如联网、电池电量等等）\",\"WorkManager 执行管理WorkRequest，安排执行Worker中的工作内容。\",\"Android Jetpack官网\",\"Android Jetpack-Navigation 使用中参数的传递\"]},\"405\":{\"h\":\"利用travis通过Hexo在Github上自动部署Markdown文档\",\"t\":[\"本文介绍了一个只需要更新Markdown文档到Github，即可实时更新博客内容的方法。\",\"本文参考这篇文章 实现，并根据我的需求更改了部分内容，以实现部署多个hexo工程到同一Github项目不同目录下。\",\"Github为我们提供了Github Pages 方便我们建立简单的网页来介绍项目，很多时候我们用他来搭建静态博客。\",\"通过Hexo可以将我们写的Markdown文档格式化为静态网页，再将其部署到Github上面对应的user_name.github.io上面，就可以拥有一个在线的静态博客。\",\"但是受Hexo的限制，每次更新博客内容都需要在更新完Markdown文档后，都需要再次重新创建对应的静态网页、将更新提交到Github。这样的步骤繁琐且没有意义，而且更换电脑后这些环境都需要重新设置一次。\",\"通过travis提供的免费CI技术，可以让云服务器代替我们实现Hexo创建以及同步Github等步骤，每次更新博客时只需要将写好的Markdown文档推送到Github项目对应目录中，等待一会儿就可以看到更新后的博客了。\",\"具体搭建过程可以参考这篇文章 本文只讲述实现部署多个hexo工程到同一Github项目不同目录下需要注意的地方：。\",\"懒——是第一生产力\"]},\"406\":{\"h\":\"hexo分支的结构\",\"t\":[\"因为有多个hexo项目，所以在github项目的hexo分支下，对不同的hexo项目分别新建文件夹存放。\",\"-- your_name.github.io //github项目，切换到hexo分支 --hexo_project1 //本地hexo项目1的所有文件 --hexo_project2 //本地hexo项目2的所有文件 \"]},\"407\":{\"h\":\".travis.yml\",\"t\":[\"重点修改script:和after_script:两部分：\",\"script: # 1. 创建对应的静态博客内容 - cd blog # 第一个本地hexo项目 - hexo clean - hexo generate - cd .. - cd imissyou # 第二个本地hexo项目 - hexo clean - hexo generate - cd .. after_script: - git config user.name \\\"jixiaoyong\\\" - git config user.email \\\"jixiaoyong1995@gmail.com\\\" - cd .. - mkdir publish - cd publish # 2. 在这里再拉取master分支的文件，并删除旧的博客内容 - git clone https://${GH_TOKEN}@github.com/jixiaoyong/jixiaoyong.github.io.git - rm -rf ./jixiaoyong.github.io/blog/* - rm -rf ./jixiaoyong.github.io/imissyou/* # 3. 将第1步生成的静态博客内容添加到master分支，并同步到github上面 - cd .. - cp -rf jixiaoyong.github.io/blog/public/* publish/jixiaoyong.github.io/blog/ - cp -rf jixiaoyong.github.io/imissyou/public/* publish/jixiaoyong.github.io/imissyou/ - cd publish/jixiaoyong.github.io/ - git add . - git commit -m \\\"auto update by www.travis-ci.org\\\" - git push \",\"文档链接：.travis.yml\",\"当以上内容都配置完成后，只要新建一个符合hexo要求的文档，并提交到Github对应项目的hexo分支中source目录，Travis便会自动帮我们创建并更新静态网页。\",\"Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程 （完全在该文档指导下完成，部分步骤有差异，感谢作者MichaelX ）\"]},\"408\":{\"h\":\"Hexo+Github=Blog\",\"t\":[\"注意\",\"这篇文章写于2016年，其所涉及内容可能已经发生较大变化，请酌情参考。\",\"Hello World！ \",\"一直以来，为了有一个合适的在线写字的地方，我尝试过许多种工具，从最初的 QQ 空间开始，到各种门户网站的博客，再到自己开始尝试搭建博客，一路奔忙，门户网站的限制太多，自己搭建的博客又时常由于空间提供商的各种问题而无法访问。许多时候一个平台只能使用一段时间，这样子颠颠撞撞大概也有五六年的时间了。\",\"一直听说 github 这个平台的各种优点，尤其是可以作为稳定而免费的空间托管博客最令我心动，但是之前多次尝试不得其道，终以失败告终。最近在学习 Android 语言的时候，又再次用起了 github ，不过这次是用它来存储代码。不得不承认，使用 github 来控制程序版本真是一件令人愉悦的事件。\",\"机缘巧合，因为需要将学习过程中的一些笔记，心得总结找个地方整理，显然单纯的使用 github 并不是一个好办法，而其他的平台的博客限制又太多，于是又尝试用 github 搭建一个博客，虽然对这些知识并不是很熟悉，但误打误撞竟然也成功的搭建好了博客。下面就把整个建站的过程大概梳理一下，以便以后查看。\",\"下载软件：\",\"git\",\"github windows 客户端(可选)\",\"node 客户端\"]},\"409\":{\"h\":\"装 git 环境\",\"t\":[\"安装 git:\",\"git 安装时按照默认的配置，一路点击确定就可以。\",\"安装 github 客户端（可选，如果熟悉 git 命令可以直接命令行操作）\",\"github 安装分为两种：\",\"用官网的安装包，在安装的时候需要从网上下载资料，受网速限制，这种方法很慢，而且容易出错；\",\"直接找一份 github 离线安装包解压到本地即可使用，我就是使用后一种方法。\"]},\"410\":{\"h\":\"安装 node\",\"t\":[\"安装 node 客户端：\",\"下载并安装 node ,我使用的版本是 node-v5.7.1-x64。\"]},\"411\":{\"h\":\"校验环境\",\"t\":[\"在安装完 git, node 之后win 键 + R 输入 cmd 打开 windows 自带终端窗口；\",\"分别输入git 、 npm之后，如果显示出 帮助信息 而非 “不是内部或外部命令，也不是可运行的程序或批处理文件” 这样的提示，就说明 git 和 node 已经配置好了环境变量，否则就需要手动配置。\"]},\"412\":{\"h\":\"配置环境变量方法：\",\"t\":[\"此电脑 –> 右键 –> 属性 –> 高级系统设置 –> 环境变量\",\"找到用户环境变量 –> path ，并添加 git 和 npm 的安装路径。\",\"更详细的教程可以参考这里：如何修改环境变量\",\"这样子 git 和 node 应该就可以正常使用了。\"]},\"413\":{\"h\":\"安装 hexo\",\"t\":[\"打开命令行，全局安装 Hexo ,加 -g 参数：\",\"npm install -g hexo \",\"查看 hexo 版本\",\"hexo version \",\"结果：\",\"Blockquotehexo-cli: 1.0.1os: Windows_NT 10.0.14316 win32 x64http_parser: 2.6.2node: 5.7.1v8: 4.6.85.31uv: 1.8.0zlib: 1.2.8ares: 1.10.1-DEVicu: 56.1modules: 47openssl: 1.0.2g \",\"到这里 hexo 就在电脑上面安装好了。\"]},\"414\":{\"h\":\"配置 hexo\",\"t\":[\"进入存放 hexo 文件的目录下，创建一个文件夹 blog 存储 hexo 的文件\",\"hexo init blog \",\"然后进入这个文件夹\",\"cd blog \",\"启动 hexo 服务器\",\"hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop \",\"打开本地地址：http://localhost:4000/ ，就可以看到本地搭建好的 hexo 博客了 这样子一个 hexo 博客就在本地搭建好了\"]},\"415\":{\"h\":\"目录的解释：\",\"t\":[\"scaffolds 脚手架，也就是一个工具模板 scripts 写文件的 js，扩展 hexo 的功能 source 存放博客正文内容 source/_drafts 草稿箱 source/_posts 文件箱 themes 存放皮肤的目录 themes/landscape 默认的皮肤 _config.yml 全局的配置文件 db.json 静态常量\"]},\"416\":{\"h\":\"一些 hexo 语句解释\",\"t\":[\"help 查看帮助信息 init 创建一个 hexo 项目 migrate 从其他系统向 hexo 迁移 version 查看 hexo 的版本 –config 参数，指定配置文件，代替默认的_config.yml –debug 参数，调试模式，输出所有日志信息 –safe 参数，安全模式，禁用所有的插件和脚本 –silent 参数，无日志输出模式\"]},\"417\":{\"h\":\"新建文章\",\"t\":[\"命名为“新的文章”，输入命令：\",\"hexo new 新的文章 \",\"hexo 默认生成 md 文件，新生成的文章在目录：.\\\\blog\\\\source_posts\\\\新的文章.md ，对其进行相应的编辑即可 文章格式：\",\"title: 新的文章date: 2014-05-07 18:44:12updated : 2014-05-10 18:44:12permalink: abctags:- 开始- 我- 日记categories:- 日志- 第一天--- \",\"或者你也可以直接自己在对应位置新建 file_name.md 文件（常用）\",\"注册并登录 github 进入 https://github.com/ ，注册新账户，并且登录\",\"新建 respositoy 在主页点击 New respositoy 新建一个名字为 yourname.github.io 的 respositoy；\",\"设置新建一个 github pages 进入仓库主页，选择 settings --> github pages --> Launch automatic page generator ,按照默认的主题配置选择一个就好\",\"对于 hexo 的相关配置： 打开_config.yml，修改以下部分：\",\"Sitetitle: Jixiaoyong's Blog subtitle: description: author: Jixiaoyong language: zh-CN timezone:# URL #If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: http://yoursite.github.io/ root: http://yoursite.github.io/blog/ \",\"此处由于我是将网站放在二级目录 ./blog/ 下面，所以 root 目录设置如此，使用的是绝对路径，否则在网页上显示的时候，css 等由于路径不对，加载可能会有问题。\"]},\"418\":{\"h\":\"部署方法 1\",\"t\":[\"deploy: type: git repo:https://github.com/yourname/yourname.github.io.git \",\"这行语句是使用 hexo 自动 deploy 到 github 时的设置，~如果正常的话，当用 hexo 对网站静态化处理后，再执行 hexo deploy 就可以自动部署到 github 上面了，但是我的电脑 git 或者 node 由于是不同时间装的期间还重装了几次系统，可能导致某些设置有误，所以在执行 hexo deploy 的时候一直提示有问题，故而采用另一种办法手动同步网站，这句话也可以不修改。~\"]},\"419\":{\"h\":\"部署方法 2\",\"t\":[\"用 hexo 对文章进行静态化处理：\",\"hexo generate \",\"在blog\\\\public目录下生成的 public 包含所有的静态化文件,此时，这个文件夹内所有的内容就是处理好的网站，将其发布到合适的空间就可以正常显示。 由于之前的 git 或者 node 配置有误，所以这时候采用手动同步网站:\",\"将上次在 github 上建立的项目 yourname.github.io 同步到本地。 同步的方法很多，这里我选择的是使用 github 的 windows 客户端，比较方便：\",\"打开 github 客户端，找到项目，选择 clone 到本地即可。\",\"之后打开同步的项目，确认当前的 branch 是 master，否则同步之后网站不会显示。\",\"在 github 同步的目录下找到上次建好的项目yourname.github.io,进入之后，将上文获得到的 public 内容放入目标文件夹，我选择的是将博客放在子目录，所以这里新建了一个 blog 文件夹用于放置博客，所以就是将 public 全部内容 放入./yourname.github.io/blog/ 目录下，这样子在网站上显示的时候，博客的网址就是http://yourname.github.io/blog/\",\"这样一个简单的利用 github 托管的 hexo 博客就搭建好了。\",\"注：本文内容是根据我建立博客时的做法整理而成，其中有部分内容是参考网上的教程，文中引用的文字全部来自http://blog.fens.me/hexo-bootstarp-github/ ，此文对我帮助很大，感谢作者张丹(Conan)的分享。\"]},\"420\":{\"h\":\"加载已安装应用、未安装apk中的资源\",\"t\":[\"加载已安装应用、未安装apk中的资源，其思路主要是获取到对应的ClassLoader/Context，通过ClassLoader加载R.java等类，再通过反射获取对应的资源id及资源。\"]},\"421\":{\"h\":\"sharedUserId\",\"t\":[\"在当前应用中加载已安装的其他应用资源，需要二者有相同的sharedUserId，这样Android系统为二者分配同一个Linux用户ID，两个App可以相互访问代码、资源等。\",\"通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样。\",\"Android逆向之旅---Android中的sharedUserId属性详解 - CSDN博客\",\"具体设置方法如下\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <manifest xmlns:android=\\\"http://schemas.android.com/apk/res/android\\\" package=\\\"cf.android666.dynamicloadapk\\\" android:sharedUserId=\\\"cf.android666.dynamic\\\"> </manifest> \"]},\"422\":{\"h\":\"筛选所有已安装应用信息\",\"t\":[\"private var packageBeanList: ArrayList<PackageInfoBean> = arrayListOf() private var packageInfoList: ArrayList<PackageInfo> = arrayListOf() var packageInfoList = packageManager.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES) as ArrayList<PackageInfo> if (packageInfoList.isNotEmpty()) { for (x in packageInfoList) { if (x.sharedUserId != null && x.sharedUserId.equals(sharedUid) && !x.packageName.equals(packageName)) { //sharedUserId与当前App相同，且packageName和当前App不同的App信息，即插件App packageBeanList.add(PackageInfoBean(packageManager .getApplicationLabel(x.applicationInfo).toString(), x.packageName)) } } } \"]},\"423\":{\"h\":\"生成插件App的Context\",\"t\":[\"activity.createPackageContext(\\\"cf.android666.pluginapp\\\", Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY) \"]},\"424\":{\"h\":\"通过Context反射获取插件App中的资源\",\"t\":[\"//获取ClassLoader var pClassLoader = PathClassLoader(pluginContext.packageResourcePath , ClassLoader.getSystemClassLoader()) //反射获取该类及其资源 var clazz = pluginContext.classLoader .loadClass(pluginContext.packageName + \\\".R\\\\$mipmap\\\") var abc = clazz.getField(s) var id = abc.getInt(R.mipmap::class.java) //调用插件App的Context获取其资源 var bg = pluginContext.resources.getDrawable(id) \"]},\"425\":{\"h\":\"获取apk信息\",\"t\":[\"val sdPath = Environment.getExternalStorageDirectory().absolutePath val apkPath = \\\"$sdPath/plugin/plugin.apk\\\" var info = packageManager.getPackageArchiveInfo(apkPath, PackageManager.GET_ACTIVITIES)//获取未安装apk的packageInfo \"]},\"426\":{\"h\":\"获取ClassLoader\",\"t\":[\"var file = getDir(\\\"dex\\\", Context.MODE_PRIVATE) var dexClassLoader = DexClassLoader(apkPath, file.absolutePath, null, ClassLoader.getSystemClassLoader()) \",\"getDir()调用了Context的getDir()\",\"Retrieve, creating if needed, a new directory in which the application can place its own custom data files. You can use the returned File object to create and access files in this directory. Note that files created through a File object will only be accessible by your own application; you can only set the mode of the entire directory, not of individual files.\"]},\"427\":{\"h\":\"通过反射加载类，获取资源\",\"t\":[\"var drawableClazz = dexClassLoader.loadClass(\\\"cf.android666.pluginapp.R\\\\$drawable\\\") var onePng = drawableClazz.getDeclaredField(\\\"abc\\\") var onId = onePng.getInt(R.id::class.java)//反射获取资源id var resources = getUninstallApkResource()//resource也是通过反射获取到 var drawable = resources.getDrawable(onId) \",\"AssetManager.addAssetPath()方法是用来将apk等中的资源添加到AssetManager中，再通过其获取到Resources对象，这样就获取到未安装apk中的资源了。\",\"fun getUninstallApkResource(): Resources { var assetManager = AssetManager::class.java.newInstance() var addAssetPath = assetManager.javaClass.getMethod(\\\"addAssetPath\\\",String::class.java) addAssetPath.invoke(assetManager, apkPath)//设置了apkPath return Resources(assetManager, resources.displayMetrics, resources.configuration) } \",\"Android之Android apk动态加载机制的研究（二）：资源加载和activity生命周期管理 - lee0oo0 - 博客园 \",\"Android逆向之旅---Android中的sharedUserId属性详解 - CSDN博客\"]},\"428\":{\"h\":\"数据结构_Hash表\",\"t\":[\"Hash表是一种可以快速插入和查找的数据结构，将数据保存在通过hash函数计算得到的下标中。\",\"插入和删除 所需时间为O(1)。在确定容量、无需遍历时效果最好。\",\"当其大小接近容量时，效率会变得很差。\",\"Hash表有两种存储方式\",\"开放地址法\",\"开放地址法，直接将数据存储在数组中。\",\"当hash算出的地址已经被占用时，则走过一定的步长找到另外一个空位（在填充质数很大时就会很耗时）并保存数据。\",\"链地址法\",\"链地址法，创建保存数据的数组，该数组中不直接保存数据，而是保存一个用来存储这些数据的链表，将数据项直接存储的链表中。\",\"当hash算法计算出的地址时，遍历数组中对应的链表找到空位并保存。\",\"其中，开放地址法又分为3种实现：\",\"线性探测\",\"每次前进的步长为1\",\"即查找的位置依次是x + 1,2,3,4,5,……\",\"存储达到容量2/3以上时候读写性能会很差 \",\"二次探测\",\"每次前进的步长为当前查找次数的平方\",\"即查找的位置依次是x + 1,4,9,……\",\"当前几次找不到之后就会很恐慌，步长越来越大到后面无法继续下去 \",\"再哈希法\",\"每次前进的步长是根据另外一个hash算法计算出来的值\",\"这个算法要求如下：\",\"1. 与第一次hash输出不同 2. 不能输出0 \",\"已经有一个公认的比较好的二次hash算法：\",\"stepSize = constant - (key % constant) 如：stepSize = 5 - (key % 5) * constant 是小于数组容量的质数 \",\"再哈希法 VS 二次探测法\",\"在小型哈希表中，再哈希法比二次探测好；\",\"但如果容量充足，并且容量大小不再变化时，二次探测效果好，在装填因子小于0.5时几乎没有性能损失\",\"开放地址法 VS 链地址法\",\"hash表容器大小未知时，用链地址法比较好\",\"当装填因子变得很大时，开放地址法性能下降很快，但链地址法只是线性下降。\",\"👉点这里查看源码\"]},\"429\":{\"h\":\"数据结构_二叉树\",\"t\":[\"本文介绍了二叉树，及其应用。\",\"树，既能像链表那样快速插入和删除，又可以像数组那样快速查找。\",\"树\",\"每棵树有且只有一个根，从根到任何一个节点有且只有一条路径；每个节点都可以有0个或者多个子节点，没有子节点的节点叫做叶子节点。\",\"层是指从根节点到该节点的“代”树，根节点的在0层。\",\"一个节点只能有0~2个子节点的树叫做二叉树；\",\"如果二叉树的左子节点的关键字小于该节点，右子节点的关键字大于该节点，则该二叉树称为二叉搜索树。\",\"如下，是一个二叉树的节点：\",\"class BinaryNode(val iId: Int, val dData: Double, var left: BinaryNode? = null, var right: BinaryNode? = null) { override fun toString(): String { return \\\"{$iId,$dData}\\\" } } \"]},\"430\":{\"h\":\"遍历\",\"t\":[\"遍历树指安装一定的顺序访问数的每个节点，按照访问节点的顺序不同，可以分为三种：\",\"前序遍历\",\"中序遍历\",\"后序遍历\",\"以中序遍历为例，其访问节点的顺序如下：\",\"调用自身遍历该节点的左子树；\",\"访问这个节点；\",\"调用自身遍历该节点的右子树。\",\"实现如下：\",\"/** * 中序遍历法 * 使所有节点的关键值按照升序被访问 */ fun inTraversing(node: BinaryNode?) { if (node == null) { return } inTraversing(node.left) print(\\\"$node,\\\") inTraversing(node.right) } \"]},\"431\":{\"h\":\"最大值和最小值\",\"t\":[\"二叉搜索树的最大值是右子树中最右端没有子节点的右子节点；\",\"二叉搜索树的最小值是左子树中最左端没有子节点的左子节点。\"]},\"432\":{\"h\":\"删除\",\"t\":[\"二叉搜索树因为节点要满足左子节点 < 节点 < 右子节点这个条件，所以删除需要分以下几种情况：\",\"按照要删除的节点子节点数目的不同，分为3种情况\",\"要删除的节点是叶节点 将其父节点的指向设为null即可\",\"要删除的节点有且只有一个节点 将其父节点指向其子节点\",\"要删除的节点有两个子节点 这时候可以找该子节点的右子树中最小的（或者左子树中最大的）节点并替换掉要删除的节点，\",\"与此同时如果这个节点有右子节点（或对应的左子节点）则按照2/3的规则处理，这样就能保证这个树的结构不会出错\",\"fun delete(iId: Int) { //查找iId对应的节点 var current = root var parent = root while (current?.iId != iId) { if (current == null) { return } parent = current current = if (iId > current.iId) { current.right } else { current.left } } if (parent == null) { return } /** * 按照要删除的节点子节点数目的不同，分为3种情况 * 1/3 要删除的节点是叶节点 将其父节点的指向设为null即可 * 2/3 要删除的节点有且只有一个节点 将其父节点指向其子节点 * 3/3 要删除的节点有两个子节点 这时候可以找该子节点的右子树中最小的（或者左子树中最大的）节点并替换掉要删除的节点， * 与此同时如果这个节点有右子节点（或对应的左子节点）则按照2/3的规则处理，这样就能保证这个树的结构不会出错 * 下面采用的是找该节点的右子树最小值，即右子节点或者右子节点的最后一个左子节点 * 找到后用该子节点的值替换掉要删除的节点值，如果该子节点还有右子节点，将该子节点的父节点指向其右子节点 */ if (current.left != null && current.right != null) { //双子节点 // 当前点右子节点的左子节点为null if (current.right!!.left == null) { if (current.iId > parent.iId) { parent.right = current.right } else { parent.left = current.right } //TODO 是否需要将右节点的左子节点指向当前点的左子节点 return } var cChildNode = current.right var cParentNode = current!! while (cChildNode?.left != null) { cParentNode = cChildNode cChildNode = cChildNode.left } //后继节点 cParentNode.left = cChildNode!!.right cChildNode!!.right = current.right cChildNode!!.left = current.left if (current.iId > parent.iId) { parent.right = cChildNode } else { parent.left = cChildNode } } else if (current.left == null && current.right == null) { //叶子节点 if (current.iId > parent.iId) { parent.right = null } else { parent.left = null } } else if (current.left == null) { if (current.iId > parent.iId) { parent.right = current.right } else { parent.left = current.right } } else if (current.right == null) { if (current.iId > parent.iId) { parent.right = current.left } else { parent.left = current.left } } } \",\"哈夫曼编码用来对一段文本进行压缩，解压。\",\"压缩：用字符的编码替代字符\",\"解压：用字符代替对应的编码\",\"实现思路如下：\",\" 将字符按照出现的频次生成优先级队列； \",\" 依次**取出**两个最小的字符，为他们生成一个父节点（父节点频次为两个子节点之和）； \",\" 并将插入优先级队列中，依次循环直到优先级队列中只有一个节点——哈夫曼树的根节点； \",\" 从哈夫曼树的根开始，以向左为0，向右为1对其叶子节点上的字符赋予编码。 \",\"其过程如下图所示：\",\"哈夫曼编码示意图\",\"👉点这里 查看二叉树源码\",\"👉点这里 查看哈夫曼编码源码\"]},\"433\":{\"h\":\"数据结构_图\",\"t\":[\"图，是由可以有多个边的顶点组成的结构。\",\"两个顶点之间有边连接，则称这两个顶点是邻接的。\",\"几个相互邻接的顶点组成的线叫做路径,至少有一条路径可以到达所有顶点的图叫做连通图。\",\"如果图的顶点只能从A→B，不能从B→A，就称图是有向图。\",\"如果边被赋予一定的权值（数字），就称图为带权图\",\"图一般有两种存储方式：\",\"邻接矩阵 用N*N的数组保存图中所有的顶点,Arr[m][n]即表示m、n顶点是否邻接（Y:1,N:0）。\",\"比较占地方。\",\"邻接矩阵\",\"邻接表 用一个N大小的数组保存，数组元素是保存着顶点和他所有的邻接点的链表。\",\"邻接表\",\"图的操作有插入（顶点），搜索等等。\",\"以下操作以邻接表方式为例。\"]},\"434\":{\"h\":\"插入\",\"t\":[\"插入分为插入顶点和插入边。\",\"插入边的时候需要注意，要同时更新start和end两个顶点对应的链表。\"]},\"435\":{\"h\":\"移除\",\"t\":[\"原理同插入边。\"]},\"436\":{\"h\":\"搜索\",\"t\":[\"搜索要求从某个特定顶点开始，沿着边移动到其他顶点，移动完毕后要保证访问了每个顶点。\",\"搜索又分为DFS（深度优先搜索）、BFS（广度优先搜索）。\"]},\"437\":{\"h\":\"DFS\",\"t\":[\"DFS的思想是，依次沿着顶点某一个邻接点，纵深访问，将该邻接点当做新的顶点压入栈中，继续纵深访问，直到有顶点没有可以访问的邻接顶点，将其打印出来（从栈中推出）；然后再返回上一层的邻接顶点中还可以访问的顶点（查找当前栈顶元素未访问的邻接点），直到没有可以访问的顶点。\",\"用栈实现，会先往深处遍历完一条路径，再遍历下一条。每个顶点只访问一次\",\"规则：\",\" 1/3 访问一个邻接的未访问顶点，访问并标记，将其压入栈中； \",\" 2/3 当规则1不能满足时，如果栈不为空，从栈中弹出一个顶点； \",\" 3/3 1,2都无法满足时，搜索结束。 \",\"private fun dfs() { var stacks = DfsStacks(hashMap.size) var keyArr = hashMap.keys.toIntArray() stacks.push(keyArr[0]) hashMap[keyArr[0]]?.isVisited = true var index = hashMap[keyArr[0]] while (stacks.size > 0) { var availableKey = getAvailableNode(index!!.data) if (availableKey != -1) { index = hashMap[availableKey]//深度优先搜索，会先顺着一个邻接点一直走到头 index!!.isVisited = true stacks.push(availableKey) } else { var pop = stacks.pop() print(\\\"$pop \\\") index = hashMap[stacks.peek()]//如果一个邻接点再没有未访问的邻接点，那么去访问下一个未访问的邻接点 } } } \"]},\"438\":{\"h\":\"BFS\",\"t\":[\"BFS的思想是，向将当前顶点的所有可以访问的邻接点访问完毕；之后将该顶点打印（推出），再去访问其邻接点的所有可以访问邻接点（从队列头取出一个顶点，查找其未访问的邻接点）。\",\"用队列实现，会先遍历完本层所有的顶点，然后再移向下一层\",\"规则：\",\" 1/3 先访问当前顶点的所有邻接顶点，标记，并插入到队列； \",\" 2/3 如果没有可以访问的邻接点，且队列不为空，从队列头取出一个顶点[此处又用到了一次该点]，使其成为当前顶点，重复1； \",\" 3/3 如果2不能满足，搜索结束。 \",\"private fun bfs() { var queue = BfsQueue() var keyArr = hashMap.keys.toIntArray() queue.push(keyArr[0]) hashMap[keyArr[0]]!!.isVisited = true var index = hashMap[keyArr[0]] while (queue.size > 0) { var availableKey = getAvailableNode(index!!.data) if (availableKey != -1) { var current = hashMap[availableKey]!!//广度优先搜索，优先将一个节点的所有邻接点依次访问 current.isVisited = true queue.push(current.data) } else { var pop = queue.pop() print(\\\"$pop \\\") if (queue.peek() == -1) { break } index = hashMap[queue.peek()]//如果该点没有未访问的邻接点，就选择去访问该点邻接点的邻接点 } } } \",\"生成树（Template:Lang-en-short）是具有图G的全部顶点，但边数最少的连通子图.\",\"——维基百科\",\"带权图的生成树中，总权重最小的称为最小生成树。\",\"最小生成树边比顶点数小1。\",\"当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。\",\"如果图的每一条边的权值都互不相同，那么最小生成树将只有一个。\",\"无向不带权图中，只需要找出最小数量的边即可。用DFS比较好实现，因为他对每个顶点只访问一次。\",\"拓扑排序是指有向图的顶点排序，满足以下条件*：\",\"每个顶点出现且只出现一次；\",\"若A在序列中排在B的前面，则在图中不存在从B到A的路径。\",\"实现思路是：\",\"依次推出有向图中没有后继点的顶点作为排序的最后项，这是因为按照拓扑排序条件2没有后继点的顶点必然排在后面；\",\"当去掉没有后继点的顶点后又会产生新的没有后继点的顶点，这样依次循环，当图中没有顶点的时候，就可以在有向无环图中完成拓扑排序。\",\"对于有环存在（即存在类似A→B，B→C，C→A的情况）的有向图，会出现找不到没有后继点的顶点，但同时图中顶点数不为0的情况，遇到这种情况退出循环，并说明有环存在即可。\",\"/** * 拓扑排序 */ fun topologicalSort() { if (hashMap.size == 0) { return } var displayList = ArrayList<T?>() while (hashMap.size > 0) { var successorKey = getSuccessorNode() if (successorKey == null) {//图中还有顶点，但却找不到“没有后继点的顶点”，说明有环 println(\\\"图中有环\\\") break } else { hashMap.remove(successorKey)//如果找到满足条件的顶点，从图中删除并保存的排序结果中 displayList.add(successorKey) } } print(\\\"\\\\n ${displayList.reversed()} \\\\n\\\")//以正确的顺序输出排序结果 } /** * 遍历图，查找没有后继点的顶点 * @return -1表示没有这样的点 否则返回该点key */ fun getSuccessorNode(): T? { val result: T? = null var ketSet = hashMap.keys ketSet.map {//遍历图中每个顶点 //如果顶点没有后继点(没有邻接点，或者邻接点已经被删除)就是满足条件 var node: GraphicNode<T>? = hashMap[it]?.next ?: return it while (node != null) { var realNode = hashMap[node.data] if (realNode != null) { return@map//有后继点，不满足条件，查找下一个顶点 } node = node.next//还有其他邻接点，依次遍历 } return it } return result//没有找到“没有后继点的顶点” } \",\"👉点这里 查看DFS/BFS/MST源码\",\"👉点这里 查看拓扑排序源码\",\"拓扑排序——维基百科\"]},\"439\":{\"h\":\"数据结构_堆\",\"t\":[\"堆是一种特殊的二叉树，用他实现的优先级队列插入和删除时间复杂度都是O(LogN) 。\",\"堆是完全二叉树*\",\"常用数组实现\",\"每个堆的节点都满足堆的条件，即堆的每个节点关键字都大于（或等于）子节点的关键字\",\"特征3保证了根节点是堆中最大的值，以及顺着某一个节点一直到遇到叶节点的路径上的节点关键字是依次递减的，但是没法保证这个值是这个堆中的最小值，这是因为堆中每个节点的左右子节点的位置和大小无关，两条这样的路径之前的值的大小没有一定的关系。\",\"堆可以进行插入、移除，遍历等操作，时间复杂度都是O(LogN)。初次之外，利用堆根节点关键值最大这个属性，还可以进行堆排序,时间复杂度为O(N∗LogN)。\",\"对于在数组中保存的堆，设元素下标为x，则各个相关元素下标如下：\",\"父节点 (x-1)/2\",\"左子节点 2*x+1\",\"右子节点 2*x+2\",\"在插入，移除的时候为了保证满足堆的条件，需要对堆进行向上或向下的遍历，将修改的值移动到对应的位置，在这过程中涉及到复制和交换。如果每次比较都需要交换数据的话会复制很多次，而如果将最终要移动值保存在临时变量中，用一个值专门记录要移动到的下标，在每次符合条件时只复制参与对比的值，在最后再将要临时保存的值复制到目的下标，就会减少复制的次数。\",\"如下图就将复制次数从9次减少到了5次。\"]},\"440\":{\"h\":\"插入\",\"t\":[\"插入操作思路是，将元素插入到数组最后一位，然后依次向元素父节点遍历，将不满足的元素下沉，直到找到满足堆特征3（父节点关键字大于该点，并且子节点关键字小于该点）的下标，或者指向了根目录，将该元素插入该处。\",\" /** * 从下向上遍历 * 如果父节点比插入值小，就将父节点移动到插入值的位置，将toIndex指向空出的地方 * 依次查找，直到查找到父节点比插入值大，子节点比插入值小的地方，或者指向了根节点 */ private fun checkUp(index: Int) { var bottom = headArray[index]//headArray是保存堆元素的数组 var toIndex = index var father = (toIndex - 1) / 2 while (toIndex > 0 && bottom!!.key > headArray[father]!!.key) { headArray[toIndex] = headArray[father]//将父节点下沉 toIndex = father father = (toIndex - 1) / 2 } headArray[toIndex] = bottom//将该值插入到对应下标 } \"]},\"441\":{\"h\":\"移除\",\"t\":[\"移除指的是将根节点推出堆中。\",\"基本思路是将根节点推出，再将数组最后一个节点（同时也是堆的最后一个节点）移动到根节点空出的位置，再依次向下遍历，直到将该节点放到符合堆条件的位置或者到达叶子节点。\",\"和插入相比，移除时要移动的节点要比较的稍微多些。\",\"该节点是叶节点 直接插入✅\",\"有两个子节点 和两个叶子节点中最大的比较，如果小于则交换，并再和新的子节点比较\",\"只有左节点 如果左节点大于本节点则交换，否则就是该位置\",\"/** * 从上向下遍历 * 如果遇到比当前值top大的就将其复制到当前位置toIndex，并记录下空出的位置为toIndex * 再以toIndex为起点向下比较，直到遇到top比父节点小，比子节点大的位置，或者叶子节点 * 将top移动到该位置 */ private fun checkDown(index: Int) { var toIndex = index var top = headArray[size - 1]!! while (toIndex < size / 2) {//非叶子节点 var leftIndex = 2 * toIndex + 1 var rightIndex = 2 * toIndex + 2 if (headArray[rightIndex] == null) {//只有左节点 if (headArray[leftIndex]!!.key > top.key) { headArray[toIndex] = headArray[leftIndex] toIndex = leftIndex } else { break } } else if (headArray[leftIndex] != null && headArray[rightIndex] != null) { if (headArray[leftIndex]!!.key >= headArray[rightIndex]!!.key) {//如果左节点比较大 if (headArray[leftIndex]!!.key > top.key) { headArray[toIndex] = headArray[leftIndex] toIndex = leftIndex } else { break } } else {//如果右节点比较大 if (headArray[rightIndex]!!.key > top.key) { headArray[toIndex] = headArray[rightIndex] toIndex = rightIndex } else { break } } } } headArray[toIndex] = top//将该节点移动到找到的下标处 } \"]},\"442\":{\"h\":\"堆排序\",\"t\":[\"利用堆根节点关键值最大这一特性，可以进行堆排序。\",\"只需要将待排序的数组依次插入堆中，然后再依次移除即可。\",\"这样需要有两倍与待排序数组大小的空间。如果每次插入时候只保存数据，不进行向上遍历，在每次移除数据时进行向下遍历，将当前剩余数据最大值选出来（其余数据仍然无序）从堆中移除根元素时都会在数组末尾空出一个位置，将该值存储在该位置即可，这样等完全插入、移除后就得到一个有序数组【从数组末尾开始依次减小】\",\"堆排序和快速排序时间复杂度都是 O(N*LogN) ，但是由于向上、向下遍历耗时，实际上要比快速排序稍慢一些。但是堆排序堆数据初始分布不敏感一直都是 O(N*LogN) ，快速排序在某些情况下时间复杂度可达到 O(N^2) 。\"]},\"443\":{\"h\":\"满二叉树\",\"t\":[\"满二叉树指除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。\",\"如果一个二叉树的层数为K，且节点总数是 (2k)−1 ，则它就是满二叉树。\",\"满二叉树\"]},\"444\":{\"h\":\"完全二叉树\",\"t\":[\"完全二叉树 如果将二叉树每层从左到右遍历，那么完全二叉树只有最后一层的右边会出现没有叶子节点的情况，即在前1~n之间没有“洞”。\",\"如下图就是一个完全二叉树：\",\"完全二叉树\",\"但下图不是完全二叉树：\",\"不是完全二叉树\",\"👉点这里 查看源码\",\"满二叉树——百度百科\",\"完全二叉树与满二叉树的区别\",\"《Java数据结构和算法 （第二版）》 Robert Lafore 陈维宁\"]},\"445\":{\"h\":\"数据结构_总结\",\"t\":[\"本文汇总了数据结构的优缺点及应用场景。\",\"通用数据结构：数组、链表、树、哈希表\",\"专用数据结构：栈、队列、优先级队列\",\"排序：冒泡排序、选择排序、插入排序，希尔排序、快速排序、归并排序、堆排序\",\"图：邻接矩阵、邻接表\",\"这些数据结构使用关键字的值存储、查找数据\",\"其速度如下：\",\"哈希表 > 树 > 链表 > 数组\",\"数组：数据量小，大小可以预测时使用\",\"链表：数据大小不可预知，或需要频繁插入删除元素时使用\",\"二叉搜索树：如果数组和链表都很慢时，优先考虑二叉树\",\"平衡树：二叉搜索树很快，但是如果遇到数据是逆序的时候，就会很耗性能，而平衡树则不会\",\"哈希表：在数据存储结构中最快，但是需要有额外的空间\",\"下面是以上数据结构的速度：\",\"通用数据结构速度统计\",\"包括栈、队列、优先级队列（堆），都是抽象数据结构(ADT)，由更加基础的通用数据结构组成。\",\"不能查找或者遍历，只能访问指定元素（头部，队列也可以访问尾部）。\"]},\"446\":{\"h\":\"栈\",\"t\":[\"先进后出(FILO)，最后插入的数据在栈顶，每次只能访问栈顶元素。\"]},\"447\":{\"h\":\"队列\",\"t\":[\"先进先出(FIFO)，最后插入的数据在队尾，最先插入的在队首，每次先弹出队首的元素。\"]},\"448\":{\"h\":\"优先级队列\",\"t\":[\"是一种特殊的队列，不同的是优先级高的在队首，优先级低的在队尾，每次弹出优先级最高的元素（这意味着每次插入或弹出时要进行排序）。\"]},\"449\":{\"h\":\"效率\",\"t\":[\"专用数据结构效率比较\",\"排序包括冒泡排序、选择排序、插入排序，希尔排序、快速排序、归并排序、堆排序。\",\"一般使用排序优先级：\",\"插入排序 > 希尔排序 > 快速排序 > 归并排序 > 堆排序\",\"归并排序：需要辅助存储空间\",\"堆排序：需要一个堆的数据结构，比快速排序更适于非随机数据\",\"快速排序：处理非随机数据时会慢到O(N2)​\",\"下面是排序算法比较：\",\"排序算法比较\"]},\"450\":{\"h\":\"数据结构_数组，链表\",\"t\":[\"本文介绍了数组、链表等数据结构。\",\"设定所有排序：小→大。\",\"数组（array）是一组具有相同类型元素的集合，用一段连续的内存来保存。使用下标来访问保存的元素，如a[0]。\",\"数组是一种数据存储结构。\",\"int a[] = new int[10]; \",\"数组大小固定，对指定下标元素读写快O(1)，但是查找慢O(N)，删除元素慢O(N)。\"]},\"451\":{\"h\":\"有序数组\",\"t\":[\"在每次插入的时候对元素进行排序，就得到有序数组。\",\"有序数组查找快O(LogN)，但插入慢O(N)，删除元素慢O(N)。\",\"有序数组插入：\",\"fun insertSort(key: Int) { if (size >= sortArr.size) { return } if (size == 0) { sortArr[size++] = key return } var insertIndex = ++size - 1 while (key < sortArr[insertIndex - 1]) { sortArr[insertIndex] = sortArr[insertIndex - 1] insertIndex-- if (insertIndex == 0) { break } } sortArr[insertIndex] = key } \",\"在有序数组要找到某个元素t可以使用二分查找，其思想是：\",\"选取一个中间值n将当前数组一分为二。\",\"如果t==n那么查找结束，如果t<n,那么在右半部分数组查找，否则在左半部分数组查找。\",\"重复步骤1,2，直到找到n或者数组已经不可再分（不存在n），结束查找。\",\"二分法查找：\",\"fun dichotomy(array: IntArray, key: Int): Int { if (array.size < 2) { return -1 } var centerIndex = array.size / 2 var centerKey = array[centerIndex] return when { key == centerKey -> centerIndex key < centerKey -> dichotomy(array.copyOfRange(0, centerIndex), key) else -> dichotomy(array.copyOfRange(centerIndex - 1, array.size), key) } } \",\"链表的每个节点除了保存的数据外，还保存着下一个节点的引用next，最后一个元素中该引用为null。\",\"链表的大小不固定，查找，删除，插入指定节点都需要O(N)\",\"链表有以下分类：\",\"单链表 每个节点只有指向下一个节点的引用，链表只保留第一个链节点的引用first\",\"单链表\",\"双向链表 每个节点保存有父节点和子节点的引用。双向链表也可以是双端链表。\",\"双向链表\",\"双端链表 双端链表保存第一个链节点farst和最后一个链节点last的引用。\",\"双端链表\",\"👉点这里 查看链表源码\",\"数组--维基百科\",\"Java数据结构和算法（第二版）Robert Laforce 计晓云等译\"]},\"452\":{\"h\":\"数据结构_栈和队列\",\"t\":[\"本文介绍栈、队列两种抽象数据类型。\",\"栈stack，又称堆栈，是一种抽象数据类型，每次只能访问栈顶元素top，可以进行压入push和推出pop操作。其元素先进后出(FILO)。\",\"队列queue,是和栈相对的一种抽象数据类型，每次从后端rear插入，从前端front删除。其元素先进先出(FIFO)。\",\"用链表实现的队列可以自由扩充，不存在伪溢出问题，但是插入和读取比较耗时；\",\"用数组实现的队列大小固定，可以使用循环队列解决伪溢出问题，即当尾端（前端也类似）指针指向超出数组大小时，可以指向数组开始位置，因为此时大小不超过数组的队列前端已经指向0之后的位置了，所以不会冲突。\"]},\"453\":{\"h\":\"优先级队列\",\"t\":[\"和队列定义一致，只是在每次插入的时候都进行排序，以满足排序规则（如尾端→前端小→大）。\",\"中缀表达式，指运算符在操作数中间的，如1 + 2。\",\"后缀表达式，指运算符在操作数后面的，如1 2 +。\",\"中缀表达式 ↔ 后缀表达式：\",\"中缀表达式：1 + 2 * ( 3 + 5 ) - 2 * 3 - 9 / 2 后缀表达式：1 2 3 5 + * + 2 3 * - 9 2 / - \",\"转换规则：\",\"设一个栈用于保存运算符，从左到右依次遍历中缀表达式，假设读取到的是x\",\"如果是操作数，则直接打印\",\"如果是运算符(，则压入栈中\",\"如果是运算符)，则推出栈中的元素，直到遇到(,推出(，继续读取下一个\",\"否则，读取栈顶元素top，如果是(，将x压入栈中；\",\"如果x优先于top，将x压入栈中；\",\"否则，将top推出，在此和新的top比较，直到遇到top是(或者优先级比x高，或者栈已经空了，将x插入栈中。\",\"/** * 中缀表达式转化为后缀表达式 * @param infix 中缀表达式 1+2 * @return 后缀表达式 1 2 + */ public static String[] covertInfixToPostfix(String infix) { StringBuilder stringBuilder = new StringBuilder(); OperatorStack operatorStack = new OperatorStack(); for (char item : infix.toCharArray()) { // 数字 if (item >= '0' && item <= '9') { stringBuilder.append(item + \\\",\\\"); } else if (item == '(') { operatorStack.insert(item); } else if (item == ')') { int size = operatorStack.size(); for (int i = 0; i < size; i++) { try { char pop = operatorStack.pop(); if (pop == '(') { break; } else { stringBuilder.append(pop + \\\",\\\"); } } catch (Exception e) { System.out.println(\\\"栈为空\\\"); } } } else { try { char peek = operatorStack.peek(); if (peek == '(') { operatorStack.insert(item); } else if (isPre(item, peek) > 0) { operatorStack.insert(item); } else { int size = operatorStack.size(); for (int i = 0; i < size; i++) { try { char pop = operatorStack.peek(); if (pop == '(') { break; } else if (isPre(item, peek) > 0) { break; } else { stringBuilder.append(pop + \\\",\\\"); operatorStack.pop(); } } catch (Exception e) { break; } } operatorStack.insert(item); } } catch (Exception e) { System.err.println(\\\"栈为空\\\"); operatorStack.insert(item); } } } int size = operatorStack.size(); for (int i = 0; i < size; i++) { try { stringBuilder.append(operatorStack.pop() + \\\",\\\"); } catch (Exception e) { System.out.println(\\\"栈为空\\\"); break; } } String result = stringBuilder.toString(); return result.split(\\\",\\\"); } \",\"👉点这里查看中缀表达式 → 后缀表达式源码\",\"堆栈——维基百科\",\"队列——维基百科\"]},\"454\":{\"h\":\"数据结构_简单排序\",\"t\":[\"所有排序顺序为 小 → 大。\",\"时间负责度都是O(N2)。\",\"排序速度：插入排序>选择排序>冒泡排序\"]},\"455\":{\"h\":\"冒泡排序\",\"t\":[\"时间复杂度：O(N2)\",\"最慢的排序，但是简单\",\"规则如下：\",\"从左到右，比较a和b，如果a>b，就交换a和b的位置\",\"再将a，b中较大的那个与c按照2的规则比较，直到最后一位\",\"重复1，2直到没有待排序的项目\",\"其思想是：每次选出当前未排序的元素中最大的元素并放到队尾（每次比较最大元素都会“冒泡”到队尾），这样当连续遍历n次后，每个元素都会排好序。\",\"/** * 冒泡排序 * 1. 每次比较前1~（n-i）个元素（i是排序次数），每次有大的就【移动】， * 这样子一轮比赛完毕最大的就在后面了 * 2. 这样子比较n次就可以完成排序 */ fun bubbleSort(intArray: IntArray): IntArray { var result = intArray var size = result.size for (index in 0 until size) { for (x in 0 until size - index - 1) { if (result[x] > result[x + 1]) {//【注意】冒泡排序，每次比较满足条件就会交换 var temp = result[x] result[x] = result[x + 1] result[x + 1] = temp } } } return result } \"]},\"456\":{\"h\":\"选择排序\",\"t\":[\"时间复杂度：O(N2)\",\"因为交换次数少，所以比冒泡快\",\"规则如下：\",\"假设第一项值最大，设其坐标为max，从左到右依次比较max和其他元素，如果遇到比max大的，将max坐标指向该值\",\"每轮结束后max就表示这轮比较最大的值坐标，将其与当前未排序的最后一项交换\",\"这样重复步骤1，2， n次就可以排序完成\",\"其思想是：每次比较当前最大的值，记录下其坐标，等当前比较完成就和未比较的最后一位交换，（这样子避免每次比较都要交换）。同样这样子比较n次就可以完成排序。\",\"/** * 选择排序 * 1. 每次比较前1~（n-i）个元素（i是排序次数），如果有大的就记录下位置，一轮比较完毕后交换他和最后一位的位置 * 2. 这样子比较n次就可以完成排序 */ fun selectSort(intArray: IntArray): IntArray { var result = intArray var size = result.size for (index in 0 until size) { var max = 0//假设arr[0]最大 for (x in 0 until size - index - 1) { if (result[max] < result[x + 1]) {//将max与每一项比较，注意这里参与比较的是max max = x + 1//遇到比max大的则记录下其位置 【注意】这里并没有交换 } } //在每轮比较完毕后max就是这轮比较出来的最大值位置，将其放到对应位置 var temp = result[size - index - 1] result[size - index - 1] = result[max] result[max] = temp } return result } \"]},\"457\":{\"h\":\"插入排序\",\"t\":[\"时间复杂度：O(N2)\",\"比冒泡快一倍，比选择排序快一些\",\"思想：假设一个标记元素的左边全部是有序数组，右边全是无序数组，那么只需要将右边的元素依次拿出来插入到左边的有序数组中即可。刚开始这个标记元素可以为0或者1（假设一个元素就是有序的）。\",\"/** * 插入排序 * 假设右端数组是有序的，依次从左端数组取出元素比较，插入到右边的有序数组 */ fun insertSort(intArray: IntArray): IntArray { var result = intArray var size = result.size for (insertIndex in 1 until size ) {//假设arr[0]已经是有序的，所以从1开始 var insertPoint = result[insertIndex] for (index in insertIndex - 1 downTo 0) { if (insertPoint < result[index]) { //默认要插入的点是有序的，如果有比插入点大的，则将该点和插入点交换 result[index + 1] = result[index] result[index] = insertPoint } else { //因为左边的数组是有序的，只要有比插入点小的元素，则剩下的肯定都小于该元素，不用再比较了 break } } } return result } \",\"👉点这里查看源码\"]},\"458\":{\"h\":\"数据结构_红黑树\",\"t\":[\"红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为O(log2​N)。\",\"红黑树必须满足以下条件：\",\"必须有颜色（黑/红）\",\"根节点颜色为黑\",\"若节点是红色，则子节点必须是黑色（反之则不然）\",\"到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色）\",\"如果不满足可以通过以下方式修正：\",\"改变节点颜色\",\"旋转（左、右）\",\"以某个支点旋转（右旋为例，旋转时注意更新各个节点的父节点）：\",\"本质是将该节点a向下进一位插入到其右节点b原先的位置，将其左节点c向上进一位插入到该节点a原先的位置，并将左节点c的右节点赋值给该节点a。\",\"步骤：\",\"将该节点a放到右节点b的位置，将该``左节点c放到节点a`原先的位置，依次类推\",\"特殊的，将该点a的内侧孙子（a的左子节点c的右子节点d）断开与其父节点c的连接，转而连接到a上，成为a的左子节点\",\"如图，依次插入6,34,23，以34为支点右旋：\",\"对获得的结果，由于，都是红色违反了规则3，将34的父节点23设置黑，祖父节点6设为红，以祖父节6点为支点左旋：\",\"最终结果\",\"每次插入红色节点，能够避免规则4。\",\"一般先以二叉搜索树的规则将数据插入表中，然后再对照规则检查是否需要调整红黑树。\",\"红黑树插入情况分类如下：\",\"插入位置为根节点，将节点颜色更改为黑色\",\"插入位置的父节点为根节点或父节点颜色为黑色，直接插入\",\"父节点为红色。\",\"只有父节点为红色这种情况需要进行修正，这时又可以细分为以下三种情况：\",\"表格来自 http://www.cnblogs.com/skywang12345/p/3245399.html#a1\",\"【注意】对于Case 3当祖父节点没有左节点无法右旋时的特殊处理：\",\"需要对先对当前节点的父节点进行右旋，再以父节点作为新插入的点N，将N的父节点设置为黑色，祖父节点设置为红色，以祖父节点为支点左旋。\",\"如依次插入如下值：\",\"32,3,53,13,983,[137],237,83,483,43,183 \",\"当插入137后红黑树如图：\",\"插入137后的树\",\"本来按照Case 3 父红 叔黑 是左节点 应该要以祖节点右旋，但是组节点53没有左子节点，无法右旋，所以先对父节点983进行右旋：\",\"再以983为新节点，父红 叔黑 是右节点，将父节点137设置为黑色，祖节点53设置为红色，以组节点53为支点左旋：\",\"删除比较复杂，可以有两种操作：\",\"在节点中保存一个标志位，标记该节点是否被删除，并不针真的删除该点。\",\"在执行删除操作时真正删除该点。\",\"👉点这里查看源码\",\"在线操作红黑树\",\"红黑树(一)之 原理和算法详细介绍\"]},\"459\":{\"h\":\"数据结构_递归和汉诺塔问题\",\"t\":[\"本文介绍了递归，归并排序，还有递归在汉诺塔问题上的应用。\",\"排序顺序为 小 → 大\",\"递归是一种在函数内部调用自己的函数。在满足一定条件后可以退出递归。\",\"比如三角数组就是一个简单的递归：\",\"有一组数据，满足这样的条件第n项 = 第n-1项 + n，就称为三角数组，如：\",\"1,2,6,10,15,21...\",\"这里面，第n项 = 第n-1项 + n,就是一个递归，每一项的计算结构都依赖于前一项的计算，直到第1项的计算结果为确定的1，不再继续递归。\",\"实现如下：\",\"/** * 三角数 * 第n个数 == 第n-1个数 + n */ fun triangleNum(num: Int): Int { if (num == 1) { return num } return num + triangleNum(num - 1) } \",\"汉诺塔是一种游戏，有三个柱子，其中一棵柱子上面有若干个半径依次递减的空心圆盘，每次只能移动最顶端的圆盘，并且下面的圆盘要比上面的圆盘直径大。游戏的目的就是在满足这些条件的前提下，将所有圆盘依次转移到另外一个圆盘上面。\",\"汉诺塔问题分析\",\"如图，实现的思路就是递归：\",\"将除最底部的圆盘bottom之外的所有圆盘当做一个整体other，那么问题就变成了如何将bottom和other这“两”个圆盘通过柱子B，移动到柱子C，这个问题显然很好解决，只需要将other移动到柱子B，再将bottom移动到柱子C即可。\",\"那么剩下的问题就成了如何将other从柱子A移动到柱子B，很显然可以参照步骤1。\",\"这样子这个问题就成了如何将一个bottom从一个柱子，移动到另外一个柱子的问题，而每个这样的问题的解决都依赖于other的解决，而这就是递归。\",\"具体实现：\",\"/** * 汉诺塔问题 * 将汉诺塔问题简化为3步： * 1/3 将最上层n-1项移动到过渡层 * 2/3 将最底层n移动到目标层 * 3/3 将n-1项移动到目标层 * @param num 要移动的层数 * @param from 所在层 * @param inter 过渡层 * @param to 目标层 */ var hanioStepNum = 0 fun hanioTower(num: Int, from: String, inter: String, to: String) { if (num == 1) { println(\\\"move 1 to $to\\\") hanioStepNum++ } else { hanioTower(num - 1, from, to, inter)//把`other`移动到中间柱子 println(\\\"move $num to $to\\\")//把`bottom`移动到目标柱子 hanioStepNum++ hanioTower(num - 1, inter, from, to)//把`other`移动到目标柱子 } } \",\"归并排序merge，将一个数组，分成两个子数组分别排序，之后再将拍好序的数组合并，这样就得到了一个有序数组。时间复杂度是O(N∗Log(N))。\",\"其思路是，将数组无限的分成两份分别进行排序，然后再将排好序的两个数组归并在一起得到有序数组。每个子数组的有序都依赖于其子数组的有序，直到每个子数组只有一个元素，这样的数组本身就是有序的。\",\"原理如下（假设序列共有n个元素）：\",\"将序列每相邻两个数字进行归并操作，形成两个n/2序列，排序后每个序列包含1/2元素\",\"若此时序列数不是1个，则将上述序列再次归并，分别形成两个n/4序列，每个序列包含1/4个元素\",\"重复步骤2，直到所有元素排序完毕，即序列数为1\",\"归并排序动态演示\",\"合并两个有序的数组(a,b)思想：\",\"将b中比a中小的元素都复制到a中对应位置，然后将剩下的元素全部依次复制到a的末尾。\",\"归并排序具体实现：\",\"/** * 归并排序 * 归并排序占空间（多占一个排序数组的大小），排序快（N*LogN） * 思想是: * 1/2 将数组无限分成两份，直到两份数组都是有序的（每个数组只有一个元素） * 2/2 再对其进行归并 * 小 -> 大 * @param intArr 待排序的数组 */ fun mergeSort(intArr: IntArray): IntArray { var size = intArr.size if (size == 1) { return intArr } else { var half = 0 if (size % 2 == 0) { half = size / 2 } else { half = (size + 1) / 2 } var arr1 = intArr.copyOfRange(0, half) val arr2 = intArr.copyOfRange(half, intArr.size) return merge(mergeSort(arr1), mergeSort(arr2))//将合并好的两个有序子数组合并 } } /** * 归并 * 合并两个有序的数组为新的有序数组 * 思想： * 1/2 相互比较两个数组每项大小，并将小的复制到新数组 * 2/2 将剩余的数组全部复制到新数组 * 小 -> 大 * @param intArrA 有序数组1 * @param intArrB 有序数组2 */ fun merge(intArrA: IntArray, intArrB: IntArray): IntArray { var resultArr = IntArray(intArrA.size + intArrB.size) var indexA = 0 var indexB = 0 var indexC = 0 while (indexA < intArrA.size && indexB < intArrB.size) { if (intArrA[indexA] < intArrB[indexB]) { resultArr[indexC++] = intArrA[indexA++] } else { resultArr[indexC++] = intArrB[indexB++] } } while (indexA < intArrA.size) { resultArr[indexC++] = intArrA[indexA++] } while (indexB < intArrB.size) { resultArr[indexC++] = intArrB[indexB++] } return resultArr } \",\"👉点这里 查看汉诺塔和递归排序源码\",\"归并排序——维基百科\"]},\"460\":{\"h\":\"数据结构_高级排序\",\"t\":[\"本文介绍两种高级排序：希尔排序和快速排序。\",\"希尔排序的时间复杂度是O(N∗(LogN)2)，简单易实现，在所有排序中可以优先使用。\",\"快速排序的时间复杂度是O(N∗LogN)，是所有通用排序中最快的。\",\"排序方向：小 → 大。\",\"希尔排序基于插入排序（将左边无须的元素依次插入到右边有序数组中），不同的是希尔排序的增量逐渐减小到1，而插入排序的增量一直是1。\",\"增量 排序的时候进行比较的两个元素之间的间隔：\",\"int[] arr = {1,2,3,4,5}; \",\"对于数组arr中的元素来说，1和 2之间的增量是1，而 1和 3之间的增量是2，以此类推。\",\"由于插入排序在排序进行到后期，右边有序数组的大小变大，导致插入和移动的次数越来越多，而且如果数组恰好是反序的，会很耗时。\",\"而希尔排序在刚开始排序时，先取一个适当的增量n，按照这个增量对数组arr进行插入排序，得到一个基本有序的数组，他内部有n个有序的子数组；再将增量n减一，在此进行插入排序；如此反复直到n为1，排序完毕的数据即为有序数组。\",\"希尔排序——4增量排序示意图\"]},\"461\":{\"h\":\"增量的选择\",\"t\":[\"可以想象，增量的计算对希尔排序效率有很大影响。\",\"这些增量的集合称为间隔序列，一般要求这些增量之间互质，这样就不会对已经排序的数组再次排序。\",\"一个常用的间隔序列计算公式：\",\"h=3h+1 计算的h值一般为：1,13,40,21... \",\"增量h要小于数组大小。\"]},\"462\":{\"h\":\"具体实现\",\"t\":[\"/** * 希尔排序 * 思路: * 1/3 将待排序数组分为h个间隔为h的小数组， * 2/3 对这些小数组进行插入排序,将排序结果写入原待排序数组 * 3/3 按照 h=3*h+1 的算法减小h在此进行希尔排序，直至h为1 * --将大数组分为较小的数组，拍完序后再对这些\\\"有序\\\"的小数组进行排序 * 小 - > 大 */ fun shellSort(intArray: IntArray, h: Int): IntArray { if (h == 1) { return insertSort(intArray) } else { //间隔排序 for (x in 0 until h) {//依次遍历x,x+1,x+2 ... x+(h-1);形成h个有序子数组 var list = arrayListOf<Int>() intArray.forEachIndexed { index, i -> if ((index + x) % h == 0) { list.add(i) } } var partSortArr = insertSort(list.toIntArray()) var listIndex = 0 intArray.forEachIndexed { index, i -> if ((index + x) % h == 0) { intArray[index] = partSortArr[listIndex++] } } } //将增量减小，再次减小排序，直到h==1 return shellSort(intArray, (h - 1) / 3) } } /** * 获取希尔排序间隔 * 对排序速度影响较大，要求互质，计算方式不唯一 */ fun getShellSortH(range: Int): Int { if (range < 5) { return 1 } var h = 1 while (h < range) { h = 3 * h + 1 } return (h - 1) / 3 } /** * 插入排序 * 思路： * 1/2 先假设第一个数是已经排好序的 * 2/2 将后面的数字依次与其比较，并插入到对应位置 * small -> big */ fun insertSort(intArray: IntArray): IntArray { for (i in 1 until intArray.size) { for (j in 0 until i) { if (intArray[i] < intArray[j]) { val temp = intArray[i] for (x in i downTo j) { if (x - 1 < 0) { break } intArray[x] = intArray[x - 1] } intArray[j] = temp } } } return intArray } \",\"快速排序在大多数情况下都是最快的。\"]},\"463\":{\"h\":\"划分\",\"t\":[\"划分指在一组数据中，指定一个值C,所有小于C的移动到左边，所有大于C的移动到右边。\",\"选出来的这个值C，叫做枢纽。\"]},\"464\":{\"h\":\"划分算法\",\"t\":[\"在数据左右两端各有一个指针指向当前元素：left，right；\",\"left指针向右移动查找比C大的值，right指针向左移动查找比C小的值，当遇到满足条件的元素则退出；\",\"当两个指针都退出时，将其指向的元素交换位置，然后再分别移动指针，直到两个指针相遇，划分结束。\"]},\"465\":{\"h\":\"快速排序的思路\",\"t\":[\"快速排序，选取一个枢纽，将数组划分为两个子数组，这样在枢纽C两边的数组满足：\",\"[左边子数组所有元素] < n < [右边子数组所有元素] \",\"这样将得到的每个子数组都划分为两个子数组，直到子数组只有一个元素（一个元素就是有序的），这样就完成了整个快速排序。\"]},\"466\":{\"h\":\"枢纽的选择\",\"t\":[\"枢纽选择影响着快速排序的效率：\",\"最简单的，可以选取数组第一个或者最后一个元素\",\"\\\"三数据项取中\\\"法，在数组首、尾、中取数排序，选中间的数作为枢纽。这样排序数组大小要>3。\"]},\"467\":{\"h\":\"具体实现\",\"t\":[\"/** * 快速排序所用的数组，使用前先初始化 */ lateinit var quickArray: IntArray /** * 快速排序算法 * #1 选择数组最右端元素作为枢纽 * 思想是 * 1/2 选出一个枢纽，先将其按大小划分为左右两部分 * 2/2 在划分好的两个数组中，分别再找一个枢纽，重复步骤1 */ fun quickSort1(left: Int, right: Int) { if (right - left <= 0) { return } /** * n 这个枢纽的取法很关键，决定了算法的速度 * 除过这里用到的取法之外，还可以有\\\"三数据项取中\\\"法，在数组首、尾、中取数排序，选中间的数作为枢纽。这样排序数组要>3 * 对于这些小于3的数组可以用插入排序法进行排序 */ val n = quickArray[right] val nIndex = devideArrayByN1(left, right, n) if (nIndex > 0) { quickSort1(left, nIndex - 1) } quickSort1(nIndex + 1, right) } /** * 划分算法决定了排序的准确性 * 提出一个阈值，并以此将数组划分为两部分 * 左边都小于枢纽，右边都大于枢纽 */ private fun devideArrayByN1(left: Int, right: Int, n: Int): Int { var leftIndex = left - 1 var rightIndex = right while (leftIndex < rightIndex) { while (leftIndex < rightIndex && quickArray[++leftIndex] < n) { } while (leftIndex < rightIndex && quickArray[--rightIndex] > n) { } val temp = quickArray[leftIndex] quickArray[leftIndex] = quickArray[rightIndex] quickArray[rightIndex] = temp } for (i in right downTo rightIndex) { if (i < 1) { break } quickArray[i] = quickArray[i - 1] } quickArray[rightIndex] = n return rightIndex } \",\"希尔排序、快速排序的思路，都是将一个大的待排序数组，通过不同的方法拆分成小的子数组，这样比较、移动的次数要小很多。\",\"👉点这里 查看源码\"]},\"468\":{\"h\":\"Python自动化部署文章\",\"t\":[\"这是一篇使用Python脚本发布的文章。\",\"python脚本实现一键自动新建文章，编译，预览，发布github.\",\"Just test\"]},\"469\":{\"h\":\"Posts\"}},\"dirtCount\":0,\"index\":[[\"尾\",{\"1\":{\"466\":1,\"467\":1}}],[\"尾递归\",{\"1\":{\"322\":2}}],[\"枢纽选择影响着快速排序的效率\",{\"1\":{\"466\":1}}],[\"枢纽的选择\",{\"0\":{\"466\":1}}],[\"叫做枢纽\",{\"1\":{\"463\":1}}],[\"划分结束\",{\"1\":{\"464\":1}}],[\"划分算法决定了排序的准确性\",{\"1\":{\"467\":1}}],[\"划分算法\",{\"0\":{\"464\":1}}],[\"划分指在一组数据中\",{\"1\":{\"463\":1}}],[\"划分\",{\"0\":{\"463\":1}}],[\"拍完序后再对这些\",{\"1\":{\"462\":1}}],[\"归并\",{\"1\":{\"459\":1}}],[\"归并排序占空间\",{\"1\":{\"459\":1}}],[\"归并排序具体实现\",{\"1\":{\"459\":1}}],[\"归并排序动态演示\",{\"1\":{\"459\":1}}],[\"归并排序merge\",{\"1\":{\"459\":1}}],[\"归并排序\",{\"1\":{\"445\":1,\"449\":3,\"459\":3}}],[\"形成h个有序子数组\",{\"1\":{\"462\":1}}],[\"形成两个n\",{\"1\":{\"459\":1}}],[\"形式的il\",{\"1\":{\"396\":1}}],[\"形式替换掉原先的值\",{\"1\":{\"54\":1}}],[\"汉诺塔问题\",{\"1\":{\"459\":1}}],[\"汉诺塔问题分析\",{\"1\":{\"459\":1}}],[\"汉诺塔是一种游戏\",{\"1\":{\"459\":1}}],[\"游戏的目的就是在满足这些条件的前提下\",{\"1\":{\"459\":1}}],[\"递归是一种在函数内部调用自己的函数\",{\"1\":{\"459\":1}}],[\"递归和汉诺塔问题\",{\"0\":{\"459\":1}}],[\"祖节点53设置为红色\",{\"1\":{\"458\":1}}],[\"祖父节点设置为红色\",{\"1\":{\"458\":1}}],[\"祖父节点6设为红\",{\"1\":{\"458\":1}}],[\"叔黑\",{\"1\":{\"458\":2}}],[\"断开与其父节点c的连接\",{\"1\":{\"458\":1}}],[\"旋转时注意更新各个节点的父节点\",{\"1\":{\"458\":1}}],[\"旋转\",{\"1\":{\"458\":1}}],[\"红\",{\"1\":{\"458\":1}}],[\"红黑树插入情况分类如下\",{\"1\":{\"458\":1}}],[\"红黑树必须满足以下条件\",{\"1\":{\"458\":1}}],[\"红黑树是一种特殊的二叉搜索树\",{\"1\":{\"458\":1}}],[\"红黑树\",{\"0\":{\"458\":1},\"1\":{\"458\":1}}],[\"黑\",{\"1\":{\"458\":1}}],[\"思路\",{\"1\":{\"462\":2}}],[\"思路来自这里\",{\"1\":{\"63\":1}}],[\"思想是\",{\"1\":{\"459\":1,\"467\":1}}],[\"思想\",{\"1\":{\"457\":1,\"459\":2}}],[\"遇到比max大的则记录下其位置\",{\"1\":{\"456\":1}}],[\"遇到这种情况退出循环\",{\"1\":{\"438\":1}}],[\"冒泡\",{\"1\":{\"455\":1}}],[\"冒泡排序\",{\"0\":{\"455\":1},\"1\":{\"445\":1,\"455\":2}}],[\"冒泡排序的思想是\",{\"1\":{\"289\":1}}],[\"头部\",{\"1\":{\"445\":1}}],[\"平衡树\",{\"1\":{\"445\":1}}],[\"希尔排序基于插入排序\",{\"1\":{\"460\":1}}],[\"希尔排序的时间复杂度是o\",{\"1\":{\"460\":1}}],[\"希尔排序和快速排序\",{\"1\":{\"460\":1}}],[\"希尔排序\",{\"1\":{\"445\":1,\"449\":2,\"460\":1,\"462\":1,\"467\":1}}],[\"希望以此记录自己提升技术能力的过程\",{\"1\":{\"0\":1}}],[\"队列queue\",{\"1\":{\"452\":1}}],[\"队列两种抽象数据类型\",{\"1\":{\"452\":1}}],[\"队列也可以访问尾部\",{\"1\":{\"445\":1}}],[\"队列\",{\"0\":{\"447\":1},\"1\":{\"445\":2,\"453\":1}}],[\"队列中\",{\"1\":{\"390\":1}}],[\"专用数据结构效率比较\",{\"1\":{\"449\":1}}],[\"专用数据结构\",{\"1\":{\"445\":1}}],[\"哈希表\",{\"1\":{\"445\":3}}],[\"哈夫曼编码示意图\",{\"1\":{\"432\":1}}],[\"哈夫曼编码用来对一段文本进行压缩\",{\"1\":{\"432\":1}}],[\"哈夫曼树的根节点\",{\"1\":{\"432\":1}}],[\"陈维宁\",{\"1\":{\"444\":1}}],[\"百度百科\",{\"1\":{\"444\":1}}],[\"洞\",{\"1\":{\"444\":1}}],[\"−1\",{\"1\":{\"443\":1}}],[\"满二叉树指除最后一层无任何子节点外\",{\"1\":{\"443\":1}}],[\"满二叉树\",{\"0\":{\"443\":1},\"1\":{\"443\":1,\"444\":1}}],[\"满足这样的条件第n项\",{\"1\":{\"459\":1}}],[\"满足以下条件\",{\"1\":{\"438\":1}}],[\"满足intent\",{\"1\":{\"12\":1}}],[\"满足条件后结束当天循环\",{\"1\":{\"3\":1}}],[\"初次之外\",{\"1\":{\"439\":1}}],[\"初始化isolate\",{\"1\":{\"381\":1}}],[\"初始化initializing\",{\"1\":{\"273\":1}}],[\"初始化各个变量downloader\",{\"1\":{\"371\":1}}],[\"初始化各种自定义属性\",{\"1\":{\"64\":1}}],[\"初始化okhttp3\",{\"1\":{\"364\":1}}],[\"初始化key\",{\"1\":{\"296\":1}}],[\"初始化秘钥\",{\"1\":{\"296\":1}}],[\"初始化时\",{\"1\":{\"279\":1}}],[\"初始化时可以为\",{\"1\":{\"161\":1}}],[\"初始化有且只有以下五种情况\",{\"1\":{\"279\":1}}],[\"初始化为默认值\",{\"1\":{\"277\":1}}],[\"初始化powerimagechannel等\",{\"1\":{\"211\":1}}],[\"初始化大小适配工具类\",{\"1\":{\"81\":1}}],[\"初始化\",{\"1\":{\"81\":1,\"279\":2}}],[\"初始化view\",{\"1\":{\"66\":1}}],[\"初始化硬件参数等\",{\"1\":{\"60\":1}}],[\"拓扑排序\",{\"1\":{\"438\":2}}],[\"拓扑排序是指有向图的顶点排序\",{\"1\":{\"438\":1}}],[\"拓展binder类\",{\"0\":{\"19\":1}}],[\"维基百科\",{\"1\":{\"438\":2,\"451\":1,\"453\":2,\"459\":1}}],[\"维持有一个消息队列event\",{\"1\":{\"95\":1}}],[\"纵深访问\",{\"1\":{\"437\":1}}],[\"广度优先搜索\",{\"1\":{\"436\":1,\"438\":1}}],[\"广泛阅读\",{\"1\":{\"0\":1}}],[\"深度优先搜索\",{\"1\":{\"436\":1,\"437\":1}}],[\"深入理解jvm\",{\"1\":{\"279\":1}}],[\"深入理解java枚举类型\",{\"1\":{\"294\":1}}],[\"深入理解java类型信息\",{\"1\":{\"279\":1}}],[\"深入理解java虚拟机\",{\"1\":{\"249\":1,\"317\":1,\"320\":1}}],[\"深入理解\",{\"1\":{\"279\":1}}],[\"深入java虚拟机\",{\"1\":{\"279\":1}}],[\"深入浅出\",{\"1\":{\"127\":1}}],[\"深入浅出aidl\",{\"1\":{\"40\":1}}],[\"深入思考\",{\"1\":{\"0\":1}}],[\"搜索结束\",{\"1\":{\"437\":1,\"438\":1}}],[\"搜索又分为dfs\",{\"1\":{\"436\":1}}],[\"搜索要求从某个特定顶点开始\",{\"1\":{\"436\":1}}],[\"搜索\",{\"0\":{\"436\":1}}],[\"搜索等等\",{\"1\":{\"433\":1}}],[\"顶点\",{\"1\":{\"433\":1}}],[\"邻接表\",{\"1\":{\"433\":2,\"445\":1}}],[\"邻接矩阵\",{\"1\":{\"433\":2,\"445\":1}}],[\"叶子节点\",{\"1\":{\"432\":1}}],[\"节点并替换掉要删除的节点\",{\"1\":{\"432\":2}}],[\"节点\",{\"1\":{\"432\":1}}],[\"层是指从根节点到该节点的\",{\"1\":{\"429\":1}}],[\"层之间\",{\"1\":{\"60\":1}}],[\"树\",{\"1\":{\"429\":3,\"445\":2}}],[\"👉点这里查看中缀表达式\",{\"1\":{\"453\":1}}],[\"👉点这里查看源码\",{\"1\":{\"428\":1,\"457\":1,\"458\":1}}],[\"👉点这里\",{\"1\":{\"432\":2,\"438\":2,\"444\":1,\"451\":1,\"459\":1,\"467\":1}}],[\"💡\",{\"1\":{\"372\":2,\"378\":1,\"383\":1}}],[\"步骤\",{\"1\":{\"458\":1}}],[\"步骤如下\",{\"1\":{\"19\":1,\"20\":1}}],[\"步长越来越大到后面无法继续下去\",{\"1\":{\"428\":1}}],[\"资源加载和activity生命周期管理\",{\"1\":{\"427\":1}}],[\"资源等\",{\"1\":{\"421\":1}}],[\"资源文件\",{\"1\":{\"66\":2}}],[\"托管的\",{\"1\":{\"419\":1}}],[\"部署方法\",{\"0\":{\"418\":1,\"419\":1}}],[\"部分步骤有差异\",{\"1\":{\"407\":1}}],[\"部分方法调用了native层的isolate实现\",{\"1\":{\"372\":1}}],[\"部分activity会使用此来操作scroll\",{\"1\":{\"219\":1}}],[\"部分\",{\"1\":{\"212\":2,\"399\":1}}],[\"部分的\",{\"1\":{\"212\":1}}],[\"部分future\",{\"1\":{\"109\":1}}],[\"禁用所有的插件和脚本\",{\"1\":{\"416\":1}}],[\"禁止指令重排优化\",{\"1\":{\"317\":1}}],[\"调试模式\",{\"1\":{\"416\":1}}],[\"调用自身遍历该节点的右子树\",{\"1\":{\"430\":1}}],[\"调用自身遍历该节点的左子树\",{\"1\":{\"430\":1}}],[\"调用自身之后\",{\"1\":{\"322\":1}}],[\"调用插件app的context获取其资源\",{\"1\":{\"424\":1}}],[\"调用pause次数分别为a\",{\"1\":{\"375\":1}}],[\"调用parcel\",{\"1\":{\"313\":1}}],[\"调用cancel\",{\"1\":{\"328\":1}}],[\"调用componentelement\",{\"1\":{\"126\":2}}],[\"调用函数之后\",{\"1\":{\"322\":1}}],[\"调用帮助类方法\",{\"1\":{\"301\":1}}],[\"调用resolveclass\",{\"1\":{\"272\":1}}],[\"调用renderobjectelement\",{\"1\":{\"127\":1}}],[\"调用findclass\",{\"1\":{\"272\":1}}],[\"调用findloadedclass\",{\"1\":{\"272\":1}}],[\"调用父类方法2\",{\"1\":{\"369\":1}}],[\"调用父类mount方法\",{\"1\":{\"127\":1}}],[\"调用父加载器的loadclass\",{\"1\":{\"272\":1}}],[\"调用回调\",{\"1\":{\"211\":1}}],[\"调用方法\",{\"1\":{\"369\":1}}],[\"调用方\",{\"1\":{\"211\":1,\"387\":1}}],[\"调用完成\",{\"1\":{\"211\":1}}],[\"调用imagecache\",{\"1\":{\"198\":1}}],[\"调用buildowner的buildscope\",{\"1\":{\"128\":1}}],[\"调用setstate方法更新\",{\"1\":{\"192\":1}}],[\"调用setstate从而触发rebuilt\",{\"1\":{\"155\":1}}],[\"调用setstate\",{\"1\":{\"128\":1}}],[\"调用系统创建线程的函数\",{\"1\":{\"115\":1}}],[\"调用\",{\"1\":{\"109\":1,\"175\":1,\"176\":1,\"201\":1,\"208\":1,\"321\":1}}],[\"调用仍是同步调用\",{\"1\":{\"43\":1}}],[\"调用本地写好的对应方法\",{\"1\":{\"40\":1}}],[\"调用enqueuemessage\",{\"1\":{\"31\":1}}],[\"调用服务中的方法\",{\"1\":{\"19\":1}}],[\"调用该方法\",{\"1\":{\"19\":1}}],[\"调用拦截方法\",{\"1\":{\"13\":1}}],[\"调用了context的getdir\",{\"1\":{\"426\":1}}],[\"调用了setmeasureddimension\",{\"1\":{\"65\":1}}],[\"调用了getpostmessage\",{\"1\":{\"30\":1}}],[\"调用了子view的dispatchtouchevent\",{\"1\":{\"13\":1}}],[\"调用了framelayout\",{\"1\":{\"13\":1}}],[\"迁移\",{\"1\":{\"416\":1}}],[\"项目\",{\"1\":{\"416\":1}}],[\"草稿箱\",{\"1\":{\"415\":1}}],[\"帮助信息\",{\"1\":{\"411\":1}}],[\"离线安装包解压到本地即可使用\",{\"1\":{\"409\":1}}],[\"受网速限制\",{\"1\":{\"409\":1}}],[\"搭建一个博客\",{\"1\":{\"408\":1}}],[\"心得总结找个地方整理\",{\"1\":{\"408\":1}}],[\"机缘巧合\",{\"1\":{\"408\":1}}],[\"机制\",{\"1\":{\"58\":1,\"272\":1}}],[\"语言的时候\",{\"1\":{\"408\":1}}],[\"语句解释\",{\"0\":{\"416\":1}}],[\"语句被锁定\",{\"1\":{\"294\":1}}],[\"语句执行向native发送io指令时\",{\"1\":{\"115\":1}}],[\"尤其是可以作为稳定而免费的空间托管博客最令我心动\",{\"1\":{\"408\":1}}],[\"许多时候一个平台只能使用一段时间\",{\"1\":{\"408\":1}}],[\"门户网站的限制太多\",{\"1\":{\"408\":1}}],[\"懒\",{\"1\":{\"405\":1}}],[\"懒汉模式\",{\"1\":{\"294\":2}}],[\"电池电量等等\",{\"1\":{\"404\":1}}],[\"电脑localhost或者127\",{\"1\":{\"76\":1}}],[\"明确具体要执行的任务内容\",{\"1\":{\"404\":1}}],[\"明确表明\",{\"1\":{\"234\":1}}],[\"规则如下\",{\"1\":{\"455\":1,\"456\":1}}],[\"规则\",{\"1\":{\"437\":1,\"438\":1}}],[\"规律是xml文件名+binding的驼峰命名\",{\"1\":{\"401\":1}}],[\"规定了每个表格可以保存的数据格式\",{\"1\":{\"403\":1}}],[\"规定\",{\"1\":{\"317\":1}}],[\"嵌套导航图中fragment自动生成的类\",{\"1\":{\"400\":1}}],[\"嵌套滑动包括滑动\",{\"1\":{\"55\":1}}],[\"嵌套滑动\",{\"1\":{\"41\":1}}],[\"植物列表\",{\"1\":{\"399\":1}}],[\"植物介绍\",{\"1\":{\"399\":1}}],[\"植物目录\",{\"1\":{\"399\":1}}],[\"植物目录和植物介绍三部分\",{\"1\":{\"399\":1}}],[\"界面\",{\"1\":{\"399\":3}}],[\"皆来自google的sunflower工程或其他互联网资源\",{\"1\":{\"399\":1}}],[\"破音\",{\"1\":{\"399\":1}}],[\"学习的过程需要不断的重复\",{\"1\":{\"398\":1}}],[\"学习的过程需要不断的探索\",{\"1\":{\"0\":1}}],[\"跟着教程做了几个app\",{\"1\":{\"398\":1}}],[\"介绍\",{\"1\":{\"397\":1}}],[\"唯一的一个activity\",{\"1\":{\"399\":1}}],[\"唯一的不同是\",{\"1\":{\"331\":1}}],[\"唯一不同的是多出的machine\",{\"1\":{\"396\":1}}],[\"独立的dart可执行文件承载了一个称为内核服务\",{\"1\":{\"393\":1}}],[\"达到最大数量就尝试复用\",{\"1\":{\"389\":1}}],[\"达到刷新页面的效果\",{\"1\":{\"134\":1}}],[\"附带当前isolate的send\",{\"1\":{\"389\":1}}],[\"附属在特定的父window中\",{\"1\":{\"41\":1}}],[\"区分了几种情况\",{\"1\":{\"387\":1}}],[\"区别不大\",{\"1\":{\"369\":1}}],[\"暂停时不能处理\",{\"1\":{\"376\":1}}],[\"暂停isolate\",{\"1\":{\"375\":1}}],[\"略\",{\"1\":{\"371\":1}}],[\"导入用到的各个类\",{\"1\":{\"371\":1}}],[\"导致插入和移动的次数越来越多\",{\"1\":{\"460\":1}}],[\"导致死锁\",{\"1\":{\"297\":1}}],[\"导致即使到了运行时也无法发现这个错误\",{\"1\":{\"291\":1}}],[\"导致内存浪费\",{\"1\":{\"265\":1}}],[\"导致\",{\"1\":{\"213\":1}}],[\"导致每次\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"导致其重叠部分的内容看起来好像在\",{\"1\":{\"172\":1}}],[\"导致build\",{\"1\":{\"143\":1}}],[\"导致appcolor也重新绘制\",{\"1\":{\"130\":1}}],[\"导致noname下面所有的子widget全部重新绘制\",{\"1\":{\"130\":1}}],[\"导致的结果就是\",{\"1\":{\"128\":1}}],[\"导致错误\",{\"1\":{\"85\":1}}],[\"导致显示异常\",{\"1\":{\"53\":1}}],[\"于是又尝试用\",{\"1\":{\"408\":1}}],[\"于是用python实现爬取其网页内容并生成json数据\",{\"1\":{\"371\":1}}],[\"于是准备执行tag2\",{\"1\":{\"294\":1}}],[\"教程内容是爬取1000条百度百科的数据\",{\"1\":{\"371\":1}}],[\"欢迎访问其blog\",{\"1\":{\"370\":1}}],[\"欢迎提issue告知\",{\"1\":{\"91\":1}}],[\"乌鸦嘴\",{\"1\":{\"370\":1}}],[\"伪装为浏览器\",{\"1\":{\"370\":1}}],[\"伪代码\",{\"1\":{\"13\":1}}],[\"升级版\",{\"1\":{\"370\":1}}],[\"爬取目标网页内容\",{\"1\":{\"371\":1}}],[\"爬取gityuan\",{\"1\":{\"370\":1}}],[\"爬虫主要活动是\",{\"1\":{\"371\":1}}],[\"爬虫很容易被识别并被拒绝服务\",{\"1\":{\"370\":1}}],[\"爬虫被识别\",{\"1\":{\"370\":1}}],[\"防止太频繁访问被识别\",{\"1\":{\"370\":1}}],[\"防止某进程正在访问共享资源时\",{\"1\":{\"58\":1}}],[\"循环遍历这些链接\",{\"1\":{\"370\":1}}],[\"循环提示用户直到满足指定的条件\",{\"1\":{\"3\":1}}],[\"汇总信息输出config\",{\"1\":{\"370\":1}}],[\"抛出异常\",{\"1\":{\"369\":1}}],[\"键\",{\"1\":{\"411\":1}}],[\"键的集合\",{\"1\":{\"369\":1}}],[\"键值对\",{\"1\":{\"369\":1}}],[\"键盘等\",{\"1\":{\"361\":1}}],[\"元组tuple\",{\"1\":{\"369\":1}}],[\"元数据验证\",{\"1\":{\"276\":1}}],[\"空子节点指本应该有叶节点却没有的节点\",{\"1\":{\"458\":1}}],[\"空间开始\",{\"1\":{\"408\":1}}],[\"空间不足时则将children一个个依次排列\",{\"1\":{\"241\":1,\"242\":1}}],[\"空间不足时可滑动\",{\"1\":{\"241\":1}}],[\"空值\",{\"1\":{\"369\":1}}],[\"布尔值可以用and\",{\"1\":{\"369\":1}}],[\"布尔值\",{\"1\":{\"369\":1}}],[\"布局也会随之自动更新\",{\"1\":{\"401\":1}}],[\"布局出现错误\",{\"1\":{\"143\":2}}],[\"布局信息主要在这里展示\",{\"1\":{\"132\":1}}],[\"布局\",{\"0\":{\"139\":1},\"1\":{\"65\":1}}],[\"布局文件\",{\"1\":{\"55\":1,\"56\":1,\"66\":1}}],[\"浮点数float\",{\"1\":{\"369\":1}}],[\"长整数long\",{\"1\":{\"369\":1}}],[\"长度最大不能超过65535\",{\"1\":{\"283\":1}}],[\"整数int\",{\"1\":{\"369\":1}}],[\"整个代码块执行失败\",{\"1\":{\"323\":1}}],[\"整个过程可以分为\",{\"1\":{\"211\":1}}],[\"整个过程如下\",{\"1\":{\"110\":1}}],[\"整个android的时间分发始于activity\",{\"1\":{\"13\":1}}],[\"渣英语请忽略\",{\"1\":{\"368\":1}}],[\"词\",{\"1\":{\"361\":1}}],[\"逆序\",{\"1\":{\"361\":1}}],[\"逆变\",{\"0\":{\"293\":1},\"1\":{\"322\":1}}],[\"排序完毕的数据即为有序数组\",{\"1\":{\"460\":1}}],[\"排序的时候进行比较的两个元素之间的间隔\",{\"1\":{\"460\":1}}],[\"排序方向\",{\"1\":{\"460\":1}}],[\"排序快\",{\"1\":{\"459\":1}}],[\"排序后每个序列包含1\",{\"1\":{\"459\":1}}],[\"排序顺序为\",{\"1\":{\"459\":1}}],[\"排序速度\",{\"1\":{\"454\":1}}],[\"排序算法比较\",{\"1\":{\"449\":1}}],[\"排序包括冒泡排序\",{\"1\":{\"449\":1}}],[\"排序\",{\"1\":{\"361\":1,\"445\":1}}],[\"排序开始的时\",{\"1\":{\"289\":1}}],[\"忽略大小写\",{\"1\":{\"361\":2}}],[\"忽略指定警告\",{\"1\":{\"298\":1}}],[\"追加输入\",{\"1\":{\"361\":1}}],[\"追踪onbind方法\",{\"1\":{\"58\":1}}],[\"标准错误\",{\"1\":{\"361\":1}}],[\"标准输出\",{\"1\":{\"361\":1}}],[\"标准输入\",{\"1\":{\"361\":1}}],[\"标记该节点是否被删除\",{\"1\":{\"458\":1}}],[\"标记\",{\"1\":{\"438\":1}}],[\"标记这个方法被调用多少次\",{\"1\":{\"395\":1}}],[\"标记注解\",{\"1\":{\"301\":1}}],[\"标记压缩法\",{\"0\":{\"264\":1}}],[\"标记清除法\",{\"0\":{\"263\":1},\"1\":{\"264\":1}}],[\"登录\",{\"1\":{\"360\":1}}],[\"登录时间\",{\"1\":{\"353\":1}}],[\"环境\",{\"0\":{\"409\":1},\"1\":{\"366\":1}}],[\"环境变量\",{\"0\":{\"360\":1},\"1\":{\"412\":1}}],[\"环境下安装和配置\",{\"1\":{\"347\":1}}],[\"别名配置\",{\"0\":{\"359\":1}}],[\"双端链表保存第一个链节点farst和最后一个链节点last的引用\",{\"1\":{\"451\":1}}],[\"双端链表\",{\"1\":{\"451\":2}}],[\"双向链表也可以是双端链表\",{\"1\":{\"451\":1}}],[\"双向链表\",{\"1\":{\"451\":2}}],[\"双子节点\",{\"1\":{\"432\":1}}],[\"双引号\",{\"1\":{\"358\":1}}],[\"双亲委托\",{\"1\":{\"272\":1}}],[\"清屏\",{\"1\":{\"357\":1}}],[\"清除对象后内存不连续\",{\"1\":{\"263\":1}}],[\"清除缓存之后又要从网络下载\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"清除所有内容\",{\"1\":{\"57\":1}}],[\"↔\",{\"1\":{\"357\":2,\"453\":1}}],[\"全部内容\",{\"1\":{\"419\":1}}],[\"全都是用fragment实现\",{\"1\":{\"399\":1}}],[\"全名\",{\"1\":{\"353\":1}}],[\"全局的配置文件\",{\"1\":{\"415\":1}}],[\"全局安装\",{\"1\":{\"413\":1}}],[\"全局分析指示在更改优化代码的内容时丢弃优化代码\",{\"1\":{\"396\":1}}],[\"全局配置唯一的okhttpclient\",{\"1\":{\"362\":1}}],[\"全局变量\",{\"1\":{\"281\":1}}],[\"全局未捕获异常处理\",{\"1\":{\"145\":1}}],[\"删\",{\"1\":{\"353\":1}}],[\"删除比较复杂\",{\"1\":{\"458\":1}}],[\"删除元素慢o\",{\"1\":{\"450\":1,\"451\":1}}],[\"删除list\",{\"1\":{\"369\":1}}],[\"删除别名\",{\"1\":{\"359\":1}}],[\"删除\",{\"0\":{\"432\":1},\"1\":{\"347\":1,\"451\":1}}],[\"删除数据时\",{\"1\":{\"48\":1}}],[\"删除key以及对应的数据\",{\"1\":{\"47\":1}}],[\"增量h要小于数组大小\",{\"1\":{\"461\":1}}],[\"增量的计算对希尔排序效率有很大影响\",{\"1\":{\"461\":1}}],[\"增量的选择\",{\"0\":{\"461\":1}}],[\"增量\",{\"1\":{\"460\":1}}],[\"增\",{\"1\":{\"353\":1}}],[\"增加超时处理\",{\"1\":{\"370\":1}}],[\"增加图片自动上传\",{\"1\":{\"368\":1}}],[\"增加文件名中文支持\",{\"1\":{\"368\":1}}],[\"增加一个值为value的变量key\",{\"1\":{\"358\":1}}],[\"增加\",{\"1\":{\"351\":1}}],[\"增加了随机性\",{\"1\":{\"280\":1}}],[\"增加了一些特有的加载中\",{\"1\":{\"200\":1}}],[\"增加了磁盘缓存\",{\"1\":{\"198\":2}}],[\"增加messenger和handler处理服务端回复\",{\"1\":{\"20\":1}}],[\"果\",{\"1\":{\"352\":1}}],[\"遮盖的原则是从原先的权限中减去umask中的权限\",{\"1\":{\"352\":1}}],[\"遮盖后\",{\"1\":{\"352\":1}}],[\"临时文件\",{\"1\":{\"349\":1}}],[\"光驱等\",{\"1\":{\"349\":1}}],[\"摘录自下面这篇文章\",{\"1\":{\"347\":1}}],[\"摘录如下\",{\"1\":{\"347\":1}}],[\"测试\",{\"1\":{\"347\":1}}],[\"测量\",{\"1\":{\"65\":1}}],[\"名字起一个容易识别的名字\",{\"1\":{\"347\":1}}],[\"名称\",{\"1\":{\"54\":1,\"57\":1,\"361\":1}}],[\"账号\",{\"1\":{\"347\":1}}],[\"画二叉树和写出前序遍历\",{\"1\":{\"346\":1}}],[\"画出对应的界面\",{\"1\":{\"64\":1}}],[\"画出文字\",{\"1\":{\"64\":1}}],[\"画出置顶的导航title\",{\"1\":{\"64\":1}}],[\"画出各个导航title\",{\"1\":{\"64\":1}}],[\"知道中序和后序遍历\",{\"1\":{\"346\":1}}],[\"知乎\",{\"1\":{\"280\":1,\"281\":1,\"293\":1,\"297\":1}}],[\"右旋为例\",{\"1\":{\"458\":1}}],[\"右\",{\"1\":{\"458\":1}}],[\"右边都大于枢纽\",{\"1\":{\"467\":1}}],[\"右边子数组所有元素\",{\"1\":{\"465\":1}}],[\"右边有序数组的大小变大\",{\"1\":{\"460\":1}}],[\"右边全是无序数组\",{\"1\":{\"457\":1}}],[\"右边的子树\",{\"1\":{\"346\":1}}],[\"右子节点\",{\"1\":{\"439\":1}}],[\"右子节点这个条件\",{\"1\":{\"432\":1}}],[\"右子节点的关键字大于该节点\",{\"1\":{\"429\":1}}],[\"右子树两个部分\",{\"1\":{\"346\":1}}],[\"右键\",{\"1\":{\"412\":1}}],[\"右两个子树\",{\"1\":{\"346\":1}}],[\"右移\",{\"1\":{\"280\":1}}],[\"切割\",{\"1\":{\"345\":1}}],[\"切换页面时\",{\"1\":{\"178\":1}}],[\"切换到hexo分支\",{\"1\":{\"406\":1}}],[\"切换到指定的isolate\",{\"1\":{\"386\":1}}],[\"切换到同一级的linux目录\",{\"1\":{\"349\":1}}],[\"切换到当前用户home路径下\",{\"1\":{\"349\":1}}],[\"切换到新建立的分支\",{\"1\":{\"347\":1}}],[\"切换到\",{\"1\":{\"174\":1}}],[\"切换时\",{\"1\":{\"173\":2}}],[\"切换退出当前isolate\",{\"1\":{\"115\":1}}],[\"把`other`移动到目标柱子\",{\"1\":{\"459\":1}}],[\"把`other`移动到中间柱子\",{\"1\":{\"459\":1}}],[\"把`bottom`移动到目标柱子\",{\"1\":{\"459\":1}}],[\"把更新的内容合并到本地分支\",{\"1\":{\"347\":1}}],[\"把字符串按照\",{\"1\":{\"345\":1}}],[\"把递归通过编译器转化为迭代\",{\"1\":{\"322\":1}}],[\"凡是可迭代的数据都可以使用map\",{\"1\":{\"345\":1}}],[\"完整的二叉树也会被建立起来\",{\"1\":{\"346\":1}}],[\"完整语法形式的参数声明放在大括号内\",{\"1\":{\"345\":1}}],[\"完全二叉树与满二叉树的区别\",{\"1\":{\"444\":1}}],[\"完全二叉树\",{\"0\":{\"444\":1},\"1\":{\"444\":2}}],[\"完全在该文档指导下完成\",{\"1\":{\"407\":1}}],[\"完全解析\",{\"1\":{\"325\":1,\"326\":1}}],[\"完全自定义\",{\"1\":{\"204\":1}}],[\"完全可以没有\",{\"1\":{\"85\":1}}],[\"合并两个有序的数组为新的有序数组\",{\"1\":{\"459\":1}}],[\"合并两个有序的数组\",{\"1\":{\"459\":1}}],[\"合并两个流的值\",{\"1\":{\"344\":1}}],[\"合并之后为\",{\"1\":{\"344\":2}}],[\"合并发射项\",{\"1\":{\"344\":1}}],[\"命令可以直接命令行操作\",{\"1\":{\"409\":1}}],[\"命令式\",{\"1\":{\"343\":1}}],[\"命名为\",{\"1\":{\"417\":1}}],[\"命名关键词参数\",{\"1\":{\"369\":1}}],[\"命名规则\",{\"1\":{\"369\":1}}],[\"命名的\",{\"1\":{\"156\":1}}],[\"命名的一众子类\",{\"1\":{\"153\":1}}],[\"命名\",{\"1\":{\"146\":2,\"157\":2,\"184\":1}}],[\"命名管道\",{\"1\":{\"58\":1}}],[\"展平为单个流\",{\"1\":{\"340\":1}}],[\"展平流\",{\"0\":{\"340\":1}}],[\"展示带单位的文件大小\",{\"1\":{\"350\":1}}],[\"展示所有文件\",{\"1\":{\"350\":1}}],[\"展示当前目录下文件信息\",{\"1\":{\"350\":1}}],[\"展示另外一部分child的内容\",{\"1\":{\"239\":1}}],[\"展示内容为\",{\"1\":{\"231\":1}}],[\"展示部分的内容已经完成\",{\"1\":{\"213\":1}}],[\"展示图片\",{\"1\":{\"207\":1,\"209\":1}}],[\"展示图片的流程一致\",{\"1\":{\"205\":1}}],[\"展示图片的呢\",{\"1\":{\"193\":1}}],[\"展示对应图片\",{\"1\":{\"207\":1}}],[\"展示\",{\"1\":{\"192\":1}}],[\"展示加载失败\",{\"1\":{\"191\":1}}],[\"展示loading动画\",{\"1\":{\"191\":1}}],[\"展示占位widget\",{\"1\":{\"181\":1}}],[\"展示错误页面\",{\"1\":{\"143\":1}}],[\"展示此widget\",{\"1\":{\"143\":1}}],[\"求和\",{\"1\":{\"337\":1}}],[\"末端流操作符\",{\"0\":{\"337\":1}}],[\"集合\",{\"1\":{\"335\":1}}],[\"梳理了学习过程中的要点和理解\",{\"1\":{\"335\":1}}],[\"拥有同一个user\",{\"1\":{\"421\":1}}],[\"拥有独立的event\",{\"1\":{\"391\":1}}],[\"拥有尽可能简单的设计\",{\"1\":{\"335\":1}}],[\"拥有一个jvm实例\",{\"1\":{\"249\":1}}],[\"毫秒\",{\"1\":{\"334\":1,\"336\":1}}],[\"延迟\",{\"1\":{\"334\":1}}],[\"延迟生产多个值并返回\",{\"1\":{\"327\":1}}],[\"意味着该\",{\"1\":{\"334\":1}}],[\"意思是当按下按钮的时候\",{\"1\":{\"79\":1}}],[\"监督协程中的异常\",{\"0\":{\"333\":1}}],[\"监督作用域\",{\"0\":{\"332\":1}}],[\"监督作业\",{\"0\":{\"331\":1}}],[\"监督\",{\"0\":{\"330\":1}}],[\"监听isolate\",{\"1\":{\"378\":1}}],[\"监听流完成\",{\"1\":{\"343\":2}}],[\"监听用户手势\",{\"1\":{\"227\":1}}],[\"监听自身变化时执行\",{\"1\":{\"218\":1}}],[\"监听native端发送的图片加载结束事件\",{\"1\":{\"211\":1}}],[\"监听回调方法\",{\"1\":{\"211\":1}}],[\"监听动画进度\",{\"1\":{\"181\":2}}],[\"监听动画的值和状态\",{\"1\":{\"168\":1}}],[\"监听动画\",{\"1\":{\"160\":1}}],[\"监听传入的两个\",{\"1\":{\"159\":1}}],[\"监听并根据\",{\"1\":{\"157\":1}}],[\"监听并处理binder死亡事件\",{\"0\":{\"38\":1}}],[\"监听listenable\",{\"1\":{\"155\":1}}],[\"监听\",{\"1\":{\"138\":1,\"148\":1,\"157\":1,\"158\":1,\"168\":1,\"181\":1}}],[\"监听binder的死亡事件\",{\"1\":{\"36\":1}}],[\"监听其发送的广播broadcast\",{\"1\":{\"11\":1}}],[\"监听每日循环的闹钟\",{\"0\":{\"11\":1}}],[\"异常处理\",{\"0\":{\"341\":1}}],[\"异常被抛出后\",{\"1\":{\"329\":1}}],[\"异常的传播\",{\"0\":{\"329\":1}}],[\"异步会有对应回调\",{\"1\":{\"362\":1}}],[\"异步流\",{\"1\":{\"334\":1}}],[\"异步异常\",{\"1\":{\"142\":1}}],[\"异步读取文件\",{\"1\":{\"111\":2}}],[\"异步消息处理机制\",{\"1\":{\"22\":1}}],[\"异步消息机制\",{\"0\":{\"22\":1}}],[\"另一个或多个协程消费这些流\",{\"1\":{\"328\":1}}],[\"另外一处使用的仍然是修改前的值\",{\"1\":{\"281\":1}}],[\"另外一个常用的图片库flutter\",{\"1\":{\"202\":1}}],[\"另外一个coordinatorlayout的子view指定了behavior为appbarlayout\",{\"1\":{\"55\":1}}],[\"弓\",{\"1\":{\"328\":1}}],[\"拦截异常\",{\"1\":{\"328\":1}}],[\"拦截事件\",{\"1\":{\"13\":1}}],[\"透明捕获\",{\"1\":{\"327\":1,\"341\":1}}],[\"透明度等变化\",{\"1\":{\"181\":1}}],[\"透明度等变化的动画\",{\"1\":{\"181\":1}}],[\"透明度\",{\"1\":{\"181\":1}}],[\"串行执行\",{\"1\":{\"327\":1}}],[\"抹平\",{\"1\":{\"327\":1}}],[\"压缩文件file并输出到file\",{\"1\":{\"356\":1}}],[\"压缩文件并输出到屏幕\",{\"1\":{\"356\":1}}],[\"压缩等级\",{\"1\":{\"356\":1}}],[\"压缩后格式\",{\"1\":{\"355\":1}}],[\"压缩和解压缩\",{\"0\":{\"355\":1}}],[\"压缩\",{\"1\":{\"327\":1,\"357\":1,\"432\":1}}],[\"限长操作符\",{\"1\":{\"338\":1}}],[\"限长过渡操作符\",{\"1\":{\"327\":1}}],[\"限制只有name和age作为关键词参数\",{\"1\":{\"369\":1}}],[\"限制只能是产生\",{\"1\":{\"212\":1}}],[\"限制只能是可以产生\",{\"1\":{\"212\":1}}],[\"限制输入的关键字\",{\"1\":{\"369\":1}}],[\"限制\",{\"1\":{\"295\":1}}],[\"限制针对的是\",{\"1\":{\"197\":1}}],[\"扩展\",{\"1\":{\"415\":1}}],[\"扩展函数\",{\"1\":{\"327\":1}}],[\"扩展类加载器\",{\"1\":{\"272\":1}}],[\"假装我们异步等待了\",{\"1\":{\"336\":1}}],[\"假装我们以消耗\",{\"1\":{\"327\":1}}],[\"假装我们在这里做了一些有用的事情\",{\"1\":{\"327\":1}}],[\"假设序列共有n个元素\",{\"1\":{\"459\":1}}],[\"假设右端数组是有序的\",{\"1\":{\"457\":1}}],[\"假设一个元素就是有序的\",{\"1\":{\"457\":1}}],[\"假设一个标记元素的左边全部是有序数组\",{\"1\":{\"457\":1}}],[\"假设arr\",{\"1\":{\"456\":1,\"457\":1}}],[\"假设第一项值最大\",{\"1\":{\"456\":1}}],[\"假设读取到的是x\",{\"1\":{\"453\":1}}],[\"假设当前目录有文件f1\",{\"1\":{\"349\":1}}],[\"假设有两个线程t1\",{\"1\":{\"294\":1}}],[\"假设为obj\",{\"1\":{\"288\":1}}],[\"假设为maxszie\",{\"1\":{\"131\":1}}],[\"假设将这个引用指向了另外一个anobj对象\",{\"1\":{\"281\":1}}],[\"假设child尺寸大于singlechildscrollview的最大尺寸\",{\"1\":{\"239\":1}}],[\"假设从页面\",{\"1\":{\"173\":1}}],[\"假设如下变量\",{\"1\":{\"81\":1}}],[\"假设起点\",{\"1\":{\"62\":1}}],[\"假设你定义了一个最小高度\",{\"1\":{\"55\":1}}],[\"构建器中注册它没有任何效果\",{\"1\":{\"329\":1}}],[\"构建器中的代码直到流被收集的时候才运行\",{\"1\":{\"327\":1}}],[\"构建器生产了1\",{\"1\":{\"327\":1}}],[\"构建器定义了一个发射固定值集的流\",{\"1\":{\"327\":1}}],[\"构造方法指定的imageprovider\",{\"1\":{\"190\":1}}],[\"构造方法\",{\"0\":{\"161\":1}}],[\"构造函数之外\",{\"1\":{\"204\":1}}],[\"构造函数中只有一个必传项imageprovider\",{\"1\":{\"188\":1}}],[\"构造函数\",{\"1\":{\"31\":1}}],[\"五\",{\"1\":{\"325\":1,\"326\":1}}],[\"五列1\",{\"1\":{\"198\":1}}],[\"挂起和结束时修改当前线程threadlocal的值为之前保存的值\",{\"1\":{\"325\":1}}],[\"挂起当前线程\",{\"1\":{\"58\":1}}],[\"推出\",{\"1\":{\"438\":1,\"453\":1}}],[\"推出的是整个func\",{\"1\":{\"322\":1}}],[\"推荐直接阅读官方原文\",{\"1\":{\"392\":1}}],[\"推荐命名为self\",{\"1\":{\"369\":1}}],[\"推荐使用sparsearray及其衍生类以节省内存\",{\"1\":{\"44\":1,\"287\":1}}],[\"推荐使用不是很精确的setinexactrepeating\",{\"1\":{\"3\":1}}],[\"推荐\",{\"1\":{\"31\":1,\"144\":1,\"287\":1,\"361\":1}}],[\"修饰\",{\"1\":{\"322\":1}}],[\"修改以下部分\",{\"1\":{\"417\":1}}],[\"修改要注解的类\",{\"1\":{\"300\":1}}],[\"修改到其他线程中对应的值\",{\"1\":{\"288\":1}}],[\"修改了这个局部变量\",{\"1\":{\"281\":1}}],[\"修改这两个\",{\"1\":{\"226\":1}}],[\"修改\",{\"1\":{\"54\":2,\"146\":1,\"157\":1}}],[\"修改incominghandler\",{\"1\":{\"20\":1}}],[\"委托类的初始化函数\",{\"1\":{\"322\":1}}],[\"委托属性\",{\"1\":{\"322\":1}}],[\"委托示意图\",{\"1\":{\"322\":1}}],[\"委托是将重复出现的代码放到一个地方\",{\"1\":{\"322\":1}}],[\"既能像链表那样快速插入和删除\",{\"1\":{\"429\":1}}],[\"既能insert正确返回对应的类型\",{\"1\":{\"322\":1}}],[\"既可以使用预设的powerimage\",{\"1\":{\"204\":1}}],[\"安全模式\",{\"1\":{\"416\":1}}],[\"安全的使用\",{\"1\":{\"322\":1}}],[\"安装分为两种\",{\"1\":{\"409\":1}}],[\"安装时按照默认的配置\",{\"1\":{\"409\":1}}],[\"安装\",{\"0\":{\"410\":1,\"413\":1},\"1\":{\"409\":2,\"410\":1}}],[\"安排执行worker中的工作内容\",{\"1\":{\"404\":1}}],[\"安排执行listener回调\",{\"1\":{\"103\":1}}],[\"安排屏幕帧绘制\",{\"1\":{\"117\":1}}],[\"安排重复闹钟\",{\"1\":{\"12\":1}}],[\"你对类型参数一无所知\",{\"1\":{\"322\":1}}],[\"你需要知道的一切\",{\"1\":{\"21\":1}}],[\"密封类的所有子类必须在一个文件\",{\"1\":{\"322\":1}}],[\"密度\",{\"1\":{\"53\":1}}],[\"未安装apk中的资源\",{\"0\":{\"420\":1},\"1\":{\"420\":1}}],[\"未爬取具体文章内容\",{\"1\":{\"370\":1}}],[\"未登录时会执行\",{\"1\":{\"361\":1}}],[\"未优化前\",{\"1\":{\"322\":1}}],[\"未重合部分\",{\"1\":{\"57\":1}}],[\"英国\",{\"1\":{\"321\":1}}],[\"英文文档若无特殊说明都是引用官方文档\",{\"1\":{\"274\":1}}],[\"蜡笔小勋\",{\"1\":{\"320\":1}}],[\"乐观锁\",{\"1\":{\"320\":1}}],[\"偏向锁\",{\"1\":{\"320\":1}}],[\"轻量级锁消耗比传统锁机制小\",{\"1\":{\"320\":1}}],[\"轻量级锁\",{\"1\":{\"320\":1}}],[\"锁粗化\",{\"1\":{\"320\":1}}],[\"锁消除\",{\"1\":{\"320\":1}}],[\"锁绑定多个条件\",{\"1\":{\"318\":1}}],[\"锁池\",{\"1\":{\"297\":1}}],[\"公平的\",{\"1\":{\"328\":1}}],[\"公平锁\",{\"1\":{\"318\":1}}],[\"公差\",{\"1\":{\"165\":1}}],[\"功能有\",{\"1\":{\"318\":1}}],[\"阻塞和唤醒会很耗时\",{\"1\":{\"320\":1}}],[\"阻塞和唤醒需要由系统内核完成\",{\"1\":{\"317\":1}}],[\"阻塞同步\",{\"0\":{\"318\":1}}],[\"工厂函数与\",{\"1\":{\"328\":1}}],[\"工厂方法powerimageprovider\",{\"1\":{\"208\":1}}],[\"工作内存与主内存同步延迟导致\",{\"1\":{\"317\":1}}],[\"工作内存三者交互关系\",{\"1\":{\"317\":1}}],[\"较复杂\",{\"1\":{\"316\":1}}],[\"灵活\",{\"1\":{\"313\":1}}],[\"灵感参考头条屏幕适配\",{\"1\":{\"81\":1}}],[\"具有特定的存储规则\",{\"1\":{\"309\":1}}],[\"具体设置方法如下\",{\"1\":{\"421\":1}}],[\"具体搭建过程可以参考这篇文章\",{\"1\":{\"405\":1}}],[\"具体见参考资料\",{\"1\":{\"400\":1}}],[\"具体见代码中实现\",{\"1\":{\"371\":1}}],[\"具体实现\",{\"0\":{\"462\":1,\"467\":1},\"1\":{\"459\":1}}],[\"具体实现在portmap\",{\"1\":{\"378\":1}}],[\"具体实现之前\",{\"1\":{\"188\":1}}],[\"具体使用方法见如下\",{\"1\":{\"306\":1}}],[\"具体使用可以参考这个gist\",{\"1\":{\"404\":1}}],[\"具体使用可以参考这篇文章\",{\"1\":{\"21\":1}}],[\"具体使用可以参见这篇文章\",{\"1\":{\"40\":1}}],[\"具体代码如下\",{\"1\":{\"289\":1}}],[\"具体分析可参考\",{\"1\":{\"287\":1}}],[\"具体jdk1\",{\"1\":{\"280\":1}}],[\"具体试讲所有存活的对象都向一端移动\",{\"1\":{\"264\":1}}],[\"具体值在\",{\"1\":{\"111\":1,\"112\":1}}],[\"具体可以参考flutter之future原理解析\",{\"1\":{\"103\":1}}],[\"具体可参考文章\",{\"1\":{\"54\":1}}],[\"具体的如何计算java中object大小\",{\"1\":{\"282\":1}}],[\"具体的处理滑动手势\",{\"1\":{\"227\":1}}],[\"具体的实现如下\",{\"1\":{\"111\":1}}],[\"具体的实现一般分为下面几步\",{\"1\":{\"94\":1}}],[\"具体的计算原理我们可以参考这篇文章\",{\"1\":{\"62\":1}}],[\"具体原因见后面\",{\"1\":{\"70\":1}}],[\"具体内容\",{\"1\":{\"69\":1}}],[\"具体则在mremote\",{\"1\":{\"58\":1}}],[\"具体配置请参考\",{\"1\":{\"54\":1}}],[\"返序列化读取的过程在readresolve\",{\"1\":{\"309\":1}}],[\"返回上次所在目录\",{\"1\":{\"349\":1}}],[\"返回上面创建好的dart\",{\"1\":{\"114\":1}}],[\"返回可迭代的数组\",{\"1\":{\"345\":1}}],[\"返回新的转换流的定义\",{\"1\":{\"327\":1,\"338\":1}}],[\"返回true允许更改值\",{\"1\":{\"322\":1}}],[\"返回true表示改变了child\",{\"1\":{\"55\":1}}],[\"返回单例本身\",{\"1\":{\"305\":1}}],[\"返回as\",{\"1\":{\"294\":1}}],[\"返回该node\",{\"1\":{\"280\":1}}],[\"返回null\",{\"1\":{\"280\":1}}],[\"返回其引用\",{\"1\":{\"254\":2}}],[\"返回超出界限的值overscroll\",{\"1\":{\"220\":1}}],[\"返回结果\",{\"1\":{\"211\":1}}],[\"返回结果两部分\",{\"1\":{\"211\":1}}],[\"返回了\",{\"1\":{\"207\":1}}],[\"返回powerexternalimage\",{\"1\":{\"205\":1}}],[\"返回值\",{\"1\":{\"196\":1}}],[\"返回值为\",{\"1\":{\"55\":2}}],[\"返回一个新的与之相反的curve\",{\"1\":{\"186\":1}}],[\"返回一个key为hero\",{\"1\":{\"175\":1}}],[\"返回\",{\"1\":{\"159\":3,\"171\":1,\"205\":1,\"221\":1}}],[\"返回和当前\",{\"1\":{\"159\":1}}],[\"返回为null的错误会导致widget构建失败\",{\"1\":{\"141\":1}}],[\"返回要展示的页面控件\",{\"1\":{\"134\":1}}],[\"返回要展示的控件即可\",{\"1\":{\"133\":1}}],[\"返回的内容或者为空\",{\"1\":{\"174\":1}}],[\"返回的\",{\"1\":{\"174\":1,\"226\":1}}],[\"返回的就是container\",{\"1\":{\"120\":1}}],[\"返回的mwindow是phonewindow的对象\",{\"1\":{\"13\":1}}],[\"返回创建好的future\",{\"1\":{\"103\":1}}],[\"返回dagger\",{\"1\":{\"92\":1}}],[\"返回测量大小\",{\"1\":{\"65\":1}}],[\"返回getsuggestedminimumwidth\",{\"1\":{\"65\":1}}],[\"返回模式\",{\"1\":{\"55\":1}}],[\"返回index\",{\"1\":{\"49\":1}}],[\"返回开始用aidl创建的ibinder\",{\"1\":{\"36\":1}}],[\"返回客户端\",{\"1\":{\"20\":1}}],[\"返回主进程继续正常开启app\",{\"1\":{\"14\":1}}],[\"演示序列化功能\",{\"1\":{\"308\":1}}],[\"写文件的\",{\"1\":{\"415\":1}}],[\"写权限2\",{\"1\":{\"351\":1}}],[\"写入以下代码\",{\"1\":{\"348\":1}}],[\"写入\",{\"1\":{\"306\":1}}],[\"写该类自身的属性\",{\"1\":{\"306\":1}}],[\"福尔马林\",{\"1\":{\"306\":1}}],[\"序列化魔法方法及使用示例\",{\"1\":{\"316\":1}}],[\"序列化的高级认识\",{\"1\":{\"316\":1}}],[\"序列化的字节流可以在文件\",{\"1\":{\"310\":1}}],[\"序列化与反序列化都需要用户自己实现\",{\"1\":{\"313\":1}}],[\"序列化过程大量使用反射和临时变量\",{\"1\":{\"310\":1}}],[\"序列化时\",{\"1\":{\"309\":1}}],[\"序列化机制为了节省磁盘空间\",{\"1\":{\"309\":1}}],[\"序列化\",{\"1\":{\"303\":1}}],[\"周志明\",{\"1\":{\"320\":1}}],[\"周六\",{\"1\":{\"302\":2}}],[\"周五\",{\"1\":{\"302\":2}}],[\"周四\",{\"1\":{\"302\":2}}],[\"周三\",{\"1\":{\"302\":2}}],[\"周二\",{\"1\":{\"302\":2}}],[\"周一\",{\"1\":{\"302\":2}}],[\"周日\",{\"1\":{\"302\":2}}],[\"法\",{\"1\":{\"466\":1,\"467\":1}}],[\"法国则是monday\",{\"1\":{\"302\":1}}],[\"法栈\",{\"1\":{\"249\":1}}],[\"美国\",{\"1\":{\"321\":1}}],[\"美国一周从sunday\",{\"1\":{\"302\":1}}],[\"美团\",{\"1\":{\"54\":1}}],[\"四天或以上\",{\"1\":{\"302\":1}}],[\"起始年份中大部分\",{\"1\":{\"302\":1}}],[\"起点前一个点为beforepointf\",{\"1\":{\"62\":1}}],[\"起点和终点已知\",{\"1\":{\"61\":1}}],[\"格式化日期时\",{\"1\":{\"302\":1}}],[\"核心方法如下\",{\"1\":{\"300\":1}}],[\"核心代码\",{\"1\":{\"72\":2,\"295\":1,\"296\":2}}],[\"唤醒的耗时\",{\"1\":{\"319\":1}}],[\"唤醒所有等待中的线程\",{\"1\":{\"297\":1}}],[\"唤醒结果如下\",{\"1\":{\"5\":1}}],[\"嗯\",{\"1\":{\"294\":1}}],[\"饿汉模式仍然有浪费资源的嫌疑\",{\"1\":{\"294\":1}}],[\"饿汉模式\",{\"1\":{\"294\":2}}],[\"令as\",{\"1\":{\"294\":1}}],[\"否的话生成类对象再返回\",{\"1\":{\"294\":1}}],[\"否则同步之后网站不会显示\",{\"1\":{\"419\":1}}],[\"否则创建新的并返回\",{\"1\":{\"389\":1}}],[\"否则创建新的element并替代\",{\"1\":{\"126\":1}}],[\"否则要用\",{\"1\":{\"369\":1}}],[\"否则可为\",{\"1\":{\"321\":1}}],[\"否则反序列化时会出错\",{\"1\":{\"307\":1}}],[\"否则threshold不为空则返回threshold\",{\"1\":{\"280\":1}}],[\"否则以链表形式保存数据\",{\"1\":{\"280\":1}}],[\"否则column按照自己的内容大小来\",{\"1\":{\"242\":1}}],[\"否则减小\",{\"1\":{\"239\":1}}],[\"否则为0\",{\"1\":{\"238\":1}}],[\"否则为maxscrollextent即最大滑动范围\",{\"1\":{\"220\":1}}],[\"否则如果能够完全显示\",{\"1\":{\"234\":1}}],[\"否则最多上划到\",{\"1\":{\"226\":1}}],[\"否则最多滑动\",{\"1\":{\"226\":1}}],[\"否则最多可以向上滑动到maxscrollextent\",{\"1\":{\"226\":1}}],[\"否则会出现异常\",{\"1\":{\"238\":1}}],[\"否则会一直显示进度\",{\"1\":{\"193\":1}}],[\"否则会报错java\",{\"1\":{\"272\":1}}],[\"否则会报错\",{\"1\":{\"85\":1,\"322\":1}}],[\"否则应该等到下一帧\",{\"1\":{\"179\":1}}],[\"否则无法则捕获\",{\"1\":{\"142\":1}}],[\"否则无效果\",{\"1\":{\"55\":1}}],[\"否则\",{\"1\":{\"109\":1,\"170\":1,\"289\":1,\"305\":1,\"390\":1,\"453\":2}}],[\"否则则将其加入到\",{\"1\":{\"106\":1}}],[\"否则继续执行下一个普通event\",{\"1\":{\"101\":1}}],[\"否则显示\",{\"1\":{\"64\":1}}],[\"否则就是该位置\",{\"1\":{\"441\":1}}],[\"否则就需要手动配置\",{\"1\":{\"411\":1}}],[\"否则就需要遍历其子view\",{\"1\":{\"13\":1}}],[\"否则就调用系统的runtime\",{\"1\":{\"395\":1}}],[\"否则就创建新的worker\",{\"1\":{\"389\":1}}],[\"否则就使用占用内存更小的常量类\",{\"1\":{\"286\":1}}],[\"否则就要求该方法是静态的\",{\"1\":{\"91\":1}}],[\"否则就会调用代理类com\",{\"1\":{\"58\":1}}],[\"否则就给sv+1\",{\"1\":{\"58\":1}}],[\"否则挂起进程等待\",{\"1\":{\"58\":1}}],[\"否则绘制出的图形可能与预设的效果不一致\",{\"1\":{\"57\":1}}],[\"否则控件的宽高等会有异常\",{\"1\":{\"56\":1}}],[\"否则在左半部分数组查找\",{\"1\":{\"451\":1}}],[\"否则在网页上显示的时候\",{\"1\":{\"417\":1}}],[\"否则在使用该自定义控件组时\",{\"1\":{\"56\":1}}],[\"否则在对比marray中对应位置marray\",{\"1\":{\"49\":1}}],[\"否则不能取消\",{\"1\":{\"327\":1}}],[\"否则不生效\",{\"1\":{\"65\":1}}],[\"否则不依赖\",{\"1\":{\"55\":1}}],[\"否则不需要拦截\",{\"1\":{\"13\":1}}],[\"否则联动失效\",{\"1\":{\"55\":1}}],[\"否则返回该点key\",{\"1\":{\"438\":1}}],[\"否则返回默认的default\",{\"1\":{\"280\":1}}],[\"否则返回true\",{\"1\":{\"228\":1}}],[\"否则返回不能消耗的delta\",{\"1\":{\"221\":1}}],[\"否则返回\",{\"1\":{\"159\":1}}],[\"否则返回false\",{\"1\":{\"55\":1}}],[\"否则返回null\",{\"1\":{\"46\":1}}],[\"否则返回key应该插入的位置的取反值\",{\"1\":{\"45\":1}}],[\"否则使用hashmap更加高效\",{\"1\":{\"44\":1,\"287\":1}}],[\"否则服务器无法接收到callback\",{\"1\":{\"35\":1}}],[\"否则默认false\",{\"1\":{\"17\":1}}],[\"否则虽然导入了对应的包\",{\"1\":{\"1\":1}}],[\"私有化构造方法\",{\"1\":{\"294\":1}}],[\"成为a的左子节点\",{\"1\":{\"458\":1}}],[\"成为可以持有某个诸如t或者t的子类的list\",{\"1\":{\"292\":1}}],[\"成员函数或拓展函数\",{\"1\":{\"322\":1}}],[\"成功之后再缓存到本地缓存文件目录\",{\"1\":{\"201\":1}}],[\"成功加载图片时\",{\"1\":{\"198\":1}}],[\"成功执行线程则返回0\",{\"1\":{\"115\":1}}],[\"协程构建器\",{\"1\":{\"334\":1}}],[\"协程构建器是一个双重的\",{\"1\":{\"334\":1}}],[\"协程构建器有两种风格\",{\"1\":{\"329\":1}}],[\"协程内部使用\",{\"1\":{\"329\":1}}],[\"协程官网\",{\"1\":{\"326\":1}}],[\"协程的\",{\"1\":{\"334\":1}}],[\"协程的线程安全\",{\"0\":{\"334\":1}}],[\"协程的并发\",{\"1\":{\"325\":1,\"326\":1}}],[\"协程的思维导图\",{\"0\":{\"324\":1}}],[\"协程\",{\"1\":{\"325\":1,\"326\":1,\"334\":1}}],[\"协程局部变量\",{\"0\":{\"325\":1}}],[\"协程中\",{\"0\":{\"323\":1}}],[\"协程可以看做是一个轻量级的thread\",{\"1\":{\"322\":1}}],[\"协变与逆变\",{\"1\":{\"293\":1}}],[\"协变\",{\"0\":{\"292\":1},\"1\":{\"322\":1}}],[\"协调inner和outer滑动事件\",{\"1\":{\"217\":1}}],[\"协调者布局\",{\"1\":{\"55\":1}}],[\"却可以保存任何类似的map\",{\"1\":{\"291\":1}}],[\"却可以获取到正确的高度\",{\"1\":{\"53\":1}}],[\"泛型原理\",{\"1\":{\"293\":1}}],[\"泛型列表只能保存指定泛型类型t的数据\",{\"1\":{\"291\":1}}],[\"泛型类型参数会在实际运行时被擦除到他的第一个边界\",{\"1\":{\"290\":1}}],[\"泛型在java\",{\"1\":{\"290\":1}}],[\"②threadlocal使用后务必调用remove方法\",{\"1\":{\"288\":1}}],[\"②线程一直运行\",{\"1\":{\"288\":1}}],[\"①threadlocal申明为private\",{\"1\":{\"288\":1}}],[\"①threadlocal引用被设置为null\",{\"1\":{\"288\":1}}],[\"③触发了垃圾回收\",{\"1\":{\"288\":1}}],[\"造成内存泄漏\",{\"1\":{\"288\":1}}],[\"强制使用utf\",{\"1\":{\"371\":1}}],[\"强软弱虚\",{\"1\":{\"288\":1}}],[\"强引用strongreference\",{\"0\":{\"268\":1}}],[\"好精巧的设计\",{\"1\":{\"288\":1}}],[\"好像是同一个\",{\"1\":{\"212\":1}}],[\"链表只保留第一个链节点的引用first\",{\"1\":{\"451\":1}}],[\"链表有以下分类\",{\"1\":{\"451\":1}}],[\"链表的大小不固定\",{\"1\":{\"451\":1}}],[\"链表的每个节点除了保存的数据外\",{\"1\":{\"451\":1}}],[\"链表等数据结构\",{\"1\":{\"450\":1}}],[\"链表\",{\"0\":{\"450\":1},\"1\":{\"445\":3}}],[\"链表和红黑树\",{\"1\":{\"287\":1}}],[\"链地址法\",{\"1\":{\"428\":3}}],[\"链接\",{\"1\":{\"55\":1,\"58\":2,\"137\":1,\"306\":1}}],[\"耗时\",{\"1\":{\"287\":1}}],[\"枚举变量以\",{\"1\":{\"321\":1}}],[\"枚举占用的内存是普通单例的两倍多\",{\"1\":{\"294\":1}}],[\"枚举值次序\",{\"1\":{\"285\":1}}],[\"枚举值名称\",{\"1\":{\"285\":1}}],[\"枚举类型\",{\"1\":{\"321\":1}}],[\"枚举类型优先于readresolve\",{\"1\":{\"305\":1,\"316\":1}}],[\"枚举类值的引用类型\",{\"1\":{\"285\":1}}],[\"枚举类中的每个枚举都是该枚举类的一个对象\",{\"1\":{\"285\":1}}],[\"枚举类大小的计算\",{\"0\":{\"285\":1}}],[\"枚举类enum\",{\"0\":{\"284\":1}}],[\"答案是有的\",{\"1\":{\"283\":1}}],[\"＝\",{\"1\":{\"283\":1}}],[\"准确计算java中对象的大小\",{\"1\":{\"282\":1}}],[\"准备工作可能在创建之后的任何时候发生\",{\"1\":{\"277\":1}}],[\"准备\",{\"1\":{\"277\":1}}],[\"准备preparation\",{\"1\":{\"275\":1}}],[\"准备和初始化发生的顺序是确定的\",{\"1\":{\"273\":1}}],[\"准备rebuild\",{\"1\":{\"128\":1}}],[\"准备响应嵌套滑动时\",{\"1\":{\"55\":1}}],[\"聊聊jvm\",{\"1\":{\"282\":1}}],[\"综合这里和这里的信息整理\",{\"1\":{\"282\":1}}],[\"综上所见\",{\"1\":{\"202\":1}}],[\"综上得出如下结论\",{\"1\":{\"81\":1}}],[\"综上\",{\"1\":{\"69\":1,\"109\":1,\"287\":1}}],[\"综上处理\",{\"1\":{\"14\":1}}],[\"匿名内部类\",{\"1\":{\"281\":1}}],[\"匿名文件映射最熟悉的应用场景就是动态内存分配\",{\"1\":{\"58\":1}}],[\"匿名文件映射一般在用户空间需要分配一段内存来存放数据时\",{\"1\":{\"58\":1}}],[\"局部变量\",{\"1\":{\"281\":1}}],[\"局部变量表\",{\"1\":{\"252\":1}}],[\"外部类\",{\"1\":{\"281\":1}}],[\"外部类引用this$0\",{\"1\":{\"281\":1}}],[\"外部类或者内部类修改这个局部变量后\",{\"1\":{\"281\":1}}],[\"仍然是要求final的\",{\"1\":{\"281\":1}}],[\"仍然不能直接访问android\",{\"1\":{\"137\":1}}],[\"仍然不是很好的解决方法\",{\"1\":{\"14\":1}}],[\"胖君的回答\",{\"1\":{\"280\":1,\"281\":1}}],[\"左边都小于枢纽\",{\"1\":{\"467\":1}}],[\"左边子数组所有元素\",{\"1\":{\"465\":1}}],[\"左边的子树\",{\"1\":{\"346\":1}}],[\"左\",{\"1\":{\"458\":1}}],[\"左子节点\",{\"1\":{\"439\":1}}],[\"左右根\",{\"1\":{\"346\":1}}],[\"左根右\",{\"1\":{\"346\":1}}],[\"左移\",{\"1\":{\"280\":1}}],[\"左上角堆积\",{\"1\":{\"139\":1}}],[\"符号之后\",{\"1\":{\"345\":1}}],[\"符号\",{\"1\":{\"280\":1}}],[\"符号引用则与jvm内存无管\",{\"1\":{\"278\":1}}],[\"符号引用验证\",{\"1\":{\"276\":1}}],[\"符号引用\",{\"1\":{\"254\":1}}],[\"恢复了这些值\",{\"1\":{\"280\":1}}],[\"负载系数\",{\"1\":{\"280\":1}}],[\"负责采用父级的约束\",{\"1\":{\"238\":1}}],[\"负责启动和管理整个c++\",{\"1\":{\"60\":1}}],[\"负责启动和管理整个java\",{\"1\":{\"60\":1}}],[\"容量\",{\"1\":{\"280\":2}}],[\"容纳滚动内容的容器\",{\"1\":{\"212\":1,\"227\":1,\"234\":1}}],[\"阈值\",{\"1\":{\"280\":1}}],[\"低位相同概率高\",{\"1\":{\"280\":1}}],[\"低30位表示specsize\",{\"1\":{\"65\":1}}],[\"^parcelable源码分析\",{\"1\":{\"316\":1}}],[\"^\",{\"1\":{\"280\":2}}],[\"^=\",{\"1\":{\"116\":1,\"383\":2,\"389\":1}}],[\"建议配合源码食用\",{\"1\":{\"362\":1}}],[\"建议大家不要修改\",{\"1\":{\"280\":1}}],[\"建立打包文档\",{\"1\":{\"357\":1}}],[\"建立一个\",{\"1\":{\"79\":1}}],[\"建造器通过一个可选的参数\",{\"1\":{\"328\":1}}],[\"极客学院wiki\",{\"1\":{\"279\":1}}],[\"称为被动引用\",{\"1\":{\"279\":1}}],[\"零值\",{\"1\":{\"277\":1}}],[\"连接一般分为3部分\",{\"1\":{\"275\":1}}],[\"连接\",{\"1\":{\"275\":1}}],[\"连接linking\",{\"1\":{\"273\":1}}],[\"网络请求相关信息\",{\"0\":{\"364\":1},\"1\":{\"362\":1}}],[\"网络中传递\",{\"1\":{\"310\":1}}],[\"网络等\",{\"1\":{\"274\":1,\"303\":1}}],[\"网络进行操作的请求\",{\"1\":{\"111\":1,\"112\":1}}],[\"验证字节流符合class文件格式规范\",{\"1\":{\"276\":1}}],[\"验证内容包括\",{\"1\":{\"276\":1}}],[\"验证和准备\",{\"1\":{\"275\":1}}],[\"验证verification\",{\"1\":{\"275\":1}}],[\"验证\",{\"1\":{\"273\":1,\"276\":1,\"279\":1}}],[\"阅读笔记\",{\"1\":{\"272\":1}}],[\"虚引用phantomreference\",{\"0\":{\"271\":1}}],[\"虚拟机说明一些事情\",{\"1\":{\"298\":1}}],[\"虚拟机\",{\"1\":{\"279\":1}}],[\"虚拟机等启动时执行主类的main\",{\"1\":{\"279\":1}}],[\"虚拟机栈\",{\"1\":{\"263\":1}}],[\"虚拟机栈和本地方法栈溢出\",{\"0\":{\"257\":1}}],[\"虚拟机最大内存一定的情况下\",{\"1\":{\"257\":1}}],[\"虚拟地址空间分为内核空间与用户空间\",{\"1\":{\"58\":1}}],[\"弱引用weakreference\",{\"0\":{\"270\":1}}],[\"软引用softreference\",{\"0\":{\"269\":1}}],[\"哪怕抛出oom也不会被gc回收的对象\",{\"1\":{\"268\":1}}],[\"没必要执行\",{\"1\":{\"266\":1}}],[\"没有找到\",{\"1\":{\"438\":1}}],[\"没有邻接点\",{\"1\":{\"438\":1}}],[\"没有后继点的顶点\",{\"1\":{\"438\":2}}],[\"没有子节点的节点叫做叶子节点\",{\"1\":{\"429\":1}}],[\"没有new\",{\"1\":{\"391\":1}}],[\"没有具体实现\",{\"1\":{\"372\":1}}],[\"没有伪装\",{\"1\":{\"370\":1}}],[\"没有该子节点则不写内容\",{\"1\":{\"346\":1}}],[\"没有缓冲的通道\",{\"1\":{\"328\":1}}],[\"没有上下文切换的开销\",{\"1\":{\"322\":1}}],[\"没有在putfields\",{\"1\":{\"306\":1}}],[\"没有值\",{\"1\":{\"298\":2}}],[\"没有hash冲突\",{\"1\":{\"280\":1}}],[\"没有主轴方向的约束\",{\"1\":{\"238\":1}}],[\"没有顶部\",{\"1\":{\"220\":1}}],[\"没有指定的图片\",{\"1\":{\"198\":1}}],[\"没有使用我们的\",{\"1\":{\"171\":1}}],[\"没有被flutter捕获的错误\",{\"1\":{\"145\":1}}],[\"没有\",{\"1\":{\"87\":1,\"167\":1,\"225\":1}}],[\"没有相机权限\",{\"1\":{\"69\":1}}],[\"没有的话先从网络下载\",{\"1\":{\"201\":1}}],[\"没有的话则先加载再缓存\",{\"1\":{\"198\":1}}],[\"没有的话执行imageprovider\",{\"1\":{\"196\":1}}],[\"没有的话\",{\"1\":{\"58\":1,\"180\":1}}],[\"没有设置这个flag的view将被固定在屏幕顶部\",{\"1\":{\"55\":1}}],[\"没有键为key的数据\",{\"1\":{\"50\":1}}],[\"没有对基本类型的数据自动装箱\",{\"1\":{\"44\":1}}],[\"没有跨进程\",{\"1\":{\"40\":1}}],[\"没有可以处理点击事件的子view\",{\"1\":{\"13\":1}}],[\"没有他们的话这个小站不会存在\",{\"1\":{\"0\":1}}],[\"筛选所有已安装应用信息\",{\"0\":{\"422\":1}}],[\"筛选\",{\"1\":{\"266\":1}}],[\"死缓\",{\"1\":{\"266\":1}}],[\"越容易尝试内存溢出oom\",{\"1\":{\"257\":1}}],[\"计晓云等译\",{\"1\":{\"451\":1}}],[\"计时器通道是一种特别的会合通道\",{\"1\":{\"328\":1}}],[\"计数器记录的是正在执行的虚拟机字节码指令的位置\",{\"1\":{\"255\":1}}],[\"计算方式不唯一\",{\"1\":{\"462\":1}}],[\"计算方式为\",{\"1\":{\"81\":1}}],[\"计算的h值一般为\",{\"1\":{\"461\":1}}],[\"计算次数\",{\"1\":{\"361\":1}}],[\"计算c+1的值\",{\"1\":{\"317\":1}}],[\"计算\",{\"1\":{\"280\":1}}],[\"计算索引时\",{\"1\":{\"280\":1}}],[\"计算而来\",{\"1\":{\"232\":1}}],[\"计算曲线在\",{\"1\":{\"186\":1}}],[\"计算animation<t>\",{\"1\":{\"186\":1}}],[\"计算值\",{\"1\":{\"166\":1}}],[\"计算出当前的\",{\"1\":{\"157\":1}}],[\"计算实际应该填写的dp\",{\"1\":{\"81\":1}}],[\"计算各个点对应控制点的坐标\",{\"1\":{\"62\":1}}],[\"计算key的index\",{\"1\":{\"52\":1}}],[\"计算key的hash值\",{\"1\":{\"49\":1,\"280\":2}}],[\"程序相关文件unix\",{\"1\":{\"349\":1}}],[\"程序计数器\",{\"1\":{\"255\":1}}],[\"程序最后执行的结果是通过dart\",{\"1\":{\"115\":1}}],[\"变成了755\",{\"1\":{\"352\":1}}],[\"变量对所有线程可见\",{\"1\":{\"317\":1}}],[\"变量\",{\"1\":{\"254\":1,\"288\":1,\"295\":2,\"369\":1}}],[\"变化时通知\",{\"0\":{\"216\":1}}],[\"变化时会调用此方法通知子类\",{\"1\":{\"152\":1}}],[\"变化为大于\",{\"1\":{\"173\":1}}],[\"变化\",{\"1\":{\"158\":1,\"170\":1,\"190\":1}}],[\"编译\",{\"1\":{\"468\":1}}],[\"编译器会要求mutator\",{\"1\":{\"396\":1}}],[\"编译器\",{\"1\":{\"395\":1}}],[\"编译器生成的各种字面量和符号引用会放到方法区的运行时常量池中\",{\"1\":{\"254\":1}}],[\"编译文章\",{\"1\":{\"368\":1}}],[\"编译时报错\",{\"1\":{\"291\":1,\"292\":2}}],[\"编译通过\",{\"1\":{\"291\":1}}],[\"编译当前目录下的java文件\",{\"1\":{\"282\":1}}],[\"编译后如下\",{\"1\":{\"281\":1}}],[\"编辑图片\",{\"1\":{\"199\":1}}],[\"静态常量\",{\"1\":{\"415\":1}}],[\"静态内部类与类的静态变量不同\",{\"1\":{\"294\":1}}],[\"静态的方法\",{\"1\":{\"294\":1}}],[\"静态语句块等则不会有clinit\",{\"1\":{\"279\":1}}],[\"静态语句块会由编译器合并为clinit\",{\"1\":{\"279\":1}}],[\"静态绑定\",{\"1\":{\"273\":1}}],[\"静态变量\",{\"1\":{\"254\":1}}],[\"静态方法的类通常有对应的\",{\"1\":{\"184\":1}}],[\"栈为空\",{\"1\":{\"453\":3}}],[\"栈stack\",{\"1\":{\"452\":1}}],[\"栈和队列\",{\"0\":{\"452\":1}}],[\"栈帧中的本地变量表\",{\"1\":{\"263\":1}}],[\"栈帧过大或者虚拟机栈容量太小\",{\"1\":{\"257\":1}}],[\"栈帧\",{\"1\":{\"252\":1}}],[\"栈\",{\"0\":{\"446\":1},\"1\":{\"251\":1,\"445\":1}}],[\"存放皮肤的目录\",{\"1\":{\"415\":1}}],[\"存放博客正文内容\",{\"1\":{\"415\":1}}],[\"存放类信息\",{\"1\":{\"254\":1}}],[\"存放基本数据和对象的引用\",{\"1\":{\"251\":1}}],[\"存放所有对象实例\",{\"1\":{\"250\":1}}],[\"存活时间长的老年对象\",{\"1\":{\"250\":1}}],[\"存储达到容量2\",{\"1\":{\"428\":1}}],[\"存储\",{\"1\":{\"414\":1}}],[\"存储在proxyintent中\",{\"1\":{\"72\":1}}],[\"存储key和value\",{\"1\":{\"49\":1}}],[\"存储所有key的hash值\",{\"1\":{\"49\":1}}],[\"存储单个数据的成本小\",{\"1\":{\"44\":1}}],[\"永久代\",{\"1\":{\"249\":1}}],[\"永远停留在指定值的\",{\"1\":{\"159\":1}}],[\"养老区\",{\"1\":{\"249\":1}}],[\"老年代\",{\"1\":{\"249\":1,\"250\":1}}],[\"幸存者区\",{\"1\":{\"249\":1}}],[\"伊甸园\",{\"1\":{\"249\":1}}],[\"互斥\",{\"1\":{\"334\":1}}],[\"互斥同步的思想是\",{\"1\":{\"318\":1}}],[\"互斥同步\",{\"0\":{\"318\":1}}],[\"互相之间space为0\",{\"1\":{\"241\":1,\"242\":1}}],[\"互联网给了我莫大的支持与帮助\",{\"1\":{\"0\":1}}],[\"想要给column的children设置spacedaround效果\",{\"1\":{\"241\":1}}],[\"换言之\",{\"1\":{\"238\":1}}],[\"换位\",{\"1\":{\"171\":1}}],[\"收集完成后再传给下一步\",{\"1\":{\"344\":1}}],[\"收集emit发送的值\",{\"1\":{\"337\":2}}],[\"收集由串行转化为并行可以节约时间\",{\"1\":{\"327\":1}}],[\"收集这个流\",{\"1\":{\"327\":1}}],[\"收缩包装\",{\"1\":{\"232\":1}}],[\"收到通知并在herostate\",{\"1\":{\"181\":1}}],[\"收到系统帧回调时触发\",{\"1\":{\"168\":1}}],[\"收到native\",{\"1\":{\"114\":1}}],[\"收到服务端返回后唤醒当前线程\",{\"1\":{\"58\":1}}],[\"沿着边移动到其他顶点\",{\"1\":{\"436\":1}}],[\"沿着\",{\"1\":{\"231\":2}}],[\"校验环境\",{\"0\":{\"411\":1}}],[\"校验是否是gzip压缩的文件\",{\"1\":{\"356\":1}}],[\"校验\",{\"0\":{\"230\":1},\"1\":{\"230\":1}}],[\"遵从\",{\"1\":{\"227\":1}}],[\"遵循\",{\"1\":{\"58\":1,\"288\":1}}],[\"尝试将其恢复至\",{\"1\":{\"226\":1}}],[\"尝试在\",{\"1\":{\"85\":1}}],[\"逻辑\",{\"1\":{\"226\":2}}],[\"跳过剩余步骤直接返回了\",{\"1\":{\"226\":1}}],[\"跳转到\",{\"1\":{\"170\":1,\"171\":1}}],[\"跳转\",{\"1\":{\"135\":1}}],[\"现有限制下不会出现\",{\"1\":{\"226\":1}}],[\"现在我们知道了\",{\"1\":{\"288\":1}}],[\"现在的问题是\",{\"1\":{\"101\":1}}],[\"现在则需要在使用到对应权限时检测是否有该权限并作出相应处理\",{\"1\":{\"67\":1}}],[\"掉了一部分\",{\"1\":{\"226\":1}}],[\"消息\",{\"1\":{\"375\":1}}],[\"消息队列message\",{\"1\":{\"58\":1}}],[\"消息队列\",{\"1\":{\"58\":2}}],[\"消费者\",{\"1\":{\"322\":1}}],[\"消耗\",{\"1\":{\"226\":2}}],[\"识别和避免学习使用泛型过程中的陷阱\",{\"1\":{\"293\":1}}],[\"识别到\",{\"1\":{\"226\":1}}],[\"识别用户手势的属性\",{\"1\":{\"223\":1}}],[\"失效\",{\"1\":{\"223\":1}}],[\"条件时\",{\"1\":{\"221\":1}}],[\"条件满足后关闭当日循环闹钟\",{\"0\":{\"12\":1}}],[\"总权重最小的称为最小生成树\",{\"1\":{\"438\":1}}],[\"总结\",{\"0\":{\"445\":1}}],[\"总结一下\",{\"1\":{\"391\":1}}],[\"总结起来其结论就是\",{\"1\":{\"286\":1}}],[\"总是被设置在由\",{\"1\":{\"329\":1}}],[\"总共遍历n\",{\"1\":{\"289\":1}}],[\"总之delta绝对值减少了\",{\"1\":{\"220\":1}}],[\"总的来说\",{\"1\":{\"186\":1}}],[\"减去\",{\"1\":{\"351\":1}}],[\"减去了overscroll\",{\"1\":{\"220\":1}}],[\"减少了阻塞\",{\"1\":{\"319\":1}}],[\"减轻\",{\"1\":{\"220\":1}}],[\"范围\",{\"1\":{\"351\":2}}],[\"范围为\",{\"1\":{\"226\":1}}],[\"范围内\",{\"1\":{\"220\":1}}],[\"范围是\",{\"1\":{\"220\":4}}],[\"能创建\",{\"1\":{\"233\":1}}],[\"能得出下面两种axisdirection说明axis是\",{\"1\":{\"228\":1}}],[\"能够避免规则4\",{\"1\":{\"458\":1}}],[\"能够流畅的访问数据库\",{\"1\":{\"403\":1}}],[\"能够实现协调\",{\"1\":{\"226\":1}}],[\"能够比较方便的实现\",{\"1\":{\"212\":1,\"227\":1}}],[\"能注意到\",{\"1\":{\"213\":1}}],[\"滑动机制的主力\",{\"1\":{\"231\":1}}],[\"滑动分析之\",{\"1\":{\"227\":1}}],[\"滑动时会先将header滑动出来\",{\"1\":{\"224\":1}}],[\"滑动的原因\",{\"1\":{\"223\":1}}],[\"滑动的基础\",{\"1\":{\"213\":1}}],[\"滑动事件的关键\",{\"1\":{\"223\":1,\"226\":1}}],[\"滑动退出等图片操作常用的\",{\"1\":{\"202\":1}}],[\"滑动退出页面\",{\"1\":{\"199\":1}}],[\"顾名思义\",{\"1\":{\"212\":1}}],[\"超时处理\",{\"1\":{\"370\":1}}],[\"超详细java中的classloader详解\",{\"1\":{\"272\":1}}],[\"超详细\",{\"1\":{\"211\":1}}],[\"超过千位\",{\"1\":{\"49\":1}}],[\"闲鱼\",{\"1\":{\"211\":1}}],[\"性能方面高出10多倍\",{\"1\":{\"316\":1}}],[\"性能好\",{\"1\":{\"316\":1}}],[\"性能差\",{\"1\":{\"310\":1}}],[\"性能消耗小\",{\"1\":{\"303\":1}}],[\"性能已经跟\",{\"1\":{\"211\":1}}],[\"性能更好\",{\"1\":{\"161\":1}}],[\"侧解码\",{\"1\":{\"211\":1}}],[\"版本\",{\"1\":{\"413\":1}}],[\"版本中\",{\"1\":{\"211\":1}}],[\"版权协议\",{\"1\":{\"58\":1,\"288\":1}}],[\"版权声明\",{\"1\":{\"58\":1,\"288\":1}}],[\"拷贝>\",{\"1\":{\"211\":1}}],[\"入口类\",{\"1\":{\"371\":1}}],[\"入参\",{\"1\":{\"211\":1}}],[\"入到另外一个页面\",{\"1\":{\"169\":1}}],[\"找出在configrequestswitharguments方法中创建的请求并执行\",{\"1\":{\"211\":1}}],[\"找到后用该子节点的值替换掉要删除的节点值\",{\"1\":{\"432\":1}}],[\"找到项目\",{\"1\":{\"419\":1}}],[\"找到用户环境变量\",{\"1\":{\"412\":1}}],[\"找到根节点\",{\"1\":{\"346\":1}}],[\"找到上一步创建的请求powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"找到父级节点中最近的renderobjectelement\",{\"1\":{\"127\":1}}],[\"找到的话返回对应索引\",{\"1\":{\"45\":1}}],[\"立即取消\",{\"1\":{\"340\":1}}],[\"立即从powerimagerequestmanager\",{\"1\":{\"211\":1}}],[\"立即执行释放请求\",{\"1\":{\"211\":1}}],[\"小\",{\"1\":{\"454\":1,\"459\":3,\"460\":1,\"462\":1}}],[\"小→大\",{\"1\":{\"450\":1}}],[\"小数\",{\"1\":{\"369\":1}}],[\"小结一下\",{\"1\":{\"211\":1}}],[\"小于\",{\"1\":{\"173\":1,\"226\":1}}],[\"小于几千个\",{\"1\":{\"44\":1,\"287\":1}}],[\"省略部分代码\",{\"1\":{\"211\":1}}],[\"跨端通信获取图片资源\",{\"1\":{\"209\":1}}],[\"跨端通信从\",{\"1\":{\"208\":1}}],[\"统计字符数\",{\"1\":{\"361\":1}}],[\"统计文本中字母个数\",{\"1\":{\"321\":1}}],[\"统计当前\",{\"1\":{\"176\":1}}],[\"统一协调处理\",{\"1\":{\"223\":1}}],[\"统一处理\",{\"1\":{\"212\":2,\"223\":1}}],[\"统一让\",{\"1\":{\"209\":1}}],[\"采用\",{\"1\":{\"205\":2,\"207\":1}}],[\"采用不同的animation\",{\"1\":{\"177\":1}}],[\"特殊的\",{\"1\":{\"458\":1}}],[\"特征3保证了根节点是堆中最大的值\",{\"1\":{\"439\":1}}],[\"特别是在io操作及网络请求等需要根据耗时操作更新界面的需求时\",{\"1\":{\"322\":1}}],[\"特别是当\",{\"1\":{\"232\":1}}],[\"特别耗时的工作应当交给线程池处理\",{\"1\":{\"80\":1}}],[\"特定的powerimageprovider\",{\"1\":{\"204\":1}}],[\"架构图\",{\"1\":{\"203\":1}}],[\"端\",{\"1\":{\"211\":2}}],[\"端注册才能正常使用\",{\"1\":{\"211\":1}}],[\"端通过powerimageloader\",{\"1\":{\"211\":1}}],[\"端的处理过程\",{\"1\":{\"211\":1}}],[\"端为例分析一下\",{\"1\":{\"211\":1}}],[\"端向\",{\"1\":{\"211\":3}}],[\"端处理完请求之后会回调\",{\"1\":{\"211\":1}}],[\"端接收请求\",{\"1\":{\"211\":1}}],[\"端发起请求的过程\",{\"1\":{\"211\":1}}],[\"端发起请求\",{\"1\":{\"211\":1}}],[\"端图片展示和native\",{\"1\":{\"203\":1}}],[\"端解决方案存在图片内存释放时机\",{\"1\":{\"203\":1}}],[\"端加载解析图片\",{\"1\":{\"203\":1}}],[\"端展示图片\",{\"1\":{\"203\":1}}],[\"端只负责展示\",{\"1\":{\"202\":1}}],[\"端已有的图片加载库完成图片加载\",{\"1\":{\"202\":1}}],[\"借助\",{\"1\":{\"202\":1}}],[\"混入的\",{\"1\":{\"230\":1}}],[\"混入了\",{\"1\":{\"229\":1}}],[\"混入了extendedimageprovider\",{\"1\":{\"201\":1}}],[\"混合开发的图片加载库\",{\"1\":{\"211\":1}}],[\"混合开发图片加载库\",{\"1\":{\"203\":1}}],[\"混合项目开发的图片加载库\",{\"1\":{\"202\":1}}],[\"阿里巴巴出品的power\",{\"1\":{\"202\":1}}],[\"阿里的powerimage由于将图片下载这个过程交给了原生成熟的图片加载库处理\",{\"1\":{\"198\":1}}],[\"仅显示用户账号\",{\"1\":{\"353\":1}}],[\"仅在预计不会由用户处理的异常上调用\",{\"1\":{\"329\":1}}],[\"仅表示可以有这些功能\",{\"1\":{\"321\":1}}],[\"仅源文件有效\",{\"1\":{\"298\":1}}],[\"仅就从网络加载图片而言\",{\"1\":{\"202\":1}}],[\"仅获取该widget执行一些操作\",{\"1\":{\"129\":1}}],[\"库文件\",{\"1\":{\"349\":1}}],[\"库中的\",{\"1\":{\"202\":1}}],[\"库的\",{\"1\":{\"200\":1}}],[\"裁剪旋转翻转\",{\"1\":{\"199\":1}}],[\"微信掘金效果\",{\"1\":{\"199\":2}}],[\"缩放拖拽图片\",{\"1\":{\"199\":1}}],[\"涌现了很多第三方图片加载控件\",{\"1\":{\"198\":1}}],[\"张或者最大\",{\"1\":{\"197\":1}}],[\"算法最多缓存1000\",{\"1\":{\"197\":1}}],[\"属性的抽象描述\",{\"1\":{\"372\":1}}],[\"属性只接受能创建\",{\"1\":{\"227\":1}}],[\"属性\",{\"1\":{\"192\":1,\"193\":1,\"412\":1}}],[\"属于2020年的只有2天\",{\"1\":{\"302\":1}}],[\"属于客户端部分\",{\"1\":{\"35\":1}}],[\"属于比较基础性的内容\",{\"1\":{\"3\":1}}],[\"占用内存大小在sparsearray和hashmap之间\",{\"1\":{\"287\":1}}],[\"占用内存小\",{\"1\":{\"255\":1}}],[\"占用4\",{\"1\":{\"283\":2}}],[\"占用大小为\",{\"1\":{\"287\":2}}],[\"占用大小\",{\"1\":{\"282\":1,\"283\":1}}],[\"占用的\",{\"1\":{\"213\":1}}],[\"占用的内存\",{\"1\":{\"188\":1}}],[\"占据剩余空间\",{\"1\":{\"238\":1}}],[\"占据容器的剩余空间\",{\"1\":{\"131\":1}}],[\"预先加载\",{\"1\":{\"188\":1}}],[\"预览\",{\"1\":{\"64\":1,\"468\":1}}],[\"线性探测\",{\"1\":{\"428\":1}}],[\"线性插值\",{\"1\":{\"185\":1}}],[\"线程本地存储\",{\"1\":{\"320\":1}}],[\"线程外部观察是无序\",{\"1\":{\"317\":1}}],[\"线程内是串行的语义\",{\"1\":{\"317\":1}}],[\"线程从内部观察时有序\",{\"1\":{\"317\":1}}],[\"线程组线程数为0时\",{\"1\":{\"297\":1}}],[\"线程共享\",{\"1\":{\"254\":1}}],[\"线程请求的栈深度大于jvm允许的深度会导致stack\",{\"1\":{\"252\":1}}],[\"线程私有\",{\"1\":{\"251\":1,\"255\":1}}],[\"线程\",{\"0\":{\"136\":1},\"1\":{\"317\":1}}],[\"线程池\",{\"1\":{\"115\":1,\"288\":1}}],[\"线程池的常规调用进行接收\",{\"1\":{\"43\":1}}],[\"线程是调度的基本单位\",{\"1\":{\"58\":1}}],[\"插值\",{\"1\":{\"184\":1}}],[\"插入137后的树\",{\"1\":{\"458\":1}}],[\"插入位置的父节点为根节点或父节点颜色为黑色\",{\"1\":{\"458\":1}}],[\"插入位置为根节点\",{\"1\":{\"458\":1}}],[\"插入到右边的有序数组\",{\"1\":{\"457\":1}}],[\"插入到tree中\",{\"1\":{\"125\":1}}],[\"插入指定节点都需要o\",{\"1\":{\"451\":1}}],[\"插入排序>选择排序>冒泡排序\",{\"1\":{\"454\":1}}],[\"插入排序\",{\"0\":{\"457\":1},\"1\":{\"445\":1,\"449\":2,\"457\":1,\"462\":1}}],[\"插入排序法思想\",{\"1\":{\"289\":1}}],[\"插入操作思路是\",{\"1\":{\"440\":1}}],[\"插入边的时候需要注意\",{\"1\":{\"434\":1}}],[\"插入分为插入顶点和插入边\",{\"1\":{\"434\":1}}],[\"插入\",{\"0\":{\"434\":1,\"440\":1}}],[\"插入和删除的时间复杂度均为o\",{\"1\":{\"458\":1}}],[\"插入和删除\",{\"1\":{\"428\":1}}],[\"插入list\",{\"1\":{\"369\":1}}],[\"插入自己的逻辑\",{\"1\":{\"72\":1}}],[\"了解泛型\",{\"1\":{\"293\":1}}],[\"了\",{\"1\":{\"182\":1,\"197\":1,\"220\":1,\"348\":1,\"394\":1}}],[\"亦或者控制这些值变化的速度快慢\",{\"1\":{\"182\":1}}],[\"产生oom\",{\"1\":{\"260\":1}}],[\"产生的间隔由tickermodel控制\",{\"1\":{\"328\":1}}],[\"产生的\",{\"1\":{\"183\":1}}],[\"产生\",{\"1\":{\"181\":1,\"182\":1}}],[\"表格来自\",{\"1\":{\"458\":1}}],[\"表格\",{\"1\":{\"403\":1}}],[\"表\",{\"1\":{\"399\":1}}],[\"表达式会视为返回值\",{\"1\":{\"345\":1}}],[\"表达式总是被大括号括着\",{\"1\":{\"345\":1}}],[\"表达式不返回任何结果\",{\"1\":{\"334\":1}}],[\"表达式允许我们使用其\",{\"1\":{\"334\":1}}],[\"表明不再需要更多的元素\",{\"1\":{\"328\":1}}],[\"表现为\",{\"1\":{\"181\":1}}],[\"表示接受关键词作为参数传入\",{\"1\":{\"369\":1}}],[\"表示参数个数可变\",{\"1\":{\"369\":1}}],[\"表示没有更多的元素进入通道\",{\"1\":{\"328\":1}}],[\"表示变量或操作的最新值时\",{\"1\":{\"327\":1}}],[\"表示这个类可以用来序列化\",{\"1\":{\"303\":1}}],[\"表示week\",{\"1\":{\"302\":1}}],[\"表示有人以\",{\"1\":{\"302\":1}}],[\"表示该标记会被标记的class的子类继承\",{\"1\":{\"298\":1}}],[\"表示该方法返回值为start\",{\"1\":{\"17\":1}}],[\"表示是否将注解信息添加在java文档中\",{\"1\":{\"298\":1}}],[\"表示为类属性\",{\"1\":{\"288\":1}}],[\"表示不会主动结束动画\",{\"1\":{\"167\":1}}],[\"表示整个rendering\",{\"1\":{\"122\":1}}],[\"表示他是一个特殊的方法\",{\"1\":{\"86\":1}}],[\"表示当前的viewgroup不需要绘制任何内容\",{\"1\":{\"65\":1}}],[\"表示启动请求时是否有额外数据\",{\"1\":{\"17\":1}}],[\"路由变化\",{\"1\":{\"181\":1}}],[\"技术的拓展\",{\"1\":{\"397\":1}}],[\"技术\",{\"1\":{\"176\":1}}],[\"技术类文章务必自己理解了\",{\"1\":{\"0\":1}}],[\"替换为github链接\",{\"1\":{\"368\":1}}],[\"替换默认的过渡widget\",{\"1\":{\"175\":1}}],[\"替换页面切换时的默认过渡\",{\"1\":{\"174\":1}}],[\"约等于\",{\"1\":{\"173\":1}}],[\"约等于中密度屏幕\",{\"1\":{\"53\":1}}],[\"刚开始这个标记元素可以为0或者1\",{\"1\":{\"457\":1}}],[\"刚开始排序的时候假设只有第一个元素是有序的\",{\"1\":{\"289\":1}}],[\"刚好看到大神gityuan\",{\"1\":{\"371\":1}}],[\"刚好处于由\",{\"1\":{\"171\":1}}],[\"刚才以及之前选出来的\",{\"1\":{\"289\":1}}],[\"刚刚创建的对象优先\",{\"1\":{\"250\":1}}],[\"刚刚从页面\",{\"1\":{\"173\":1}}],[\"始终与\",{\"1\":{\"173\":1}}],[\"根节点颜色为黑\",{\"1\":{\"458\":1}}],[\"根节点的在0层\",{\"1\":{\"429\":1}}],[\"根左右\",{\"1\":{\"346\":1}}],[\"根号\",{\"1\":{\"173\":1}}],[\"根号2\",{\"1\":{\"172\":2}}],[\"根据篇幅需要做了部分精简\",{\"1\":{\"399\":1}}],[\"根据刚刚创建的isolate\",{\"1\":{\"388\":1}}],[\"根据是aot还是jit获取kernel\",{\"1\":{\"387\":1}}],[\"根据提示操作即可\",{\"1\":{\"368\":1}}],[\"根据根节点坐标\",{\"1\":{\"346\":1}}],[\"根据之前的知识\",{\"1\":{\"346\":1}}],[\"根据这份jdk文档\",{\"1\":{\"302\":1}}],[\"根据romain\",{\"1\":{\"282\":1,\"287\":1}}],[\"根据需要加载类来解析未定义的符号\",{\"1\":{\"278\":1}}],[\"根据数组元素的类型不同\",{\"1\":{\"274\":1}}],[\"根据滑动方向的不同\",{\"1\":{\"226\":1}}],[\"根据position计算出child实际在singlechildscrollview中的offset\",{\"1\":{\"239\":1}}],[\"根据position创建inner\",{\"1\":{\"225\":1}}],[\"根据physics的不同\",{\"1\":{\"220\":1}}],[\"根据physics而不同\",{\"1\":{\"220\":1}}],[\"根据实现方式的不同\",{\"1\":{\"212\":1,\"227\":1}}],[\"根据官方power\",{\"1\":{\"211\":1}}],[\"根据官方的说法\",{\"1\":{\"211\":1}}],[\"根据阿里的描述\",{\"1\":{\"211\":1}}],[\"根据内存中的数据创建ui\",{\"1\":{\"211\":1}}],[\"根据构造方法的不同创建了不同的imageprovider对象作为image\",{\"1\":{\"195\":1}}],[\"根据\",{\"1\":{\"191\":1,\"211\":1,\"232\":1}}],[\"根据动画进度创建\",{\"1\":{\"181\":1}}],[\"根据不同的powerimageprovider\",{\"1\":{\"205\":1}}],[\"根据不同的方法调用创建对应的\",{\"1\":{\"157\":1}}],[\"根据不同的状态创建创建不同属性的\",{\"1\":{\"155\":1}}],[\"根据传入的powerimagerequestoptions中powerimagerequestoptions\",{\"1\":{\"208\":1}}],[\"根据传入的animation<double>对象创建\",{\"1\":{\"183\":1}}],[\"根据传入的\",{\"1\":{\"147\":1,\"182\":1,\"227\":1}}],[\"根据element的定义\",{\"1\":{\"125\":1}}],[\"根据external的定义\",{\"1\":{\"111\":1}}],[\"根据上述的代码\",{\"1\":{\"378\":1}}],[\"根据上述分析\",{\"1\":{\"158\":1,\"226\":1}}],[\"根据上述理论\",{\"1\":{\"130\":1}}],[\"根据上面创建的nmh创建dart\",{\"1\":{\"115\":2}}],[\"根据上下滑动的距离判断当前选中的字母\",{\"1\":{\"64\":1}}],[\"根据创建timer的时候\",{\"1\":{\"109\":1}}],[\"根据设计稿宽度\",{\"1\":{\"81\":1}}],[\"根据用户对权限的处理结果决定接下来的操作\",{\"1\":{\"68\":1}}],[\"根据viewgroup的getchildmeasurespec\",{\"1\":{\"65\":1}}],[\"根据android服务之bindservice源码分析mconnection会通过context\",{\"1\":{\"58\":1}}],[\"根据android官方的定义\",{\"1\":{\"53\":1}}],[\"根据dependency的位置\",{\"1\":{\"55\":1}}],[\"根据jdk文档关于日期的定义\",{\"1\":{\"302\":1}}],[\"根据jessyan的文章可知由于每种屏幕宽\",{\"1\":{\"53\":1}}],[\"根据java笔记之hashmap保存数据和java笔记之计算java对象的大小及其应用可以知道\",{\"1\":{\"44\":1}}],[\"根据方法\",{\"1\":{\"40\":1}}],[\"圆半径\",{\"1\":{\"172\":1}}],[\"组成\",{\"1\":{\"395\":1}}],[\"组成的数组table保存数据\",{\"1\":{\"280\":1}}],[\"组成的裁剪遮罩\",{\"1\":{\"172\":1}}],[\"组合而成的一个实体\",{\"1\":{\"334\":1}}],[\"组合\",{\"1\":{\"275\":1}}],[\"组合在一起\",{\"1\":{\"226\":1}}],[\"组件展示图片\",{\"1\":{\"211\":1}}],[\"组件逻辑一致\",{\"1\":{\"207\":1}}],[\"组件一致\",{\"1\":{\"207\":1}}],[\"组件\",{\"1\":{\"203\":1}}],[\"组件实现图片加载\",{\"1\":{\"202\":1}}],[\"组件的主要区别在于\",{\"1\":{\"202\":1}}],[\"组件类似\",{\"1\":{\"200\":1}}],[\"组件加载图片的流程\",{\"1\":{\"198\":1}}],[\"组件占位\",{\"1\":{\"171\":2}}],[\"组件间传递数据\",{\"1\":{\"135\":1}}],[\"径向动画的本质还是\",{\"1\":{\"172\":1}}],[\"径向过渡\",{\"1\":{\"172\":1}}],[\"径向转化\",{\"1\":{\"172\":1}}],[\"样式\",{\"1\":{\"171\":1}}],[\"样例代码\",{\"1\":{\"69\":1}}],[\"页面卡顿等\",{\"1\":{\"198\":1}}],[\"页面切换时触发的\",{\"1\":{\"181\":1}}],[\"页面切换时过渡的\",{\"1\":{\"171\":1}}],[\"页面\",{\"1\":{\"174\":1}}],[\"页面中的\",{\"1\":{\"171\":1}}],[\"页面将需要实现\",{\"1\":{\"170\":1}}],[\"轴方向上处于所有\",{\"1\":{\"171\":1}}],[\"逐渐变为\",{\"1\":{\"170\":1}}],[\"逐渐从\",{\"1\":{\"170\":1}}],[\"移动的次数要小很多\",{\"1\":{\"467\":1}}],[\"移动\",{\"1\":{\"455\":1}}],[\"移动完毕后要保证访问了每个顶点\",{\"1\":{\"436\":1}}],[\"移动到另外一个柱子的问题\",{\"1\":{\"459\":1}}],[\"移动到柱子c\",{\"1\":{\"459\":1}}],[\"移动到根节点空出的位置\",{\"1\":{\"441\":1}}],[\"移动到\",{\"1\":{\"170\":1}}],[\"移除后就得到一个有序数组\",{\"1\":{\"442\":1}}],[\"移除时要移动的节点要比较的稍微多些\",{\"1\":{\"441\":1}}],[\"移除指的是将根节点推出堆中\",{\"1\":{\"441\":1}}],[\"移除的时候为了保证满足堆的条件\",{\"1\":{\"439\":1}}],[\"移除回调\",{\"1\":{\"216\":1}}],[\"移除hero\",{\"1\":{\"181\":1}}],[\"移除监听\",{\"1\":{\"155\":1,\"237\":1}}],[\"移除\",{\"0\":{\"435\":1,\"441\":1},\"1\":{\"119\":1,\"439\":1}}],[\"详细配置了访问的url\",{\"1\":{\"362\":1}}],[\"详细介绍android中parcelable的原理和使用方法\",{\"1\":{\"316\":1}}],[\"详细的代码可以从advanced\",{\"1\":{\"172\":1}}],[\"详细的代码可以从simple\",{\"1\":{\"170\":1}}],[\"详解\",{\"1\":{\"57\":1}}],[\"感兴趣的可以直接阅读官方文档\",{\"1\":{\"169\":1}}],[\"感谢作者张丹\",{\"1\":{\"419\":1}}],[\"感谢作者michaelx\",{\"1\":{\"407\":1}}],[\"感谢原作者的分享\",{\"1\":{\"347\":1}}],[\"感谢这篇文章\",{\"1\":{\"302\":1}}],[\"感谢以上各位朋友\",{\"1\":{\"0\":1}}],[\"感谢所有为以上提到的项目有过付出的人\",{\"1\":{\"0\":1}}],[\"飞入\",{\"1\":{\"181\":1}}],[\"飞\",{\"1\":{\"169\":1,\"181\":1}}],[\"放入\",{\"1\":{\"419\":1}}],[\"放入到\",{\"1\":{\"171\":1}}],[\"放到后面\",{\"1\":{\"289\":1}}],[\"放到一个列表中\",{\"1\":{\"213\":1}}],[\"放到drawable目录下\",{\"1\":{\"66\":1}}],[\"放大缩小\",{\"1\":{\"169\":1}}],[\"帧刷新时\",{\"1\":{\"168\":1}}],[\"速度等建模\",{\"1\":{\"165\":1}}],[\"速度快\",{\"1\":{\"58\":1}}],[\"操纵正向\",{\"1\":{\"161\":1}}],[\"操纵从double\",{\"1\":{\"161\":1}}],[\"操作过程提示及说明如下\",{\"1\":{\"368\":1}}],[\"操作\",{\"1\":{\"351\":2}}],[\"操作符\",{\"1\":{\"327\":1}}],[\"操作这些变量\",{\"1\":{\"295\":1}}],[\"操作数栈\",{\"1\":{\"252\":1}}],[\"操作文件的mode\",{\"1\":{\"111\":1}}],[\"操作该图片\",{\"1\":{\"2\":1}}],[\"触达此值时\",{\"1\":{\"161\":1}}],[\"触发\",{\"1\":{\"266\":1}}],[\"触发重建\",{\"1\":{\"192\":1}}],[\"触发异常的时候不会崩溃\",{\"1\":{\"141\":1}}],[\"触发该闹钟\",{\"1\":{\"5\":1}}],[\"触发时间\",{\"0\":{\"5\":1},\"1\":{\"3\":1}}],[\"至少有一条路径可以到达所有顶点的图叫做连通图\",{\"1\":{\"433\":1}}],[\"至少有一个\",{\"1\":{\"197\":1}}],[\"至少能够晚一些消寂于这广阔的数据海洋中\",{\"1\":{\"398\":1}}],[\"至少保证\",{\"1\":{\"161\":1}}],[\"至此已经完成了java实现单例的绝大部分方法\",{\"1\":{\"294\":1}}],[\"至此\",{\"1\":{\"72\":1,\"84\":1,\"195\":1,\"240\":1,\"389\":1}}],[\"至此将looper和handler通过messagequeue联系在一起\",{\"1\":{\"31\":1}}],[\"尽可能不让他人修改变更引用\",{\"1\":{\"288\":1}}],[\"尽管子协程已经设置了异常处理者\",{\"1\":{\"329\":1}}],[\"尽管为了优化性能\",{\"1\":{\"287\":1}}],[\"尽管有各种子类\",{\"1\":{\"160\":1}}],[\"尽量避免写一些口水文\",{\"1\":{\"0\":1}}],[\"处对应的值\",{\"1\":{\"186\":1}}],[\"处于运动状态时返回\",{\"1\":{\"159\":1}}],[\"处理非随机数据时会慢到o\",{\"1\":{\"449\":1}}],[\"处理后\",{\"1\":{\"340\":1}}],[\"处理用户\",{\"1\":{\"226\":1}}],[\"处理native端发送的事件\",{\"1\":{\"211\":1}}],[\"处理回调\",{\"1\":{\"211\":1}}],[\"处理\",{\"1\":{\"155\":1,\"189\":1,\"212\":1,\"223\":1}}],[\"处理引导着render\",{\"1\":{\"122\":1}}],[\"处理event\",{\"1\":{\"101\":1}}],[\"处理两种消息\",{\"1\":{\"95\":1}}],[\"处理请求权限的结果\",{\"1\":{\"69\":1}}],[\"处理客户端msg\",{\"1\":{\"20\":1}}],[\"处理点击事件\",{\"1\":{\"13\":1}}],[\"反之则不然\",{\"1\":{\"458\":1}}],[\"反之\",{\"1\":{\"307\":1}}],[\"反之亦然\",{\"1\":{\"137\":1}}],[\"反序列化得到的对象会被丢弃\",{\"1\":{\"305\":1}}],[\"反序列化\",{\"1\":{\"303\":2,\"305\":1,\"309\":1}}],[\"反射的用法较为简单\",{\"1\":{\"295\":1}}],[\"反射获取资源id\",{\"1\":{\"427\":1}}],[\"反射获取该类及其资源\",{\"1\":{\"424\":1}}],[\"反射获取方法\",{\"1\":{\"295\":1}}],[\"反射获取变量\",{\"1\":{\"295\":1}}],[\"反射\",{\"1\":{\"295\":1}}],[\"反向开始朝向double\",{\"1\":{\"161\":1}}],[\"反向开始动画\",{\"1\":{\"161\":1}}],[\"反向运行的时长\",{\"1\":{\"161\":1}}],[\"反方向的\",{\"1\":{\"159\":1}}],[\"转而连接到a上\",{\"1\":{\"458\":1}}],[\"转换规则\",{\"1\":{\"453\":1}}],[\"转义\",{\"1\":{\"369\":1}}],[\"转到给\",{\"1\":{\"226\":1}}],[\"转发调用\",{\"1\":{\"226\":1}}],[\"转发过来的滑动事件\",{\"1\":{\"212\":1}}],[\"转化\",{\"1\":{\"183\":1}}],[\"转化为具体方法的调用\",{\"1\":{\"278\":1}}],[\"转化为曲线在\",{\"1\":{\"186\":1}}],[\"转化为\",{\"1\":{\"158\":1}}],[\"转载请附上原文出处链接及本声明\",{\"1\":{\"58\":1,\"288\":1}}],[\"种\",{\"1\":{\"161\":1}}],[\"种状态\",{\"1\":{\"158\":1}}],[\"种方式绑定\",{\"1\":{\"55\":1}}],[\"框架底层实现动画的各个类\",{\"1\":{\"157\":1}}],[\"框架层\",{\"1\":{\"60\":1}}],[\"曲线\",{\"1\":{\"156\":1}}],[\"控制\",{\"1\":{\"156\":1}}],[\"控制动画的开始和结束\",{\"1\":{\"156\":1}}],[\"控件的\",{\"1\":{\"170\":1}}],[\"控件在从\",{\"1\":{\"171\":1}}],[\"控件在屏幕中应该展示的像素大小\",{\"1\":{\"81\":1}}],[\"控件在app中对应的dp\",{\"1\":{\"81\":1}}],[\"控件在设计稿中的大小n\",{\"1\":{\"81\":1}}],[\"控件设计稿中的宽度\",{\"1\":{\"81\":1}}],[\"控件绑定处理器\",{\"1\":{\"79\":1}}],[\"控件\",{\"1\":{\"66\":1,\"170\":1}}],[\"值使用两个字节来表示\",{\"1\":{\"283\":1}}],[\"值对hashmap的数组长度length的余数\",{\"1\":{\"280\":1}}],[\"值对应状态而无动画\",{\"1\":{\"153\":1}}],[\"值的\",{\"1\":{\"227\":1}}],[\"值的构造方法\",{\"1\":{\"161\":1}}],[\"值之间创建线性的插值\",{\"1\":{\"184\":1}}],[\"值为\",{\"1\":{\"159\":1}}],[\"值和的二分之一\",{\"1\":{\"159\":1}}],[\"值和之前不一样的才会触发动画\",{\"1\":{\"153\":1}}],[\"值一样则无动画\",{\"1\":{\"153\":1}}],[\"应当考虑使用基于sliver的listview\",{\"1\":{\"242\":1}}],[\"应当将不需要每次更新的\",{\"1\":{\"153\":1}}],[\"应该要以祖节点右旋\",{\"1\":{\"458\":1}}],[\"应该就可以正常使用了\",{\"1\":{\"412\":1}}],[\"应该将coroutineexceptionhandler\",{\"1\":{\"329\":1}}],[\"应该尽可能采用这种方式\",{\"1\":{\"305\":1}}],[\"应该为负值\",{\"1\":{\"220\":1}}],[\"应该能了解\",{\"1\":{\"168\":1}}],[\"应用程序加载器\",{\"1\":{\"272\":1}}],[\"应用\",{\"1\":{\"225\":1,\"226\":2,\"399\":1}}],[\"应用delta之后没有变化\",{\"1\":{\"221\":1}}],[\"应用于\",{\"1\":{\"182\":1}}],[\"应用一个\",{\"1\":{\"159\":1}}],[\"应用到自身的\",{\"1\":{\"158\":1}}],[\"应用请求暂停\",{\"1\":{\"138\":1}}],[\"应用可见\",{\"1\":{\"138\":1}}],[\"应用在后台运行\",{\"1\":{\"138\":1}}],[\"应用处于非活动状态\",{\"1\":{\"138\":1}}],[\"应用层\",{\"1\":{\"60\":1}}],[\"应用常常要分发到多个应用商店\",{\"1\":{\"54\":1}}],[\"应用window\",{\"1\":{\"41\":1}}],[\"过渡层\",{\"1\":{\"459\":1}}],[\"过渡流操作符\",{\"0\":{\"338\":1}}],[\"过渡操作符应用于上游流\",{\"1\":{\"327\":1,\"338\":1}}],[\"过渡动画相关\",{\"1\":{\"177\":1}}],[\"过渡的过程\",{\"1\":{\"171\":1}}],[\"过渡到\",{\"1\":{\"153\":1}}],[\"过渡activity到主activity跳转时会出现短暂黑屏\",{\"1\":{\"14\":1}}],[\"首行默认以下命令\",{\"1\":{\"369\":1}}],[\"首次加载或者缓存被清空\",{\"1\":{\"198\":1}}],[\"首次\",{\"1\":{\"153\":1}}],[\"首先看一下\",{\"1\":{\"399\":1}}],[\"首先看看okhttputils的结构\",{\"1\":{\"362\":1}}],[\"首先根据jdk默认的第01周的定义\",{\"1\":{\"302\":1}}],[\"首先是在\",{\"1\":{\"211\":1}}],[\"首先创建了\",{\"1\":{\"211\":1}}],[\"首先创建整个应用程序使用的\",{\"1\":{\"89\":1}}],[\"首先通信的双方是flutter和本地操作系统或者应用\",{\"1\":{\"137\":1}}],[\"首先要添加相关依赖\",{\"1\":{\"88\":1}}],[\"首先要知道\",{\"1\":{\"58\":1}}],[\"首先\",{\"1\":{\"86\":1,\"187\":1,\"272\":1,\"400\":1}}],[\"首先需要请出第一个主角\",{\"1\":{\"83\":1}}],[\"首先被调用的是activity\",{\"1\":{\"13\":1}}],[\"渐变到\",{\"1\":{\"146\":1,\"157\":1}}],[\"渐变背景使用shader实现\",{\"1\":{\"63\":1}}],[\"停止从\",{\"1\":{\"375\":1}}],[\"停止动画\",{\"1\":{\"164\":1}}],[\"停止等都封装在\",{\"1\":{\"146\":1,\"157\":1}}],[\"停止服务\",{\"1\":{\"17\":1}}],[\"隐藏时\",{\"1\":{\"174\":1}}],[\"隐藏掉\",{\"1\":{\"13\":1}}],[\"隐式动画会自动播放\",{\"1\":{\"156\":1}}],[\"隐式动画内部维护着自己的animationcontroller\",{\"1\":{\"147\":1}}],[\"隐式动画内部持有\",{\"1\":{\"147\":1}}],[\"隐式动画\",{\"1\":{\"146\":3,\"156\":1,\"157\":2}}],[\"封装之后的\",{\"1\":{\"393\":1}}],[\"封装屏蔽掉滑动底层细节\",{\"1\":{\"227\":1}}],[\"封装好的动画\",{\"1\":{\"146\":1}}],[\"封装好的\",{\"1\":{\"146\":1}}],[\"封装了客户端绑定服务端的一些方法\",{\"1\":{\"35\":1}}],[\"底层基于\",{\"1\":{\"169\":1,\"170\":1}}],[\"底层实现\",{\"1\":{\"146\":1}}],[\"底层是通过aidl调用binder实现\",{\"1\":{\"43\":1}}],[\"颜色\",{\"1\":{\"146\":1,\"157\":1}}],[\"随着每一帧的变化\",{\"1\":{\"146\":1,\"157\":1}}],[\"输入y或n\",{\"1\":{\"368\":2}}],[\"输入回车会自动创建xxx\",{\"1\":{\"368\":1}}],[\"输入要发布的文章名称xxx\",{\"1\":{\"368\":1}}],[\"输入和\",{\"1\":{\"361\":1}}],[\"输入\",{\"1\":{\"348\":1,\"411\":1}}],[\"输入命令\",{\"1\":{\"347\":1,\"417\":1}}],[\"输入值为设计稿中对应的控件大小\",{\"1\":{\"81\":2}}],[\"输出所有日志信息\",{\"1\":{\"416\":1}}],[\"输出加工数据\",{\"1\":{\"371\":1}}],[\"输出格式化的数据\",{\"1\":{\"371\":1}}],[\"输出汇总文档\",{\"1\":{\"370\":1}}],[\"输出汇总信息\",{\"1\":{\"370\":1}}],[\"输出\",{\"1\":{\"361\":1}}],[\"输出信息\",{\"1\":{\"357\":1}}],[\"输出目录\",{\"1\":{\"357\":1}}],[\"输出sizeof计算结果\",{\"1\":{\"282\":1}}],[\"输出到控制台\",{\"1\":{\"144\":1}}],[\"交给zone统一处理\",{\"1\":{\"144\":2}}],[\"出错不会调用fluttererror\",{\"1\":{\"143\":1}}],[\"任务的类型\",{\"1\":{\"404\":1}}],[\"任务分两种\",{\"1\":{\"141\":1}}],[\"任意一个流中的值发生变化都会触发执行计算\",{\"1\":{\"344\":1}}],[\"任意值任意次\",{\"1\":{\"327\":1}}],[\"任意finally子句不能正常完成时的警告\",{\"1\":{\"298\":1}}],[\"任意时间\",{\"1\":{\"6\":1}}],[\"访问并标记\",{\"1\":{\"437\":1}}],[\"访问一个邻接的未访问顶点\",{\"1\":{\"437\":1}}],[\"访问这个节点\",{\"1\":{\"430\":1}}],[\"访问本地资源\",{\"1\":{\"140\":1}}],[\"访问外部存储空间中的媒体文件除了需要read\",{\"1\":{\"2\":1}}],[\"行号\",{\"1\":{\"361\":1}}],[\"行\",{\"1\":{\"139\":1,\"361\":1}}],[\"行间距\",{\"1\":{\"15\":1}}],[\"列表list\",{\"1\":{\"369\":1}}],[\"列表为\",{\"1\":{\"231\":1}}],[\"列表中在\",{\"1\":{\"231\":2}}],[\"列表中的字母标题\",{\"1\":{\"64\":1}}],[\"列表children\",{\"1\":{\"231\":1}}],[\"列表\",{\"1\":{\"226\":1}}],[\"列\",{\"1\":{\"139\":1}}],[\"黄马\",{\"1\":{\"137\":1}}],[\"远程过程调用\",{\"1\":{\"137\":1}}],[\"远程调用不会阻塞\",{\"1\":{\"43\":1}}],[\"截止flutter\",{\"1\":{\"137\":1}}],[\"隔离\",{\"1\":{\"136\":1}}],[\"状态\",{\"1\":{\"334\":1}}],[\"状态便不会再更改\",{\"1\":{\"132\":1}}],[\"状态栏等\",{\"1\":{\"41\":1}}],[\"脚手架\",{\"1\":{\"132\":1,\"415\":1}}],[\"万物皆控件\",{\"1\":{\"132\":1}}],[\"万一有某处遗忘了便会导致出错\",{\"1\":{\"94\":1}}],[\"稍微特殊一些\",{\"1\":{\"131\":1}}],[\"剩下的则清空\",{\"1\":{\"262\":1}}],[\"剩下的内存\",{\"1\":{\"257\":1}}],[\"剩下按照和\",{\"1\":{\"211\":1}}],[\"剩下工作就是计算两个控制点的坐标\",{\"1\":{\"61\":1}}],[\"剩余空间的时候\",{\"1\":{\"131\":1}}],[\"梁飞宇\",{\"1\":{\"130\":1}}],[\"判断优化的条件是否满足\",{\"1\":{\"396\":1}}],[\"判断url是否是完整\",{\"1\":{\"371\":1}}],[\"判断as是否为null\",{\"1\":{\"294\":1}}],[\"判断为true\",{\"1\":{\"294\":1}}],[\"判断targetvalue是否不等于tween\",{\"1\":{\"149\":1}}],[\"判断有需要时调用state\",{\"1\":{\"128\":1}}],[\"判断是否画出导航title\",{\"1\":{\"64\":1}}],[\"判断是否要开始根据dependency子view的行为改变child的状态\",{\"1\":{\"55\":1}}],[\"判断是否需要拦截\",{\"1\":{\"13\":1}}],[\"保存数据\",{\"1\":{\"371\":1}}],[\"保存的便是t的某个子类\",{\"1\":{\"292\":1}}],[\"保存的就是属于当前线程的独立的变量\",{\"1\":{\"288\":1}}],[\"保存1000个对象的hashmap<integer\",{\"1\":{\"287\":1}}],[\"保存1000个int对象的sparsearray\",{\"1\":{\"287\":1}}],[\"保存hashmap的键值对等信息\",{\"1\":{\"287\":1}}],[\"保存对象的\",{\"1\":{\"282\":1}}],[\"保存table数据\",{\"1\":{\"280\":1}}],[\"保存size\",{\"1\":{\"280\":1}}],[\"保存没有被使用的overscroll\",{\"1\":{\"226\":1}}],[\"保存创建的请求\",{\"1\":{\"211\":1}}],[\"保存发起的图片请求\",{\"1\":{\"211\":1}}],[\"保存\",{\"1\":{\"199\":1}}],[\"保持一致\",{\"1\":{\"128\":2,\"173\":1,\"224\":1}}],[\"保证oneach在catch之前\",{\"0\":{\"328\":1}}],[\"保证线程安全\",{\"1\":{\"320\":1}}],[\"保证线程安全的实质是保证对数据操作的原子性\",{\"1\":{\"317\":1}}],[\"保证同一时刻只能被一个线程使用\",{\"1\":{\"318\":1}}],[\"保证class文件中的字节流信息符合虚拟机的要求\",{\"1\":{\"276\":1}}],[\"保证child超出父级限制时可以滑动\",{\"1\":{\"242\":1}}],[\"保证了column的children可以完全显示\",{\"1\":{\"241\":1}}],[\"保证了布局在不同大小的屏幕上\",{\"1\":{\"53\":1}}],[\"保证其可以正常访问\",{\"1\":{\"2\":1}}],[\"管理要下载的链接\",{\"1\":{\"371\":1}}],[\"管理当前用户信息\",{\"0\":{\"353\":1}}],[\"管理员权限进入\",{\"1\":{\"348\":1}}],[\"管理scrollable\",{\"1\":{\"234\":1}}],[\"管理图片的比较适用于\",{\"1\":{\"211\":1}}],[\"管理图片\",{\"1\":{\"209\":1}}],[\"管理缓存\",{\"1\":{\"198\":1}}],[\"管理的所有\",{\"1\":{\"171\":1}}],[\"管理\",{\"1\":{\"171\":1,\"212\":1,\"227\":1}}],[\"管理rendering\",{\"1\":{\"127\":1}}],[\"管道指\",{\"1\":{\"328\":1}}],[\"管道pipe\",{\"1\":{\"58\":1}}],[\"管道\",{\"1\":{\"58\":2}}],[\"带权图的生成树中\",{\"1\":{\"438\":1}}],[\"带缓冲的通道\",{\"1\":{\"328\":1}}],[\"带有对象引用类型的所有实例域则都必须声明为transient的\",{\"1\":{\"305\":1}}],[\"带着这个疑问\",{\"1\":{\"127\":1}}],[\"带进度更新的弹窗\",{\"1\":{\"66\":1}}],[\"终以失败告终\",{\"1\":{\"408\":1}}],[\"终端输入\",{\"1\":{\"347\":1}}],[\"终止\",{\"1\":{\"178\":1}}],[\"终于到了我们这个app真正在屏幕上显示的内容这里了\",{\"1\":{\"127\":1}}],[\"终点后一个点为afterpoint\",{\"1\":{\"62\":1}}],[\"终点分别为startpoint\",{\"1\":{\"62\":1}}],[\"间接调用了text的build方法\",{\"1\":{\"126\":1}}],[\"间隔排序\",{\"1\":{\"462\":1}}],[\"间隔时间有两种\",{\"1\":{\"6\":1}}],[\"间隔时间\",{\"0\":{\"6\":1}}],[\"间隔多久重复一次\",{\"1\":{\"4\":1}}],[\"生产从\",{\"1\":{\"334\":1}}],[\"生产一个项目\",{\"1\":{\"327\":1}}],[\"生产者\",{\"1\":{\"322\":1}}],[\"生产widget\",{\"1\":{\"126\":1}}],[\"生命周期内有多个\",{\"1\":{\"161\":1}}],[\"生命周期\",{\"0\":{\"138\":1}}],[\"生成树\",{\"1\":{\"438\":1}}],[\"生成插件app的context\",{\"0\":{\"423\":1}}],[\"生成网页并预览\",{\"1\":{\"366\":1}}],[\"生成的\",{\"1\":{\"198\":1}}],[\"生成渠道包\",{\"1\":{\"54\":1}}],[\"生成\",{\"1\":{\"40\":1,\"347\":1}}],[\"必需\",{\"1\":{\"367\":3}}],[\"必要时更新child的slot\",{\"1\":{\"126\":1}}],[\"必须先退出当前关联的isolate\",{\"1\":{\"392\":1}}],[\"必须先被连接linked\",{\"1\":{\"279\":1}}],[\"必须使用对应的resumecapability依次resume才可以恢复isolate\",{\"1\":{\"375\":1}}],[\"必须使用同一个\",{\"1\":{\"375\":1}}],[\"必须至少有一个参数\",{\"1\":{\"321\":1}}],[\"必须有颜色\",{\"1\":{\"458\":1}}],[\"必须有这个变量\",{\"1\":{\"314\":1}}],[\"必须有前两个参数\",{\"1\":{\"56\":1}}],[\"必须与读取的顺序对应\",{\"1\":{\"314\":1}}],[\"必须按照写入的顺序读取\",{\"1\":{\"314\":1}}],[\"必须是能够产生rendersliver的widget\",{\"1\":{\"212\":1}}],[\"必须支持+\",{\"1\":{\"184\":1}}],[\"必须返回\",{\"1\":{\"147\":1}}],[\"必须在ui线程\",{\"1\":{\"80\":1}}],[\"必须在主线程调用\",{\"1\":{\"80\":1}}],[\"必须各进程利用同步工具解决\",{\"1\":{\"58\":1}}],[\"必须实现该方法\",{\"1\":{\"17\":1}}],[\"必须被指定\",{\"1\":{\"17\":1}}],[\"必须继承自service\",{\"1\":{\"17\":1}}],[\"事实上machine\",{\"1\":{\"396\":1}}],[\"事实上\",{\"1\":{\"305\":1}}],[\"事实上的final\",{\"1\":{\"281\":1}}],[\"事实也确实如此\",{\"1\":{\"126\":1}}],[\"事件\",{\"1\":{\"399\":1}}],[\"事件时\",{\"1\":{\"226\":1}}],[\"事件联动\",{\"1\":{\"64\":1}}],[\"→widget\",{\"1\":{\"128\":1}}],[\"→\",{\"1\":{\"124\":4,\"125\":2,\"126\":15,\"127\":8,\"377\":3,\"383\":1,\"391\":3,\"395\":2,\"396\":4,\"453\":1,\"454\":1,\"459\":1,\"460\":1}}],[\"↓\",{\"1\":{\"122\":1,\"126\":1}}],[\"个圆盘通过柱子b\",{\"1\":{\"459\":1}}],[\"个元素\",{\"1\":{\"455\":1,\"456\":1}}],[\"个数值\",{\"1\":{\"334\":1}}],[\"个数字\",{\"1\":{\"328\":1}}],[\"个数不同也不行\",{\"1\":{\"34\":1}}],[\"个tree\",{\"1\":{\"119\":1}}],[\"简单易实现\",{\"1\":{\"460\":1}}],[\"简单排序\",{\"0\":{\"454\":1}}],[\"简单\",{\"1\":{\"310\":1}}],[\"简单计算一下这个enumclazz的大小\",{\"1\":{\"285\":1}}],[\"简单的可以理解为程序编译期的绑定\",{\"1\":{\"273\":1}}],[\"简单的flutter\",{\"1\":{\"117\":1,\"127\":1}}],[\"简单总结一下\",{\"1\":{\"198\":1}}],[\"简单梳理一下图片从加载到展示的过程\",{\"1\":{\"187\":1}}],[\"简单使用\",{\"0\":{\"170\":1}}],[\"简单许多\",{\"1\":{\"154\":1}}],[\"简单来说如下\",{\"1\":{\"198\":1}}],[\"简单来说\",{\"1\":{\"146\":1,\"157\":1}}],[\"简书\",{\"1\":{\"15\":1,\"55\":2,\"87\":1}}],[\"快速排序算法\",{\"1\":{\"467\":1}}],[\"快速排序所用的数组\",{\"1\":{\"467\":1}}],[\"快速排序的思路\",{\"0\":{\"465\":1},\"1\":{\"467\":1}}],[\"快速排序的时间复杂度是o\",{\"1\":{\"460\":1}}],[\"快速排序在大多数情况下都是最快的\",{\"1\":{\"462\":1}}],[\"快速排序在某些情况下时间复杂度可达到\",{\"1\":{\"442\":1}}],[\"快速排序\",{\"1\":{\"445\":1,\"449\":3,\"465\":1}}],[\"快速滑动\",{\"1\":{\"55\":1}}],[\"快手\",{\"1\":{\"116\":1}}],[\"声明式\",{\"1\":{\"343\":1}}],[\"声明式捕获\",{\"0\":{\"328\":1},\"1\":{\"341\":1}}],[\"声明线程局部变量\",{\"1\":{\"325\":1}}],[\"声明系统线程类型\",{\"1\":{\"115\":1}}],[\"声明其为parcelable类型\",{\"1\":{\"34\":1}}],[\"运行指定的代码\",{\"1\":{\"389\":1}}],[\"运行\",{\"0\":{\"368\":1},\"1\":{\"275\":1}}],[\"运行时常量池属于方法区\",{\"1\":{\"258\":1}}],[\"运行时常量池溢出\",{\"0\":{\"258\":1}}],[\"运行时常量池\",{\"1\":{\"254\":1}}],[\"运行时发现会出错\",{\"1\":{\"85\":1}}],[\"运行的时候执行对应的messagehandler回调\",{\"1\":{\"115\":1}}],[\"看这篇就够了\",{\"1\":{\"316\":1}}],[\"看这里\",{\"1\":{\"305\":1}}],[\"看源码可以知道\",{\"1\":{\"312\":1}}],[\"看起来很完美\",{\"1\":{\"294\":1}}],[\"看起来好像是前一个页面的\",{\"1\":{\"170\":1}}],[\"看一下具体的实现\",{\"1\":{\"211\":1}}],[\"看一下dart\",{\"1\":{\"116\":1}}],[\"看一下portmap\",{\"1\":{\"115\":1}}],[\"看到messengerimpl继承的imessenger\",{\"1\":{\"43\":1}}],[\"见下文详细分析\",{\"1\":{\"389\":1}}],[\"见下文↓\",{\"1\":{\"280\":1}}],[\"见\",{\"1\":{\"115\":1,\"227\":1}}],[\"见上\",{\"1\":{\"80\":1}}],[\"激活这个端口\",{\"1\":{\"115\":1}}],[\"退出命令行\",{\"1\":{\"368\":2}}],[\"退出当前isolate\",{\"1\":{\"115\":2}}],[\"退出app\",{\"1\":{\"101\":1,\"109\":1,\"144\":1}}],[\"释放platform\",{\"1\":{\"211\":1}}],[\"释放图片资源等\",{\"1\":{\"208\":1}}],[\"释放时机\",{\"1\":{\"203\":1}}],[\"释放资源\",{\"1\":{\"164\":1}}],[\"释放掉占用的port\",{\"1\":{\"112\":1}}],[\"释放这个触发这个回调的sendport\",{\"1\":{\"111\":1,\"112\":1}}],[\"位运算\",{\"1\":{\"280\":1}}],[\"位于\",{\"1\":{\"171\":1,\"173\":2}}],[\"位于sdk\",{\"1\":{\"112\":1}}],[\"位移的动画\",{\"1\":{\"169\":1}}],[\"位置在runtime\",{\"1\":{\"372\":1}}],[\"位置在sdk\",{\"1\":{\"372\":2}}],[\"位置参数\",{\"1\":{\"369\":1}}],[\"位置的值的类\",{\"1\":{\"186\":1}}],[\"位置\",{\"1\":{\"181\":1}}],[\"位置变化从而推测出\",{\"1\":{\"172\":1}}],[\"位置和大小的路径动画\",{\"1\":{\"171\":1}}],[\"位置等属性\",{\"1\":{\"146\":1,\"157\":1}}],[\"位置不变\",{\"1\":{\"41\":1}}],[\"读权限4\",{\"1\":{\"351\":1}}],[\"读取栈顶元素top\",{\"1\":{\"453\":1}}],[\"读取每一项内容并保存\",{\"1\":{\"371\":1}}],[\"读取快\",{\"1\":{\"369\":1}}],[\"读取数据时默认该对象不会被其他对象更改而不加锁\",{\"1\":{\"320\":1}}],[\"读取c的值\",{\"1\":{\"317\":1}}],[\"读取之前序列化的两个对象\",{\"1\":{\"309\":1}}],[\"读取变量\",{\"1\":{\"306\":1}}],[\"读取\",{\"1\":{\"279\":1}}],[\"读取的文件内容\",{\"1\":{\"111\":1}}],[\"读取文件的信息\",{\"1\":{\"111\":1}}],[\"读取文件过程分析\",{\"0\":{\"110\":1}}],[\"读写\",{\"1\":{\"79\":1}}],[\"官网异常处理\",{\"1\":{\"145\":1}}],[\"官网\",{\"1\":{\"109\":1,\"172\":1}}],[\"官方定义是在指定约束条件成熟时可靠的在后台执行对应的任务\",{\"1\":{\"404\":1}}],[\"官方介绍是参考rxjava等响应式流实现的\",{\"1\":{\"335\":1}}],[\"官方的\",{\"1\":{\"208\":1}}],[\"官方的实现为radial\",{\"1\":{\"172\":1}}],[\"官方\",{\"1\":{\"202\":1}}],[\"官方对其定义是\",{\"1\":{\"212\":1,\"234\":1}}],[\"官方对\",{\"1\":{\"171\":1,\"227\":1}}],[\"官方给了一张图\",{\"1\":{\"146\":1,\"157\":1}}],[\"官方手册\",{\"1\":{\"87\":1}}],[\"官方文档未相关描述\",{\"1\":{\"274\":1}}],[\"官方文档\",{\"1\":{\"54\":1,\"94\":1}}],[\"官方推荐我们使用sparearray和arraymap\",{\"1\":{\"44\":1}}],[\"官方方法如下\",{\"1\":{\"14\":1}}],[\"去除非必须的生命周期长的对象\",{\"1\":{\"256\":1}}],[\"去检查执行一下micro\",{\"1\":{\"109\":1}}],[\"去掉共享的head和methodarea占的内存\",{\"1\":{\"257\":1}}],[\"去掉\",{\"1\":{\"85\":1}}],[\"告诉event\",{\"1\":{\"108\":1}}],[\"≠\",{\"0\":{\"108\":1},\"1\":{\"108\":1}}],[\"`entrypoint`\",{\"1\":{\"378\":1}}],[\"`paused`\",{\"1\":{\"378\":1}}],[\"`main`\",{\"1\":{\"378\":2}}],[\"``void\",{\"1\":{\"373\":1}}],[\"``sendport\",{\"1\":{\"373\":1}}],[\"`val`\",{\"1\":{\"346\":1}}],[\"`tosubtreecontext`\",{\"1\":{\"180\":1}}],[\"`to`\",{\"1\":{\"179\":2,\"180\":1}}],[\"`fromsubtreecontext`\",{\"1\":{\"180\":1}}],[\"`future`\",{\"1\":{\"102\":1}}],[\"`renderobjecttowidgetadapter`\",{\"1\":{\"121\":1}}],[\"`\",{\"1\":{\"102\":2}}],[\"`scheduleimmediate`\",{\"1\":{\"100\":1}}],[\"什么时候会被安排执行呢\",{\"1\":{\"101\":1}}],[\"包裹的\",{\"1\":{\"226\":1}}],[\"包裹之后执行的\",{\"1\":{\"100\":1}}],[\"包含所有的静态化文件\",{\"1\":{\"419\":1}}],[\"包含了要创建的object以及如何关联这些对象的说明信息\",{\"1\":{\"396\":1}}],[\"包含其持有对象的大小\",{\"1\":{\"282\":1}}],[\"包含在内\",{\"1\":{\"220\":1}}],[\"包含底部导航栏\",{\"1\":{\"81\":1}}],[\"包括栈\",{\"1\":{\"445\":1}}],[\"包括表和对表的操作\",{\"1\":{\"399\":1}}],[\"包括数据\",{\"1\":{\"399\":1}}],[\"包括隐藏文件\",{\"1\":{\"350\":1}}],[\"包括私有的\",{\"1\":{\"295\":1}}],[\"包括父类或接口的xx\",{\"1\":{\"295\":1}}],[\"包括包名\",{\"1\":{\"295\":1}}],[\"包括\",{\"1\":{\"275\":1}}],[\"包括了\",{\"1\":{\"212\":1}}],[\"包括异步的都可以捕获到\",{\"1\":{\"145\":1}}],[\"包括inheritedwidget\",{\"1\":{\"129\":1}}],[\"比选择排序快一些\",{\"1\":{\"457\":1}}],[\"比冒泡快一倍\",{\"1\":{\"457\":1}}],[\"比快速排序更适于非随机数据\",{\"1\":{\"449\":1}}],[\"比子节点大的位置\",{\"1\":{\"441\":1}}],[\"比serializable麻烦\",{\"1\":{\"313\":1}}],[\"比\",{\"1\":{\"154\":1}}],[\"比较a和b\",{\"1\":{\"455\":1}}],[\"比较占地方\",{\"1\":{\"433\":1}}],[\"比较方便\",{\"1\":{\"419\":1}}],[\"比较简单\",{\"1\":{\"371\":1}}],[\"比较偏基础\",{\"1\":{\"321\":1}}],[\"比较并交换\",{\"1\":{\"319\":1}}],[\"比较耗性能\",{\"1\":{\"233\":1}}],[\"比较耗费性能\",{\"1\":{\"232\":1,\"242\":1}}],[\"比较容易理解\",{\"1\":{\"131\":1}}],[\"比较特殊\",{\"1\":{\"95\":1}}],[\"比如三角数组就是一个简单的递归\",{\"1\":{\"459\":1}}],[\"比如执行native代码\",{\"1\":{\"396\":1}}],[\"比如heap\",{\"1\":{\"396\":1}}],[\"比如调用main方法\",{\"1\":{\"394\":1}}],[\"比如手机\",{\"1\":{\"393\":1}}],[\"比如flutter就将cfe\",{\"1\":{\"393\":1}}],[\"比如isolate\",{\"1\":{\"389\":2}}],[\"比如你要添加一个文件xxx到本地仓库\",{\"1\":{\"347\":1}}],[\"比如onclicklistener\",{\"1\":{\"345\":1}}],[\"比如说\",{\"1\":{\"329\":1}}],[\"比如非连续判断\",{\"1\":{\"286\":1}}],[\"比如非法内存访问\",{\"1\":{\"58\":1}}],[\"比如一些native方法或者artificial\",{\"1\":{\"395\":1}}],[\"比如一直位于屏幕下方的版权信息\",{\"1\":{\"242\":1}}],[\"比如一个\",{\"1\":{\"231\":1}}],[\"比如竖屏变为横屏等\",{\"1\":{\"240\":1}}],[\"比如在column中直接使用singlechildscrollview就会在内容过长的时候发生overflowed错误并且无法滑动singlechildscrollview\",{\"1\":{\"238\":1}}],[\"比如customscrollview及其子类listview\",{\"1\":{\"234\":1}}],[\"比如axis\",{\"1\":{\"239\":1}}],[\"比如android会触发在scrollablestate\",{\"1\":{\"221\":1}}],[\"比如appcomponent类\",{\"1\":{\"94\":1}}],[\"比如是否可以滚动或弹性滚动等\",{\"1\":{\"212\":1,\"227\":1,\"234\":1}}],[\"比如external\",{\"1\":{\"211\":1}}],[\"比如network\",{\"1\":{\"211\":1}}],[\"比如runapp之前执行\",{\"1\":{\"211\":1}}],[\"比如glide\",{\"1\":{\"198\":1}}],[\"比如网络图片没有磁盘缓存\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"比如从页面\",{\"1\":{\"174\":1}}],[\"比如监听进度从而实现旋转\",{\"1\":{\"172\":1}}],[\"比如\",{\"1\":{\"148\":1,\"157\":2,\"184\":1,\"188\":1,\"198\":1,\"211\":1,\"212\":3,\"226\":1,\"227\":3,\"235\":1,\"277\":1,\"302\":1,\"327\":1,\"375\":1}}],[\"比如暂停动画\",{\"1\":{\"147\":1}}],[\"比如异步的方法\",{\"1\":{\"145\":1}}],[\"比如输出到控制台\",{\"1\":{\"144\":1}}],[\"比如本例中的center\",{\"1\":{\"121\":1}}],[\"比如1表示只要包含第一天就算该年的第一周\",{\"1\":{\"302\":1}}],[\"比如1\",{\"1\":{\"62\":1}}],[\"比如某一行\",{\"1\":{\"15\":1}}],[\"各种事件\",{\"1\":{\"95\":1}}],[\"各个步骤按照顺序进行\",{\"1\":{\"273\":1}}],[\"各个时间都会通知到\",{\"1\":{\"178\":1}}],[\"各个isolate之间的代码运行时是隔离的\",{\"1\":{\"95\":1}}],[\"各个效果如下\",{\"1\":{\"57\":1}}],[\"优缺点\",{\"0\":{\"310\":1,\"313\":1,\"316\":1},\"1\":{\"262\":1,\"263\":1,\"264\":1,\"265\":1}}],[\"优缺点参考\",{\"1\":{\"58\":1}}],[\"优先级低的在队尾\",{\"1\":{\"448\":1}}],[\"优先级队列\",{\"0\":{\"448\":1,\"453\":1},\"1\":{\"445\":2}}],[\"优先考虑二叉树\",{\"1\":{\"445\":1}}],[\"优先将一个节点的所有邻接点依次访问\",{\"1\":{\"438\":1}}],[\"优先处理obb\",{\"1\":{\"376\":1}}],[\"优先消息\",{\"1\":{\"376\":1}}],[\"优先使用\",{\"1\":{\"318\":1}}],[\"优先使用tohero\",{\"1\":{\"180\":1}}],[\"优先选择\",{\"1\":{\"211\":1}}],[\"优先从\",{\"1\":{\"196\":1}}],[\"优先执行\",{\"1\":{\"95\":1}}],[\"做一分析\",{\"1\":{\"227\":1}}],[\"做完了以上所有内容\",{\"1\":{\"93\":1}}],[\"做验证的手段有\",{\"1\":{\"39\":1}}],[\"权限验证\",{\"1\":{\"351\":1}}],[\"权限\",{\"1\":{\"351\":2}}],[\"权限之外\",{\"1\":{\"2\":1}}],[\"权衡之下我觉得这种方式是比较能接受的\",{\"1\":{\"91\":1}}],[\"引入协变\",{\"1\":{\"291\":1}}],[\"引用其他key的值\",{\"1\":{\"358\":1}}],[\"引用的等级来划分\",{\"1\":{\"288\":1}}],[\"引用\",{\"1\":{\"282\":1,\"285\":1}}],[\"引用类型大小为4\",{\"1\":{\"282\":1}}],[\"引用类\",{\"1\":{\"274\":1}}],[\"引用+1\",{\"1\":{\"265\":1}}],[\"引用计数算法\",{\"0\":{\"265\":1}}],[\"引用该插件\",{\"1\":{\"88\":1}}],[\"引擎会调用powerimageplugin\",{\"1\":{\"211\":2}}],[\"引擎注册对应的方法\",{\"1\":{\"211\":1}}],[\"引擎持有的\",{\"1\":{\"203\":1}}],[\"引起appcolor重新创建\",{\"1\":{\"130\":1}}],[\"引导芯片从rom读取读取初始化代码\",{\"1\":{\"60\":1}}],[\"❤️\",{\"0\":{\"88\":1}}],[\"系列\",{\"1\":{\"87\":1}}],[\"系统运行时的用户数据\",{\"1\":{\"349\":1}}],[\"系统的所有设备文件\",{\"1\":{\"349\":1}}],[\"系统的配置文件\",{\"1\":{\"349\":1}}],[\"系统内核\",{\"1\":{\"349\":1}}],[\"系统在关闭该子线程前\",{\"1\":{\"297\":1}}],[\"系统会自动传入类对象\",{\"1\":{\"369\":1}}],[\"系统会自动用对象的hashcode\",{\"1\":{\"304\":1}}],[\"系统会对此进行优化\",{\"1\":{\"65\":1}}],[\"系统会根据过去的时间和重复间隔选择一个合适的时间来触发\",{\"1\":{\"5\":1}}],[\"系统启动示意图\",{\"1\":{\"60\":1}}],[\"系统启动框架图\",{\"1\":{\"60\":1}}],[\"系统库+android运行时\",{\"1\":{\"60\":1}}],[\"系统对每个接口方法的编号\",{\"1\":{\"58\":1}}],[\"系统对我们在aidl中定义的方法的具体实现\",{\"1\":{\"58\":1}}],[\"系统自动帮我们实现了更详细的内容\",{\"1\":{\"58\":1}}],[\"系统提供了4个实现类\",{\"1\":{\"55\":1}}],[\"系统window\",{\"1\":{\"41\":1}}],[\"系统\",{\"1\":{\"19\":1,\"353\":1}}],[\"继而在threadgroup\",{\"1\":{\"297\":1}}],[\"继续读取下一个\",{\"1\":{\"453\":1}}],[\"继续纵深访问\",{\"1\":{\"437\":1}}],[\"继续运行\",{\"1\":{\"326\":2}}],[\"继续执行代码1后面的代码直到最后一行\",{\"1\":{\"323\":1}}],[\"继续消耗\",{\"1\":{\"226\":1}}],[\"继续保留一遍下一次可能的复用\",{\"1\":{\"87\":1}}],[\"继承到的方法中\",{\"1\":{\"179\":1}}],[\"继承的方法外\",{\"1\":{\"161\":1}}],[\"继承implicitlyanimatedwidget\",{\"1\":{\"156\":1}}],[\"继承\",{\"1\":{\"146\":1,\"152\":1,\"157\":1,\"369\":1}}],[\"继承自abstractmap\",{\"1\":{\"287\":1}}],[\"继承自asynctask\",{\"1\":{\"80\":1}}],[\"继承自map\",{\"1\":{\"280\":1}}],[\"继承自classloader\",{\"1\":{\"272\":1}}],[\"继承自imageproviderext\",{\"1\":{\"208\":1}}],[\"继承自imageprovider\",{\"1\":{\"201\":1}}],[\"继承自父类\",{\"1\":{\"168\":1}}],[\"继承自\",{\"1\":{\"79\":1,\"152\":1,\"158\":1,\"182\":1,\"185\":1,\"186\":1,\"194\":1,\"212\":1,\"213\":1,\"214\":1,\"227\":1,\"229\":1}}],[\"继承自dialog\",{\"1\":{\"66\":1}}],[\"继承自布局文件的父布局linearlayout\",{\"1\":{\"56\":1}}],[\"发布github\",{\"1\":{\"468\":1}}],[\"发布文章\",{\"1\":{\"368\":1}}],[\"发布完后默认打开该网页\",{\"1\":{\"367\":1}}],[\"发布到对应xxx\",{\"1\":{\"366\":1}}],[\"发射一个异常\",{\"1\":{\"341\":1}}],[\"发射下一个值\",{\"1\":{\"327\":1,\"336\":1,\"341\":1}}],[\"发射\",{\"1\":{\"327\":1}}],[\"发生hash冲突时\",{\"1\":{\"280\":1}}],[\"发生变化了\",{\"1\":{\"148\":1}}],[\"发出overscroll的overscrollnotification通知\",{\"1\":{\"221\":1}}],[\"发出scrollupdatenotification通知\",{\"1\":{\"220\":1}}],[\"发出通知\",{\"1\":{\"157\":1}}],[\"发来了不认识的事件\",{\"1\":{\"211\":1}}],[\"发起请求加载图片\",{\"1\":{\"211\":1}}],[\"发起请求至服务端\",{\"1\":{\"40\":2}}],[\"发起图片请求\",{\"1\":{\"211\":1}}],[\"发送到主通道\",{\"1\":{\"334\":1}}],[\"发送消息\",{\"1\":{\"334\":1}}],[\"发送消息时\",{\"1\":{\"211\":2}}],[\"发送一条消息以用来从一个\",{\"1\":{\"334\":1}}],[\"发送和接收操作是\",{\"1\":{\"328\":1}}],[\"发送下一个值\",{\"1\":{\"327\":1}}],[\"发送\",{\"1\":{\"227\":1,\"328\":1}}],[\"发送获取释放图片指令\",{\"1\":{\"211\":1}}],[\"发送的消息\",{\"1\":{\"107\":1}}],[\"发现了真正的原因\",{\"1\":{\"302\":1}}],[\"发现\",{\"1\":{\"86\":1}}],[\"错误widget在debug和release模式下有一些区别\",{\"1\":{\"143\":1}}],[\"错误\",{\"1\":{\"85\":1}}],[\"桥梁\",{\"1\":{\"85\":1}}],[\"大\",{\"1\":{\"454\":1,\"459\":3,\"460\":1,\"462\":1}}],[\"大多数应用如今已经不能正常使用了\",{\"1\":{\"398\":1}}],[\"大多数情况下会减少消耗\",{\"1\":{\"320\":1}}],[\"大部分内容都参考\",{\"1\":{\"347\":1}}],[\"大王叫我来巡山的回答\",{\"1\":{\"297\":1}}],[\"大string\",{\"1\":{\"250\":1}}],[\"大对象\",{\"1\":{\"250\":1}}],[\"大图片会出现内存峰值偏高\",{\"1\":{\"211\":1}}],[\"大而全\",{\"1\":{\"202\":1}}],[\"大于\",{\"1\":{\"173\":1,\"226\":1}}],[\"大类\",{\"1\":{\"147\":1,\"154\":1}}],[\"大袋子\",{\"1\":{\"85\":1}}],[\"大小可以预测时使用\",{\"1\":{\"445\":1}}],[\"大小由\",{\"1\":{\"232\":1}}],[\"大小由父级指定\",{\"1\":{\"231\":1}}],[\"大小等属性返回\",{\"1\":{\"211\":1}}],[\"大小等于内存总量\",{\"1\":{\"58\":1}}],[\"大小\",{\"1\":{\"181\":2,\"282\":1}}],[\"大小为\",{\"1\":{\"173\":2}}],[\"大小是mhashes的两倍\",{\"1\":{\"49\":1}}],[\"打包\",{\"1\":{\"357\":2}}],[\"打包后格式\",{\"1\":{\"355\":1}}],[\"打包提供给\",{\"1\":{\"85\":1}}],[\"打印前\",{\"1\":{\"328\":1}}],[\"打开本地地址\",{\"1\":{\"414\":1}}],[\"打开命令行\",{\"1\":{\"413\":1}}],[\"打开\",{\"1\":{\"411\":1,\"417\":1,\"419\":1}}],[\"打开终端\",{\"1\":{\"348\":1}}],[\"打开终端执行以下命令\",{\"1\":{\"348\":1}}],[\"打开文件\",{\"1\":{\"111\":1,\"371\":1}}],[\"打开服务\",{\"1\":{\"79\":1}}],[\"装\",{\"0\":{\"409\":1},\"1\":{\"85\":1}}],[\"像是ping\",{\"1\":{\"376\":1}}],[\"像padding\",{\"1\":{\"132\":1}}],[\"像一个袋子一样把\",{\"1\":{\"85\":1}}],[\"像素\",{\"1\":{\"53\":1,\"193\":1}}],[\"像素级\",{\"1\":{\"53\":1}}],[\"某种意义上他们像是一种enum\",{\"1\":{\"322\":1}}],[\"某个thread调用某个对象的同步方法\",{\"1\":{\"297\":1}}],[\"某个将service依赖注入的方法\",{\"1\":{\"82\":1}}],[\"某一控件\",{\"1\":{\"15\":1}}],[\"示例\",{\"1\":{\"282\":1}}],[\"示例代码\",{\"1\":{\"82\":1,\"135\":1}}],[\"示意图除非特殊注明外\",{\"1\":{\"399\":1}}],[\"示意图如下\",{\"1\":{\"174\":1}}],[\"示意图来自https\",{\"1\":{\"58\":2}}],[\"手指向上滑动屏幕此值增大\",{\"1\":{\"239\":1}}],[\"手势事件会被\",{\"1\":{\"226\":1}}],[\"手势事件会被其捕获并内部消耗\",{\"1\":{\"223\":1}}],[\"手势识别\",{\"1\":{\"212\":1,\"227\":1,\"234\":1}}],[\"手势等封装\",{\"1\":{\"200\":1}}],[\"手机屏幕真实高度\",{\"1\":{\"81\":1}}],[\"手动调用measure\",{\"1\":{\"65\":1}}],[\"获得\",{\"1\":{\"198\":1}}],[\"获得屏幕真实高度\",{\"1\":{\"81\":1}}],[\"获取希尔排序间隔\",{\"1\":{\"462\":1}}],[\"获取资源\",{\"0\":{\"427\":1}}],[\"获取未安装apk的packageinfo\",{\"1\":{\"425\":1}}],[\"获取apk信息\",{\"0\":{\"425\":1}}],[\"获取当前isolate\",{\"0\":{\"377\":1}}],[\"获取所有的文章节点nodes\",{\"1\":{\"371\":1}}],[\"获取有用数据\",{\"1\":{\"371\":1}}],[\"获取中序排序中根节点的坐标\",{\"1\":{\"346\":1}}],[\"获取根节点\",{\"1\":{\"346\":1}}],[\"获取对象的同时初始化listener\",{\"1\":{\"345\":1}}],[\"获取对应内存中的数据\",{\"1\":{\"211\":1}}],[\"获取注解的值\",{\"1\":{\"300\":1}}],[\"获取注解对象\",{\"1\":{\"300\":1}}],[\"获取该类中的所有域变量\",{\"1\":{\"300\":1}}],[\"获取要反射class的变量\",{\"1\":{\"295\":1}}],[\"获取要反射的class对象atestclsobj\",{\"1\":{\"295\":1}}],[\"获取要显示的联系人数据对应的英文tag集合\",{\"1\":{\"64\":1}}],[\"获取classloader\",{\"0\":{\"426\":1},\"1\":{\"424\":1}}],[\"获取class对象clazz\",{\"1\":{\"295\":1}}],[\"获取canonical\",{\"1\":{\"384\":1}}],[\"获取compose中对应的px\",{\"1\":{\"81\":1}}],[\"获取compose中对应的dp\",{\"1\":{\"81\":1}}],[\"获取父级约束信息\",{\"1\":{\"241\":2,\"242\":1}}],[\"获取图片\",{\"1\":{\"211\":1}}],[\"获取图片信息\",{\"1\":{\"211\":1}}],[\"获取图片的过程\",{\"1\":{\"211\":1}}],[\"获取图片在内存中的指针\",{\"1\":{\"211\":1}}],[\"获取并监听\",{\"1\":{\"198\":1,\"200\":1}}],[\"获取指定类型的inheritedwidget\",{\"1\":{\"129\":1}}],[\"获取网络信息\",{\"0\":{\"78\":1}}],[\"获取屏幕画面\",{\"0\":{\"77\":1}}],[\"获取path总长度\",{\"1\":{\"63\":1}}],[\"获取从0\",{\"1\":{\"63\":1}}],[\"获取\",{\"1\":{\"54\":1,\"163\":1,\"190\":1,\"202\":1,\"208\":1,\"211\":1,\"213\":1}}],[\"获取到该锁的线程可以多次重入\",{\"1\":{\"317\":1}}],[\"获取到使用注解的类\",{\"1\":{\"300\":1}}],[\"获取到对应的\",{\"1\":{\"148\":1}}],[\"获取到的\",{\"1\":{\"193\":1}}],[\"获取到的port\",{\"1\":{\"115\":1}}],[\"获取到的状态栏是系统的状态栏69px\",{\"1\":{\"53\":1}}],[\"获取到\",{\"1\":{\"55\":1}}],[\"获取到当前线程的looper和messagequeue\",{\"1\":{\"31\":1}}],[\"获取key的hashcode\",{\"1\":{\"49\":1}}],[\"获取数据\",{\"1\":{\"46\":1}}],[\"获取的对象\",{\"1\":{\"305\":1}}],[\"获取的\",{\"1\":{\"43\":1,\"207\":1,\"211\":1}}],[\"获取的路径\",{\"1\":{\"2\":1}}],[\"获取客户端传过来的数据\",{\"1\":{\"40\":1}}],[\"获取msg\",{\"1\":{\"31\":1}}],[\"获取服务实例\",{\"1\":{\"19\":1}}],[\"获取服务端ibinder\",{\"1\":{\"19\":1}}],[\"已知条件\",{\"1\":{\"81\":1}}],[\"已经是有序的\",{\"1\":{\"457\":1}}],[\"已经有一个公认的比较好的二次hash算法\",{\"1\":{\"428\":1}}],[\"已经有键为key的数据\",{\"1\":{\"50\":1}}],[\"已经配置好了环境变量\",{\"1\":{\"411\":1}}],[\"已经排好顺序的最大值不用参与排序\",{\"1\":{\"289\":1}}],[\"已经存在值并且数量大于8\",{\"1\":{\"280\":1}}],[\"已经确定了文本方向\",{\"1\":{\"228\":1}}],[\"已经由于某种原因超过\",{\"1\":{\"220\":1}}],[\"已经被监听了\",{\"1\":{\"197\":1}}],[\"已经控制动画开始执行\",{\"1\":{\"152\":1}}],[\"已经对activity\",{\"1\":{\"72\":1}}],[\"已经提供了管道\",{\"1\":{\"58\":1}}],[\"已经绘制到了p\",{\"1\":{\"63\":1}}],[\"已经绘制的图形\",{\"1\":{\"57\":1}}],[\"已经绘制好的图形为dst\",{\"1\":{\"57\":1}}],[\"真\",{\"1\":{\"370\":1}}],[\"真实面试题之\",{\"1\":{\"280\":1}}],[\"真正影响我们格式化日期结果的是simpledateformat中的calendar对象对应的值\",{\"1\":{\"302\":1}}],[\"真正展示图片内容\",{\"1\":{\"206\":1}}],[\"真正从网络加载图片的方法\",{\"1\":{\"196\":1}}],[\"真正在路由切换时操作\",{\"1\":{\"178\":1}}],[\"真正执行逻辑的类\",{\"1\":{\"212\":1}}],[\"真正执行请求\",{\"1\":{\"211\":1}}],[\"真正执行\",{\"1\":{\"80\":1}}],[\"真是惭愧\",{\"1\":{\"0\":1}}],[\"适用于页面内容通常为全部可见\",{\"1\":{\"242\":1}}],[\"适用于child通常是完全可见的\",{\"1\":{\"240\":1}}],[\"适用于日常场景\",{\"1\":{\"211\":1}}],[\"适用于\",{\"1\":{\"161\":2}}],[\"适用于没有预设编辑的物理模拟动画\",{\"1\":{\"161\":1}}],[\"适用于将原先线性变化的\",{\"1\":{\"159\":1}}],[\"适用于动画可能会变化的情况\",{\"1\":{\"159\":1}}],[\"适用于有可注入的构造函数并且包含控制类型实例如何重用的类\",{\"1\":{\"87\":1}}],[\"适用于大量并发请求\",{\"1\":{\"32\":1}}],[\"适合实时更新后台任务进度的工作\",{\"1\":{\"80\":1}}],[\"刷新页面\",{\"1\":{\"119\":1}}],[\"刷新等事件也在此类event中\",{\"1\":{\"101\":1}}],[\"刷新\",{\"1\":{\"79\":1}}],[\"利用堆根节点关键值最大这一特性\",{\"1\":{\"442\":1}}],[\"利用堆根节点关键值最大这个属性\",{\"1\":{\"439\":1}}],[\"利用travis通过hexo在github上自动部署markdown文档\",{\"0\":{\"405\":1}}],[\"利用上述的参数可以并通过generaterequest\",{\"1\":{\"364\":1}}],[\"利用readresolve\",{\"1\":{\"305\":1}}],[\"利用该\",{\"1\":{\"79\":1}}],[\"利用mscroller计算出接下来要scrollto\",{\"1\":{\"41\":1}}],[\"加\",{\"1\":{\"413\":1}}],[\"加一\",{\"1\":{\"390\":1}}],[\"加工\",{\"1\":{\"371\":1}}],[\"加密后的密码\",{\"1\":{\"306\":2}}],[\"加密文本并转化为16进制\",{\"1\":{\"296\":1}}],[\"加密和解密的结果都是二进制的\",{\"1\":{\"296\":1}}],[\"加密\",{\"1\":{\"296\":2}}],[\"加重\",{\"1\":{\"220\":1}}],[\"加载已安装应用\",{\"0\":{\"420\":1},\"1\":{\"420\":1}}],[\"加载可能会有问题\",{\"1\":{\"417\":1}}],[\"加载imgurl中的图片到imageview等等\",{\"1\":{\"399\":1}}],[\"加载因子为0\",{\"1\":{\"280\":1}}],[\"加载系数\",{\"1\":{\"280\":1}}],[\"加载loading\",{\"1\":{\"273\":1}}],[\"加载\",{\"1\":{\"272\":1,\"274\":1}}],[\"加载当前应用的classpath的所有类\",{\"1\":{\"272\":1}}],[\"加载目录\",{\"1\":{\"272\":1}}],[\"加载核心类库\",{\"1\":{\"272\":1}}],[\"加载成功\",{\"1\":{\"211\":1}}],[\"加载到图片之后进行解析\",{\"1\":{\"211\":1}}],[\"加载失败\",{\"1\":{\"200\":1}}],[\"加载图片\",{\"1\":{\"188\":1,\"198\":1}}],[\"加载过程\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"加载引导程序到ram中\",{\"1\":{\"60\":1}}],[\"加入支持泛型参数\",{\"1\":{\"291\":1}}],[\"加入\",{\"1\":{\"79\":1}}],[\"定向\",{\"1\":{\"361\":1}}],[\"定时返回unit的channel\",{\"1\":{\"328\":1}}],[\"定时输出\",{\"1\":{\"0\":1}}],[\"定位泄露对象\",{\"1\":{\"256\":1}}],[\"定义要执行的任务内容\",{\"1\":{\"404\":1}}],[\"定义各个界面之前的切换关系\",{\"1\":{\"400\":1}}],[\"定义入口类\",{\"1\":{\"371\":1}}],[\"定义类\",{\"1\":{\"369\":1}}],[\"定义只需要一步\",{\"1\":{\"345\":1}}],[\"定义的方法和java中写法类似\",{\"1\":{\"345\":1}}],[\"定义方法setonclicklistener\",{\"1\":{\"345\":1}}],[\"定义一个接口onclicklistener\",{\"1\":{\"345\":1}}],[\"定义一个注解帮助类\",{\"1\":{\"298\":1}}],[\"定义一个注解类\",{\"1\":{\"298\":1}}],[\"定义一个待反射的类atestclass\",{\"1\":{\"295\":1}}],[\"定义一些类\",{\"1\":{\"130\":1}}],[\"定义hero过渡widget切换方式\",{\"1\":{\"175\":1}}],[\"定义\",{\"1\":{\"174\":1}}],[\"定义了对表格\",{\"1\":{\"403\":1}}],[\"定义了例如插入数据\",{\"1\":{\"399\":1}}],[\"定义了存储的数据项及其格式\",{\"1\":{\"399\":1}}],[\"定义了一系列网络请求基本的参数\",{\"1\":{\"364\":1}}],[\"定义了一个预先设定的动作\",{\"1\":{\"79\":1}}],[\"定义了\",{\"1\":{\"79\":1}}],[\"备注\",{\"1\":{\"79\":1,\"282\":1}}],[\"按顺序调用它的代码块\",{\"1\":{\"327\":1}}],[\"按位取反\",{\"1\":{\"280\":1}}],[\"按位异或\",{\"1\":{\"280\":1}}],[\"按位或\",{\"1\":{\"280\":1}}],[\"按位与\",{\"1\":{\"280\":1}}],[\"按钮绑定事件处理器\",{\"1\":{\"79\":1}}],[\"按照这个增量对数组arr进行插入排序\",{\"1\":{\"460\":1}}],[\"按照要删除的节点子节点数目的不同\",{\"1\":{\"432\":2}}],[\"按照要求输入即可\",{\"1\":{\"347\":1}}],[\"按照访问节点的顺序不同\",{\"1\":{\"430\":1}}],[\"按照默认的主题配置选择一个就好\",{\"1\":{\"417\":1}}],[\"按照优先级不断的依次从oob\",{\"1\":{\"391\":1}}],[\"按照优先级从前到后依次是\",{\"1\":{\"109\":1}}],[\"按照jdk1\",{\"1\":{\"302\":1}}],[\"按照java文档中的定义\",{\"1\":{\"302\":1}}],[\"按照排序速度依次是冒泡排序\",{\"1\":{\"289\":1}}],[\"按照开头的公式\",{\"1\":{\"282\":1}}],[\"按照offset\",{\"1\":{\"239\":1}}],[\"按照列表的方向\",{\"1\":{\"231\":1}}],[\"按照列表反方向\",{\"1\":{\"231\":1}}],[\"按照正常创建\",{\"1\":{\"225\":1}}],[\"按照physics的规则\",{\"1\":{\"221\":1}}],[\"按照\",{\"1\":{\"212\":1,\"288\":1,\"462\":1}}],[\"按照所处位置的不同\",{\"1\":{\"212\":1}}],[\"按照所占比重\",{\"1\":{\"183\":1}}],[\"按照自定义的规则展示\",{\"1\":{\"205\":1}}],[\"按照上述的要求\",{\"1\":{\"170\":1}}],[\"按照上述分析\",{\"1\":{\"146\":1}}],[\"按照上面分析的逻辑\",{\"1\":{\"130\":1}}],[\"按照上面的分析\",{\"1\":{\"107\":1}}],[\"按照inheritedwidget的规则\",{\"1\":{\"130\":1}}],[\"按照之前的分析\",{\"1\":{\"126\":1}}],[\"按照我们上一步的分析\",{\"1\":{\"126\":1}}],[\"按照长度比例截取对应的path并赋值给dstpath\",{\"1\":{\"63\":1}}],[\"按照进度绘制贝塞尔曲线\",{\"1\":{\"63\":1}}],[\"按照贝塞尔曲线的定义\",{\"1\":{\"62\":1}}],[\"按照官方的定义\",{\"1\":{\"57\":1}}],[\"按照前述规则\",{\"1\":{\"50\":1}}],[\"向将当前顶点的所有可以访问的邻接点访问完毕\",{\"1\":{\"438\":1}}],[\"向右为1对其叶子节点上的字符赋予编码\",{\"1\":{\"432\":1}}],[\"向gityuan大神致敬\",{\"1\":{\"370\":1}}],[\"向编译器\",{\"1\":{\"298\":1}}],[\"向下遍历耗时\",{\"1\":{\"442\":1}}],[\"向下为正\",{\"1\":{\"239\":1}}],[\"向下滑动到初始位置\",{\"1\":{\"226\":1}}],[\"向下滑动inner\",{\"1\":{\"226\":1}}],[\"向下滑动\",{\"1\":{\"220\":2,\"226\":1}}],[\"向下滑动最小到初始位置\",{\"1\":{\"220\":2}}],[\"向下将这些指令转发至native层的io\",{\"1\":{\"112\":1}}],[\"向上为负\",{\"1\":{\"239\":1}}],[\"向上滑动\",{\"1\":{\"220\":2,\"226\":1}}],[\"向上滑动时\",{\"1\":{\"220\":1,\"226\":1}}],[\"向上遍历\",{\"1\":{\"127\":1}}],[\"向上承接来自dart代码的io请求指令\",{\"1\":{\"112\":1}}],[\"向native层的ioservice获取用于通信的sendport\",{\"1\":{\"115\":1}}],[\"向ioservice发送消息\",{\"1\":{\"111\":1,\"112\":1}}],[\"向\",{\"1\":{\"79\":2,\"171\":1}}],[\"向用户解释为什么需要改权限\",{\"1\":{\"69\":1}}],[\"描述类\",{\"1\":{\"298\":1}}],[\"描述参数\",{\"1\":{\"298\":1}}],[\"描述包\",{\"1\":{\"298\":1}}],[\"描述方法\",{\"1\":{\"298\":1}}],[\"描述局部变量\",{\"1\":{\"298\":1}}],[\"描述域\",{\"1\":{\"298\":1}}],[\"描述构造器\",{\"1\":{\"298\":1}}],[\"描述了\",{\"1\":{\"79\":1}}],[\"描述\",{\"1\":{\"79\":1}}],[\"里面传入了要展示的widget\",{\"1\":{\"132\":1}}],[\"里面为按钮添加监听事件\",{\"1\":{\"79\":1}}],[\"里面实现targetintent和proxy的转换\",{\"1\":{\"72\":1}}],[\"便可以开始执行\",{\"1\":{\"180\":1}}],[\"便可以根据其值修改自身属性\",{\"1\":{\"157\":1}}],[\"便可以根据此值修改\",{\"1\":{\"157\":1}}],[\"便可以自动从\",{\"1\":{\"146\":1}}],[\"便可以打包不同渠道的\",{\"1\":{\"54\":1}}],[\"便会调用该\",{\"1\":{\"79\":1}}],[\"很显然可以参照步骤1\",{\"1\":{\"459\":1}}],[\"很多时候我们用他来搭建静态博客\",{\"1\":{\"405\":1}}],[\"很多操作都能看到通过\",{\"1\":{\"111\":1}}],[\"很明显\",{\"1\":{\"85\":1}}],[\"很简单的组件却花费了不少功夫\",{\"1\":{\"79\":1}}],[\"很遗憾在此之前\",{\"1\":{\"0\":1}}],[\"译\",{\"1\":{\"78\":1,\"316\":1}}],[\"记录左节点直到没有\",{\"1\":{\"346\":1}}],[\"记录下其坐标\",{\"1\":{\"456\":1}}],[\"记录下来备用\",{\"1\":{\"56\":1}}],[\"记录下要滑动的数据\",{\"1\":{\"41\":1}}],[\"记得加上对应的端口\",{\"1\":{\"76\":1}}],[\"例子中的函数计算10000到100000的阶乘时会溢出\",{\"1\":{\"322\":1}}],[\"例\",{\"1\":{\"74\":1}}],[\"例如375\",{\"1\":{\"81\":1}}],[\"例如颜色\",{\"1\":{\"64\":1}}],[\"例如\",{\"1\":{\"3\":1,\"54\":1,\"55\":1,\"80\":1,\"82\":1,\"327\":3,\"344\":2}}],[\"篇\",{\"1\":{\"72\":1}}],[\"到叶节点或空子节点的每一条边上的黑色节点数量必须相同\",{\"1\":{\"458\":1}}],[\"到队尾\",{\"1\":{\"455\":1}}],[\"到本地即可\",{\"1\":{\"419\":1}}],[\"到各种门户网站的博客\",{\"1\":{\"408\":1}}],[\"到达某个阈值\",{\"1\":{\"396\":1}}],[\"到时候会一起分析一下\",{\"1\":{\"381\":1}}],[\"到时间后取消当日循环闹钟\",{\"1\":{\"12\":1}}],[\"到官网下载\",{\"1\":{\"348\":1}}],[\"到github的某个仓库\",{\"1\":{\"347\":1}}],[\"到此注解目的达到\",{\"1\":{\"300\":1}}],[\"到此为止\",{\"1\":{\"239\":1}}],[\"到maxscrollextent\",{\"1\":{\"226\":1}}],[\"到目前位置\",{\"1\":{\"213\":1}}],[\"到目前为止\",{\"1\":{\"84\":1,\"100\":1,\"126\":1,\"152\":1,\"195\":1,\"211\":1,\"239\":1}}],[\"到目标页面对应位置\",{\"1\":{\"181\":1}}],[\"到\",{\"1\":{\"171\":1,\"172\":1,\"173\":1,\"188\":1,\"266\":1,\"334\":1,\"418\":1}}],[\"到一起\",{\"1\":{\"85\":1}}],[\"到这里就顺利的在\",{\"1\":{\"347\":1}}],[\"到这里widget的文本方向\",{\"1\":{\"228\":1}}],[\"到这里跟center插入到render\",{\"1\":{\"126\":1}}],[\"到这里我们发现\",{\"1\":{\"116\":1}}],[\"到这里\",{\"1\":{\"72\":1,\"81\":1,\"127\":1,\"348\":2,\"413\":1}}],[\"使其成为当前顶点\",{\"1\":{\"438\":1}}],[\"使所有节点的关键值按照升序被访问\",{\"1\":{\"430\":1}}],[\"使您可以更轻松地开发出色的\",{\"1\":{\"399\":1}}],[\"使代码更加简洁\",{\"1\":{\"345\":1}}],[\"使得编译器在编译时将递归转化为迭代\",{\"1\":{\"322\":1}}],[\"使得方法使用的其他类的更改不太可能破坏这个代码\",{\"1\":{\"278\":1}}],[\"使得在\",{\"1\":{\"226\":1}}],[\"使得在statelesswidget控件中调用statefulwidget控件的setstate\",{\"1\":{\"134\":1}}],[\"使得\",{\"1\":{\"213\":1}}],[\"使得imagecache只管理已经加载完成的图片\",{\"1\":{\"198\":1}}],[\"使之看起来从一种状态渐变为另外一种状态\",{\"1\":{\"146\":1,\"157\":1}}],[\"使之启动targetintent对应的activity\",{\"1\":{\"72\":1}}],[\"使当前mainapplication继承自hasactivityinjector\",{\"1\":{\"92\":1}}],[\"使application继承自\",{\"0\":{\"92\":1}}],[\"使用前先初始化\",{\"1\":{\"467\":1}}],[\"使用下标来访问保存的元素\",{\"1\":{\"450\":1}}],[\"使用中参数的传递\",{\"1\":{\"400\":1,\"404\":1}}],[\"使用在osthread\",{\"1\":{\"391\":1}}],[\"使用已有的worker处理任务\",{\"1\":{\"390\":1}}],[\"使用全局的initialize\",{\"1\":{\"381\":1}}],[\"使用isolate\",{\"1\":{\"387\":1}}],[\"使用isolate往receiveport\",{\"1\":{\"376\":1}}],[\"使用imageprovider\",{\"1\":{\"195\":1}}],[\"使用不同\",{\"1\":{\"375\":1}}],[\"使用同一个\",{\"1\":{\"375\":1}}],[\"使用方法\",{\"0\":{\"374\":1}}],[\"使用时直接fun\",{\"1\":{\"369\":1}}],[\"使用时\",{\"1\":{\"369\":1}}],[\"使用时需要根据自己的项目更新main\",{\"0\":{\"367\":1}}],[\"使用时需要注意\",{\"1\":{\"153\":1}}],[\"使用起来更加连贯\",{\"1\":{\"362\":1}}],[\"使用起来也更加简洁\",{\"1\":{\"345\":1}}],[\"使用okhttpclient客户端创建call并执行该网络请求\",{\"1\":{\"362\":1}}],[\"使用bz2\",{\"1\":{\"357\":1}}],[\"使用build\",{\"1\":{\"40\":1}}],[\"使用命令\",{\"1\":{\"347\":5}}],[\"使用androidstudio同步工程到github\",{\"0\":{\"347\":1}}],[\"使用aidl接口生成mibinder\",{\"1\":{\"36\":1}}],[\"使用代码表示如下\",{\"1\":{\"346\":1}}],[\"使用lambda的形式如下\",{\"1\":{\"345\":1}}],[\"使用线程安全的数据结构\",{\"1\":{\"334\":1}}],[\"使用flow流在不阻塞主线程的情况下\",{\"1\":{\"327\":1}}],[\"使用父类泛型的对象可以赋值给使用子类泛型的对象\",{\"1\":{\"322\":1}}],[\"使用子类泛型的对象可以赋值给使用父类泛型的对象\",{\"1\":{\"322\":1}}],[\"使用这种方法可以加密\",{\"1\":{\"306\":1}}],[\"使用初始化之后的变量\",{\"1\":{\"301\":1}}],[\"使用了过时的类或方法时的警告\",{\"1\":{\"298\":1}}],[\"使用了自己的\",{\"1\":{\"223\":1}}],[\"使用注解\",{\"0\":{\"301\":1},\"1\":{\"298\":1,\"301\":1}}],[\"使用threadlocal时会发生内存泄漏的前提条件\",{\"1\":{\"288\":1}}],[\"使用系统\",{\"1\":{\"274\":1}}],[\"使用简单\",{\"1\":{\"242\":1}}],[\"使用新的paintoffset绘制child\",{\"1\":{\"239\":1}}],[\"使用我们创建好的slivers填充viewport\",{\"1\":{\"227\":1}}],[\"使用的是绝对路径\",{\"1\":{\"417\":1}}],[\"使用的是box\",{\"1\":{\"240\":1}}],[\"使用的\",{\"1\":{\"217\":1}}],[\"使用的应该也是此原理\",{\"1\":{\"54\":1}}],[\"使用hashmap移除数据时\",{\"1\":{\"280\":1}}],[\"使用hashmap获取数据时\",{\"1\":{\"280\":1}}],[\"使用hashmap保存数据时\",{\"1\":{\"280\":1}}],[\"使用hash\",{\"1\":{\"280\":1}}],[\"使用handler发送消息\",{\"1\":{\"43\":1}}],[\"使用handler发送有序消息队列\",{\"1\":{\"43\":1}}],[\"使用headersliverbuilder提供\",{\"1\":{\"212\":1}}],[\"使用glide加载图片drawable\",{\"1\":{\"211\":1}}],[\"使用返回的图片信息\",{\"1\":{\"211\":1}}],[\"使用powerimageloader\",{\"1\":{\"211\":2}}],[\"使用指定的uint8list创建ui\",{\"1\":{\"210\":1}}],[\"使用于混合项目的图片加载库\",{\"1\":{\"198\":1}}],[\"使用获得的imageinfo更新rawimage\",{\"1\":{\"191\":1}}],[\"使用默认的shuttlebuilder\",{\"1\":{\"180\":1}}],[\"使用者可以从父类\",{\"1\":{\"168\":1}}],[\"使用者可以通过\",{\"1\":{\"168\":1}}],[\"使用者可以用它来控制\",{\"1\":{\"160\":1}}],[\"使用者需要负责创建\",{\"1\":{\"156\":1}}],[\"使用者不可以直接控制动画\",{\"1\":{\"156\":1}}],[\"使用者实现builder创建对应的widget\",{\"1\":{\"153\":1}}],[\"使用者只能设置\",{\"1\":{\"147\":1}}],[\"使用传入的\",{\"1\":{\"151\":1}}],[\"使用各种内置的\",{\"1\":{\"146\":1,\"157\":1}}],[\"使用navigator和routes实现在同一个\",{\"1\":{\"135\":1}}],[\"使用或未使用到inheritedwidget\",{\"1\":{\"130\":1}}],[\"使用dart语言\",{\"1\":{\"132\":1}}],[\"使用dart\",{\"1\":{\"114\":2}}],[\"使用serialversionuid标记当前serializable的版本\",{\"1\":{\"304\":1}}],[\"使用service的实例service\",{\"1\":{\"82\":1}}],[\"使用sparsearray和arraymap代替hashmap\",{\"1\":{\"287\":1}}],[\"使用sqflite\",{\"1\":{\"198\":1}}],[\"使用style\",{\"1\":{\"66\":1}}],[\"使用只需要两个步骤即可\",{\"1\":{\"81\":1}}],[\"使用详解\",{\"1\":{\"78\":1}}],[\"使用xfermode正确的绘制出遮罩效果\",{\"1\":{\"65\":1}}],[\"使用以下方式则可以正常获取view的宽高\",{\"1\":{\"65\":1}}],[\"使用createwithinexistingisolategroup创建isolate\",{\"1\":{\"381\":1}}],[\"使用curveanimation计算当前对应的padding值\",{\"1\":{\"152\":1}}],[\"使用completers记录下刚刚发起的请求\",{\"1\":{\"211\":1}}],[\"使用completer通过event\",{\"1\":{\"116\":1}}],[\"使用coordinatorlayout打造一个炫酷的详情页\",{\"1\":{\"55\":1}}],[\"使用canvas绘制坐标时\",{\"1\":{\"63\":1}}],[\"使用最佳匹配算法从缓存池中找到一块大小合适的空间\",{\"1\":{\"58\":1}}],[\"使用透明部分的像素与已有图形对应位置交叉作用\",{\"1\":{\"57\":1}}],[\"使用自定义属性\",{\"1\":{\"56\":1}}],[\"使用到的类有\",{\"1\":{\"55\":1}}],[\"使用场景难免有些受限\",{\"1\":{\"54\":1}}],[\"使用\",{\"1\":{\"54\":1,\"81\":2,\"105\":1,\"112\":1,\"146\":1,\"149\":1,\"157\":1,\"159\":1,\"164\":1,\"184\":2,\"188\":1,\"197\":1,\"207\":1,\"211\":1,\"238\":1,\"321\":1,\"322\":1,\"327\":2,\"356\":1,\"361\":1,\"408\":1}}],[\"使用服务端的messenger向服务端发送消息\",{\"1\":{\"43\":1}}],[\"使用该关键字时\",{\"1\":{\"43\":1}}],[\"使用提供的方法绑定服务\",{\"1\":{\"19\":1}}],[\"使用rtc\",{\"1\":{\"5\":1}}],[\"使用elapsed\",{\"1\":{\"5\":1}}],[\"欺骗系统对activity是否已注册的验证\",{\"1\":{\"72\":1}}],[\"欺骗系统调起activity的过程\",{\"1\":{\"70\":1}}],[\"正式的iso定义\",{\"1\":{\"302\":1}}],[\"正式启动activity时\",{\"1\":{\"70\":1}}],[\"正如上面分析的\",{\"1\":{\"240\":1}}],[\"正如之前所言\",{\"1\":{\"235\":1}}],[\"正如我们之前所说\",{\"1\":{\"235\":1}}],[\"正常联动\",{\"1\":{\"226\":1}}],[\"正常使用\",{\"1\":{\"211\":1}}],[\"正负\",{\"1\":{\"220\":1}}],[\"正在使用的图片\",{\"1\":{\"197\":1}}],[\"正在加载中的图片\",{\"1\":{\"197\":1}}],[\"正确配置\",{\"1\":{\"54\":1}}],[\"警告⚠️\",{\"1\":{\"69\":1}}],[\"申请权限的结果在onrequestpermissionsresult\",{\"1\":{\"68\":1}}],[\"第n个数\",{\"1\":{\"459\":1}}],[\"第n项\",{\"1\":{\"459\":1}}],[\"第n\",{\"1\":{\"459\":3}}],[\"第四步\",{\"1\":{\"347\":1}}],[\"第四级richtext下面再分析\",{\"1\":{\"126\":1}}],[\"第三方包\",{\"1\":{\"371\":1}}],[\"第三方类即是如此\",{\"1\":{\"85\":1}}],[\"第三步\",{\"1\":{\"347\":2}}],[\"第01周有几个相互等效且兼容的描述\",{\"1\":{\"302\":1}}],[\"第4版\",{\"1\":{\"293\":1}}],[\"第二版\",{\"1\":{\"444\":1,\"451\":1}}],[\"第二个本地hexo项目\",{\"1\":{\"407\":1}}],[\"第二个参数unshared是false\",{\"1\":{\"309\":1}}],[\"第二步\",{\"1\":{\"347\":2}}],[\"第二种表示形式\",{\"1\":{\"289\":1}}],[\"第二种是传递信息\",{\"1\":{\"137\":1}}],[\"第二次序列化\",{\"1\":{\"309\":1}}],[\"第二次做的修改在序列化的时候并没有保存\",{\"1\":{\"309\":1}}],[\"第二次标记\",{\"1\":{\"266\":1}}],[\"第二次请求时为true\",{\"1\":{\"69\":1}}],[\"第二次申请时返回true\",{\"1\":{\"68\":1}}],[\"第一天\",{\"1\":{\"417\":1}}],[\"第一步\",{\"1\":{\"347\":2}}],[\"第一个本地hexo项目\",{\"1\":{\"407\":1}}],[\"第一个为根节点\",{\"1\":{\"346\":1}}],[\"第一个异常赢得了胜利\",{\"1\":{\"329\":1}}],[\"第一个点p0的前一个仍然为p0\",{\"1\":{\"62\":1}}],[\"第一次进入会要求输入\",{\"1\":{\"347\":1}}],[\"第一次调用立马返回unit\",{\"1\":{\"328\":1}}],[\"第一次读的时候是1\",{\"1\":{\"327\":1}}],[\"第一次序列化\",{\"1\":{\"309\":1}}],[\"第一次标记\",{\"1\":{\"266\":1}}],[\"第一次插入\",{\"1\":{\"150\":1}}],[\"第一次请求时为false\",{\"1\":{\"69\":1}}],[\"第一种是调用方法\",{\"1\":{\"137\":1}}],[\"第一种\",{\"1\":{\"2\":1}}],[\"填充布局\",{\"1\":{\"66\":1}}],[\"模拟解密\",{\"1\":{\"306\":1}}],[\"模拟加密\",{\"1\":{\"306\":1}}],[\"模拟器访问localhost会默认访问手机的本地网址\",{\"1\":{\"76\":1}}],[\"模式下检查确保\",{\"1\":{\"228\":1}}],[\"模式展示图片\",{\"1\":{\"205\":2}}],[\"模糊\",{\"1\":{\"66\":1}}],[\"模块\",{\"1\":{\"54\":1}}],[\"半透明\",{\"1\":{\"66\":1}}],[\"背景透明\",{\"1\":{\"66\":1}}],[\"持有的\",{\"1\":{\"229\":1}}],[\"持有\",{\"1\":{\"211\":1}}],[\"持有binder对象\",{\"1\":{\"40\":1}}],[\"持续时间ms\",{\"1\":{\"66\":1}}],[\"默认要插入的点是有序的\",{\"1\":{\"457\":1}}],[\"默认生成\",{\"1\":{\"417\":1}}],[\"默认执行时直接从kernel\",{\"1\":{\"394\":1}}],[\"默认值必须不可变\",{\"1\":{\"369\":1}}],[\"默认参数必须是参数中后面的几位\",{\"1\":{\"369\":1}}],[\"默认参数\",{\"1\":{\"369\":1}}],[\"默认返回none\",{\"1\":{\"369\":1}}],[\"默认第一列\",{\"1\":{\"361\":1}}],[\"默认以第一列排序\",{\"1\":{\"361\":1}}],[\"默认64\",{\"1\":{\"280\":1}}],[\"默认容量为16\",{\"1\":{\"280\":1}}],[\"默认0\",{\"1\":{\"280\":1}}],[\"默认主轴尺寸尽可能的小\",{\"1\":{\"241\":1}}],[\"默认创建的\",{\"1\":{\"223\":1}}],[\"默认会创建\",{\"1\":{\"213\":1}}],[\"默认的皮肤\",{\"1\":{\"415\":1}}],[\"默认的初始化方法\",{\"1\":{\"369\":1}}],[\"默认的负载因子0\",{\"1\":{\"280\":1}}],[\"默认的\",{\"1\":{\"211\":1}}],[\"默认的是0\",{\"1\":{\"74\":1}}],[\"默认提供了image用于从网络\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"默认线性的在\",{\"1\":{\"184\":1}}],[\"默认是tab\",{\"1\":{\"361\":1}}],[\"默认是tohero\",{\"1\":{\"181\":1}}],[\"默认是按照当前的进度线性计算返回的值\",{\"1\":{\"184\":1}}],[\"默认是用相同大小的sizebox占位\",{\"1\":{\"176\":1}}],[\"默认是使用\",{\"1\":{\"174\":1}}],[\"默认使用\",{\"1\":{\"174\":1}}],[\"默认\",{\"1\":{\"174\":1,\"230\":1}}],[\"默认实现的\",{\"1\":{\"172\":1}}],[\"默认标记动画为\",{\"1\":{\"164\":1}}],[\"默认分别为\",{\"1\":{\"161\":2}}],[\"默认构造方法\",{\"1\":{\"161\":1}}],[\"默认没有动画\",{\"1\":{\"147\":1}}],[\"默认情况下\",{\"1\":{\"131\":1,\"143\":1}}],[\"默认情况下他使用的fit模式是flexfit\",{\"1\":{\"131\":1}}],[\"默认启用\",{\"1\":{\"65\":1}}],[\"默认为黑色\",{\"1\":{\"458\":1}}],[\"默认为所有数组的父类\",{\"1\":{\"291\":1}}],[\"默认为空\",{\"1\":{\"223\":1}}],[\"默认为\",{\"1\":{\"166\":1}}],[\"默认为0\",{\"1\":{\"41\":1,\"280\":1}}],[\"默认为主线程\",{\"1\":{\"36\":1}}],[\"被认为是完全动态的\",{\"1\":{\"395\":1}}],[\"被限制并封装到该协程中的状态以及一个与其它协程通信的\",{\"1\":{\"334\":1}}],[\"被重置为上一个通过ascontextelement\",{\"1\":{\"325\":1}}],[\"被重新创建时\",{\"1\":{\"150\":1}}],[\"被编译器丢弃\",{\"1\":{\"298\":1}}],[\"被应用\",{\"1\":{\"220\":1}}],[\"被移除\",{\"1\":{\"171\":1}}],[\"被其持有\",{\"1\":{\"153\":1}}],[\"被flutter框架引起的异常\",{\"1\":{\"144\":1}}],[\"被调用过\",{\"1\":{\"106\":1}}],[\"被调用后一直无返回值时\",{\"1\":{\"17\":1}}],[\"被调用后\",{\"1\":{\"13\":1}}],[\"被我们当做设计稿中控件大小与设备中控件dp大小之间的缩放系数\",{\"1\":{\"81\":1}}],[\"被执行时view已经初始化好了\",{\"1\":{\"65\":1}}],[\"普通消息\",{\"1\":{\"376\":1}}],[\"普通用户需要验证权限\",{\"1\":{\"351\":1}}],[\"普通写法\",{\"1\":{\"345\":1}}],[\"普通的取消\",{\"1\":{\"330\":1}}],[\"普通的同步方法\",{\"1\":{\"109\":1}}],[\"普通递归和尾递归都存在栈溢出风险\",{\"1\":{\"322\":1}}],[\"普通递归\",{\"1\":{\"322\":1}}],[\"普通变量则需要等线程操作完毕\",{\"1\":{\"317\":1}}],[\"普通图片\",{\"1\":{\"211\":1}}],[\"普通开发者不可见\",{\"1\":{\"80\":1}}],[\"普通view是父容器的measurespec\",{\"1\":{\"65\":1}}],[\"普通文件映射就是将一个文件与一块内存建立起映射关系\",{\"1\":{\"58\":1}}],[\"父红\",{\"1\":{\"458\":2}}],[\"父节点为红色\",{\"1\":{\"458\":1}}],[\"父节点关键字大于该点\",{\"1\":{\"440\":1}}],[\"父节点\",{\"1\":{\"439\":1}}],[\"父节点频次为两个子节点之和\",{\"1\":{\"432\":1}}],[\"父协程被取消的时候\",{\"1\":{\"322\":1}}],[\"父类出参为any\",{\"1\":{\"322\":1}}],[\"父类入参为noting\",{\"1\":{\"322\":1}}],[\"父类的变量值\",{\"1\":{\"307\":1}}],[\"父类的clinit\",{\"1\":{\"279\":1}}],[\"父类未继承serializable的类的序列化\",{\"0\":{\"307\":1}}],[\"父类指定了view的具体大小\",{\"1\":{\"65\":1}}],[\"父加载器没有找到\",{\"1\":{\"272\":1}}],[\"父加载器为空则调用bootstrap\",{\"1\":{\"272\":1}}],[\"父加载器不为空则调用父加载器的loadclass\",{\"1\":{\"272\":1}}],[\"父级空间不足时可以滚动\",{\"1\":{\"241\":1}}],[\"父容器没有限定view大小\",{\"1\":{\"65\":1}}],[\"依然要遵循以上三种遍历的先后顺序\",{\"1\":{\"346\":1}}],[\"依次插入6\",{\"1\":{\"458\":1}}],[\"依次查找\",{\"1\":{\"440\":1}}],[\"依次遍历x\",{\"1\":{\"462\":1}}],[\"依次遍历\",{\"1\":{\"438\":1}}],[\"依次遍历inner\",{\"1\":{\"225\":1}}],[\"依次推出有向图中没有后继点的顶点作为排序的最后项\",{\"1\":{\"438\":1}}],[\"依次沿着顶点某一个邻接点\",{\"1\":{\"437\":1}}],[\"依次循环直到优先级队列中只有一个节点\",{\"1\":{\"432\":1}}],[\"依次\",{\"1\":{\"432\":1}}],[\"依次从左端数组取出元素比较\",{\"1\":{\"457\":1}}],[\"依次从oob\",{\"1\":{\"391\":1}}],[\"依次从1\",{\"1\":{\"272\":1}}],[\"依次调用resume即可\",{\"1\":{\"375\":1}}],[\"依次调用performxxx\",{\"1\":{\"65\":1}}],[\"依次展平流\",{\"1\":{\"340\":1}}],[\"依次执行内部代码\",{\"1\":{\"323\":1}}],[\"依次类推\",{\"1\":{\"289\":1,\"458\":1}}],[\"依次进行比较\",{\"1\":{\"289\":1}}],[\"依次协调\",{\"1\":{\"226\":1}}],[\"依旧是\",{\"1\":{\"173\":1}}],[\"依旧会阻塞其他方法的执行\",{\"1\":{\"95\":1}}],[\"依赖于原生图片加载库\",{\"1\":{\"198\":1}}],[\"依赖\",{\"1\":{\"82\":1}}],[\"依赖注入\",{\"1\":{\"82\":1,\"87\":1}}],[\"依赖方会通过\",{\"1\":{\"55\":1}}],[\"绘制到\",{\"1\":{\"211\":1}}],[\"绘制自定义效果等功能\",{\"1\":{\"199\":1}}],[\"绘制自身\",{\"1\":{\"65\":1}}],[\"绘制与inheritedwidget解析\",{\"0\":{\"128\":1}}],[\"绘制装饰\",{\"1\":{\"65\":1}}],[\"绘制children\",{\"1\":{\"65\":1}}],[\"绘制背景\",{\"1\":{\"65\":1}}],[\"绘制过程分为以下几步\",{\"1\":{\"65\":1}}],[\"绘制\",{\"1\":{\"65\":1,\"95\":1,\"195\":1}}],[\"绘制对应的path\",{\"1\":{\"63\":1}}],[\"决定了算法的速度\",{\"1\":{\"467\":1}}],[\"决定了view的具体显示内容\",{\"1\":{\"65\":1}}],[\"决定了view的测量宽\",{\"1\":{\"65\":1}}],[\"决定任务一次性还是重复的\",{\"1\":{\"404\":1}}],[\"决定view的四个顶点坐标和实际的宽\",{\"1\":{\"65\":1}}],[\"几个相互邻接的顶点组成的线叫做路径\",{\"1\":{\"433\":1}}],[\"几\",{\"1\":{\"328\":1}}],[\"几乎相差8倍\",{\"1\":{\"287\":1}}],[\"几乎所有的方法都是后期绑定的\",{\"1\":{\"273\":1}}],[\"几乎所有情况下都等同于view的最终宽\",{\"1\":{\"65\":1}}],[\"几秒钟\",{\"1\":{\"5\":1}}],[\"高级排序\",{\"0\":{\"460\":1}}],[\"高级系统设置\",{\"1\":{\"412\":1}}],[\"高的测量值\",{\"1\":{\"65\":1}}],[\"高2位表示specmode\",{\"1\":{\"65\":1}}],[\"高\",{\"1\":{\"65\":4}}],[\"高对应的总dp数不一定都是相同的\",{\"1\":{\"53\":1}}],[\"源代码已经上传github\",{\"1\":{\"368\":1}}],[\"源代码在我的github\",{\"1\":{\"64\":1}}],[\"源文件路径等有不存在路径时的警告\",{\"1\":{\"298\":1}}],[\"源码github链接\",{\"1\":{\"296\":1}}],[\"源码中表示具体的值\",{\"1\":{\"254\":1}}],[\"源码及使用见github\",{\"1\":{\"57\":1}}],[\"源码\",{\"1\":{\"52\":3,\"55\":1}}],[\"该节点是叶节点\",{\"1\":{\"441\":1}}],[\"该图的所有生成树都是最小生成树\",{\"1\":{\"438\":1}}],[\"该数组中不直接保存数据\",{\"1\":{\"428\":1}}],[\"该isolate的mutator\",{\"1\":{\"392\":1}}],[\"该对象还没有构造完毕\",{\"1\":{\"317\":1}}],[\"该对象在方法区中\",{\"1\":{\"274\":1}}],[\"该值会在类发生改变时变化\",{\"1\":{\"304\":1}}],[\"该线程可以再次回到锁池竞争该对象的锁\",{\"1\":{\"297\":1}}],[\"该变量是一个定制的hash\",{\"1\":{\"288\":1}}],[\"该接口只有一个方法\",{\"1\":{\"92\":1}}],[\"该runnable在view的消息队列尾部\",{\"1\":{\"65\":1}}],[\"该类用来画出字母导航栏\",{\"1\":{\"64\":1}}],[\"该方法所有可以做的工作\",{\"1\":{\"266\":1}}],[\"该方法\",{\"1\":{\"266\":1}}],[\"该方法失效\",{\"1\":{\"72\":1}}],[\"该方法是用来从前台删除服务\",{\"1\":{\"21\":1}}],[\"该方法的作用是把当前服务设置为前台服务\",{\"1\":{\"21\":1}}],[\"故而采用另一种办法手动同步网站\",{\"1\":{\"418\":1}}],[\"故而文件结构如下\",{\"1\":{\"371\":1}}],[\"故而虽然volatile修饰的变量在所有线程可见\",{\"1\":{\"317\":1}}],[\"故而会调用bootstrap\",{\"1\":{\"272\":1}}],[\"故而面对大量高清大图加载的场景\",{\"1\":{\"198\":1}}],[\"故而也\",{\"1\":{\"198\":1}}],[\"故而\",{\"1\":{\"173\":2}}],[\"故而在其内部自定义了一个继承自itemdecoratio得静态内部类decorationn类\",{\"1\":{\"64\":1}}],[\"故而大多数软件多渠道打包配置如下\",{\"1\":{\"54\":1}}],[\"联系人列表滑动时\",{\"1\":{\"64\":1}}],[\"联系人列表有两个要点\",{\"1\":{\"64\":1}}],[\"点这里查看\",{\"1\":{\"371\":1}}],[\"点这里可以找到\",{\"1\":{\"64\":1}}],[\"点击事件\",{\"0\":{\"140\":1},\"1\":{\"109\":1}}],[\"点击事件发生后\",{\"1\":{\"13\":1}}],[\"点击确认开始赋予权限\",{\"1\":{\"69\":1}}],[\"点\",{\"1\":{\"63\":1}}],[\"点的贝塞尔曲线时\",{\"1\":{\"63\":1}}],[\"动态支持时\",{\"1\":{\"279\":1}}],[\"动态绑定\",{\"1\":{\"273\":1}}],[\"动态链接将符号引用\",{\"1\":{\"278\":1}}],[\"动态链接\",{\"1\":{\"252\":1}}],[\"动态计算\",{\"1\":{\"225\":1}}],[\"动态调整数组的大小\",{\"1\":{\"49\":1}}],[\"动图\",{\"1\":{\"211\":1}}],[\"动图示意如下\",{\"1\":{\"61\":1}}],[\"动画组件\",{\"1\":{\"181\":1}}],[\"动画实际播放的过渡动画内容\",{\"1\":{\"181\":1}}],[\"动画后状态的变化而更改\",{\"1\":{\"176\":1}}],[\"动画开始\",{\"1\":{\"174\":1}}],[\"动画将要结束时\",{\"1\":{\"173\":1}}],[\"动画播放的时候在圆和正方形之间切换\",{\"1\":{\"172\":1}}],[\"动画播放完毕之后\",{\"1\":{\"171\":1}}],[\"动画之上做了一层由\",{\"1\":{\"172\":1}}],[\"动画\",{\"1\":{\"172\":1,\"176\":1,\"178\":2,\"180\":1,\"181\":1}}],[\"动画只支持大小和位移变化\",{\"1\":{\"172\":1}}],[\"动画执行的解释\",{\"1\":{\"171\":1}}],[\"动画正在运行中\",{\"1\":{\"171\":1}}],[\"动画正向\",{\"1\":{\"161\":1}}],[\"动画框架读取要跳转去的\",{\"1\":{\"171\":1}}],[\"动画框架会先隐藏\",{\"1\":{\"171\":1}}],[\"动画是基于\",{\"1\":{\"181\":1}}],[\"动画是如何实现这个效果的呢\",{\"1\":{\"171\":1}}],[\"动画是指可以在切换页面时自动跨页面实现\",{\"1\":{\"169\":1}}],[\"动画作用于\",{\"1\":{\"170\":1}}],[\"动画默认只支持大小\",{\"1\":{\"170\":1}}],[\"动画不会生效\",{\"1\":{\"170\":1}}],[\"动画的过渡组件动画渐变的方式\",{\"1\":{\"174\":1}}],[\"动画的变化而变化\",{\"1\":{\"173\":1}}],[\"动画的进度和方向\",{\"1\":{\"172\":1}}],[\"动画的简单使用代码基础上进行修改\",{\"1\":{\"172\":1}}],[\"动画的\",{\"1\":{\"170\":1}}],[\"动画的使用比较简单\",{\"1\":{\"170\":1}}],[\"动画的开始结束动都由这些\",{\"1\":{\"154\":1}}],[\"动画中\",{\"1\":{\"168\":1,\"171\":1}}],[\"动画中也起到很重要的作用\",{\"1\":{\"165\":1}}],[\"动画被标记为\",{\"1\":{\"164\":1}}],[\"动画相关的\",{\"1\":{\"157\":1}}],[\"动画效果介绍\",{\"1\":{\"156\":1,\"168\":1}}],[\"动画都是类似实现\",{\"1\":{\"152\":1}}],[\"动画主要限定在\",{\"1\":{\"146\":1,\"157\":1}}],[\"三数据项取中\",{\"1\":{\"466\":1,\"467\":1}}],[\"三角数\",{\"1\":{\"459\":1}}],[\"三种运算\",{\"1\":{\"184\":1}}],[\"三\",{\"1\":{\"119\":1,\"282\":1}}],[\"三阶贝塞尔曲线\",{\"1\":{\"61\":2}}],[\"三个\",{\"1\":{\"41\":1}}],[\"贝塞尔曲线是用节点和控制点绘制的高精度曲线\",{\"1\":{\"61\":1}}],[\"扼要内容如图\",{\"1\":{\"60\":1}}],[\"桌面app\",{\"1\":{\"60\":1}}],[\"驱动此隐式动画的animation\",{\"1\":{\"147\":1}}],[\"驱动等等\",{\"1\":{\"60\":1}}],[\"驱动会根据发送数据包的大小\",{\"1\":{\"58\":1}}],[\"袁辉辉博客\",{\"1\":{\"60\":1,\"279\":1}}],[\"说明有环\",{\"1\":{\"438\":1}}],[\"说明注解存活的生命周期\",{\"1\":{\"298\":1}}],[\"说明注解所能修饰的范围\",{\"1\":{\"298\":1}}],[\"说明\",{\"1\":{\"60\":1,\"159\":1,\"370\":1}}],[\"说明它就是我们所需要的dependency\",{\"1\":{\"55\":1}}],[\"秘密\",{\"1\":{\"58\":1}}],[\"理论和实践\",{\"1\":{\"293\":1}}],[\"理论上的binder逻辑\",{\"1\":{\"58\":1}}],[\"理顺了才写\",{\"1\":{\"0\":1}}],[\"捕获处理\",{\"1\":{\"58\":1}}],[\"效率\",{\"0\":{\"449\":1}}],[\"效率会变得很差\",{\"1\":{\"428\":1}}],[\"效率最高的ipc\",{\"1\":{\"58\":1}}],[\"效果的\",{\"1\":{\"226\":1}}],[\"效果\",{\"1\":{\"212\":1,\"227\":1}}],[\"效果和expanded一致\",{\"1\":{\"131\":1}}],[\"效果预览\",{\"1\":{\"56\":1}}],[\"效果不错\",{\"1\":{\"56\":1}}],[\"缓冲发射项\",{\"1\":{\"344\":1}}],[\"缓冲允许发送者在被挂起前发送多个元素\",{\"1\":{\"328\":1}}],[\"缓冲区大小\",{\"1\":{\"328\":1}}],[\"缓冲小\",{\"1\":{\"58\":1}}],[\"缓存区已满或不存在时调用方会被挂起\",{\"1\":{\"328\":1}}],[\"缓存区大小比较有限\",{\"1\":{\"58\":1}}],[\"缓存的功能\",{\"1\":{\"202\":1}}],[\"缓存的图片状态\",{\"1\":{\"197\":1}}],[\"缓存的图片\",{\"1\":{\"197\":1}}],[\"缓存\",{\"1\":{\"202\":2}}],[\"缓存imagecache\",{\"1\":{\"202\":1}}],[\"缓存图片原始数据\",{\"1\":{\"202\":1}}],[\"缓存不存在或者读取失败\",{\"1\":{\"201\":1}}],[\"缓存网络图片\",{\"1\":{\"199\":1}}],[\"缓存有关的类\",{\"1\":{\"197\":1}}],[\"杀死某个进程等\",{\"1\":{\"58\":1}}],[\"常规的作业和监督作业之间的另一个重要区别是异常处理\",{\"1\":{\"333\":1}}],[\"常用数组实现\",{\"1\":{\"439\":1}}],[\"常用\",{\"1\":{\"355\":1,\"417\":1}}],[\"常用的可执行文件\",{\"1\":{\"349\":1}}],[\"常用的存储键值对的数据结构是hashmap\",{\"1\":{\"44\":1}}],[\"常用作服务器缓存\",{\"1\":{\"269\":1}}],[\"常量等等\",{\"1\":{\"383\":1}}],[\"常量池中的所有字面量几乎都是通过constant\",{\"1\":{\"283\":1}}],[\"常量\",{\"1\":{\"254\":1,\"369\":1}}],[\"常见的有\",{\"1\":{\"227\":1}}],[\"常见的有singlechildscrollview\",{\"1\":{\"212\":1,\"234\":1}}],[\"常见的用法是传入animationcontroller\",{\"1\":{\"185\":1}}],[\"常作为一种锁机制\",{\"1\":{\"58\":1}}],[\"信号是进程间通信中唯一的异步通信机制\",{\"1\":{\"58\":1}}],[\"信号变量\",{\"1\":{\"58\":1}}],[\"信号\",{\"1\":{\"58\":2}}],[\"信号量是为了保护进程共享资源在同一时刻只能被一个进程访问\",{\"1\":{\"58\":1}}],[\"信号量\",{\"1\":{\"58\":2}}],[\"信息\",{\"1\":{\"282\":1}}],[\"信息复制两次\",{\"1\":{\"58\":1}}],[\"信息了\",{\"1\":{\"54\":1}}],[\"传输\",{\"1\":{\"303\":1}}],[\"传输效率低\",{\"1\":{\"58\":2}}],[\"传递给\",{\"1\":{\"181\":1}}],[\"传递给serviceport后\",{\"1\":{\"112\":1}}],[\"传入\",{\"1\":{\"194\":1}}],[\"传入到自定义的\",{\"1\":{\"213\":1}}],[\"传入到\",{\"1\":{\"153\":2}}],[\"传入的是classloader\",{\"1\":{\"313\":1}}],[\"传入的是\",{\"1\":{\"226\":1}}],[\"传入的\",{\"1\":{\"80\":1}}],[\"传入参数开始执行\",{\"1\":{\"80\":1}}],[\"传回客户端\",{\"1\":{\"40\":1}}],[\"套接字socket\",{\"1\":{\"58\":1}}],[\"套接字\",{\"1\":{\"58\":1}}],[\"额外的cpu消耗\",{\"1\":{\"58\":1}}],[\"函数体跟在一个\",{\"1\":{\"345\":1}}],[\"函数将buffer\",{\"1\":{\"327\":1}}],[\"函数\",{\"1\":{\"58\":1,\"345\":1}}],[\"映射到相应的一组连续的物理页面\",{\"1\":{\"58\":1}}],[\"堆栈\",{\"1\":{\"453\":1}}],[\"堆排序和快速排序时间复杂度都是\",{\"1\":{\"442\":1}}],[\"堆排序\",{\"0\":{\"442\":1},\"1\":{\"445\":1,\"449\":3}}],[\"堆可以进行插入\",{\"1\":{\"439\":1}}],[\"堆是完全二叉树\",{\"1\":{\"439\":1}}],[\"堆是一种特殊的二叉树\",{\"1\":{\"439\":1}}],[\"堆\",{\"0\":{\"439\":1},\"1\":{\"58\":1,\"250\":1,\"445\":1}}],[\"非叶子节点\",{\"1\":{\"441\":1}}],[\"非受限\",{\"1\":{\"324\":1}}],[\"非局部返回\",{\"1\":{\"322\":1}}],[\"非阻塞同步\",{\"0\":{\"319\":1}}],[\"非静态\",{\"1\":{\"282\":1}}],[\"非引用类\",{\"1\":{\"274\":1}}],[\"非数组类\",{\"1\":{\"274\":1}}],[\"非heap区\",{\"1\":{\"249\":1}}],[\"非\",{\"1\":{\"185\":1}}],[\"非商业转载请注明出处\",{\"1\":{\"58\":1,\"137\":1}}],[\"非必须\",{\"1\":{\"54\":1,\"66\":1}}],[\"商业转载请联系作者获得授权\",{\"1\":{\"58\":1,\"137\":1}}],[\"著作权归作者所有\",{\"1\":{\"58\":1,\"137\":1}}],[\"掘金\",{\"1\":{\"58\":1,\"109\":2,\"137\":1}}],[\"共有\",{\"1\":{\"158\":1}}],[\"共享同一份代码\",{\"1\":{\"381\":1}}],[\"共享数据值存在于同一个线程中\",{\"1\":{\"320\":1}}],[\"共享缓冲区直接付附加到进程虚拟地址空间\",{\"1\":{\"58\":1}}],[\"共享内存空间\",{\"1\":{\"60\":1}}],[\"共享内存\",{\"1\":{\"58\":2}}],[\"共享内存和\",{\"1\":{\"58\":1}}],[\"共享库以及栈\",{\"1\":{\"58\":1}}],[\"共18个\",{\"1\":{\"57\":1}}],[\"含义\",{\"1\":{\"57\":1,\"298\":1}}],[\"才获取该单例\",{\"1\":{\"294\":1}}],[\"才能继续访问\",{\"1\":{\"294\":1}}],[\"才能识别手势并处理\",{\"1\":{\"223\":1}}],[\"才能实现绑定效果\",{\"1\":{\"55\":1}}],[\"才会退出\",{\"1\":{\"323\":1}}],[\"才会进行初始化\",{\"1\":{\"294\":1}}],[\"才会去执行future等普通的event\",{\"1\":{\"95\":1}}],[\"才会出现下述效果\",{\"1\":{\"57\":1}}],[\"重复步骤2\",{\"1\":{\"459\":1}}],[\"重复步骤1\",{\"1\":{\"451\":1,\"467\":1}}],[\"重复1\",{\"1\":{\"438\":1,\"455\":1}}],[\"重复闹钟具有以下特征\",{\"1\":{\"3\":1}}],[\"重点修改script\",{\"1\":{\"407\":1}}],[\"重建二叉树\",{\"0\":{\"346\":1},\"1\":{\"346\":1}}],[\"重入锁\",{\"1\":{\"318\":1}}],[\"重新绘制child\",{\"1\":{\"239\":1}}],[\"重新下载\",{\"1\":{\"198\":1}}],[\"重新创建新的\",{\"1\":{\"164\":1}}],[\"重新\",{\"1\":{\"156\":1}}],[\"重新执行state的build\",{\"1\":{\"128\":1}}],[\"重要\",{\"1\":{\"138\":1}}],[\"重要性\",{\"1\":{\"74\":1}}],[\"重写父类方法\",{\"1\":{\"298\":1}}],[\"重写findclass\",{\"1\":{\"272\":1}}],[\"重写\",{\"1\":{\"208\":1}}],[\"重写了父类的\",{\"1\":{\"186\":1}}],[\"重写对应方法\",{\"1\":{\"80\":1}}],[\"重写ondraw\",{\"1\":{\"64\":1}}],[\"重写该类主要是为了实现itemdecoration根据不同的item变化\",{\"1\":{\"64\":1}}],[\"重合部分\",{\"1\":{\"57\":1}}],[\"硬件加速\",{\"1\":{\"57\":2}}],[\"硬件加速的本质是把一部分cpu计算的工作量交给gpu完成\",{\"1\":{\"57\":1}}],[\"宽高\",{\"1\":{\"57\":1,\"211\":1}}],[\"宽度rdp\",{\"1\":{\"81\":1}}],[\"宽度wpx\",{\"1\":{\"81\":1}}],[\"宽度等\",{\"1\":{\"79\":1}}],[\"宽度是物理条件无法更改\",{\"1\":{\"53\":1}}],[\"宽度为\",{\"1\":{\"53\":2}}],[\"宽度\",{\"1\":{\"53\":4,\"81\":2}}],[\"给新增的变量默认值\",{\"1\":{\"304\":1}}],[\"给\",{\"1\":{\"212\":2}}],[\"给另一个对象提供依赖的技术\",{\"1\":{\"82\":1}}],[\"给服务端发消息\",{\"1\":{\"58\":1}}],[\"给服务发消息\",{\"1\":{\"20\":1}}],[\"给控件组内部控件添加点击事件监听\",{\"1\":{\"56\":1}}],[\"更详细的教程可以参考这里\",{\"1\":{\"412\":1}}],[\"更适用于\",{\"1\":{\"211\":1}}],[\"更适用于进程中断控制\",{\"1\":{\"58\":1}}],[\"更改权限\",{\"1\":{\"351\":1}}],[\"更改\",{\"1\":{\"339\":1}}],[\"更改其相应的state\",{\"1\":{\"134\":1}}],[\"更改参数少的构造方法的super\",{\"1\":{\"56\":1}}],[\"更新文件\",{\"1\":{\"370\":1}}],[\"更新内容\",{\"1\":{\"370\":1}}],[\"更新viewport的内容content的大小范围\",{\"1\":{\"238\":1}}],[\"更新scroll方向\",{\"1\":{\"226\":1}}],[\"更新了\",{\"1\":{\"223\":1}}],[\"更新当前scrollposition的pixels值\",{\"1\":{\"221\":1}}],[\"更新pixels\",{\"1\":{\"220\":1}}],[\"更新为当前\",{\"1\":{\"219\":1}}],[\"更新自己的\",{\"1\":{\"193\":1}}],[\"更新duration\",{\"1\":{\"150\":1}}],[\"更新child\",{\"1\":{\"126\":2}}],[\"更新来间接管理widget\",{\"1\":{\"119\":1}}],[\"更新\",{\"1\":{\"79\":1,\"190\":1,\"191\":1,\"194\":1,\"216\":1,\"223\":1,\"227\":1,\"274\":1}}],[\"更新按钮\",{\"1\":{\"79\":1}}],[\"更需要有条理的总结\",{\"1\":{\"0\":1,\"398\":1}}],[\"泡在网上的日子\",{\"1\":{\"55\":1}}],[\"由更加基础的通用数据结构组成\",{\"1\":{\"445\":1}}],[\"由activity通过navigation控制切换\",{\"1\":{\"399\":1}}],[\"由一条il对应生成多行machine\",{\"1\":{\"395\":1}}],[\"由所有在这个isolate\",{\"1\":{\"388\":1}}],[\"由用户控制\",{\"1\":{\"322\":1}}],[\"由jvm智能决定自旋次数\",{\"1\":{\"320\":1}}],[\"由指令重排\",{\"1\":{\"317\":1}}],[\"由objectoutputstream\",{\"1\":{\"303\":1}}],[\"由上述代码可知\",{\"1\":{\"237\":1}}],[\"由子类根据需要实现\",{\"1\":{\"233\":1}}],[\"由\",{\"1\":{\"181\":1,\"211\":1}}],[\"由构造方法中必传的\",{\"1\":{\"161\":1}}],[\"由系统控件控制动画\",{\"1\":{\"146\":1,\"157\":1}}],[\"由此数据才变为可用数据\",{\"1\":{\"371\":1}}],[\"由此形成的格式一般是类似\",{\"1\":{\"357\":1}}],[\"由此可以计算出enumclazz实际占用的大小应该是\",{\"1\":{\"285\":1}}],[\"由此我们可以计算出设计稿中的控件在compose中对应的dp大小\",{\"1\":{\"81\":1}}],[\"由此\",{\"1\":{\"65\":1,\"285\":1}}],[\"由init进程fork而来\",{\"1\":{\"60\":1}}],[\"由init进程fork生成\",{\"1\":{\"60\":1}}],[\"由zygote进程fork而来\",{\"1\":{\"60\":1}}],[\"由swapper进程创建\",{\"1\":{\"60\":1}}],[\"由内核创建匿名文件并与内存进行映射\",{\"1\":{\"58\":1}}],[\"由简到难手把手带你撸三款\",{\"1\":{\"55\":1}}],[\"由于插入排序在排序进行到后期\",{\"1\":{\"460\":1}}],[\"由于之前的\",{\"1\":{\"419\":1}}],[\"由于是不同时间装的期间还重装了几次系统\",{\"1\":{\"418\":1}}],[\"由于原网站特性\",{\"1\":{\"370\":1}}],[\"由于actor\",{\"1\":{\"334\":1}}],[\"由于android绘制文字时\",{\"1\":{\"15\":1}}],[\"由于android引入了分区存储\",{\"1\":{\"2\":1}}],[\"由于内部类自动持有外部类的this引用\",{\"1\":{\"317\":1}}],[\"由于枚举类型的对象是唯一的\",{\"1\":{\"294\":1}}],[\"由于java的线程实现是映射到系统线程的\",{\"1\":{\"317\":1}}],[\"由于java运算的具体实现并非原子性的\",{\"1\":{\"317\":1}}],[\"由于java内存模型\",{\"1\":{\"317\":1}}],[\"由于java代码是一行行进行的\",{\"1\":{\"294\":1}}],[\"由于java匿名内部类的实现并不是真正的闭包\",{\"1\":{\"281\":1}}],[\"由于泛型的类型在运行时会被擦除\",{\"1\":{\"291\":1}}],[\"由于泛型类型参数会在运行时被擦除\",{\"1\":{\"291\":1}}],[\"由于map中的泛型参数类型已经被擦除\",{\"1\":{\"291\":1}}],[\"由于他默认持有外部类的引用\",{\"1\":{\"282\":1}}],[\"由于他需要二分法查找的影响会比hashmap慢很多\",{\"1\":{\"49\":1}}],[\"由于table\",{\"1\":{\"280\":1}}],[\"由于sparsearray类的key是int类型而非被自动装箱后的integer对象\",{\"1\":{\"287\":1}}],[\"由于string类是final的\",{\"1\":{\"254\":1}}],[\"由于singlechildscrollview的child尺寸和父级一致\",{\"1\":{\"241\":1}}],[\"由于默认的获取viewmodel的方法只能调取无参构造函数\",{\"1\":{\"402\":1}}],[\"由于默认的\",{\"1\":{\"227\":1}}],[\"由于\",{\"1\":{\"223\":1,\"458\":1}}],[\"由于我们已经在appcomponent中包括了androidinjectionmodule\",{\"1\":{\"92\":1}}],[\"由于我们开发者只能接触到asynctask\",{\"1\":{\"80\":1}}],[\"由于view的绘制和activity的生命周期不同步\",{\"1\":{\"65\":1}}],[\"由于主进程被阻塞的同时成为了后台进程\",{\"1\":{\"14\":1}}],[\"由于child\",{\"1\":{\"13\":1}}],[\"由于闹钟会在设备关机的时候被取消\",{\"1\":{\"9\":1}}],[\"由于上述方式获取到的uri只对本app赋予了权限\",{\"1\":{\"2\":1}}],[\"针对java\",{\"1\":{\"273\":1}}],[\"针对本文中的例子做了一些修改\",{\"1\":{\"94\":1}}],[\"针对item中的联系人姓名首字母对应的tag作比较\",{\"1\":{\"64\":1}}],[\"针对\",{\"1\":{\"55\":2}}],[\"开放地址法性能下降很快\",{\"1\":{\"428\":1}}],[\"开放地址法又分为3种实现\",{\"1\":{\"428\":1}}],[\"开放地址法\",{\"1\":{\"428\":3}}],[\"开头aa\",{\"1\":{\"369\":1}}],[\"开机必备文件\",{\"1\":{\"349\":1}}],[\"开机时执行\",{\"1\":{\"361\":1}}],[\"开机时\",{\"1\":{\"60\":1}}],[\"开启了动画\",{\"1\":{\"150\":1}}],[\"开眼快创\",{\"1\":{\"116\":1}}],[\"开始同步就可以了\",{\"1\":{\"347\":1}}],[\"开始的无限的整数流\",{\"1\":{\"328\":1}}],[\"开始生产整数\",{\"1\":{\"328\":1}}],[\"开始\",{\"1\":{\"302\":2,\"365\":1,\"417\":1}}],[\"开始执行asingleton构造方法\",{\"1\":{\"294\":1}}],[\"开始与其后的元素\",{\"1\":{\"289\":1}}],[\"开始时更新时\",{\"1\":{\"226\":1}}],[\"开始时调用\",{\"1\":{\"226\":1}}],[\"开始真正执行请求\",{\"1\":{\"211\":1}}],[\"开始全新的hero过渡动画\",{\"1\":{\"180\":1}}],[\"开始ticker\",{\"1\":{\"162\":1}}],[\"开始和结束值等\",{\"1\":{\"156\":1}}],[\"开始动画\",{\"1\":{\"150\":1}}],[\"开始前准备工作\",{\"1\":{\"80\":1}}],[\"开始设置一个间隔10分钟唤醒一次的闹钟\",{\"1\":{\"10\":1}}],[\"开发的\",{\"1\":{\"203\":1}}],[\"开发进阶\",{\"1\":{\"57\":1}}],[\"开发者根据实际情况运用就好了\",{\"1\":{\"55\":1}}],[\"尺寸或者位置发生了变化\",{\"1\":{\"55\":1}}],[\"尺寸或者位置发生变化时\",{\"1\":{\"55\":1}}],[\"尺寸为6\",{\"1\":{\"53\":1}}],[\"尺寸为5\",{\"1\":{\"53\":2}}],[\"确认当前的\",{\"1\":{\"419\":1}}],[\"确认是否拦截点击事件\",{\"1\":{\"13\":1}}],[\"确保了在dart\",{\"1\":{\"377\":1}}],[\"确保如string等关键类不会被自定义的classloader加载而导致异常\",{\"1\":{\"272\":1}}],[\"确保结果永远不会大于使用\",{\"1\":{\"184\":1}}],[\"确保\",{\"1\":{\"168\":1}}],[\"确定虚拟方法的具体执行\",{\"1\":{\"396\":1}}],[\"确定不会变化\",{\"1\":{\"184\":1}}],[\"确定\",{\"1\":{\"55\":1}}],[\"类委托\",{\"1\":{\"322\":1}}],[\"类编译时会产生类型未检查转换的警告\",{\"1\":{\"291\":1}}],[\"类通过一种别扭的方法绕过了这个问题\",{\"1\":{\"291\":1}}],[\"类的加载\",{\"1\":{\"279\":1}}],[\"类或接口在被初始化之前\",{\"1\":{\"279\":1}}],[\"类方法解析\",{\"1\":{\"278\":1}}],[\"类肯定不同\",{\"1\":{\"272\":1}}],[\"类加载机制\",{\"1\":{\"279\":2}}],[\"类加载机制一般分为三部分\",{\"1\":{\"273\":1}}],[\"类加载根据加载的类不同分为两种\",{\"1\":{\"274\":1}}],[\"类加载的地方是开发人员可控性最强的地方\",{\"1\":{\"274\":1}}],[\"类加载器不同\",{\"1\":{\"272\":1}}],[\"类加载后\",{\"1\":{\"254\":1}}],[\"类结构图\",{\"1\":{\"203\":1}}],[\"类修改为\",{\"1\":{\"172\":1}}],[\"类型错误\",{\"1\":{\"293\":1}}],[\"类型转化错误\",{\"1\":{\"292\":1}}],[\"类型转化为其他的类型比如\",{\"1\":{\"157\":1}}],[\"类型不兼容\",{\"1\":{\"291\":1}}],[\"类型为threadlocal<\",{\"1\":{\"288\":1}}],[\"类型为int64\",{\"1\":{\"115\":1}}],[\"类型是否为\",{\"0\":{\"230\":1},\"1\":{\"230\":1}}],[\"类型是extendednetworkimageprovider\",{\"1\":{\"200\":1}}],[\"类型\",{\"1\":{\"183\":2,\"205\":1,\"252\":1,\"362\":1}}],[\"类型的插值\",{\"1\":{\"186\":1}}],[\"类型的对象\",{\"1\":{\"183\":1}}],[\"类型的值\",{\"1\":{\"182\":1,\"183\":1}}],[\"类型的\",{\"1\":{\"182\":1,\"185\":1}}],[\"类型的方法\",{\"1\":{\"158\":1,\"230\":1}}],[\"类\",{\"1\":{\"157\":1,\"158\":1,\"172\":1,\"211\":1,\"254\":1,\"278\":1,\"279\":1}}],[\"类似启动新线程\",{\"1\":{\"323\":1}}],[\"类似c\",{\"1\":{\"317\":1}}],[\"类似的步骤展示图片\",{\"1\":{\"211\":1}}],[\"类似\",{\"1\":{\"183\":1,\"264\":1,\"280\":1,\"327\":1}}],[\"类似于collectlatest\",{\"1\":{\"340\":1}}],[\"类似于线程的锁\",{\"1\":{\"334\":1}}],[\"类似于\",{\"1\":{\"329\":1}}],[\"类似于blockingqueue\",{\"1\":{\"328\":1}}],[\"类似于数组中object\",{\"1\":{\"291\":1}}],[\"类似于android的thread\",{\"1\":{\"145\":1}}],[\"类似于窗户\",{\"1\":{\"41\":1}}],[\"类似framelayout\",{\"1\":{\"139\":1}}],[\"类似android的onstop\",{\"1\":{\"138\":1}}],[\"类似android的onpostresume\",{\"1\":{\"138\":1}}],[\"类似android的onpause\",{\"1\":{\"138\":1}}],[\"类似rpc\",{\"1\":{\"137\":1}}],[\"类和对应的布局文件\",{\"1\":{\"79\":1}}],[\"类时候具体重写的方法不一样\",{\"1\":{\"55\":1}}],[\"尹star\",{\"1\":{\"55\":1}}],[\"作用对象\",{\"1\":{\"361\":1}}],[\"作用根据传入的\",{\"1\":{\"184\":1}}],[\"作用的方式\",{\"1\":{\"182\":1}}],[\"作为入口类\",{\"1\":{\"370\":1}}],[\"作为有序部分的最后一个元素\",{\"1\":{\"289\":1}}],[\"作为方法区数据的访问入口\",{\"1\":{\"274\":1}}],[\"作为singlechildscrollview子级的column内部能够使用expanded的关键在于instrinsicheight\",{\"1\":{\"242\":1}}],[\"作为statelesswidget\",{\"1\":{\"126\":1}}],[\"作为其直接子类\",{\"1\":{\"233\":1}}],[\"作为其\",{\"1\":{\"213\":1}}],[\"作为renderimage\",{\"1\":{\"198\":1}}],[\"作为renderview的child\",{\"1\":{\"121\":1}}],[\"作为一个statelesswidget\",{\"1\":{\"235\":1}}],[\"作为一个\",{\"1\":{\"195\":1,\"198\":1}}],[\"作为\",{\"1\":{\"147\":1,\"170\":1,\"186\":1,\"213\":1}}],[\"作为大小单位即可\",{\"1\":{\"81\":1}}],[\"作为更通用的接口\",{\"1\":{\"58\":1}}],[\"作为第三方统计平台\",{\"1\":{\"54\":1}}],[\"作者\",{\"1\":{\"55\":1,\"58\":2,\"137\":1,\"306\":1,\"347\":1}}],[\"显式动画\",{\"1\":{\"146\":2,\"154\":1,\"156\":1,\"157\":1}}],[\"显然单纯的使用\",{\"1\":{\"408\":1}}],[\"显然\",{\"1\":{\"387\":1}}],[\"显然这样十分危险\",{\"1\":{\"294\":1}}],[\"显然我们是无法用\",{\"1\":{\"84\":1}}],[\"显然又调用了decorview的superdispatchtouchevent\",{\"1\":{\"13\":1}}],[\"显示没有该字符的行号\",{\"1\":{\"361\":1}}],[\"显示压缩前后压缩比\",{\"1\":{\"356\":1}}],[\"显示在\",{\"1\":{\"228\":1}}],[\"显示在屏幕上面\",{\"1\":{\"213\":1}}],[\"显示为边长约为\",{\"1\":{\"173\":1}}],[\"显示为直径为\",{\"1\":{\"173\":1}}],[\"显示动画\",{\"1\":{\"155\":2}}],[\"显示\",{\"1\":{\"55\":1}}],[\"提出一个阈值\",{\"1\":{\"467\":1}}],[\"提心threadgroup当前线程已经被终止\",{\"1\":{\"297\":1}}],[\"提供一些自己特有的内容\",{\"1\":{\"235\":1}}],[\"提供一个可以折叠的toolbar布局\",{\"1\":{\"55\":1}}],[\"提供按照\",{\"1\":{\"229\":1}}],[\"提供像buildslivers之类的方法方便子类能够快速实现一个\",{\"1\":{\"227\":1}}],[\"提供的\",{\"1\":{\"209\":1,\"211\":1}}],[\"提供的动画\",{\"1\":{\"157\":1}}],[\"提供多种创建方式\",{\"1\":{\"204\":1}}],[\"提供ffi和texture两种图片展示方式\",{\"1\":{\"198\":1}}],[\"提供给前面创建的\",{\"1\":{\"181\":1}}],[\"提供\",{\"1\":{\"168\":1}}],[\"提供进一步封装的\",{\"1\":{\"157\":1}}],[\"提供了检测\",{\"1\":{\"230\":1}}],[\"提供了\",{\"1\":{\"211\":1}}],[\"提供了一些方法供scrollposition和其他viewport调用\",{\"1\":{\"237\":1}}],[\"提供了一些通用的方法\",{\"1\":{\"202\":1}}],[\"提供了一套简单易用的api\",{\"1\":{\"117\":1}}],[\"提供了将\",{\"1\":{\"158\":1}}],[\"提供了build方法供子类根据不同的状态创建widget\",{\"1\":{\"154\":1}}],[\"提供了常见的动画效果\",{\"1\":{\"153\":1}}],[\"提示开始发布文章\",{\"1\":{\"368\":1}}],[\"提示符前面的内容\",{\"1\":{\"358\":1}}],[\"提示如you\",{\"1\":{\"347\":1}}],[\"提示用户到设置中开启\",{\"1\":{\"69\":1}}],[\"提示️\",{\"1\":{\"69\":1}}],[\"提示等用户友好的页面\",{\"1\":{\"14\":1}}],[\"​\",{\"1\":{\"54\":1,\"56\":3,\"321\":3,\"368\":1,\"449\":1}}],[\"目标层\",{\"1\":{\"459\":1}}],[\"目前只实现了爬取gityuan\",{\"1\":{\"371\":1}}],[\"目前已经分析了底层实现的部分\",{\"1\":{\"146\":1}}],[\"目前稳定高效的ui适配方案\",{\"1\":{\"53\":1}}],[\"目的2\",{\"1\":{\"55\":1}}],[\"目的1\",{\"1\":{\"55\":1}}],[\"目录设置如此\",{\"1\":{\"417\":1}}],[\"目录的解释\",{\"0\":{\"415\":1}}],[\"目录下面新建一个嵌套导航图\",{\"1\":{\"400\":1}}],[\"目录下\",{\"1\":{\"348\":1,\"419\":1}}],[\"目录下新建对应渠道文件夹\",{\"1\":{\"54\":1}}],[\"目录\",{\"1\":{\"111\":1,\"112\":1}}],[\"目录树如下\",{\"1\":{\"54\":1}}],[\"博客就搭建好了\",{\"1\":{\"419\":1}}],[\"博客就在本地搭建好了\",{\"1\":{\"414\":1}}],[\"博客的网址就是http\",{\"1\":{\"419\":1}}],[\"博客了\",{\"1\":{\"414\":1}}],[\"博客要同步的git工程路径\",{\"1\":{\"367\":1}}],[\"博客园\",{\"1\":{\"65\":1,\"427\":1}}],[\"博客\",{\"1\":{\"54\":1}}],[\"若此时序列数不是1个\",{\"1\":{\"459\":1}}],[\"若节点是红色\",{\"1\":{\"458\":1}}],[\"若a在序列中排在b的前面\",{\"1\":{\"438\":1}}],[\"若父加载器为空\",{\"1\":{\"272\":1}}],[\"若内存不够则会被gc回收\",{\"1\":{\"269\":1}}],[\"若finalize\",{\"1\":{\"266\":1}}],[\"若是则放到f\",{\"1\":{\"266\":1}}],[\"若执行的是native方法\",{\"1\":{\"255\":1}}],[\"若执行java方法\",{\"1\":{\"255\":1}}],[\"若无法显示可点击这里查看\",{\"1\":{\"84\":1,\"85\":1,\"86\":1}}],[\"若无此类要求可直接使用\",{\"1\":{\"54\":1}}],[\"若用户选择了不再提示则一直为false\",{\"1\":{\"69\":1}}],[\"若与前一个相同则不显示title\",{\"1\":{\"64\":1}}],[\"若手动指定为false则即使有intent\",{\"1\":{\"17\":1}}],[\"$ddata\",{\"1\":{\"429\":1}}],[\"$drawable\",{\"1\":{\"427\":1}}],[\"$sdpath\",{\"1\":{\"425\":1}}],[\"$sysdir\",{\"1\":{\"272\":1}}],[\"$mipmap\",{\"1\":{\"424\":1}}],[\"$message\",{\"1\":{\"373\":3}}],[\"$b\",{\"1\":{\"327\":2}}],[\"$a\",{\"1\":{\"327\":2}}],[\"$value\",{\"1\":{\"327\":3,\"334\":2,\"341\":2}}],[\"$key​\",{\"1\":{\"358\":1}}],[\"$k\",{\"1\":{\"327\":1}}],[\"$num\",{\"1\":{\"459\":1}}],[\"$number\",{\"1\":{\"325\":1}}],[\"$node\",{\"1\":{\"430\":1}}],[\"$name\",{\"1\":{\"272\":1}}],[\"$navigator\",{\"1\":{\"180\":1}}],[\"$classname\",{\"1\":{\"322\":2}}],[\"$curve\",{\"1\":{\"185\":1}}],[\"$currenttimems\",{\"1\":{\"110\":1}}],[\"$url\",{\"1\":{\"201\":1}}],[\"$to\",{\"1\":{\"459\":2}}],[\"$time\",{\"1\":{\"327\":1}}],[\"$timeelapsestring$\",{\"1\":{\"110\":1}}],[\"$t\",{\"1\":{\"186\":1}}],[\"$pop\",{\"1\":{\"437\":1,\"438\":1}}],[\"$parentwidget\",{\"1\":{\"143\":1}}],[\"$prefix\",{\"1\":{\"110\":1}}],[\"$error\",{\"1\":{\"145\":1}}],[\"$e\",{\"1\":{\"142\":2,\"212\":1,\"341\":3}}],[\"$element\",{\"1\":{\"95\":1}}],[\"$iid\",{\"1\":{\"429\":1}}],[\"$i\",{\"1\":{\"140\":1,\"327\":1,\"341\":1}}],[\"$index\",{\"1\":{\"131\":1,\"212\":1,\"234\":1}}],[\"$it\",{\"1\":{\"78\":1,\"321\":1,\"327\":1}}],[\"$resource\",{\"1\":{\"211\":1}}],[\"$repeatcounter\",{\"1\":{\"95\":1}}],[\"$rootproject\",{\"1\":{\"88\":3}}],[\"$waitforinjectclass\",{\"1\":{\"93\":1}}],[\"$\",{\"1\":{\"54\":4,\"81\":4,\"101\":1,\"110\":2,\"111\":1,\"130\":9,\"143\":2,\"180\":1,\"185\":1,\"245\":1,\"246\":1,\"247\":1,\"248\":1,\"321\":2,\"325\":2,\"327\":1,\"334\":1,\"345\":1,\"373\":4,\"378\":2,\"407\":1,\"438\":1}}],[\"友盟初始化appkey和channel\",{\"1\":{\"54\":1}}],[\"友盟sdk\",{\"1\":{\"54\":1}}],[\"添加回调\",{\"1\":{\"216\":1}}],[\"添加目标\",{\"1\":{\"170\":1}}],[\"添加点击事件\",{\"1\":{\"140\":1}}],[\"添加\",{\"1\":{\"79\":1,\"230\":1,\"347\":1}}],[\"添加监听事件\",{\"1\":{\"79\":2}}],[\"添加依赖\",{\"1\":{\"54\":1}}],[\"添加方法先用二分法查找key对应的位置\",{\"1\":{\"45\":1}}],[\"图中有环\",{\"1\":{\"438\":1}}],[\"图中还有顶点\",{\"1\":{\"438\":1}}],[\"图的操作有插入\",{\"1\":{\"433\":1}}],[\"图一般有两种存储方式\",{\"1\":{\"433\":1}}],[\"图\",{\"0\":{\"433\":1},\"1\":{\"433\":1,\"445\":1}}],[\"图片内存优化实践\",{\"1\":{\"211\":1}}],[\"图片框架架构演进\",{\"1\":{\"211\":1}}],[\"图片库高燃新登场\",{\"1\":{\"211\":1}}],[\"图片库加载图片\",{\"1\":{\"208\":1}}],[\"图片数据\",{\"1\":{\"211\":1}}],[\"图片浏览\",{\"1\":{\"199\":1}}],[\"图片加载两部分\",{\"1\":{\"203\":1}}],[\"图片加载过程中的回调\",{\"1\":{\"198\":1}}],[\"图片加载成功\",{\"1\":{\"191\":1,\"198\":1}}],[\"图片会一直被持有\",{\"1\":{\"197\":1}}],[\"图片会被imagecache\",{\"1\":{\"197\":1}}],[\"图片的加载逻辑在其handlerequest方法中\",{\"1\":{\"211\":1}}],[\"图片的\",{\"1\":{\"197\":1}}],[\"图片的获取与缓存\",{\"1\":{\"195\":1}}],[\"图片\",{\"1\":{\"197\":1}}],[\"图片来自于android\",{\"1\":{\"282\":1}}],[\"图片来自\",{\"1\":{\"61\":1}}],[\"图片来自https\",{\"1\":{\"58\":3,\"282\":2}}],[\"图片来源\",{\"1\":{\"40\":1}}],[\"图标\",{\"1\":{\"54\":1}}],[\"与第一次hash输出不同\",{\"1\":{\"428\":1}}],[\"与之相比\",{\"1\":{\"396\":1}}],[\"与isolate有关的类有\",{\"1\":{\"372\":1}}],[\"与io\",{\"1\":{\"111\":1}}],[\"与列表类似\",{\"1\":{\"369\":1}}],[\"与具体执行网络请求有关的方法\",{\"1\":{\"362\":1}}],[\"与它发送元素的通道相关联\",{\"1\":{\"334\":1}}],[\"与它接收消息的通道相关联\",{\"1\":{\"334\":1}}],[\"与rxjava结合\",{\"1\":{\"321\":1}}],[\"与有序部分的最后一个元素\",{\"1\":{\"289\":1}}],[\"与反射机制\",{\"1\":{\"279\":1}}],[\"与java虚拟机栈作用类似\",{\"1\":{\"253\":1}}],[\"与其无限拓展\",{\"1\":{\"242\":1}}],[\"与physics等结合计算之后\",{\"1\":{\"226\":1}}],[\"与圆内切的正方形边长s\",{\"1\":{\"172\":1}}],[\"与此同时如果这个节点有右子节点\",{\"1\":{\"432\":2}}],[\"与此同时\",{\"1\":{\"171\":1}}],[\"与此同时对应的io操作已经压入消息栈中等待触发在单独的线程中执行\",{\"1\":{\"116\":1}}],[\"与父类componentelement\",{\"1\":{\"128\":1}}],[\"与上述两者不太一样的是\",{\"1\":{\"128\":1}}],[\"与自己绑定\",{\"1\":{\"121\":1}}],[\"与dart层的\",{\"1\":{\"115\":1}}],[\"与dpx单位保持一致\",{\"1\":{\"81\":1}}],[\"与管道不同\",{\"1\":{\"58\":1}}],[\"与信号\",{\"1\":{\"58\":1}}],[\"与\",{\"0\":{\"323\":1},\"1\":{\"54\":1,\"55\":1,\"57\":1,\"183\":1,\"211\":1,\"232\":1,\"327\":1,\"347\":1,\"400\":1}}],[\"与客户端调用服务端方法在同一线程\",{\"1\":{\"36\":1}}],[\"国内很多软件都使用的是\",{\"1\":{\"54\":1}}],[\"国内\",{\"1\":{\"54\":1}}],[\"国内较快的仓库\",{\"1\":{\"1\":1}}],[\"望解答多谢\",{\"1\":{\"53\":1}}],[\"拉丁吴\",{\"1\":{\"53\":1}}],[\"支持a\",{\"1\":{\"369\":1}}],[\"支持android\",{\"1\":{\"132\":1}}],[\"支持加载以及失败显示\",{\"1\":{\"199\":1}}],[\"支持的格式有\",{\"1\":{\"188\":1}}],[\"支持的数据格式\",{\"0\":{\"33\":1}}],[\"支持\",{\"1\":{\"184\":1}}],[\"支持更加丰富的动画\",{\"1\":{\"183\":1}}],[\"支持不同的像素密度\",{\"1\":{\"53\":1}}],[\"骚年你的屏幕适配方式该升级了\",{\"1\":{\"53\":1}}],[\"又称堆栈\",{\"1\":{\"452\":1}}],[\"又可以像数组那样快速查找\",{\"1\":{\"429\":1}}],[\"又再次用起了\",{\"1\":{\"408\":1}}],[\"又当生产者时\",{\"1\":{\"322\":1}}],[\"又由于列表不能保存不同的类型\",{\"1\":{\"292\":1}}],[\"又有\",{\"1\":{\"280\":1}}],[\"又会因为singlechildscrollview给child在主轴方向的尺寸无限制\",{\"1\":{\"242\":1}}],[\"又会导致children内容无法完整显示\",{\"1\":{\"242\":1}}],[\"又需要保证在父级空间不足时能够完整显示所有children的内容的话\",{\"1\":{\"241\":1}}],[\"又是如何实现滑动效果的呢\",{\"1\":{\"239\":1}}],[\"又是怎样才显示到屏幕上的\",{\"1\":{\"117\":1}}],[\"又吹风\",{\"1\":{\"116\":1}}],[\"又将isolate切换回来\",{\"1\":{\"115\":1}}],[\"又通过androidinjector从appcomponent中拿到mainactivitymodule中的androidinjector\",{\"1\":{\"94\":1}}],[\"又根据\",{\"1\":{\"81\":1,\"238\":1}}],[\"又根据这个文章\",{\"1\":{\"15\":1}}],[\"又知道android中将像素和dp等单位转化的方法如下\",{\"1\":{\"53\":1}}],[\"设其坐标为max\",{\"1\":{\"456\":1}}],[\"设一个栈用于保存运算符\",{\"1\":{\"453\":1}}],[\"设定所有排序\",{\"1\":{\"450\":1}}],[\"设元素下标为x\",{\"1\":{\"439\":1}}],[\"设计不同界面切换效果\",{\"1\":{\"400\":1}}],[\"设计用来执行并行操作\",{\"1\":{\"323\":1}}],[\"设计用来以阻塞的方式执行协程代码\",{\"1\":{\"323\":1}}],[\"设计稿中的屏幕宽度\",{\"1\":{\"81\":1}}],[\"设计稿屏幕宽度\",{\"1\":{\"81\":1}}],[\"设计稿宽度对应设备水平方向\",{\"1\":{\"81\":1}}],[\"设计稿总宽度dpx\",{\"1\":{\"81\":1}}],[\"设为m\",{\"1\":{\"289\":1}}],[\"设要绘制的图形为src\",{\"1\":{\"57\":1}}],[\"设备文件分为block\",{\"1\":{\"111\":1}}],[\"设备\",{\"1\":{\"53\":2}}],[\"设置了apkpath\",{\"1\":{\"427\":1}}],[\"设置新建一个\",{\"1\":{\"417\":1}}],[\"设置新的状态\",{\"1\":{\"146\":1,\"157\":1}}],[\"设置类\",{\"1\":{\"279\":1}}],[\"设置虚引用只是为了在对象被gc回收时获取系统通知\",{\"1\":{\"271\":1}}],[\"设置column约束\",{\"1\":{\"241\":1}}],[\"设置child的位置\",{\"1\":{\"55\":1}}],[\"设置的事件是打开一个\",{\"1\":{\"79\":1}}],[\"设置的闹钟间隔为10分钟\",{\"1\":{\"5\":1}}],[\"设置二者重叠部分的绘制方式\",{\"1\":{\"65\":1}}],[\"设置wrap\",{\"1\":{\"65\":1}}],[\"设置当前选中的字母\",{\"1\":{\"64\":1}}],[\"设置滑动监听事件\",{\"1\":{\"64\":1}}],[\"设置监听事件\",{\"1\":{\"56\":1}}],[\"设置toolbar以及和toolbar一起联动的子view\",{\"1\":{\"55\":1}}],[\"设置主activity的背景为透明色\",{\"1\":{\"14\":1}}],[\"设置一个每天指定时间循环的闹钟\",{\"0\":{\"10\":1}}],[\"设置ndk环境变量\",{\"1\":{\"1\":1}}],[\"设置\",{\"1\":{\"1\":1,\"79\":1,\"357\":1}}],[\"单链表\",{\"1\":{\"451\":2}}],[\"单引号\",{\"1\":{\"358\":1}}],[\"单例模式\",{\"1\":{\"305\":1,\"316\":1}}],[\"单但为了更好的避免这种情况的发生我们使用threadlocal时遵守以下两个小原则\",{\"1\":{\"288\":1}}],[\"单个线程最大栈内存=最大线程数量\",{\"1\":{\"257\":1}}],[\"单线程下\",{\"1\":{\"257\":1}}],[\"单线程\",{\"1\":{\"257\":1}}],[\"单位转换为像素时所必须使用的缩放系数\",{\"1\":{\"53\":1}}],[\"单就viewgroup和view而论\",{\"1\":{\"13\":1}}],[\"字典dict\",{\"1\":{\"369\":1,\"371\":1}}],[\"字符串前面加r或者r表示字符串内部不需要转义\",{\"1\":{\"369\":1}}],[\"字符串\",{\"1\":{\"369\":1}}],[\"字符\",{\"1\":{\"361\":1}}],[\"字型\",{\"1\":{\"328\":2}}],[\"字段解析\",{\"1\":{\"278\":1}}],[\"字段表示根据当前像素密度指定将\",{\"1\":{\"53\":1}}],[\"字节码验证\",{\"1\":{\"276\":1}}],[\"字节跳动\",{\"1\":{\"53\":1}}],[\"字面量\",{\"1\":{\"254\":1}}],[\"字母导航栏要留出方法\",{\"1\":{\"64\":1}}],[\"字母导航栏\",{\"1\":{\"64\":1}}],[\"字体的高度＝上坡度＋下坡度＋行间距\",{\"1\":{\"15\":1}}],[\"屏幕等\",{\"1\":{\"361\":2}}],[\"屏幕帧刷新\",{\"1\":{\"157\":1}}],[\"屏幕点击\",{\"1\":{\"101\":1}}],[\"屏幕刷新等\",{\"1\":{\"109\":1}}],[\"屏幕刷新\",{\"1\":{\"95\":2}}],[\"屏幕宽度总dp\",{\"1\":{\"81\":1}}],[\"屏幕宽度为\",{\"1\":{\"53\":2}}],[\"屏幕实际像素宽度\",{\"1\":{\"81\":1}}],[\"屏幕适配方案\",{\"1\":{\"81\":2}}],[\"屏幕的实际水平dp大小rdp\",{\"1\":{\"81\":1}}],[\"屏幕的总\",{\"1\":{\"53\":4,\"81\":4}}],[\"屏幕总\",{\"1\":{\"53\":2}}],[\"屏幕尺寸inch计算\",{\"1\":{\"53\":1}}],[\"屏幕每平方英寸有多少像素\",{\"1\":{\"53\":1}}],[\"选出一个枢纽\",{\"1\":{\"467\":1}}],[\"选出来的这个值c\",{\"1\":{\"463\":1}}],[\"选中间的数作为枢纽\",{\"1\":{\"466\":1,\"467\":1}}],[\"选取一个枢纽\",{\"1\":{\"465\":1}}],[\"选取一个中间值n将当前数组一分为二\",{\"1\":{\"451\":1}}],[\"选用aes加密算法进行加密后\",{\"1\":{\"296\":1}}],[\"选择数组最右端元素作为枢纽\",{\"1\":{\"467\":1}}],[\"选择了某个植物后\",{\"1\":{\"399\":1}}],[\"选择了基于今日头条的androidautosize适配方案\",{\"1\":{\"53\":1}}],[\"选择是否发布文章到网站\",{\"1\":{\"368\":1}}],[\"选择是否用hexo编译文章\",{\"1\":{\"368\":1}}],[\"选择\",{\"1\":{\"347\":1,\"417\":1,\"419\":1}}],[\"选择排序\",{\"0\":{\"456\":1},\"1\":{\"445\":1,\"449\":1,\"456\":1}}],[\"选择排序的思想\",{\"1\":{\"289\":1}}],[\"选择排序和插入排序\",{\"1\":{\"289\":1}}],[\"选择在正方向上离我们最远的inner\",{\"1\":{\"225\":1}}],[\"选择内置的隐式动画\",{\"1\":{\"156\":1}}],[\"选好方向\",{\"1\":{\"0\":1}}],[\"然后依次向元素父节点遍历\",{\"1\":{\"440\":1}}],[\"然后进入这个文件夹\",{\"1\":{\"414\":1}}],[\"然后转化为machine\",{\"1\":{\"394\":1}}],[\"然后推送到设备上面\",{\"1\":{\"393\":1}}],[\"然后选择execute执行即可\",{\"1\":{\"362\":1}}],[\"然后复制右边的有个https\",{\"1\":{\"347\":1}}],[\"然后把这个添加提交到本地的仓库\",{\"1\":{\"347\":1}}],[\"然后异常传递给父协程\",{\"1\":{\"329\":1}}],[\"然后哪个值先出来\",{\"1\":{\"327\":1}}],[\"然后对结果调用\",{\"1\":{\"327\":1}}],[\"然后对其flatmapconcat\",{\"1\":{\"327\":1}}],[\"然后collect\",{\"1\":{\"327\":2}}],[\"然后阻塞其他线程进入\",{\"1\":{\"317\":1}}],[\"然后自身在父级约束条件下尽可能满足child\",{\"1\":{\"239\":1}}],[\"然后自身在满足父级约束的情况下应用child的size\",{\"1\":{\"238\":1}}],[\"然后发出overscroll的通知\",{\"1\":{\"226\":1}}],[\"然后是outer\",{\"1\":{\"226\":1}}],[\"然后以此计算\",{\"1\":{\"225\":1}}],[\"然后会有地方处理overscroll\",{\"1\":{\"221\":1}}],[\"然后会执行powerimageloader\",{\"1\":{\"211\":1}}],[\"然后powerimagerequestmanager\",{\"1\":{\"211\":1}}],[\"然后根据是否创建了new\",{\"1\":{\"391\":1}}],[\"然后根据\",{\"1\":{\"191\":1,\"228\":1}}],[\"然后根据事件失败或者成功\",{\"1\":{\"116\":1}}],[\"然后中通过下面的方法实现android和flutter交互\",{\"1\":{\"135\":1}}],[\"然后执行\",{\"1\":{\"128\":1}}],[\"然后将剩下的元素全部依次复制到a的末尾\",{\"1\":{\"459\":1}}],[\"然后将其生成的code以及vm内部的数据结构序列化为appjit\",{\"1\":{\"396\":1}}],[\"然后将其与thread\",{\"1\":{\"383\":1}}],[\"然后将结果push回这个stack中\",{\"1\":{\"395\":1}}],[\"然后将我们传入的richtext的renderobject\",{\"1\":{\"127\":1}}],[\"然后将activity传入inject\",{\"1\":{\"94\":1}}],[\"然后调用dart\",{\"1\":{\"383\":1}}],[\"然后调用powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"然后调用其insertrenderobjectchild方法将当前的renderparagraph插入到rendering\",{\"1\":{\"127\":1}}],[\"然后调用此element\",{\"1\":{\"122\":1}}],[\"然后这个element在上述widgetsbinding\",{\"1\":{\"125\":1}}],[\"然后创建一个对应的dart\",{\"1\":{\"115\":1}}],[\"然后创建了\",{\"1\":{\"94\":1}}],[\"然后使用这个isolate\",{\"1\":{\"383\":1}}],[\"然后使用\",{\"1\":{\"111\":1}}],[\"然后使用indexof\",{\"1\":{\"49\":1}}],[\"然后等待返回结果\",{\"1\":{\"111\":1}}],[\"然后判断是否有micro\",{\"1\":{\"109\":1}}],[\"然后系统会在时间到了之后\",{\"1\":{\"108\":1}}],[\"然后计算出timer的唤醒时间wakeuptime\",{\"1\":{\"105\":1}}],[\"然后通过powerimagechannel发送请求\",{\"1\":{\"211\":1}}],[\"然后通过renderobjecttowidgetelement\",{\"1\":{\"127\":1}}],[\"然后通过\",{\"1\":{\"100\":1,\"211\":1}}],[\"然后通过mmu\",{\"1\":{\"58\":1}}],[\"然后不停的从event\",{\"1\":{\"95\":1}}],[\"然后当mainactivity之中需要使用到mainactivitysubcomponent时\",{\"1\":{\"94\":1}}],[\"然后\",{\"1\":{\"91\":1,\"101\":1,\"213\":1,\"285\":1,\"393\":1}}],[\"然后再分别移动指针\",{\"1\":{\"464\":1}}],[\"然后再将排好序的两个数组归并在一起得到有序数组\",{\"1\":{\"459\":1}}],[\"然后再将其绘制到原有图层\",{\"1\":{\"57\":1}}],[\"然后再对照规则检查是否需要调整红黑树\",{\"1\":{\"458\":1}}],[\"然后再依次移除即可\",{\"1\":{\"442\":1}}],[\"然后再移向下一层\",{\"1\":{\"438\":1}}],[\"然后再返回上一层的邻接顶点中还可以访问的顶点\",{\"1\":{\"437\":1}}],[\"然后再从这个snapshot中重建对应的状态\",{\"1\":{\"396\":1}}],[\"然后再执行未优化过程\",{\"1\":{\"396\":1}}],[\"然后再在dart\",{\"1\":{\"389\":1}}],[\"然后再在使用该类的时候使用\",{\"1\":{\"84\":1}}],[\"然后再等待所有内部协程结束\",{\"1\":{\"323\":1}}],[\"然后再修改为其他\",{\"1\":{\"159\":1}}],[\"然后再使用\",{\"1\":{\"106\":1}}],[\"然后再检查一次event\",{\"1\":{\"101\":1}}],[\"然后重写ontouchevent\",{\"1\":{\"64\":1}}],[\"然后结合valueanimator实时获得对应长度的path并绘制\",{\"1\":{\"63\":1}}],[\"然后在activity对应的xml中插入该导航\",{\"1\":{\"400\":1}}],[\"然后在enqueueentrypointinvocationandnotifyspawner方法中将isolate要运行的所有东西都准备好\",{\"1\":{\"389\":1}}],[\"然后在调用诸如out\",{\"1\":{\"306\":1}}],[\"然后在其renderimage\",{\"1\":{\"195\":1}}],[\"然后在要跳转到的第二个页面\",{\"1\":{\"170\":1}}],[\"然后在代码中使用width\",{\"1\":{\"81\":1}}],[\"然后在ondraw\",{\"1\":{\"63\":1}}],[\"然后在\",{\"1\":{\"55\":1,\"195\":1}}],[\"然后在build\",{\"1\":{\"32\":1}}],[\"然后删除对应位置的数据\",{\"1\":{\"52\":1}}],[\"然后取出对应的数据value并返回即可\",{\"1\":{\"51\":1}}],[\"改密码\",{\"0\":{\"354\":1}}],[\"改用户\",{\"1\":{\"353\":1}}],[\"改变节点颜色\",{\"1\":{\"458\":1}}],[\"改变通知\",{\"1\":{\"167\":1}}],[\"改变translationx\",{\"1\":{\"41\":1}}],[\"改为非线性的\",{\"1\":{\"159\":1}}],[\"改动等时\",{\"1\":{\"48\":1}}],[\"时间负责度都是o\",{\"1\":{\"454\":1}}],[\"时间复杂度是o\",{\"1\":{\"459\":1}}],[\"时间复杂度\",{\"1\":{\"455\":1,\"456\":1,\"457\":1}}],[\"时间复杂度为o\",{\"1\":{\"439\":1}}],[\"时间复杂度都是o\",{\"1\":{\"439\":1}}],[\"时的设置\",{\"1\":{\"418\":1}}],[\"时的intent\",{\"1\":{\"17\":1}}],[\"时获取的是当前唯一的isolate\",{\"1\":{\"377\":1}}],[\"时获取到的future便会收到回调\",{\"1\":{\"111\":1}}],[\"时使用\",{\"1\":{\"322\":2}}],[\"时使用animatable\",{\"1\":{\"148\":1}}],[\"时会自动扩容\",{\"1\":{\"280\":1}}],[\"时会被调用多次\",{\"1\":{\"65\":1}}],[\"时都会先检查一下\",{\"1\":{\"230\":1}}],[\"时则会使用\",{\"1\":{\"207\":1}}],[\"时后者才会真正的\",{\"1\":{\"194\":1}}],[\"时要切换回图片\",{\"1\":{\"193\":1}}],[\"时曲线上对应的值\",{\"1\":{\"186\":1}}],[\"时报错\",{\"1\":{\"175\":1}}],[\"时没有动画\",{\"1\":{\"150\":1}}],[\"时序图\",{\"1\":{\"58\":1}}],[\"时\",{\"1\":{\"49\":1,\"55\":1,\"157\":1,\"171\":1,\"174\":1,\"190\":1,\"197\":1,\"198\":2,\"207\":1,\"217\":1,\"220\":2,\"223\":1,\"226\":3,\"280\":2}}],[\"时丢弃\",{\"1\":{\"47\":1}}],[\"~如果正常的话\",{\"1\":{\"418\":1}}],[\"~double\",{\"1\":{\"220\":1}}],[\"~pflag3\",{\"1\":{\"65\":1}}],[\"~\",{\"1\":{\"63\":1,\"109\":1,\"111\":1,\"167\":1,\"220\":4,\"280\":1,\"349\":1,\"361\":5,\"401\":1,\"418\":1}}],[\"~end\",{\"1\":{\"49\":1}}],[\"~0\",{\"1\":{\"49\":1}}],[\"~containerhelpers\",{\"1\":{\"45\":1}}],[\"~index\",{\"1\":{\"50\":1}}],[\"~i\",{\"1\":{\"45\":1}}],[\"查找\",{\"1\":{\"451\":1,\"458\":1}}],[\"查找数据\",{\"1\":{\"445\":1}}],[\"查找下一个顶点\",{\"1\":{\"438\":1}}],[\"查找没有后继点的顶点\",{\"1\":{\"438\":1}}],[\"查找其未访问的邻接点\",{\"1\":{\"438\":1}}],[\"查找当前栈顶元素未访问的邻接点\",{\"1\":{\"437\":1}}],[\"查找iid对应的节点\",{\"1\":{\"432\":1}}],[\"查找isolate开始运行的第一个方法entrypoint\",{\"1\":{\"389\":1}}],[\"查找isolate开始运行的第一个方法\",{\"1\":{\"389\":1}}],[\"查找符合条件的第一个值\",{\"1\":{\"337\":1}}],[\"查找是否已经存在key对应的值\",{\"1\":{\"287\":1}}],[\"查找对应位置的node\",{\"1\":{\"280\":1}}],[\"查阅文档定义可知\",{\"1\":{\"131\":1}}],[\"查阅源码可知\",{\"1\":{\"122\":1}}],[\"查阅\",{\"1\":{\"111\":1}}],[\"查阅相应的资料后大体有以下几种方案\",{\"1\":{\"14\":1}}],[\"查看汉诺塔和递归排序源码\",{\"1\":{\"459\":1}}],[\"查看链表源码\",{\"1\":{\"451\":1}}],[\"查看源码\",{\"1\":{\"444\":1,\"467\":1}}],[\"查看拓扑排序源码\",{\"1\":{\"438\":1}}],[\"查看dfs\",{\"1\":{\"438\":1}}],[\"查看哈夫曼编码源码\",{\"1\":{\"432\":1}}],[\"查看二叉树源码\",{\"1\":{\"432\":1}}],[\"查看帮助信息\",{\"1\":{\"416\":1}}],[\"查看所有别名\",{\"1\":{\"359\":1}}],[\"查看所有变量\",{\"1\":{\"358\":1}}],[\"查看shell命令历史\",{\"1\":{\"358\":1}}],[\"查看指令的位置\",{\"1\":{\"357\":1}}],[\"查看类型\",{\"1\":{\"357\":1}}],[\"查看环境变量\",{\"1\":{\"357\":1}}],[\"查看打包文件的内容\",{\"1\":{\"357\":1}}],[\"查看用户相关信息\",{\"1\":{\"353\":1}}],[\"查看用户所在群组\",{\"1\":{\"353\":1}}],[\"查看某人或者自己相关的uid\",{\"1\":{\"353\":1}}],[\"查看文件格式信息\",{\"1\":{\"349\":1}}],[\"查看当前仓库有几个分支\",{\"1\":{\"347\":1}}],[\"查看实现\",{\"1\":{\"186\":1}}],[\"查看\",{\"0\":{\"353\":1},\"1\":{\"86\":2,\"413\":1,\"416\":1}}],[\"查看gc\",{\"1\":{\"44\":1}}],[\"查询数据等操作\",{\"1\":{\"399\":1}}],[\"查询内容\",{\"1\":{\"361\":1}}],[\"查询是否已经加载该类\",{\"1\":{\"272\":1}}],[\"查询本地是否有符合该描述\",{\"1\":{\"58\":1}}],[\"查询所需的服务呢\",{\"1\":{\"58\":1}}],[\"复数complex\",{\"1\":{\"369\":1}}],[\"复杂度\",{\"1\":{\"129\":1}}],[\"复杂度o\",{\"1\":{\"129\":1}}],[\"复制算法\",{\"0\":{\"262\":1}}],[\"复制了一次\",{\"1\":{\"58\":1}}],[\"复制数组\",{\"1\":{\"44\":1}}],[\"复用messagemessage池中已有的对象\",{\"1\":{\"31\":1}}],[\"涉及到新建\",{\"1\":{\"44\":1}}],[\"避免切换线程\",{\"1\":{\"322\":1}}],[\"避免\",{\"1\":{\"317\":1}}],[\"避免因为hashcode计算得到的hash值\",{\"1\":{\"280\":1}}],[\"避免了将其包装为一个node对象的开销\",{\"1\":{\"287\":1}}],[\"避免了将其封装为node对象带来的内存消耗\",{\"1\":{\"44\":1}}],[\"避免了double运算后产生误差\",{\"1\":{\"186\":1}}],[\"避免泄漏\",{\"1\":{\"54\":1}}],[\"避免出现分配内存\",{\"1\":{\"31\":1}}],[\"他内部有n个有序的子数组\",{\"1\":{\"460\":1}}],[\"他可以负责fragment\",{\"1\":{\"400\":1}}],[\"他和上述isolate\",{\"1\":{\"387\":1}}],[\"他不会处理异常\",{\"1\":{\"343\":1}}],[\"他运行在线程当中\",{\"1\":{\"322\":1}}],[\"他通过监听offset的变化展示children的一部分来实现滑动的视觉效果\",{\"1\":{\"231\":1}}],[\"他也创建了一个statelesselement\",{\"1\":{\"126\":1}}],[\"他创建的renderobject是renderpositionedbox\",{\"1\":{\"122\":1}}],[\"他会根据当前是android还是其他平台的不同被初始化为android主线程或者普通线程池\",{\"1\":{\"363\":1}}],[\"他会根据客户端和服务端是否在同一进程而决定返回stub实例还是proxy类实例以实现跨进程通信\",{\"1\":{\"43\":1}}],[\"他会\",{\"1\":{\"232\":1}}],[\"他会占据父级给的最大空间\",{\"1\":{\"231\":1}}],[\"他会强制child改变大小\",{\"1\":{\"131\":1}}],[\"他会强制将child的size改为renderview初始化时候的入参configuration的值\",{\"1\":{\"122\":1}}],[\"他对应的祖先节点就是持有renderview\",{\"1\":{\"121\":1}}],[\"他对应的实现是\",{\"1\":{\"103\":1}}],[\"他又是如何实现与dart中的调用方双向通信\",{\"1\":{\"112\":1}}],[\"他就会立即执行属于microtask\",{\"1\":{\"95\":1}}],[\"他们凭空创建\",{\"1\":{\"395\":1}}],[\"他们从stack中读取操作数\",{\"1\":{\"395\":1}}],[\"他们之间通过不同的action连接起来\",{\"1\":{\"400\":1}}],[\"他们之间共享heap\",{\"1\":{\"391\":1}}],[\"他们之间的关系可以表示为下图\",{\"1\":{\"87\":1}}],[\"他们之间的关系可以用下图表示\",{\"1\":{\"86\":1}}],[\"他们会根据\",{\"1\":{\"228\":1}}],[\"他们根据各自的特点对图片进行处理后\",{\"1\":{\"211\":1}}],[\"他们都继承自powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"他们都是concurrency并行执行\",{\"1\":{\"95\":1}}],[\"他们提供了animation<t>\",{\"1\":{\"186\":1}}],[\"他们相交的区域也从圆变为圆角\",{\"1\":{\"173\":1}}],[\"他们有自己的队列\",{\"1\":{\"141\":1}}],[\"他们的关系大致如图\",{\"1\":{\"372\":1}}],[\"他们的关系如下\",{\"1\":{\"127\":1,\"157\":1}}],[\"他们的具体实现在timer\",{\"1\":{\"105\":1}}],[\"他们的执行顺序如下\",{\"1\":{\"95\":1}}],[\"他的主要实现是\",{\"1\":{\"396\":1}}],[\"他的主要逻辑在\",{\"1\":{\"227\":1}}],[\"他的主要逻辑都在statelesswidget\",{\"1\":{\"126\":1}}],[\"他的this引用就已经被发布出去了\",{\"1\":{\"317\":1}}],[\"他的逻辑在network\",{\"1\":{\"201\":1}}],[\"他的逻辑如下\",{\"1\":{\"126\":1}}],[\"他的构造函数分别是\",{\"1\":{\"200\":1}}],[\"他的obtainkey\",{\"1\":{\"196\":1}}],[\"他的两个构造方法分别是\",{\"1\":{\"161\":1}}],[\"他的子类是有限的\",{\"1\":{\"322\":1}}],[\"他的子类也可以根据需要重写此方法以返回自己的\",{\"1\":{\"228\":1}}],[\"他的子类\",{\"1\":{\"155\":1}}],[\"他的子widget可以通过他来获取这些状态\",{\"1\":{\"128\":1}}],[\"他的线程和android的ui线程绑定\",{\"1\":{\"136\":1}}],[\"他的继承关系是\",{\"1\":{\"128\":1}}],[\"他的内容比较简单\",{\"1\":{\"126\":1}}],[\"他的child也正是我们的text\",{\"1\":{\"125\":1}}],[\"他的child也就是rootwidget\",{\"1\":{\"121\":1}}],[\"他的几个属性如下\",{\"1\":{\"124\":1}}],[\"他的native层实现名称是ioservice\",{\"1\":{\"114\":1}}],[\"他的定义如下\",{\"1\":{\"111\":1}}],[\"他的实现在native层的eventhander中名为event\",{\"1\":{\"108\":1}}],[\"他的实现如下\",{\"1\":{\"108\":1}}],[\"他的实现是\",{\"1\":{\"105\":1}}],[\"他的实现应该是线程安全的\",{\"1\":{\"87\":1}}],[\"他的\",{\"1\":{\"94\":1,\"197\":1}}],[\"他的api和hashmap相差无几\",{\"1\":{\"49\":1}}],[\"他的优点主要在于没有对保存的数据二次封装\",{\"1\":{\"44\":1}}],[\"他是将key和value全部保存在一个数组中\",{\"1\":{\"44\":1}}],[\"日志\",{\"1\":{\"417\":1}}],[\"日记categories\",{\"1\":{\"417\":1}}],[\"日期\",{\"1\":{\"347\":1}}],[\"日本\",{\"1\":{\"321\":1}}],[\"日常开发中\",{\"1\":{\"44\":1}}],[\"日后逐渐深入源码\",{\"1\":{\"0\":1}}],[\"两\",{\"1\":{\"459\":1}}],[\"两条这样的路径之前的值的大小没有一定的关系\",{\"1\":{\"439\":1}}],[\"两部分\",{\"1\":{\"407\":1}}],[\"两大部分\",{\"1\":{\"146\":1}}],[\"两种计算java对象大小的方法\",{\"1\":{\"282\":1}}],[\"两种加载图片的方式\",{\"1\":{\"211\":1}}],[\"两种方案展示图片的过程\",{\"1\":{\"211\":1}}],[\"两种方法使用到的resources一个是app的\",{\"1\":{\"53\":1}}],[\"两种\",{\"1\":{\"146\":1}}],[\"两种情况\",{\"1\":{\"55\":1}}],[\"两者占用内存小\",{\"1\":{\"287\":1}}],[\"两者可以相互访问\",{\"1\":{\"87\":1}}],[\"两者的不同之处在于\",{\"1\":{\"134\":1}}],[\"两者的差异在于在实现coordinatorlayout\",{\"1\":{\"55\":1}}],[\"两者的连线就是aidl\",{\"1\":{\"32\":1}}],[\"两者不一致\",{\"1\":{\"49\":1}}],[\"两者一致\",{\"1\":{\"49\":1}}],[\"两个顶点之间有边连接\",{\"1\":{\"433\":1}}],[\"两个最小的字符\",{\"1\":{\"432\":1}}],[\"两个app可以相互访问代码\",{\"1\":{\"421\":1}}],[\"两个流中的值一一对应\",{\"1\":{\"344\":1}}],[\"两个是同一个对象\",{\"1\":{\"126\":1}}],[\"两个控制点的坐标为\",{\"1\":{\"63\":1}}],[\"两个原子操作\",{\"1\":{\"58\":1}}],[\"两个方法都只是用来初始化了imessenger\",{\"1\":{\"43\":1}}],[\"两个构造方法我们也可以知道\",{\"1\":{\"43\":1}}],[\"取出\",{\"1\":{\"432\":1}}],[\"取出一个task并运行\",{\"1\":{\"391\":1}}],[\"取得其最大值\",{\"1\":{\"238\":1}}],[\"取得服务端的messenger\",{\"1\":{\"43\":1}}],[\"取值\",{\"1\":{\"220\":1,\"369\":1}}],[\"取自\",{\"1\":{\"182\":1}}],[\"取的是主线程的looper\",{\"1\":{\"80\":1}}],[\"取消网络请求cancel\",{\"1\":{\"365\":1}}],[\"取消之前的收集器\",{\"1\":{\"337\":1}}],[\"取消所有的子协程来让主协程结束\",{\"1\":{\"328\":1}}],[\"取消子协程\",{\"1\":{\"328\":1}}],[\"取消接收来自这个通道的剩余元素\",{\"1\":{\"328\":1}}],[\"取消服务\",{\"1\":{\"21\":1}}],[\"取消绑定时回调\",{\"1\":{\"19\":1}}],[\"取消闹钟\",{\"0\":{\"8\":1}}],[\"接着再从无序部分取出一个元素与有序部分的元素依次比较\",{\"1\":{\"289\":1}}],[\"接管\",{\"1\":{\"223\":1}}],[\"接受\",{\"1\":{\"156\":1}}],[\"接下来会插入数据\",{\"1\":{\"280\":1}}],[\"接下来分析一下之前提到的\",{\"1\":{\"211\":1}}],[\"接下来实现一种使用inheritedwidget的方法\",{\"1\":{\"130\":1}}],[\"接下来实现一种基础的使用inheritedwidget的方法\",{\"1\":{\"130\":1}}],[\"接下来我们逐一分析一下他们的源码\",{\"1\":{\"227\":1}}],[\"接下来我们分析一下text是如何被加入widget\",{\"1\":{\"126\":1}}],[\"接下来我们看一下前2步分别是怎么实现的\",{\"1\":{\"114\":1}}],[\"接下来便按照之前的逻辑\",{\"1\":{\"94\":1}}],[\"接下来看一下在主线程和后台线程之间是如何依靠handler机制来传递消息的\",{\"1\":{\"80\":1}}],[\"接下来\",{\"1\":{\"72\":1}}],[\"接口clinit\",{\"1\":{\"279\":1}}],[\"接口类除外\",{\"1\":{\"279\":1}}],[\"接口方法解析\",{\"1\":{\"278\":1}}],[\"接口解析\",{\"1\":{\"278\":1}}],[\"接口\",{\"1\":{\"158\":1,\"224\":1,\"279\":1,\"298\":1}}],[\"接口的实现类也无需执行接口的clinit\",{\"1\":{\"279\":1}}],[\"接口的实现最终接收此调用时\",{\"1\":{\"43\":1}}],[\"接口的构造方法clinit\",{\"1\":{\"279\":1}}],[\"接口的binder对象\",{\"1\":{\"58\":1}}],[\"接口定义语言\",{\"1\":{\"43\":1}}],[\"接收方的版本多扩展了一些字段\",{\"1\":{\"306\":1}}],[\"接收外部所有的滑动事件全部归集到\",{\"1\":{\"212\":1}}],[\"接收图片成功加载的事件\",{\"1\":{\"211\":1}}],[\"接收传入的方法\",{\"1\":{\"134\":1}}],[\"接收数据\",{\"1\":{\"79\":1}}],[\"接收\",{\"1\":{\"40\":1,\"328\":1}}],[\"接收服务端返回的msg\",{\"1\":{\"20\":1}}],[\"接收客户端每个调用的回调\",{\"1\":{\"20\":1}}],[\"关键词参数\",{\"1\":{\"369\":1}}],[\"关键就在\",{\"1\":{\"193\":1}}],[\"关键方法\",{\"1\":{\"183\":1}}],[\"关键字用于修改远程调用的行为\",{\"1\":{\"43\":1}}],[\"关闭通道并从中删除所有缓存的元素\",{\"1\":{\"328\":1}}],[\"关闭通道\",{\"1\":{\"328\":1}}],[\"关闭dart\",{\"1\":{\"115\":2}}],[\"关闭硬件加速\",{\"1\":{\"57\":1}}],[\"关于oob\",{\"1\":{\"391\":1}}],[\"关于枚举的更详细资料\",{\"1\":{\"294\":1}}],[\"关于是否应该在android中使用枚举类\",{\"1\":{\"286\":1}}],[\"关于hashmap的一些按位与计算的问题\",{\"1\":{\"280\":1}}],[\"关于动画的开始\",{\"1\":{\"146\":1,\"157\":1}}],[\"关于他主要有两个方法\",{\"1\":{\"100\":1}}],[\"关于fragment加入到activity的demo在官方文档有\",{\"1\":{\"94\":1}}],[\"关于构造函数\",{\"1\":{\"80\":1}}],[\"关于硬件加速更详细的说明可以参考这里\",{\"1\":{\"57\":1}}],[\"关于android中使用枚举和常量所占用的大小对比romainguy有下图的对比\",{\"1\":{\"286\":1}}],[\"关于android\",{\"1\":{\"21\":1}}],[\"关于\",{\"0\":{\"0\":1}}],[\"进而可以操作类的私有变量\",{\"1\":{\"295\":1}}],[\"进而决定了view的宽高\",{\"1\":{\"65\":1}}],[\"进一步封装\",{\"1\":{\"235\":1}}],[\"进阶使用\",{\"0\":{\"172\":1}}],[\"进入之后\",{\"1\":{\"419\":1}}],[\"进入仓库主页\",{\"1\":{\"417\":1}}],[\"进入存放\",{\"1\":{\"414\":1}}],[\"进入和推出的交互逻辑\",{\"1\":{\"400\":1}}],[\"进入要所要上传文件的目录\",{\"1\":{\"347\":1}}],[\"进入android\",{\"1\":{\"347\":1}}],[\"进入android系统\",{\"1\":{\"60\":1}}],[\"进入\",{\"1\":{\"347\":1,\"348\":1,\"417\":1}}],[\"进入到源码看一下\",{\"1\":{\"43\":1}}],[\"进行数据绑定\",{\"1\":{\"387\":1}}],[\"进行解密\",{\"1\":{\"296\":1}}],[\"进行比较\",{\"1\":{\"289\":1}}],[\"进行通信\",{\"1\":{\"211\":1}}],[\"进行跨进程通信\",{\"1\":{\"58\":1}}],[\"进行更新\",{\"1\":{\"13\":1}}],[\"进程\",{\"1\":{\"60\":1,\"249\":1}}],[\"进程1访问资源时对信号量进行等待操作p\",{\"1\":{\"58\":1}}],[\"进程1将数据写入到管道\",{\"1\":{\"58\":1}}],[\"进程2从管道中读取数据\",{\"1\":{\"58\":1}}],[\"进程对共享对象的写操作对于其他也使用到该共享对象的进程是可见的\",{\"1\":{\"58\":1}}],[\"进程是资源分配的基本单位\",{\"1\":{\"58\":1}}],[\"代\",{\"1\":{\"429\":1}}],[\"代替默认的\",{\"1\":{\"416\":1}}],[\"代理\",{\"1\":{\"159\":1}}],[\"代理等改变系统原有的行为以达到自己的目的\",{\"1\":{\"70\":1}}],[\"代理类\",{\"1\":{\"58\":1}}],[\"代码编号\",{\"1\":{\"361\":1}}],[\"代码块捕获的异常仅仅应该被用来作为额外调试信息的资源\",{\"1\":{\"329\":1}}],[\"代码上下文的正确方式\",{\"1\":{\"327\":1,\"339\":1}}],[\"代码中的注解替换为真正要实现的逻辑\",{\"1\":{\"300\":1}}],[\"代码中的参数顺序一致\",{\"1\":{\"115\":1}}],[\"代码如下\",{\"1\":{\"289\":2,\"370\":1}}],[\"代码缓存区\",{\"1\":{\"249\":1}}],[\"代码会执行final\",{\"1\":{\"226\":1}}],[\"代码会执行到outerdelta\",{\"1\":{\"226\":1}}],[\"代码示例\",{\"0\":{\"130\":1}}],[\"代码分析\",{\"0\":{\"96\":1,\"102\":1}}],[\"代码参考\",{\"1\":{\"95\":1}}],[\"代码有节略\",{\"1\":{\"80\":1}}],[\"代码设置\",{\"1\":{\"55\":1}}],[\"代码\",{\"0\":{\"69\":1},\"1\":{\"42\":1,\"361\":1,\"392\":1}}],[\"代表一项单独的任务\",{\"1\":{\"404\":1}}],[\"代表了一系列的\",{\"1\":{\"79\":1}}],[\"代表\",{\"1\":{\"41\":2,\"79\":1}}],[\"代表原始位置信息的left\",{\"1\":{\"41\":1}}],[\"kshutdown\",{\"1\":{\"391\":2}}],[\"kforbidmarked\",{\"1\":{\"383\":1}}],[\"kfreeport\",{\"1\":{\"115\":1}}],[\"kvmisolatename\",{\"1\":{\"383\":1}}],[\"khtml\",{\"1\":{\"370\":1}}],[\"kw\",{\"1\":{\"369\":1}}],[\"kproperty<\",{\"1\":{\"322\":4}}],[\"kg\",{\"1\":{\"296\":3}}],[\"k已经被回收了\",{\"1\":{\"288\":1}}],[\"kreleasemode\",{\"1\":{\"198\":1}}],[\"kdebugmode\",{\"1\":{\"147\":1,\"191\":1,\"193\":1}}],[\"kdeletedport\",{\"1\":{\"115\":1}}],[\"kok\",{\"1\":{\"391\":9}}],[\"koobpriority\",{\"1\":{\"376\":1,\"391\":4}}],[\"kozsir\",{\"1\":{\"127\":1}}],[\"kotlincn\",{\"1\":{\"345\":1}}],[\"kotlin笔记之flow\",{\"0\":{\"335\":1}}],[\"kotlin的独门秘籍reified实化类型参数\",{\"1\":{\"326\":1,\"334\":1}}],[\"kotlin官方推荐一下两种方式\",{\"1\":{\"326\":1}}],[\"kotlinx\",{\"1\":{\"322\":4,\"328\":2}}],[\"kotlin协程需要单独添加依赖\",{\"1\":{\"322\":1}}],[\"kotlin也存在java泛型所具有的类型擦除问题\",{\"1\":{\"322\":1}}],[\"kotlin提供了一种尾递归优化的方法\",{\"1\":{\"322\":1}}],[\"kotlin学习笔记3\",{\"0\":{\"327\":1}}],[\"kotlin学习笔记2\",{\"0\":{\"322\":1}}],[\"kotlin学习笔记1\",{\"0\":{\"321\":1}}],[\"kotlin环境\",{\"1\":{\"88\":1}}],[\"kotlin\",{\"1\":{\"42\":1,\"86\":1,\"88\":1,\"325\":1,\"326\":2,\"334\":1,\"335\":1,\"344\":1}}],[\"kclassid\",{\"1\":{\"116\":1}}],[\"kminint\",{\"1\":{\"115\":1}}],[\"kmask2\",{\"1\":{\"115\":2}}],[\"kmask1\",{\"1\":{\"115\":2}}],[\"knife\",{\"1\":{\"298\":1}}],[\"knewport\",{\"1\":{\"115\":1}}],[\"knormalpriority\",{\"1\":{\"115\":1,\"389\":1,\"391\":4}}],[\"known\",{\"1\":{\"177\":1,\"396\":1}}],[\"know\",{\"1\":{\"96\":1,\"104\":2,\"108\":1,\"179\":1,\"316\":1}}],[\"kliveport\",{\"1\":{\"115\":1}}],[\"karray\",{\"1\":{\"115\":1}}],[\"kapt\",{\"1\":{\"88\":3}}],[\"kisaotruntime\",{\"1\":{\"383\":3}}],[\"kisolateliboobmsg\",{\"1\":{\"376\":1}}],[\"kisweb\",{\"1\":{\"118\":1}}],[\"kinvalidthreadjoinid\",{\"1\":{\"115\":1}}],[\"kinterruptmessagesize\",{\"1\":{\"108\":3}}],[\"kill\",{\"1\":{\"59\":1,\"373\":4,\"376\":1}}],[\"k\",{\"0\":{\"50\":1},\"1\":{\"115\":1,\"280\":2,\"288\":2,\"302\":2,\"327\":1,\"361\":1}}],[\"ktimedout\",{\"1\":{\"391\":1}}],[\"ktimerid\",{\"1\":{\"108\":1}}],[\"kthreadinnative\",{\"1\":{\"383\":1}}],[\"kthreadd进程\",{\"1\":{\"60\":1}}],[\"ktransparentimage\",{\"1\":{\"201\":1}}],[\"kt\",{\"1\":{\"41\":1,\"61\":1,\"322\":1}}],[\"ketset\",{\"1\":{\"438\":2}}],[\"keptalive\",{\"1\":{\"198\":1}}],[\"kept\",{\"1\":{\"115\":1,\"180\":1}}],[\"kernel转换\",{\"1\":{\"393\":1}}],[\"kernelisolate\",{\"1\":{\"383\":3}}],[\"kernel层\",{\"1\":{\"60\":1}}],[\"kernel\",{\"1\":{\"60\":1,\"382\":3,\"383\":5,\"387\":27,\"392\":6,\"393\":3,\"394\":2,\"395\":3,\"396\":2}}],[\"keyarr\",{\"1\":{\"437\":4,\"438\":4}}],[\"keywords\",{\"1\":{\"369\":2}}],[\"key=value\",{\"1\":{\"358\":1,\"360\":1}}],[\"keygen\",{\"1\":{\"347\":1}}],[\"keygenerator\",{\"1\":{\"296\":2}}],[\"keyboarddismissbehavior\",{\"1\":{\"227\":1,\"235\":1}}],[\"keytomd5\",{\"1\":{\"201\":1}}],[\"key是hero\",{\"1\":{\"178\":1}}],[\"key是创建renderobjecttowidgetadapter时候创建的globalobjectkey\",{\"1\":{\"121\":1}}],[\"keyedsubtree\",{\"1\":{\"176\":1}}],[\"keyevent\",{\"1\":{\"13\":4}}],[\"keyset\",{\"1\":{\"287\":1}}],[\"keys\",{\"1\":{\"48\":3,\"287\":1,\"347\":2,\"437\":1,\"438\":2}}],[\"keycode\",{\"1\":{\"13\":1}}],[\"key\",{\"0\":{\"45\":1,\"46\":1,\"47\":1,\"50\":1,\"51\":1,\"52\":1},\"1\":{\"11\":1,\"20\":1,\"45\":5,\"46\":4,\"47\":4,\"49\":16,\"50\":1,\"51\":2,\"54\":5,\"65\":1,\"69\":4,\"72\":4,\"120\":1,\"121\":5,\"122\":8,\"125\":6,\"126\":8,\"130\":16,\"131\":8,\"143\":1,\"147\":4,\"154\":4,\"155\":4,\"156\":4,\"172\":4,\"175\":4,\"176\":2,\"180\":1,\"188\":5,\"196\":10,\"198\":13,\"201\":12,\"202\":4,\"206\":2,\"207\":2,\"209\":5,\"211\":1,\"280\":6,\"287\":1,\"288\":4,\"296\":7,\"321\":1,\"347\":5,\"361\":2,\"428\":2,\"440\":2,\"441\":8,\"451\":9}}],[\"keepalive\",{\"1\":{\"180\":1,\"197\":2,\"198\":1}}],[\"keepplaceholder\",{\"1\":{\"176\":2}}],[\"keep\",{\"1\":{\"0\":1,\"14\":3,\"80\":1,\"115\":1,\"391\":1}}],[\"子节点比插入值小的地方\",{\"1\":{\"440\":1}}],[\"子节点的关键字\",{\"1\":{\"439\":1}}],[\"子句查询\",{\"1\":{\"334\":1}}],[\"子句\",{\"1\":{\"334\":4}}],[\"子协程执行完毕才会退出\",{\"1\":{\"323\":2}}],[\"子函数\",{\"1\":{\"322\":2}}],[\"子线程run\",{\"1\":{\"297\":1}}],[\"子类如果有与父类同名方法\",{\"1\":{\"369\":1}}],[\"子类继承父类\",{\"1\":{\"369\":1}}],[\"子类方法不会自己调用父类方法\",{\"1\":{\"369\":1}}],[\"子类最多返回和父类一样范围的参数\",{\"1\":{\"322\":1}}],[\"子类至少接收和父类一样范围的参数\",{\"1\":{\"322\":1}}],[\"子类等不受影响\",{\"1\":{\"279\":1}}],[\"子类只需重写\",{\"1\":{\"159\":1}}],[\"子类必须实现此方法\",{\"1\":{\"151\":1}}],[\"子类可以选择自己主动监听\",{\"1\":{\"152\":1}}],[\"子类可以使用其获取对应的\",{\"1\":{\"149\":1}}],[\"子类可以实现该listener的方法\",{\"1\":{\"35\":1}}],[\"子类在此方法内部\",{\"1\":{\"148\":1}}],[\"子类\",{\"1\":{\"146\":1,\"152\":1,\"154\":1,\"157\":1,\"184\":1}}],[\"子view是imageview\",{\"1\":{\"55\":1}}],[\"子window\",{\"1\":{\"41\":1}}],[\"zzg1229059735\",{\"1\":{\"288\":1}}],[\"zi\",{\"1\":{\"288\":1}}],[\"zip将两个流\",{\"1\":{\"327\":1}}],[\"zip\",{\"1\":{\"274\":1,\"327\":1,\"344\":1}}],[\"zero\",{\"1\":{\"104\":1,\"106\":5,\"107\":4,\"108\":1,\"109\":3,\"152\":1,\"162\":1,\"231\":1,\"239\":1}}],[\"zone可以理解为一个沙盒\",{\"1\":{\"145\":1}}],[\"zone的回调\",{\"1\":{\"111\":1,\"112\":1}}],[\"zone是抽象类\",{\"1\":{\"105\":1}}],[\"zones\",{\"1\":{\"102\":1}}],[\"zonedelegate\",{\"1\":{\"96\":1}}],[\"zonefunction\",{\"1\":{\"96\":1}}],[\"zone\",{\"1\":{\"96\":16,\"103\":3,\"104\":12,\"105\":6,\"115\":2,\"144\":1,\"302\":6,\"382\":1,\"383\":2,\"389\":20}}],[\"zygote进程孵化的第一个app进程\",{\"1\":{\"60\":1}}],[\"zygote进程\",{\"1\":{\"60\":2}}],[\"zh\",{\"1\":{\"417\":1}}],[\"zhy\",{\"1\":{\"362\":1,\"364\":3,\"365\":2}}],[\"zhihu\",{\"1\":{\"58\":1}}],[\"zhang31jian\",{\"1\":{\"54\":1}}],[\"zhushou91\",{\"1\":{\"54\":1}}],[\"z\",{\"1\":{\"41\":4,\"171\":1,\"302\":2,\"346\":1,\"357\":1,\"383\":1}}],[\"让您摆脱编写样板代码的工作并简化复杂任务\",{\"1\":{\"399\":1}}],[\"让我推翻了上一次的结论\",{\"1\":{\"302\":1}}],[\"让我们在用反射时访问私有变量\",{\"1\":{\"295\":1}}],[\"让我们分别看一下他们是如何获取的\",{\"1\":{\"209\":1}}],[\"让我们分析一下这个\",{\"1\":{\"126\":1}}],[\"让我们来分别看一下\",{\"1\":{\"205\":1}}],[\"让我们来分析一下sendport\",{\"1\":{\"112\":1}}],[\"让我们再看一下\",{\"1\":{\"213\":1}}],[\"让我们再看一下center的widget\",{\"1\":{\"122\":1}}],[\"让我们再看一下他的具体实现\",{\"1\":{\"112\":1}}],[\"让我们接下来一个一个分析一下\",{\"1\":{\"117\":1}}],[\"让我们使用flutter\",{\"1\":{\"117\":1}}],[\"让我们运行一个\",{\"1\":{\"117\":1}}],[\"让我们挨个分析一下\",{\"1\":{\"115\":1}}],[\"让我们看一下他是怎么来的\",{\"1\":{\"386\":1}}],[\"让我们看一下在native中是如何找到当前的isolate的\",{\"1\":{\"377\":1}}],[\"让我们看一下这三个值的来历\",{\"1\":{\"238\":1}}],[\"让我们看一下这个方法的实现\",{\"1\":{\"111\":1}}],[\"让我们看一下flexible的源码\",{\"1\":{\"131\":1}}],[\"让我们看一下attachrenderobject的实现\",{\"1\":{\"127\":1}}],[\"让我们看一下super\",{\"1\":{\"127\":1}}],[\"让我们看一下上述方法的具体实现\",{\"1\":{\"96\":1}}],[\"让我们先看一下第一个方法\",{\"1\":{\"100\":1}}],[\"让child进行layout\",{\"1\":{\"238\":1}}],[\"让scrollable知道之后做出蓝色波纹\",{\"1\":{\"226\":1}}],[\"让scrollable绘制蓝色波纹\",{\"1\":{\"226\":1}}],[\"让inner开始滑动\",{\"1\":{\"226\":1}}],[\"让outer\",{\"1\":{\"226\":1}}],[\"让\",{\"1\":{\"182\":1}}],[\"让其实现hasfragmentinjector即可\",{\"1\":{\"94\":1}}],[\"让window显示在锁屏界面上\",{\"1\":{\"41\":1}}],[\"让你深入理解\",{\"1\":{\"22\":1}}],[\"之刨根问底\",{\"1\":{\"297\":1}}],[\"之四\",{\"1\":{\"279\":1}}],[\"之所以不会\",{\"1\":{\"220\":1}}],[\"之下所有区域的\",{\"1\":{\"212\":1}}],[\"之间\",{\"1\":{\"186\":1}}],[\"之间时调用\",{\"1\":{\"184\":1}}],[\"之间的桥梁\",{\"1\":{\"401\":1}}],[\"之间的跳转由\",{\"1\":{\"171\":1}}],[\"之间的依赖关系\",{\"1\":{\"55\":1}}],[\"之外\",{\"1\":{\"150\":1,\"153\":1,\"156\":1,\"159\":1,\"202\":1}}],[\"之外的交给其他window处理\",{\"1\":{\"41\":1}}],[\"之widget数据共享之inheritedwidget\",{\"1\":{\"130\":1}}],[\"之类\",{\"1\":{\"227\":1}}],[\"之类中\",{\"1\":{\"129\":1}}],[\"之类的方法\",{\"1\":{\"80\":1}}],[\"之\",{\"1\":{\"127\":1,\"458\":1}}],[\"之后将该顶点打印\",{\"1\":{\"438\":1}}],[\"之后打开同步的项目\",{\"1\":{\"419\":1}}],[\"之后win\",{\"1\":{\"411\":1}}],[\"之后就可以在activity或者fragment中获取该导航的实力\",{\"1\":{\"400\":1}}],[\"之后就进入到选择同步的仓库\",{\"1\":{\"347\":1}}],[\"之后经过vm再移除一些不可达方法\",{\"1\":{\"396\":1}}],[\"之后才可以根据遍历的规则切换到下一子树\",{\"1\":{\"346\":1}}],[\"之后才继续执行普通event\",{\"1\":{\"101\":1}}],[\"之后再将拍好序的数组合并\",{\"1\":{\"459\":1}}],[\"之后再根据找到的根节点将中序排序分为左\",{\"1\":{\"346\":1}}],[\"之后再执行下一轮的flow项目\",{\"1\":{\"327\":1}}],[\"之后再在使用完毕后同步到主内存中\",{\"1\":{\"317\":1}}],[\"之后必须调用本方法\",{\"1\":{\"306\":1}}],[\"之后必须调用out\",{\"1\":{\"306\":1}}],[\"之后他们都可以回到锁池竞争该对象的锁\",{\"1\":{\"297\":1}}],[\"之后的使用中就不需要再去反复创建了\",{\"1\":{\"363\":1}}],[\"之后的\",{\"1\":{\"231\":1}}],[\"之后滑动视图中的\",{\"1\":{\"223\":1}}],[\"之后\",{\"1\":{\"190\":1,\"223\":1,\"238\":1}}],[\"之后在\",{\"1\":{\"116\":1}}],[\"之后我们就可以使用\",{\"1\":{\"86\":1}}],[\"之后用户态就可以通过操作这段虚拟地址来操作内存了\",{\"1\":{\"58\":1}}],[\"之前发布的几个app\",{\"0\":{\"398\":1}}],[\"之前优化的条件不满足了\",{\"1\":{\"396\":1}}],[\"之前的代码在一个单独的协程运行\",{\"1\":{\"327\":1}}],[\"之前的\",{\"1\":{\"231\":1}}],[\"之前的文章\",{\"1\":{\"0\":1}}],[\"之前在\",{\"1\":{\"226\":1}}],[\"之前提到的extendedimageprovider为\",{\"1\":{\"202\":1}}],[\"之前分析的\",{\"1\":{\"154\":1}}],[\"之前调用\",{\"1\":{\"93\":1}}],[\"之前\",{\"1\":{\"13\":1}}],[\"都需要再次重新创建对应的静态网页\",{\"1\":{\"405\":1}}],[\"都执行了run\",{\"1\":{\"389\":1}}],[\"都合法\",{\"1\":{\"349\":1}}],[\"都可以用\",{\"1\":{\"306\":1}}],[\"都不能将\",{\"1\":{\"291\":1}}],[\"都不能改变view的定位\",{\"1\":{\"41\":1}}],[\"都必须执行垃圾回收gc\",{\"1\":{\"287\":1}}],[\"都应用的是\",{\"1\":{\"226\":1}}],[\"都应该以此宽度为准来获取其他控件的大小\",{\"1\":{\"81\":1}}],[\"都使用\",{\"1\":{\"217\":1}}],[\"都采用了imagecache来管理图片缓存\",{\"1\":{\"211\":1}}],[\"都继承自\",{\"1\":{\"182\":1,\"230\":1}}],[\"都提供了创建\",{\"1\":{\"178\":1}}],[\"都被移除\",{\"1\":{\"171\":1}}],[\"都是将一个大的待排序数组\",{\"1\":{\"467\":1}}],[\"都是红色违反了规则3\",{\"1\":{\"458\":1}}],[\"都是抽象数据结构\",{\"1\":{\"445\":1}}],[\"都是在dart\",{\"1\":{\"387\":1}}],[\"都是先调用rawreceiveport获取rawreceiveport\",{\"1\":{\"378\":1}}],[\"都是继承自\",{\"1\":{\"228\":1,\"230\":1}}],[\"都是继承自官方\",{\"1\":{\"200\":1}}],[\"都是所处的\",{\"1\":{\"213\":1}}],[\"都是\",{\"1\":{\"194\":1}}],[\"都是随着时间线性变化\",{\"1\":{\"157\":1}}],[\"都是属于implicitly\",{\"1\":{\"146\":1,\"157\":1}}],[\"都要执行没有被执行的micro\",{\"1\":{\"109\":1}}],[\"都具有独立的地址空间\",{\"1\":{\"60\":1}}],[\"都默认持有这个binder的引用\",{\"1\":{\"58\":1}}],[\"都会是默认的值或者是在父类无参构造函数中初始化的值\",{\"1\":{\"307\":1}}],[\"都会使得scrollab的viewport也就是我们这里的\",{\"1\":{\"237\":1}}],[\"都会对齐添加监听\",{\"1\":{\"237\":1}}],[\"都会调用paintingbinding\",{\"1\":{\"197\":1}}],[\"都会调用object\",{\"1\":{\"49\":1}}],[\"都会执行\",{\"1\":{\"179\":1}}],[\"都会执行ondependentviewchanged方法\",{\"1\":{\"55\":1}}],[\"都会通过\",{\"1\":{\"161\":1}}],[\"都会保证\",{\"1\":{\"106\":1}}],[\"都会检查执行micro\",{\"1\":{\"101\":1}}],[\"都会检查并执行event\",{\"1\":{\"101\":1}}],[\"都会被当做一个个event放入到event\",{\"1\":{\"95\":1}}],[\"都会运行在同一线程\",{\"1\":{\"36\":1}}],[\"通用数据结构速度统计\",{\"1\":{\"445\":1}}],[\"通用数据结构\",{\"1\":{\"445\":1}}],[\"通用方法\",{\"1\":{\"372\":1}}],[\"通道\",{\"1\":{\"334\":2}}],[\"通常会丢弃优化后的代码\",{\"1\":{\"396\":1}}],[\"通常意味着thread被暂停\",{\"1\":{\"396\":1}}],[\"通常的规则是\",{\"1\":{\"329\":1}}],[\"通常是\",{\"1\":{\"155\":1,\"156\":1,\"184\":1}}],[\"通常是一个抽象类或者接口\",{\"1\":{\"84\":1}}],[\"通常用在interaction\",{\"1\":{\"129\":1}}],[\"通信原语表示未来可知\",{\"1\":{\"334\":1}}],[\"通信\",{\"1\":{\"60\":2,\"111\":1}}],[\"通知\",{\"1\":{\"221\":1}}],[\"通知监听者\",{\"1\":{\"218\":1}}],[\"通知结果\",{\"1\":{\"211\":1}}],[\"通知原先的inheritedelement的\",{\"1\":{\"128\":1}}],[\"通知event\",{\"1\":{\"109\":1}}],[\"通知接收信号的进程发生了什么事情\",{\"1\":{\"58\":1}}],[\"通知view重绘\",{\"1\":{\"41\":2}}],[\"通过不同的方法拆分成小的子数组\",{\"1\":{\"467\":1}}],[\"通过反射加载类\",{\"0\":{\"427\":1}}],[\"通过反射获取到类中使用注解的变量\",{\"1\":{\"298\":1}}],[\"通过hexo可以将我们写的markdown文档格式化为静态网页\",{\"1\":{\"405\":1}}],[\"通过hash值计算value应该保存的位置i\",{\"1\":{\"280\":1}}],[\"通过官方文档可知\",{\"1\":{\"400\":1}}],[\"通过databinding与viewmodel中的可观察数据livedata绑定在一起\",{\"1\":{\"399\":1}}],[\"通过dart的\",{\"1\":{\"115\":1}}],[\"通过循环遍历获取所有文章列表信息\",{\"1\":{\"370\":1}}],[\"通过okhttprequestbuilder收集网络请求的属性并传递给okhttprequest\",{\"1\":{\"365\":1}}],[\"通过travis提供的免费ci技术\",{\"1\":{\"405\":1}}],[\"通过threadlocal\",{\"1\":{\"325\":1}}],[\"通过texture和ffi技术借助原生图片加载库加载图片\",{\"1\":{\"203\":1}}],[\"通过这个特性我们可以确保在反序列化的时候也能实现单例\",{\"1\":{\"305\":1}}],[\"通过这种算法\",{\"1\":{\"296\":1}}],[\"通过遍历\",{\"1\":{\"300\":1}}],[\"通过普通类加载器加载\",{\"1\":{\"274\":1}}],[\"通过将其设置为自定义的classloader可以在加载类的时候做一些特殊的事情\",{\"1\":{\"272\":1}}],[\"通过监听offset的变化展示children的一部分来实现滑动的视觉效果\",{\"1\":{\"232\":1}}],[\"通过根据传入的\",{\"1\":{\"227\":1}}],[\"通过powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"通过重写\",{\"1\":{\"209\":1}}],[\"通过重写handler\",{\"1\":{\"72\":1}}],[\"通过上面的分析\",{\"1\":{\"207\":1,\"378\":1}}],[\"通过上述步骤\",{\"1\":{\"226\":1}}],[\"通过上述代码\",{\"1\":{\"115\":1,\"227\":1}}],[\"通过上述分析\",{\"1\":{\"36\":1,\"122\":1}}],[\"通过对比\",{\"1\":{\"207\":1}}],[\"通过rawimage传入到canvas\",{\"1\":{\"193\":1}}],[\"通过receiveport\",{\"1\":{\"136\":1}}],[\"通过imageprovider\",{\"1\":{\"196\":1}}],[\"通过imageprovider获取imagestream\",{\"1\":{\"190\":1}}],[\"通过intent传递出去的imguri\",{\"1\":{\"2\":1}}],[\"通过指定cachewidth和cacheheight可以让引擎按照指定大小解码图片\",{\"1\":{\"188\":1}}],[\"通过二者的配合\",{\"1\":{\"172\":1}}],[\"通过使用\",{\"1\":{\"172\":1}}],[\"通过传入的\",{\"1\":{\"168\":1}}],[\"通过context反射获取插件app中的资源\",{\"0\":{\"424\":1}}],[\"通过completer\",{\"1\":{\"111\":1,\"112\":1}}],[\"通过clazz\",{\"1\":{\"295\":1}}],[\"通过classloader加载r\",{\"1\":{\"420\":1}}],[\"通过class\",{\"1\":{\"295\":1}}],[\"通过channel\",{\"1\":{\"137\":1}}],[\"通过调用rebuild\",{\"1\":{\"128\":1}}],[\"通过shared\",{\"1\":{\"421\":1}}],[\"通过synchronize\",{\"1\":{\"317\":2}}],[\"通过statefulwidget更改状态state\",{\"1\":{\"134\":1}}],[\"通过statefulwidget的state\",{\"1\":{\"128\":1}}],[\"通过send方法触发ioservicecallback执行对应的io操作\",{\"1\":{\"116\":1}}],[\"通过管理element\",{\"1\":{\"127\":1}}],[\"通过widget\",{\"1\":{\"127\":1}}],[\"通过atestclsobj\",{\"1\":{\"295\":1}}],[\"通过attachrenderobject\",{\"1\":{\"121\":1}}],[\"通过animatable\",{\"1\":{\"158\":1}}],[\"通过android原生intent组件获取到其他app传来的数据\",{\"1\":{\"135\":1}}],[\"通过appcomponent找到我们在mainactivitymodule提供的对应的androidinjector\",{\"1\":{\"94\":1}}],[\"通过与ioservice跨isolate通信\",{\"1\":{\"110\":1}}],[\"通过enum的valueof\",{\"1\":{\"321\":1}}],[\"通过eventhandler发送\",{\"1\":{\"109\":1}}],[\"通过exec\",{\"1\":{\"80\":1}}],[\"通过messagehandler\",{\"1\":{\"107\":1}}],[\"通过观察上面的两份代码\",{\"1\":{\"94\":1}}],[\"通过该factory和mainactivitysubcomponent中的builder产生关联\",{\"1\":{\"94\":1}}],[\"通过之前的代码我们可以知道\",{\"1\":{\"94\":1}}],[\"通过查看其源码可以知道其背后是\",{\"1\":{\"87\":1}}],[\"通过系统检查后\",{\"1\":{\"72\":1}}],[\"通过自定义dialog类\",{\"1\":{\"66\":1}}],[\"通过自定义view画出26个字母\",{\"1\":{\"64\":1}}],[\"通过bindingadapter对xml中的数据做预处理\",{\"1\":{\"399\":1}}],[\"通过binder对象mremote执行aidlbinderinterface接口的具体方法\",{\"1\":{\"58\":1}}],[\"通过buildowner的schedulebuildfor\",{\"1\":{\"128\":1}}],[\"通过behavior将一个子view\",{\"1\":{\"55\":1}}],[\"通过如下语句获取从用户使用时赋给这些属性的值\",{\"1\":{\"56\":1}}],[\"通过在项目中生成多个渠道的文件夹\",{\"1\":{\"54\":1}}],[\"通过通过\",{\"1\":{\"54\":1}}],[\"通过getstatusbarheight\",{\"1\":{\"53\":1}}],[\"通过分别打印这两种resources可以发现\",{\"1\":{\"53\":1}}],[\"通过\",{\"1\":{\"40\":1,\"55\":2,\"111\":2,\"112\":1,\"157\":1,\"163\":1,\"202\":1,\"212\":1,\"213\":1,\"226\":2,\"227\":1,\"229\":1,\"272\":1,\"329\":1}}],[\"通过创建aidl将接口暴露给客户端\",{\"1\":{\"32\":1}}],[\"通过for循环\",{\"1\":{\"25\":1}}],[\"通过以上方案1和2的结合\",{\"1\":{\"14\":1}}],[\"通过他调用继承自view的dispatchtouchevent\",{\"1\":{\"13\":1}}],[\"景色\",{\"1\":{\"41\":1}}],[\"数字\",{\"1\":{\"369\":1,\"433\":1,\"453\":1}}],[\"数字越大重要性越低\",{\"1\":{\"74\":1}}],[\"数组是一种数据存储结构\",{\"1\":{\"450\":1}}],[\"数组元素是保存着顶点和他所有的邻接点的链表\",{\"1\":{\"433\":1}}],[\"数组只能存放定义的实际类型以及他们的子类型\",{\"1\":{\"291\":1}}],[\"数组引用类型\",{\"1\":{\"285\":1}}],[\"数组数据占用大小\",{\"1\":{\"282\":1}}],[\"数组大小固定\",{\"1\":{\"450\":1}}],[\"数组大小标记length\",{\"1\":{\"282\":1}}],[\"数组大小\",{\"1\":{\"282\":1}}],[\"数组长度\",{\"1\":{\"282\":1}}],[\"数组类的可见性与其元素类的可见性一致\",{\"1\":{\"274\":1}}],[\"数组类的元素加载\",{\"1\":{\"274\":1}}],[\"数组类不通过类加载器创建\",{\"1\":{\"274\":1}}],[\"数组类\",{\"1\":{\"274\":1}}],[\"数组\",{\"0\":{\"450\":1},\"1\":{\"250\":1,\"371\":1,\"445\":3,\"450\":1,\"451\":1}}],[\"数据大小不可预知\",{\"1\":{\"445\":1}}],[\"数据量小\",{\"1\":{\"445\":1}}],[\"数据结构\",{\"0\":{\"428\":1,\"429\":1,\"433\":1,\"439\":1,\"445\":1,\"450\":1,\"452\":1,\"454\":1,\"458\":1,\"459\":1,\"460\":1}}],[\"数据访问结构\",{\"1\":{\"403\":1}}],[\"数据访问对象\",{\"1\":{\"399\":1}}],[\"数据访问对象dao和数据库database三个层次\",{\"1\":{\"399\":1}}],[\"数据库\",{\"1\":{\"399\":1,\"403\":1}}],[\"数据库使用实现\",{\"1\":{\"399\":1}}],[\"数据库管理缓存的网络图片加载库\",{\"1\":{\"198\":1}}],[\"数据类\",{\"1\":{\"321\":1}}],[\"数据来自这里\",{\"1\":{\"287\":1}}],[\"数据区占用的大小如下\",{\"1\":{\"282\":1}}],[\"数据区\",{\"1\":{\"282\":1}}],[\"数据以数组或链表形式保存\",{\"1\":{\"280\":1}}],[\"数据拷贝1次\",{\"1\":{\"58\":1}}],[\"数据内存复制0次\",{\"1\":{\"58\":1}}],[\"数据从写端流入管道\",{\"1\":{\"58\":1}}],[\"数据复制2次\",{\"1\":{\"58\":3}}],[\"数据\",{\"1\":{\"58\":1}}],[\"数据流\",{\"1\":{\"40\":2}}],[\"数值依次递增\",{\"1\":{\"41\":1}}],[\"竖轴为y轴\",{\"1\":{\"41\":1}}],[\"尚未成文\",{\"1\":{\"41\":1,\"327\":1}}],[\"二分法查找\",{\"1\":{\"451\":1}}],[\"二叉搜索树很快\",{\"1\":{\"445\":1}}],[\"二叉搜索树\",{\"1\":{\"445\":1}}],[\"二叉搜索树因为节点要满足左子节点\",{\"1\":{\"432\":1}}],[\"二叉搜索树的最小值是左子树中最左端没有子节点的左子节点\",{\"1\":{\"431\":1}}],[\"二叉搜索树的最大值是右子树中最右端没有子节点的右子节点\",{\"1\":{\"431\":1}}],[\"二叉树\",{\"0\":{\"429\":1}}],[\"二叉树遍历算法总结\",{\"1\":{\"346\":1}}],[\"二叉树的遍历根据根节点与左右子节点的遍历顺序的不同分为三种\",{\"1\":{\"346\":1}}],[\"二次探测效果好\",{\"1\":{\"428\":1}}],[\"二次探测法\",{\"1\":{\"428\":1}}],[\"二次探测\",{\"1\":{\"428\":1}}],[\"二进制格式\",{\"1\":{\"276\":1}}],[\"二者最终还是创建了\",{\"1\":{\"207\":1}}],[\"二者都继承自widget\",{\"1\":{\"128\":1}}],[\"二者的滑动效果联动在一起\",{\"1\":{\"212\":1}}],[\"二者的runtimetype和key一样\",{\"1\":{\"126\":1}}],[\"二者的使用几乎没有差别\",{\"1\":{\"88\":1}}],[\"二者的density值不一样\",{\"1\":{\"53\":1}}],[\"二阶贝塞尔曲线\",{\"1\":{\"61\":1}}],[\"二\",{\"1\":{\"40\":1,\"293\":1,\"427\":1}}],[\"流完成\",{\"0\":{\"343\":1}}],[\"流取消\",{\"0\":{\"342\":1}}],[\"流默认运行在收集器提供的上下文中\",{\"1\":{\"339\":1}}],[\"流上下文\",{\"0\":{\"339\":1}}],[\"流的收集\",{\"0\":{\"337\":1}}],[\"流的异常有如下捕获方式\",{\"1\":{\"327\":1}}],[\"流构造器中的协程上下文默认和collect的协程上下文一致\",{\"1\":{\"327\":1}}],[\"流构建器\",{\"1\":{\"327\":1}}],[\"流程概述\",{\"1\":{\"79\":1}}],[\"流程如下\",{\"1\":{\"60\":1}}],[\"流\",{\"1\":{\"40\":1}}],[\"执行管理workrequest\",{\"1\":{\"404\":1}}],[\"执行操作\",{\"1\":{\"395\":1}}],[\"执行threadpool\",{\"1\":{\"391\":1}}],[\"执行具体的消息分发内容\",{\"1\":{\"389\":1}}],[\"执行具体的逻辑\",{\"1\":{\"115\":1}}],[\"执行ui操作\",{\"1\":{\"383\":1}}],[\"执行uri对应的library中的main方法\",{\"1\":{\"373\":1}}],[\"执行网络请求\",{\"0\":{\"365\":1}}],[\"执行对应代码\",{\"1\":{\"362\":1}}],[\"执行cls就等于执行clear\",{\"1\":{\"359\":1}}],[\"执行权限1\",{\"1\":{\"351\":1}}],[\"执行反序列化结果\",{\"1\":{\"306\":1}}],[\"执行了未检查的转换时的警告\",{\"1\":{\"298\":1}}],[\"执行了什么\",{\"1\":{\"80\":1}}],[\"执行静态方法\",{\"1\":{\"279\":1}}],[\"执行类\",{\"1\":{\"279\":1}}],[\"执行死刑\",{\"1\":{\"266\":1}}],[\"执行paintingbinding\",{\"1\":{\"196\":1}}],[\"执行performrebuild\",{\"1\":{\"128\":1}}],[\"执行其\",{\"1\":{\"178\":1}}],[\"执行一次\",{\"1\":{\"171\":1}}],[\"执行该方法\",{\"1\":{\"134\":1}}],[\"执行创建threadstartdata时传入的方法\",{\"1\":{\"115\":1}}],[\"执行析构函数\",{\"1\":{\"115\":1}}],[\"执行到这里后saver对象被回收\",{\"1\":{\"115\":1}}],[\"执行完毕后\",{\"1\":{\"297\":1}}],[\"执行完毕之后\",{\"1\":{\"115\":1}}],[\"执行完毕\",{\"1\":{\"115\":1}}],[\"执行完isolateleavescope\",{\"1\":{\"115\":1}}],[\"执行handler方法\",{\"1\":{\"111\":1,\"112\":1}}],[\"执行\",{\"1\":{\"101\":1,\"115\":2,\"181\":1,\"279\":1,\"349\":1,\"393\":1}}],[\"执行用户点击\",{\"1\":{\"95\":1}}],[\"执行时间的mfuture排队放入串行线程池中\",{\"1\":{\"80\":1}}],[\"执行后\",{\"1\":{\"80\":1}}],[\"执行相应操作\",{\"1\":{\"40\":1}}],[\"执行msg对应的处理方法\",{\"1\":{\"25\":1}}],[\"执行multidexopt操作\",{\"1\":{\"14\":1}}],[\"所在层\",{\"1\":{\"459\":1}}],[\"所在周为该年第一周\",{\"1\":{\"302\":1}}],[\"所做的那样\",{\"1\":{\"332\":1}}],[\"所做的更改也会实时更新到外部类中\",{\"1\":{\"281\":1}}],[\"所包含的日期也不一定全部都是当年的日期\",{\"1\":{\"302\":1}}],[\"所谓的通过threadlocal实现线程本地变量与其他线程隔离\",{\"1\":{\"288\":1}}],[\"所需时间为o\",{\"1\":{\"428\":1}}],[\"所需不会滑动\",{\"1\":{\"241\":1}}],[\"所需的\",{\"1\":{\"152\":1}}],[\"所创建的\",{\"1\":{\"213\":1}}],[\"所处位置的区域\",{\"1\":{\"176\":1}}],[\"所指定动作\",{\"1\":{\"79\":1}}],[\"所保存的数据个数\",{\"1\":{\"44\":1}}],[\"所有大于c的移动到右边\",{\"1\":{\"463\":1}}],[\"所有小于c的移动到左边\",{\"1\":{\"463\":1}}],[\"所有排序顺序为\",{\"1\":{\"454\":1}}],[\"所有权益归原作者所有\",{\"1\":{\"399\":1}}],[\"所有用户可见\",{\"1\":{\"349\":2}}],[\"所有节点都被完全遍历\",{\"1\":{\"346\":1}}],[\"所有同级的子协程都会被关闭\",{\"1\":{\"329\":1}}],[\"所有它的子协程也会被递归的取消\",{\"1\":{\"322\":1}}],[\"所有方法可以直接用类名调用\",{\"1\":{\"321\":1}}],[\"所有线程公用的数据保存在主内存中\",{\"1\":{\"317\":1}}],[\"所有线程共享\",{\"1\":{\"250\":1}}],[\"所有基本数据类型\",{\"1\":{\"299\":1}}],[\"所有需要保存在常量池中的数据\",{\"1\":{\"283\":1}}],[\"所有\",{\"1\":{\"170\":1}}],[\"所有想滚动出屏幕的view都需要设置这个flag\",{\"1\":{\"55\":1}}],[\"所有的植物信息列表\",{\"1\":{\"399\":1}}],[\"所有的function只是持有了一个真正要执行的方法体的placeholder指向lazycompilestub\",{\"1\":{\"394\":1}}],[\"所有的类方法必须至少有一个参数\",{\"1\":{\"369\":1}}],[\"所有的targetintent都会被拦截\",{\"1\":{\"72\":1}}],[\"所有的client\",{\"1\":{\"58\":1}}],[\"所有的value\",{\"1\":{\"44\":1}}],[\"所有的key\",{\"1\":{\"44\":1}}],[\"所有可以在binder中传输的接口都要继承自该接口\",{\"1\":{\"40\":1}}],[\"所以先对父节点983进行右旋\",{\"1\":{\"458\":1}}],[\"所以从1开始\",{\"1\":{\"457\":1}}],[\"所以比冒泡快\",{\"1\":{\"456\":1}}],[\"所以删除需要分以下几种情况\",{\"1\":{\"432\":1}}],[\"所以默认就是可以互相访问任意数据\",{\"1\":{\"421\":1}}],[\"所以aot将所有潜在的可触达的功能编译为native\",{\"1\":{\"396\":1}}],[\"所以appcolor的child还是之前的\",{\"1\":{\"130\":1}}],[\"所以appcolor和整个noname都被重建\",{\"1\":{\"130\":1}}],[\"所以走的是runlightweight\",{\"1\":{\"381\":1}}],[\"所以暂时不需要实现url\",{\"1\":{\"371\":1}}],[\"所以对下载功能做了简单的伪装\",{\"1\":{\"370\":1}}],[\"所以其肯定要持有okhttpclient对象\",{\"1\":{\"363\":1}}],[\"所以就是将\",{\"1\":{\"419\":1}}],[\"所以就需要对齐进行必要的封装以简化网络请求流程\",{\"1\":{\"362\":1}}],[\"所以就会使\",{\"1\":{\"223\":1}}],[\"所以上述simple\",{\"1\":{\"336\":1}}],[\"所以上面的等式相当于给table\",{\"1\":{\"280\":1}}],[\"所以那些可以被\",{\"1\":{\"329\":1}}],[\"所以用crossinline修饰\",{\"1\":{\"322\":1}}],[\"所以最好赋予一个默认的值\",{\"1\":{\"304\":1}}],[\"所以2010\",{\"1\":{\"302\":1}}],[\"所以2019\",{\"1\":{\"302\":1}}],[\"所以这时候采用手动同步网站\",{\"1\":{\"419\":1}}],[\"所以这一周被划归为2019年的第53周\",{\"1\":{\"302\":1}}],[\"所以这里新建了一个\",{\"1\":{\"419\":1}}],[\"所以这里执行的是runheavyweight\",{\"1\":{\"385\":1}}],[\"所以这里actualnewpixels是真正可以应用的pixels\",{\"1\":{\"220\":1}}],[\"所以这里的\",{\"1\":{\"197\":1}}],[\"所以这里使用positioned定位\",{\"1\":{\"181\":1}}],[\"所以这里会将centerwidget的renderpositionedbox\",{\"1\":{\"121\":1}}],[\"所以这里为他创建了一个对应的widget\",{\"1\":{\"120\":1}}],[\"所以是实现单例的较优选择\",{\"1\":{\"294\":1}}],[\"所以t2直接执行语句4\",{\"1\":{\"294\":1}}],[\"所以t1和t2无法同时访问初始化语句tag2\",{\"1\":{\"294\":1}}],[\"所以也不能保存任何t的子类\",{\"1\":{\"292\":1}}],[\"所以也不会执行\",{\"1\":{\"226\":1}}],[\"所以也不会触发anr\",{\"1\":{\"14\":1}}],[\"所以拒绝向其中传递任何类型对象\",{\"1\":{\"292\":1}}],[\"所以将类型检查放到了编译期\",{\"1\":{\"291\":1}}],[\"所以我们只要破坏其中一个条件就可以避免内存泄漏\",{\"1\":{\"288\":1}}],[\"所以我们会在之前对\",{\"1\":{\"199\":1}}],[\"所以为null\",{\"1\":{\"288\":1}}],[\"所以当when\",{\"1\":{\"322\":1}}],[\"所以当同样使用int类型的key保存数据时\",{\"1\":{\"287\":1}}],[\"所以当inheritedwidget变化的时候并不会触发此控件重建\",{\"1\":{\"130\":1}}],[\"所以一个string对象的大小是\",{\"1\":{\"283\":1}}],[\"所以一个完整的aidl通信过程如下\",{\"1\":{\"58\":1}}],[\"所以无需suspend修饰\",{\"1\":{\"336\":1}}],[\"所以无论何时\",{\"1\":{\"281\":1}}],[\"所以无法应用underscroll效果\",{\"1\":{\"226\":1}}],[\"所以会稍微慢一些\",{\"1\":{\"317\":1}}],[\"所以会比普通类的对象多4个byte\",{\"1\":{\"282\":1}}],[\"所以会比较耗费性能\",{\"1\":{\"242\":1}}],[\"所以会在其slivers中直接传入\",{\"1\":{\"230\":1}}],[\"所以空间足够时column可以按需分布children\",{\"1\":{\"241\":1,\"242\":1}}],[\"所以可以看到okhttputils做了双重锁定的单例处理\",{\"1\":{\"363\":1}}],[\"所以可以执行value\",{\"1\":{\"322\":1}}],[\"所以可以得出结论\",{\"1\":{\"302\":1}}],[\"所以可以上下滑动\",{\"1\":{\"241\":1}}],[\"所以可以解决这个问题\",{\"1\":{\"238\":1}}],[\"所以可以在state调用setstate\",{\"1\":{\"128\":1}}],[\"所以直接返回true\",{\"1\":{\"228\":1}}],[\"所以直接使用inflatewidget\",{\"1\":{\"122\":1}}],[\"所以整个\",{\"1\":{\"226\":1}}],[\"所以没有执行\",{\"1\":{\"226\":1}}],[\"所以此\",{\"1\":{\"217\":1}}],[\"所以此处不用再绘制\",{\"1\":{\"63\":1}}],[\"所以创建好的viewport滑动范围\",{\"1\":{\"213\":1}}],[\"所以更推荐使用\",{\"1\":{\"211\":1}}],[\"所以只会被调用一次\",{\"1\":{\"377\":1}}],[\"所以只能自救一次\",{\"1\":{\"266\":1}}],[\"所以只能从另外一个角度考虑\",{\"1\":{\"15\":1}}],[\"所以只要native端图片加载库比较成熟\",{\"1\":{\"211\":1}}],[\"所以大部分使用方式和官方类似\",{\"1\":{\"199\":1}}],[\"所以注意进度为100\",{\"1\":{\"193\":1}}],[\"所以又出现了flutter\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"所以他们的相交处为\",{\"1\":{\"173\":2}}],[\"所以不会冲突\",{\"1\":{\"452\":1}}],[\"所以不会再继续新建\",{\"1\":{\"294\":1}}],[\"所以不能保存object或者t等类型\",{\"1\":{\"292\":1}}],[\"所以不能直接为\",{\"1\":{\"79\":1}}],[\"所以不需要final\",{\"1\":{\"281\":1}}],[\"所以不应当再操作它\",{\"1\":{\"153\":1}}],[\"所以还需要将二进制与十六进制互转\",{\"1\":{\"296\":1}}],[\"所以还不能自动触发\",{\"1\":{\"152\":1}}],[\"所以还是所有的非const\",{\"1\":{\"128\":1}}],[\"所以widget\",{\"1\":{\"130\":1}}],[\"所以每次setstate引起alwaysrebuildwidget重新绘制\",{\"1\":{\"130\":1}}],[\"所以需要final来限制对局部变量的更改\",{\"1\":{\"281\":1}}],[\"所以需要在这里获取最新的\",{\"1\":{\"130\":1}}],[\"所以需要监听设备开机广播\",{\"1\":{\"9\":1}}],[\"所以后面对children的处理在本例中不涉及\",{\"1\":{\"127\":1}}],[\"所以updatechild传入的值分别是null\",{\"1\":{\"121\":1}}],[\"所以实际上执行下方的方法\",{\"1\":{\"118\":1}}],[\"所以file\",{\"1\":{\"111\":1}}],[\"所以如果内部类所处的方法\",{\"1\":{\"281\":1}}],[\"所以如果outer有underscroll则会先恢复到0然后返回\",{\"1\":{\"226\":1}}],[\"所以如果这些event中存在耗时长的方法\",{\"1\":{\"95\":1}}],[\"所以如果判断当前并非第一次申请该权限\",{\"1\":{\"68\":1}}],[\"所以接下来的代码如下\",{\"1\":{\"92\":1}}],[\"所以dagger\",{\"1\":{\"92\":1}}],[\"所以限制了asynctask只能在主线程实例化\",{\"1\":{\"80\":1}}],[\"所以mhandler=getmainhandler\",{\"1\":{\"80\":1}}],[\"所以即使是同一个threadlocal对象\",{\"1\":{\"288\":1}}],[\"所以即使在其他线程执行threadlocal\",{\"1\":{\"288\":1}}],[\"所以即使要执行intent的activity已经消失或者还没生成\",{\"1\":{\"75\":1}}],[\"所以即使使用了dp作为单位\",{\"1\":{\"53\":1}}],[\"所以在执行\",{\"1\":{\"418\":1}}],[\"所以在github项目的hexo分支下\",{\"1\":{\"406\":1}}],[\"所以在以上述方式执行代码的同时会记录以下信息\",{\"1\":{\"396\":1}}],[\"所以在\",{\"1\":{\"329\":1}}],[\"所以在此期间如果有其他的线程访问这段代码\",{\"1\":{\"317\":1}}],[\"所以在t2中tag1判断为true\",{\"1\":{\"294\":1}}],[\"所以在这里不会被计算\",{\"1\":{\"242\":1}}],[\"所以在oncreate\",{\"1\":{\"65\":1}}],[\"所以在绘制曲线图时可以先将坐标原点向下平移一段距离\",{\"1\":{\"63\":1}}],[\"所以在绘制文字时\",{\"1\":{\"15\":1}}],[\"所以调用copy\",{\"1\":{\"58\":1}}],[\"所以viewpager中页面有上述4个类或其子类时\",{\"1\":{\"55\":1}}],[\"所以使用状态栏高度来控制布局的时候就会展示异常\",{\"1\":{\"53\":1}}],[\"所以scrollx>0\",{\"1\":{\"41\":1}}],[\"所以\",{\"1\":{\"15\":1,\"63\":2,\"81\":2,\"121\":1,\"170\":1,\"171\":1,\"212\":1,\"213\":1,\"223\":1,\"226\":1,\"227\":1,\"254\":1,\"280\":1,\"283\":1,\"294\":1,\"417\":1}}],[\"所以基本不用担心会触发java\",{\"1\":{\"14\":1}}],[\"新生成的文章在目录\",{\"1\":{\"417\":1}}],[\"新生代\",{\"1\":{\"250\":1}}],[\"新的文章date\",{\"1\":{\"417\":1}}],[\"新的文章\",{\"1\":{\"417\":3}}],[\"新动画从动画当前值开始\",{\"1\":{\"153\":1}}],[\"新建文章\",{\"0\":{\"417\":1}}],[\"新建的isolate和当前isolate在同一个isolategroup中\",{\"1\":{\"373\":1}}],[\"新建的woker和threadpool绑定\",{\"1\":{\"115\":1}}],[\"新建一个名字为\",{\"1\":{\"417\":1}}],[\"新建一个仓库\",{\"1\":{\"347\":1}}],[\"新建一个aidl文件\",{\"1\":{\"40\":1}}],[\"新建了一个isolate引用\",{\"1\":{\"377\":1}}],[\"新建了一个\",{\"1\":{\"194\":1}}],[\"新建线程的属性\",{\"1\":{\"115\":1}}],[\"新建\",{\"1\":{\"79\":1,\"417\":1}}],[\"新建activity等\",{\"0\":{\"71\":1}}],[\"新建图层\",{\"1\":{\"57\":1}}],[\"新建该类的对象会提示出错\",{\"1\":{\"56\":1}}],[\"新建xxx\",{\"1\":{\"56\":1}}],[\"新开一个进程\",{\"1\":{\"14\":1}}],[\"新开一个进程并在其中进行multidex\",{\"1\":{\"14\":1}}],[\"虽然对这些知识并不是很熟悉\",{\"1\":{\"408\":1}}],[\"虽然随着使用的api的失效\",{\"1\":{\"398\":1}}],[\"虽然unoptimizing\",{\"1\":{\"396\":1}}],[\"虽然整体的逻辑已经很简单了\",{\"1\":{\"362\":1}}],[\"虽然\",{\"1\":{\"200\":1,\"211\":1}}],[\"虽然inheritedwidget的确只标记了那些依赖了他的widget\",{\"1\":{\"128\":1}}],[\"虽然在服务端中回调客户端的方法是在服务端的binder线程\",{\"1\":{\"36\":1}}],[\"虽然也提供循环任务的\",{\"1\":{\"3\":1}}],[\"那就将等待中的任务数pending\",{\"1\":{\"390\":1}}],[\"那就发送通知\",{\"1\":{\"390\":1}}],[\"那就是用enmu实现\",{\"1\":{\"294\":1}}],[\"那这样岂不是没法反序列化这些数据了\",{\"1\":{\"280\":1}}],[\"那些在flutter中加载图片并且完全采用imagecache管理图片内存的图片加载框架比如image\",{\"1\":{\"198\":1}}],[\"那里拿到ui\",{\"1\":{\"195\":1}}],[\"那么剩下的问题就成了如何将other从柱子a移动到柱子b\",{\"1\":{\"459\":1}}],[\"那么问题就变成了如何将bottom和other这\",{\"1\":{\"459\":1}}],[\"那么只需要将右边的元素依次拿出来插入到左边的有序数组中即可\",{\"1\":{\"457\":1}}],[\"那么完全二叉树只有最后一层的右边会出现没有叶子节点的情况\",{\"1\":{\"444\":1}}],[\"那么最小生成树将只有一个\",{\"1\":{\"438\":1}}],[\"那么最多滑动到\",{\"1\":{\"220\":1}}],[\"那么去访问下一个未访问的邻接点\",{\"1\":{\"437\":1}}],[\"那么等待已有的worker空闲时执行任务\",{\"1\":{\"391\":1}}],[\"那么要想resume\",{\"1\":{\"375\":1}}],[\"那么okhttputils是如何实现这一点的呢\",{\"1\":{\"362\":1}}],[\"那么你可以使用\",{\"1\":{\"347\":1}}],[\"那么该\",{\"1\":{\"345\":1}}],[\"那么该怎么适配呢\",{\"1\":{\"53\":1}}],[\"那么collect就读取5\",{\"1\":{\"327\":1}}],[\"那么column采用viewportconstraints\",{\"1\":{\"242\":1}}],[\"那么启动该子协程后\",{\"1\":{\"323\":1}}],[\"那么父类必须要有一个公开的无参构造函数\",{\"1\":{\"307\":1}}],[\"那么很明显这一周属于2020年的天数\",{\"1\":{\"302\":1}}],[\"那么本周所有日期的week\",{\"1\":{\"302\":1}}],[\"那么本线程获取到的也会是变更后的值\",{\"1\":{\"288\":1}}],[\"那么list也可以安全的保存t或者t的子类\",{\"1\":{\"293\":1}}],[\"那么list<\",{\"1\":{\"292\":1}}],[\"那么threadlocals中保存的threadlocal<\",{\"1\":{\"288\":1}}],[\"那么默认会展示\",{\"1\":{\"231\":1}}],[\"那么它是在什么时候被调用的呢\",{\"1\":{\"230\":1}}],[\"那么它将完全展开\",{\"1\":{\"55\":1}}],[\"那么它将被滚动到收缩或展开\",{\"1\":{\"55\":1}}],[\"那么potentialouterdelta会比delta大\",{\"1\":{\"226\":1}}],[\"那么max是0\",{\"1\":{\"220\":1}}],[\"那么max为无限大\",{\"1\":{\"220\":1}}],[\"那么此时最多向上滑动\",{\"1\":{\"220\":1}}],[\"那么我们立即得知hero动画的目标尺寸\",{\"1\":{\"179\":1}}],[\"那么我们不难得到以下方程\",{\"1\":{\"81\":1}}],[\"那么在右半部分数组查找\",{\"1\":{\"451\":1}}],[\"那么在进行注解的时候\",{\"1\":{\"299\":1}}],[\"那么在判断as为null后\",{\"1\":{\"294\":1}}],[\"那么在哪里发起和结束\",{\"1\":{\"176\":1}}],[\"那么在flutter中是如何绘制一个app呢\",{\"1\":{\"117\":1}}],[\"那么允许child按照自己的大小来显示\",{\"1\":{\"131\":1}}],[\"那么依旧用的是之前的noname\",{\"1\":{\"130\":1}}],[\"那么他的子类也自动支持序列化与反序列化\",{\"1\":{\"307\":1}}],[\"那么他就不会被rebuild\",{\"1\":{\"128\":1}}],[\"那么他会在value执行完毕后返回他的值\",{\"1\":{\"95\":1}}],[\"那么这个属性是如何影响到我们的\",{\"1\":{\"193\":1}}],[\"那么这里的renderparagraph是如何找到并插入到rendering\",{\"1\":{\"127\":1}}],[\"那么这一切dagger\",{\"1\":{\"82\":1}}],[\"那么假设依赖类service现在有两个构造方法\",{\"1\":{\"85\":1}}],[\"那么\",{\"1\":{\"81\":1,\"112\":1,\"171\":1,\"173\":1,\"242\":1,\"294\":1,\"400\":1}}],[\"那么可以判断用户选择了不再提示\",{\"1\":{\"69\":1}}],[\"那么终止点1\",{\"1\":{\"62\":1}}],[\"那么当新的值生产出来时\",{\"1\":{\"327\":1}}],[\"那么当用户滑动屏幕导致offset改变的时候\",{\"1\":{\"239\":1}}],[\"那么当从\",{\"1\":{\"171\":1}}],[\"那么当沿着当前线段移动d\",{\"1\":{\"61\":1}}],[\"那么当该方法返回时\",{\"1\":{\"59\":1}}],[\"那么server\",{\"1\":{\"58\":1}}],[\"那么view将在到达这个最小高度的时候开始显示\",{\"1\":{\"55\":1}}],[\"那么就应该调用对应的方法\",{\"1\":{\"395\":1}}],[\"那么就\",{\"1\":{\"228\":1}}],[\"那么就添加为source的listener\",{\"1\":{\"103\":1}}],[\"那么就只能更改density\",{\"1\":{\"53\":1}}],[\"那么就能保证同一dp的在不同dpi上占得像素是等比例变化的\",{\"1\":{\"53\":1}}],[\"那么不会再调用\",{\"1\":{\"13\":1}}],[\"那他是怎么保证跨进程注册\",{\"1\":{\"36\":1}}],[\"供使用者获取指定时间\",{\"1\":{\"186\":1}}],[\"供使用xxx\",{\"1\":{\"56\":1}}],[\"供\",{\"1\":{\"176\":1,\"188\":1}}],[\"供客户端调用\",{\"1\":{\"36\":1}}],[\"供服务端回调\",{\"1\":{\"35\":1}}],[\"自带终端窗口\",{\"1\":{\"411\":1}}],[\"自适应自旋\",{\"1\":{\"320\":1}}],[\"自旋锁\",{\"1\":{\"320\":1}}],[\"自然不会存在两处更新不同步的问题\",{\"1\":{\"281\":1}}],[\"自己搭建的博客又时常由于空间提供商的各种问题而无法访问\",{\"1\":{\"408\":1}}],[\"自己以便在主轴上匹配\",{\"1\":{\"232\":1}}],[\"自己处理完异常后\",{\"1\":{\"144\":1}}],[\"自己也能rebuilt\",{\"1\":{\"129\":1}}],[\"自定义变量\",{\"0\":{\"358\":1}}],[\"自定义序列化过程\",{\"0\":{\"306\":1}}],[\"自定义的类加载器完成加载\",{\"1\":{\"274\":1}}],[\"自定义的parcelable对象\",{\"1\":{\"34\":1}}],[\"自定义classloader一般步骤\",{\"1\":{\"272\":1}}],[\"自定义classloader也是如此\",{\"1\":{\"272\":1}}],[\"自定义dialog的style\",{\"1\":{\"66\":1}}],[\"自定义接口\",{\"1\":{\"56\":1}}],[\"自定义\",{\"1\":{\"55\":1,\"57\":3}}],[\"自定义behavior并不难\",{\"1\":{\"55\":1}}],[\"自定义behavior有两个目的\",{\"1\":{\"55\":1}}],[\"自定义behavior\",{\"1\":{\"55\":1}}],[\"自动\",{\"1\":{\"418\":1}}],[\"自动调用viewmodel的oncleared\",{\"1\":{\"402\":1}}],[\"自动打开网页\",{\"1\":{\"368\":1}}],[\"自动执行脚本\",{\"1\":{\"360\":1}}],[\"自动判断添加哪些文件\",{\"1\":{\"347\":1}}],[\"自动的传播异常\",{\"1\":{\"329\":1}}],[\"自动添加监听\",{\"1\":{\"229\":1}}],[\"自动添加依赖\",{\"1\":{\"1\":1}}],[\"自动触发rebuilt\",{\"1\":{\"155\":1}}],[\"自动化之旅\",{\"1\":{\"54\":1}}],[\"自动删除无用依赖\",{\"1\":{\"1\":1}}],[\"中缀表达式转化为后缀表达式\",{\"1\":{\"453\":1}}],[\"中缀表达式\",{\"1\":{\"453\":4}}],[\"中传入的entrypoint\",{\"1\":{\"379\":1}}],[\"中传入多个\",{\"1\":{\"226\":1}}],[\"中优先处理的\",{\"1\":{\"376\":1}}],[\"中取数排序\",{\"1\":{\"466\":1,\"467\":1}}],[\"中取出消息并执行\",{\"1\":{\"391\":1}}],[\"中取\",{\"1\":{\"375\":1}}],[\"中分别实现下载\",{\"1\":{\"371\":1}}],[\"中序遍历法\",{\"1\":{\"430\":1}}],[\"中序遍历\",{\"1\":{\"346\":3,\"430\":1}}],[\"中所有的代码\",{\"1\":{\"340\":1}}],[\"中所有dirty的element执行element\",{\"1\":{\"128\":1}}],[\"中间的2\",{\"1\":{\"327\":1}}],[\"中挂起的时候取消\",{\"1\":{\"327\":1}}],[\"中直接退出lambda所在的外层函数\",{\"1\":{\"322\":1}}],[\"中国\",{\"1\":{\"321\":1}}],[\"中加入的数据\",{\"1\":{\"306\":1}}],[\"中唤醒被阻塞的调用线程\",{\"1\":{\"297\":1}}],[\"中引用的对象\",{\"1\":{\"263\":1}}],[\"中基于\",{\"1\":{\"233\":1}}],[\"中基本上做了如下判断\",{\"1\":{\"103\":1}}],[\"中容纳\",{\"1\":{\"229\":1}}],[\"中默认会按照\",{\"1\":{\"228\":1}}],[\"中可滑动\",{\"1\":{\"226\":1}}],[\"中没有\",{\"1\":{\"226\":1}}],[\"中调用\",{\"1\":{\"216\":2}}],[\"中持有了\",{\"1\":{\"213\":1}}],[\"中一个重要的属性就是\",{\"1\":{\"213\":1}}],[\"中列表时\",{\"1\":{\"212\":1}}],[\"中向\",{\"1\":{\"211\":1}}],[\"中使用\",{\"1\":{\"200\":1}}],[\"中使用imageprovider\",{\"1\":{\"198\":1}}],[\"中查找对应的缓存\",{\"1\":{\"198\":1}}],[\"中读取\",{\"1\":{\"198\":1}}],[\"中执行真正获取图片的逻辑\",{\"1\":{\"196\":1}}],[\"中返回的imageinfo\",{\"1\":{\"192\":1}}],[\"中用于展示图片的\",{\"1\":{\"188\":1}}],[\"中应用\",{\"1\":{\"183\":1}}],[\"中从而作用于其创建的\",{\"1\":{\"182\":1}}],[\"中衍生出其他类型的\",{\"1\":{\"182\":1}}],[\"中主要由animationcontroller控制动画的开始\",{\"1\":{\"182\":1}}],[\"中创建的\",{\"1\":{\"178\":1,\"226\":1}}],[\"中创建并持有\",{\"1\":{\"178\":1}}],[\"中则为\",{\"1\":{\"172\":1}}],[\"中对应的方法\",{\"1\":{\"223\":1}}],[\"中对应的位置和大小\",{\"1\":{\"171\":1}}],[\"中对应的位置和大小过渡到\",{\"1\":{\"171\":1}}],[\"中对应的代码即可\",{\"1\":{\"82\":1}}],[\"中文文档\",{\"1\":{\"344\":1}}],[\"中文官网\",{\"1\":{\"334\":1}}],[\"中文字虽然是second\",{\"1\":{\"171\":1}}],[\"中文互联网存在着很多\",{\"1\":{\"0\":1}}],[\"中常用的子类有以下两种\",{\"1\":{\"165\":1}}],[\"中只有一个\",{\"1\":{\"161\":1}}],[\"中最小值\",{\"1\":{\"159\":1}}],[\"中最大值\",{\"1\":{\"159\":1,\"220\":1}}],[\"中获取消息并处理\",{\"1\":{\"391\":1}}],[\"中获取消息\",{\"1\":{\"391\":1}}],[\"中获取计数值\",{\"1\":{\"334\":1}}],[\"中获取缓存的图片\",{\"1\":{\"196\":1}}],[\"中获取\",{\"1\":{\"196\":1}}],[\"中获取到\",{\"1\":{\"190\":1}}],[\"中获取当前\",{\"1\":{\"157\":1}}],[\"中获取meta\",{\"1\":{\"54\":1}}],[\"中帧刷新时\",{\"1\":{\"157\":1}}],[\"中动画的基石\",{\"1\":{\"157\":1}}],[\"中动画的实现分为\",{\"1\":{\"146\":1}}],[\"中关于动画的类有很多\",{\"1\":{\"157\":1}}],[\"中监听其并触发\",{\"1\":{\"154\":1}}],[\"中监听着rawreceiveport\",{\"1\":{\"112\":1}}],[\"中避免重绘\",{\"1\":{\"153\":1}}],[\"中内置的\",{\"1\":{\"152\":1}}],[\"中这些与动画有关的类如何选择\",{\"1\":{\"146\":1,\"157\":1}}],[\"中不同的界面间\",{\"1\":{\"135\":1}}],[\"中实际处理一个microtask\",{\"1\":{\"100\":1}}],[\"中参照在activity实现的步骤实现hasfragmentinjector\",{\"1\":{\"94\":1}}],[\"中注册的\",{\"1\":{\"211\":1}}],[\"中注册\",{\"1\":{\"79\":1}}],[\"中各个组件及其样式\",{\"1\":{\"79\":1}}],[\"中都无法有效获取view的宽高\",{\"1\":{\"65\":1}}],[\"中y并不是text的最低端\",{\"1\":{\"64\":1}}],[\"中的sendport\",{\"1\":{\"378\":1}}],[\"中的博客地址\",{\"1\":{\"367\":1}}],[\"中的post\",{\"1\":{\"367\":1}}],[\"中的方法\",{\"1\":{\"340\":1}}],[\"中的代码\",{\"1\":{\"337\":1}}],[\"中的代码会在一个新的线程中执行\",{\"1\":{\"115\":1}}],[\"中的内容\",{\"1\":{\"336\":1,\"347\":1}}],[\"中的初始化阶段jvm会调用clinit方法\",{\"1\":{\"279\":1}}],[\"中的二进制字节流保存到虚拟机方法区和堆中\",{\"1\":{\"274\":1}}],[\"中的int\",{\"1\":{\"209\":1}}],[\"中的imageinfo\",{\"1\":{\"192\":1}}],[\"中的ui\",{\"1\":{\"207\":1}}],[\"中的动画\",{\"1\":{\"146\":1}}],[\"中的build方法\",{\"1\":{\"128\":1}}],[\"中的activitymanagerservice和handler\",{\"1\":{\"70\":1}}],[\"中的参数个数为参数最多的构造方法的参数数\",{\"1\":{\"56\":1}}],[\"中的\",{\"1\":{\"55\":1,\"79\":3,\"111\":1,\"112\":1,\"115\":1,\"153\":1,\"169\":1,\"171\":7,\"174\":1,\"187\":1,\"203\":1,\"207\":1,\"212\":2,\"223\":2,\"226\":2,\"227\":1,\"230\":1}}],[\"中处理了\",{\"1\":{\"227\":1}}],[\"中处理\",{\"1\":{\"55\":1}}],[\"中\",{\"1\":{\"55\":1,\"121\":1,\"128\":1,\"147\":2,\"153\":1,\"155\":1,\"171\":4,\"174\":1,\"181\":2,\"182\":1,\"186\":1,\"188\":1,\"189\":1,\"191\":1,\"195\":1,\"196\":1,\"198\":1,\"207\":2,\"213\":2,\"218\":1,\"223\":3,\"230\":1,\"280\":1,\"283\":1,\"322\":1,\"386\":1,\"402\":1}}],[\"中<meta\",{\"1\":{\"54\":1}}],[\"中计算得出的key应该添加的位置\",{\"1\":{\"50\":1}}],[\"中存入客户端的数据\",{\"1\":{\"40\":1}}],[\"中添加material组件使其应用样式即可\",{\"1\":{\"171\":1}}],[\"中添加第一个\",{\"1\":{\"170\":1}}],[\"中添加\",{\"1\":{\"32\":1}}],[\"中通过sendmessagedelayed\",{\"1\":{\"31\":1}}],[\"中通过looper\",{\"1\":{\"31\":1}}],[\"中被调用\",{\"1\":{\"29\":1}}],[\"中此值为null\",{\"1\":{\"28\":1}}],[\"和队列定义一致\",{\"1\":{\"453\":1}}],[\"和两个叶子节点中最大的比较\",{\"1\":{\"441\":1}}],[\"和插入相比\",{\"1\":{\"441\":1}}],[\"和after\",{\"1\":{\"407\":1}}],[\"和他相关的有下面几个关键类\",{\"1\":{\"404\":1}}],[\"和他们的子类\",{\"1\":{\"157\":1}}],[\"和布局文件一样\",{\"1\":{\"400\":1}}],[\"和unoptimizing\",{\"1\":{\"396\":1}}],[\"和方法对应的execution\",{\"1\":{\"396\":1}}],[\"和一个线程池\",{\"1\":{\"391\":1}}],[\"和全局变量\",{\"1\":{\"391\":1}}],[\"和isolate\",{\"1\":{\"387\":1}}],[\"和init\",{\"1\":{\"279\":1}}],[\"和inner\",{\"1\":{\"224\":1}}],[\"和queue\",{\"1\":{\"376\":1,\"391\":3}}],[\"和false\",{\"1\":{\"369\":1}}],[\"和future<t>\",{\"1\":{\"196\":1}}],[\"和追加输出\",{\"1\":{\"361\":1}}],[\"和>>\",{\"1\":{\"361\":1}}],[\"和whoami输出当前用户名\",{\"1\":{\"353\":1}}],[\"和协程所在的线程没有关系\",{\"1\":{\"325\":1}}],[\"和objectinputstream的readfields\",{\"1\":{\"306\":1}}],[\"和getminimaldaysinfirstweek\",{\"1\":{\"302\":1}}],[\"和要赋予的类型\",{\"1\":{\"291\":1}}],[\"和romainguy\",{\"1\":{\"282\":1}}],[\"和readexternal\",{\"1\":{\"310\":1}}],[\"和read\",{\"1\":{\"111\":1}}],[\"和markneedssemanticsupdate\",{\"1\":{\"237\":1}}],[\"和messenger\",{\"1\":{\"43\":1}}],[\"和被\",{\"1\":{\"226\":1}}],[\"和使用\",{\"1\":{\"205\":1}}],[\"和load\",{\"1\":{\"196\":1}}],[\"和loop\",{\"1\":{\"26\":1}}],[\"和位置\",{\"1\":{\"170\":1}}],[\"和状态\",{\"1\":{\"168\":1}}],[\"和其他一些必须的信息即可\",{\"1\":{\"227\":1}}],[\"和其他\",{\"1\":{\"153\":1}}],[\"和build\",{\"1\":{\"152\":1}}],[\"和上面的\",{\"1\":{\"146\":1,\"157\":1}}],[\"和element\",{\"1\":{\"127\":1}}],[\"和设计稿对应物体大小\",{\"1\":{\"81\":1}}],[\"和主程序不在同一个进程为\",{\"1\":{\"79\":1}}],[\"和应用程序不再同一个进程当中\",{\"1\":{\"79\":1}}],[\"和switchmap\",{\"1\":{\"78\":1}}],[\"和startservice\",{\"1\":{\"17\":1}}],[\"和proxyactivity\",{\"1\":{\"71\":1}}],[\"和非系统app进程\",{\"1\":{\"60\":1}}],[\"和vm分别置于两个设备上\",{\"1\":{\"393\":1}}],[\"和v\",{\"1\":{\"58\":1}}],[\"和toolbar联动的子view高度需大于toolbar高度\",{\"1\":{\"55\":1}}],[\"和实际的状态栏高度不一致\",{\"1\":{\"53\":1}}],[\"和\",{\"1\":{\"40\":1,\"54\":1,\"55\":1,\"79\":1,\"146\":2,\"147\":4,\"156\":2,\"158\":1,\"159\":3,\"168\":1,\"171\":1,\"172\":1,\"173\":1,\"176\":1,\"177\":1,\"182\":5,\"184\":1,\"185\":2,\"196\":1,\"197\":1,\"200\":1,\"202\":2,\"203\":1,\"211\":6,\"212\":9,\"213\":6,\"216\":1,\"217\":1,\"220\":4,\"223\":2,\"225\":2,\"226\":6,\"227\":1,\"228\":2,\"233\":1,\"294\":1,\"369\":1,\"411\":1,\"412\":2}}],[\"配置有误\",{\"1\":{\"419\":1}}],[\"配置环境变量方法\",{\"0\":{\"412\":1}}],[\"配置相关的一些属性\",{\"1\":{\"364\":1}}],[\"配置email\",{\"1\":{\"347\":1}}],[\"配置用户名\",{\"1\":{\"347\":1}}],[\"配置\",{\"0\":{\"414\":1},\"1\":{\"347\":1}}],[\"配置方法数超过\",{\"1\":{\"14\":1}}],[\"配合oneach\",{\"1\":{\"337\":1}}],[\"配合ascontextelement\",{\"1\":{\"325\":1}}],[\"配合原文食用口味更佳\",{\"1\":{\"22\":1}}],[\"先将其按大小划分为左右两部分\",{\"1\":{\"467\":1}}],[\"先假设第一个数是已经排好序的\",{\"1\":{\"462\":1}}],[\"先取一个适当的增量n\",{\"1\":{\"460\":1}}],[\"先进先出\",{\"1\":{\"447\":1}}],[\"先进后出\",{\"1\":{\"446\":1}}],[\"先访问当前顶点的所有邻接顶点\",{\"1\":{\"438\":1}}],[\"先用模拟数据在vm上运行\",{\"1\":{\"396\":1}}],[\"先用二分法查找\",{\"1\":{\"46\":1}}],[\"先用二分法查找key对应的索引\",{\"1\":{\"45\":1}}],[\"先详细看一下获取new\",{\"1\":{\"390\":1}}],[\"先是用isolate\",{\"1\":{\"383\":1}}],[\"先是更新了imagestream\",{\"1\":{\"191\":1}}],[\"先根据前序排序\",{\"1\":{\"346\":1}}],[\"先根据请求参数创建好请求并返回给\",{\"1\":{\"211\":1}}],[\"先左子树\",{\"1\":{\"346\":2}}],[\"先从当前isolate获取对应的isolate\",{\"1\":{\"383\":1}}],[\"先从根节点开始\",{\"1\":{\"346\":1}}],[\"先从overscrolled恢复并返回剩余没有使用的delta\",{\"1\":{\"226\":1}}],[\"先遍历根节点\",{\"1\":{\"346\":1}}],[\"先执行\",{\"1\":{\"340\":1}}],[\"先执行完毕所有的同步方法\",{\"1\":{\"109\":1}}],[\"先顺序收集所有流\",{\"1\":{\"340\":1}}],[\"先依次对flow项目调用代码块\",{\"1\":{\"327\":1}}],[\"先了解几个知识点\",{\"1\":{\"302\":1}}],[\"先了解几个基础方法\",{\"1\":{\"188\":1}}],[\"先了解两个概念\",{\"1\":{\"297\":1}}],[\"先说结论\",{\"1\":{\"281\":1}}],[\"先于init\",{\"1\":{\"279\":1}}],[\"先触发父类的初始化\",{\"1\":{\"279\":1}}],[\"先移除已有的监听\",{\"1\":{\"237\":1}}],[\"先等达到\",{\"1\":{\"226\":1}}],[\"先让outer复现出来\",{\"1\":{\"226\":1}}],[\"先恢复inner\",{\"1\":{\"226\":1}}],[\"先创建对应的请求\",{\"1\":{\"211\":1}}],[\"先仅从网络加载图片\",{\"1\":{\"201\":1}}],[\"先尝试从缓存文件中读取图片\",{\"1\":{\"201\":1}}],[\"先使用\",{\"1\":{\"159\":1}}],[\"先行返回future\",{\"1\":{\"112\":1}}],[\"先通过io\",{\"1\":{\"110\":1}}],[\"先在当前tree中向上找到父级中离得最近的renderobjectelement\",{\"1\":{\"127\":1}}],[\"先在dart代码创建file引用\",{\"1\":{\"110\":1}}],[\"先在marray中查找key对应的索引index\",{\"1\":{\"50\":1}}],[\"先获取了当前的时间戳\",{\"1\":{\"105\":1}}],[\"先看一个属性\",{\"1\":{\"239\":1}}],[\"先看一下navigation的定义\",{\"1\":{\"400\":1}}],[\"先看一下的createisolategroupandsetup实现\",{\"1\":{\"387\":1}}],[\"先看一下sdk\",{\"1\":{\"377\":1}}],[\"先看一下sparearray的结构\",{\"1\":{\"44\":1}}],[\"先看一下常用的几个方法是怎么实现的\",{\"1\":{\"376\":1}}],[\"先看一下这些日期对应的星期\",{\"1\":{\"302\":1}}],[\"先看一下center的源码\",{\"1\":{\"122\":1}}],[\"先看一下在最顶层的renderview\",{\"1\":{\"122\":1}}],[\"先看一下\",{\"1\":{\"107\":1,\"226\":1,\"237\":1}}],[\"先看一下futrue\",{\"1\":{\"103\":1}}],[\"先看一下arraymap的结构\",{\"1\":{\"49\":1}}],[\"先看几种会触发此类事件的方法\",{\"1\":{\"101\":1}}],[\"先解释几个概念\",{\"1\":{\"82\":1}}],[\"先绘制dst\",{\"1\":{\"57\":1}}],[\"先绘制src\",{\"1\":{\"57\":1}}],[\"先查找key的索引\",{\"1\":{\"51\":1}}],[\"先向后\",{\"1\":{\"49\":1}}],[\"先启动后绑定service\",{\"1\":{\"21\":1}}],[\"先绑定后启动service\",{\"1\":{\"21\":1}}],[\"结\",{\"1\":{\"352\":1}}],[\"结构正确\",{\"1\":{\"276\":1}}],[\"结合两个流的值\",{\"1\":{\"344\":1}}],[\"结合以上结论\",{\"1\":{\"302\":1}}],[\"结合时间\",{\"1\":{\"168\":1}}],[\"结合上述的分析后\",{\"1\":{\"14\":1}}],[\"结束查找\",{\"1\":{\"451\":1}}],[\"结束遍历\",{\"1\":{\"370\":1}}],[\"结束时才会展示child\",{\"1\":{\"176\":1}}],[\"结束\",{\"1\":{\"156\":1,\"182\":1}}],[\"结果为\",{\"1\":{\"272\":1}}],[\"结果\",{\"1\":{\"21\":1,\"413\":1}}],[\"顺序会乱\",{\"1\":{\"340\":1}}],[\"顺序\",{\"1\":{\"21\":1}}],[\"期间执行绑定\",{\"1\":{\"21\":1}}],[\"不存在伪溢出问题\",{\"1\":{\"452\":1}}],[\"不存在n\",{\"1\":{\"451\":1}}],[\"不进行向上遍历\",{\"1\":{\"442\":1}}],[\"不是完全二叉树\",{\"1\":{\"444\":1}}],[\"不是内部或外部命令\",{\"1\":{\"411\":1}}],[\"不是所有的service类都可以被我们随意修改\",{\"1\":{\"84\":1}}],[\"不得不承认\",{\"1\":{\"408\":1}}],[\"不得为\",{\"1\":{\"21\":1}}],[\"不满足条件\",{\"1\":{\"438\":1}}],[\"不满足的话就丢弃优化代码\",{\"1\":{\"396\":1}}],[\"不满足第一周的条件\",{\"1\":{\"302\":1}}],[\"不断的在任务队列tasks\",{\"1\":{\"391\":1}}],[\"不断刷新绘图\",{\"1\":{\"63\":1}}],[\"不管哪一种都不会直接执行dart源码\",{\"1\":{\"392\":1}}],[\"不管是isolate\",{\"1\":{\"378\":1}}],[\"不管在什么样的屏幕上\",{\"1\":{\"53\":1}}],[\"不想执行任何语句\",{\"1\":{\"369\":1}}],[\"不发布文章\",{\"1\":{\"368\":1}}],[\"不编译文章\",{\"1\":{\"368\":1}}],[\"不受权限限制\",{\"1\":{\"351\":1}}],[\"不受其最大数量和最大总大小约束\",{\"1\":{\"198\":1}}],[\"不应该在协程中使用\",{\"1\":{\"323\":1}}],[\"不应当执行耗时方法\",{\"1\":{\"95\":1}}],[\"不用再比较了\",{\"1\":{\"457\":1}}],[\"不用in或者out\",{\"1\":{\"322\":1}}],[\"不用手动添加移除\",{\"1\":{\"159\":1}}],[\"不变\",{\"1\":{\"322\":1}}],[\"不一定与源代码一致\",{\"1\":{\"371\":1}}],[\"不一定需要同步\",{\"1\":{\"320\":1}}],[\"不一定和代码中的顺序一致\",{\"1\":{\"317\":1}}],[\"不一致而报错\",{\"1\":{\"291\":1}}],[\"不够5天\",{\"1\":{\"302\":1}}],[\"不赞成使用的api\",{\"1\":{\"298\":1}}],[\"不停止\",{\"1\":{\"288\":1}}],[\"不停的遍历\",{\"1\":{\"115\":1}}],[\"不停的通过mqueue获取到msg\",{\"1\":{\"25\":1}}],[\"不含引用对象的大小\",{\"1\":{\"285\":1}}],[\"不计算持有的char数组占用的大小\",{\"1\":{\"283\":1}}],[\"不涉及该对象所持有的对象本身的大小\",{\"1\":{\"282\":1}}],[\"不涉及具体项目应用\",{\"1\":{\"82\":1}}],[\"不对\",{\"1\":{\"281\":1}}],[\"不引用\",{\"1\":{\"265\":1}}],[\"不支持普通的滑动\",{\"1\":{\"226\":1}}],[\"不支持静态变量\",{\"1\":{\"34\":1}}],[\"不生效\",{\"1\":{\"226\":1}}],[\"不考虑\",{\"1\":{\"222\":1}}],[\"不执行剩余步骤\",{\"1\":{\"220\":1}}],[\"不需要重新layout\",{\"1\":{\"179\":1}}],[\"不建议有其他变化\",{\"1\":{\"170\":1}}],[\"不限制高度\",{\"1\":{\"238\":1}}],[\"不限制宽度\",{\"1\":{\"238\":1}}],[\"不限制\",{\"1\":{\"161\":1}}],[\"不为空时\",{\"1\":{\"280\":1}}],[\"不为0表示不可以应用到\",{\"1\":{\"220\":1}}],[\"不为\",{\"1\":{\"161\":1}}],[\"不接受输入\",{\"1\":{\"138\":2}}],[\"不接受输入事件\",{\"1\":{\"41\":1}}],[\"不难看出\",{\"1\":{\"126\":1}}],[\"不过这次是用它来存储代码\",{\"1\":{\"408\":1}}],[\"不过native\",{\"1\":{\"253\":1}}],[\"不过可以发送overscroll\",{\"1\":{\"226\":1}}],[\"不过\",{\"1\":{\"200\":1}}],[\"不过最后也是调用\",{\"1\":{\"111\":1}}],[\"不过放在aidl中便于多个客户端开发\",{\"1\":{\"35\":1}}],[\"不再继续递归\",{\"1\":{\"459\":1}}],[\"不再关心后续的发展\",{\"1\":{\"87\":1}}],[\"不再提醒\",{\"1\":{\"69\":1}}],[\"不知道用哪一个好\",{\"1\":{\"85\":1}}],[\"不可能对每个网络请求都写一次上述代码\",{\"1\":{\"362\":1}}],[\"不可能有虚拟按键\",{\"1\":{\"81\":1}}],[\"不可以调用非局部返回\",{\"1\":{\"322\":1}}],[\"不可达则未标记\",{\"1\":{\"263\":1}}],[\"不可见\",{\"1\":{\"138\":1,\"171\":2}}],[\"不可继续\",{\"1\":{\"69\":1}}],[\"不适用于信息交换\",{\"1\":{\"58\":1}}],[\"不合适频繁或信息量大的通信\",{\"1\":{\"58\":1}}],[\"不能查找或者遍历\",{\"1\":{\"445\":1}}],[\"不能从b→a\",{\"1\":{\"433\":1}}],[\"不能输出0\",{\"1\":{\"428\":1}}],[\"不能变的变量\",{\"1\":{\"369\":1}}],[\"不能安全写入\",{\"1\":{\"322\":1}}],[\"不能作为消费者调用set之类的方法\",{\"1\":{\"322\":1}}],[\"不能有重复的\",{\"1\":{\"369\":1}}],[\"不能有泛型数组\",{\"0\":{\"291\":1}}],[\"不能有多个\",{\"1\":{\"170\":1}}],[\"不能直接调用其4种常用方法\",{\"1\":{\"80\":1}}],[\"不能以数字开头\",{\"1\":{\"54\":1}}],[\"不能单独存在\",{\"1\":{\"41\":1}}],[\"不同点\",{\"1\":{\"323\":1}}],[\"不同thread可以通过一个threadlocal变量分别保存不同的变量而互不影响\",{\"1\":{\"288\":1}}],[\"不同位1\",{\"1\":{\"280\":1}}],[\"不同为0\",{\"1\":{\"280\":1}}],[\"不同为\",{\"1\":{\"280\":1}}],[\"不同如下\",{\"1\":{\"279\":1}}],[\"不同而值展示\",{\"1\":{\"227\":1}}],[\"不同的系统实现不同\",{\"1\":{\"108\":1}}],[\"不同的是希尔排序的增量逐渐减小到1\",{\"1\":{\"460\":1}}],[\"不同的是优先级高的在队首\",{\"1\":{\"448\":1}}],[\"不同的是此方法返回的是\",{\"1\":{\"183\":1}}],[\"不同的是\",{\"1\":{\"53\":1,\"232\":1}}],[\"不同xfermode绘制结果如下\",{\"1\":{\"57\":1}}],[\"不同\",{\"1\":{\"54\":3}}],[\"不会尝试静态解析任何没有在kernel\",{\"1\":{\"395\":1}}],[\"不会被catch捕获\",{\"1\":{\"341\":1}}],[\"不会被缓存的图片\",{\"1\":{\"197\":1}}],[\"不会挂起后面的协程代码\",{\"1\":{\"337\":1}}],[\"不会产生并发问题\",{\"1\":{\"334\":1}}],[\"不会限定协程运行的线程\",{\"1\":{\"324\":1}}],[\"不会阻塞其所在线程\",{\"1\":{\"323\":1}}],[\"不会阻塞当前线程\",{\"1\":{\"323\":1}}],[\"不会再加深越界\",{\"1\":{\"220\":2}}],[\"不会影响其他的图片缓存\",{\"1\":{\"202\":1}}],[\"不会触发通知\",{\"1\":{\"164\":1}}],[\"不会缩减\",{\"1\":{\"44\":1}}],[\"不会唤醒机器\",{\"1\":{\"4\":1}}],[\"不获取焦点\",{\"1\":{\"41\":1}}],[\"不要在onresume\",{\"1\":{\"21\":1}}],[\"多占一个排序数组的大小\",{\"1\":{\"459\":1}}],[\"多\",{\"1\":{\"390\":1}}],[\"多次pause\",{\"1\":{\"375\":1}}],[\"多次序列化同一个对象\",{\"0\":{\"309\":1}}],[\"多线程时\",{\"1\":{\"257\":1}}],[\"多线程\",{\"1\":{\"257\":1}}],[\"多出的空隙由column按照mainaxisalignment\",{\"1\":{\"241\":1}}],[\"多了一层本地磁盘缓存\",{\"1\":{\"202\":1}}],[\"多个helper\",{\"1\":{\"392\":1}}],[\"多个值\",{\"1\":{\"369\":1}}],[\"多个线程申请锁时必须按照申请时间顺序获得锁\",{\"1\":{\"318\":1}}],[\"多个线程使用同一个共享数据时\",{\"1\":{\"318\":1}}],[\"多个线程的中只会有一个线程执行一次clinit\",{\"1\":{\"279\":1}}],[\"多个进程可以访问一个公用的内存空间\",{\"1\":{\"58\":1}}],[\"多个客户端可连接一个服务端\",{\"1\":{\"21\":1}}],[\"多数时候是service被意外销毁\",{\"1\":{\"19\":1}}],[\"回到要存放的目录下\",{\"1\":{\"347\":1}}],[\"回到我们的center\",{\"1\":{\"122\":1}}],[\"回收过程\",{\"0\":{\"266\":1}}],[\"回收算法\",{\"0\":{\"261\":1}}],[\"回收使用完的msg\",{\"1\":{\"25\":1}}],[\"回去执行对应的文件操作\",{\"1\":{\"115\":1}}],[\"回调方法\",{\"1\":{\"362\":1}}],[\"回调方法返回此binder实例\",{\"1\":{\"19\":1}}],[\"回调嵌套等导致代码可读性查的问题\",{\"1\":{\"322\":1}}],[\"回调powerimageresponse\",{\"1\":{\"211\":1}}],[\"回调时执行animationcontroller\",{\"1\":{\"161\":1}}],[\"回调handler\",{\"1\":{\"115\":1}}],[\"回调结果\",{\"1\":{\"111\":1}}],[\"回调的具体方法\",{\"1\":{\"35\":1}}],[\"回调接口\",{\"1\":{\"35\":1}}],[\"回复消息\",{\"1\":{\"20\":1}}],[\"回复客户端消息\",{\"1\":{\"20\":1}}],[\"解压\",{\"1\":{\"357\":1,\"432\":2}}],[\"解压文件\",{\"1\":{\"356\":1}}],[\"解包\",{\"1\":{\"357\":2}}],[\"解密部分变量\",{\"1\":{\"306\":1}}],[\"解密\",{\"1\":{\"296\":1}}],[\"解密用法\",{\"1\":{\"296\":1}}],[\"解除私有限定\",{\"1\":{\"295\":1}}],[\"解除绑定\",{\"1\":{\"19\":1}}],[\"解释几个概念\",{\"1\":{\"254\":1}}],[\"解码前的数据拷贝影响较小\",{\"1\":{\"211\":1}}],[\"解析参数\",{\"1\":{\"379\":1,\"384\":1,\"389\":2}}],[\"解析网页内容\",{\"1\":{\"371\":1}}],[\"解析分为\",{\"1\":{\"278\":1}}],[\"解析\",{\"1\":{\"278\":1,\"279\":1}}],[\"解析resolution\",{\"1\":{\"275\":1}}],[\"解析加载的图片信息\",{\"1\":{\"201\":1}}],[\"解析未知格式\",{\"1\":{\"188\":1}}],[\"解决方法参考\",{\"1\":{\"288\":1}}],[\"解决了第三方依赖引用的问题\",{\"1\":{\"85\":1}}],[\"解决同步和互斥问题\",{\"1\":{\"58\":1}}],[\"解决flavor\",{\"1\":{\"54\":1}}],[\"解决代码如下\",{\"1\":{\"42\":1}}],[\"解绑\",{\"1\":{\"21\":1}}],[\"解绑service\",{\"1\":{\"17\":1}}],[\"参见关于合并的相关章节\",{\"1\":{\"327\":1}}],[\"参阅\",{\"1\":{\"294\":1}}],[\"参数类型小写\",{\"1\":{\"400\":1}}],[\"参数args\",{\"1\":{\"389\":2}}],[\"参数传入\",{\"1\":{\"367\":1}}],[\"参数等信息\",{\"1\":{\"362\":1}}],[\"参数\",{\"1\":{\"298\":1,\"369\":1,\"413\":1,\"416\":4}}],[\"参数如下\",{\"1\":{\"298\":1}}],[\"参数为\",{\"1\":{\"111\":1}}],[\"参数3\",{\"1\":{\"19\":1}}],[\"参2\",{\"1\":{\"79\":1}}],[\"参1是用于指定被更新\",{\"1\":{\"79\":1}}],[\"参1\",{\"1\":{\"79\":1}}],[\"参与binder通信的所有角色\",{\"1\":{\"58\":1}}],[\"参考这里\",{\"1\":{\"287\":1}}],[\"参考一个java对象到底占用多大内存\",{\"1\":{\"282\":1}}],[\"参考了几篇文章\",{\"1\":{\"72\":1}}],[\"参考自这里\",{\"1\":{\"282\":1}}],[\"参考自\",{\"1\":{\"65\":1}}],[\"参考下图\",{\"1\":{\"49\":1}}],[\"参考文章\",{\"1\":{\"15\":1,\"146\":2,\"157\":2}}],[\"创建保存数据的数组\",{\"1\":{\"428\":1}}],[\"创建isolatedata\",{\"1\":{\"387\":1}}],[\"创建isolate\",{\"0\":{\"378\":1},\"1\":{\"386\":1,\"387\":1,\"388\":2}}],[\"创建imageinfo\",{\"1\":{\"209\":1}}],[\"创建新isolate的方式\",{\"0\":{\"373\":1}}],[\"创建新的isolate\",{\"1\":{\"383\":1}}],[\"创建新的收集器\",{\"1\":{\"337\":1}}],[\"创建新的\",{\"1\":{\"182\":1}}],[\"创建新的element并作为renderobjecttowidgetelement的\",{\"1\":{\"122\":1}}],[\"创建新的sendport并将dart\",{\"1\":{\"116\":1}}],[\"创建新的worker\",{\"1\":{\"115\":1}}],[\"创建类对象\",{\"1\":{\"369\":1}}],[\"创建okhttp3\",{\"1\":{\"365\":1}}],[\"创建outer\",{\"1\":{\"225\":1}}],[\"创建文件\",{\"1\":{\"349\":1,\"370\":1}}],[\"创建文件夹\",{\"1\":{\"349\":1}}],[\"创建flow\",{\"0\":{\"336\":1}}],[\"创建计时器通道\",{\"1\":{\"328\":2}}],[\"创建密码器\",{\"1\":{\"296\":2}}],[\"创建继承自\",{\"1\":{\"226\":1}}],[\"创建powerimagerequest\",{\"1\":{\"211\":1}}],[\"创建供imageext使用的imageinfo\",{\"1\":{\"208\":1}}],[\"创建widgetsapp\",{\"1\":{\"178\":1}}],[\"创建好之后\",{\"1\":{\"171\":1}}],[\"创建好element之后\",{\"1\":{\"121\":1}}],[\"创建并返回dart\",{\"1\":{\"387\":1}}],[\"创建并返回该类的对象\",{\"1\":{\"364\":1}}],[\"创建并应用\",{\"1\":{\"212\":1}}],[\"创建并监听\",{\"1\":{\"168\":1}}],[\"创建并持有了\",{\"1\":{\"147\":1}}],[\"创建弹性的模拟\",{\"1\":{\"168\":1}}],[\"创建其他动画\",{\"1\":{\"160\":1}}],[\"创建所需要的tween\",{\"1\":{\"152\":1}}],[\"创建的流的繁忙循环默认可以取消\",{\"1\":{\"342\":1}}],[\"创建的是封装了的\",{\"1\":{\"207\":1}}],[\"创建的位于\",{\"1\":{\"171\":1}}],[\"创建的\",{\"1\":{\"152\":1,\"200\":1,\"207\":1,\"211\":1,\"212\":1,\"213\":1,\"223\":1,\"227\":1}}],[\"创建的multichildrenderobjectelement\",{\"1\":{\"127\":1}}],[\"创建自己对应的\",{\"1\":{\"151\":1}}],[\"创建对应的静态博客内容\",{\"1\":{\"407\":1}}],[\"创建对应的\",{\"1\":{\"183\":1}}],[\"创建对应的renderobjecttowidgetelement\",{\"1\":{\"121\":1}}],[\"创建对象\",{\"1\":{\"80\":1}}],[\"创建了一个oob消息并压入oob\",{\"1\":{\"376\":1}}],[\"创建了renderview对象\",{\"1\":{\"122\":1}}],[\"创建了rendering\",{\"1\":{\"118\":1}}],[\"创建了用于管理渲染管道的pipelineowner\",{\"1\":{\"118\":1}}],[\"创建renderobjecttowidgetelement\",{\"1\":{\"121\":1}}],[\"创建renderobjecttowidgetadapter包装renderview\",{\"1\":{\"119\":1}}],[\"创建renderview具体的逻辑在widgetsflutterbinding\",{\"1\":{\"118\":1}}],[\"创建render\",{\"1\":{\"117\":1}}],[\"创建nativemessagehandler\",{\"1\":{\"115\":2}}],[\"创建dart\",{\"1\":{\"114\":1,\"387\":2}}],[\"创建timer\",{\"0\":{\"105\":1}}],[\"创建包含了提供androidinjector\",{\"1\":{\"94\":1}}],[\"创建实现了androidinjector<mainfragment>的mainfragmentsubcomponent\",{\"1\":{\"94\":1}}],[\"创建application的\",{\"1\":{\"94\":1}}],[\"创建属于整个activity的\",{\"1\":{\"91\":1}}],[\"创建某个activity专属的\",{\"1\":{\"90\":1}}],[\"创建单个activity的\",{\"0\":{\"90\":1,\"91\":1}}],[\"创建\",{\"0\":{\"215\":1},\"1\":{\"80\":1,\"127\":1,\"130\":1,\"161\":2,\"188\":1,\"198\":1,\"207\":1,\"215\":1,\"225\":2,\"233\":1,\"347\":2}}],[\"创建一个文件夹\",{\"1\":{\"414\":1}}],[\"创建一个thread并和当前isolate绑定\",{\"1\":{\"383\":1}}],[\"创建一个和当前的isolate共享同一份代码的isolate\",{\"1\":{\"373\":2}}],[\"创建一个和当前isolate共享同一份代码的isolate\",{\"1\":{\"373\":1}}],[\"创建一个网络请求\",{\"1\":{\"362\":1}}],[\"创建一个okhttpclient客户端\",{\"1\":{\"362\":1}}],[\"创建一个本地分支\",{\"1\":{\"347\":1}}],[\"创建一个本地仓库\",{\"1\":{\"347\":1}}],[\"创建一个新的系统线程\",{\"1\":{\"389\":1}}],[\"创建一个新的worker在新的系统线程运行task\",{\"1\":{\"389\":1}}],[\"创建一个新的message并将其压入isolate的父isolate对应的messagehandler的event\",{\"1\":{\"389\":1}}],[\"创建一个新的animation<u>\",{\"1\":{\"168\":1}}],[\"创建一个新的native\",{\"1\":{\"114\":1}}],[\"创建一个inheritedwidget来传递数据\",{\"1\":{\"130\":1}}],[\"创建一个系统线程的包装类osthread和新建的系统线程绑定\",{\"1\":{\"115\":1}}],[\"创建一个worker\",{\"1\":{\"115\":1}}],[\"创建一个dart\",{\"1\":{\"115\":1}}],[\"创建一个\",{\"1\":{\"79\":5,\"416\":1}}],[\"创建一个jobservice可以避免这个情况\",{\"1\":{\"59\":1}}],[\"创建代理类\",{\"1\":{\"58\":1}}],[\"创建service监听client的请求\",{\"1\":{\"32\":1}}],[\"创建handler接收\",{\"1\":{\"20\":1}}],[\"创建绑定对象\",{\"1\":{\"19\":1}}],[\"创建bindservice服务端\",{\"1\":{\"19\":1}}],[\"绝对不会\",{\"1\":{\"19\":1}}],[\"实践\",{\"1\":{\"116\":1}}],[\"实际占用大小为16比特\",{\"1\":{\"282\":1}}],[\"实际保存键值对的数组\",{\"1\":{\"280\":1}}],[\"实际内容一致\",{\"1\":{\"226\":1}}],[\"实际代码可以参考这里\",{\"1\":{\"211\":1}}],[\"实际的执行的类是powerimageplatformchannel\",{\"1\":{\"211\":1}}],[\"实际调用的是\",{\"1\":{\"111\":1}}],[\"实际上要比快速排序稍慢一些\",{\"1\":{\"442\":1}}],[\"实际上就是onisolateinitialize\",{\"1\":{\"382\":1}}],[\"实际上就是通过管理element的插入\",{\"1\":{\"119\":1}}],[\"实际上返回的是一个tuple\",{\"1\":{\"369\":1}}],[\"实际上这个类期望\",{\"1\":{\"291\":1}}],[\"实际上图片信息在对应的powertextureimageinfo\",{\"1\":{\"211\":1}}],[\"实际上根据此方式\",{\"1\":{\"172\":1}}],[\"实际上expanded就是flexfit\",{\"1\":{\"131\":1}}],[\"实际上inheritedwidget本身只标记了colorfulcontainer为dirty\",{\"1\":{\"130\":1}}],[\"实际上inheritedelement没有重新创建\",{\"1\":{\"128\":1}}],[\"实际上取了widget的child\",{\"1\":{\"128\":1}}],[\"实际上\",{\"1\":{\"126\":1,\"196\":1}}],[\"实际上不存在\",{\"1\":{\"126\":1}}],[\"实际上是开启了处理消息队列\",{\"1\":{\"389\":1}}],[\"实际上是继承自\",{\"1\":{\"182\":1}}],[\"实际上是将发送指令到io\",{\"1\":{\"111\":1}}],[\"实际上是通过\",{\"1\":{\"103\":1}}],[\"实际上创建的是\",{\"1\":{\"111\":1}}],[\"实际设备高度为2160\",{\"1\":{\"81\":2}}],[\"实例化asynctask对象\",{\"1\":{\"80\":1}}],[\"实现思路是\",{\"1\":{\"438\":1}}],[\"实现思路如下\",{\"1\":{\"432\":1}}],[\"实现如下\",{\"1\":{\"430\":1,\"459\":1}}],[\"实现阻塞同步时\",{\"1\":{\"320\":1}}],[\"实现线程安全有以下几种方法\",{\"1\":{\"317\":1}}],[\"实现序列化与反序列化的细节\",{\"1\":{\"310\":1}}],[\"实现可序列化最简单安全的方式是采用枚举的形式\",{\"1\":{\"305\":1}}],[\"实现简单\",{\"1\":{\"303\":1}}],[\"实现注解\",{\"1\":{\"298\":1}}],[\"实现原理\",{\"1\":{\"297\":1}}],[\"实现接口的方法\",{\"1\":{\"295\":1}}],[\"实现滑动效果\",{\"1\":{\"216\":1}}],[\"实现协调\",{\"1\":{\"213\":1}}],[\"实现布局\",{\"1\":{\"212\":2,\"227\":2}}],[\"实现近似线性插值\",{\"1\":{\"184\":1}}],[\"实现的思路就是递归\",{\"1\":{\"459\":1}}],[\"实现的\",{\"1\":{\"181\":1,\"212\":2,\"227\":2,\"233\":1}}],[\"实现的方法\",{\"1\":{\"111\":1}}],[\"实现非线性变化\",{\"1\":{\"168\":1}}],[\"实现非线性的变化\",{\"1\":{\"157\":1}}],[\"实现\",{\"0\":{\"308\":1,\"311\":1,\"314\":1},\"1\":{\"158\":1,\"169\":1,\"170\":1,\"227\":1,\"229\":1,\"405\":1}}],[\"实现丰富的动画\",{\"1\":{\"156\":1}}],[\"实现逻辑也比较简单\",{\"1\":{\"155\":1}}],[\"实现隐式动画的常用流程\",{\"1\":{\"152\":1}}],[\"实现程度由易到难\",{\"1\":{\"146\":1,\"157\":1}}],[\"实现一个简单的读取文件的代码如下\",{\"1\":{\"110\":1}}],[\"实现具体的逻辑\",{\"1\":{\"103\":1}}],[\"实现inject注入入口\",{\"1\":{\"89\":1}}],[\"实现启动targetintent而非proxyintent\",{\"1\":{\"72\":1}}],[\"实现拦截targetintent并发起proxyintent\",{\"1\":{\"72\":1}}],[\"实现动画视觉效果\",{\"1\":{\"157\":1}}],[\"实现动画效果\",{\"1\":{\"148\":1}}],[\"实现动画\",{\"1\":{\"66\":1}}],[\"实现路径绘制\",{\"1\":{\"63\":1}}],[\"实现了方法调用的最快路径\",{\"1\":{\"395\":1}}],[\"实现了renderabstractviewport接口\",{\"1\":{\"237\":1}}],[\"实现了不同的子类分别创建\",{\"1\":{\"209\":1}}],[\"实现了跨进程\",{\"1\":{\"58\":1}}],[\"实现了send\",{\"1\":{\"43\":1}}],[\"实现分页\",{\"1\":{\"58\":1}}],[\"实现toolbar的效果\",{\"1\":{\"55\":1}}],[\"实现deathrecipient接口的方法\",{\"1\":{\"36\":1}}],[\"实现该回调方法\",{\"1\":{\"35\":1}}],[\"实现客户端和服务端交互\",{\"1\":{\"19\":1}}],[\"实在没有必要再花费时间在这里了\",{\"1\":{\"0\":1}}],[\"绑定一些数据\",{\"1\":{\"382\":1}}],[\"绑定在一起\",{\"1\":{\"218\":1}}],[\"绑定到之前生成的renderview上面\",{\"1\":{\"120\":1}}],[\"绑定到服务端获取binder对象\",{\"1\":{\"32\":1}}],[\"绑定服务是异步进行的\",{\"1\":{\"21\":1}}],[\"绑定服务\",{\"1\":{\"19\":1}}],[\"绑定服务时被调用\",{\"1\":{\"19\":1}}],[\"绑定service\",{\"1\":{\"17\":1}}],[\"客户端的messenger\",{\"1\":{\"43\":2}}],[\"客户端远程请求经过系统封装后调用该方法\",{\"1\":{\"40\":1}}],[\"客户端会被挂起\",{\"1\":{\"36\":1}}],[\"客户端调用服务端方法\",{\"1\":{\"36\":1}}],[\"客户端调用服务端和服务端回调客户端方法\",{\"1\":{\"36\":1}}],[\"客户端从ibinder对象中获取到aidl接口对象\",{\"1\":{\"35\":1}}],[\"客户端提供的方法\",{\"1\":{\"35\":1}}],[\"客户端使用ibinder实例化messenger\",{\"1\":{\"20\":1}}],[\"客户端\",{\"0\":{\"37\":1},\"1\":{\"19\":1,\"20\":2,\"32\":1,\"408\":2,\"409\":1,\"410\":1,\"419\":2}}],[\"客户端通过其访问service中的公共方法\",{\"1\":{\"19\":1}}],[\"用数组实现的队列大小固定\",{\"1\":{\"452\":1}}],[\"用链表实现的队列可以自由扩充\",{\"1\":{\"452\":1}}],[\"用链地址法比较好\",{\"1\":{\"428\":1}}],[\"用一段连续的内存来保存\",{\"1\":{\"450\":1}}],[\"用一个值专门记录要移动到的下标\",{\"1\":{\"439\":1}}],[\"用一个n大小的数组保存\",{\"1\":{\"433\":1}}],[\"用他实现的优先级队列插入和删除时间复杂度都是o\",{\"1\":{\"439\":1}}],[\"用dfs比较好实现\",{\"1\":{\"438\":1}}],[\"用队列实现\",{\"1\":{\"438\":1}}],[\"用栈实现\",{\"1\":{\"437\":1}}],[\"用n\",{\"1\":{\"433\":1}}],[\"用字符代替对应的编码\",{\"1\":{\"432\":1}}],[\"用字符的编码替代字符\",{\"1\":{\"432\":1}}],[\"用\",{\"1\":{\"419\":1}}],[\"用官网的安装包\",{\"1\":{\"409\":1}}],[\"用如下代码将布局与页面绑定到一起\",{\"1\":{\"401\":1}}],[\"用beautifulsoup解析文档内容\",{\"1\":{\"371\":1}}],[\"用build\",{\"1\":{\"54\":1}}],[\"用逗号分隔\",{\"1\":{\"369\":1}}],[\"用新的值执行\",{\"1\":{\"337\":1}}],[\"用类全限定名获取类的二进制字节流\",{\"1\":{\"274\":1}}],[\"用作android等内存紧张的设备中的缓存\",{\"1\":{\"270\":1}}],[\"用来切换界面了\",{\"1\":{\"400\":1}}],[\"用来使用数据类xxxrepository类的实例创建对应的viewmodel\",{\"1\":{\"399\":1}}],[\"用来存储所有的dart\",{\"1\":{\"392\":1}}],[\"用来执行gc\",{\"1\":{\"392\":1}}],[\"用来创建执行网络请求的requestcall\",{\"1\":{\"364\":1}}],[\"用来逐个在item中延迟执行完整操作\",{\"1\":{\"328\":1}}],[\"用来从parcel中创建parcelable类\",{\"1\":{\"314\":1}}],[\"用来生成其他自定义的注解\",{\"1\":{\"298\":1}}],[\"用来在协程之间传递多个值\",{\"1\":{\"328\":1}}],[\"用来在运行时获取给定类的构造函数\",{\"1\":{\"295\":1}}],[\"用来在遍历的过程中检查hashmap是否被改动过来\",{\"1\":{\"280\":1}}],[\"用来保存线程私有的数据\",{\"1\":{\"288\":1}}],[\"用来遍历hashmap\",{\"1\":{\"280\":1}}],[\"用来支持方法代码\",{\"1\":{\"278\":1}}],[\"用来指代某种值得符号\",{\"1\":{\"254\":1}}],[\"用来对\",{\"1\":{\"225\":1}}],[\"用来放置hero过渡动画\",{\"1\":{\"180\":1}}],[\"用来管理与widget\",{\"1\":{\"119\":1}}],[\"用来管理rendering\",{\"1\":{\"118\":1}}],[\"用来响应点击事件\",{\"1\":{\"79\":1}}],[\"用来初始化进程管理\",{\"1\":{\"60\":1}}],[\"用该\",{\"1\":{\"79\":2}}],[\"用户硬件挂载点\",{\"1\":{\"349\":1}}],[\"用户需要通过writeexternal\",{\"1\":{\"310\":1}}],[\"用户传入的nestedscrollview的scrollcontroller\",{\"1\":{\"224\":1}}],[\"用户通过\",{\"1\":{\"198\":1}}],[\"用户\",{\"1\":{\"190\":1,\"353\":1,\"357\":1}}],[\"用户可以通过传入\",{\"1\":{\"156\":1}}],[\"用户可能会以为系统卡顿\",{\"1\":{\"14\":1}}],[\"用户拒绝了赋予权限\",{\"1\":{\"69\":1}}],[\"用户同意后开始申请权限\",{\"1\":{\"69\":1}}],[\"用户态在该虚拟地址区域读写就相当于读写这个文件\",{\"1\":{\"58\":1}}],[\"用户空间包括代码\",{\"1\":{\"58\":1}}],[\"用户动态给这些属性赋值\",{\"1\":{\"56\":1}}],[\"用androidstudio自动生成一个binder类\",{\"1\":{\"40\":1}}],[\"用于实现hexo文章创建\",{\"1\":{\"366\":1}}],[\"用于更新下载进度等\",{\"1\":{\"364\":1}}],[\"用于异步返回多个值\",{\"1\":{\"335\":1}}],[\"用于方法的参数\",{\"1\":{\"322\":1}}],[\"用于方法的返回值\",{\"1\":{\"322\":1}}],[\"用于返回可迭代的数组\",{\"1\":{\"321\":1}}],[\"用于查缺补漏\",{\"1\":{\"321\":1}}],[\"用于查找指定\",{\"1\":{\"175\":1}}],[\"用于描述其它类型的annotation应该被作为被标注的程序成员的公共api\",{\"1\":{\"298\":1}}],[\"用于获取nestedscrollview的scrollcontroller\",{\"1\":{\"224\":1}}],[\"用于获取图片\",{\"1\":{\"204\":1}}],[\"用于rawgesturedetector\",{\"1\":{\"223\":1}}],[\"用于\",{\"1\":{\"168\":1}}],[\"用于isdone中\",{\"1\":{\"165\":1}}],[\"用于操纵动画\",{\"1\":{\"161\":1}}],[\"用于驱动隐式动画\",{\"1\":{\"147\":1}}],[\"用于管理widget框架的类\",{\"1\":{\"119\":1}}],[\"用于将rootwidget绑定到renderview上面\",{\"1\":{\"119\":1}}],[\"用于将部分信息统一放置在本地配置文件中\",{\"1\":{\"54\":1}}],[\"用于向io\",{\"1\":{\"111\":1,\"112\":2}}],[\"用于提供androidinjector\",{\"1\":{\"90\":1}}],[\"用于调用hook方法\",{\"1\":{\"71\":1}}],[\"用于调用客户端的具体方法\",{\"1\":{\"35\":1}}],[\"用于和嵌套滑动事件绑定\",{\"1\":{\"55\":1}}],[\"用于本地调用\",{\"1\":{\"43\":1}}],[\"用于服务端\",{\"1\":{\"43\":2}}],[\"用于服务端往客户端通信\",{\"1\":{\"35\":1}}],[\"用于在ontransact中区分调用的是哪个方法\",{\"1\":{\"40\":1}}],[\"用于android\",{\"1\":{\"32\":1}}],[\"用于连续作业\",{\"1\":{\"17\":1}}],[\"用msg\",{\"1\":{\"31\":1}}],[\"用messenger创建ibinder对象\",{\"1\":{\"20\":1}}],[\"用其将message对象发送给service\",{\"1\":{\"20\":1}}],[\"用handler创建messenger对象\",{\"1\":{\"20\":1}}],[\"最简单的\",{\"1\":{\"466\":1}}],[\"最简单有效的方法是使用后将其移除\",{\"1\":{\"288\":1}}],[\"最慢的排序\",{\"1\":{\"455\":1}}],[\"最先插入的在队首\",{\"1\":{\"447\":1}}],[\"最初的snapshot并不包含machine\",{\"1\":{\"396\":1}}],[\"最通用的一种称为\",{\"1\":{\"327\":1}}],[\"最近在学习\",{\"1\":{\"408\":1}}],[\"最近在项目里面遇到了屏幕适配的问题\",{\"1\":{\"53\":1}}],[\"最近看到一个帖子\",{\"1\":{\"302\":1}}],[\"最近手机中涉及到用户账户密码保存的问题\",{\"1\":{\"296\":1}}],[\"最长为65534\",{\"0\":{\"283\":1}}],[\"最多交换n\",{\"1\":{\"289\":1}}],[\"最多会返回未执行的overscroll\",{\"1\":{\"226\":1}}],[\"最多向下滑动到minscrollextent\",{\"1\":{\"226\":1}}],[\"最大\",{\"1\":{\"456\":1}}],[\"最大值和最小值\",{\"0\":{\"431\":1}}],[\"最大值不限定\",{\"1\":{\"220\":2}}],[\"最大滑动范围之后\",{\"1\":{\"226\":1}}],[\"最大为maxscrollextent\",{\"1\":{\"220\":1}}],[\"最大只能是父容器分配的大小\",{\"1\":{\"131\":1}}],[\"最小生成树边比顶点数小1\",{\"1\":{\"438\":1}}],[\"最小值\",{\"1\":{\"220\":1}}],[\"最小宽以及它的布局文件\",{\"1\":{\"79\":1}}],[\"最常用的子类是\",{\"1\":{\"160\":1}}],[\"最重要的是使用\",{\"1\":{\"150\":1}}],[\"最\",{\"1\":{\"117\":1,\"127\":1}}],[\"最终结果\",{\"1\":{\"458\":1}}],[\"最终通过new\",{\"1\":{\"378\":1}}],[\"最终还是调用了okhttp3\",{\"1\":{\"365\":1}}],[\"最终用来保存threadlocal以及对应值的是一个entry数组\",{\"1\":{\"288\":1}}],[\"最终返回的是rawimage\",{\"1\":{\"205\":1}}],[\"最终会通过powerimageplugin\",{\"1\":{\"211\":1}}],[\"最终会返回经过封装的texture\",{\"1\":{\"205\":1}}],[\"最终会触发\",{\"1\":{\"106\":1}}],[\"最终调用transform\",{\"1\":{\"183\":1}}],[\"最终调用element同名方法\",{\"1\":{\"122\":1}}],[\"最终是在\",{\"1\":{\"181\":1}}],[\"最终执行的是element同名方法逻辑\",{\"1\":{\"126\":1}}],[\"最终在renderobjecttowidgetelement的updatechild方法被创建并被buildowner\",{\"1\":{\"125\":1}}],[\"最终在activitymanagerservice通过binder驱动程序调用activitythread类中的schedulebindservice方法传递到service所在进程中\",{\"1\":{\"58\":1}}],[\"最终回调用户需要的命令\",{\"1\":{\"116\":1}}],[\"最终都会使用\",{\"1\":{\"109\":1}}],[\"最终都是调用的\",{\"1\":{\"105\":1}}],[\"最终贝塞尔曲线path计算方法如下\",{\"1\":{\"63\":1}}],[\"最终事件会传递给下层具有焦点的window\",{\"1\":{\"41\":1}}],[\"最后插入的数据在队尾\",{\"1\":{\"447\":1}}],[\"最后插入的数据在栈顶\",{\"1\":{\"446\":1}}],[\"最后将ssa\",{\"1\":{\"396\":1}}],[\"最后在创建了新的isolate之后\",{\"1\":{\"389\":1}}],[\"最后在当前isolate对应的isolategroup的线程池中执行spawnisolatetask\",{\"1\":{\"379\":1}}],[\"最后在非当前isolate的线程中执行\",{\"1\":{\"116\":1}}],[\"最后是根据native端返回的信息\",{\"1\":{\"377\":1}}],[\"最后是通过rawreceiveport\",{\"1\":{\"111\":1}}],[\"最后通过该call对象的enqueue方法执行网络请求\",{\"1\":{\"365\":1}}],[\"最后通过msg\",{\"1\":{\"25\":1}}],[\"最后把本地仓库origin提交到远程的github仓库\",{\"1\":{\"347\":1}}],[\"最后反序列化后的password为pass\",{\"1\":{\"306\":1}}],[\"最后如果有\",{\"1\":{\"226\":1}}],[\"最后交给inner处理overscroll\",{\"1\":{\"226\":1}}],[\"最后只有\",{\"1\":{\"223\":1}}],[\"最后会通过调用wait\",{\"1\":{\"297\":1}}],[\"最后会调用\",{\"1\":{\"223\":1}}],[\"最后会根据情况调用oncancelled\",{\"1\":{\"80\":1}}],[\"最后还调用了didupdatetweens\",{\"1\":{\"148\":1}}],[\"最后都是执行的messagehandlertask\",{\"1\":{\"391\":1}}],[\"最后都是调用了\",{\"1\":{\"111\":1,\"378\":1}}],[\"最后都执行了一下三步\",{\"1\":{\"387\":1}}],[\"最后都会触发timer的\",{\"1\":{\"109\":1}}],[\"最后调用\",{\"1\":{\"105\":1,\"107\":1}}],[\"最后调用的是\",{\"1\":{\"96\":1}}],[\"最后介绍一下在google官方demo中学到的一个小技巧\",{\"1\":{\"88\":1}}],[\"最后\",{\"1\":{\"80\":1,\"401\":1}}],[\"最后一个元素中该引用为null\",{\"1\":{\"451\":1}}],[\"最后一个输入空数据\",{\"1\":{\"371\":1}}],[\"最后一个为根节点\",{\"1\":{\"346\":1}}],[\"最后一个点pn的后一个点仍为pn\",{\"1\":{\"62\":1}}],[\"最后一周的影响\",{\"1\":{\"302\":2}}],[\"最后一列\",{\"1\":{\"126\":1}}],[\"最后一次调用startservice\",{\"1\":{\"17\":1}}],[\"最后也是在sendmessagedelayed方法中调用sendmessageattime\",{\"1\":{\"30\":1}}],[\"最好先判断是否为null\",{\"1\":{\"19\":1}}],[\"最好在service中单独创建一个线程\",{\"1\":{\"17\":1}}],[\"最安全\",{\"1\":{\"17\":1}}],[\"除过这里用到的取法之外\",{\"1\":{\"467\":1}}],[\"除文章中罗列的链接外\",{\"1\":{\"287\":1}}],[\"除以上三种外\",{\"1\":{\"272\":1}}],[\"除非子类特别调用父类的方法\",{\"1\":{\"369\":1}}],[\"除非特殊说明\",{\"1\":{\"282\":1}}],[\"除非在时间和空间比较特殊的情况下\",{\"1\":{\"280\":1}}],[\"除非imagestreamcompleter没有\",{\"1\":{\"197\":1}}],[\"除非是挂起的intent如pendingintent\",{\"1\":{\"17\":1}}],[\"除了常见的android\",{\"1\":{\"401\":1}}],[\"除了可以使用系统的classloader外还可以自定义classloader\",{\"1\":{\"274\":1}}],[\"除了父级传入的offset外\",{\"1\":{\"239\":1}}],[\"除了设置修改axisdirection\",{\"1\":{\"237\":1}}],[\"除了上述在修改offset的时候添加\",{\"1\":{\"237\":1}}],[\"除了上述与\",{\"1\":{\"183\":1}}],[\"除了修改部分类为\",{\"1\":{\"208\":1}}],[\"除了powerimage\",{\"1\":{\"204\":1}}],[\"除了之前文章中分析的传入\",{\"1\":{\"182\":1}}],[\"除了之前提到的各个属性之外\",{\"1\":{\"175\":1}}],[\"除了\",{\"1\":{\"179\":1,\"201\":1}}],[\"除了从\",{\"1\":{\"161\":1}}],[\"除了后面要详细分析的\",{\"1\":{\"159\":1}}],[\"除了直接继承\",{\"1\":{\"153\":1,\"156\":1}}],[\"除了检查并更新\",{\"1\":{\"150\":1}}],[\"除了调用父类的mount方法外\",{\"1\":{\"121\":1}}],[\"除了我们在代码里面添加的center和text这两个widget之外\",{\"1\":{\"117\":1}}],[\"除了同步读写文件是对返回的文件引用直接操作外\",{\"1\":{\"111\":1}}],[\"除了future\",{\"1\":{\"102\":1}}],[\"除了下面列出来的使用future或者timer等创建的方法外\",{\"1\":{\"101\":1}}],[\"除了处理本身变化外\",{\"1\":{\"64\":1}}],[\"除了处理本身的变化外\",{\"1\":{\"64\":1}}],[\"除了部分字体等显示需要微调外\",{\"1\":{\"53\":1}}],[\"除了socket\",{\"1\":{\"40\":1}}],[\"除此之外再没有用到a\",{\"1\":{\"265\":1}}],[\"除此之外\",{\"1\":{\"15\":1,\"158\":1,\"161\":1,\"202\":1}}],[\"内联缓存的实现主要有\",{\"1\":{\"395\":1}}],[\"内联缓存\",{\"1\":{\"395\":1}}],[\"内联函数会直接被插入到被调用的地方\",{\"1\":{\"322\":1}}],[\"内是参数\",{\"1\":{\"345\":1}}],[\"内是不是有\",{\"1\":{\"225\":1}}],[\"内其余\",{\"1\":{\"226\":1}}],[\"内容放入目标文件夹\",{\"1\":{\"419\":1}}],[\"内容是纯文本\",{\"1\":{\"358\":1}}],[\"内容尺寸如何\",{\"1\":{\"213\":1}}],[\"内容\",{\"1\":{\"212\":1}}],[\"内容更加完善的文章\",{\"1\":{\"0\":1}}],[\"内置的显式动画为\",{\"1\":{\"156\":1}}],[\"内置的隐式动画为\",{\"1\":{\"156\":1}}],[\"内置的以\",{\"1\":{\"156\":1}}],[\"内置的这些类主要以\",{\"1\":{\"146\":1,\"157\":1}}],[\"内置封装好的动画相关的\",{\"1\":{\"146\":1}}],[\"内部类访问这个对象时\",{\"1\":{\"317\":1}}],[\"内部类访问外部类的全部变量和局部变量\",{\"1\":{\"281\":1}}],[\"内部类的话\",{\"1\":{\"282\":1}}],[\"内部类中的外部类全局变量都是最新的\",{\"1\":{\"281\":1}}],[\"内部类通过局部变量的备份引用访问的this\",{\"1\":{\"281\":1}}],[\"内部通过\",{\"1\":{\"226\":1}}],[\"内部通过imageprovider\",{\"1\":{\"188\":1}}],[\"内部的\",{\"1\":{\"223\":1}}],[\"内部会调用imageprovider\",{\"1\":{\"196\":1}}],[\"内部创建\",{\"1\":{\"212\":1}}],[\"内部创建的\",{\"1\":{\"181\":1}}],[\"内部创建并监听\",{\"1\":{\"156\":1}}],[\"内部可以通过herocontrollerscope\",{\"1\":{\"178\":1}}],[\"内部都是通过\",{\"1\":{\"161\":1}}],[\"内部控制\",{\"1\":{\"154\":1}}],[\"内部持有使用者传入的tween\",{\"1\":{\"153\":1}}],[\"内部\",{\"1\":{\"146\":1,\"157\":1}}],[\"内部调用了readobject0\",{\"1\":{\"305\":1}}],[\"内部调用scrolldragcontroller\",{\"1\":{\"226\":1}}],[\"内部调用sthreadlocal获取已有的looper对象\",{\"1\":{\"26\":1}}],[\"内部调用getpostmessage\",{\"1\":{\"31\":1}}],[\"内核空间的某些区域被映射到所有进程共享的物理页面\",{\"1\":{\"58\":1}}],[\"内核空间包括内核中的代码和数据结构\",{\"1\":{\"58\":1}}],[\"内存中的状态信息\",{\"1\":{\"349\":1}}],[\"内存中的图片数据创建了对应的\",{\"1\":{\"211\":1}}],[\"内存利用效率低\",{\"1\":{\"262\":1}}],[\"内存一分为二\",{\"1\":{\"262\":1}}],[\"内存指针创建ui\",{\"1\":{\"211\":1}}],[\"内存管理\",{\"1\":{\"60\":1}}],[\"内存管理单元\",{\"1\":{\"58\":1}}],[\"内存缓存区\",{\"1\":{\"58\":1}}],[\"内存映射提供了共享对象的机制\",{\"1\":{\"58\":1}}],[\"内存再次空闲系统也不会再重新创建服务\",{\"1\":{\"17\":1}}],[\"内存空闲时系统会重新创建service\",{\"1\":{\"17\":1}}],[\"会很耗时\",{\"1\":{\"460\":1}}],[\"会出现找不到没有后继点的顶点\",{\"1\":{\"438\":1}}],[\"会显示用户在植物目录中选择并种植的植物信息\",{\"1\":{\"399\":1}}],[\"会对应创建一个新的系统线程\",{\"1\":{\"390\":1}}],[\"会删除file\",{\"1\":{\"356\":1}}],[\"会丢弃来不及处理的中间值\",{\"1\":{\"344\":1}}],[\"会取消掉所有子协程\",{\"1\":{\"330\":1}}],[\"会阻塞调用线程\",{\"1\":{\"327\":1}}],[\"会打印\",{\"1\":{\"325\":1}}],[\"会运行一个新的协程线程\",{\"1\":{\"323\":1}}],[\"会有一些特殊方法\",{\"1\":{\"322\":1}}],[\"会有一定的浪费\",{\"1\":{\"263\":1}}],[\"会优先尝试使用轻量级锁\",{\"1\":{\"320\":1}}],[\"会消耗大量的时间\",{\"1\":{\"317\":1}}],[\"会自动向上到其父类中查找\",{\"1\":{\"298\":1}}],[\"会进入该界面显示植物详细介绍\",{\"1\":{\"399\":1}}],[\"会进入等待池\",{\"1\":{\"297\":1}}],[\"会进入锁池和其他类似的线程一起竞争该对象的锁\",{\"1\":{\"297\":1}}],[\"会导致部分数据重复\",{\"1\":{\"370\":1}}],[\"会导致严重的问题\",{\"1\":{\"280\":1}}],[\"会导致渐变为黑色\",{\"1\":{\"184\":1}}],[\"会产生两个对象\",{\"1\":{\"254\":1}}],[\"会oomstring\",{\"1\":{\"254\":1}}],[\"会oom\",{\"1\":{\"250\":1,\"251\":1,\"253\":1,\"254\":1}}],[\"会一次性创建所有child内容\",{\"1\":{\"242\":1}}],[\"会得到最大的主轴尺寸\",{\"1\":{\"238\":1}}],[\"会依次展示出\",{\"1\":{\"231\":1}}],[\"会依次尝试从\",{\"1\":{\"198\":1}}],[\"会监听offset的变化来重新绘制slivers从而实现滑动效果\",{\"1\":{\"227\":1}}],[\"会发出overscroll通知\",{\"1\":{\"221\":1}}],[\"会应用\",{\"1\":{\"221\":1}}],[\"会使用\",{\"1\":{\"207\":1}}],[\"会按照实际情况更新\",{\"1\":{\"223\":1}}],[\"会按照传入的\",{\"1\":{\"198\":1}}],[\"会按照他们的flex占比来分配每个child可以占据的空间大小\",{\"1\":{\"131\":1}}],[\"会比较明显\",{\"1\":{\"198\":1}}],[\"会通过\",{\"1\":{\"190\":1}}],[\"会通过一系列条件判断是由viewgroup拦截该事件\",{\"1\":{\"13\":1}}],[\"会尝试应用到\",{\"1\":{\"226\":1}}],[\"会尝试使用平台\",{\"1\":{\"188\":1}}],[\"会尝试重新调用onstartcommand\",{\"1\":{\"17\":1}}],[\"会展示\",{\"1\":{\"174\":1}}],[\"会从网络下载\",{\"1\":{\"198\":1}}],[\"会从网络\",{\"1\":{\"188\":1}}],[\"会从小变大\",{\"1\":{\"173\":1}}],[\"会从链表尾部开始读取\",{\"1\":{\"103\":1}}],[\"会执行\",{\"1\":{\"190\":1,\"226\":1}}],[\"会执行动画\",{\"1\":{\"147\":1}}],[\"会执行下面的方法\",{\"1\":{\"115\":1}}],[\"会被改为切换到的协程所使用的的值\",{\"1\":{\"325\":1}}],[\"会被分为\",{\"1\":{\"317\":1}}],[\"会被压缩为a\",{\"1\":{\"264\":1}}],[\"会被\",{\"1\":{\"213\":1}}],[\"会被发送到这里处理\",{\"1\":{\"145\":1}}],[\"会被回调的方法\",{\"1\":{\"115\":1}}],[\"会交由当前代码所在的zone处理\",{\"1\":{\"141\":1}}],[\"会判断以下几种情况\",{\"1\":{\"128\":1}}],[\"会创建\",{\"1\":{\"213\":1}}],[\"会创建renderimage并在renderimage\",{\"1\":{\"189\":1}}],[\"会创建rootwidget对应的element并将其作为当前element的child\",{\"1\":{\"121\":1}}],[\"会创建一个\",{\"1\":{\"100\":1}}],[\"会是一个新的线程\",{\"1\":{\"115\":1}}],[\"会压入消息栈中\",{\"1\":{\"115\":1}}],[\"会先遍历完本层所有的顶点\",{\"1\":{\"438\":1}}],[\"会先顺着一个邻接点一直走到头\",{\"1\":{\"437\":1}}],[\"会先往深处遍历完一条路径\",{\"1\":{\"437\":1}}],[\"会先删除f1\",{\"1\":{\"349\":1}}],[\"会先计算key的hash值\",{\"1\":{\"280\":1}}],[\"会先尝试下滑\",{\"1\":{\"226\":1}}],[\"会先向上滑动\",{\"1\":{\"212\":1}}],[\"会先通过powerimageloader\",{\"1\":{\"211\":1}}],[\"会先通过dart\",{\"1\":{\"115\":1}}],[\"会先执行rawreceiveport原本的handler内容\",{\"1\":{\"101\":1}}],[\"会切换出当前isolate直到下面的\",{\"1\":{\"115\":1}}],[\"会调用其exit\",{\"1\":{\"297\":1}}],[\"会调用此方法\",{\"1\":{\"211\":1}}],[\"会调用paintimage方法绘制\",{\"1\":{\"195\":1}}],[\"会调用inheritedelement的update\",{\"1\":{\"128\":1}}],[\"会调用对应的element的markneedsbuild\",{\"1\":{\"128\":1}}],[\"会调用下面的方法\",{\"1\":{\"115\":1}}],[\"会调用\",{\"1\":{\"111\":1,\"112\":1,\"150\":1}}],[\"会调用eventhandlerimplementation\",{\"1\":{\"108\":1}}],[\"会分别使用messagehandler执行或者在名为event\",{\"1\":{\"109\":1}}],[\"会将\",{\"1\":{\"212\":1}}],[\"会将自己注册到appcolor\",{\"1\":{\"130\":1}}],[\"会将其加入到\",{\"1\":{\"108\":1}}],[\"会将此值转换为相应的实际像素数\",{\"1\":{\"53\":1}}],[\"会触发\",{\"1\":{\"100\":1,\"167\":1}}],[\"会在切换协程的时候失效\",{\"1\":{\"325\":1}}],[\"会在反序列化时用到并返回这里提供的对象\",{\"1\":{\"305\":1}}],[\"会在这里被处理\",{\"1\":{\"144\":1}}],[\"会在这里回调mworker的call\",{\"1\":{\"80\":1}}],[\"会在\",{\"1\":{\"111\":1,\"115\":1}}],[\"会在app\",{\"1\":{\"40\":1}}],[\"会向左\",{\"1\":{\"41\":1}}],[\"会主动移除其注册的listener\",{\"1\":{\"36\":1}}],[\"会绑定宿主\",{\"1\":{\"21\":1}}],[\"会重建服务并传递给最后一个intent\",{\"1\":{\"17\":1}}],[\"无向不带权图中\",{\"1\":{\"438\":1}}],[\"无日志输出模式\",{\"1\":{\"416\":1}}],[\"无末尾逗号\",{\"1\":{\"371\":1}}],[\"无需遍历时效果最好\",{\"1\":{\"428\":1}}],[\"无需手动传入\",{\"1\":{\"369\":1}}],[\"无需再返回当前函数\",{\"1\":{\"322\":1}}],[\"无需再滑动才会向上滑动列表\",{\"1\":{\"212\":1}}],[\"无权限\",{\"1\":{\"351\":1}}],[\"无提示\",{\"1\":{\"349\":1}}],[\"无同步方案\",{\"0\":{\"320\":1}}],[\"无符号右移\",{\"1\":{\"280\":1}}],[\"无法右旋\",{\"1\":{\"458\":1}}],[\"无法进行jit意味着\",{\"1\":{\"396\":1}}],[\"无法直接转化为字符串\",{\"1\":{\"296\":1}}],[\"无法\",{\"1\":{\"288\":1}}],[\"无法影响其生存时间\",{\"1\":{\"271\":1}}],[\"无法识别手势\",{\"1\":{\"223\":1}}],[\"无stw\",{\"1\":{\"262\":1}}],[\"无则创建并返回\",{\"1\":{\"254\":1}}],[\"无论如何\",{\"1\":{\"291\":1,\"391\":1}}],[\"无论这些thread使用的是同一个threadlocal对象还是完全不同的threadlocal对象\",{\"1\":{\"288\":1}}],[\"无论content是否可见\",{\"1\":{\"240\":1}}],[\"无论\",{\"1\":{\"213\":1,\"220\":1}}],[\"无论他们是否使用到了inheritedwidget\",{\"1\":{\"130\":1}}],[\"无论是哪种worker\",{\"1\":{\"391\":1}}],[\"无论是runheavyweight\",{\"1\":{\"389\":1}}],[\"无论是恶意的流还是不完整的流\",{\"1\":{\"306\":1}}],[\"无论是在\",{\"1\":{\"223\":1}}],[\"无论是普通的文件格式\",{\"1\":{\"111\":1}}],[\"无论是\",{\"1\":{\"106\":1,\"109\":1,\"178\":1,\"186\":1,\"203\":1,\"230\":1}}],[\"无论是单次的还是循环的timer都是使用vmlibraryhooks\",{\"1\":{\"105\":1}}],[\"无论是microtask还是普通的event\",{\"1\":{\"95\":1}}],[\"无须复制\",{\"1\":{\"58\":1}}],[\"无限期运行\",{\"1\":{\"17\":1}}],[\"无\",{\"1\":{\"17\":1}}],[\"前端也类似\",{\"1\":{\"452\":1}}],[\"前序遍历\",{\"1\":{\"346\":3,\"430\":1}}],[\"前五步是类加载机制\",{\"1\":{\"273\":1}}],[\"前至少经历两个标记过程\",{\"1\":{\"266\":1}}],[\"前后传入的值不同便可以自动从\",{\"1\":{\"157\":1}}],[\"前后传入的值不同\",{\"1\":{\"146\":1}}],[\"前者优先级高\",{\"1\":{\"376\":1}}],[\"前者执行失败才会执行后者\",{\"1\":{\"361\":1}}],[\"前者执行成功才会执行后者\",{\"1\":{\"361\":1}}],[\"前者对待异常是不处理的\",{\"1\":{\"329\":1}}],[\"前者用于生成\",{\"1\":{\"152\":1}}],[\"前者一旦创建\",{\"1\":{\"132\":1}}],[\"前者在共有的进程中进行\",{\"1\":{\"17\":1}}],[\"前三个属性含义很明显\",{\"1\":{\"124\":1}}],[\"前三者都需要app在前台运行\",{\"1\":{\"3\":1}}],[\"前面我们知道renderview其实是一个renderobject\",{\"1\":{\"120\":1}}],[\"有三个柱子\",{\"1\":{\"459\":1}}],[\"有一组数据\",{\"1\":{\"459\":1}}],[\"有一些内置的动画\",{\"1\":{\"146\":1,\"157\":1}}],[\"有序\",{\"1\":{\"462\":1}}],[\"有序数组2\",{\"1\":{\"459\":1}}],[\"有序数组1\",{\"1\":{\"459\":1}}],[\"有序数组插入\",{\"1\":{\"451\":1}}],[\"有序数组查找快o\",{\"1\":{\"451\":1}}],[\"有序数组\",{\"0\":{\"451\":1}}],[\"有序性\",{\"1\":{\"317\":1}}],[\"有序性三个特征进行的\",{\"1\":{\"317\":1}}],[\"有两个子节点\",{\"1\":{\"441\":1}}],[\"有两种途径\",{\"1\":{\"318\":1}}],[\"有两种构造方法\",{\"1\":{\"161\":1}}],[\"有后继点\",{\"1\":{\"438\":1}}],[\"有着非常优雅的架构与十分简洁的代码\",{\"1\":{\"399\":1}}],[\"有new\",{\"1\":{\"391\":1}}],[\"有不同的获取数据的方式\",{\"1\":{\"387\":1}}],[\"有不同的项目\",{\"1\":{\"54\":1}}],[\"有2个\",{\"1\":{\"375\":1}}],[\"有了okhttpclient对象之后\",{\"1\":{\"364\":1}}],[\"有了以上知识\",{\"1\":{\"302\":1}}],[\"有指定的容量一样\",{\"1\":{\"328\":1}}],[\"有需要对其增加一个方法\",{\"1\":{\"321\":1}}],[\"有参的情况如下\",{\"1\":{\"321\":1}}],[\"有该注解则会被javadoc工具文档化\",{\"1\":{\"298\":1}}],[\"有该string对象则返回\",{\"1\":{\"254\":1}}],[\"有set\",{\"1\":{\"288\":1}}],[\"有1则1\",{\"1\":{\"280\":1}}],[\"有类变量赋值\",{\"1\":{\"279\":1}}],[\"有人说在堆中\",{\"1\":{\"274\":1}}],[\"有\",{\"1\":{\"225\":1,\"226\":1}}],[\"有什么优势和限制\",{\"1\":{\"212\":1,\"234\":1}}],[\"有关的逻辑\",{\"1\":{\"212\":1,\"227\":1}}],[\"有关的三个方法外\",{\"1\":{\"183\":1}}],[\"有以下几种类\",{\"1\":{\"211\":1}}],[\"有对应的特殊类\",{\"1\":{\"184\":1}}],[\"有时候看起来似乎他的child占据的大小既不全是父布局的剩余空间\",{\"1\":{\"131\":1}}],[\"有空闲sendport\",{\"1\":{\"112\":1}}],[\"有其他需求可以再自己实现\",{\"1\":{\"66\":1}}],[\"有的话就用调用entry并增加frequency\",{\"1\":{\"395\":1}}],[\"有的话就返回从readresolve\",{\"1\":{\"305\":1}}],[\"有的话就立即执行\",{\"1\":{\"109\":1}}],[\"有的话查找其位置\",{\"1\":{\"287\":1}}],[\"有的话直接返回本地对象\",{\"1\":{\"58\":1}}],[\"有的话则标记为deleted\",{\"1\":{\"47\":1}}],[\"有权限校验\",{\"1\":{\"58\":1}}],[\"有长度限制\",{\"1\":{\"58\":2}}],[\"有intent执行所需的context\",{\"1\":{\"75\":1}}],[\"有intent\",{\"1\":{\"17\":1}}],[\"有几分钟内的误差\",{\"1\":{\"5\":1}}],[\"是右节点\",{\"1\":{\"458\":1}}],[\"是左节点\",{\"1\":{\"458\":1}}],[\"是和栈相对的一种抽象数据类型\",{\"1\":{\"452\":1}}],[\"是具有图g的全部顶点\",{\"1\":{\"438\":1}}],[\"是具体执行读取文件的地方\",{\"1\":{\"111\":1}}],[\"是小于数组容量的质数\",{\"1\":{\"428\":1}}],[\"是第一生产力\",{\"1\":{\"405\":1}}],[\"是用来区分pause的\",{\"1\":{\"375\":1}}],[\"是用来创建\",{\"1\":{\"228\":1}}],[\"是isolate的native层实现\",{\"1\":{\"372\":1}}],[\"是app等平台对应的具体实现\",{\"1\":{\"372\":1}}],[\"是android系统第一个java进程\",{\"1\":{\"60\":1}}],[\"是生成的\",{\"1\":{\"347\":1}}],[\"是函数具体的行为\",{\"1\":{\"345\":1}}],[\"是的话就直接写入引用\",{\"1\":{\"309\":1}}],[\"是的话向\",{\"1\":{\"224\":1}}],[\"是获取该类及其实现的接口中所有的public方法\",{\"1\":{\"300\":1}}],[\"是获取图片资源的基类\",{\"1\":{\"196\":1}}],[\"是描述java代码的代码\",{\"1\":{\"298\":1}}],[\"是线程安全的\",{\"1\":{\"279\":1}}],[\"是将类或者接口组合到java虚拟机运行状态的过程\",{\"1\":{\"275\":1}}],[\"是将标准输入输出连接起来的进程\",{\"1\":{\"58\":1}}],[\"是内存溢出memory\",{\"1\":{\"256\":1}}],[\"是内存泄漏memory\",{\"1\":{\"256\":1}}],[\"是renderbox\",{\"1\":{\"237\":1}}],[\"是renderview的child\",{\"1\":{\"122\":1}}],[\"是真正显示在屏幕上的\",{\"1\":{\"227\":1}}],[\"是直接指定的\",{\"1\":{\"225\":1}}],[\"是为了将\",{\"1\":{\"220\":1}}],[\"是因为\",{\"1\":{\"220\":1}}],[\"是在dart\",{\"1\":{\"382\":1}}],[\"是在创建threadlocal的时候\",{\"1\":{\"288\":1}}],[\"是在jvm初始化类的时候初始化静态变量\",{\"1\":{\"279\":1}}],[\"是在new对象的时候初始化非静态变量\",{\"1\":{\"279\":1}}],[\"是在nestedscrollview中传给\",{\"1\":{\"217\":1}}],[\"是在运行时常量池中动态确定符号引用的具体值的过程\",{\"1\":{\"278\":1}}],[\"是在传入的begin\",{\"1\":{\"184\":1}}],[\"是power\",{\"1\":{\"208\":1}}],[\"是个不错的选择\",{\"1\":{\"202\":1}}],[\"是个抽象类\",{\"1\":{\"201\":1}}],[\"是对\",{\"1\":{\"194\":1}}],[\"是原始的\",{\"1\":{\"193\":1}}],[\"是ui\",{\"1\":{\"193\":1}}],[\"是从\",{\"1\":{\"172\":1}}],[\"是从callbacklist依次取出来执行\",{\"1\":{\"36\":1}}],[\"是由可以有多个边的顶点组成的结构\",{\"1\":{\"433\":1}}],[\"是由协程\",{\"1\":{\"334\":1}}],[\"是由圆形变成正方形的过渡动画\",{\"1\":{\"172\":1}}],[\"是由内核创建的第一个进程\",{\"1\":{\"60\":1}}],[\"是\",{\"1\":{\"157\":1,\"184\":1,\"188\":1,\"212\":1,\"213\":2,\"226\":2,\"228\":1,\"231\":1,\"233\":1,\"419\":1}}],[\"是center\",{\"1\":{\"122\":1}}],[\"是ffi还是texture\",{\"1\":{\"204\":1}}],[\"是file\",{\"1\":{\"111\":1}}],[\"是future\",{\"1\":{\"95\":1}}],[\"是kotlin中注解字段特别需要的\",{\"1\":{\"86\":1}}],[\"是可以使用的对象\",{\"1\":{\"82\":1}}],[\"是每一个字母所在单元的高度\",{\"1\":{\"64\":1}}],[\"是zygote孵化的第一个进程\",{\"1\":{\"60\":1}}],[\"是所有通用排序中最快的\",{\"1\":{\"460\":1}}],[\"是所有java进程的父进程\",{\"1\":{\"60\":1}}],[\"是所有用户进程鼻祖\",{\"1\":{\"60\":1}}],[\"是所有内核进程的鼻祖\",{\"1\":{\"60\":1}}],[\"是linux系统的内核进程\",{\"1\":{\"60\":1}}],[\"是启动android系统之前的引导程序\",{\"1\":{\"60\":1}}],[\"是servermanager内部创建匿名binder\",{\"1\":{\"58\":1}}],[\"是一组具有相同类型元素的集合\",{\"1\":{\"450\":1}}],[\"是一致的\",{\"1\":{\"396\":1}}],[\"是一种抽象数据类型\",{\"1\":{\"452\":1}}],[\"是一种特殊的队列\",{\"1\":{\"448\":1}}],[\"是一种双向机制\",{\"1\":{\"330\":1}}],[\"是一种renderobjectwidget\",{\"1\":{\"127\":1}}],[\"是一串可以有不同类型的消息块的链表\",{\"1\":{\"58\":1}}],[\"是一个二叉树的节点\",{\"1\":{\"429\":1}}],[\"是一个接口或者抽象类\",{\"1\":{\"403\":1}}],[\"是一个普通类\",{\"1\":{\"403\":1}}],[\"是一个继承自roomdatabase的抽象类\",{\"1\":{\"403\":1}}],[\"是一个协程\",{\"1\":{\"334\":1}}],[\"是一个标记注解\",{\"1\":{\"298\":2}}],[\"是一个同步方法\",{\"1\":{\"297\":1}}],[\"是一个抽象类\",{\"1\":{\"227\":1}}],[\"是一个可以在内部嵌套其他\",{\"1\":{\"212\":1}}],[\"是一个利用原生库加载\",{\"1\":{\"211\":1}}],[\"是一个leafrenderobjectwidget\",{\"1\":{\"189\":1}}],[\"是一个数据类\",{\"1\":{\"177\":1}}],[\"是一个\",{\"1\":{\"175\":1,\"178\":1}}],[\"是一个新的\",{\"1\":{\"153\":1}}],[\"是一个renderobjectelement\",{\"1\":{\"122\":1}}],[\"是一个对象\",{\"1\":{\"82\":1}}],[\"是一个实现了材料设计的默认垂直布局的viewgroup\",{\"1\":{\"55\":1}}],[\"是一个虚拟像素单位\",{\"1\":{\"53\":1}}],[\"是否需要将右节点的左子节点指向当前点的左子节点\",{\"1\":{\"432\":1}}],[\"是否spawn\",{\"1\":{\"389\":2}}],[\"是否成功\",{\"1\":{\"347\":1}}],[\"是否扩容的阈值\",{\"1\":{\"280\":1}}],[\"是否有必要执行finalize\",{\"1\":{\"266\":1}}],[\"是否同步手势\",{\"1\":{\"175\":1}}],[\"是否同时处理\",{\"1\":{\"114\":1}}],[\"是否竖屏\",{\"1\":{\"81\":1}}],[\"是否依附到root\",{\"1\":{\"56\":1}}],[\"是否强制使用system\",{\"1\":{\"49\":1}}],[\"是否调用gc\",{\"1\":{\"44\":1}}],[\"是否能被其他应用隐式调用\",{\"1\":{\"17\":1}}],[\"是以正常远程调用形式将其作为来自\",{\"1\":{\"43\":1}}],[\"是分别是view左上角顶点的x轴\",{\"1\":{\"41\":1}}],[\"是view的左上角坐标\",{\"1\":{\"41\":1}}],[\"是binder的唯一标识\",{\"1\":{\"40\":1}}],[\"是taskcallback的子类\",{\"1\":{\"35\":1}}],[\"是确定的\",{\"1\":{\"15\":1}}],[\"将后面的数字依次与其比较\",{\"1\":{\"462\":1}}],[\"将增量减小\",{\"1\":{\"462\":1}}],[\"将大数组分为较小的数组\",{\"1\":{\"462\":1}}],[\"将排序结果写入原待排序数组\",{\"1\":{\"462\":1}}],[\"将待排序数组分为h个间隔为h的小数组\",{\"1\":{\"462\":1}}],[\"将待排序的元素分为有序和无序两种\",{\"1\":{\"289\":1}}],[\"将左边无须的元素依次插入到右边有序数组中\",{\"1\":{\"460\":1}}],[\"将剩余的数组全部复制到新数组\",{\"1\":{\"459\":1}}],[\"将合并好的两个有序子数组合并\",{\"1\":{\"459\":1}}],[\"将序列每相邻两个数字进行归并操作\",{\"1\":{\"459\":1}}],[\"将一个数组\",{\"1\":{\"459\":1}}],[\"将一个子view与另一个子view的滑动事件绑定在一起\",{\"1\":{\"55\":1}}],[\"将n\",{\"1\":{\"459\":1}}],[\"将n的父节点设置为黑色\",{\"1\":{\"458\":1}}],[\"将最底层n移动到目标层\",{\"1\":{\"459\":1}}],[\"将最上层n\",{\"1\":{\"459\":1}}],[\"将最后一个未排序元素与这一轮遍历找到的最大值交换\",{\"1\":{\"289\":1}}],[\"将汉诺塔问题简化为3步\",{\"1\":{\"459\":1}}],[\"将除最底部的圆盘bottom之外的所有圆盘当做一个整体other\",{\"1\":{\"459\":1}}],[\"将所有圆盘依次转移到另外一个圆盘上面\",{\"1\":{\"459\":1}}],[\"将所有有效链接全部加入\",{\"1\":{\"370\":1}}],[\"将父节点137设置为黑色\",{\"1\":{\"458\":1}}],[\"将父节点下沉\",{\"1\":{\"440\":1}}],[\"将节点颜色更改为黑色\",{\"1\":{\"458\":1}}],[\"将34的父节点23设置黑\",{\"1\":{\"458\":1}}],[\"将x插入栈中\",{\"1\":{\"453\":1}}],[\"将x压入栈中\",{\"1\":{\"453\":2}}],[\"将top推出\",{\"1\":{\"453\":1}}],[\"将top移动到该位置\",{\"1\":{\"441\":1}}],[\"将toindex指向空出的地方\",{\"1\":{\"440\":1}}],[\"将text插入到了tree中\",{\"1\":{\"126\":1}}],[\"将不满足的元素下沉\",{\"1\":{\"440\":1}}],[\"将元素插入到数组最后一位\",{\"1\":{\"440\":1}}],[\"将修改的值移动到对应的位置\",{\"1\":{\"439\":1}}],[\"将修改过的dart\",{\"1\":{\"393\":1}}],[\"将字符按照出现的频次生成优先级队列\",{\"1\":{\"432\":1}}],[\"将字节流中静态存储结构转化为方法区的运行时数据结构\",{\"1\":{\"274\":1}}],[\"将该点a的内侧孙子\",{\"1\":{\"458\":1}}],[\"将该``左节点c放到节点a`原先的位置\",{\"1\":{\"458\":1}}],[\"将该节点a放到右节点b的位置\",{\"1\":{\"458\":1}}],[\"将该节点移动到找到的下标处\",{\"1\":{\"441\":1}}],[\"将该值存储在该位置即可\",{\"1\":{\"442\":1}}],[\"将该值插入到对应下标\",{\"1\":{\"440\":1}}],[\"将该元素插入该处\",{\"1\":{\"440\":1}}],[\"将该邻接点当做新的顶点压入栈中\",{\"1\":{\"437\":1}}],[\"将该子节点的父节点指向其右子节点\",{\"1\":{\"432\":1}}],[\"将该方法传入statelesswidget中\",{\"1\":{\"134\":1}}],[\"将上文获得到的\",{\"1\":{\"419\":1}}],[\"将上次在\",{\"1\":{\"419\":1}}],[\"将上述创建的widget\",{\"1\":{\"126\":1}}],[\"将第1步生成的静态博客内容添加到master分支\",{\"1\":{\"407\":1}}],[\"将第一个元素\",{\"1\":{\"289\":1}}],[\"将更新提交到github\",{\"1\":{\"405\":1}}],[\"将更改后的state传给statelesswidget\",{\"1\":{\"134\":1}}],[\"将布局中的组件捆绑到app中使用到的数据上\",{\"1\":{\"401\":1}}],[\"将二者联系起来\",{\"1\":{\"401\":1}}],[\"将二叉树分为左\",{\"1\":{\"346\":1}}],[\"将itemview的viewmodel与布局xml中绑定在一起\",{\"1\":{\"399\":1}}],[\"将unoptimized\",{\"1\":{\"396\":1}}],[\"将ui\",{\"1\":{\"194\":1}}],[\"将调用的类与方法映射在一起\",{\"1\":{\"395\":1}}],[\"将处理好的数据按格式输出\",{\"1\":{\"371\":1}}],[\"将处理结果以其他形式返回\",{\"1\":{\"322\":1}}],[\"将处理结果data\",{\"1\":{\"111\":1,\"112\":1}}],[\"将值为value的key添加到环境变量\",{\"1\":{\"360\":1}}],[\"将file压缩成file\",{\"1\":{\"356\":1}}],[\"将本地分支同步到github上面\",{\"1\":{\"347\":1}}],[\"将本地的项目同步到\",{\"1\":{\"347\":1}}],[\"将前序排序也分为左右两个子树的前序排序\",{\"1\":{\"346\":1}}],[\"将collect的代码移动到oneach中\",{\"1\":{\"341\":1}}],[\"将collect的主要逻辑放到oneach中\",{\"0\":{\"328\":1}}],[\"将收集到的流交给\",{\"1\":{\"340\":1}}],[\"将嵌套有flow的flow\",{\"1\":{\"340\":1}}],[\"将异常处理者设置在\",{\"1\":{\"329\":1}}],[\"将类的属性名称和map中的key一一对应\",{\"1\":{\"322\":1}}],[\"将类型作为类型参数传入\",{\"1\":{\"290\":1}}],[\"将同一类型的属性的get\",{\"1\":{\"322\":1}}],[\"将结果赋予c这几步来完成\",{\"1\":{\"317\":1}}],[\"将结果从工作内存写入到主内存中才可以被其他线程可见\",{\"1\":{\"317\":1}}],[\"将结果通过future返回给dart调用方\",{\"1\":{\"112\":1}}],[\"将变量写入到parcel中\",{\"1\":{\"314\":1}}],[\"将变量访问转化为运行时内存\",{\"1\":{\"278\":1}}],[\"将使用到注解的变量初始化\",{\"1\":{\"300\":1}}],[\"将加密16进制文本转为二进制\",{\"1\":{\"296\":1}}],[\"将a加到b后面\",{\"1\":{\"289\":1}}],[\"将无序部分的一个元素\",{\"1\":{\"289\":1}}],[\"将较大的元素\",{\"1\":{\"289\":1}}],[\"将key和value直接保存在数组中\",{\"1\":{\"287\":1}}],[\"将对象总大小对齐到8字节所需的填充\",{\"1\":{\"282\":1}}],[\"将对于的renderobject添加到rendering\",{\"1\":{\"127\":1}}],[\"将外部类的引用和局部变量作为内部类的参数传入到内部类中\",{\"1\":{\"281\":1}}],[\"将外部文件缓存本地的步骤参考第一步操作即可自行完成\",{\"1\":{\"2\":1}}],[\"将外部文件保存到本地并获取uri\",{\"1\":{\"2\":1}}],[\"将数组划分为两个子数组\",{\"1\":{\"465\":1}}],[\"将数组无限分成两份\",{\"1\":{\"459\":1}}],[\"将数组无限的分成两份分别进行排序\",{\"1\":{\"459\":1}}],[\"将数组与引导类加载器标识\",{\"1\":{\"274\":1}}],[\"将数据项直接存储的链表中\",{\"1\":{\"428\":1}}],[\"将数据保存在通过hash函数计算得到的下标中\",{\"1\":{\"428\":1}}],[\"将数据保存到了thread对象自己的threadlocals中\",{\"1\":{\"288\":1}}],[\"将数据的的具体实现与viewmodel对数据的操作解耦\",{\"1\":{\"399\":1}}],[\"将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间\",{\"1\":{\"58\":1}}],[\"将数据从发送缓存区复制过来\",{\"1\":{\"58\":1}}],[\"将首次出现的对象实例复制到永久代\",{\"1\":{\"254\":1}}],[\"将此scrollposition和\",{\"1\":{\"217\":1}}],[\"将请求信息返回给flutter端\",{\"1\":{\"211\":1}}],[\"将请求结果返回\",{\"1\":{\"211\":1}}],[\"将请求保存到powerimageloader\",{\"1\":{\"211\":1}}],[\"将onreceiveimageevent放到eventhandlers中\",{\"1\":{\"211\":1}}],[\"将parent\",{\"1\":{\"183\":1}}],[\"将自身加入\",{\"1\":{\"218\":1}}],[\"将自身作为\",{\"1\":{\"183\":1}}],[\"将自己和传入的\",{\"1\":{\"218\":1}}],[\"将自己的renderobject绑定到renderview\",{\"1\":{\"121\":1}}],[\"将接收\",{\"1\":{\"183\":1}}],[\"将\",{\"1\":{\"157\":1,\"182\":1,\"212\":1,\"213\":1,\"225\":1,\"226\":3}}],[\"将任意属性在\",{\"1\":{\"146\":1,\"157\":1}}],[\"将之前创建的buildowner与自己绑定\",{\"1\":{\"127\":1}}],[\"将b中比a中小的元素都复制到a中对应位置\",{\"1\":{\"459\":1}}],[\"将buildowner与之绑定\",{\"1\":{\"121\":1}}],[\"将binder和指定的接口绑定\",{\"1\":{\"40\":1}}],[\"将rootwidget绑定到renderviewelement\",{\"1\":{\"119\":1}}],[\"将renderobject插入\",{\"1\":{\"127\":1}}],[\"将renderobject绘制到屏幕上面\",{\"1\":{\"118\":1}}],[\"将renderview绑定到指定newslot\",{\"1\":{\"121\":1}}],[\"将renderview设置为\",{\"1\":{\"118\":1}}],[\"将r插入到线程池中\",{\"1\":{\"80\":1}}],[\"将我们的app\",{\"1\":{\"117\":1}}],[\"将用户的io指令发送到native层的ioservice中\",{\"1\":{\"116\":1}}],[\"将worker和系统线程绑定\",{\"1\":{\"115\":1}}],[\"将线程切换到新创建的系统线程\",{\"1\":{\"115\":1}}],[\"将当前剩余数据最大值选出来\",{\"1\":{\"442\":1}}],[\"将当前任务加入到tasks\",{\"1\":{\"390\":1}}],[\"将当前ioservice对应的send\",{\"1\":{\"114\":1}}],[\"将当前listener添加到链表头部\",{\"1\":{\"103\":1}}],[\"将当前画布保存为新的一层\",{\"1\":{\"65\":1}}],[\"将传入的callback当做microtask执行\",{\"1\":{\"97\":1}}],[\"将传过来的数据取出来\",{\"1\":{\"40\":1}}],[\"将max与每一项比较\",{\"1\":{\"456\":1}}],[\"将max坐标指向该值\",{\"1\":{\"456\":1}}],[\"将mainfragmentsubcomponent加入到想要加入的类的\",{\"1\":{\"94\":1}}],[\"将mainactivitymodule加入到应用程序的\",{\"1\":{\"91\":1}}],[\"将message加入到messagequeue中\",{\"1\":{\"115\":1}}],[\"将mworker当做了他的callable\",{\"1\":{\"80\":1}}],[\"将装有可以产生依赖的\",{\"1\":{\"85\":1}}],[\"将准备好参数\",{\"1\":{\"80\":1}}],[\"将参数传入mworker\",{\"1\":{\"80\":1}}],[\"将参数params传入mworker\",{\"1\":{\"80\":1}}],[\"将返回我们自定义的callback以替换系统的\",{\"1\":{\"72\":1}}],[\"将原有的activitymanagerservice替换为我们自定义的\",{\"1\":{\"72\":1}}],[\"将descriptor和这个接口绑定到一起\",{\"1\":{\"58\":1}}],[\"将dst绘制在src上面\",{\"1\":{\"57\":1}}],[\"将dst与src的透明与不透明颜色相互作用\",{\"1\":{\"57\":1}}],[\"将生成的binder和对应名字发送到binder驱动\",{\"1\":{\"58\":1}}],[\"将ls\",{\"1\":{\"58\":1}}],[\"将其指向的元素交换位置\",{\"1\":{\"464\":1}}],[\"将其左节点c向上进一位插入到该节点a原先的位置\",{\"1\":{\"458\":1}}],[\"将其放到对应位置\",{\"1\":{\"456\":1}}],[\"将其放到catch之前\",{\"1\":{\"341\":1}}],[\"将其与当前未排序的最后一项交换\",{\"1\":{\"456\":1}}],[\"将其与上一步找到的entrypoint结合\",{\"1\":{\"389\":1}}],[\"将其压入栈中\",{\"1\":{\"437\":1}}],[\"将其压入serialexecutor线程池中排队\",{\"1\":{\"80\":1}}],[\"将其打印出来\",{\"1\":{\"437\":1}}],[\"将其父节点指向其子节点\",{\"1\":{\"432\":2}}],[\"将其父节点的指向设为null即可\",{\"1\":{\"432\":2}}],[\"将其发布到合适的空间就可以正常显示\",{\"1\":{\"419\":1}}],[\"将其简单分为\",{\"1\":{\"294\":1}}],[\"将其分发给\",{\"1\":{\"212\":1}}],[\"将其分为两大类\",{\"1\":{\"157\":1}}],[\"将其\",{\"1\":{\"181\":1}}],[\"将其大小和位置与为\",{\"1\":{\"171\":1}}],[\"将其变为同步任务\",{\"1\":{\"142\":1}}],[\"将其标记为dirty\",{\"1\":{\"128\":1}}],[\"将其绑定到rendering\",{\"1\":{\"127\":1}}],[\"将其使用\",{\"1\":{\"100\":1}}],[\"将其闭合\",{\"1\":{\"63\":1}}],[\"将其翻译为物理地址\",{\"1\":{\"58\":1}}],[\"将其转化为对应aidl\",{\"1\":{\"32\":1}}],[\"将script\",{\"1\":{\"387\":1}}],[\"将sizeof\",{\"1\":{\"282\":1}}],[\"将src绘制在dst上面\",{\"1\":{\"57\":1}}],[\"将service和当前的activity绑定在一起\",{\"1\":{\"17\":1}}],[\"将新图层绘制到原有图层上\",{\"1\":{\"57\":1}}],[\"将两个或多个子view绑定\",{\"1\":{\"55\":1}}],[\"将服务端的binder转化为客户端需要的iinterface\",{\"1\":{\"40\":1}}],[\"将需要回传的数据写入\",{\"1\":{\"40\":1}}],[\"将handler发送的msg压入到当前线程的looper持有的messagequeue中\",{\"1\":{\"28\":1}}],[\"将handler赋予msg\",{\"1\":{\"28\":1}}],[\"服务器\",{\"1\":{\"414\":1}}],[\"服务连接成功后\",{\"1\":{\"37\":1}}],[\"服务连接成功\",{\"1\":{\"35\":1}}],[\"服务端的messenger\",{\"1\":{\"43\":1}}],[\"服务端回调客户端方法运行在客户端主线程\",{\"1\":{\"36\":1}}],[\"服务端\",{\"0\":{\"36\":1},\"1\":{\"20\":1,\"32\":1}}],[\"服务与客户端双向通信\",{\"1\":{\"20\":1}}],[\"服务中公共方法\",{\"1\":{\"19\":1}}],[\"服务解绑\",{\"1\":{\"17\":1}}],[\"服务绑定\",{\"1\":{\"17\":1}}],[\"启用快速\",{\"1\":{\"55\":1}}],[\"启用当日循环闹钟\",{\"1\":{\"11\":1}}],[\"启动了一个循环\",{\"1\":{\"391\":1}}],[\"启动android\",{\"1\":{\"347\":1}}],[\"启动的协程中\",{\"1\":{\"329\":1}}],[\"启动带缓冲的通道\",{\"1\":{\"328\":1}}],[\"启动并发的协程以验证主线程并未阻塞\",{\"1\":{\"327\":1}}],[\"启动和恢复时保存threadlocal在当前线程的值\",{\"1\":{\"325\":1}}],[\"启动类加载器\",{\"1\":{\"272\":1}}],[\"启动处理timer的event\",{\"1\":{\"106\":1}}],[\"启动未在androidmanifest\",{\"1\":{\"71\":1}}],[\"启动开机动画bootnaim\",{\"1\":{\"60\":1}}],[\"启动组件传递过来的intent\",{\"1\":{\"17\":1}}],[\"启动时\",{\"1\":{\"17\":1}}],[\"启动\",{\"1\":{\"17\":1,\"414\":1}}],[\"启动servicemanager管理系统服务\",{\"1\":{\"60\":1}}],[\"启动service\",{\"1\":{\"17\":1,\"21\":1}}],[\"启动一个service\",{\"0\":{\"17\":1}}],[\"上建立的项目\",{\"1\":{\"419\":1}}],[\"上图中\",{\"1\":{\"393\":1}}],[\"上文的isolate\",{\"1\":{\"382\":1}}],[\"上文indexof\",{\"1\":{\"50\":1}}],[\"上传工程到\",{\"1\":{\"347\":1}}],[\"上回我们对\",{\"1\":{\"227\":1}}],[\"上触发\",{\"1\":{\"217\":1}}],[\"上较大尺寸可能会\",{\"1\":{\"211\":1}}],[\"上\",{\"1\":{\"211\":1}}],[\"上应用加减乘运算\",{\"1\":{\"184\":1}}],[\"上层路径\",{\"1\":{\"349\":1}}],[\"上层\",{\"1\":{\"171\":1}}],[\"上节我们说道\",{\"1\":{\"122\":1}}],[\"上篇文章介绍了dagger\",{\"1\":{\"88\":1}}],[\"上所有的控件\",{\"1\":{\"79\":1}}],[\"上面是dart\",{\"1\":{\"394\":1}}],[\"上面时的步骤的总结\",{\"1\":{\"347\":1}}],[\"上面了\",{\"1\":{\"347\":1,\"418\":1}}],[\"上面将工程同步到\",{\"1\":{\"347\":1}}],[\"上面添加\",{\"1\":{\"347\":1}}],[\"上面的代码就支持了app\",{\"1\":{\"401\":1}}],[\"上面的代码中还分别调用了\",{\"1\":{\"227\":1}}],[\"上面的滑动事件\",{\"1\":{\"213\":1}}],[\"上面的博客\",{\"1\":{\"0\":1}}],[\"上面提到的这种string长度的限制是编译期的限制\",{\"1\":{\"283\":1}}],[\"上面提到\",{\"1\":{\"211\":1}}],[\"上面\",{\"1\":{\"211\":1,\"226\":1,\"347\":1}}],[\"上面分析了\",{\"1\":{\"193\":1}}],[\"上面说道\",{\"1\":{\"127\":1}}],[\"上面我们分析到\",{\"1\":{\"127\":1}}],[\"上面isolateleavescope\",{\"1\":{\"115\":1}}],[\"上面执行\",{\"1\":{\"79\":1}}],[\"上面涉及到的代码路径\",{\"1\":{\"72\":1}}],[\"上述这种基于乐观假设的优化\",{\"1\":{\"396\":1}}],[\"上述这些步骤能够实施的关键\",{\"1\":{\"112\":1}}],[\"上述isolate\",{\"1\":{\"378\":1}}],[\"上述方法会被编译为类似下面的过程\",{\"1\":{\"294\":1}}],[\"上述所有的scrollable\",{\"1\":{\"234\":1}}],[\"上述所有的\",{\"1\":{\"212\":1,\"227\":1}}],[\"上述powerimageloader发起的请求完成后会执行下述代码\",{\"1\":{\"211\":1}}],[\"上述其余构造函数都根据传入的string\",{\"1\":{\"204\":1}}],[\"上述三值都为\",{\"1\":{\"197\":1}}],[\"上述关于\",{\"1\":{\"182\":1}}],[\"上述四种方法\",{\"1\":{\"161\":1}}],[\"上述两种库都是基于\",{\"1\":{\"202\":1}}],[\"上述两种方式中\",{\"1\":{\"157\":1}}],[\"上述两种event会在普通的dart同步方法执行完毕后执行\",{\"1\":{\"95\":1}}],[\"上述分析是继承\",{\"1\":{\"152\":1}}],[\"上述几种情况都没有处理的异常\",{\"1\":{\"145\":1}}],[\"上述几种情况都没有处理的\",{\"1\":{\"144\":1}}],[\"上述涉及到的几个类彼此之间到底是什么关系\",{\"1\":{\"117\":1}}],[\"上述代码中执行到的extendednetworkimageprovider\",{\"1\":{\"201\":1}}],[\"上述代码中的mainerrorwidget是一个自定义的展示错误信息的页面\",{\"1\":{\"143\":1}}],[\"上述代码中的\",{\"1\":{\"85\":1,\"188\":1}}],[\"上述代码的效果如下\",{\"1\":{\"117\":1}}],[\"上述代码最后将结果包装成了message打包进messagehandler的消息队列中\",{\"1\":{\"115\":1}}],[\"上述完整的代码如下\",{\"1\":{\"94\":1}}],[\"上述完整代码如下\",{\"1\":{\"85\":1,\"86\":1}}],[\"上述问题的解决方案是在另外一个方法上加一个注解\",{\"1\":{\"86\":1}}],[\"上述值中\",{\"1\":{\"81\":1}}],[\"上述的屏幕适配方案使用简单\",{\"1\":{\"53\":1}}],[\"上述无论是translationx还是scrollx等引起的view变化\",{\"1\":{\"41\":1}}],[\"上的组件是单独管理的\",{\"1\":{\"171\":1}}],[\"上的\",{\"1\":{\"53\":1}}],[\"上方移动\",{\"1\":{\"41\":1}}],[\"上坡度\",{\"1\":{\"15\":1}}],[\"坡底到下一行坡顶的距离\",{\"1\":{\"15\":1}}],[\"坡底\",{\"1\":{\"15\":1}}],[\"坡顶\",{\"1\":{\"15\":1}}],[\"就称为三角数组\",{\"1\":{\"459\":1}}],[\"就称图为带权图\",{\"1\":{\"433\":1}}],[\"就称图是有向图\",{\"1\":{\"433\":1}}],[\"就交换a和b的位置\",{\"1\":{\"455\":1}}],[\"就得到有序数组\",{\"1\":{\"451\":1}}],[\"就选择去访问该点邻接点的邻接点\",{\"1\":{\"438\":1}}],[\"就说明\",{\"1\":{\"411\":1}}],[\"就说明用户选择了不再提示\",{\"1\":{\"68\":1}}],[\"就新建一个worker\",{\"1\":{\"390\":1}}],[\"就新建sendport用于远程服务通信\",{\"1\":{\"112\":1}}],[\"就等待已有的worker执行任务\",{\"1\":{\"389\":1}}],[\"就执行messagehandlertask\",{\"1\":{\"389\":1}}],[\"就执行createisolategroupandsetuphelper\",{\"1\":{\"387\":1}}],[\"就执行createandsetupserviceisolate\",{\"1\":{\"387\":1}}],[\"就执行createandsetupdartdevisolate\",{\"1\":{\"387\":1}}],[\"就执行createandsetupkernelisolate\",{\"1\":{\"387\":1}}],[\"就执行普通的event\",{\"1\":{\"109\":1}}],[\"就发生了被限制访问\",{\"1\":{\"370\":1}}],[\"就先对其调用\",{\"1\":{\"327\":1}}],[\"就要返回contents\",{\"1\":{\"314\":1}}],[\"就要保证屏幕的总dp宽度一致\",{\"1\":{\"53\":1}}],[\"就像访问本程序的数据一样\",{\"1\":{\"421\":1}}],[\"就像\",{\"1\":{\"328\":1,\"332\":1}}],[\"就像流一样\",{\"1\":{\"327\":1,\"338\":1}}],[\"就像使用集合与序列一样\",{\"1\":{\"327\":1}}],[\"就像java中给程序员看的注释一样\",{\"1\":{\"298\":1}}],[\"就像是一个设计好的处理预案\",{\"1\":{\"79\":1}}],[\"就可能会抛出异常\",{\"1\":{\"283\":1}}],[\"就可以在有向无环图中完成拓扑排序\",{\"1\":{\"438\":1}}],[\"就可以自动部署到\",{\"1\":{\"418\":1}}],[\"就可以看到本地搭建好的\",{\"1\":{\"414\":1}}],[\"就可以拥有一个在线的静态博客\",{\"1\":{\"405\":1}}],[\"就可以正常运行\",{\"1\":{\"348\":1}}],[\"就可以避免这个问题\",{\"1\":{\"211\":1}}],[\"就可以将其保存在static\",{\"1\":{\"184\":1}}],[\"就可以和native层的io\",{\"1\":{\"114\":1}}],[\"就可以计算出baseline的y坐标\",{\"1\":{\"15\":1}}],[\"就应该考虑使用listview\",{\"1\":{\"240\":1}}],[\"就只会请求最新的值\",{\"1\":{\"327\":1}}],[\"就只限制宽度\",{\"1\":{\"238\":1}}],[\"就只限制高度\",{\"1\":{\"238\":1}}],[\"就只更新child的slot\",{\"1\":{\"126\":1}}],[\"就singlechildscrollview就会保证用户可以上下滑动\",{\"1\":{\"234\":1}}],[\"就由outer完全处理滑动事件\",{\"1\":{\"226\":1}}],[\"就表示当前nestedscrollview停止\",{\"1\":{\"225\":1}}],[\"就无法协调\",{\"1\":{\"223\":1}}],[\"就不限制主轴方向的尺寸\",{\"1\":{\"238\":1}}],[\"就不能再超了\",{\"1\":{\"220\":1}}],[\"就不会repaint整个的noname了\",{\"1\":{\"130\":1}}],[\"就展示失败信息\",{\"1\":{\"201\":1}}],[\"就从网络加载\",{\"1\":{\"201\":1}}],[\"就将父节点移动到插入值的位置\",{\"1\":{\"440\":1}}],[\"就将此图片加入\",{\"1\":{\"198\":1}}],[\"就将其加入\",{\"1\":{\"198\":1}}],[\"就去下载\",{\"1\":{\"198\":1}}],[\"就加入\",{\"1\":{\"198\":1}}],[\"就加入到micro\",{\"1\":{\"103\":1}}],[\"就直接返回\",{\"1\":{\"198\":1}}],[\"就停止监听\",{\"1\":{\"163\":1}}],[\"就在电脑上面安装好了\",{\"1\":{\"413\":1}}],[\"就在刚刚写下这句话的时候\",{\"1\":{\"370\":1}}],[\"就在本文编辑的过程中\",{\"1\":{\"370\":1}}],[\"就在此时\",{\"1\":{\"294\":1}}],[\"就在同一个值\",{\"1\":{\"159\":1}}],[\"就在该行限定的高度内居中显示\",{\"1\":{\"15\":1}}],[\"就使用内置的显式动画结合自己创建的animationcontroller实现动画\",{\"1\":{\"156\":1}}],[\"就会很耗性能\",{\"1\":{\"445\":1}}],[\"就会减少复制的次数\",{\"1\":{\"439\":1}}],[\"就会通过livedata主动通知布局更新界面\",{\"1\":{\"399\":1}}],[\"就会通过isolate\",{\"1\":{\"384\":1}}],[\"就会发生冲突\",{\"1\":{\"317\":1}}],[\"就会去调用该对象的writeexternal方法\",{\"1\":{\"312\":1}}],[\"就会去找这个对象是否已经被序列化过了\",{\"1\":{\"309\":1}}],[\"就会被回收掉\",{\"1\":{\"288\":1}}],[\"就会被认为built\",{\"1\":{\"128\":1}}],[\"就会强制child大小为maxszie\",{\"1\":{\"131\":1}}],[\"就会执行一次此类普通event\",{\"1\":{\"101\":1}}],[\"就会执行\",{\"1\":{\"79\":1}}],[\"就调用下面的方法👇\",{\"1\":{\"305\":1}}],[\"就调用下一个\",{\"1\":{\"80\":1}}],[\"就调用\",{\"1\":{\"201\":1}}],[\"就调用child\",{\"1\":{\"126\":1}}],[\"就有了对应的widget和element\",{\"1\":{\"121\":1}}],[\"就安排更新帧\",{\"1\":{\"119\":1}}],[\"就通过\",{\"1\":{\"106\":1}}],[\"就添加监听\",{\"1\":{\"103\":1}}],[\"就立即返回结果\",{\"1\":{\"102\":1}}],[\"就知道了有个对象需要它来帮助我们注入\",{\"1\":{\"83\":1}}],[\"就是一个递归\",{\"1\":{\"459\":1}}],[\"就是满足条件\",{\"1\":{\"438\":1}}],[\"就是我们前文提到的那个integer\",{\"1\":{\"283\":1}}],[\"就是我们传入的child\",{\"1\":{\"235\":1}}],[\"就是我们在\",{\"1\":{\"111\":1,\"112\":1}}],[\"就是继承自\",{\"1\":{\"233\":1}}],[\"就是借助\",{\"1\":{\"184\":1}}],[\"就是\",{\"1\":{\"173\":1}}],[\"就是为了帮助我们解决这个问题\",{\"1\":{\"82\":1}}],[\"就是上述的dpi\",{\"1\":{\"81\":1}}],[\"就是上述的density\",{\"1\":{\"81\":1}}],[\"就实现了启动通过已经注册了的proxyactivity启动未注册targetactivity的全过程\",{\"1\":{\"72\":1}}],[\"就需要用到factory工厂模式来创建viewmodel\",{\"1\":{\"402\":1}}],[\"就需要结合singlechildscrollview\",{\"1\":{\"241\":1}}],[\"就需要在其外部包裹一个statefulwidget\",{\"1\":{\"128\":1}}],[\"就需要同时也更改client对应的方法\",{\"1\":{\"82\":1}}],[\"就需要重写onmeasure\",{\"1\":{\"65\":1}}],[\"就需要考虑aidl而非messenger\",{\"1\":{\"43\":1}}],[\"就画出背景\",{\"1\":{\"64\":1}}],[\"就出触发gc\",{\"1\":{\"48\":1}}],[\"得知了子类中是否有\",{\"1\":{\"149\":1}}],[\"得出所需要的效果\",{\"1\":{\"57\":1}}],[\"得出结论\",{\"1\":{\"15\":1}}],[\"得到一个基本有序的数组\",{\"1\":{\"460\":1}}],[\"得到一个sendport\",{\"1\":{\"116\":1}}],[\"得到key应该插入的位置\",{\"1\":{\"45\":1}}],[\"得到执行\",{\"1\":{\"3\":1}}],[\"+threadlocal\",{\"1\":{\"288\":4}}],[\"+thread\",{\"1\":{\"288\":2}}],[\"++leftindex\",{\"1\":{\"467\":1}}],[\"++size\",{\"1\":{\"451\":1}}],[\"++i\",{\"1\":{\"226\":1}}],[\"++\",{\"1\":{\"115\":2,\"390\":2}}],[\"+=\",{\"1\":{\"109\":3,\"127\":1}}],[\"+id\",{\"1\":{\"56\":1,\"66\":1,\"79\":1,\"400\":4,\"401\":1}}],[\"+1\",{\"1\":{\"50\":1,\"51\":1}}],[\"+\",{\"1\":{\"15\":7,\"30\":1,\"36\":2,\"37\":2,\"40\":1,\"41\":2,\"48\":1,\"49\":1,\"52\":2,\"58\":1,\"62\":2,\"63\":5,\"64\":4,\"69\":2,\"80\":3,\"105\":3,\"115\":3,\"121\":1,\"166\":1,\"167\":1,\"184\":1,\"192\":1,\"211\":3,\"213\":2,\"220\":7,\"239\":3,\"240\":2,\"281\":4,\"282\":21,\"283\":3,\"285\":16,\"289\":8,\"295\":2,\"296\":5,\"306\":3,\"308\":11,\"309\":3,\"311\":10,\"317\":1,\"325\":1,\"330\":1,\"345\":1,\"346\":1,\"351\":1,\"365\":1,\"370\":3,\"371\":1,\"383\":1,\"389\":1,\"390\":1,\"411\":1,\"424\":1,\"428\":2,\"441\":2,\"453\":11,\"455\":3,\"456\":2,\"457\":1,\"459\":6,\"462\":3,\"467\":1}}],[\"即序列数为1\",{\"1\":{\"459\":1}}],[\"即当尾端\",{\"1\":{\"452\":1}}],[\"即在前1~n之间没有\",{\"1\":{\"444\":1}}],[\"即在声明的时候就将对象初始化\",{\"1\":{\"294\":1}}],[\"即堆的每个节点关键字都大于\",{\"1\":{\"439\":1}}],[\"即存在类似a→b\",{\"1\":{\"438\":1}}],[\"即表示m\",{\"1\":{\"433\":1}}],[\"即右子节点或者右子节点的最后一个左子节点\",{\"1\":{\"432\":1}}],[\"即查找的位置依次是x\",{\"1\":{\"428\":2}}],[\"即插件app\",{\"1\":{\"422\":1}}],[\"即将到来消息的迭代器\",{\"1\":{\"334\":1}}],[\"即将点击事件从viewgroup分发到了view\",{\"1\":{\"13\":1}}],[\"即先执行代码块\",{\"1\":{\"327\":1}}],[\"即假设原先为array<array<int>>\",{\"1\":{\"327\":1}}],[\"即每个构建值发生变化时都会触发collect\",{\"1\":{\"327\":1}}],[\"即自身返回值依赖于下一级函数\",{\"1\":{\"322\":1}}],[\"即一个线程对数据的操作能够及时的更新到其他使用该数据的线程中\",{\"1\":{\"317\":1}}],[\"即调用线程\",{\"1\":{\"297\":1}}],[\"即list保存的是t的某个父类\",{\"1\":{\"293\":1}}],[\"即容器将数组在运行时才会有的类型检查放到了编译期\",{\"1\":{\"292\":1}}],[\"即i永远<=table\",{\"1\":{\"280\":1}}],[\"即直接引用\",{\"1\":{\"278\":1}}],[\"即晚期绑定\",{\"1\":{\"273\":1}}],[\"即前期绑定\",{\"1\":{\"273\":1}}],[\"即前文所说的doinbackgroud\",{\"1\":{\"80\":1}}],[\"即时编译器编译后的代码\",{\"1\":{\"254\":1}}],[\"即使有全局和局部分析\",{\"1\":{\"397\":1}}],[\"即使处理消息时\",{\"1\":{\"376\":1}}],[\"即使isolate被pause也可以被处理\",{\"1\":{\"376\":1}}],[\"即使isolate被pause也会执行\",{\"1\":{\"376\":1}}],[\"即使isolate当前被pause也可以正常发送\",{\"1\":{\"376\":1}}],[\"即使不同步也是线程安全的\",{\"1\":{\"320\":1}}],[\"即使在第一次序列化并保存后修改了这个对象的部分属性\",{\"1\":{\"309\":1}}],[\"即使这些值在子类对象中已经被修改了\",{\"1\":{\"307\":1}}],[\"即使类结构有变化\",{\"1\":{\"304\":1}}],[\"即使object也不行\",{\"1\":{\"292\":1}}],[\"即使设置了outer的physics为bouncingscrollphysics\",{\"1\":{\"226\":1}}],[\"即使参数类型\",{\"1\":{\"34\":1}}],[\"即body中的\",{\"1\":{\"224\":1}}],[\"即恢复初始位置\",{\"1\":{\"220\":1}}],[\"即向下滑动\",{\"1\":{\"220\":3}}],[\"即向上滑动\",{\"1\":{\"220\":3}}],[\"即底部出现\",{\"1\":{\"220\":1}}],[\"即\",{\"1\":{\"211\":1,\"224\":1}}],[\"即可实时更新博客内容的方法\",{\"1\":{\"405\":1}}],[\"即可完成排序\",{\"1\":{\"289\":1}}],[\"即可\",{\"1\":{\"155\":2}}],[\"即抛型\",{\"1\":{\"95\":1}}],[\"即单例\",{\"1\":{\"87\":1}}],[\"即是使用了handler发送消息\",{\"1\":{\"80\":1}}],[\"即这种情况下wrap\",{\"1\":{\"65\":1}}],[\"即android内核层\",{\"1\":{\"60\":1}}],[\"即mconnection通过servermanager从client传递到了service\",{\"1\":{\"58\":1}}],[\"即mibinder通过servermanager从service传递到了client\",{\"1\":{\"58\":1}}],[\"即25dp\",{\"1\":{\"53\":1}}],[\"即上述方程等价于\",{\"1\":{\"53\":1}}],[\"即上图中的center\",{\"1\":{\"15\":1}}],[\"即客户端调用服务端时所在的线程\",{\"1\":{\"36\":1}}],[\"即添加一个java路径\",{\"1\":{\"32\":1}}],[\"文中引用的文字全部来自http\",{\"1\":{\"419\":1}}],[\"文章格式\",{\"1\":{\"417\":1}}],[\"文章参考\",{\"1\":{\"21\":1}}],[\"文档链接\",{\"1\":{\"407\":1}}],[\"文本可以跨行\",{\"1\":{\"369\":1}}],[\"文本方向\",{\"1\":{\"117\":1}}],[\"文件箱\",{\"1\":{\"415\":1}}],[\"文件的目录下\",{\"1\":{\"414\":1}}],[\"文件打包\",{\"0\":{\"355\":1}}],[\"文件群组权限一项默认为该群组\",{\"1\":{\"353\":1}}],[\"文件夹用于放置博客\",{\"1\":{\"419\":1}}],[\"文件夹\",{\"1\":{\"352\":1}}],[\"文件权限与umask\",{\"0\":{\"352\":1}}],[\"文件解压\",{\"1\":{\"348\":1}}],[\"文件读取\",{\"1\":{\"321\":1}}],[\"文件描述\",{\"1\":{\"314\":1}}],[\"文件中保存\",{\"1\":{\"303\":1}}],[\"文件中提供而导致java\",{\"1\":{\"14\":1}}],[\"文件是使用一种变体utf\",{\"1\":{\"283\":1}}],[\"文件格式验证\",{\"1\":{\"276\":1}}],[\"文件等获取图片\",{\"1\":{\"204\":1}}],[\"文件等加载图片\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"文件路径\",{\"1\":{\"111\":1}}],[\"文件\",{\"0\":{\"368\":1},\"1\":{\"58\":1,\"352\":1,\"417\":2}}],[\"文件可以一步打包多个渠道\",{\"1\":{\"54\":1}}],[\"文字在控件上下居中\",{\"1\":{\"15\":1}}],[\"文字在一行居中显示\",{\"1\":{\"15\":1}}],[\"文字的上下高度中心\",{\"1\":{\"15\":1}}],[\"文字的上下中心\",{\"1\":{\"15\":1}}],[\"因而节省了内存\",{\"1\":{\"44\":1}}],[\"因为左边的数组是有序的\",{\"1\":{\"457\":1}}],[\"因为交换次数少\",{\"1\":{\"456\":1}}],[\"因为他对每个顶点只访问一次\",{\"1\":{\"438\":1}}],[\"因为他用了context\",{\"1\":{\"130\":1}}],[\"因为需要将学习过程中的一些笔记\",{\"1\":{\"408\":1}}],[\"因为jit需要deoptimize兜底实现正确的行为\",{\"1\":{\"396\":1}}],[\"因为spawnuri中isolatespawnstate的isolategroup为nulltrp\",{\"1\":{\"385\":1}}],[\"因为setstate不会重新创建selectiverebuildwidget\",{\"1\":{\"130\":1}}],[\"因为执行到这里的都有isolategroup\",{\"1\":{\"381\":1}}],[\"因为有多个hexo项目\",{\"1\":{\"406\":1}}],[\"因为有可能会在进行正则匹配时造成误删等问题\",{\"1\":{\"349\":1}}],[\"因为有两个方法都可以提供service\",{\"1\":{\"85\":1}}],[\"因为流只会在被收集的时候才会被启动\",{\"1\":{\"336\":1}}],[\"因为在这种情况下它总是有工作要做\",{\"1\":{\"334\":1}}],[\"因为在绘制文字时\",{\"1\":{\"15\":1}}],[\"因为没有办法从该\",{\"1\":{\"322\":1}}],[\"因为泛型是通过擦除实现的\",{\"1\":{\"291\":1}}],[\"因为全局变量是通过传入内部类的\",{\"1\":{\"281\":1}}],[\"因为此时大小不超过数组的队列前端已经指向0之后的位置了\",{\"1\":{\"452\":1}}],[\"因为此时限制了\",{\"1\":{\"226\":1}}],[\"因为此时可能offset已经由于某种原因超过maxscrollextent了\",{\"1\":{\"220\":1}}],[\"因为此时可能\",{\"1\":{\"220\":1}}],[\"因为当scrollposition的\",{\"1\":{\"226\":1}}],[\"因为delta是负值\",{\"1\":{\"226\":1}}],[\"因为这里我们的isolate→group不为空\",{\"1\":{\"381\":1}}],[\"因为这些变量不会变化\",{\"1\":{\"313\":1}}],[\"因为这个库是官方\",{\"1\":{\"199\":1}}],[\"因为这表示上一个页面还存在\",{\"1\":{\"179\":1}}],[\"因为\",{\"1\":{\"184\":1,\"199\":1,\"233\":1,\"291\":1}}],[\"因为每次oncolorchanged时appcolor都会重建\",{\"1\":{\"130\":1}}],[\"因为center\",{\"1\":{\"122\":1}}],[\"因为child==null\",{\"1\":{\"122\":1}}],[\"因为widgetsflutterbinding继承自bindingbase\",{\"1\":{\"118\":1}}],[\"因为避免了自动装箱\",{\"1\":{\"44\":1}}],[\"因此调用\",{\"1\":{\"395\":1}}],[\"因此synchronize是重量级操作\",{\"1\":{\"317\":1}}],[\"因此在线程操作数据时需要考虑线程并发时操作数据的同步问题\",{\"1\":{\"317\":1}}],[\"因此只剩下\",{\"1\":{\"283\":1}}],[\"因此理论上允许的的最大长度是2^16=65536\",{\"1\":{\"283\":1}}],[\"因此应当保证column子级数量尽可能少\",{\"1\":{\"242\":1}}],[\"因此\",{\"1\":{\"58\":1,\"242\":1}}],[\"因此两个app的aidl必须一致\",{\"1\":{\"32\":1}}],[\"因此即使应用未运行\",{\"1\":{\"3\":1}}],[\"来控制程序版本真是一件令人愉悦的事件\",{\"1\":{\"408\":1}}],[\"来优化\",{\"1\":{\"396\":1}}],[\"来处理消息\",{\"1\":{\"391\":1}}],[\"来处理任务\",{\"1\":{\"390\":1}}],[\"来看一下对应的isolate\",{\"1\":{\"379\":1}}],[\"来看一下他是怎么实现的\",{\"1\":{\"115\":1}}],[\"来resume\",{\"1\":{\"375\":1}}],[\"来进行取消\",{\"1\":{\"329\":1}}],[\"来进行依赖绑定\",{\"1\":{\"55\":1}}],[\"来指定\",{\"1\":{\"328\":1}}],[\"来确保类有一个唯一的对象\",{\"1\":{\"294\":1}}],[\"来引用的\",{\"1\":{\"281\":1}}],[\"来获取一些使此viewport在屏幕上可见的信息\",{\"1\":{\"237\":1}}],[\"来获取对象的hashcode\",{\"1\":{\"49\":1}}],[\"来转发给\",{\"1\":{\"223\":1}}],[\"来展示图片\",{\"1\":{\"207\":1}}],[\"来缓存一些图片\",{\"1\":{\"202\":1}}],[\"来创建线性插值\",{\"1\":{\"185\":1}}],[\"来说基本可以满足要求\",{\"1\":{\"203\":1}}],[\"来说\",{\"1\":{\"184\":1,\"203\":1}}],[\"来实现动态调用\",{\"1\":{\"395\":1}}],[\"来实现相同的目的\",{\"1\":{\"332\":1}}],[\"来实现\",{\"1\":{\"153\":1,\"241\":1}}],[\"来触发inheritedwidget重建\",{\"1\":{\"128\":1}}],[\"来避免内存资源的浪费\",{\"1\":{\"58\":1}}],[\"来源2\",{\"1\":{\"283\":1}}],[\"来源\",{\"1\":{\"15\":1,\"55\":1,\"58\":1,\"291\":1,\"302\":2,\"347\":1}}],[\"来自https\",{\"1\":{\"302\":1}}],[\"来自gityuan\",{\"1\":{\"60\":1}}],[\"来自\",{\"1\":{\"13\":1}}],[\"下一步便是创建一个适当的网络请求\",{\"1\":{\"364\":1}}],[\"下一帧屏幕刷新\",{\"1\":{\"128\":1}}],[\"下安装\",{\"1\":{\"347\":1}}],[\"下篇\",{\"1\":{\"326\":1,\"334\":1}}],[\"下可能显示不全的情况\",{\"1\":{\"240\":1}}],[\"下称\",{\"1\":{\"226\":1}}],[\"下\",{\"1\":{\"224\":1}}],[\"下载并安装\",{\"1\":{\"410\":1}}],[\"下载并返回网页内容\",{\"1\":{\"371\":1}}],[\"下载软件\",{\"1\":{\"408\":1}}],[\"下载网页内容\",{\"1\":{\"371\":1}}],[\"下载到的\",{\"1\":{\"348\":1}}],[\"下载失败了\",{\"1\":{\"201\":1}}],[\"下载对应进度条的图片资源\",{\"1\":{\"66\":1}}],[\"下所有的\",{\"1\":{\"175\":1}}],[\"下新建\",{\"1\":{\"79\":1}}],[\"下图是viewmodel和activity的生命周期对比\",{\"1\":{\"402\":1}}],[\"下图是sunflower架构的简单示意图\",{\"1\":{\"399\":1}}],[\"下图是google\",{\"1\":{\"399\":1}}],[\"下图是runtime执行代码的示意图\",{\"1\":{\"392\":1}}],[\"下图是\",{\"1\":{\"171\":1,\"182\":1}}],[\"下图是一个被statefulwidget包裹的inheritedwidget在setsate\",{\"1\":{\"128\":1}}],[\"下图是二阶贝塞尔曲线绘制方法介绍\",{\"1\":{\"61\":1}}],[\"下图描述了android系统从开机到apk运行的整个流程\",{\"1\":{\"60\":1}}],[\"下图表示paint\",{\"1\":{\"15\":1}}],[\"下面采用的是找该节点的右子树最小值\",{\"1\":{\"432\":1}}],[\"下面\",{\"1\":{\"417\":1}}],[\"下面就把整个建站的过程大概梳理一下\",{\"1\":{\"408\":1}}],[\"下面两行代码解决编码问题\",{\"1\":{\"371\":1}}],[\"下面提供了两个结局思路\",{\"1\":{\"294\":1}}],[\"下面称其为\",{\"1\":{\"213\":1}}],[\"下面对这些类逐一分析\",{\"1\":{\"212\":1}}],[\"下面的actualnewpixels会展示出越界的效果\",{\"1\":{\"221\":1}}],[\"下面的\",{\"1\":{\"212\":1}}],[\"下面的代码依旧是在当前isolate所在的iothread也即系统线程下进行的\",{\"1\":{\"115\":1}}],[\"下面着重分析一下执行图片请求的逻辑\",{\"1\":{\"211\":1}}],[\"下面以\",{\"1\":{\"211\":1}}],[\"下面分别分析\",{\"1\":{\"203\":1}}],[\"下面我们详细分析一下这个过程\",{\"1\":{\"122\":1}}],[\"下面我们对ibookmanager\",{\"1\":{\"40\":1}}],[\"下面是排序算法比较\",{\"1\":{\"449\":1}}],[\"下面是以上数据结构的速度\",{\"1\":{\"445\":1}}],[\"下面是以上思路的kotlin实现\",{\"1\":{\"81\":1}}],[\"下面是dart代码在vm中执行的过程分析\",{\"1\":{\"394\":1}}],[\"下面是使用serializable实现序列化与反序列化的简单示例\",{\"1\":{\"308\":1}}],[\"下面是hashmap的结构\",{\"1\":{\"287\":1}}],[\"下面是一个parcelable的实现\",{\"1\":{\"314\":1}}],[\"下面是一个singlechildscrollview的简单使用\",{\"1\":{\"234\":1}}],[\"下面是一个statefulwidget的示例\",{\"1\":{\"134\":1}}],[\"下面是一个statelesswidget示例\",{\"1\":{\"133\":1}}],[\"下面是一个\",{\"1\":{\"212\":1}}],[\"下面是\",{\"1\":{\"201\":1}}],[\"下面是我们这个\",{\"1\":{\"127\":1}}],[\"下面是到目前为止涉及到的类关系示意图\",{\"1\":{\"111\":1}}],[\"下面为该挂件设置具体的布局样式\",{\"1\":{\"79\":1}}],[\"下面这两个类无需关注\",{\"1\":{\"281\":1}}],[\"下面这段代码中service就是client的依赖\",{\"1\":{\"82\":1}}],[\"下面这些是系统根据我们在aidl中定义的方法写的接口\",{\"1\":{\"58\":1}}],[\"下面这个来自hencoder\",{\"1\":{\"57\":1}}],[\"下面这个方法在不同系统分别采用不同方式获取文件对应的uri\",{\"1\":{\"2\":1}}],[\"下同\",{\"1\":{\"36\":1,\"63\":1,\"80\":2,\"274\":1}}],[\"下坡度\",{\"1\":{\"15\":1}}],[\"yml\",{\"0\":{\"407\":1},\"1\":{\"407\":1,\"415\":1,\"416\":1,\"417\":1}}],[\"yield\",{\"1\":{\"325\":1,\"327\":1}}],[\"y表示的是我们日常使用的年份\",{\"1\":{\"302\":1}}],[\"yyyy和yyyy的区别\",{\"1\":{\"302\":1}}],[\"yyyy\",{\"1\":{\"302\":10}}],[\"ylxfc的回答\",{\"1\":{\"293\":1}}],[\"yaml\",{\"1\":{\"132\":1}}],[\"year不一定是当年的值\",{\"1\":{\"302\":1}}],[\"year不一定是当年的年份值\",{\"1\":{\"302\":1}}],[\"year都是属于2019\",{\"1\":{\"302\":1}}],[\"year都是次年的\",{\"1\":{\"302\":1}}],[\"year的结论\",{\"1\":{\"302\":1}}],[\"year表示的是这个周所属的年份\",{\"1\":{\"302\":1}}],[\"year\",{\"1\":{\"302\":18}}],[\"yet\",{\"1\":{\"198\":1,\"378\":1}}],[\"yellow\",{\"1\":{\"131\":1,\"241\":1,\"242\":1}}],[\"yes\",{\"1\":{\"69\":2}}],[\"youtube\",{\"1\":{\"372\":2}}],[\"yout\",{\"1\":{\"368\":1}}],[\"youname是你的github的用户名\",{\"1\":{\"347\":1}}],[\"you\",{\"1\":{\"75\":1,\"136\":5,\"243\":3,\"308\":3,\"316\":1,\"368\":1,\"369\":1,\"426\":2}}],[\"yoursite\",{\"1\":{\"417\":3}}],[\"yourrepo是你要上传到github的仓库\",{\"1\":{\"347\":1}}],[\"yourrepo\",{\"1\":{\"347\":1}}],[\"yourname\",{\"1\":{\"347\":1,\"417\":1,\"418\":2,\"419\":3}}],[\"youremail\",{\"1\":{\"347\":1}}],[\"yourqualifiername替代\",{\"1\":{\"86\":1}}],[\"yourqualifiername可以是任意你喜欢的名字\",{\"1\":{\"86\":1}}],[\"yourqualifiername\",{\"1\":{\"86\":1}}],[\"your\",{\"1\":{\"2\":3,\"75\":1,\"136\":1,\"170\":1,\"243\":1,\"347\":3,\"367\":5,\"368\":1,\"406\":1,\"417\":1,\"426\":1}}],[\"y3\",{\"1\":{\"61\":1}}],[\"y2\",{\"1\":{\"61\":2}}],[\"y1\",{\"1\":{\"61\":2}}],[\"ydpi=403\",{\"1\":{\"53\":2}}],[\"y坐标和结束的的x\",{\"1\":{\"61\":2}}],[\"y坐标\",{\"1\":{\"41\":1,\"61\":2}}],[\"y坐标减去view内容的x\",{\"1\":{\"41\":1}}],[\"y的值便可以更改view的位置\",{\"1\":{\"41\":1}}],[\"y轴坐标\",{\"1\":{\"41\":2}}],[\"y根据场景不同可以是一行的行中心\",{\"1\":{\"15\":1}}],[\"y\",{\"1\":{\"15\":12,\"41\":3,\"62\":6,\"63\":7,\"64\":4,\"81\":1,\"302\":2,\"345\":2,\"368\":2,\"433\":1}}],[\"注销时执行~\",{\"1\":{\"361\":1}}],[\"注销登录时调用执行\",{\"1\":{\"360\":1}}],[\"注销的是指定的listener呢\",{\"1\":{\"36\":1}}],[\"注解要实现的逻辑\",{\"1\":{\"300\":1}}],[\"注解帮助类\",{\"0\":{\"300\":1}}],[\"注解参数支持数据类型如下\",{\"1\":{\"299\":1}}],[\"注解参数只可以为public或者默认\",{\"1\":{\"299\":1}}],[\"注解元素必须有明确的值\",{\"1\":{\"299\":1}}],[\"注解类\",{\"0\":{\"299\":1}}],[\"注解不能继承其他注解或接口\",{\"1\":{\"298\":1}}],[\"注解\",{\"1\":{\"298\":1}}],[\"注解从小于\",{\"1\":{\"173\":1}}],[\"注册新账户\",{\"1\":{\"417\":1}}],[\"注册并登录\",{\"1\":{\"417\":1}}],[\"注册获取\",{\"1\":{\"211\":1}}],[\"注册与flutter端对应的方法\",{\"1\":{\"211\":1}}],[\"注册到了buildowner中\",{\"1\":{\"121\":1}}],[\"注册事件\",{\"1\":{\"79\":1}}],[\"注册ongloballayoutlistener\",{\"1\":{\"65\":1}}],[\"注册myservices\",{\"1\":{\"17\":1}}],[\"注\",{\"1\":{\"14\":1,\"126\":1,\"419\":1}}],[\"注意下面这里的group=nullptr\",{\"1\":{\"384\":1}}],[\"注意下面这个方法\",{\"1\":{\"130\":1}}],[\"注意getmethod\",{\"1\":{\"300\":1}}],[\"注意此时只是为as分配了内存\",{\"1\":{\"294\":1}}],[\"注意此处监听了animationcontroller的变化并自动触发setstate\",{\"1\":{\"152\":1}}],[\"注意不是创建richtext的text\",{\"1\":{\"127\":1}}],[\"注意如果是kotlin语言\",{\"1\":{\"88\":1}}],[\"注意如果需要更新进度\",{\"1\":{\"80\":1}}],[\"注意是类\",{\"1\":{\"85\":1}}],[\"注意三个参数\",{\"1\":{\"56\":1}}],[\"注意其直接子view必须就是要实现联动的view\",{\"1\":{\"55\":1}}],[\"注意\",{\"1\":{\"36\":1,\"40\":1,\"41\":1,\"56\":2,\"114\":2,\"115\":1,\"193\":1,\"206\":2,\"272\":1,\"282\":1,\"302\":1,\"306\":1,\"334\":1,\"369\":1,\"375\":1,\"408\":1,\"455\":1,\"456\":1,\"458\":1}}],[\"注意mservice在androidmanife\",{\"1\":{\"36\":1}}],[\"注意这里参与比较的是max\",{\"1\":{\"456\":1}}],[\"注意这里需要是完整的类名\",{\"1\":{\"295\":1}}],[\"注意这里获取到是线程本身的threadlocals对象\",{\"1\":{\"288\":1}}],[\"注意这里获取到了overlaystate\",{\"1\":{\"180\":1}}],[\"注意这里调用multichildrenderobjectelement持有的renderobject的\",{\"1\":{\"230\":1}}],[\"注意这里只给\",{\"1\":{\"223\":1}}],[\"注意这里只是加入到\",{\"1\":{\"198\":1}}],[\"注意这里使用的从\",{\"1\":{\"213\":1}}],[\"注意这里使用了子类实现的widget\",{\"1\":{\"155\":1}}],[\"注意这里传入了widget处获取的controller\",{\"1\":{\"213\":1}}],[\"注意这里将\",{\"1\":{\"178\":1}}],[\"注意这里返回了richtext\",{\"1\":{\"126\":1}}],[\"注意这里用container也就是renderview创建了一个globalobjectkey\",{\"1\":{\"120\":1}}],[\"注意这里创建了renderview\",{\"1\":{\"118\":1}}],[\"注意这里\",{\"1\":{\"93\":1,\"118\":1,\"125\":2,\"309\":1}}],[\"注意这里是\",{\"1\":{\"91\":1}}],[\"注意这里是new\",{\"1\":{\"35\":1}}],[\"注意这里要指明\",{\"1\":{\"91\":1}}],[\"注意这里会调用doinbackground\",{\"1\":{\"80\":1}}],[\"注意这里注册了一个\",{\"1\":{\"79\":1}}],[\"注意这里一定要判断非空\",{\"1\":{\"36\":1}}],[\"注意这里的run方法\",{\"1\":{\"381\":1}}],[\"注意这里的requestcode\",{\"1\":{\"7\":1}}],[\"注意这里的key是networkimage对象\",{\"1\":{\"196\":1}}],[\"注意这里的tag要和下一个页面的hero\",{\"1\":{\"170\":1}}],[\"注意这里的参数\",{\"1\":{\"114\":1}}],[\"注意这里的关键代码\",{\"1\":{\"101\":1}}],[\"注意这里的要求\",{\"1\":{\"80\":1}}],[\"注意这里的构造方法传入的是ibinder对象\",{\"1\":{\"43\":1}}],[\"注意这里的pintent需要与设置闹钟时的pendingintent一致\",{\"1\":{\"12\":1}}],[\"注意事项\",{\"0\":{\"34\":1}}],[\"注意该方法并不会停止服务\",{\"1\":{\"21\":1}}],[\"注意service要在不同的进程中\",{\"1\":{\"20\":1}}],[\"注意recyclerview的版本号要和当前工程中其他android\",{\"1\":{\"1\":1}}],[\"只在正式的数据和模拟训练的配置无法匹配的时候执行jit\",{\"1\":{\"396\":1}}],[\"只需一次resume就可以恢复isolate\",{\"1\":{\"375\":1}}],[\"只需要将other移动到柱子b\",{\"1\":{\"459\":1}}],[\"只需要将待排序的数组依次插入堆中\",{\"1\":{\"442\":1}}],[\"只需要找出最小数量的边即可\",{\"1\":{\"438\":1}}],[\"只需要实现接口\",{\"1\":{\"310\":1}}],[\"只需要实现serializable接口即可\",{\"1\":{\"303\":1}}],[\"只需要在在\",{\"1\":{\"155\":1}}],[\"只需要在\",{\"1\":{\"55\":1}}],[\"只需要按当前待注销的listener的binder对象找到已经注册了的listener并删除掉即可\",{\"1\":{\"36\":1}}],[\"只需要添加一个过渡页面为启动activity\",{\"1\":{\"14\":1}}],[\"只捕获上游异常\",{\"1\":{\"341\":1}}],[\"只取前n个发射的值\",{\"1\":{\"338\":1}}],[\"只接受flow发送的一个值\",{\"1\":{\"337\":1}}],[\"只接受可以创建\",{\"1\":{\"213\":1}}],[\"只支持阻塞代码\",{\"1\":{\"335\":1}}],[\"只支持可以创建\",{\"1\":{\"230\":1}}],[\"只获取并处理最新的值\",{\"1\":{\"344\":1}}],[\"只获取前两个\",{\"1\":{\"327\":1}}],[\"只获取指定类型的widget\",{\"1\":{\"129\":1}}],[\"只计算该java对象本身的大小\",{\"1\":{\"282\":1}}],[\"只使用一半\",{\"1\":{\"262\":1}}],[\"只要有比插入点小的元素\",{\"1\":{\"457\":1}}],[\"只要有足够内存就不会被gc回收\",{\"1\":{\"269\":1}}],[\"只要新建一个符合hexo要求的文档\",{\"1\":{\"407\":1}}],[\"只要数据库中的数据有更新\",{\"1\":{\"399\":1}}],[\"只要保持一致即可\",{\"1\":{\"304\":1}}],[\"只要obj指向的对象改变\",{\"1\":{\"288\":1}}],[\"只要\",{\"1\":{\"146\":1,\"157\":1}}],[\"只要各个点满足条件\",{\"1\":{\"61\":1}}],[\"只会解析加载的类和库的基本信息\",{\"1\":{\"394\":1}}],[\"只会捕获发送在他之前的异常\",{\"1\":{\"327\":1}}],[\"只会记录下首次出现的实例的引用\",{\"1\":{\"254\":1}}],[\"只会终止执行出错代码之后的逻辑\",{\"1\":{\"141\":1}}],[\"只会更新那些在inheritedwidget这里注册依赖了的widget\",{\"1\":{\"130\":1}}],[\"只会被调用一次\",{\"1\":{\"17\":1}}],[\"只是在每次插入的时候都进行排序\",{\"1\":{\"453\":1}}],[\"只是一个标记\",{\"1\":{\"303\":1}}],[\"只是根据传参创建请求并保存\",{\"1\":{\"211\":1}}],[\"只是替子类做了监听\",{\"1\":{\"155\":1}}],[\"只是监听传入的\",{\"1\":{\"155\":1}}],[\"只是查找到inheritedwidget的引用\",{\"1\":{\"130\":1}}],[\"只是为了和text对应表示这里本应该有一个对应的renderobject\",{\"1\":{\"126\":1}}],[\"只不过他的子类可以有多个实例\",{\"1\":{\"322\":1}}],[\"只不过它支持key值为其他类型\",{\"1\":{\"287\":1}}],[\"只不过它可以将多个\",{\"1\":{\"183\":1}}],[\"只不过编译器判断该局部变量不会再被修改时\",{\"1\":{\"281\":1}}],[\"只不过\",{\"1\":{\"207\":1}}],[\"只不过在\",{\"1\":{\"172\":1}}],[\"只不过由于fragment的特性\",{\"1\":{\"94\":1}}],[\"只不过没有反应\",{\"1\":{\"13\":1}}],[\"只有父节点为红色这种情况需要进行修正\",{\"1\":{\"458\":1}}],[\"只有左节点\",{\"1\":{\"441\":2}}],[\"只有一个参数\",{\"1\":{\"322\":1}}],[\"只有1号到4号4天\",{\"1\":{\"302\":1}}],[\"只有明确调用静态内部类的时候才会初始化静态内部类\",{\"1\":{\"294\":1}}],[\"只有要用到该实例时\",{\"1\":{\"294\":1}}],[\"只有数组对象才有\",{\"1\":{\"282\":1}}],[\"只有table为空\",{\"1\":{\"280\":1}}],[\"只有直接定义其的类才会\",{\"1\":{\"279\":1}}],[\"只有横轴方向的约束\",{\"1\":{\"238\":1}}],[\"只有在访问的时候才生产对应的项目\",{\"1\":{\"327\":1}}],[\"只有在程序结束才会被回收\",{\"1\":{\"288\":1}}],[\"只有在\",{\"1\":{\"226\":1}}],[\"只有主动调用\",{\"1\":{\"223\":1}}],[\"只有内存中的\",{\"1\":{\"198\":1}}],[\"只有当没有\",{\"1\":{\"194\":1}}],[\"只有动画未开始\",{\"1\":{\"176\":1}}],[\"只有根据目标\",{\"1\":{\"171\":1}}],[\"只有传入\",{\"1\":{\"153\":1}}],[\"只有colorfulcontainer重新绘制了\",{\"1\":{\"130\":1}}],[\"只有renderobject类及其子类才会创建renderobject\",{\"1\":{\"126\":1}}],[\"只有newwidget\",{\"1\":{\"126\":1}}],[\"只有屏幕水平dp值rdp还是未知的\",{\"1\":{\"81\":1}}],[\"只有第一个客户端绑定时才会调用服务onbind\",{\"1\":{\"21\":1}}],[\"只能访问指定元素\",{\"1\":{\"445\":1}}],[\"只能一次性返回多个值\",{\"1\":{\"335\":1}}],[\"只能作为生产者调用get之类的方法\",{\"1\":{\"322\":1}}],[\"只能在内存中存在\",{\"1\":{\"303\":1}}],[\"只能等t1运行完这段语句并释放之后\",{\"1\":{\"294\":1}}],[\"只能滑到最大范围\",{\"1\":{\"220\":2}}],[\"只能通过double\",{\"1\":{\"186\":1}}],[\"只能通过isolate\",{\"1\":{\"115\":1}}],[\"只能被执行一次\",{\"1\":{\"80\":1}}],[\"只能承载很小的信息量\",{\"1\":{\"58\":1}}],[\"只绘制src与dst未重合部分\",{\"1\":{\"57\":1}}],[\"只绘制src与dst重合部分\",{\"1\":{\"57\":1}}],[\"只绘制src\",{\"1\":{\"57\":1}}],[\"只绘制dst与src未重合部分\",{\"1\":{\"57\":1}}],[\"只绘制dst与src重合部分\",{\"1\":{\"57\":1}}],[\"只绘制dst\",{\"1\":{\"57\":1}}],[\"只处理window区域内的点击事件\",{\"1\":{\"41\":1}}],[\"待排序的数组\",{\"1\":{\"459\":1}}],[\"待排序的文件的分隔符\",{\"1\":{\"361\":1}}],[\"待实现\",{\"1\":{\"368\":1}}],[\"待整理\",{\"1\":{\"327\":1}}],[\"待主activity完全加载好后再将背景切换为普通模式\",{\"1\":{\"14\":1}}],[\"待定的intent是一个pendingintent\",{\"1\":{\"7\":1}}],[\"待定的intent\",{\"0\":{\"7\":1}}],[\"以此类推\",{\"1\":{\"460\":1}}],[\"以此来移除不可达的方法\",{\"1\":{\"396\":1}}],[\"以组节点53为支点左旋\",{\"1\":{\"458\":1}}],[\"以祖父节点为支点左旋\",{\"1\":{\"458\":1}}],[\"以祖父节6点为支点左旋\",{\"1\":{\"458\":1}}],[\"以34为支点右旋\",{\"1\":{\"458\":1}}],[\"以某个支点旋转\",{\"1\":{\"458\":1}}],[\"以满足排序规则\",{\"1\":{\"453\":1}}],[\"以正确的顺序输出排序结果\",{\"1\":{\"438\":1}}],[\"以向左为0\",{\"1\":{\"432\":1}}],[\"以中序遍历为例\",{\"1\":{\"430\":1}}],[\"以实现部署多个hexo工程到同一github项目不同目录下\",{\"1\":{\"405\":1}}],[\"以实现当padding\",{\"1\":{\"156\":1}}],[\"以供参考\",{\"1\":{\"371\":1}}],[\"以英文月份排序\",{\"1\":{\"361\":1}}],[\"以数组排序\",{\"1\":{\"361\":1}}],[\"以第几列为标准排序\",{\"1\":{\"361\":1}}],[\"以分页形式查看文件内容\",{\"1\":{\"349\":1}}],[\"以文本格式查看文件全部内容\",{\"1\":{\"349\":1}}],[\"以备后用\",{\"1\":{\"347\":1}}],[\"以保证某一侧的子树\",{\"1\":{\"346\":1}}],[\"以粗粒度限制线程\",{\"1\":{\"334\":1}}],[\"以细粒度限制线程\",{\"1\":{\"334\":1}}],[\"以外的异常\",{\"1\":{\"329\":1}}],[\"以时间换取空间\",{\"1\":{\"322\":1}}],[\"以确保它包含\",{\"1\":{\"291\":1}}],[\"以确保绘制的背景在我们需要的范围内\",{\"1\":{\"63\":1}}],[\"以enumclazz\",{\"1\":{\"285\":1}}],[\"以extendedimage\",{\"1\":{\"200\":1}}],[\"以64位jvm启用压缩为例\",{\"1\":{\"282\":1}}],[\"以sun\",{\"1\":{\"255\":1}}],[\"以string\",{\"1\":{\"254\":1}}],[\"以statefulwidget为例\",{\"1\":{\"128\":1}}],[\"以child的左上角在singlechildscrollview左上角为0\",{\"1\":{\"239\":1}}],[\"以在\",{\"1\":{\"231\":1}}],[\"以一个垂直方向向下布局的滑动列表为例\",{\"1\":{\"220\":1}}],[\"以从网络加载图片为例\",{\"1\":{\"198\":1}}],[\"以networkimage加载网络图片的过程为例\",{\"1\":{\"196\":1}}],[\"以image\",{\"1\":{\"188\":1}}],[\"以当前\",{\"1\":{\"171\":1}}],[\"以触发\",{\"1\":{\"156\":1}}],[\"以维护动画\",{\"1\":{\"156\":1}}],[\"以\",{\"1\":{\"152\":1,\"153\":1,\"178\":1,\"211\":1}}],[\"以管理动画\",{\"1\":{\"147\":1}}],[\"以竖屏情况下屏幕宽度为例\",{\"1\":{\"81\":1}}],[\"以设计稿宽度和屏幕水平方法大小为准\",{\"1\":{\"81\":1}}],[\"以上所有类型的数组\",{\"1\":{\"299\":1}}],[\"以上所有情况的警告\",{\"1\":{\"298\":1}}],[\"以上所有代码如下\",{\"1\":{\"93\":1}}],[\"以上5种称为对一个类的主动引用\",{\"1\":{\"279\":1}}],[\"以上分析为\",{\"1\":{\"211\":1}}],[\"以上完整的代码可以参考这里\",{\"1\":{\"84\":1}}],[\"以上介绍了线程和线程池部分的内容\",{\"1\":{\"80\":1}}],[\"以上都没有找到\",{\"1\":{\"49\":1}}],[\"以通过系统的检查\",{\"1\":{\"72\":1}}],[\"以其宽度为例\",{\"1\":{\"65\":1}}],[\"以path\",{\"1\":{\"61\":1}}],[\"以初始化这个虚拟内存区域的内容\",{\"1\":{\"58\":1}}],[\"以下操作以邻接表方式为例\",{\"1\":{\"433\":1}}],[\"以下为原文提到的其他方法\",{\"1\":{\"347\":1}}],[\"以下为非必须代码\",{\"1\":{\"321\":1}}],[\"以下为示例\",{\"1\":{\"56\":1}}],[\"以下示例皆为从小到大的排序\",{\"1\":{\"289\":1}}],[\"以下所说的计算java对象大小\",{\"1\":{\"282\":1}}],[\"以下类都是基于\",{\"1\":{\"233\":1}}],[\"以下是错误信息\",{\"1\":{\"143\":1}}],[\"以下是代码\",{\"1\":{\"79\":1}}],[\"以下数据为redmi\",{\"1\":{\"81\":1}}],[\"以下内容来自\",{\"1\":{\"58\":1}}],[\"以便以后查看\",{\"1\":{\"408\":1}}],[\"以便在充分利用sqlite强大功能的同时\",{\"1\":{\"403\":1}}],[\"以便在下次屏幕刷新时安排rebuilt\",{\"1\":{\"128\":1}}],[\"以便您将精力集中放在所需的代码上\",{\"1\":{\"399\":1}}],[\"以便学习如何封装常见工具的思想\",{\"1\":{\"362\":1}}],[\"以便日后查验\",{\"1\":{\"335\":1}}],[\"以便header内容尽快scroll\",{\"1\":{\"226\":1}}],[\"以便让imagecache能够管理texture创建的图片\",{\"1\":{\"210\":1}}],[\"以便对一部分图片缓存统一处理\",{\"1\":{\"202\":1}}],[\"以便\",{\"1\":{\"188\":1}}],[\"以便产生非线性的动画\",{\"1\":{\"186\":1}}],[\"以便为\",{\"1\":{\"185\":1}}],[\"以便实时改变过渡组件\",{\"1\":{\"181\":1}}],[\"以便告诉flutter在下一次rebuild的时候更新ui\",{\"1\":{\"134\":1}}],[\"以便当该widget变化的时候\",{\"1\":{\"129\":1}}],[\"以便其他控件指定选中的字母\",{\"1\":{\"64\":1}}],[\"以便其他控件获取当前选中的字母\",{\"1\":{\"64\":1}}],[\"以便可以在activity布局文件里面使用到该件组时自定义控一些属性\",{\"1\":{\"56\":1}}],[\"以便整理数组结构\",{\"1\":{\"48\":1}}],[\"以2160\",{\"1\":{\"53\":1}}],[\"以我们使用的设计稿宽度为375dp为例\",{\"1\":{\"53\":1}}],[\"以适配屏幕宽度为例\",{\"1\":{\"53\":1}}],[\"以横轴为x轴\",{\"1\":{\"41\":1}}],[\"以屏幕左上角顶点为原点\",{\"1\":{\"41\":1}}],[\"以及顺着某一个节点一直到遇到叶节点的路径上的节点关键字是依次递减的\",{\"1\":{\"439\":1}}],[\"以及任务执行的条件\",{\"1\":{\"404\":1}}],[\"以及custom\",{\"1\":{\"400\":1}}],[\"以及他们如何巧妙的搭配使用\",{\"1\":{\"399\":1}}],[\"以及他们是如何添加到我们的flutter\",{\"1\":{\"122\":1}}],[\"以及无聊时瞎琢磨得出来的稀奇古怪的想法放到这里\",{\"1\":{\"398\":1}}],[\"以及类型在程序中是如何应用的\",{\"1\":{\"396\":1}}],[\"以及将解析好的数据格式化输出\",{\"1\":{\"371\":1}}],[\"以及便利这些url的功能\",{\"1\":{\"370\":1}}],[\"以及挂起友好且遵从结构化并发\",{\"1\":{\"335\":1}}],[\"以及实施更复杂的转换\",{\"1\":{\"327\":1}}],[\"以及实现了parcelable接口的对象\",{\"1\":{\"33\":1}}],[\"以及跨进程传递对象等时使用parcelable以节省性能\",{\"1\":{\"316\":1}}],[\"以及基于customscrollview的nestedscrollview\",{\"1\":{\"234\":1}}],[\"以及基于\",{\"1\":{\"212\":1,\"227\":1}}],[\"以及超大图内存峰值等问题\",{\"1\":{\"203\":1}}],[\"以及图片大小sizebytes\",{\"1\":{\"197\":1}}],[\"以及一个获取图片像素大小的sizebytes方法\",{\"1\":{\"192\":1}}],[\"以及一下几种会按照同步方法立即执行的方式\",{\"1\":{\"95\":1}}],[\"以及热更新\",{\"1\":{\"190\":1}}],[\"以及依赖于特定设备的格式\",{\"1\":{\"188\":1}}],[\"以及power\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"以及绘制过渡\",{\"1\":{\"176\":1}}],[\"以及控制其\",{\"1\":{\"176\":1}}],[\"以及根据初始化以及开始\",{\"1\":{\"176\":1}}],[\"以及展示对应的\",{\"1\":{\"155\":1}}],[\"以及\",{\"1\":{\"154\":1,\"202\":1,\"212\":1,\"302\":1,\"329\":2}}],[\"以及flutter开发的一些基础知识\",{\"1\":{\"132\":1}}],[\"以及执行调用方需要的功能呢\",{\"1\":{\"112\":1}}],[\"以及timer\",{\"1\":{\"101\":1}}],[\"以及其简单用法\",{\"1\":{\"82\":1}}],[\"以及我们需要求得的控件在设备中的dp值m\",{\"1\":{\"81\":1}}],[\"以及view的margin和padding\",{\"1\":{\"65\":1}}],[\"以及颜色变化\",{\"1\":{\"57\":1}}],[\"以及在实际使用中遇到的一个问题\",{\"1\":{\"53\":1}}],[\"以及通过二分法查找索引都会消耗性能\",{\"1\":{\"44\":1}}],[\"以及主进程的主activity启动时生命周期会出现异常\",{\"1\":{\"14\":1}}],[\"以调用服务的公共方法\",{\"1\":{\"19\":1}}],[\"以启动服务以及执行其他操作\",{\"1\":{\"3\":1}}],[\"并以此将数组划分为两部分\",{\"1\":{\"467\":1}}],[\"并以json格式输出\",{\"1\":{\"371\":1}}],[\"并插入到对应位置\",{\"1\":{\"462\":1}}],[\"并插入到队列\",{\"1\":{\"438\":1}}],[\"并记录下空出的位置为toindex\",{\"1\":{\"441\":1}}],[\"并再和新的子节点比较\",{\"1\":{\"441\":1}}],[\"并说明有环存在即可\",{\"1\":{\"438\":1}}],[\"并添加\",{\"1\":{\"412\":1}}],[\"并添加对于自定义属性\",{\"1\":{\"56\":1}}],[\"并提交到github对应项目的hexo分支中source目录\",{\"1\":{\"407\":1}}],[\"并提供了double\",{\"1\":{\"186\":1}}],[\"并提供\",{\"1\":{\"177\":1}}],[\"并同步到github上面\",{\"1\":{\"407\":1}}],[\"并删除旧的博客内容\",{\"1\":{\"407\":1}}],[\"并devirtuablize\",{\"1\":{\"396\":1}}],[\"并通知isolate的父isolate当前isolate创建成功\",{\"1\":{\"389\":1}}],[\"并通过帮助类真正实现注解逻辑\",{\"1\":{\"301\":1}}],[\"并通过\",{\"1\":{\"181\":1}}],[\"并通过herocontroller\",{\"1\":{\"178\":1}}],[\"并通过其管理动画\",{\"1\":{\"157\":1}}],[\"并通过其\",{\"1\":{\"146\":1}}],[\"并通过0号引用将其发给servermanager\",{\"1\":{\"58\":1}}],[\"并通过onbind\",{\"1\":{\"20\":1}}],[\"并处理\",{\"1\":{\"375\":1}}],[\"并回车\",{\"1\":{\"368\":1}}],[\"并回调\",{\"1\":{\"162\":1}}],[\"并据此产生call对象\",{\"1\":{\"365\":1}}],[\"并据此创建\",{\"1\":{\"171\":1}}],[\"并有可选的类型标注\",{\"1\":{\"345\":1}}],[\"并发拼接\",{\"1\":{\"340\":1}}],[\"并发出\",{\"1\":{\"221\":1}}],[\"并发出通知\",{\"1\":{\"162\":1,\"163\":1,\"168\":1}}],[\"并行执行\",{\"1\":{\"327\":1}}],[\"并修改为\",{\"1\":{\"325\":1}}],[\"并修改了传入的值的话则不会相等\",{\"1\":{\"65\":1}}],[\"并阻塞其所在线程\",{\"1\":{\"323\":1}}],[\"并探讨一下其实现原理\",{\"1\":{\"303\":1}}],[\"并未执行asingleton的构造方法\",{\"1\":{\"294\":1}}],[\"并未使用\",{\"1\":{\"198\":1}}],[\"并没有在native层新建isolate\",{\"1\":{\"378\":1}}],[\"并没有调用\",{\"1\":{\"223\":1}}],[\"并没有注册依赖\",{\"1\":{\"130\":1}}],[\"并生成\",{\"1\":{\"211\":1}}],[\"并指定回调方法为powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"并根据我的需求更改了部分内容\",{\"1\":{\"405\":1}}],[\"并根据返回值调用子类\",{\"1\":{\"208\":1}}],[\"并根据service的状态不同而被调用对应方法\",{\"1\":{\"58\":1}}],[\"并加入到\",{\"1\":{\"198\":1}}],[\"并绑定\",{\"1\":{\"181\":1}}],[\"并伴随着位置\",{\"1\":{\"181\":1}}],[\"并引发\",{\"1\":{\"176\":1}}],[\"并执行uri中的main方法\",{\"1\":{\"391\":1}}],[\"并执行entrypoint方法\",{\"1\":{\"373\":1}}],[\"并执行其handlerequest方法处理加载图片请求\",{\"1\":{\"211\":1}}],[\"并执行其方法\",{\"1\":{\"35\":1}}],[\"并执行powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"并执行\",{\"1\":{\"171\":1}}],[\"并用该二进制表示形式创建类或者接口的过程\",{\"1\":{\"274\":1}}],[\"并用相同大小的\",{\"1\":{\"171\":1}}],[\"并用构造函数调用initview\",{\"1\":{\"66\":1}}],[\"并开启\",{\"1\":{\"168\":1}}],[\"并开始监听传入的\",{\"1\":{\"157\":1}}],[\"并保存数据\",{\"1\":{\"428\":1}}],[\"并保存源文件\",{\"1\":{\"368\":1}}],[\"并保存到数组res\",{\"1\":{\"371\":1}}],[\"并保存到\",{\"1\":{\"188\":1}}],[\"并保存对应数据\",{\"1\":{\"50\":1}}],[\"并保证当\",{\"1\":{\"161\":1}}],[\"并允许其他对象监听二者的变化\",{\"1\":{\"158\":1}}],[\"并对其作以修改\",{\"1\":{\"295\":1}}],[\"并对\",{\"1\":{\"157\":1}}],[\"并监听传入的offset\",{\"1\":{\"239\":1}}],[\"并监听其值变化\",{\"1\":{\"156\":1}}],[\"并监听回调\",{\"1\":{\"112\":1}}],[\"并传入无参\",{\"1\":{\"373\":1}}],[\"并传入scrollable\",{\"1\":{\"227\":1}}],[\"并传入ui\",{\"1\":{\"198\":1}}],[\"并传入\",{\"1\":{\"153\":1}}],[\"并不针真的删除该点\",{\"1\":{\"458\":1}}],[\"并不是一个好办法\",{\"1\":{\"408\":1}}],[\"并不是从文字高度的中间开始绘制\",{\"1\":{\"15\":1}}],[\"并不会处理\",{\"1\":{\"328\":1}}],[\"并不会再将对象的内容进行存储\",{\"1\":{\"309\":1}}],[\"并不会影响其他任务执行\",{\"1\":{\"141\":1}}],[\"并不推荐在android中使用\",{\"1\":{\"294\":1}}],[\"并不推荐该方法\",{\"1\":{\"266\":1}}],[\"并不需要立即获取到其单例\",{\"1\":{\"294\":1}}],[\"并不能真正真正绘制内容\",{\"1\":{\"211\":1}}],[\"并接受输入\",{\"1\":{\"138\":1}}],[\"并依此将text\",{\"1\":{\"127\":1}}],[\"并作为根element\",{\"1\":{\"119\":1}}],[\"并触发\",{\"1\":{\"108\":1,\"155\":2,\"198\":1}}],[\"并丢弃掉后续future的返回\",{\"1\":{\"102\":1}}],[\"并获取到他实例化好的service对象注入到client中就可以了\",{\"1\":{\"85\":1}}],[\"并按照串行的顺序依次调用\",{\"1\":{\"80\":1}}],[\"并一并传入mfuture中\",{\"1\":{\"80\":1}}],[\"并一直存活\",{\"1\":{\"17\":1}}],[\"并为按钮绑定监听事件\",{\"1\":{\"79\":1}}],[\"并改变字的颜色\",{\"1\":{\"64\":1}}],[\"并更新界面\",{\"1\":{\"64\":1}}],[\"并相应更新界面\",{\"1\":{\"64\":1}}],[\"并实现动画效果\",{\"1\":{\"61\":1}}],[\"并实现客户端\",{\"1\":{\"43\":1}}],[\"并返回下游流\",{\"1\":{\"327\":1,\"338\":1}}],[\"并返回其结果\",{\"1\":{\"305\":1}}],[\"并返回其指针\",{\"1\":{\"211\":1}}],[\"并返回结果\",{\"1\":{\"184\":1}}],[\"并返回红底黄字的错误原因widget\",{\"1\":{\"141\":1}}],[\"并返回\",{\"1\":{\"49\":1,\"183\":1,\"207\":1}}],[\"并分别插入key和value\",{\"1\":{\"45\":1}}],[\"并从中取出服务端传回来的数据\",{\"1\":{\"40\":1}}],[\"并请求服务端调用指定方法\",{\"1\":{\"40\":1}}],[\"并向\",{\"1\":{\"40\":1,\"211\":1}}],[\"并调用由子类实现的foreachtween\",{\"1\":{\"148\":1}}],[\"并调用其execute\",{\"1\":{\"80\":1}}],[\"并调用listener\",{\"1\":{\"56\":1}}],[\"并调用接口对应方法\",{\"1\":{\"32\":1}}],[\"并调用msg\",{\"1\":{\"25\":1}}],[\"并在布局中使用\",{\"1\":{\"401\":1}}],[\"并在新的线程运行\",{\"1\":{\"389\":1}}],[\"并在初始化完成后通知创建这个isolate的isolate\",{\"1\":{\"383\":1}}],[\"并在内部调用self\",{\"1\":{\"370\":1}}],[\"并在块执行完毕后消耗掉这个receivechannel\",{\"1\":{\"328\":1}}],[\"并在任何上游流发出值时重新计算它\",{\"1\":{\"327\":1}}],[\"并在readobject\",{\"1\":{\"280\":1}}],[\"并在检测到有重复\",{\"1\":{\"175\":1}}],[\"并在builder中直接复用\",{\"1\":{\"156\":1}}],[\"并在每次执行完event后\",{\"1\":{\"109\":1}}],[\"并在每次普通的event\",{\"1\":{\"101\":1}}],[\"并在\",{\"1\":{\"106\":1,\"181\":1,\"184\":1}}],[\"并在thread\",{\"1\":{\"80\":1}}],[\"并在post\",{\"1\":{\"31\":1}}],[\"并在后台进程运行multidex\",{\"1\":{\"14\":1}}],[\"并共同参与处理message\",{\"1\":{\"31\":1}}],[\"并由此获得mqueue\",{\"1\":{\"31\":1}}],[\"并将小的复制到新数组\",{\"1\":{\"459\":1}}],[\"并将左节点c的右节点赋值给该节点a\",{\"1\":{\"458\":1}}],[\"并将插入优先级队列中\",{\"1\":{\"432\":1}}],[\"并将isolate标记为runnable\",{\"1\":{\"387\":1}}],[\"并将m与其后的另外一个元素继续进行比较\",{\"1\":{\"289\":1}}],[\"并将msg压入mqueue中\",{\"1\":{\"28\":1}}],[\"并将数组用该类加载器标识\",{\"1\":{\"274\":1}}],[\"并将其作为整个flutter\",{\"1\":{\"122\":1}}],[\"并将其设置为\",{\"1\":{\"118\":1}}],[\"并将renderview设置为\",{\"1\":{\"127\":1}}],[\"并将renderview作为自己对应的renderobject\",{\"1\":{\"120\":1}}],[\"并将renderobjecttowidgetadapter与之绑定\",{\"1\":{\"121\":1}}],[\"并将renderobjecttowidgetadapter和renderview与之绑定\",{\"1\":{\"119\":1}}],[\"并将上一个timer的\",{\"1\":{\"106\":1}}],[\"并将androidinjectionmodule加入其中\",{\"1\":{\"89\":1}}],[\"并将主activity背景设置为透明\",{\"1\":{\"14\":1}}],[\"并与当前线程关联保存在sthreadlocal中\",{\"1\":{\"24\":1}}],[\"并且下面的圆盘要比上面的圆盘直径大\",{\"1\":{\"459\":1}}],[\"并且子节点关键字小于该点\",{\"1\":{\"440\":1}}],[\"并且容量大小不再变化时\",{\"1\":{\"428\":1}}],[\"并且登录\",{\"1\":{\"417\":1}}],[\"并且可以在不中断线程的情况下访问或修改\",{\"1\":{\"396\":1}}],[\"并且可以使用sizebox给child指定大小以减轻计算intrinsic\",{\"1\":{\"242\":1}}],[\"并且目前为止dart和flutter都默认支持在使用isolate\",{\"1\":{\"372\":1}}],[\"并且限制访问文件数量\",{\"1\":{\"370\":1}}],[\"并且使用\",{\"1\":{\"347\":1}}],[\"并且使用imagecache统一管理图片缓存\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"并且尊重调用它们的多个协程\",{\"1\":{\"328\":1}}],[\"并且只能处理上游的异常\",{\"1\":{\"328\":1}}],[\"并且去处理最新的值\",{\"1\":{\"327\":1}}],[\"并且每次collect都会被启动\",{\"1\":{\"327\":1}}],[\"并且每次循环间隔有几毫秒的误差\",{\"1\":{\"5\":1}}],[\"并且参数都需要用var\",{\"1\":{\"321\":1}}],[\"并且需要一个明确实现的\",{\"1\":{\"310\":1}}],[\"并且需要展示\",{\"1\":{\"176\":1}}],[\"并且起始年份包含的天数至少要有4天\",{\"1\":{\"302\":1}}],[\"并且当年的1月1日\",{\"1\":{\"302\":1}}],[\"并且之后的修改也不会\",{\"1\":{\"288\":1}}],[\"并且链表长度超过min\",{\"1\":{\"280\":1}}],[\"并且这个对象在其他线程被更改\",{\"1\":{\"288\":1}}],[\"并且这个尺寸超过了父级约束\",{\"1\":{\"238\":1}}],[\"并且这里的sizebytes是图片实际大小\",{\"1\":{\"198\":1}}],[\"并且已经得知文本方向\",{\"1\":{\"228\":1}}],[\"并且内部持有\",{\"1\":{\"217\":1}}],[\"并且还会在\",{\"1\":{\"213\":1}}],[\"并且混入了extendedimageprovider的子类\",{\"1\":{\"200\":1}}],[\"并且监听imagestream以便在图片加载成功之后获取imageinfo\",{\"1\":{\"195\":1}}],[\"并且大小也从\",{\"1\":{\"170\":1}}],[\"并且\",{\"1\":{\"153\":1,\"306\":1}}],[\"并且将上述第二步常见网络请求的过程也加入链式调用中\",{\"1\":{\"362\":1}}],[\"并且将自己注册到此widget\",{\"1\":{\"129\":1}}],[\"并且将我们在runapp传入的widgetrootwidget\",{\"1\":{\"127\":1}}],[\"并且初始化它以便在下一帧的时候对其进行渲染\",{\"1\":{\"122\":1}}],[\"并且有了自己的child\",{\"1\":{\"121\":1}}],[\"并且同时也将rootwidget和之前创建的rendering\",{\"1\":{\"121\":1}}],[\"并且在\",{\"1\":{\"168\":1}}],[\"并且在最后调用dart\",{\"1\":{\"116\":1}}],[\"并且在api19+之后的所有的重复闹钟都不是精确的\",{\"1\":{\"3\":1}}],[\"并且选择了\",{\"1\":{\"69\":1}}],[\"并且返回值还是\",{\"1\":{\"184\":1}}],[\"并且返回值为false\",{\"1\":{\"69\":1}}],[\"并且返回结果为false\",{\"1\":{\"68\":1}}],[\"并且提供方法获取\",{\"1\":{\"64\":1}}],[\"并且包括透明区域在内的图片大小\",{\"1\":{\"57\":1}}],[\"并且滑动的方向是垂直的\",{\"1\":{\"55\":1}}],[\"并且从这个时候开始慢慢展开\",{\"1\":{\"55\":1}}],[\"并且用数组直接保存key\",{\"1\":{\"44\":1}}],[\"并且会在客户端被调用\",{\"1\":{\"40\":1}}],[\"并且直至服务死亡\",{\"1\":{\"17\":1}}],[\"并且要确保过渡activity可能会调用到的类加载到了主dex文件中\",{\"1\":{\"14\":1}}],[\"并且不是action\",{\"1\":{\"13\":1}}],[\"并且恢复闹钟\",{\"1\":{\"9\":1}}],[\"并且唤醒设备\",{\"1\":{\"4\":1}}],[\"并且对于循环的间隔也更加灵活\",{\"1\":{\"3\":1}}],[\"并且重新生成uri并赋予将要处理该图的第三方app对应权限\",{\"1\":{\"2\":1}}],[\"检测是否已经加载\",{\"1\":{\"272\":1}}],[\"检测是否需要解释为什么需要改权限\",{\"1\":{\"69\":1}}],[\"检测到尚未进行multidexopt\",{\"1\":{\"14\":1}}],[\"检查虚拟机堆参数是否可以调大\",{\"1\":{\"256\":1}}],[\"检查ram\",{\"1\":{\"60\":1}}],[\"检查是否需要拦截\",{\"1\":{\"13\":1}}],[\"体验并不好\",{\"1\":{\"14\":1}}],[\"十分影响体验\",{\"1\":{\"14\":1}}],[\"往往会持续数十秒以上\",{\"1\":{\"14\":1}}],[\"主页面\",{\"1\":{\"399\":1}}],[\"主体中的最后一个\",{\"1\":{\"345\":1}}],[\"主作用域内启动的协程中是没有意义的\",{\"1\":{\"329\":1}}],[\"主内存\",{\"1\":{\"317\":1}}],[\"主轴方向的尺寸作为自己的\",{\"1\":{\"213\":1}}],[\"主动设置\",{\"1\":{\"223\":2}}],[\"主动发送请求到native端\",{\"1\":{\"211\":1}}],[\"主动画\",{\"1\":{\"181\":1}}],[\"主动管理动画\",{\"1\":{\"146\":1}}],[\"主线程\",{\"1\":{\"14\":1}}],[\"主要目的是快速创建出可执行代码\",{\"1\":{\"395\":1}}],[\"主要创建isolate的过程在isolate\",{\"1\":{\"386\":1}}],[\"主要改动如下\",{\"1\":{\"370\":1}}],[\"主要增加了初始化所有url\",{\"1\":{\"370\":1}}],[\"主要群组\",{\"1\":{\"353\":1}}],[\"主要提供使用注解的方法\",{\"1\":{\"300\":1}}],[\"主要加载核心类库\",{\"1\":{\"272\":1}}],[\"主要添加了两项功能\",{\"1\":{\"214\":1}}],[\"主要作用是创建继承自\",{\"1\":{\"213\":1}}],[\"主要作用是创建自定义的\",{\"1\":{\"212\":1}}],[\"主要作为进程间以及同一进程内不同线程之间的同步手段\",{\"1\":{\"58\":1}}],[\"主要涉及类\",{\"1\":{\"362\":1}}],[\"主要涉及三方面\",{\"1\":{\"298\":1}}],[\"主要涉及到以下类\",{\"1\":{\"212\":1}}],[\"主要涉及style自定义以及animationdrawable的使用\",{\"1\":{\"66\":1}}],[\"主要实现通过\",{\"1\":{\"208\":1}}],[\"主要逻辑是创建和更新renderobject\",{\"1\":{\"236\":1}}],[\"主要逻辑是将传入的参数slivers作为list<widget>\",{\"1\":{\"233\":1}}],[\"主要逻辑是分别创建对应的\",{\"1\":{\"228\":1}}],[\"主要逻辑就是创建\",{\"1\":{\"194\":1}}],[\"主要逻辑\",{\"1\":{\"183\":1}}],[\"主要封装了fromhero\",{\"1\":{\"177\":1}}],[\"主要在于\",{\"1\":{\"173\":1}}],[\"主要区别在于不同方法方法创建了不同的\",{\"1\":{\"161\":1}}],[\"主要分为\",{\"1\":{\"147\":1}}],[\"主要分为两大类\",{\"1\":{\"146\":1,\"157\":1}}],[\"主要分为两部分\",{\"1\":{\"32\":1}}],[\"主要有2种方式\",{\"1\":{\"396\":1}}],[\"主要有以下形式\",{\"1\":{\"290\":1}}],[\"主要有两个作用\",{\"1\":{\"213\":1}}],[\"主要有如下用法\",{\"1\":{\"188\":1}}],[\"主要有\",{\"1\":{\"161\":1,\"298\":2}}],[\"主要有三种使用方式\",{\"1\":{\"146\":1,\"157\":1}}],[\"主要有对文件\",{\"1\":{\"111\":1,\"112\":1}}],[\"主要做了2件事\",{\"1\":{\"128\":1}}],[\"主要的作用是持有\",{\"1\":{\"158\":1}}],[\"主要的逻辑都在build方法中\",{\"1\":{\"126\":1}}],[\"主要的逻辑在他的父类align中\",{\"1\":{\"122\":1}}],[\"主要的流程有\",{\"1\":{\"115\":1}}],[\"主要看一下timer\",{\"1\":{\"106\":1}}],[\"主要基于slivergeometry实现布局\",{\"1\":{\"234\":1}}],[\"主要基于size实现布局\",{\"1\":{\"234\":1}}],[\"主要基于\",{\"1\":{\"80\":1,\"212\":2,\"227\":2}}],[\"主要是isolate\",{\"1\":{\"372\":1}}],[\"主要是数据存取\",{\"1\":{\"371\":1}}],[\"主要是通过第三方插件beautifulsoup解析数据\",{\"1\":{\"371\":1}}],[\"主要是通过channel完成\",{\"1\":{\"137\":1}}],[\"主要是将\",{\"1\":{\"215\":1}}],[\"主要是检查入参是否合规\",{\"1\":{\"186\":1}}],[\"主要是提供了操纵\",{\"1\":{\"176\":1}}],[\"主要是提供\",{\"1\":{\"176\":1}}],[\"主要是对官方介绍的理解与分析\",{\"1\":{\"169\":1}}],[\"主要是在一维空间对物理进行位置\",{\"1\":{\"165\":1}}],[\"主要是监听\",{\"1\":{\"146\":1,\"157\":1}}],[\"主要是methodchannel和messagechannel两种\",{\"1\":{\"137\":1}}],[\"主要是修改了\",{\"1\":{\"79\":1}}],[\"主要是为了自己能够在学习的过程中有计划的总结学习到的知识\",{\"1\":{\"0\":1,\"398\":1}}],[\"主要思想是找到系统实现该过程的逻辑\",{\"1\":{\"72\":1}}],[\"主要代码如下\",{\"1\":{\"370\":1}}],[\"主要代码在这里\",{\"1\":{\"111\":1}}],[\"主要代码\",{\"1\":{\"64\":1,\"72\":1}}],[\"主要参考文章\",{\"1\":{\"58\":1}}],[\"主要参考书目\",{\"1\":{\"40\":1}}],[\"主要用在android的intent或线程间通信中\",{\"1\":{\"313\":1}}],[\"主要用在进程的中断控制\",{\"1\":{\"58\":1}}],[\"主要用途是更新\",{\"1\":{\"212\":1}}],[\"主要用于不通机器或跨网络的通信\",{\"1\":{\"58\":1}}],[\"主要用于\",{\"1\":{\"4\":2}}],[\"主要使用到的文件\",{\"1\":{\"43\":1}}],[\"主要流程分为两部分\",{\"1\":{\"13\":1}}],[\"主要讲解一下如何将对外分享的uri赋予读写权限\",{\"1\":{\"2\":1}}],[\"❷标记需要框架自动实例化的对象\",{\"1\":{\"83\":2}}],[\"❷\",{\"1\":{\"14\":1}}],[\"❶标记依赖类的构造方法\",{\"1\":{\"83\":1}}],[\"❶\",{\"1\":{\"14\":1}}],[\"此文对我帮助很大\",{\"1\":{\"419\":1}}],[\"此文为鸿洋博客阅读笔记\",{\"1\":{\"22\":1}}],[\"此电脑\",{\"1\":{\"412\":1}}],[\"此内存区域是唯一一个在java虚拟机规范字没有规定任何oomerror的区域\",{\"1\":{\"255\":1}}],[\"此情况\",{\"1\":{\"226\":1}}],[\"此后还会要求你输入一个本地密码\",{\"1\":{\"347\":1}}],[\"此后再在renderimage\",{\"1\":{\"198\":1}}],[\"此后无需调用就可将同一个ibinder传递给其他客户端\",{\"1\":{\"21\":1}}],[\"此类题的解答思路一般为\",{\"1\":{\"346\":1}}],[\"此类能够实现切换的同时修改\",{\"1\":{\"173\":1}}],[\"此类动画还可以改变duration和curve\",{\"1\":{\"161\":1}}],[\"此类\",{\"1\":{\"146\":2,\"157\":2}}],[\"此方法在scrollablestate中被rawgesturedetector通过\",{\"1\":{\"226\":1}}],[\"此方法在满足\",{\"1\":{\"221\":1}}],[\"此方法的一种使用方式如下\",{\"1\":{\"225\":1}}],[\"此方法是\",{\"1\":{\"223\":1}}],[\"此方法是widgetsflutterbinding的另外一个混合类widgetsbinding负责具体实现\",{\"1\":{\"119\":1}}],[\"此方法不会主动创建\",{\"1\":{\"220\":1}}],[\"此方法返回的是没有使用的\",{\"1\":{\"220\":1}}],[\"此方法会回调powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"此方法会调用imagecache\",{\"1\":{\"196\":1}}],[\"此方法内部执行powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"此方法调用上面registerimageloader方法注册的imageloader获取图片\",{\"1\":{\"211\":1}}],[\"此方法使用一个通用的ui\",{\"1\":{\"210\":1}}],[\"此方法获取的图片会被imageprovider缓存到imagecache中\",{\"1\":{\"201\":1}}],[\"此方法位于sdk\",{\"1\":{\"115\":1}}],[\"此方法传入一个布尔值\",{\"1\":{\"21\":1}}],[\"此处又用到了一次该点\",{\"1\":{\"438\":1}}],[\"此处由于我是将网站放在二级目录\",{\"1\":{\"417\":1}}],[\"此处为0022\",{\"1\":{\"352\":1}}],[\"此处为替代clazz中的findviewbyid\",{\"1\":{\"300\":1}}],[\"此处异常会被catch捕获\",{\"1\":{\"341\":1}}],[\"此处如有异常\",{\"1\":{\"341\":1}}],[\"此处会校验child的类型\",{\"1\":{\"230\":1}}],[\"此处outerdelta\",{\"1\":{\"226\":1}}],[\"此处outerdelta为剩余没有消耗的delta\",{\"1\":{\"226\":1}}],[\"此处的offset是来自于scrollable的scrollposition\",{\"1\":{\"236\":2}}],[\"此处的remainingdelta是未执行的overscroll减去了outer消耗的内容\",{\"1\":{\"226\":1}}],[\"此处的delegate就是我们之前传入的\",{\"1\":{\"226\":1}}],[\"此处的context一般是scrollablestate\",{\"1\":{\"223\":1}}],[\"此处的controller是给tabbar和tabbarview使用的\",{\"1\":{\"212\":1}}],[\"此处错误在release中也会调用fluttererror\",{\"1\":{\"143\":1}}],[\"此处仅做提前展示\",{\"1\":{\"126\":1}}],[\"此处限制execute\",{\"1\":{\"80\":1}}],[\"此处发送msg到mhandler那里接受处理\",{\"1\":{\"80\":1}}],[\"此处创建internalhandler用于在ui线程处理消息\",{\"1\":{\"80\":1}}],[\"此处是tempview类\",{\"1\":{\"55\":1}}],[\"此前开发者只需要应用需要的权限在androidmanifest\",{\"1\":{\"67\":1}}],[\"此布局将在滚动到达这个最小高度的时候折叠\",{\"1\":{\"55\":1}}],[\"此代码同样强制在webview中打开对应的网页\",{\"1\":{\"42\":1}}],[\"此外viewmodel与lifecycle的结合可以保证在activity等生命周期结束后数据得到及时的清理\",{\"1\":{\"402\":1}}],[\"此外可以通过viewmodel在绑定到同一个activity的fragment之间共享数据\",{\"1\":{\"400\":1}}],[\"此外arraymap的api和hashmap类似\",{\"1\":{\"287\":1}}],[\"此外在okhttputils的结构中可以注意到有一个mplatform的变量\",{\"1\":{\"363\":1}}],[\"此外在\",{\"1\":{\"213\":1}}],[\"此外根据贝壳的分析\",{\"1\":{\"203\":1}}],[\"此外比较特殊的是他的\",{\"1\":{\"167\":1}}],[\"此外也可以通过\",{\"1\":{\"157\":1}}],[\"此外还需要有一个专门管理爬虫活动的主类\",{\"1\":{\"371\":1}}],[\"此外还可以写到一些文件中\",{\"1\":{\"360\":1}}],[\"此外还可以看到提供该factory的方法是放到了另外一个抽象类里面然后再导入mainactivitymodule中的\",{\"1\":{\"91\":1}}],[\"此外还持有了\",{\"1\":{\"223\":1}}],[\"此外还提供了一个\",{\"1\":{\"202\":1}}],[\"此外还封装了过渡动画相关的get\",{\"1\":{\"177\":1}}],[\"此外还调用了\",{\"1\":{\"148\":1}}],[\"此外还有一个抽象方法\",{\"1\":{\"364\":1}}],[\"此外还有一种用来传输数据的widget\",{\"1\":{\"128\":1}}],[\"此外还有包含了数据的对象大小计算方式如下\",{\"1\":{\"282\":1}}],[\"此外还有\",{\"1\":{\"174\":1}}],[\"此外还有美团的多渠道打包技术等\",{\"1\":{\"54\":1}}],[\"此外两个关系为\",{\"1\":{\"87\":1}}],[\"此外子进程中的过渡activity也只用到了基本的类\",{\"1\":{\"14\":1}}],[\"此外\",{\"1\":{\"14\":1,\"20\":1,\"31\":1,\"36\":1,\"52\":1,\"78\":1,\"87\":1,\"121\":1,\"174\":1,\"195\":1,\"197\":1,\"202\":2,\"211\":1,\"237\":1,\"254\":1,\"282\":1,\"287\":2,\"306\":1,\"313\":1,\"387\":1,\"392\":1,\"402\":1,\"403\":1}}],[\"此时已经有足够的信息让runtime用来调用方法\",{\"1\":{\"394\":1}}],[\"此时这里返回null\",{\"1\":{\"389\":1}}],[\"此时反序列化时\",{\"1\":{\"307\":1}}],[\"此时t2获取到的是一个没有执行构造方法的asingleton对象\",{\"1\":{\"294\":1}}],[\"此时t1尚未执行tag2\",{\"1\":{\"294\":1}}],[\"此时由于as已经分配了内存不为null\",{\"1\":{\"294\":1}}],[\"此时由编译器或其它连接程序实现\",{\"1\":{\"273\":1}}],[\"此时as已经被赋予了对象\",{\"1\":{\"294\":1}}],[\"此时可以在上面例子的基础上增加intrinsicheight\",{\"1\":{\"242\":1}}],[\"此时singlechildscrollview的child尺寸大于父级尺寸\",{\"1\":{\"241\":1}}],[\"此时service类的\",{\"1\":{\"85\":1}}],[\"此时overscroll为0\",{\"1\":{\"220\":1}}],[\"此时overscroll偏移量为pixels\",{\"1\":{\"220\":1}}],[\"此时max为pixels表示不能继续滑动超出此值\",{\"1\":{\"220\":1}}],[\"此时会检测大小和数量\",{\"1\":{\"198\":2}}],[\"此时\",{\"1\":{\"173\":2,\"198\":1,\"220\":3,\"394\":1,\"419\":1}}],[\"此时view已经初始化完毕\",{\"1\":{\"65\":1}}],[\"此时如果有进程2等待sv而挂起\",{\"1\":{\"58\":1}}],[\"此时intent是null\",{\"1\":{\"17\":1}}],[\"此时需要添加multidex依赖\",{\"1\":{\"14\":1}}],[\"此时点击事件从activity转到了viewgroup中\",{\"1\":{\"13\":1}}],[\"方便我们建立简单的网页来介绍项目\",{\"1\":{\"405\":1}}],[\"方便指导日后对jetpack的使用\",{\"1\":{\"399\":1}}],[\"方便同时输出多个文档\",{\"1\":{\"370\":1}}],[\"方便复制\",{\"1\":{\"321\":1}}],[\"方便保存\",{\"1\":{\"296\":1}}],[\"方便接收其转发的事件\",{\"1\":{\"224\":1}}],[\"方便后续操作\",{\"1\":{\"48\":1}}],[\"方案在\",{\"1\":{\"211\":1}}],[\"方案则只有图片获取在\",{\"1\":{\"211\":1}}],[\"方案实际使用\",{\"1\":{\"211\":1}}],[\"方案\",{\"1\":{\"211\":2}}],[\"方案创建的\",{\"1\":{\"211\":1}}],[\"方案采用的\",{\"1\":{\"211\":1}}],[\"方案时\",{\"1\":{\"207\":2}}],[\"方案2中在过渡activity的后台线程进行multidexopt操作思路是正确的\",{\"1\":{\"14\":1}}],[\"方式2\",{\"1\":{\"288\":2}}],[\"方式1\",{\"1\":{\"288\":2}}],[\"方式❷\",{\"1\":{\"14\":1,\"84\":1}}],[\"方式❶\",{\"1\":{\"14\":1,\"84\":1}}],[\"方法清除这些数据以避免内存泄漏\",{\"1\":{\"402\":1}}],[\"方法等信息\",{\"1\":{\"396\":1}}],[\"方法开启循环\",{\"1\":{\"391\":1}}],[\"方法初始化各个变量\",{\"1\":{\"371\":1}}],[\"方法初始化dialog样式\",{\"1\":{\"66\":1}}],[\"方法生成output目录\",{\"1\":{\"370\":1}}],[\"方法增加一个file\",{\"1\":{\"370\":1}}],[\"方法修改如下\",{\"1\":{\"370\":1}}],[\"方法产生request\",{\"1\":{\"365\":1}}],[\"方法名\",{\"1\":{\"321\":1}}],[\"方法一直返回any\",{\"1\":{\"322\":1}}],[\"方法一节已经涉及到了\",{\"1\":{\"309\":1}}],[\"方法一致返回\",{\"1\":{\"167\":1}}],[\"方法分别不能与defaultwriteobject\",{\"1\":{\"306\":1}}],[\"方法来将序列化得到的对象初始化到正确的状态\",{\"1\":{\"306\":1}}],[\"方法来检索ibinder\",{\"1\":{\"21\":1}}],[\"方法进行处理以达到目的\",{\"1\":{\"298\":1}}],[\"方法则会唤醒所有在等待池中的线程\",{\"1\":{\"297\":1}}],[\"方法释放掉该对象的锁进入阻塞后\",{\"1\":{\"297\":1}}],[\"方法挂起当前线程\",{\"1\":{\"297\":1}}],[\"方法使当前线程阻塞\",{\"1\":{\"297\":1}}],[\"方法使用\",{\"1\":{\"168\":1,\"192\":1}}],[\"方法重载等时就使用枚举\",{\"1\":{\"286\":1}}],[\"方法重新进行lay\",{\"1\":{\"237\":1}}],[\"方法无需调用父类接口的clinit\",{\"1\":{\"279\":1}}],[\"方法无论类是否重写了hashcode\",{\"1\":{\"49\":1}}],[\"方法时才会执行init方法\",{\"1\":{\"279\":1}}],[\"方法时\",{\"1\":{\"279\":1}}],[\"方法时丢弃掉这些数据\",{\"1\":{\"44\":1}}],[\"方法和变量的这种后期绑定\",{\"1\":{\"278\":1}}],[\"方法以及调用过\",{\"1\":{\"266\":1}}],[\"方法以规范对\",{\"1\":{\"186\":1}}],[\"方法尝试\",{\"1\":{\"258\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"263\":1}}],[\"方法区中的类静态属性引用的对象\",{\"1\":{\"263\":1}}],[\"方法区溢出\",{\"0\":{\"259\":1}}],[\"方法区\",{\"1\":{\"254\":1}}],[\"方法出口等\",{\"1\":{\"252\":1}}],[\"方法顾名思义\",{\"1\":{\"228\":1}}],[\"方法只会被调用一次\",{\"1\":{\"266\":1}}],[\"方法只会使用httpclient从网络中下载图片并返回\",{\"1\":{\"201\":1}}],[\"方法只能返回\",{\"1\":{\"227\":1}}],[\"方法内部执行了delegate\",{\"1\":{\"226\":1}}],[\"方法内部对mfirsttouchtarget进行更新\",{\"1\":{\"13\":1}}],[\"方法更新的值或者null\",{\"1\":{\"325\":1}}],[\"方法更新\",{\"1\":{\"213\":1}}],[\"方法更新widget\",{\"1\":{\"155\":1}}],[\"方法被调用时通过\",{\"1\":{\"213\":1}}],[\"方法请求加载图片\",{\"1\":{\"211\":1}}],[\"方法正是调用他们获取图片\",{\"1\":{\"211\":1}}],[\"方法或者powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"方法才是真正使用httpclient从网上获取图片资源的方法\",{\"1\":{\"196\":1}}],[\"方法通过canvas\",{\"1\":{\"198\":1}}],[\"方法通过\",{\"1\":{\"190\":1}}],[\"方法通知子类\",{\"1\":{\"148\":1}}],[\"方法而非\",{\"1\":{\"184\":1}}],[\"方法类似\",{\"1\":{\"183\":1}}],[\"方法之前\",{\"1\":{\"226\":1}}],[\"方法之外\",{\"1\":{\"182\":1}}],[\"方法之后\",{\"1\":{\"128\":1}}],[\"方法与之绑定\",{\"1\":{\"178\":1}}],[\"方法与io\",{\"1\":{\"111\":1}}],[\"方法主要是创建一个不存在于\",{\"1\":{\"378\":1}}],[\"方法主要作用是异步执行\",{\"1\":{\"216\":1}}],[\"方法主要影响的是\",{\"1\":{\"176\":1}}],[\"方法主要也是用来触发\",{\"1\":{\"100\":1}}],[\"方法供\",{\"1\":{\"175\":1}}],[\"方法监听\",{\"1\":{\"162\":1}}],[\"方法是用来将apk等中的资源添加到assetmanager中\",{\"1\":{\"427\":1}}],[\"方法是抽象方法\",{\"1\":{\"233\":1}}],[\"方法是位于\",{\"1\":{\"195\":1}}],[\"方法是其实现动画的基石\",{\"1\":{\"162\":1}}],[\"方法是通过ipc获取到activitymanager的引用\",{\"1\":{\"58\":1}}],[\"方法计算对应的属性并展示\",{\"1\":{\"152\":1}}],[\"方法即可\",{\"1\":{\"152\":1,\"159\":1,\"196\":1}}],[\"方法实现的单例也会遭受到攻击\",{\"1\":{\"305\":1}}],[\"方法实现滑动效果\",{\"1\":{\"229\":1}}],[\"方法实现如下\",{\"1\":{\"196\":1}}],[\"方法实现\",{\"1\":{\"161\":2,\"184\":1,\"325\":1}}],[\"方法实现和statelesswidget中的方法类似\",{\"1\":{\"134\":1}}],[\"方法实现是view的内容滑动的效果\",{\"1\":{\"41\":1}}],[\"方法还会将当前element标记为dirty\",{\"1\":{\"128\":1}}],[\"方法执行后的流程图\",{\"1\":{\"128\":1}}],[\"方法因各个element的实现而异\",{\"1\":{\"128\":1}}],[\"方法插入到渲染树中\",{\"1\":{\"122\":1}}],[\"方法最后一个参数是lambda表达式时\",{\"1\":{\"345\":1}}],[\"方法最后调用了attachrootwidget\",{\"1\":{\"119\":1}}],[\"方法最后再这里调用了ioservice\",{\"1\":{\"114\":1}}],[\"方法最终通过schedulerbinding\",{\"1\":{\"162\":1}}],[\"方法最终通过sendmessageattime\",{\"1\":{\"31\":1}}],[\"方法最终会调用sendmessageattime\",{\"1\":{\"28\":1}}],[\"方法创建了新的isolate\",{\"1\":{\"378\":1}}],[\"方法创建request\",{\"1\":{\"364\":1}}],[\"方法创建\",{\"1\":{\"208\":1}}],[\"方法创建的是\",{\"1\":{\"223\":1}}],[\"方法创建的\",{\"1\":{\"114\":1,\"213\":1}}],[\"方法创建looper对象\",{\"1\":{\"24\":1}}],[\"方法异步读取文件\",{\"1\":{\"111\":1}}],[\"方法发送\",{\"1\":{\"106\":1}}],[\"方法携带targetintent\",{\"1\":{\"72\":1}}],[\"方法获取枚举对象实例\",{\"1\":{\"321\":1}}],[\"方法获取全部\",{\"1\":{\"295\":1}}],[\"方法获取全部公有变量\",{\"1\":{\"295\":1}}],[\"方法获取\",{\"1\":{\"198\":1}}],[\"方法获取的实际是network\",{\"1\":{\"196\":1}}],[\"方法获取对应的值\",{\"1\":{\"184\":1}}],[\"方法获取animation对应的值\",{\"1\":{\"183\":1}}],[\"方法获取并显示最新的属性\",{\"1\":{\"148\":1}}],[\"方法获取到\",{\"1\":{\"94\":1,\"178\":1}}],[\"方法获取宽高\",{\"1\":{\"65\":1}}],[\"方法获取保存的looper对象并由此获取到messagequeue对象\",{\"1\":{\"25\":1}}],[\"方法设置了view宽\",{\"1\":{\"65\":1}}],[\"方法调用了join\",{\"1\":{\"297\":1}}],[\"方法调用imageprovider\",{\"1\":{\"196\":1}}],[\"方法调用onmeasure\",{\"1\":{\"65\":1}}],[\"方法调用sendmessageattime\",{\"1\":{\"31\":1}}],[\"方法2\",{\"0\":{\"63\":1}}],[\"方法1\",{\"0\":{\"62\":1}}],[\"方法为例\",{\"1\":{\"61\":1}}],[\"方法返回未使用的\",{\"1\":{\"222\":1}}],[\"方法返回图片请求结果\",{\"1\":{\"211\":1}}],[\"方法返回null\",{\"1\":{\"143\":1}}],[\"方法返回\",{\"1\":{\"58\":1}}],[\"方法也会先使用indexofkey\",{\"1\":{\"52\":1}}],[\"方法就比较简单了\",{\"1\":{\"51\":1}}],[\"方法我们在之前的文章中介绍过\",{\"1\":{\"43\":1}}],[\"方法会调用okhttprequestbuilder对象的generaterequest\",{\"1\":{\"365\":1}}],[\"方法会生成requestcall对象\",{\"1\":{\"365\":1}}],[\"方法会在通道缓存满的时候挂起调用方\",{\"1\":{\"334\":1}}],[\"方法会在looper\",{\"1\":{\"29\":1}}],[\"方法会从等待池中唤醒一个指定线程\",{\"1\":{\"297\":1}}],[\"方法会先于子类执行\",{\"1\":{\"279\":1}}],[\"方法会先用二分法查找hash对应的index\",{\"1\":{\"49\":1}}],[\"方法会使用他所处\",{\"1\":{\"213\":1}}],[\"方法会创建一个\",{\"1\":{\"149\":1}}],[\"方法会创建一个messengerimpl对象\",{\"1\":{\"43\":1}}],[\"方法会触发widget的rebuild\",{\"1\":{\"128\":1}}],[\"方法会将path切断\",{\"1\":{\"63\":1}}],[\"方法会\",{\"1\":{\"58\":1}}],[\"方法可以解除private\",{\"1\":{\"295\":1}}],[\"方法可以停止动画\",{\"1\":{\"168\":1}}],[\"方法可以自动判断是否需要反向并修改方向\",{\"1\":{\"167\":1}}],[\"方法可以创建一个新的将传入的\",{\"1\":{\"158\":1}}],[\"方法可以实现平滑的滑动\",{\"1\":{\"41\":1}}],[\"方法可以使用任意时间\",{\"1\":{\"6\":1}}],[\"方法的注意事项\",{\"1\":{\"254\":1}}],[\"方法的实现\",{\"1\":{\"106\":1}}],[\"方法的标志\",{\"1\":{\"40\":1}}],[\"方法的返回值意义如下\",{\"1\":{\"17\":1}}],[\"方法运行的线程\",{\"1\":{\"36\":1}}],[\"方法回调handler中的msg处理方法\",{\"1\":{\"31\":1}}],[\"方法将ui\",{\"1\":{\"198\":1}}],[\"方法将\",{\"1\":{\"186\":1,\"213\":1}}],[\"方法将当前element标记为dirty\",{\"1\":{\"128\":1}}],[\"方法将nmh放到线程池中运行\",{\"1\":{\"115\":2}}],[\"方法将timer添加到heap或者timer\",{\"1\":{\"106\":1}}],[\"方法将它们传递给服务端\",{\"1\":{\"40\":1}}],[\"方法将runnable赋予msg\",{\"1\":{\"31\":1}}],[\"方法将r赋予msg\",{\"1\":{\"30\":1}}],[\"方法将msg压入到messagequeue中\",{\"1\":{\"31\":1}}],[\"方法将msg压入messagequeue中\",{\"1\":{\"30\":1,\"31\":1}}],[\"方法接收binder\",{\"1\":{\"19\":1}}],[\"方法启动service的时候都会被调用\",{\"1\":{\"17\":1}}],[\"方法中webbrowser\",{\"1\":{\"367\":1}}],[\"方法中主动保存了部分数据\",{\"1\":{\"280\":1}}],[\"方法中自救一次\",{\"1\":{\"266\":1}}],[\"方法中会检验\",{\"1\":{\"230\":1}}],[\"方法中初始化\",{\"1\":{\"213\":1}}],[\"方法中使用\",{\"1\":{\"211\":1}}],[\"方法中以用来获取\",{\"1\":{\"188\":1}}],[\"方法中实时创建\",{\"1\":{\"184\":1}}],[\"方法中真正执行\",{\"1\":{\"181\":1}}],[\"方法中创建的\",{\"1\":{\"213\":1}}],[\"方法中创建\",{\"1\":{\"178\":1}}],[\"方法中创建looper及messagequeue对象并保存在sthreadlocal中\",{\"1\":{\"31\":1}}],[\"方法中可以使用\",{\"1\":{\"168\":1}}],[\"方法中可以使用publishprogress\",{\"1\":{\"80\":1}}],[\"方法中除了\",{\"1\":{\"166\":1}}],[\"方法中将\",{\"1\":{\"112\":1,\"219\":1}}],[\"方法中传入当前application的依赖\",{\"1\":{\"92\":1}}],[\"方法中执行\",{\"1\":{\"81\":1,\"107\":1,\"115\":1}}],[\"方法中调用并返回defineclass\",{\"1\":{\"272\":1}}],[\"方法中调用原生的图片加载库获取\",{\"1\":{\"211\":1}}],[\"方法中调用了material的runapp\",{\"1\":{\"132\":1}}],[\"方法中调用publishprogress\",{\"1\":{\"80\":1}}],[\"方法中调用对应方法\",{\"1\":{\"69\":1}}],[\"方法中为\",{\"1\":{\"79\":1}}],[\"方法中返回\",{\"1\":{\"68\":1}}],[\"方法中绘制对应的path\",{\"1\":{\"63\":1}}],[\"方法中被传入到iactivitymanager的publishservice方法中\",{\"1\":{\"58\":1}}],[\"方法中通过\",{\"1\":{\"168\":1}}],[\"方法中通过返回值告知\",{\"1\":{\"55\":1}}],[\"方法中通过mylooper\",{\"1\":{\"31\":1}}],[\"方法中做验证\",{\"1\":{\"39\":1}}],[\"方法中进行dex文件合并优化等耗时操作\",{\"1\":{\"14\":1}}],[\"方法中\",{\"1\":{\"13\":1,\"20\":1,\"43\":1,\"65\":1,\"121\":1,\"128\":1,\"186\":1,\"193\":1,\"205\":1,\"211\":1,\"213\":1,\"226\":1,\"227\":1,\"228\":1,\"235\":1,\"312\":1}}],[\"方法中设置的视图\",{\"1\":{\"13\":1}}],[\"方法如下\",{\"1\":{\"13\":1}}],[\"方法判断是否需要拦截\",{\"1\":{\"13\":2}}],[\"方法\",{\"1\":{\"13\":8,\"14\":1,\"17\":1,\"26\":1,\"28\":2,\"29\":1,\"40\":1,\"41\":1,\"43\":2,\"44\":1,\"49\":1,\"54\":2,\"55\":1,\"56\":2,\"63\":1,\"64\":2,\"65\":6,\"78\":1,\"79\":1,\"80\":6,\"106\":1,\"111\":1,\"118\":1,\"121\":1,\"127\":1,\"128\":9,\"132\":2,\"133\":1,\"134\":1,\"148\":1,\"149\":1,\"150\":1,\"152\":1,\"153\":1,\"161\":1,\"162\":1,\"168\":2,\"179\":1,\"182\":1,\"184\":2,\"186\":2,\"196\":1,\"211\":3,\"212\":1,\"223\":2,\"226\":3,\"227\":2,\"230\":1,\"237\":1,\"239\":1,\"254\":1,\"266\":1,\"279\":4,\"282\":1,\"288\":3,\"295\":6,\"297\":2,\"298\":1,\"300\":1,\"305\":2,\"306\":1,\"321\":1,\"365\":1,\"370\":2,\"378\":1,\"389\":2,\"391\":1}}],[\"再对其进行归并\",{\"1\":{\"459\":1}}],[\"再以983为新节点\",{\"1\":{\"458\":1}}],[\"再以父节点作为新插入的点n\",{\"1\":{\"458\":1}}],[\"再以toindex为起点向下比较\",{\"1\":{\"441\":1}}],[\"再依次向下遍历\",{\"1\":{\"441\":1}}],[\"再遍历下一条\",{\"1\":{\"437\":1}}],[\"再哈希法比二次探测好\",{\"1\":{\"428\":1}}],[\"再哈希法\",{\"1\":{\"428\":2}}],[\"再通过其获取到resources对象\",{\"1\":{\"427\":1}}],[\"再通过反射获取对应的资源id及资源\",{\"1\":{\"420\":1}}],[\"再通过sharedpreferences保存在手机端\",{\"1\":{\"296\":1}}],[\"再到自己开始尝试搭建博客\",{\"1\":{\"408\":1}}],[\"再判断是否有热点代码需要优化\",{\"1\":{\"396\":1}}],[\"再回退到a阶段执行代码\",{\"1\":{\"394\":1}}],[\"再次减小排序\",{\"1\":{\"462\":1}}],[\"再次分别循环分析左右两个子树的结构\",{\"1\":{\"346\":1}}],[\"再次postinvalidate\",{\"1\":{\"41\":1}}],[\"再根节点\",{\"1\":{\"346\":1}}],[\"再根子树\",{\"1\":{\"346\":1}}],[\"再根据yyyy表示的是week\",{\"1\":{\"302\":1}}],[\"再根据下面的\",{\"1\":{\"207\":1}}],[\"再右子树\",{\"1\":{\"346\":2}}],[\"再左子树\",{\"1\":{\"346\":1}}],[\"再执行\",{\"1\":{\"418\":1}}],[\"再执行collect等方法\",{\"1\":{\"340\":1}}],[\"再执行另外一个\",{\"1\":{\"95\":1}}],[\"再同时收集结果流\",{\"1\":{\"340\":1}}],[\"再去访问其邻接点的所有可以访问邻接点\",{\"1\":{\"438\":1}}],[\"再去请求下一个流\",{\"1\":{\"340\":1}}],[\"再去更新state刷新ui\",{\"1\":{\"136\":1}}],[\"再比如下面这个示例中的2010\",{\"1\":{\"302\":1}}],[\"再调用不同的方法对这些变量\",{\"1\":{\"298\":1}}],[\"再将增量n减一\",{\"1\":{\"460\":1}}],[\"再将bottom移动到柱子c即可\",{\"1\":{\"459\":1}}],[\"再将a\",{\"1\":{\"455\":1}}],[\"再将a与下一个有序元素进行比较\",{\"1\":{\"289\":1}}],[\"再将数组最后一个节点\",{\"1\":{\"441\":1}}],[\"再将其部署到github上面对应的user\",{\"1\":{\"405\":1}}],[\"再将滑动分配给\",{\"1\":{\"226\":1}}],[\"再结合官方的描述\",{\"1\":{\"287\":1}}],[\"再从3\",{\"1\":{\"272\":1}}],[\"再为新的offset添加监听\",{\"1\":{\"237\":1}}],[\"再尝试将\",{\"1\":{\"226\":1}}],[\"再加上一个前序排序\",{\"1\":{\"346\":1}}],[\"再加上在64位jvm中\",{\"1\":{\"283\":1}}],[\"再加上8比特对齐\",{\"1\":{\"282\":1}}],[\"再加上\",{\"1\":{\"213\":1}}],[\"再变为正方形\",{\"1\":{\"173\":1}}],[\"再来看一下dart\",{\"1\":{\"115\":1}}],[\"再来看看我们写的对应的aidl文件\",{\"1\":{\"58\":1}}],[\"再来看看一个完整的流程\",{\"1\":{\"58\":1}}],[\"再仔细看一下thread\",{\"1\":{\"80\":1}}],[\"再查下去\",{\"1\":{\"80\":1}}],[\"再讲proxyintent恢复为targetintent\",{\"1\":{\"70\":1}}],[\"再决定如何申请权限requestpermissions\",{\"1\":{\"68\":1}}],[\"再绘制对应坐标\",{\"1\":{\"63\":1}}],[\"再在顶部绘制src与dst重合的部分\",{\"1\":{\"57\":1}}],[\"再在顶部绘制dst与src重合的部分\",{\"1\":{\"57\":1}}],[\"再看一下创建isolate的具体方法\",{\"1\":{\"383\":1}}],[\"再看一下\",{\"1\":{\"183\":1}}],[\"再看一下dart\",{\"1\":{\"115\":1}}],[\"再看一下internalhandler类\",{\"1\":{\"80\":1}}],[\"再看一眼上述的公式\",{\"1\":{\"53\":1}}],[\"再看futuretask\",{\"1\":{\"80\":1}}],[\"再看看android提供的android\",{\"1\":{\"287\":1}}],[\"再看看内部类outclass$1\",{\"1\":{\"281\":1}}],[\"再看看serialexecutor这个线程池\",{\"1\":{\"80\":1}}],[\"再看看messenger客户端的实现\",{\"1\":{\"43\":1}}],[\"再看看getimessenger\",{\"1\":{\"43\":1}}],[\"再看看phonewindow\",{\"1\":{\"13\":1}}],[\"再向前查询是否有相同的key\",{\"1\":{\"49\":1}}],[\"再逐层分发到view中\",{\"1\":{\"13\":1}}],[\"经验\",{\"1\":{\"398\":1}}],[\"经验总结放到这里\",{\"1\":{\"0\":1}}],[\"经典的使用分为3步\",{\"1\":{\"362\":1}}],[\"经典的使用方式\",{\"1\":{\"212\":1}}],[\"经常动态生成大量class的应用\",{\"1\":{\"259\":1}}],[\"经历几次gc\",{\"1\":{\"250\":2}}],[\"经过包装再返回到调用方\",{\"1\":{\"377\":1}}],[\"经过umask\",{\"1\":{\"352\":1}}],[\"经过8\",{\"1\":{\"282\":1}}],[\"经过上面的分析\",{\"1\":{\"181\":1}}],[\"经过上述检查\",{\"1\":{\"228\":1}}],[\"经过上述代码\",{\"1\":{\"178\":1}}],[\"经过上述分析可以知道\",{\"1\":{\"198\":1}}],[\"经过上述分析\",{\"1\":{\"168\":1,\"186\":1}}],[\"经过phonewindow\",{\"1\":{\"13\":1}}],[\"可变参数\",{\"1\":{\"369\":1}}],[\"可传达\",{\"1\":{\"334\":1}}],[\"可重入代码\",{\"1\":{\"320\":1}}],[\"可达标记存活\",{\"1\":{\"263\":1}}],[\"可视为一个特殊的\",{\"1\":{\"171\":1}}],[\"可能导致某些设置有误\",{\"1\":{\"418\":1}}],[\"可能导致ui卡顿等情况\",{\"1\":{\"95\":1}}],[\"可能没法处理部分情况\",{\"1\":{\"396\":1}}],[\"可能需要执行依赖于相应流的最新值的计算\",{\"1\":{\"327\":1}}],[\"可能被虚拟机忽略\",{\"1\":{\"298\":1}}],[\"可能会产生逆序和环形链表\",{\"1\":{\"280\":1}}],[\"可能会通过折叠展开等方式改变尺寸时\",{\"1\":{\"232\":1}}],[\"可能会显得有些臃肿\",{\"1\":{\"202\":1}}],[\"可能在准确性上犯错\",{\"1\":{\"396\":1}}],[\"可能在用到asingleton类的时候\",{\"1\":{\"294\":1}}],[\"可能在\",{\"1\":{\"220\":1}}],[\"可能是最通俗易懂的自动发布博客图文教程\",{\"1\":{\"407\":1}}],[\"可能是\",{\"1\":{\"197\":2}}],[\"可能是线性变化\",{\"1\":{\"186\":1}}],[\"可能同时在\",{\"1\":{\"197\":1}}],[\"可能可能同时也是\",{\"1\":{\"197\":1}}],[\"可能修改\",{\"1\":{\"153\":1}}],[\"可能有虚拟按键的情况\",{\"1\":{\"81\":1}}],[\"可知\",{\"1\":{\"81\":1}}],[\"可知mremote便是指向ams服务的binderproxy对象\",{\"1\":{\"58\":1}}],[\"可见是直接取的当前线程对应的isolate对应的值\",{\"1\":{\"377\":1}}],[\"可见性\",{\"1\":{\"317\":2}}],[\"可见处理offset以便更新content实现滑动效果的主要逻辑在\",{\"1\":{\"236\":1}}],[\"可见的\",{\"1\":{\"233\":1}}],[\"可见在计算\",{\"1\":{\"225\":1}}],[\"可见对于ffi和texture方案\",{\"1\":{\"211\":1}}],[\"可见\",{\"1\":{\"55\":1,\"80\":1,\"108\":1,\"223\":1,\"230\":1,\"379\":1}}],[\"可见view的dispatchtouchevent\",{\"1\":{\"13\":1}}],[\"可选\",{\"1\":{\"43\":2,\"57\":1,\"152\":1,\"156\":1,\"279\":1,\"367\":2,\"408\":1,\"409\":1}}],[\"可以选取数组第一个或者最后一个元素\",{\"1\":{\"466\":1}}],[\"可以选择使用\",{\"1\":{\"154\":1}}],[\"可以想象\",{\"1\":{\"461\":1}}],[\"可以指向数组开始位置\",{\"1\":{\"452\":1}}],[\"可以指定一个\",{\"1\":{\"202\":1}}],[\"可以进行压入push和推出pop操作\",{\"1\":{\"452\":1}}],[\"可以进行堆排序\",{\"1\":{\"442\":1}}],[\"可以让云服务器代替我们实现hexo创建以及同步github等步骤\",{\"1\":{\"405\":1}}],[\"可以让开发者在flutter中快速开发出一个精美的app\",{\"1\":{\"117\":1}}],[\"可以提供对表格的操作方法\",{\"1\":{\"403\":1}}],[\"可以帮助我们很好地学习jetpack以及mvvm思想\",{\"1\":{\"399\":1}}],[\"可以满足客户端需求\",{\"1\":{\"370\":1}}],[\"可以爬取gityuan\",{\"1\":{\"370\":1}}],[\"可以传入dict\",{\"1\":{\"369\":1}}],[\"可以输入list\",{\"1\":{\"369\":1}}],[\"可以输出key的值\",{\"1\":{\"358\":1}}],[\"可以输出到文件\",{\"1\":{\"303\":1}}],[\"可以return\",{\"1\":{\"369\":1}}],[\"可以没有return\",{\"1\":{\"369\":1}}],[\"可以和xx\",{\"1\":{\"345\":1}}],[\"可以很好的替代匿名内部类\",{\"1\":{\"345\":1}}],[\"可以放到\",{\"1\":{\"345\":1}}],[\"可以放弃等待\",{\"1\":{\"318\":1}}],[\"可以添加\",{\"1\":{\"342\":1}}],[\"可以允许为空\",{\"1\":{\"334\":1}}],[\"可以调用非局部返回\",{\"1\":{\"322\":1}}],[\"可以拦截赋值操作\",{\"1\":{\"322\":1}}],[\"可以安全读取\",{\"1\":{\"322\":1}}],[\"可以安全的应用\",{\"1\":{\"292\":1}}],[\"可以有两种操作\",{\"1\":{\"458\":1}}],[\"可以有方法\",{\"1\":{\"321\":1}}],[\"可以有一个比较完美的解决方案\",{\"1\":{\"14\":1}}],[\"可以自定义一个classname\",{\"1\":{\"321\":1}}],[\"可以自定义要参与到序列化与反序列化的变量\",{\"1\":{\"313\":1}}],[\"可以先对其进行忙循环\",{\"1\":{\"320\":1}}],[\"可以持久化保存\",{\"1\":{\"310\":1}}],[\"可以手动指定\",{\"1\":{\"304\":1}}],[\"可以这么想\",{\"1\":{\"292\":1}}],[\"可以合法的指向一个list<\",{\"1\":{\"292\":1}}],[\"可以参考下文\",{\"1\":{\"286\":1}}],[\"可以参考文章\",{\"1\":{\"282\":1}}],[\"可以参考stackoverflow的这个回答\",{\"1\":{\"282\":1}}],[\"可以参考这篇文章\",{\"1\":{\"282\":1,\"303\":1}}],[\"可以参照这张图\",{\"1\":{\"282\":1}}],[\"可以省略参数\",{\"1\":{\"345\":1}}],[\"可以省略\",{\"1\":{\"281\":1}}],[\"可以增加负载因子loadfactor的值\",{\"1\":{\"280\":1}}],[\"可以回收\",{\"1\":{\"266\":1}}],[\"可以用来定义用户从不同的界面切换\",{\"1\":{\"400\":1}}],[\"可以用来打开service\",{\"1\":{\"7\":1}}],[\"可以用pass当做占位符\",{\"1\":{\"369\":1}}],[\"可以用$key\",{\"1\":{\"358\":1}}],[\"可以用于确定流收集是正常完成\",{\"1\":{\"343\":1}}],[\"可以用buffer\",{\"1\":{\"327\":1}}],[\"可以用如下命令\",{\"1\":{\"282\":1}}],[\"可以用try\",{\"1\":{\"266\":1}}],[\"可以用string\",{\"1\":{\"258\":1}}],[\"可以定位到内存中的\",{\"1\":{\"254\":1}}],[\"可以创建\",{\"1\":{\"227\":1}}],[\"可以产生的线程数就会越少\",{\"1\":{\"257\":1}}],[\"可以产生\",{\"1\":{\"226\":1}}],[\"可以识别手势\",{\"1\":{\"223\":1}}],[\"可以推迟或者影响\",{\"1\":{\"217\":1}}],[\"可以监听\",{\"1\":{\"213\":1}}],[\"可以知道\",{\"1\":{\"207\":1,\"302\":1}}],[\"可以分为三种\",{\"1\":{\"430\":1}}],[\"可以分为两大类\",{\"1\":{\"212\":1,\"227\":1,\"234\":1}}],[\"可以分为下面这几种情况\",{\"1\":{\"126\":1}}],[\"可以分别使用maximumsize和maximumsizebytes修改配置\",{\"1\":{\"197\":1}}],[\"可以直接引用该方法\",{\"1\":{\"345\":1}}],[\"可以直接用类名\",{\"1\":{\"321\":1}}],[\"可以直接传入canvas\",{\"1\":{\"194\":1}}],[\"可以直接展示ui\",{\"1\":{\"194\":1}}],[\"可以降低负载因子load\",{\"1\":{\"280\":1}}],[\"可以降低\",{\"1\":{\"188\":1}}],[\"可以返回一个新的\",{\"1\":{\"186\":1}}],[\"可以此方法作用是结合两个\",{\"1\":{\"183\":1}}],[\"可以按照给定的\",{\"1\":{\"182\":1}}],[\"可以按照以下顺序选择实现方式\",{\"1\":{\"156\":1}}],[\"可以等比例缩放\",{\"1\":{\"174\":1}}],[\"可以实现下面的方法\",{\"1\":{\"306\":1}}],[\"可以实现由圆变为正方形的过渡动画\",{\"1\":{\"172\":1}}],[\"可以实现此方法\",{\"1\":{\"152\":1}}],[\"可以被用来替代\",{\"1\":{\"332\":1}}],[\"可以被用于这些目的\",{\"1\":{\"331\":1}}],[\"可以被组合起来创建各种\",{\"1\":{\"227\":1}}],[\"可以被独立管理\",{\"1\":{\"171\":1}}],[\"可以被客户端通过ibinder获取实例调用\",{\"1\":{\"19\":1}}],[\"可以组合多个\",{\"1\":{\"159\":1}}],[\"可以为传入的\",{\"1\":{\"159\":1}}],[\"可以与\",{\"1\":{\"157\":1}}],[\"可以考虑使用custompainter自己绘制动画\",{\"1\":{\"156\":1}}],[\"可以考虑使用isolates利用cpu多核心处理任务\",{\"1\":{\"136\":1}}],[\"可以考虑进一步自定义实现隐式动画\",{\"1\":{\"156\":1}}],[\"可以开始动画\",{\"1\":{\"149\":1}}],[\"可以开始调用服务的一系列方法\",{\"1\":{\"37\":1}}],[\"可以大体分为\",{\"1\":{\"146\":1}}],[\"可以依次考虑\",{\"1\":{\"146\":1,\"157\":1}}],[\"可以类比为android中的thread\",{\"1\":{\"145\":1}}],[\"可以预先缓存final\",{\"1\":{\"144\":1}}],[\"可以重写\",{\"1\":{\"138\":1}}],[\"可以称之为隧道\",{\"1\":{\"137\":1}}],[\"可以使用循环队列解决伪溢出问题\",{\"1\":{\"452\":1}}],[\"可以使用isolategroup来解决\",{\"1\":{\"372\":1}}],[\"可以使用imagecache\",{\"1\":{\"197\":1}}],[\"可以使用source\",{\"1\":{\"361\":1}}],[\"可以使用sync\",{\"1\":{\"136\":1}}],[\"可以使用命令\",{\"1\":{\"347\":2}}],[\"可以使用操作符转换流\",{\"1\":{\"327\":1}}],[\"可以使用下面的方法实现读\",{\"1\":{\"306\":1}}],[\"可以使用\",{\"1\":{\"170\":1,\"291\":1,\"347\":1}}],[\"可以使用自定义实现显式动画\",{\"1\":{\"156\":1}}],[\"可以使用await等待其执行完毕\",{\"1\":{\"142\":1}}],[\"可以使用expanded或flexible\",{\"1\":{\"131\":1}}],[\"可以使用以下方式\",{\"1\":{\"2\":1}}],[\"可以简单理解为\",{\"1\":{\"128\":1}}],[\"可以得知\",{\"1\":{\"115\":1}}],[\"可以从下述例子详细看一下代码执行的时候各个方法执行过程\",{\"1\":{\"95\":1}}],[\"可以从客户端的得到的messenger中取出该handler\",{\"1\":{\"43\":1}}],[\"可以设置的值参考下图\",{\"1\":{\"65\":1}}],[\"可以获取宽\",{\"1\":{\"65\":1}}],[\"可以绘制实际的y坐标负值\",{\"1\":{\"63\":1}}],[\"可以避免阻塞\",{\"1\":{\"58\":1}}],[\"可以看其最后只是将requestcall和callback传递给了okhttputils类的execute方法\",{\"1\":{\"365\":1}}],[\"可以看做是官方文档的不完全翻译\",{\"1\":{\"88\":1}}],[\"可以看出\",{\"1\":{\"57\":1,\"96\":1,\"176\":1,\"239\":1}}],[\"可以看到isolate\",{\"1\":{\"384\":1}}],[\"可以看到okhttprequestbuilder只是将网络请求的相关参数传递到okhttprequest中\",{\"1\":{\"364\":1}}],[\"可以看到大体上可以将其分为3个部分\",{\"1\":{\"362\":1}}],[\"可以看到两次获取的是完全相同的对象\",{\"1\":{\"309\":1}}],[\"可以看到使用了synchronized\",{\"1\":{\"294\":1}}],[\"可以看到在singlechildscrollview先让child在主轴方向尽可能自由布局\",{\"1\":{\"238\":1}}],[\"可以看到在mainactivitymodule中提供了一个方法利用刚刚mainactivitysubcomponent中提供的mainactivitysubcomponent\",{\"1\":{\"91\":1}}],[\"可以看到其createelement创建的是statelesselement\",{\"1\":{\"126\":1}}],[\"可以看到其内部还有xxxelement\",{\"1\":{\"117\":1}}],[\"可以看到center的\",{\"1\":{\"122\":1}}],[\"可以看到无论是单次还是循环的timer最后都是使用\",{\"1\":{\"106\":1}}],[\"可以看到这两个方法到最后都相当于调用了thread对象的threadlocals的set\",{\"1\":{\"288\":1}}],[\"可以看到这里\",{\"1\":{\"239\":1,\"309\":1}}],[\"可以看到这里最后的关键方法是sendport\",{\"1\":{\"112\":1}}],[\"可以看到这里实际上是调用了timer中对应的私有方法\",{\"1\":{\"105\":1}}],[\"可以看到这种问题的优化思路主要在于如何在避免java\",{\"1\":{\"14\":1}}],[\"可以看到除了p0和pn外\",{\"1\":{\"62\":1}}],[\"可以看到\",{\"1\":{\"13\":1,\"82\":1,\"100\":2,\"102\":1,\"105\":2,\"111\":2,\"112\":1,\"117\":1,\"121\":1,\"127\":1,\"131\":1,\"155\":1,\"171\":1,\"176\":1,\"191\":1,\"198\":1,\"228\":1,\"233\":1,\"235\":1,\"238\":1,\"281\":1,\"377\":1,\"378\":1,\"383\":1,\"391\":1,\"399\":1}}],[\"可以关闭硬件加速\",{\"1\":{\"57\":1}}],[\"可以加速绘制速度\",{\"1\":{\"57\":1}}],[\"可以根据需求增减\",{\"1\":{\"56\":1}}],[\"可以通过umask查看umask的值\",{\"1\":{\"352\":1}}],[\"可以通过writeobject\",{\"1\":{\"307\":1}}],[\"可以通过try\",{\"1\":{\"142\":1}}],[\"可以通过对该方法就行包装\",{\"1\":{\"134\":1}}],[\"可以通过屏幕对角线的像素数px\",{\"1\":{\"53\":1}}],[\"可以通过context\",{\"1\":{\"2\":1}}],[\"可以注意到statefulwidget重写了createstate\",{\"1\":{\"134\":1}}],[\"可以注意到在客户端通过messenger\",{\"1\":{\"43\":1}}],[\"可以注意到一个细节\",{\"1\":{\"36\":1}}],[\"可以往reply中写入结果\",{\"1\":{\"40\":1}}],[\"可以在创建isolate的时候指定他的状态为\",{\"1\":{\"372\":1}}],[\"可以在打开的页面预览后做决定\",{\"1\":{\"368\":1}}],[\"可以在加入其它操作\",{\"1\":{\"322\":1}}],[\"可以在类和方法中\",{\"1\":{\"290\":1}}],[\"可以在finlize\",{\"1\":{\"266\":1}}],[\"可以在runapp方法中替换这个默认的错误界面\",{\"1\":{\"143\":1}}],[\"可以在res\",{\"1\":{\"2\":1}}],[\"可以在其外部包裹一层statefulwidget\",{\"1\":{\"134\":1}}],[\"可以在这里预览\",{\"1\":{\"186\":1}}],[\"可以在这里获取宽高\",{\"1\":{\"65\":1}}],[\"可以在这个布局里面\",{\"1\":{\"55\":1}}],[\"可以在下面的两个网站在线体验贝塞尔曲线\",{\"1\":{\"61\":1}}],[\"可以在java文件中获取到\",{\"1\":{\"54\":1}}],[\"可以在服务的onbind\",{\"1\":{\"39\":1}}],[\"可以将前者的标准输出当做后者的输入\",{\"1\":{\"361\":1}}],[\"可以将collect中执行的代码放到oneach中\",{\"1\":{\"337\":1}}],[\"可以将flow的内容\",{\"1\":{\"327\":1}}],[\"可以将各种集合与序列转换为流\",{\"1\":{\"327\":1}}],[\"可以将io操作和界面操作串行\",{\"1\":{\"322\":1}}],[\"可以将\",{\"1\":{\"213\":1}}],[\"可以将其传给child\",{\"1\":{\"156\":1}}],[\"可以将几乎所有的和dagger\",{\"1\":{\"88\":1}}],[\"可以将一个livedata经过处理转化为另外一个livedata\",{\"1\":{\"78\":1}}],[\"可以将aidl文件放到一个android\",{\"1\":{\"32\":1}}],[\"可以将获取到的图片缓存到app私有目录\",{\"1\":{\"2\":1}}],[\"可以是正则表达式\",{\"1\":{\"361\":1}}],[\"可以是任意需要的大小\",{\"1\":{\"65\":1}}],[\"可以是\",{\"1\":{\"17\":1}}],[\"可以查询可能会调用的app并赋予其访问权限\",{\"1\":{\"2\":1}}],[\"可以继承fileprovider类并修改下文中name字段\",{\"1\":{\"2\":1}}],[\"寻找可以处理点击事件的子view\",{\"1\":{\"13\":1}}],[\"寻找一个可以处理点击事件的子view\",{\"1\":{\"13\":1}}],[\"遍历等操作\",{\"1\":{\"439\":1}}],[\"遍历图中每个顶点\",{\"1\":{\"438\":1}}],[\"遍历图\",{\"1\":{\"438\":1}}],[\"遍历树指安装一定的顺序访问数的每个节点\",{\"1\":{\"430\":1}}],[\"遍历树查找是否存在与key一致的node\",{\"1\":{\"280\":1}}],[\"遍历数组中对应的链表找到空位并保存\",{\"1\":{\"428\":1}}],[\"遍历receivechannel的item执行指定action\",{\"1\":{\"328\":1}}],[\"遍历nodes\",{\"1\":{\"371\":1}}],[\"遍历n\",{\"1\":{\"289\":1}}],[\"遍历找到对应的node并删除\",{\"1\":{\"280\":1}}],[\"遍历链表查找是否存在与key一致的node\",{\"1\":{\"280\":1}}],[\"遍历\",{\"0\":{\"430\":1},\"1\":{\"148\":1}}],[\"遍历了所有的children将其插入到multichildrenderobjectelement中\",{\"1\":{\"127\":1}}],[\"遍历子view\",{\"1\":{\"13\":1}}],[\"遍历viewgroup的所有子view\",{\"1\":{\"13\":1}}],[\"后缀表达式源码\",{\"1\":{\"453\":1}}],[\"后缀表达式\",{\"1\":{\"453\":4}}],[\"后继节点\",{\"1\":{\"432\":1}}],[\"后期也可以改为post\",{\"1\":{\"367\":1}}],[\"后期稳定\",{\"1\":{\"5\":1}}],[\"后右子树\",{\"1\":{\"346\":1}}],[\"后序遍历\",{\"1\":{\"346\":1,\"430\":1}}],[\"后文详述\",{\"1\":{\"274\":1}}],[\"后文附有本方案的kotlin语言实现\",{\"1\":{\"81\":1}}],[\"后面是否需要再走b阶段\",{\"1\":{\"394\":1}}],[\"后面的就不会执行\",{\"1\":{\"361\":1}}],[\"后面紧跟要操作的文件\",{\"1\":{\"357\":1}}],[\"后面再详细分析\",{\"1\":{\"209\":1}}],[\"后面会再讲到\",{\"1\":{\"13\":1}}],[\"后续排序的特点\",{\"1\":{\"346\":1}}],[\"后续排序来逆向生成二叉树\",{\"1\":{\"346\":1}}],[\"后续遍历\",{\"1\":{\"346\":1}}],[\"后续所有的widget创建的renderobject都是在renderview的下层\",{\"1\":{\"122\":1}}],[\"后续的滑动事件才能被响应\",{\"1\":{\"55\":1}}],[\"后\",{\"1\":{\"115\":1}}],[\"后者关于数组大小的计算中width\",{\"1\":{\"282\":1}}],[\"后者会将\",{\"1\":{\"213\":1}}],[\"后者创建的\",{\"1\":{\"213\":1}}],[\"后者又创建了\",{\"1\":{\"212\":1}}],[\"后者又会调用powerimageloader\",{\"1\":{\"211\":1}}],[\"后者持有加载的图片的\",{\"1\":{\"211\":1}}],[\"后者提供了get\",{\"1\":{\"201\":1}}],[\"后者则创建了renderimage并最终将\",{\"1\":{\"195\":1}}],[\"后者则使用生成的\",{\"1\":{\"152\":1}}],[\"后者是解码的图片数据的不透明句柄\",{\"1\":{\"194\":1}}],[\"后者实际是黑色透明\",{\"1\":{\"184\":1}}],[\"后者的handler是\",{\"1\":{\"106\":1}}],[\"后者在名字为\",{\"1\":{\"17\":1}}],[\"后台线程\",{\"1\":{\"80\":1}}],[\"且节点总数是\",{\"1\":{\"443\":1}}],[\"且队列不为空\",{\"1\":{\"438\":1}}],[\"且packagename和当前app不同的app信息\",{\"1\":{\"422\":1}}],[\"且当所有的子协程被终止的时候\",{\"1\":{\"329\":1}}],[\"且它被用来提供一个稳定的协程层次结构来进行结构化并发而无需依赖\",{\"1\":{\"329\":1}}],[\"且后面没有set\",{\"1\":{\"288\":1}}],[\"且velocity不为0\",{\"1\":{\"225\":1}}],[\"且只能被调用一次\",{\"1\":{\"80\":1}}],[\"且该子view需要是nestedscrollingchild的实现类\",{\"1\":{\"55\":1}}],[\"且侵入小\",{\"1\":{\"53\":1}}],[\"且disallowintercept为false也需要调用onintercepttouchevent\",{\"1\":{\"13\":1}}],[\"且最小间隔15min\",{\"1\":{\"3\":1}}],[\"983\",{\"1\":{\"458\":1}}],[\"9e8922486154\",{\"1\":{\"346\":1}}],[\"952\",{\"1\":{\"327\":1}}],[\"9344l\",{\"1\":{\"309\":1}}],[\"97821\",{\"1\":{\"347\":1}}],[\"978\",{\"1\":{\"302\":1}}],[\"96\",{\"1\":{\"302\":1}}],[\"9之前\",{\"1\":{\"283\":1}}],[\"9d729c9c94c4\",{\"1\":{\"282\":1}}],[\"92397\",{\"1\":{\"211\":1}}],[\"94e0d\",{\"1\":{\"117\":2,\"122\":1}}],[\"99英寸的屏幕为例\",{\"1\":{\"53\":1}}],[\"99英寸的屏幕上\",{\"1\":{\"53\":1}}],[\"9bfed6e127cc\",{\"1\":{\"41\":1}}],[\"9159904\",{\"1\":{\"41\":1}}],[\"9\",{\"1\":{\"13\":1,\"81\":1,\"115\":1,\"276\":1,\"428\":1,\"453\":3}}],[\"原始权限\",{\"1\":{\"352\":1}}],[\"原文信息及链接如下\",{\"1\":{\"347\":1}}],[\"原文链接\",{\"1\":{\"58\":1,\"288\":1}}],[\"原本的异常被父协程所处理\",{\"1\":{\"329\":1}}],[\"原子性\",{\"1\":{\"317\":1}}],[\"原创\",{\"1\":{\"316\":1}}],[\"原密码\",{\"1\":{\"306\":2}}],[\"原有的\",{\"1\":{\"207\":1}}],[\"原生语法层\",{\"1\":{\"318\":1}}],[\"原生方法直接操作物理内存时导致物理内存不够\",{\"1\":{\"260\":1}}],[\"原生\",{\"1\":{\"198\":1}}],[\"原生提供的\",{\"1\":{\"198\":1}}],[\"原生的解决方案\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"原理如下\",{\"1\":{\"459\":1}}],[\"原理和算法详细介绍\",{\"1\":{\"458\":1}}],[\"原理同插入边\",{\"1\":{\"435\":1}}],[\"原理参考这篇文章parcelable源码分析\",{\"1\":{\"315\":1}}],[\"原理\",{\"0\":{\"312\":1,\"315\":1},\"1\":{\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"322\":1,\"325\":1}}],[\"原理做一简单分析\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"原理分析\",{\"0\":{\"171\":1,\"173\":1}}],[\"原理解析\",{\"1\":{\"2\":2}}],[\"原因是运行时类型会被擦除\",{\"1\":{\"292\":1}}],[\"原因是\",{\"1\":{\"283\":1}}],[\"原因是默认的serializable由于不同jvm实现对同一对象如string的hashcode不一定一致\",{\"1\":{\"280\":1}}],[\"原因是上面说到的flutter\",{\"1\":{\"130\":1}}],[\"原因\",{\"1\":{\"257\":1}}],[\"原因如下所示\",{\"1\":{\"13\":1}}],[\"原\",{\"1\":{\"65\":1}}],[\"指运算符在操作数后面的\",{\"1\":{\"453\":1}}],[\"指运算符在操作数中间的\",{\"1\":{\"453\":1}}],[\"指针指向超出数组大小时\",{\"1\":{\"452\":1}}],[\"指执行类似flow\",{\"1\":{\"336\":1}}],[\"指从lambda2中执行return语句\",{\"1\":{\"322\":1}}],[\"指在代码执行的过程中\",{\"1\":{\"320\":1}}],[\"指对于变量的赋值会在定义该变量和使用该变量的值之间的任意位置执行\",{\"1\":{\"317\":1}}],[\"指令重排\",{\"1\":{\"317\":1}}],[\"指的是从字节流中恢复java对象\",{\"1\":{\"303\":1}}],[\"指的是这一年所有的周\",{\"1\":{\"302\":1}}],[\"指将java对象转化为字节流以便在网络\",{\"1\":{\"303\":1}}],[\"指向了一条字节码指令的位置\",{\"1\":{\"252\":1}}],[\"指向\",{\"1\":{\"194\":1}}],[\"指向线程的指针\",{\"1\":{\"115\":1}}],[\"指定一个值c\",{\"1\":{\"463\":1}}],[\"指定一周的第一天\",{\"1\":{\"302\":1}}],[\"指定配置文件\",{\"1\":{\"416\":1}}],[\"指定在单独的协程中启动流的收集\",{\"1\":{\"337\":1}}],[\"指定serialversionuid\",{\"1\":{\"304\":1}}],[\"指定默认值\",{\"1\":{\"299\":1}}],[\"指定位置为空\",{\"1\":{\"280\":1}}],[\"指定同一个\",{\"1\":{\"170\":1}}],[\"指定时间的速度\",{\"1\":{\"165\":1}}],[\"指定时间的位置\",{\"1\":{\"165\":1}}],[\"指定的uri中创建并孵化一个isolate\",{\"1\":{\"373\":1}}],[\"指定的范围变化\",{\"1\":{\"146\":1,\"157\":1}}],[\"指定的几种间隔时间\",{\"1\":{\"6\":1}}],[\"指定其subcomponents为mainfragmentsubcomponent\",{\"1\":{\"94\":1}}],[\"指定事件发生时会被执行的\",{\"1\":{\"79\":1}}],[\"指定被绑定处理器的控件id\",{\"1\":{\"79\":1}}],[\"指定该behavior的子view需要是nestedscrollingchild的实现类\",{\"1\":{\"55\":1}}],[\"指示是否也删除状态栏通知\",{\"1\":{\"21\":1}}],[\"指手指点击屏幕后\",{\"1\":{\"13\":1}}],[\"直至h为1\",{\"1\":{\"462\":1}}],[\"直观算法\",{\"1\":{\"346\":1}}],[\"直达所有元素都为有序元素\",{\"1\":{\"289\":1}}],[\"直径\",{\"1\":{\"172\":1}}],[\"直到子数组只有一个元素\",{\"1\":{\"465\":1}}],[\"直到子线程cthread执行完毕后\",{\"1\":{\"297\":1}}],[\"直到两个指针相遇\",{\"1\":{\"464\":1}}],[\"直到两份数组都是有序的\",{\"1\":{\"459\":1}}],[\"直到h==1\",{\"1\":{\"462\":1}}],[\"直到所有元素排序完毕\",{\"1\":{\"459\":1}}],[\"直到每个子数组只有一个元素\",{\"1\":{\"459\":1}}],[\"直到第1项的计算结果为确定的1\",{\"1\":{\"459\":1}}],[\"直到遇到top是\",{\"1\":{\"453\":1}}],[\"直到遇到top比父节点小\",{\"1\":{\"441\":1}}],[\"直到遇到\",{\"1\":{\"453\":1}}],[\"直到将该节点放到符合堆条件的位置或者到达叶子节点\",{\"1\":{\"441\":1}}],[\"直到查找到父节点比插入值大\",{\"1\":{\"440\":1}}],[\"直到找到n或者数组已经不可再分\",{\"1\":{\"451\":1}}],[\"直到找到满足堆特征3\",{\"1\":{\"440\":1}}],[\"直到找到一个可用的port\",{\"1\":{\"115\":1}}],[\"直到没有可以访问的顶点\",{\"1\":{\"437\":1}}],[\"直到有顶点没有可以访问的邻接顶点\",{\"1\":{\"437\":1}}],[\"直到aot\",{\"1\":{\"396\":1}}],[\"直到异常被处理\",{\"1\":{\"329\":1}}],[\"直到执行成功\",{\"1\":{\"319\":1}}],[\"直到该注解类型被找到或是查找完了object类还未找到\",{\"1\":{\"298\":1}}],[\"直到其内部所有协程\",{\"1\":{\"323\":1}}],[\"直到其他线程调用子线程cthread的notify\",{\"1\":{\"297\":1}}],[\"直到其为空再执行下一个event\",{\"1\":{\"95\":1}}],[\"直到最后一位\",{\"1\":{\"455\":1}}],[\"直到最后一个没有排好序的元素\",{\"1\":{\"289\":1}}],[\"直到最顶层消耗掉点击事件\",{\"1\":{\"13\":1}}],[\"直到invalidate方法被调用\",{\"1\":{\"132\":1}}],[\"直到下一次因为widget更改或者state更新而被重新创建\",{\"1\":{\"132\":1}}],[\"直到遍历完整个widget\",{\"1\":{\"127\":1}}],[\"直到dart\",{\"1\":{\"115\":1}}],[\"直到当前app中既没有micro\",{\"1\":{\"109\":1}}],[\"直到event\",{\"1\":{\"95\":1,\"101\":1}}],[\"直到服务端方法在binder线程池中运行完毕\",{\"1\":{\"36\":1}}],[\"直到超时或者满足指定的条件后取消该闹钟\",{\"1\":{\"10\":1}}],[\"直接插入\",{\"1\":{\"458\":1}}],[\"直接插入✅\",{\"1\":{\"441\":1}}],[\"直接插入链表或红黑树尾部\",{\"1\":{\"280\":1}}],[\"直接将数据存储在数组中\",{\"1\":{\"428\":1}}],[\"直接找一份\",{\"1\":{\"409\":1}}],[\"直接预览\",{\"1\":{\"400\":1}}],[\"直接粘贴到指定位置就行\",{\"1\":{\"347\":1}}],[\"直接修改threadlocal的值\",{\"1\":{\"325\":1}}],[\"直接新建node并保存到table\",{\"1\":{\"280\":1}}],[\"直接清理掉端边界外的内存\",{\"1\":{\"264\":1}}],[\"直接引用可以直接定位到内存中某一段地址\",{\"1\":{\"278\":1}}],[\"直接引用\",{\"1\":{\"254\":1}}],[\"直接结束掉app等\",{\"1\":{\"144\":1}}],[\"直接覆盖旧值并返回\",{\"1\":{\"50\":1}}],[\"直接\",{\"1\":{\"0\":1,\"275\":1}}],[\"x+\",{\"1\":{\"462\":1}}],[\"x+2\",{\"1\":{\"439\":1,\"462\":1}}],[\"x+1\",{\"1\":{\"439\":1,\"462\":1}}],[\"x++\",{\"1\":{\"328\":1}}],[\"x64http\",{\"1\":{\"413\":1}}],[\"x64\",{\"1\":{\"410\":1}}],[\"x64fre\",{\"1\":{\"110\":1}}],[\"xrange\",{\"1\":{\"370\":1}}],[\"xref\",{\"1\":{\"13\":1}}],[\"xs\",{\"1\":{\"369\":1}}],[\"x3\",{\"1\":{\"61\":1}}],[\"x2\",{\"1\":{\"61\":2}}],[\"x1\",{\"1\":{\"61\":2}}],[\"xor\",{\"1\":{\"57\":1}}],[\"xfermode的本质是处理dst与src重合与未重合部分的展示与否\",{\"1\":{\"57\":1}}],[\"xfermode\",{\"1\":{\"57\":2}}],[\"xfermode是android中用来指示paint绘制的内容与view中已有内容的混合计算方式\",{\"1\":{\"57\":1}}],[\"xdpi\",{\"1\":{\"53\":3}}],[\"xdpi=403\",{\"1\":{\"53\":2}}],[\"xuxingxing002\",{\"1\":{\"15\":1}}],[\"x\",{\"1\":{\"15\":5,\"41\":3,\"62\":6,\"63\":13,\"64\":3,\"93\":1,\"126\":2,\"162\":1,\"163\":1,\"165\":1,\"166\":2,\"167\":2,\"182\":1,\"302\":1,\"321\":2,\"328\":4,\"345\":2,\"351\":1,\"352\":2,\"357\":1,\"369\":5,\"370\":2,\"422\":6,\"439\":1,\"455\":7,\"456\":3,\"462\":7}}],[\"x的系统会在app安装后第一次启动时\",{\"1\":{\"14\":1}}],[\"x以下加载multidex白屏的处理优化\",{\"0\":{\"14\":1}}],[\"xxfile\",{\"1\":{\"369\":1}}],[\"xxxrepository类对应封装了这数据库appdatabase中对两个表的操作\",{\"1\":{\"399\":1}}],[\"xxxrepository类的出现时为了将viewmodel与数据的具体实现解耦合\",{\"1\":{\"399\":1}}],[\"xxxviewmodelfactory向activity等屏蔽了viewmodel的具体实现\",{\"1\":{\"399\":1}}],[\"xxx\",{\"1\":{\"56\":1,\"71\":1,\"298\":2,\"301\":1,\"321\":1,\"347\":1,\"367\":2,\"368\":1}}],[\"xx\",{\"1\":{\"10\":2,\"321\":3,\"322\":1,\"345\":2}}],[\"xml注册的activity\",{\"1\":{\"71\":1}}],[\"xml文件中声明即可\",{\"1\":{\"67\":1}}],[\"xml文件夹中新建file\",{\"1\":{\"2\":1}}],[\"xml下新建对应文件\",{\"1\":{\"56\":1}}],[\"xmlns\",{\"1\":{\"56\":2,\"66\":3,\"79\":3,\"400\":3,\"401\":5,\"421\":1}}],[\"xml中注册indexactivity和proxyactivity\",{\"1\":{\"71\":1}}],[\"xml中注册的activity\",{\"1\":{\"70\":1}}],[\"xml中声明所需权限\",{\"1\":{\"68\":1}}],[\"xml中添加该控件\",{\"1\":{\"56\":1}}],[\"xml中配置\",{\"1\":{\"36\":1}}],[\"xml中的属性\",{\"1\":{\"17\":1}}],[\"xml并做如下配置\",{\"1\":{\"2\":1}}],[\"xml\",{\"1\":{\"2\":2,\"17\":1,\"20\":1,\"54\":3,\"55\":1,\"56\":2,\"66\":2,\"79\":9,\"401\":1,\"421\":1}}],[\"4增量排序示意图\",{\"1\":{\"460\":1}}],[\"4序列\",{\"1\":{\"459\":1}}],[\"483\",{\"1\":{\"458\":1}}],[\"480\",{\"1\":{\"53\":1}}],[\"480dpi\",{\"1\":{\"53\":1}}],[\"44\",{\"1\":{\"417\":2}}],[\"47openssl\",{\"1\":{\"413\":1}}],[\"49\",{\"1\":{\"370\":1}}],[\"49c477a875e84b2aae764c67f38f26b2\",{\"1\":{\"58\":1}}],[\"4s发射一次直接拼接\",{\"1\":{\"344\":2}}],[\"452\",{\"1\":{\"327\":1}}],[\"4都会被丢弃\",{\"1\":{\"327\":1}}],[\"4时\",{\"1\":{\"302\":1}}],[\"4+\",{\"1\":{\"287\":6}}],[\"4个元素\",{\"1\":{\"459\":1}}],[\"4个\",{\"1\":{\"285\":1}}],[\"41\",{\"1\":{\"115\":1}}],[\"411\",{\"1\":{\"53\":4}}],[\"411dp\",{\"1\":{\"53\":1}}],[\"40\",{\"1\":{\"115\":1,\"282\":1,\"461\":1}}],[\"40614\",{\"1\":{\"111\":2}}],[\"4000\",{\"1\":{\"414\":2}}],[\"400\",{\"1\":{\"58\":1,\"327\":2}}],[\"42\",{\"1\":{\"115\":1}}],[\"429a1ff3560c\",{\"1\":{\"59\":1}}],[\"426620\",{\"1\":{\"58\":1}}],[\"4f\",{\"1\":{\"53\":1}}],[\"4\",{\"0\":{\"255\":1,\"259\":1,\"265\":1},\"1\":{\"14\":1,\"58\":1,\"60\":1,\"66\":1,\"69\":1,\"115\":4,\"130\":1,\"158\":1,\"192\":1,\"198\":2,\"210\":1,\"276\":2,\"277\":1,\"281\":2,\"282\":17,\"283\":3,\"285\":11,\"287\":6,\"288\":1,\"294\":1,\"299\":1,\"302\":1,\"321\":1,\"322\":1,\"325\":2,\"328\":1,\"336\":1,\"346\":3,\"347\":1,\"352\":1,\"376\":1,\"389\":1,\"413\":1,\"428\":2,\"460\":1}}],[\"4300\",{\"1\":{\"111\":1}}],[\"432\",{\"1\":{\"81\":1}}],[\"43\",{\"1\":{\"5\":1,\"458\":1}}],[\"46\",{\"1\":{\"5\":2}}],[\"651\",{\"1\":{\"327\":1}}],[\"65534个字节\",{\"1\":{\"283\":1}}],[\"65536\",{\"1\":{\"283\":1}}],[\"694\",{\"1\":{\"327\":1}}],[\"696\",{\"1\":{\"5\":1}}],[\"6以后\",{\"1\":{\"320\":1}}],[\"666\",{\"1\":{\"352\":1}}],[\"666l\",{\"1\":{\"308\":1}}],[\"66\",{\"1\":{\"295\":1}}],[\"6647114\",{\"1\":{\"61\":1}}],[\"6及以下输出false\",{\"1\":{\"254\":1}}],[\"6及以下\",{\"1\":{\"254\":1}}],[\"6e802\",{\"1\":{\"125\":1}}],[\"644\",{\"1\":{\"352\":1}}],[\"64136\",{\"1\":{\"287\":1}}],[\"64\",{\"1\":{\"111\":1}}],[\"64k\",{\"1\":{\"14\":1,\"111\":1}}],[\"6fb6d4\",{\"1\":{\"66\":1}}],[\"6211589\",{\"1\":{\"58\":3,\"59\":1}}],[\"6\",{\"1\":{\"35\":1,\"36\":1,\"62\":1,\"115\":1,\"231\":3,\"278\":1,\"281\":2,\"299\":1,\"370\":1,\"413\":2,\"459\":1}}],[\"634\",{\"1\":{\"5\":1}}],[\"60\",{\"1\":{\"5\":1,\"11\":1}}],[\"分成两个子数组分别排序\",{\"1\":{\"459\":1}}],[\"分配哪些类的实例\",{\"1\":{\"396\":1}}],[\"分配worker\",{\"1\":{\"389\":1}}],[\"分配的尺寸只比\",{\"1\":{\"213\":1}}],[\"分配的内存除了映射进了接收方进程里\",{\"1\":{\"58\":1}}],[\"分隔\",{\"1\":{\"321\":1,\"369\":1}}],[\"分类\",{\"1\":{\"250\":1,\"282\":1}}],[\"分发\",{\"1\":{\"226\":1}}],[\"分发事件\",{\"1\":{\"13\":1}}],[\"分组的方法\",{\"1\":{\"202\":1}}],[\"分段读取文件\",{\"1\":{\"111\":1}}],[\"分别再找一个枢纽\",{\"1\":{\"467\":1}}],[\"分别形成两个n\",{\"1\":{\"459\":1}}],[\"分别输入git\",{\"1\":{\"411\":1}}],[\"分别使用\",{\"1\":{\"233\":1}}],[\"分别会是\",{\"1\":{\"227\":1}}],[\"分别应用于outer\",{\"1\":{\"224\":1}}],[\"分别涉及到\",{\"1\":{\"211\":1}}],[\"分别采用\",{\"1\":{\"211\":1}}],[\"分别创建对应的powerexternalimageprovider或者powertextureimageprovider\",{\"1\":{\"208\":1}}],[\"分别在两个\",{\"1\":{\"170\":1}}],[\"分别被认为是\",{\"1\":{\"161\":1}}],[\"分别是isolate初始运行方法\",{\"1\":{\"389\":2}}],[\"分别是\",{\"1\":{\"114\":1}}],[\"分别是控制点1\",{\"1\":{\"61\":1}}],[\"分别是控制点的x\",{\"1\":{\"61\":1}}],[\"分别设置对应页面布局setcontentview\",{\"1\":{\"71\":1}}],[\"分析jetpack架构中各部分的作用\",{\"1\":{\"399\":1}}],[\"分析为何\",{\"1\":{\"226\":1}}],[\"分析完了runapp\",{\"1\":{\"122\":1}}],[\"分析一下在这个过程中涉及到的widget\",{\"1\":{\"117\":1}}],[\"分析\",{\"1\":{\"64\":1}}],[\"分析可知\",{\"1\":{\"53\":1}}],[\"分为3种情况\",{\"1\":{\"432\":2}}],[\"分为阻塞和异步两种方式\",{\"1\":{\"362\":1}}],[\"分为有参和无参\",{\"1\":{\"321\":1}}],[\"分为两种\",{\"1\":{\"279\":1}}],[\"分为两类\",{\"1\":{\"274\":1}}],[\"分为alpha合成和混合两种\",{\"1\":{\"57\":1}}],[\"分为从设备上次启动时间和精准时间两种\",{\"1\":{\"5\":1}}],[\"分钟一次\",{\"1\":{\"3\":1}}],[\"距离开机时间多久后启用闹钟\",{\"1\":{\"4\":1}}],[\"距离系统启动后的时间\",{\"1\":{\"4\":1}}],[\"它可以允许数据在诸如屏幕旋转的变化中存活下来\",{\"1\":{\"402\":1}}],[\"它可以用来模仿简单的转换\",{\"1\":{\"327\":1}}],[\"它处理dart源代码编译成内核的过程\",{\"1\":{\"393\":1}}],[\"它也会在所有的子作业执行结束前等待\",{\"1\":{\"332\":1}}],[\"它只会单向的传播并且当子作业自身执行失败的时候将它们全部取消\",{\"1\":{\"332\":1}}],[\"它只是发送事务数据并立即返回\",{\"1\":{\"43\":1}}],[\"它类似于常规的\",{\"1\":{\"330\":1,\"331\":1}}],[\"它将取消具有该异常的父协程\",{\"1\":{\"329\":1}}],[\"它将被挂起直到发送被调用\",{\"1\":{\"328\":1}}],[\"它将折叠\",{\"1\":{\"55\":1}}],[\"它运行的速度很快\",{\"1\":{\"327\":1,\"338\":1}}],[\"它力求帮助开发者实现高性能和高可控的序列化过程\",{\"1\":{\"303\":1}}],[\"它能够被编译器解析\",{\"1\":{\"298\":1}}],[\"它更希望将自己size定位一个更加合理的固有高度\",{\"1\":{\"242\":1}}],[\"它主要的作用是将上面提到的三部分组合起来\",{\"1\":{\"227\":1}}],[\"它追踪这些\",{\"1\":{\"217\":1}}],[\"它在initstate\",{\"1\":{\"213\":1}}],[\"它为\",{\"1\":{\"213\":1}}],[\"它\",{\"1\":{\"213\":1}}],[\"它借助于\",{\"1\":{\"212\":1}}],[\"它是如何实现滚动效果\",{\"1\":{\"234\":1}}],[\"它是如何实现联动滚动效果\",{\"1\":{\"212\":1}}],[\"它是否对嵌套滑动感兴趣\",{\"1\":{\"55\":1}}],[\"它的主要作用就是在isolate创建好之后进行统一的初始化操作\",{\"1\":{\"382\":1}}],[\"它的主要逻辑在\",{\"1\":{\"147\":1}}],[\"它的定义是\",{\"1\":{\"242\":1}}],[\"它的泛型指定了child的类型只能是renderbox\",{\"1\":{\"237\":1}}],[\"它的width\",{\"1\":{\"195\":1}}],[\"它实现了父类\",{\"1\":{\"184\":1}}],[\"它继承自\",{\"1\":{\"152\":1,\"157\":1}}],[\"它创建了真正在屏幕上渲染的renderobject\",{\"1\":{\"127\":1}}],[\"它没有名字也不需要注册\",{\"1\":{\"58\":1}}],[\"它不需要通过\",{\"1\":{\"55\":1}}],[\"它会替换原始闹钟\",{\"1\":{\"3\":1,\"7\":1}}],[\"它们遵守先进先出原则\",{\"1\":{\"328\":1}}],[\"它们可以帮助您最大限度地降低应用的资源要求\",{\"1\":{\"3\":1}}],[\"它们可让您按设定的时间和\",{\"1\":{\"3\":1}}],[\"它们在应用外部运行\",{\"1\":{\"3\":1}}],[\"当两个指针都退出时\",{\"1\":{\"464\":1}}],[\"当遇到满足条件的元素则退出\",{\"1\":{\"464\":1}}],[\"当插入137后红黑树如图\",{\"1\":{\"458\":1}}],[\"当图中没有顶点的时候\",{\"1\":{\"438\":1}}],[\"当图的每一条边的权值都相同时\",{\"1\":{\"438\":1}}],[\"当去掉没有后继点的顶点后又会产生新的没有后继点的顶点\",{\"1\":{\"438\":1}}],[\"当规则1不能满足时\",{\"1\":{\"437\":1}}],[\"当装填因子变得很大时\",{\"1\":{\"428\":1}}],[\"当hash算法计算出的地址时\",{\"1\":{\"428\":1}}],[\"当hash算出的地址已经被占用时\",{\"1\":{\"428\":1}}],[\"当hero动画变到最大时\",{\"1\":{\"172\":1}}],[\"当hero动画变到最小时\",{\"1\":{\"172\":1}}],[\"当用\",{\"1\":{\"418\":1}}],[\"当用户操作屏幕发生\",{\"1\":{\"226\":1}}],[\"当用户滑动等事件发生\",{\"1\":{\"212\":1}}],[\"当以上内容都配置完成后\",{\"1\":{\"407\":1}}],[\"当livedata的值发生变化时activity等可以及时得到通知\",{\"1\":{\"402\":1}}],[\"当runtime要执行的时候再创建并运行可执行代码\",{\"1\":{\"394\":1}}],[\"当runtime实际用到的时候才会去获取完整的信息用来创建对象分配内存等\",{\"1\":{\"394\":1}}],[\"当request执行完毕之后\",{\"1\":{\"111\":1,\"112\":1}}],[\"当kernel\",{\"1\":{\"394\":1}}],[\"当热更新触发时\",{\"1\":{\"393\":1}}],[\"当osthread要进入一个isolate的时候\",{\"1\":{\"392\":1}}],[\"当offset变化时\",{\"1\":{\"239\":1}}],[\"当执行requestcall的execute方法时\",{\"1\":{\"365\":1}}],[\"当下次同步的时候需要输入\",{\"1\":{\"347\":1}}],[\"当父节点只有一个子节点时\",{\"1\":{\"346\":1}}],[\"当父级指定的最大约束是double\",{\"1\":{\"242\":1}}],[\"当父级指定的最小约束minheight大于instrinsicheight\",{\"1\":{\"242\":1}}],[\"当父级尺寸小于column的children尺寸时\",{\"1\":{\"241\":1}}],[\"当父级尺寸大于column的children尺寸时\",{\"1\":{\"241\":1}}],[\"当方法只有一个参数时\",{\"1\":{\"345\":1}}],[\"当缓冲区被占满的时候将会引起阻塞\",{\"1\":{\"328\":1}}],[\"当collect比构建慢的时候\",{\"1\":{\"327\":1}}],[\"当child可能有无限的高度时\",{\"1\":{\"242\":1}}],[\"当child的内容大于父级约束时\",{\"1\":{\"238\":1}}],[\"当流在一个可取消的挂起函数\",{\"1\":{\"327\":1}}],[\"当泛型即当消费者\",{\"1\":{\"322\":1}}],[\"当线程操作的数据不是共享数据时\",{\"1\":{\"320\":1}}],[\"当第二次再次尝试时\",{\"1\":{\"319\":1}}],[\"当第二个\",{\"1\":{\"159\":1}}],[\"当写入文件的为同一对象时\",{\"1\":{\"309\":1}}],[\"当可序列化的类缺少serialversionuid定义时的警告\",{\"1\":{\"298\":1}}],[\"当switch程序块进入进入下一个case而没有break时的警告\",{\"1\":{\"298\":1}}],[\"当某个thread调用某个对象的wait\",{\"1\":{\"297\":1}}],[\"当某个事件出现之后才会执行\",{\"1\":{\"79\":1}}],[\"当t1执行到语句2\",{\"1\":{\"294\":1}}],[\"当table\",{\"1\":{\"280\":2}}],[\"当table为空或者长度超过加载因子default\",{\"1\":{\"280\":1}}],[\"当判断as为null时\",{\"1\":{\"294\":1}}],[\"当需要向viewmodel传递参数时\",{\"1\":{\"402\":1}}],[\"当需要用到枚举类的特性时\",{\"1\":{\"286\":1}}],[\"当需要填充容器\",{\"1\":{\"131\":1}}],[\"当我们在dart代码中调用isolate\",{\"1\":{\"387\":1}}],[\"当我们新建一个threadlocal并为之赋值时\",{\"1\":{\"288\":1}}],[\"当我们用javap查看其编译后的字节码可以看到\",{\"1\":{\"285\":1}}],[\"当我们仔细查看具体的widget\",{\"1\":{\"117\":1}}],[\"当存储的数据总量超过加载系数loadfactor规定的阈值时则对table进行扩容\",{\"1\":{\"280\":1}}],[\"当常量过多时会导致oom\",{\"1\":{\"258\":1}}],[\"当单个线程最大栈内存增加时\",{\"1\":{\"257\":1}}],[\"当内存无法分配时都会导致stack\",{\"1\":{\"257\":1}}],[\"当做当前线程执行字节码的行号指示器\",{\"1\":{\"255\":1}}],[\"当minheight\",{\"1\":{\"242\":1}}],[\"当multidexopt完成后再关闭当前进程\",{\"1\":{\"14\":1}}],[\"当手指向下滑动的时候\",{\"1\":{\"231\":1}}],[\"当向下滑动时\",{\"1\":{\"226\":1}}],[\"当向上滑动\",{\"1\":{\"212\":1}}],[\"当没有给\",{\"1\":{\"223\":1}}],[\"当pixels大于等于0也就是不存在overscroll时\",{\"1\":{\"220\":2}}],[\"当pixels小于0也就是存在overscroll时\",{\"1\":{\"220\":2}}],[\"当其大小接近容量时\",{\"1\":{\"428\":1}}],[\"当其进入之后\",{\"1\":{\"392\":1}}],[\"当其内部所有协程\",{\"1\":{\"323\":1}}],[\"当其再次滑入时再recreate\",{\"1\":{\"240\":1}}],[\"当其变化时执行markneedpaint\",{\"1\":{\"239\":1}}],[\"当其\",{\"1\":{\"220\":1}}],[\"当其是coordinatorlayout类的直接子view时\",{\"1\":{\"55\":1}}],[\"当使用同一个objectoutputstream对象序列化同一个序列化对象时\",{\"1\":{\"309\":1}}],[\"当使用yyyy格式化时\",{\"1\":{\"302\":1}}],[\"当使用ui\",{\"1\":{\"211\":1}}],[\"当使用\",{\"1\":{\"207\":1}}],[\"当使用不同的值重新构建\",{\"1\":{\"147\":1}}],[\"当成功加载图片之后获得imageinfo\",{\"1\":{\"200\":1}}],[\"当依赖变化\",{\"1\":{\"190\":1}}],[\"当上述代码执行的时候\",{\"1\":{\"396\":1}}],[\"当上述条件满足之后\",{\"1\":{\"180\":1}}],[\"当上面loadimage发起的图片加载完成之后\",{\"1\":{\"211\":1}}],[\"当上一步无法满足需求时\",{\"1\":{\"156\":1}}],[\"当刚刚完整切换到页面\",{\"1\":{\"173\":1}}],[\"当从\",{\"1\":{\"170\":1}}],[\"当随着时间变化\",{\"1\":{\"157\":1}}],[\"当动画相关的属性变化时\",{\"1\":{\"156\":1}}],[\"当动画执行完毕会调用\",{\"1\":{\"153\":1}}],[\"当然也可以是其他实现\",{\"1\":{\"154\":1}}],[\"当然也不排除有其他更优雅的解决方案\",{\"1\":{\"91\":1}}],[\"当再次切回本协程时\",{\"1\":{\"325\":1}}],[\"当再次返回继续执行该代码时不会影响到其执行结果的代码\",{\"1\":{\"320\":1}}],[\"当再次序列化时保存的只是前一个对象的引用\",{\"1\":{\"309\":1}}],[\"当再次提供一个有新\",{\"1\":{\"153\":1}}],[\"当再次被更新时会触发动画\",{\"1\":{\"150\":1}}],[\"当widget更新后\",{\"1\":{\"150\":1}}],[\"当as为null的时候t1执行到tag1位置\",{\"1\":{\"294\":1}}],[\"当animationcontroller监听的ticker时执行setstate触发rebuilt\",{\"1\":{\"152\":1}}],[\"当animationstatus\",{\"1\":{\"148\":1}}],[\"当app的minsdkversion低于android\",{\"1\":{\"14\":1}}],[\"当app目标版本是android\",{\"1\":{\"2\":1}}],[\"当在\",{\"1\":{\"190\":1,\"399\":1}}],[\"当在widget构建过程中出现错误\",{\"1\":{\"143\":1}}],[\"当在client中想使用这个方法的依赖时\",{\"1\":{\"86\":1}}],[\"当inheritedwidget更新的时候\",{\"1\":{\"130\":1}}],[\"当io操作完成时会通过\",{\"1\":{\"111\":1}}],[\"当外层statefulwidget的element执行到updatechild\",{\"1\":{\"128\":1}}],[\"当屏幕刷新的时候\",{\"1\":{\"127\":1}}],[\"当flutter\",{\"1\":{\"118\":1}}],[\"当nmh执行完毕回调后\",{\"1\":{\"115\":1}}],[\"当native层处理完这些io指令之后\",{\"1\":{\"112\":1}}],[\"当有新的microtask加入的时候\",{\"1\":{\"100\":1}}],[\"当有多个线程可以访问该实例时\",{\"1\":{\"87\":1}}],[\"当按钮被点击的时候触发相应的动作\",{\"1\":{\"79\":1}}],[\"当达到某个特定条件时\",{\"1\":{\"79\":1}}],[\"当滑动字母导航栏时\",{\"1\":{\"64\":1}}],[\"当该进程1对资源执行完操作后\",{\"1\":{\"58\":1}}],[\"当\",{\"1\":{\"55\":1,\"108\":1,\"150\":1,\"152\":1,\"153\":1,\"159\":1,\"161\":1,\"168\":1,\"171\":2,\"174\":1,\"196\":1,\"198\":3,\"211\":3,\"223\":1,\"226\":1,\"302\":1,\"327\":1}}],[\"当一个进程使用binder\",{\"1\":{\"58\":1}}],[\"当一个被依赖项\",{\"1\":{\"55\":1}}],[\"当一个滚动事件结束\",{\"1\":{\"55\":1}}],[\"当dependency子view滑动时\",{\"1\":{\"55\":1}}],[\"当你定义了一个minheight\",{\"1\":{\"55\":1}}],[\"当滚动到顶部的时候展开完\",{\"1\":{\"55\":1}}],[\"当添加item时\",{\"1\":{\"50\":1}}],[\"当要保存的数据量比较小\",{\"1\":{\"44\":1,\"287\":1}}],[\"当要注销时\",{\"1\":{\"36\":1}}],[\"当view树的状态变更可能被调用多次\",{\"1\":{\"65\":1}}],[\"当view树的状态变更\",{\"1\":{\"65\":1}}],[\"当view平移的时候\",{\"1\":{\"41\":1}}],[\"当viewgroup\",{\"1\":{\"13\":1}}],[\"当服务端进程意外死亡时\",{\"1\":{\"38\":1}}],[\"当binder死亡时\",{\"1\":{\"36\":1}}],[\"当跨进程通信时传递的是proxy类\",{\"1\":{\"35\":1}}],[\"当客户端取消绑定时\",{\"1\":{\"19\":1}}],[\"当前点右子节点的左子节点为null\",{\"1\":{\"432\":1}}],[\"当前几次找不到之后就会很恐慌\",{\"1\":{\"428\":1}}],[\"当前爬虫主体功能以及实现\",{\"1\":{\"370\":1}}],[\"当前版本暂不支持中文\",{\"1\":{\"368\":1}}],[\"当前用户主目录\",{\"1\":{\"349\":1}}],[\"当前路径\",{\"1\":{\"349\":1}}],[\"当前线程才会恢复运行\",{\"1\":{\"297\":1}}],[\"当前位于overlay中的所有hero动画\",{\"1\":{\"178\":1}}],[\"当前值\",{\"1\":{\"161\":1}}],[\"当前event\",{\"1\":{\"101\":1}}],[\"当前的window获取或失去焦点的时候调用\",{\"1\":{\"65\":1}}],[\"当前服务id\",{\"1\":{\"17\":1}}],[\"当前自开机完后的时间\",{\"1\":{\"11\":1}}],[\"当不需要该闹钟时可以根据这个来取消\",{\"1\":{\"7\":1}}],[\"当您设置了使用同一待定\",{\"1\":{\"3\":1,\"7\":1}}],[\"等当前比较完成就和未比较的最后一位交换\",{\"1\":{\"456\":1}}],[\"等由于路径不对\",{\"1\":{\"417\":1}}],[\"等成功之后将其处理后返回给dart层的调用者\",{\"1\":{\"378\":1}}],[\"等设置为传入的对象\",{\"1\":{\"378\":1}}],[\"等接口\",{\"1\":{\"365\":1}}],[\"等处理完再读取的时候构建器生产的是5\",{\"1\":{\"327\":1}}],[\"等同于只有一个实例的类\",{\"1\":{\"321\":1}}],[\"等这些继承自\",{\"1\":{\"233\":1}}],[\"等这样的需求\",{\"1\":{\"4\":1}}],[\"等完全下拉之后\",{\"1\":{\"231\":1}}],[\"等继承自\",{\"1\":{\"227\":1}}],[\"等继承自scrollview的\",{\"1\":{\"212\":1}}],[\"等产生的\",{\"1\":{\"226\":1}}],[\"等于\",{\"1\":{\"226\":2,\"351\":1}}],[\"等效果\",{\"1\":{\"226\":1}}],[\"等与滑动有关的方法中都有直接或间接的调用\",{\"1\":{\"225\":1}}],[\"等与滑动相关的方法被调用时执行\",{\"1\":{\"223\":1}}],[\"等和滑动有关的事件转发给\",{\"1\":{\"212\":1}}],[\"等组装在一起\",{\"1\":{\"212\":1}}],[\"等分别修改\",{\"1\":{\"212\":1}}],[\"等进行封装的\",{\"1\":{\"212\":1,\"227\":1}}],[\"等直接对\",{\"1\":{\"212\":1,\"227\":1}}],[\"等的具体地址\",{\"1\":{\"254\":1}}],[\"等的\",{\"1\":{\"212\":1,\"227\":1}}],[\"等图片的实现\",{\"1\":{\"211\":1}}],[\"等都约定俗成在\",{\"1\":{\"196\":1}}],[\"等都继承自\",{\"1\":{\"188\":1}}],[\"等一众\",{\"1\":{\"196\":1}}],[\"等能够更快地加载\",{\"1\":{\"188\":1}}],[\"等依赖变化时会调用的地方\",{\"1\":{\"188\":1}}],[\"等类的关系简单示意\",{\"1\":{\"182\":1}}],[\"等属性的变化\",{\"1\":{\"182\":1}}],[\"等封装到\",{\"1\":{\"181\":1}}],[\"等适用于\",{\"1\":{\"170\":1}}],[\"等动画\",{\"1\":{\"168\":1}}],[\"等获取当前值\",{\"1\":{\"168\":1}}],[\"等方法保存其他变量\",{\"1\":{\"306\":1}}],[\"等方法\",{\"1\":{\"178\":1}}],[\"等方法创建不同的\",{\"1\":{\"168\":1}}],[\"等方式读取\",{\"1\":{\"2\":1}}],[\"等结合使\",{\"1\":{\"157\":1}}],[\"等计算出当前的\",{\"1\":{\"157\":1}}],[\"等决定动画的时长\",{\"1\":{\"156\":1}}],[\"等提示并输出错误堆栈信息\",{\"1\":{\"143\":1}}],[\"等式后面的所有数据都为已知或者在app运行时可知\",{\"1\":{\"81\":1}}],[\"等比拉伸控件大小\",{\"1\":{\"81\":1}}],[\"等到当前一轮的遍历完成之后\",{\"1\":{\"289\":1}}],[\"等到当前的执行完了\",{\"1\":{\"80\":1}}],[\"等到\",{\"1\":{\"212\":1}}],[\"等到native执行完操作之后再回调结果\",{\"1\":{\"110\":1}}],[\"等到通过系统验证\",{\"1\":{\"70\":1}}],[\"等待一会儿就可以看到更新后的博客了\",{\"1\":{\"405\":1}}],[\"等待有空闲的worker处理任务\",{\"1\":{\"390\":1}}],[\"等待3s\",{\"1\":{\"370\":1}}],[\"等待内部流处理完毕后\",{\"1\":{\"340\":1}}],[\"等待可中断\",{\"1\":{\"318\":1}}],[\"等待池中的线程不会竞争该对象的锁\",{\"1\":{\"297\":1}}],[\"等待池\",{\"1\":{\"297\":1}}],[\"等待执行\",{\"1\":{\"80\":1}}],[\"等待下次gc\",{\"1\":{\"47\":1}}],[\"等待multidexopt操作完成后再跳转到主activity并finish掉本activity\",{\"1\":{\"14\":1}}],[\"等源码发现他的数组只会增加\",{\"1\":{\"44\":1}}],[\"等\",{\"1\":{\"44\":1,\"54\":1,\"58\":1,\"154\":1,\"157\":2,\"226\":2,\"227\":1}}],[\"等服务端回调时会执行对应方法\",{\"1\":{\"37\":1}}],[\"等dex文件处理完毕后再加载主activity\",{\"1\":{\"14\":1}}],[\"等等都在\",{\"1\":{\"227\":1}}],[\"等等一系列与scroll有关的逻辑\",{\"1\":{\"234\":1}}],[\"等等一系列与\",{\"1\":{\"212\":1,\"227\":1}}],[\"等等\",{\"1\":{\"3\":1,\"54\":2}}],[\"5d7206c5f265da03ab427181\",{\"1\":{\"306\":1}}],[\"55\",{\"1\":{\"302\":1}}],[\"537\",{\"1\":{\"370\":2}}],[\"53\",{\"1\":{\"302\":1,\"458\":1}}],[\"53英寸的屏幕上\",{\"1\":{\"53\":1}}],[\"56\",{\"1\":{\"282\":2,\"413\":1}}],[\"560\",{\"1\":{\"53\":1}}],[\"560dpi\",{\"1\":{\"53\":1}}],[\"5要在初始化那一步才进行\",{\"1\":{\"277\":1}}],[\"5b35a75e51882574ea3a25e3\",{\"1\":{\"137\":1}}],[\"512\",{\"1\":{\"108\":2}}],[\"51162011\",{\"1\":{\"63\":1}}],[\"51637678https\",{\"1\":{\"41\":1}}],[\"50\",{\"1\":{\"234\":1}}],[\"50sp\",{\"1\":{\"79\":1}}],[\"500dp\",{\"1\":{\"66\":1}}],[\"500f\",{\"1\":{\"63\":1}}],[\"50971606\",{\"1\":{\"15\":1}}],[\"59c9cd59f265da065754e6f1\",{\"1\":{\"59\":1}}],[\"59f8691b51882534af254317\",{\"1\":{\"58\":2}}],[\"5a6l5l2t\",{\"1\":{\"58\":1}}],[\"5287d090e777\",{\"1\":{\"55\":1}}],[\"54266101\",{\"1\":{\"35\":1}}],[\"5时几乎没有性能损失\",{\"1\":{\"428\":1}}],[\"5时\",{\"1\":{\"14\":1}}],[\"579\",{\"1\":{\"5\":1}}],[\"5\",{\"0\":{\"14\":1,\"260\":1},\"1\":{\"3\":1,\"81\":1,\"115\":1,\"131\":3,\"211\":1,\"231\":3,\"274\":1,\"276\":1,\"277\":3,\"278\":2,\"279\":1,\"281\":2,\"299\":1,\"302\":2,\"325\":1,\"328\":2,\"336\":1,\"346\":3,\"347\":1,\"370\":2,\"376\":1,\"413\":1,\"428\":3,\"453\":2,\"460\":1,\"462\":1}}],[\"每轮结束后max就表示这轮比较最大的值坐标\",{\"1\":{\"456\":1}}],[\"每棵树有且只有一个根\",{\"1\":{\"429\":1}}],[\"每隔1s会打印一个kotlin\",{\"1\":{\"328\":1}}],[\"每年最开始的几天和最后的几天的week\",{\"1\":{\"302\":2}}],[\"每执行一个方法就会产生一个栈帧并压入栈中\",{\"1\":{\"252\":1}}],[\"每当需要增长数组或获取数组大小或获取条目值时\",{\"1\":{\"287\":1}}],[\"每当\",{\"1\":{\"157\":1}}],[\"每一项的计算结构都依赖于前一项的计算\",{\"1\":{\"459\":1}}],[\"每一层上的所有结点都有两个子结点二叉树\",{\"1\":{\"443\":1}}],[\"每一轮开始的时候\",{\"1\":{\"289\":1}}],[\"每一个子作业应该通过异常处理机制处理自身的异常\",{\"1\":{\"333\":1}}],[\"每一个\",{\"1\":{\"194\":1}}],[\"每一帧刷新\",{\"1\":{\"168\":1}}],[\"每一帧刷新后\",{\"1\":{\"157\":1}}],[\"每一次比较都可能要交换元素\",{\"1\":{\"289\":1}}],[\"每一次向屏幕添加\",{\"1\":{\"79\":1}}],[\"每一次通过startservice\",{\"1\":{\"17\":1}}],[\"每个数组只有一个元素\",{\"1\":{\"459\":1}}],[\"每个序列包含1\",{\"1\":{\"459\":1}}],[\"每个子数组的有序都依赖于其子数组的有序\",{\"1\":{\"459\":1}}],[\"每个元素都会排好序\",{\"1\":{\"455\":1}}],[\"每个节点保存有父节点和子节点的引用\",{\"1\":{\"451\":1}}],[\"每个节点只有指向下一个节点的引用\",{\"1\":{\"451\":1}}],[\"每个节点都可以有0个或者多个子节点\",{\"1\":{\"429\":1}}],[\"每个堆的节点都满足堆的条件\",{\"1\":{\"439\":1}}],[\"每个顶点出现且只出现一次\",{\"1\":{\"438\":1}}],[\"每个顶点只访问一次\",{\"1\":{\"437\":1}}],[\"每个dao对应一个包装类xxxrepository类供viewmodel使用\",{\"1\":{\"399\":1}}],[\"每个viewmodel有一个xxxviewmodelfactory类\",{\"1\":{\"399\":1}}],[\"每个界面的xml中的布局信息\",{\"1\":{\"399\":1}}],[\"每个http访问对应一个request\",{\"1\":{\"362\":1}}],[\"每个node包含了以下信息\",{\"1\":{\"280\":1}}],[\"每个栈帧frame都有一个当前方法到运行时常量池\",{\"1\":{\"278\":1}}],[\"每个线程每次获取单例都要进入同步锁\",{\"1\":{\"294\":1}}],[\"每个线程都有一个classloader\",{\"1\":{\"272\":1}}],[\"每个线程栈分配的内存越大\",{\"1\":{\"257\":1}}],[\"每个类由加载它的类加载器和类本身确定其唯一性\",{\"1\":{\"272\":1}}],[\"每个页面不能有多个相同tag的hero\",{\"1\":{\"175\":1}}],[\"每个任务是相互独立的\",{\"1\":{\"141\":1}}],[\"每个项目改变都会回调对应的onchange\",{\"1\":{\"78\":1}}],[\"每个进程的输出被当做下一个进程的输入\",{\"1\":{\"58\":1}}],[\"每个渠道有不同的包名\",{\"1\":{\"54\":1}}],[\"每次插入红色节点\",{\"1\":{\"458\":1}}],[\"每次有大的就\",{\"1\":{\"455\":1}}],[\"每次比较当前最大的值\",{\"1\":{\"456\":1}}],[\"每次比较满足条件就会交换\",{\"1\":{\"455\":1}}],[\"每次比较前1~\",{\"1\":{\"455\":1,\"456\":1}}],[\"每次比较最大元素都会\",{\"1\":{\"455\":1}}],[\"每次比较的时候找到的两个数中的较大值并记下其位置\",{\"1\":{\"289\":1}}],[\"每次比较的时候不交换\",{\"1\":{\"289\":1}}],[\"每次选出当前未排序的元素中最大的元素并放到队尾\",{\"1\":{\"455\":1}}],[\"每次从后端rear插入\",{\"1\":{\"452\":1}}],[\"每次弹出优先级最高的元素\",{\"1\":{\"448\":1}}],[\"每次先弹出队首的元素\",{\"1\":{\"447\":1}}],[\"每次前进的步长是根据另外一个hash算法计算出来的值\",{\"1\":{\"428\":1}}],[\"每次前进的步长为当前查找次数的平方\",{\"1\":{\"428\":1}}],[\"每次前进的步长为1\",{\"1\":{\"428\":1}}],[\"每次更新博客时只需要将写好的markdown文档推送到github项目对应目录中\",{\"1\":{\"405\":1}}],[\"每次更新博客内容都需要在更新完markdown文档后\",{\"1\":{\"405\":1}}],[\"每次使用网络请求时只需要选择get\",{\"1\":{\"362\":1}}],[\"每次使用之前检测是否有改权限\",{\"1\":{\"69\":1}}],[\"每次经过特定的延迟都会从该通道进行消费并产生\",{\"1\":{\"328\":1}}],[\"每次新值出来就会取消还没有处理结束的旧流的操作\",{\"1\":{\"327\":1}}],[\"每次写数据时对比当前值与持有值是否一致\",{\"1\":{\"320\":1}}],[\"每次生成的key都是一样的\",{\"1\":{\"296\":1}}],[\"每次gc的时候\",{\"1\":{\"288\":1}}],[\"每次修改hashmap都会叠加\",{\"1\":{\"280\":1}}],[\"每次new\",{\"1\":{\"254\":1}}],[\"每次通过imageprovider\",{\"1\":{\"197\":1}}],[\"每次只能移动最顶端的圆盘\",{\"1\":{\"459\":1}}],[\"每次只能访问栈顶元素top\",{\"1\":{\"452\":1}}],[\"每次只能访问栈顶元素\",{\"1\":{\"446\":1}}],[\"每次只异步读取一部分文本\",{\"1\":{\"111\":1}}],[\"每次只读取\",{\"1\":{\"111\":1}}],[\"每次执行完一个event就执行一次步骤2\",{\"1\":{\"109\":1}}],[\"每次执行完event之后\",{\"1\":{\"109\":1}}],[\"每次执行完毕都会先检查执行micro\",{\"1\":{\"95\":1}}],[\"每次申请权限时更新计数器\",{\"1\":{\"69\":1}}],[\"每次dependency位置发生变化\",{\"1\":{\"55\":1}}],[\"每次重绘都会调用computescroll\",{\"1\":{\"41\":1}}],[\"每次action\",{\"1\":{\"13\":1}}],[\"每次点击事件回调该方法\",{\"1\":{\"13\":1}}],[\"每次都会被调用\",{\"1\":{\"13\":1}}],[\"每十分钟循环一次\",{\"1\":{\"11\":1}}],[\"每\",{\"1\":{\"3\":1}}],[\"每小时一次\",{\"1\":{\"3\":1}}],[\"每天一次\",{\"1\":{\"3\":1}}],[\"每天都要提醒\",{\"1\":{\"3\":1}}],[\"每天在指定时间范围内\",{\"1\":{\"3\":1}}],[\"则子节点必须是黑色\",{\"1\":{\"458\":1}}],[\"则剩下的肯定都小于该元素\",{\"1\":{\"457\":1}}],[\"则推出栈中的元素\",{\"1\":{\"453\":1}}],[\"则压入栈中\",{\"1\":{\"453\":1}}],[\"则它就是满二叉树\",{\"1\":{\"443\":1}}],[\"则它将被挂起直到接收被调用\",{\"1\":{\"328\":1}}],[\"则各个相关元素下标如下\",{\"1\":{\"439\":1}}],[\"则称这两个顶点是邻接的\",{\"1\":{\"433\":1}}],[\"则按照2\",{\"1\":{\"432\":2}}],[\"则按照父级的最小尺寸来\",{\"1\":{\"238\":1}}],[\"则该二叉树称为二叉搜索树\",{\"1\":{\"429\":1}}],[\"则走过一定的步长找到另外一个空位\",{\"1\":{\"428\":1}}],[\"则管理着一个从json读取数据并加载到数据库中的后台任务seeddatabaseworker\",{\"1\":{\"399\":1}}],[\"则优先调用子类方法\",{\"1\":{\"369\":1}}],[\"则押平后为\",{\"1\":{\"327\":1}}],[\"则其他子协程都会被取消\",{\"1\":{\"323\":1}}],[\"则有以下三种实现方式\",{\"1\":{\"322\":1}}],[\"则表示该类group<t>满足\",{\"1\":{\"322\":1}}],[\"则表示view内容向左移动\",{\"1\":{\"41\":1}}],[\"则最后一个变量后为\",{\"1\":{\"321\":1}}],[\"则除了互斥锁的开销外\",{\"1\":{\"320\":1}}],[\"则jvm会将这些锁合并为一个大锁\",{\"1\":{\"320\":1}}],[\"则就有可能发生\",{\"1\":{\"317\":1}}],[\"则很明显2010\",{\"1\":{\"302\":1}}],[\"则objarr1中实际保存的类型\",{\"1\":{\"291\":1}}],[\"则这个对象在所有的线程中还是共享的\",{\"1\":{\"288\":1}}],[\"则这里actualnewpixels最终是越界的pixels\",{\"1\":{\"221\":1}}],[\"则默认的父加载器为appclassloader\",{\"1\":{\"272\":1}}],[\"则\",{\"1\":{\"266\":1,\"325\":1}}],[\"则计数器为空undefined\",{\"1\":{\"255\":1}}],[\"则内容无法滑动\",{\"1\":{\"234\":1}}],[\"则执行完innerdelta之后\",{\"1\":{\"226\":1}}],[\"则只会\",{\"1\":{\"220\":1}}],[\"则只是\",{\"1\":{\"17\":1}}],[\"则根据\",{\"1\":{\"211\":1}}],[\"则将上述序列再次归并\",{\"1\":{\"459\":1}}],[\"则将该点和插入点交换\",{\"1\":{\"457\":1}}],[\"则将a与b交换\",{\"1\":{\"289\":1}}],[\"则将红黑树转化为链表\",{\"1\":{\"280\":1}}],[\"则将链表转化为红黑树\",{\"1\":{\"280\":2}}],[\"则将一个字节数组转化为一个类的实例\",{\"1\":{\"272\":1}}],[\"则将图片绘制到surface中并返回textureid等信息\",{\"1\":{\"211\":1}}],[\"则将图片写入文件缓存\",{\"1\":{\"201\":1}}],[\"则将其转到新的方向\",{\"1\":{\"180\":1}}],[\"则上述步骤又会反向\",{\"1\":{\"171\":1}}],[\"则切换到第二个并不会调用\",{\"1\":{\"159\":1}}],[\"则更新其begin和end值\",{\"1\":{\"150\":1}}],[\"则在图中不存在从b到a的路径\",{\"1\":{\"438\":1}}],[\"则在此分配具体值\",{\"1\":{\"277\":1}}],[\"则在此过程中\",{\"1\":{\"149\":1}}],[\"则在窗户中看到的效果是景色向窗户左边移动\",{\"1\":{\"41\":1}}],[\"则应该使用\",{\"1\":{\"147\":1}}],[\"则是在本文最开始的mplatform提供的线程中进行\",{\"1\":{\"365\":1}}],[\"则是任何可迭代数据都有的用来遍历的方法\",{\"1\":{\"321\":1}}],[\"则是与\",{\"1\":{\"226\":1}}],[\"则是根据\",{\"1\":{\"225\":1}}],[\"则是目录路径等等\",{\"1\":{\"111\":1,\"112\":1}}],[\"则是文件路径\",{\"1\":{\"111\":1,\"112\":1}}],[\"则调用findclass\",{\"1\":{\"272\":1}}],[\"则调用bootstrap\",{\"1\":{\"272\":1}}],[\"则调用\",{\"1\":{\"108\":1}}],[\"则本步也是activity等\",{\"1\":{\"94\":1}}],[\"则不用\",{\"1\":{\"369\":1}}],[\"则不允许这个lambda函数非局部返回\",{\"1\":{\"322\":1}}],[\"则不能和\",{\"1\":{\"87\":1}}],[\"则不会发送\",{\"1\":{\"220\":1}}],[\"则不会有任何影响\",{\"1\":{\"43\":1}}],[\"则不会回调本方法\",{\"1\":{\"13\":1}}],[\"则a\",{\"1\":{\"74\":1}}],[\"则返回的是背景的minimumwidth的值和android\",{\"1\":{\"65\":1}}],[\"则返回的是view的android\",{\"1\":{\"65\":1}}],[\"则返回的是stub\",{\"1\":{\"40\":1}}],[\"则恢复进程2\",{\"1\":{\"58\":1}}],[\"则无法作用到对应的图形\",{\"1\":{\"57\":1}}],[\"则需要在子类定义时传入父类\",{\"1\":{\"369\":1}}],[\"则需要子类自己处理\",{\"1\":{\"155\":1}}],[\"则需要手动关闭这个标志\",{\"1\":{\"65\":1}}],[\"则需要\",{\"1\":{\"55\":1,\"185\":1}}],[\"则需要设置alarmmanager\",{\"1\":{\"6\":1}}],[\"则依赖\",{\"1\":{\"55\":1}}],[\"则取反得到应该插入的位置\",{\"1\":{\"45\":1}}],[\"则取消任务\",{\"1\":{\"12\":1}}],[\"则直接打印\",{\"1\":{\"453\":1}}],[\"则直接插入value\",{\"1\":{\"280\":1}}],[\"则直接覆盖\",{\"1\":{\"45\":1}}],[\"则直接返回服务端的stub对象本身\",{\"1\":{\"40\":1}}],[\"则可以指定流创建的协程上下文\",{\"1\":{\"327\":1}}],[\"则可以根据不同的需要切换不同的livedata\",{\"1\":{\"78\":1}}],[\"则可以更改view的定位\",{\"1\":{\"41\":1}}],[\"则可能出现第三方app没有读写权限而导致操作失败的情况\",{\"1\":{\"2\":1}}],[\"则通知也会被删除\",{\"1\":{\"21\":1}}],[\"则service在应用自己的进程里面运行\",{\"1\":{\"17\":1}}],[\"则整个控件的上下中间显示\",{\"1\":{\"15\":1}}],[\"则阻塞当前进程\",{\"1\":{\"14\":1}}],[\"则又一层层向上返回\",{\"1\":{\"13\":1}}],[\"则会返回null\",{\"1\":{\"328\":1}}],[\"则会挂起直到collect赶上来\",{\"1\":{\"327\":1}}],[\"则会序列化失败notserializableexception\",{\"1\":{\"303\":1}}],[\"则会报错\",{\"1\":{\"230\":1}}],[\"则会先恢复到\",{\"1\":{\"226\":1}}],[\"则会消耗完innerdelta\",{\"1\":{\"226\":1}}],[\"则会再次从网络加载\",{\"1\":{\"198\":1}}],[\"则会展示\",{\"1\":{\"174\":1}}],[\"则会被添加到\",{\"1\":{\"106\":1}}],[\"则会一直返回false\",{\"1\":{\"68\":1}}],[\"则会执行本地对接口\",{\"1\":{\"58\":1}}],[\"则会调用dispatchtransformedtouchevent\",{\"1\":{\"13\":1}}],[\"则会在刚开始的两三次出现间隔时间小于指定时间的情况\",{\"1\":{\"5\":1}}],[\"则闹钟会立即触发\",{\"1\":{\"3\":1}}],[\"请酌情参考\",{\"1\":{\"408\":1}}],[\"请传入null而非color\",{\"1\":{\"184\":1}}],[\"请求操作为\",{\"1\":{\"111\":1}}],[\"请求网络\",{\"0\":{\"78\":1}}],[\"请求系统裁剪并返回图片为例展示对应的适配方法\",{\"1\":{\"2\":1}}],[\"请别人在适当的时候执行\",{\"1\":{\"75\":1}}],[\"请问两种获取屏幕密度的方式有什么区别\",{\"1\":{\"53\":1}}],[\"请参阅选择闹钟类型\",{\"1\":{\"3\":1}}],[\"如依次插入如下值\",{\"1\":{\"458\":1}}],[\"如1\",{\"1\":{\"453\":2}}],[\"如尾端→前端小→大\",{\"1\":{\"453\":1}}],[\"如联网\",{\"1\":{\"404\":1}}],[\"如int\",{\"1\":{\"369\":1}}],[\"如硬盘\",{\"1\":{\"349\":1}}],[\"如如下子树\",{\"1\":{\"346\":1}}],[\"如flow<string>\",{\"1\":{\"340\":1}}],[\"如flow<flow<string>>\",{\"1\":{\"340\":1}}],[\"如list等\",{\"1\":{\"335\":1}}],[\"如配合支持协程的retrofit\",{\"1\":{\"322\":1}}],[\"如每个线程的threadlocal对象\",{\"1\":{\"320\":1}}],[\"如\",{\"1\":{\"299\":1,\"314\":1,\"359\":1,\"428\":1,\"459\":1}}],[\"如下图就是一个完全二叉树\",{\"1\":{\"444\":1}}],[\"如下图就将复制次数从9次减少到了5次\",{\"1\":{\"439\":1}}],[\"如下\",{\"1\":{\"291\":1,\"429\":1}}],[\"如下代码虽然在编译期不会报错\",{\"1\":{\"291\":1}}],[\"如下载等\",{\"1\":{\"17\":1}}],[\"如<t>会被擦除为objet\",{\"1\":{\"290\":1}}],[\"如a\",{\"1\":{\"264\":1,\"450\":1}}],[\"如activitymanager\",{\"1\":{\"60\":1}}],[\"如spring等框架\",{\"1\":{\"259\":1}}],[\"如s\",{\"1\":{\"254\":1}}],[\"如hello\",{\"1\":{\"254\":1}}],[\"如数组\",{\"1\":{\"250\":1}}],[\"如上图所示\",{\"1\":{\"182\":1}}],[\"如上节分析的\",{\"1\":{\"127\":1}}],[\"如何修改环境变量\",{\"1\":{\"412\":1}}],[\"如何监听使用\",{\"1\":{\"193\":1}}],[\"如何获取变化的值\",{\"1\":{\"155\":1}}],[\"如何实现flutter中的动画\",{\"1\":{\"146\":1,\"157\":1}}],[\"如何处理两个图形重合部分的颜色变化\",{\"1\":{\"57\":1}}],[\"如用户点击\",{\"1\":{\"95\":1}}],[\"如dart内部的微任务\",{\"1\":{\"95\":1}}],[\"如dialog\",{\"1\":{\"41\":1}}],[\"如x\",{\"1\":{\"64\":1}}],[\"如图\",{\"1\":{\"55\":1,\"58\":1,\"458\":1,\"459\":1}}],[\"如toast\",{\"1\":{\"41\":1}}],[\"如此反复直到n为1\",{\"1\":{\"460\":1}}],[\"如此反复直到绘制滑动完毕\",{\"1\":{\"41\":1}}],[\"如此便没有发生类型擦除\",{\"1\":{\"322\":1}}],[\"如此可见\",{\"1\":{\"200\":1}}],[\"如此循环直到子view是一个view\",{\"1\":{\"13\":1}}],[\"如内存不足\",{\"1\":{\"19\":1}}],[\"如果x优先于top\",{\"1\":{\"453\":1}}],[\"如果数组和链表都很慢时\",{\"1\":{\"445\":1}}],[\"如果将二叉树每层从左到右遍历\",{\"1\":{\"444\":1}}],[\"如果每次插入时候只保存数据\",{\"1\":{\"442\":1}}],[\"如果每次比较都需要交换数据的话会复制很多次\",{\"1\":{\"439\":1}}],[\"如果右节点比较大\",{\"1\":{\"441\":1}}],[\"如果左节点比较大\",{\"1\":{\"441\":1}}],[\"如果左节点大于本节点则交换\",{\"1\":{\"441\":1}}],[\"如果遇到比max大的\",{\"1\":{\"456\":1}}],[\"如果遇到比当前值top大的就将其复制到当前位置toindex\",{\"1\":{\"441\":1}}],[\"如果遇到优化失效的\",{\"1\":{\"394\":1}}],[\"如果小于则交换\",{\"1\":{\"441\":1}}],[\"如果父节点比插入值小\",{\"1\":{\"440\":1}}],[\"如果父类未初始化\",{\"1\":{\"279\":1}}],[\"如果顶点没有后继点\",{\"1\":{\"438\":1}}],[\"如果2不能满足\",{\"1\":{\"438\":1}}],[\"如果栈不为空\",{\"1\":{\"437\":1}}],[\"如果边被赋予一定的权值\",{\"1\":{\"433\":1}}],[\"如果图的每一条边的权值都互不相同\",{\"1\":{\"438\":1}}],[\"如果图的顶点只能从a→b\",{\"1\":{\"433\":1}}],[\"如果图片还在加载中\",{\"1\":{\"198\":1}}],[\"如果该点没有未访问的邻接点\",{\"1\":{\"438\":1}}],[\"如果该子节点还有右子节点\",{\"1\":{\"432\":1}}],[\"如果该方法返回false才会执行ontouchevent\",{\"1\":{\"13\":1}}],[\"如果二叉树的左子节点的关键字小于该节点\",{\"1\":{\"429\":1}}],[\"如果显示出\",{\"1\":{\"411\":1}}],[\"如果熟悉\",{\"1\":{\"409\":1}}],[\"如果程序调用计数器\",{\"1\":{\"396\":1}}],[\"如果成功运行了就更新上面的缓存\",{\"1\":{\"395\":1}}],[\"如果receiver和已有的缓存类对应\",{\"1\":{\"395\":1}}],[\"如果空闲count\",{\"1\":{\"390\":1}}],[\"如果以上都不满足\",{\"1\":{\"387\":1}}],[\"如果为空再去考虑处理普通消息\",{\"1\":{\"376\":1}}],[\"如果为0表示可以任意超出界限\",{\"1\":{\"220\":1}}],[\"如果命名关键词前面有可变参数\",{\"1\":{\"369\":1}}],[\"如果你不想手动去合并\",{\"1\":{\"347\":1}}],[\"如果本地的版本不是最新的\",{\"1\":{\"347\":1}}],[\"如果推断出的该\",{\"1\":{\"345\":1}}],[\"如果只有这一个参数时\",{\"1\":{\"345\":1}}],[\"如果协程遇到除\",{\"1\":{\"329\":1}}],[\"如果接收先被调用\",{\"1\":{\"328\":1}}],[\"如果发送先被调用\",{\"1\":{\"328\":1}}],[\"如果构建运行的快\",{\"1\":{\"327\":1}}],[\"如果flow的生产和收集很消耗时间时\",{\"1\":{\"327\":1}}],[\"如果future已经完成了\",{\"1\":{\"103\":1}}],[\"如果future是延迟完成的\",{\"1\":{\"103\":1}}],[\"如果强行转换上下文会出错\",{\"1\":{\"327\":1}}],[\"如果使用这个方法更新\",{\"1\":{\"325\":1}}],[\"如果使用默认的\",{\"1\":{\"223\":1}}],[\"如果代码1是启动协程\",{\"1\":{\"323\":1}}],[\"如果enum还有方法或者伴生对象\",{\"1\":{\"321\":1}}],[\"如果中断其运行并运行其他的线程\",{\"1\":{\"320\":1}}],[\"如果其他线程也用到了该数据则可能会出现问题\",{\"1\":{\"317\":1}}],[\"如果包含一个文件描述符filedescriptor\",{\"1\":{\"314\":1}}],[\"如果检测到当前对象是externalizable时\",{\"1\":{\"312\":1}}],[\"如果unshared为false的话\",{\"1\":{\"309\":1}}],[\"如果一个二叉树的层数为k\",{\"1\":{\"443\":1}}],[\"如果一个邻接点再没有未访问的邻接点\",{\"1\":{\"437\":1}}],[\"如果一个类实现了serializable接口\",{\"1\":{\"307\":1}}],[\"如果一个类实现了序列化\",{\"1\":{\"307\":1}}],[\"如果一段代码中有连续的锁\",{\"1\":{\"320\":1}}],[\"如果一开始两个\",{\"1\":{\"159\":1}}],[\"如果采用readresolve实现的话\",{\"1\":{\"305\":1}}],[\"如果依赖readresolve进行实例控制\",{\"1\":{\"305\":1}}],[\"如果依赖于source\",{\"1\":{\"103\":1}}],[\"如果hasreadresolvemethod\",{\"1\":{\"305\":1}}],[\"如果注解中的值不是value\",{\"1\":{\"299\":1}}],[\"如果注册了onclicklistener则会调用其onclick\",{\"1\":{\"13\":1}}],[\"如果注册了onclicklistener会在action\",{\"1\":{\"13\":1}}],[\"如果唯一唤醒的线程阻塞了并依赖其他线程唤醒\",{\"1\":{\"297\":1}}],[\"如果这个对象的writetoparcel方法的输出中有特殊的对象则传递对应的描述代码\",{\"1\":{\"314\":1}}],[\"如果这个threadlocal对象没有被引用\",{\"1\":{\"288\":1}}],[\"如果这二者都未命中缓存则从网络下载图片\",{\"1\":{\"202\":1}}],[\"如果要执行的方法和listener定义的方法返回值类型相同\",{\"1\":{\"345\":1}}],[\"如果要遍历计算java对象大小\",{\"1\":{\"282\":1}}],[\"如果要更新状态\",{\"1\":{\"128\":1}}],[\"如果红黑树数量小于6\",{\"1\":{\"280\":1}}],[\"如果内存空间紧张而对时间效率要求不高\",{\"1\":{\"280\":1}}],[\"如果内存空间很多而又对时间效率要求很高\",{\"1\":{\"280\":1}}],[\"如果类没有静态赋值\",{\"1\":{\"279\":1}}],[\"如果java\",{\"1\":{\"279\":1}}],[\"如果虚拟机栈可以动态扩展\",{\"1\":{\"252\":1}}],[\"如果直接在column上加一个singlechildscrollview作为父级\",{\"1\":{\"242\":1}}],[\"如果直接继承自view的控件必须重写onmeasure\",{\"1\":{\"65\":1}}],[\"如果getdirection\",{\"1\":{\"228\":1}}],[\"如果没法判断则抛出fluttererror\",{\"1\":{\"228\":1}}],[\"如果没有可以访问的邻接点\",{\"1\":{\"438\":1}}],[\"如果没有可用的sendport\",{\"1\":{\"112\":1}}],[\"如果没有指定则锁定对应的类对象或class对象\",{\"1\":{\"317\":1}}],[\"如果没有指定\",{\"1\":{\"304\":1,\"325\":1}}],[\"如果没有加载到再依次经过extention\",{\"1\":{\"272\":1}}],[\"如果没有inner\",{\"1\":{\"226\":1}}],[\"如果没有则调用imageprovider\",{\"1\":{\"196\":1}}],[\"如果没有满足条件的内置显式动画\",{\"1\":{\"156\":1}}],[\"如果没有权限则检测是否需要向用户解释为什么需要该权限activitycompat\",{\"1\":{\"68\":1}}],[\"如果没有\",{\"1\":{\"45\":1}}],[\"如果支持泛型数组\",{\"1\":{\"291\":1}}],[\"如果支持\",{\"1\":{\"226\":1}}],[\"如果inner\",{\"1\":{\"226\":1}}],[\"如果index<0则返回index\",{\"1\":{\"49\":1}}],[\"如果physics支持underscroll会执行underscroll\",{\"1\":{\"226\":1}}],[\"如果physics允许越界返回overscroll是0\",{\"1\":{\"221\":1}}],[\"如果还不行再去执行阻塞操作\",{\"1\":{\"320\":1}}],[\"如果还是没有加载到该类\",{\"1\":{\"272\":1}}],[\"如果还是失败\",{\"1\":{\"201\":1}}],[\"如果还有剩下的overscroll\",{\"1\":{\"226\":1}}],[\"如果还有剩下的\",{\"1\":{\"226\":1}}],[\"如果都没有滑动\",{\"1\":{\"225\":1}}],[\"如果都没有则会尝试执行传入的\",{\"1\":{\"198\":1}}],[\"如果可以overscroll则返回0\",{\"1\":{\"221\":1}}],[\"如果可以更新就更新否则就创建新的element\",{\"1\":{\"126\":1}}],[\"如果向上滑动并且已经overscroll了\",{\"1\":{\"220\":1}}],[\"如果向下滑动\",{\"1\":{\"220\":1}}],[\"如果从网络成功加载图片\",{\"1\":{\"201\":1}}],[\"如果快速滑动会导致\",{\"1\":{\"198\":1}}],[\"如果被监听的话\",{\"1\":{\"197\":1}}],[\"如果被点击了\",{\"1\":{\"64\":1}}],[\"如果想要自己处理序列化的过程\",{\"1\":{\"306\":1}}],[\"如果想要更深入的控制动画\",{\"1\":{\"147\":1}}],[\"如果想随时间变化\",{\"1\":{\"182\":1}}],[\"如果maintainstate为true\",{\"1\":{\"179\":1}}],[\"如果mhashes\",{\"1\":{\"52\":1}}],[\"如果此值不为\",{\"1\":{\"174\":1}}],[\"如果又从\",{\"1\":{\"171\":1}}],[\"如果两个数值相差小于等于此值则认为二者相等\",{\"1\":{\"165\":1}}],[\"如果动画已经结束了\",{\"1\":{\"163\":1}}],[\"如果上述方法仍然无法满足动画需求\",{\"1\":{\"156\":1}}],[\"如果上一步是activity\",{\"1\":{\"94\":1}}],[\"如果a>b\",{\"1\":{\"455\":1}}],[\"如果a<b\",{\"1\":{\"289\":1}}],[\"如果animatedbuilder要创建的一部分内容和动画无关\",{\"1\":{\"156\":1}}],[\"如果asinterface返回本地对象\",{\"1\":{\"58\":1}}],[\"如果listenable改变了则重写添加listener\",{\"1\":{\"155\":1}}],[\"如果需要的话暂停创建好的isolate\",{\"1\":{\"389\":1}}],[\"如果需要缓存时\",{\"1\":{\"201\":1}}],[\"如果需要缓存图片\",{\"1\":{\"201\":1}}],[\"如果需要渐变透明\",{\"1\":{\"184\":1}}],[\"如果需要手动主动控制动画\",{\"1\":{\"154\":1}}],[\"如果需要精确闹钟需要使用\",{\"1\":{\"3\":1}}],[\"如果t<n\",{\"1\":{\"451\":1}}],[\"如果t==n那么查找结束\",{\"1\":{\"451\":1}}],[\"如果tween有效则开始动画\",{\"1\":{\"153\":1}}],[\"如果tween可以开始\",{\"1\":{\"150\":1}}],[\"如果timer的\",{\"1\":{\"106\":1}}],[\"如果collect比生产慢\",{\"1\":{\"327\":1}}],[\"如果column的高度无法在屏幕中完全展示\",{\"1\":{\"234\":1}}],[\"如果class实现了readresolve\",{\"1\":{\"305\":1}}],[\"如果child比singlechildscrollview尺寸大\",{\"1\":{\"238\":1}}],[\"如果child\",{\"1\":{\"238\":1}}],[\"如果child为空\",{\"1\":{\"238\":1}}],[\"如果child的大小比这个maxszie要小的话\",{\"1\":{\"131\":1}}],[\"如果curve变化则创建新的curveanimation\",{\"1\":{\"150\":1}}],[\"如果改变flexible的fit为flexfit\",{\"1\":{\"131\":1}}],[\"如果子widget不是const\",{\"1\":{\"128\":1}}],[\"如果widget是const的\",{\"1\":{\"128\":1}}],[\"如果widgetsbinding\",{\"1\":{\"118\":1}}],[\"如果当前worker数量已经最大了\",{\"1\":{\"390\":1}}],[\"如果当前类没有\",{\"1\":{\"298\":1}}],[\"如果当前\",{\"1\":{\"220\":1}}],[\"如果当前的timer是\",{\"1\":{\"108\":1}}],[\"如果当前viewgroup已经决定拦截事件\",{\"1\":{\"13\":1}}],[\"如果他是第一个timer\",{\"1\":{\"106\":1}}],[\"如果value有空格的话需要用引号包住\",{\"1\":{\"358\":1}}],[\"如果value不是future\",{\"1\":{\"95\":1}}],[\"如果value\",{\"1\":{\"95\":1}}],[\"如果viewgroup需要绘制内容时\",{\"1\":{\"65\":1}}],[\"如果viewgroup判断要拦截该事件\",{\"1\":{\"13\":1}}],[\"如果view有背景\",{\"1\":{\"65\":1}}],[\"如果view没有背景\",{\"1\":{\"65\":1}}],[\"如果view需要多次measure才能确定大小\",{\"1\":{\"65\":1}}],[\"如果view处于不可用状态下\",{\"1\":{\"13\":1}}],[\"如果view注册了ontouchlistener则会先执行montouchlistener\",{\"1\":{\"13\":1}}],[\"如果找到满足条件的顶点\",{\"1\":{\"438\":1}}],[\"如果找到就返回对应的值\",{\"1\":{\"46\":1}}],[\"如果找不到才会再到\",{\"1\":{\"85\":1}}],[\"如果string的长度超过这个范围\",{\"1\":{\"283\":1}}],[\"如果service类是第三方提供的类\",{\"1\":{\"84\":1}}],[\"如果service类的构造方法有变更\",{\"1\":{\"82\":1}}],[\"如果sv>0则操作资源并将信号量\",{\"1\":{\"58\":1}}],[\"如果不满足可以通过以下方式修正\",{\"1\":{\"458\":1}}],[\"如果不行\",{\"1\":{\"320\":1}}],[\"如果不一致则会使反序列化失败\",{\"1\":{\"304\":1}}],[\"如果不同的thread使用的threadlocal变量保存的是同一个引用类型的对象\",{\"1\":{\"288\":1}}],[\"如果不将这个外部类设置为final的话\",{\"1\":{\"281\":1}}],[\"如果不需要缓存或者从缓存中读取\",{\"1\":{\"201\":1}}],[\"如果不止要展示动画\",{\"1\":{\"156\":1}}],[\"如果不是则会抛出\",{\"1\":{\"230\":1}}],[\"如果不是新的则\",{\"1\":{\"153\":1}}],[\"如果不是第一次请求该权限\",{\"1\":{\"69\":1}}],[\"如果不定义的话\",{\"1\":{\"143\":1}}],[\"如果不设置该属性\",{\"1\":{\"17\":1}}],[\"如果透明区域过小\",{\"1\":{\"57\":1}}],[\"如果在间隔还没到的时候调用tickerchannel\",{\"1\":{\"328\":1}}],[\"如果在第一次操作失败到第二次再次尝试操作之间\",{\"1\":{\"319\":1}}],[\"如果在broadcastreceiver\",{\"1\":{\"59\":1}}],[\"如果在这个方法中\",{\"1\":{\"55\":1}}],[\"如果在服务正在前台运行时将其停止\",{\"1\":{\"21\":1}}],[\"如果dependency是要依赖的子view\",{\"1\":{\"55\":1}}],[\"如果它的底部75\",{\"1\":{\"55\":1}}],[\"如果视图只有底部25\",{\"1\":{\"55\":1}}],[\"如果视图是部分可见的\",{\"1\":{\"55\":1}}],[\"如果已有的worker有空闲的或者已经达到最大数目了\",{\"1\":{\"389\":1}}],[\"如果已经越界了\",{\"1\":{\"220\":1}}],[\"如果已经在顶部出现\",{\"1\":{\"220\":1}}],[\"如果已经超出范围\",{\"1\":{\"220\":1}}],[\"如果已经存在hero过渡动画\",{\"1\":{\"180\":1}}],[\"如果已经拦截了\",{\"1\":{\"13\":1}}],[\"如果已存在值则直接覆盖\",{\"1\":{\"45\":1}}],[\"如果key是其他类型则使用arraymap\",{\"1\":{\"44\":1,\"287\":1}}],[\"如果key是基本类型\",{\"1\":{\"44\":1,\"287\":1}}],[\"如果\",{\"1\":{\"43\":1,\"153\":1,\"184\":1,\"198\":4,\"202\":1,\"226\":2}}],[\"如果大量并发或者跨进程调用服务端的方法\",{\"1\":{\"43\":1}}],[\"如果是运算符\",{\"1\":{\"453\":2}}],[\"如果是操作数\",{\"1\":{\"453\":1}}],[\"如果是vm\",{\"1\":{\"387\":1}}],[\"如果是dartdev\",{\"1\":{\"387\":1}}],[\"如果是kernel\",{\"1\":{\"387\":1}}],[\"如果是使用isolate\",{\"1\":{\"384\":1}}],[\"如果是调用isolate\",{\"1\":{\"383\":1}}],[\"如果是externalizable就执行这个\",{\"1\":{\"312\":1}}],[\"如果是serializable就执行这个\",{\"1\":{\"312\":1}}],[\"如果是obecjt类型\",{\"1\":{\"305\":1}}],[\"如果是\",{\"1\":{\"282\":1,\"453\":1}}],[\"如果是不同的key\",{\"1\":{\"280\":1}}],[\"如果是不同的key则先尝试以链表保存数据\",{\"1\":{\"280\":1}}],[\"如果是不同的进程\",{\"1\":{\"40\":1}}],[\"如果是同一个key则覆盖旧的值\",{\"1\":{\"280\":1}}],[\"如果是树\",{\"1\":{\"280\":1}}],[\"如果是链表\",{\"1\":{\"280\":1}}],[\"如果是大量item\",{\"1\":{\"242\":1}}],[\"如果是垂直布局\",{\"1\":{\"238\":1}}],[\"如果是水平布局\",{\"1\":{\"238\":1}}],[\"如果是上述两种axisdirection说明axis是axis\",{\"1\":{\"228\":1}}],[\"如果是启动框架\",{\"1\":{\"119\":1}}],[\"如果是目录\",{\"1\":{\"111\":1,\"112\":1}}],[\"如果是文件\",{\"1\":{\"111\":1,\"112\":1}}],[\"如果是待完成的或者忽略错误的\",{\"1\":{\"103\":1}}],[\"如果是相同的进程\",{\"1\":{\"40\":1}}],[\"如果客户端和服务端运行在不同进程\",{\"1\":{\"36\":1}}],[\"如果客户端和服务端运行在同一进程\",{\"1\":{\"36\":1}}],[\"如果底层没有处理点击事件\",{\"1\":{\"13\":1}}],[\"如果有比插入点大的\",{\"1\":{\"457\":1}}],[\"如果有大的就记录下位置\",{\"1\":{\"456\":1}}],[\"如果有空闲的\",{\"1\":{\"389\":1}}],[\"如果有对象在内部类语句之后构造\",{\"1\":{\"317\":1}}],[\"如果有则抛出异常concurrentmodificationexception\",{\"1\":{\"280\":1}}],[\"如果有则继续相应操作\",{\"1\":{\"68\":1}}],[\"如果有child\",{\"1\":{\"238\":1}}],[\"如果有缓存\",{\"1\":{\"198\":1}}],[\"如果有loadingbuilder就包裹result\",{\"1\":{\"193\":1}}],[\"如果有指定占位widget\",{\"1\":{\"176\":1}}],[\"如果有多个expanded的话\",{\"1\":{\"131\":1}}],[\"如果有micro\",{\"1\":{\"101\":1}}],[\"如果有返回对应index\",{\"1\":{\"49\":1}}],[\"如果有\",{\"1\":{\"45\":1,\"226\":1}}],[\"如果有子view可以处理点击事件\",{\"1\":{\"13\":1}}],[\"如果有能处理点击事件的子view\",{\"1\":{\"13\":1}}],[\"如果设置了montouchlistener的话\",{\"1\":{\"13\":1}}],[\"如果设置的是setinexactrepeating\",{\"1\":{\"6\":1}}],[\"如果触发的时间早于当前系统时间的话\",{\"1\":{\"5\":1}}],[\"如果系统在休眠中则不会唤醒\",{\"1\":{\"4\":1}}],[\"如果您指定的触发时间为过去的时间\",{\"1\":{\"3\":1}}],[\"如你所见\",{\"1\":{\"0\":1}}],[\"而希尔排序在刚开始排序时\",{\"1\":{\"460\":1}}],[\"而插入排序的增量一直是1\",{\"1\":{\"460\":1}}],[\"而每个这样的问题的解决都依赖于other的解决\",{\"1\":{\"459\":1}}],[\"而平衡树则不会\",{\"1\":{\"445\":1}}],[\"而其他的平台的博客限制又太多\",{\"1\":{\"408\":1}}],[\"而其余场景中\",{\"1\":{\"226\":1}}],[\"而做出相应变化\",{\"1\":{\"402\":1}}],[\"而无需投机性优化\",{\"1\":{\"396\":1}}],[\"而无需依赖定时器或持续运行后台服务\",{\"1\":{\"3\":1}}],[\"而网络请求的回调\",{\"1\":{\"365\":1}}],[\"而网络图片由于网速等导致\",{\"1\":{\"198\":1}}],[\"而序列\",{\"1\":{\"335\":1}}],[\"而一个\",{\"1\":{\"334\":1}}],[\"而launchin可以指定其在单独的协程程序中启动流的集合\",{\"1\":{\"328\":1}}],[\"而跳过中间生产的这些值\",{\"1\":{\"327\":1}}],[\"而xx\",{\"1\":{\"321\":1}}],[\"而线程在使用时先从主内存中取到线程私有的工作内存中\",{\"1\":{\"317\":1}}],[\"而只是再次存储一份引用\",{\"1\":{\"309\":1}}],[\"而只能配合view的computescroll\",{\"1\":{\"41\":1}}],[\"而发送方的版本没有这些字段\",{\"1\":{\"306\":1}}],[\"而2010\",{\"1\":{\"302\":1}}],[\"而通过打印这个simpledateformat\",{\"1\":{\"302\":1}}],[\"而通过比较\",{\"1\":{\"43\":1}}],[\"而7表示只有完整的一周都在该年才算该年的第一周\",{\"1\":{\"302\":1}}],[\"而y表示的是week\",{\"1\":{\"302\":1}}],[\"而t2开始执行语句1时\",{\"1\":{\"294\":1}}],[\"而<t\",{\"1\":{\"290\":1}}],[\"而u2是无符号的16位整数\",{\"1\":{\"283\":1}}],[\"而hashmap的长度length又只能是2n\",{\"1\":{\"280\":1}}],[\"而handler消息机制用于同进程的线程间\",{\"1\":{\"60\":1}}],[\"而i\",{\"1\":{\"277\":1}}],[\"而invalidate\",{\"1\":{\"41\":1}}],[\"而defineclass\",{\"1\":{\"272\":1}}],[\"而displaymetrics\",{\"1\":{\"53\":1}}],[\"而expanded又要求占据所有剩余空间从而导致出错\",{\"1\":{\"242\":1}}],[\"而viewport的size则在父级给的最大尺寸内展示一部分child内容\",{\"1\":{\"239\":1}}],[\"而view则只会被drawn一次\",{\"1\":{\"132\":1}}],[\"而因为不管是\",{\"1\":{\"230\":1}}],[\"而最小滑动范围为\",{\"1\":{\"220\":1}}],[\"而后者依赖用户来最终消耗异常\",{\"1\":{\"329\":1}}],[\"而后者又主要负责创建和更新继承自\",{\"1\":{\"213\":1}}],[\"而后者则可以动态改变state从而使flutter改变其状态\",{\"1\":{\"132\":1}}],[\"而对于powerimageloader\",{\"1\":{\"211\":1}}],[\"而对于内存限制较大的android平台来说\",{\"1\":{\"44\":1}}],[\"而使用flowon\",{\"1\":{\"327\":1}}],[\"而使用body提供在填充\",{\"1\":{\"212\":1}}],[\"而使用blankj的工具类\",{\"1\":{\"53\":1}}],[\"而使用\",{\"1\":{\"207\":1,\"223\":1}}],[\"而power\",{\"1\":{\"203\":1}}],[\"而collect读取的慢\",{\"1\":{\"327\":1}}],[\"而componentelement\",{\"1\":{\"128\":1}}],[\"而clinit是类构造器方法\",{\"1\":{\"279\":1}}],[\"而child本身在主轴方向上的尺寸是大于singlechildscrollview的尺寸\",{\"1\":{\"238\":1}}],[\"而cache中没有\",{\"1\":{\"198\":1}}],[\"而此方法内部又是执行\",{\"1\":{\"161\":1}}],[\"而不用保持次数一致\",{\"1\":{\"375\":1}}],[\"而不必在编译时获取该类\",{\"1\":{\"295\":1}}],[\"而不必每次都使用ui\",{\"1\":{\"202\":1}}],[\"而不能保存其子类\",{\"1\":{\"291\":1}}],[\"而不是再次序列化\",{\"1\":{\"309\":1}}],[\"而不是普通的\",{\"1\":{\"233\":1}}],[\"而不是精确的setrepeating\",{\"1\":{\"3\":1}}],[\"而不会影响其他线程分毫\",{\"1\":{\"288\":1}}],[\"而不会\",{\"1\":{\"220\":1}}],[\"而不会走到这里来\",{\"1\":{\"144\":1}}],[\"而reified修饰的类型参数会保证将用户调用时写的类型string同时也写入到被调用的地方\",{\"1\":{\"322\":1}}],[\"而release模式返回的是灰色widget\",{\"1\":{\"143\":1}}],[\"而renderobject则是实际渲染的对象\",{\"1\":{\"128\":1}}],[\"而且如果数组恰好是反序的\",{\"1\":{\"460\":1}}],[\"而且容易出错\",{\"1\":{\"409\":1}}],[\"而且更换电脑后这些环境都需要重新设置一次\",{\"1\":{\"405\":1}}],[\"而且根本不需要切换到不同的上下文\",{\"1\":{\"334\":1}}],[\"而且他还可以判断是否是异常退出\",{\"1\":{\"328\":1}}],[\"而且\",{\"1\":{\"211\":1}}],[\"而且方法的调用和消息的方法可以从任何一方发起\",{\"1\":{\"137\":1}}],[\"而且过渡activity可以展示进度\",{\"1\":{\"14\":1}}],[\"而该方法返回了自定义的productmanagerstate类对象\",{\"1\":{\"134\":1}}],[\"而flexible则会告诉child\",{\"1\":{\"131\":1}}],[\"而如果将最终要移动值保存在临时变量中\",{\"1\":{\"439\":1}}],[\"而如果将其修改为final则保证了局部变量与内部类使用的值是一致的\",{\"1\":{\"281\":1}}],[\"而如果serialversionuid一致\",{\"1\":{\"304\":1}}],[\"而如果我们把第一周最小天数minimaldaysinfirstweek改为5天\",{\"1\":{\"302\":1}}],[\"而如果给\",{\"1\":{\"223\":1}}],[\"而如果没有\",{\"1\":{\"212\":1}}],[\"而如果有特别频繁的cpu计算以至于能导致ui挂起\",{\"1\":{\"136\":1}}],[\"而如果flexible的fit是flexfit\",{\"1\":{\"131\":1}}],[\"而如果更改margin的值\",{\"1\":{\"41\":1}}],[\"而statefulwidget因为有state\",{\"1\":{\"128\":1}}],[\"而switchmap\",{\"1\":{\"78\":1}}],[\"而作为第一次创建的center\",{\"1\":{\"122\":1}}],[\"而newwidget也就是center不为null\",{\"1\":{\"122\":1}}],[\"而notification是一个状态栏的通知\",{\"1\":{\"21\":1}}],[\"而block\",{\"1\":{\"111\":1}}],[\"而结合上面的代码\",{\"1\":{\"100\":1}}],[\"而mainactivitymodule要是需要给activity提供依赖实例所必须的\",{\"1\":{\"91\":1}}],[\"而messenger也是用aidl来实现的\",{\"1\":{\"40\":1}}],[\"而\",{\"1\":{\"87\":2,\"98\":1,\"146\":1,\"156\":1,\"157\":1,\"173\":1,\"182\":1,\"185\":1,\"186\":1,\"207\":2,\"211\":1,\"225\":1,\"226\":1,\"283\":1,\"460\":1}}],[\"而把依赖提供给使用该依赖的对象\",{\"1\":{\"82\":1}}],[\"而是保存一个用来存储这些数据的链表\",{\"1\":{\"428\":1}}],[\"而是经过转化之后的kernel\",{\"1\":{\"392\":1}}],[\"而是随环境切换\",{\"1\":{\"324\":1}}],[\"而是受到当年的第一周\",{\"1\":{\"302\":1}}],[\"而是受到每年的第01周\",{\"1\":{\"302\":1}}],[\"而是\",{\"1\":{\"223\":1}}],[\"而是通过jvm直接创建\",{\"1\":{\"274\":1}}],[\"而是通过他的build方法返回一个可以产生renderobject的widget\",{\"1\":{\"127\":1}}],[\"而是通过element\",{\"1\":{\"119\":1}}],[\"而是将child按照指定的对齐方式进行定位\",{\"1\":{\"124\":1}}],[\"而是在生成内部类的时候将局部变量的引用拷贝了一份到内部类中\",{\"1\":{\"281\":1}}],[\"而是在\",{\"1\":{\"79\":1}}],[\"而是baseline\",{\"1\":{\"64\":1}}],[\"而是从baseline开始绘制\",{\"1\":{\"15\":1}}],[\"而根据\",{\"1\":{\"233\":1}}],[\"而根据这篇文章\",{\"1\":{\"58\":1}}],[\"而根据上图可知\",{\"1\":{\"15\":1}}],[\"而进程接受到信号后可以忽略\",{\"1\":{\"58\":1}}],[\"而系统实际的density是2\",{\"1\":{\"53\":1}}],[\"而在图片完全加载完成之前\",{\"1\":{\"198\":1}}],[\"而在\",{\"1\":{\"178\":1,\"223\":1}}],[\"而在分辨率为2400\",{\"1\":{\"53\":1}}],[\"而在android开发中官方推荐的使用的单位是dp\",{\"1\":{\"53\":1}}],[\"而屏幕的总\",{\"1\":{\"53\":1}}],[\"而保证了数组后面都是deleted或null\",{\"1\":{\"48\":1}}],[\"而非编程的方式\",{\"1\":{\"401\":1}}],[\"而非默认的unicode编码\",{\"1\":{\"371\":1}}],[\"而非新建的对象\",{\"1\":{\"305\":1}}],[\"而非直接复制全局变量的值\",{\"1\":{\"281\":1}}],[\"而非转发到\",{\"1\":{\"223\":1}}],[\"而非flutter\",{\"1\":{\"211\":1}}],[\"而非加载的图片\",{\"1\":{\"193\":1}}],[\"而非在\",{\"1\":{\"184\":1}}],[\"而非\",{\"1\":{\"184\":1,\"411\":1}}],[\"而非接口\",{\"1\":{\"85\":1}}],[\"而非android\",{\"1\":{\"56\":1}}],[\"而非像hashmap那样将其封装为node对象后再保存\",{\"1\":{\"44\":1}}],[\"而非new\",{\"1\":{\"35\":1}}],[\"而这就是递归\",{\"1\":{\"459\":1}}],[\"而这两个值都属于本地化值\",{\"1\":{\"302\":1}}],[\"而这两者又都继承自\",{\"1\":{\"228\":1}}],[\"而这本来是不允许的\",{\"1\":{\"291\":1}}],[\"而这一切都通过他的animate方法实现\",{\"1\":{\"183\":1}}],[\"而这个任务的内容便是开启messagehandler\",{\"1\":{\"391\":1}}],[\"而这个\",{\"1\":{\"216\":1}}],[\"而这个factory就是我们后面要将mainactivitymodule中的依赖实例通过appcomponent传递给mainactivity实例的关键\",{\"1\":{\"91\":1}}],[\"而这个对象\",{\"1\":{\"43\":1}}],[\"而这里的ibinder对象则是通过服务端的messenger的getbinder\",{\"1\":{\"43\":1}}],[\"而这还是我已经发现的有明显谬论的地方\",{\"1\":{\"0\":1}}],[\"您可以安排定期执行操作\",{\"1\":{\"3\":1}}],[\"您可以将它们与广播接收器结合使用\",{\"1\":{\"3\":1}}],[\"您也可以使用它们来触发事件或操作\",{\"1\":{\"3\":1}}],[\"闹钟开始时间早于当前时间\",{\"1\":{\"5\":1}}],[\"闹钟触发的时间\",{\"1\":{\"5\":1}}],[\"闹钟触发的待定\",{\"1\":{\"3\":1}}],[\"闹钟有两个类型\",{\"1\":{\"4\":1}}],[\"闹钟的间隔\",{\"1\":{\"3\":1}}],[\"闹钟类型\",{\"0\":{\"4\":1},\"1\":{\"3\":1}}],[\"闹钟具有以下特征\",{\"1\":{\"3\":1}}],[\"闹钟主要用于在应用程序生命周期之外进行定时操作\",{\"1\":{\"3\":1}}],[\"据android官网介绍\",{\"1\":{\"3\":1}}],[\"精确的时间utc\",{\"1\":{\"4\":1}}],[\"精确的时间\",{\"1\":{\"3\":1}}],[\"相应的操作符族称为联合操作符\",{\"1\":{\"327\":1}}],[\"相应的工作流程概览\",{\"1\":{\"40\":1}}],[\"相同点\",{\"1\":{\"323\":1}}],[\"相同为1\",{\"1\":{\"280\":1}}],[\"相同为0\",{\"1\":{\"280\":2}}],[\"相同的\",{\"1\":{\"170\":1}}],[\"相互比较两个数组每项大小\",{\"1\":{\"459\":1}}],[\"相互循环使用\",{\"1\":{\"265\":1}}],[\"相互之间没有间隙\",{\"1\":{\"241\":1}}],[\"相互借鉴\",{\"1\":{\"0\":1}}],[\"相当于java的set\",{\"1\":{\"369\":1}}],[\"相当于java的map\",{\"1\":{\"369\":1}}],[\"相当于java中的静态类\",{\"1\":{\"321\":1}}],[\"相当于java中的静态方法\",{\"1\":{\"321\":1}}],[\"相当于super\",{\"1\":{\"322\":1}}],[\"相当于extend\",{\"1\":{\"322\":1}}],[\"相当于除以2n\",{\"1\":{\"280\":1}}],[\"相当于乘以2n\",{\"1\":{\"280\":1}}],[\"相当于给他指定了一个约束\",{\"1\":{\"238\":1}}],[\"相当于使用animatable<t>\",{\"1\":{\"186\":1}}],[\"相当于android的setcontentview\",{\"1\":{\"132\":1}}],[\"相反\",{\"1\":{\"55\":1,\"280\":1}}],[\"相比于list等整体执行完毕才进行下一级操作的\",{\"1\":{\"328\":1}}],[\"相比hashmap而言\",{\"1\":{\"44\":1}}],[\"相比之下\",{\"1\":{\"3\":1}}],[\"相对比较轻量\",{\"1\":{\"202\":1}}],[\"相对于使用sliver实现滑动效果的widget来说\",{\"1\":{\"240\":1}}],[\"相对于\",{\"1\":{\"208\":1}}],[\"相对于之前的\",{\"1\":{\"172\":1}}],[\"相对于隐式动画\",{\"1\":{\"155\":1}}],[\"相对于servermanager来说其他和他交互的都是client\",{\"1\":{\"58\":1}}],[\"相对于当前view左上角的坐标\",{\"1\":{\"41\":1}}],[\"相对于手机屏幕原点的坐标\",{\"1\":{\"41\":1}}],[\"相对来说体验也好了很多\",{\"1\":{\"14\":1}}],[\"甚至是heap中的object\",{\"1\":{\"396\":1}}],[\"甚至更加简洁\",{\"1\":{\"345\":1}}],[\"甚至在sun\",{\"1\":{\"253\":1}}],[\"甚至在低版本上workmanager底层也是通过alarmmanager实现的\",{\"1\":{\"3\":1}}],[\"甚至\",{\"1\":{\"211\":1}}],[\"甚至主activity也可以不做改动\",{\"1\":{\"14\":1}}],[\"甚至设备关机重启等情况下也会被执行\",{\"1\":{\"3\":1}}],[\"jxv\",{\"1\":{\"357\":1}}],[\"jcv\",{\"1\":{\"357\":1}}],[\"jetpack官网\",{\"1\":{\"404\":1}}],[\"jetpack官网对jetpack的介绍图\",{\"1\":{\"399\":1}}],[\"jetpack\",{\"1\":{\"400\":1,\"404\":1}}],[\"jetpack是google推出的一系列android软件集合\",{\"1\":{\"399\":1}}],[\"jetbrains\",{\"1\":{\"322\":2}}],[\"jessyan\",{\"1\":{\"53\":2}}],[\"jmm的设计是围绕着原子性\",{\"1\":{\"317\":1}}],[\"jmm\",{\"1\":{\"317\":1}}],[\"jtp01255\",{\"1\":{\"291\":1}}],[\"j+1\",{\"1\":{\"289\":1}}],[\"j++\",{\"1\":{\"289\":2}}],[\"j\",{\"1\":{\"289\":18,\"291\":1,\"306\":1,\"309\":1,\"357\":1,\"462\":4}}],[\"jdk主目录的绝对路径\",{\"1\":{\"348\":3}}],[\"jdk中日期格式化的参数及含义\",{\"1\":{\"302\":1}}],[\"jdk\",{\"1\":{\"288\":1,\"348\":3}}],[\"jdk1\",{\"1\":{\"254\":2,\"279\":1,\"280\":5,\"283\":1,\"287\":1,\"302\":4,\"320\":1}}],[\"jls\",{\"1\":{\"281\":3}}],[\"japan\",{\"1\":{\"321\":2}}],[\"jar和class等\",{\"1\":{\"272\":1}}],[\"jar\",{\"1\":{\"272\":2,\"274\":1,\"282\":8}}],[\"java数据结构和算法\",{\"1\":{\"444\":1,\"451\":1}}],[\"java等类\",{\"1\":{\"420\":1}}],[\"java8\",{\"1\":{\"345\":2}}],[\"java会通过指令重排来优化代码\",{\"1\":{\"317\":1}}],[\"java代码编译成class文件后可以看到\",{\"1\":{\"317\":1}}],[\"java代码如下\",{\"1\":{\"78\":1}}],[\"java多线程编码中\",{\"1\":{\"317\":1}}],[\"java线程安全与volatile和synchronize\",{\"0\":{\"317\":1}}],[\"java之serializable\",{\"1\":{\"316\":1}}],[\"java序列化\",{\"1\":{\"316\":1}}],[\"java周的判断与simpledateformat\",{\"1\":{\"302\":1}}],[\"java默认只要次年的1月1日在在这个跨年周\",{\"1\":{\"302\":1}}],[\"java判断周日期的标准与iso\",{\"1\":{\"302\":1}}],[\"java核心技术点之注解\",{\"1\":{\"301\":1}}],[\"java语言有四个预留的注解\",{\"1\":{\"298\":1}}],[\"java注解\",{\"0\":{\"298\":1},\"1\":{\"301\":1}}],[\"java并发编程笔记\",{\"0\":{\"297\":1}}],[\"java实现aes加密\",{\"1\":{\"296\":1}}],[\"java实现aes加密解密应用\",{\"0\":{\"296\":1}}],[\"java实现hook具体逻辑\",{\"0\":{\"72\":1}}],[\"java反射简单应用\",{\"0\":{\"295\":1}}],[\"javazejian\",{\"1\":{\"294\":1}}],[\"java创建线程安全的单例singleton\",{\"0\":{\"294\":1}}],[\"java编程思想\",{\"1\":{\"293\":1}}],[\"java泛型\",{\"1\":{\"293\":1}}],[\"java为什么不支持泛型数组\",{\"1\":{\"293\":1}}],[\"java为什么匿名内部类的参数引用时final\",{\"1\":{\"281\":1}}],[\"javaworld\",{\"1\":{\"287\":1}}],[\"javap\",{\"1\":{\"285\":1}}],[\"javaagent\",{\"1\":{\"282\":2}}],[\"javaclass\",{\"1\":{\"427\":1}}],[\"javac\",{\"1\":{\"282\":2,\"285\":1,\"348\":3}}],[\"javase\",{\"1\":{\"274\":1,\"281\":1,\"295\":1,\"302\":2}}],[\"javascript\",{\"1\":{\"115\":1}}],[\"java当中的方法只有final\",{\"1\":{\"273\":1}}],[\"java绑定分为静态绑定和动态绑定\",{\"1\":{\"273\":1}}],[\"java动态绑定\",{\"1\":{\"273\":1}}],[\"java未使用\",{\"1\":{\"265\":1}}],[\"java堆溢出\",{\"0\":{\"256\":1}}],[\"java虚拟机栈\",{\"1\":{\"249\":1}}],[\"java用于启动targetintent\",{\"1\":{\"71\":1}}],[\"java层和native\",{\"1\":{\"60\":1}}],[\"java类时实现对监听事件的处理\",{\"1\":{\"56\":1}}],[\"java中实现序列化的方式有\",{\"1\":{\"303\":1}}],[\"java中判断周主要受到calendar对象的getfirstdayofweek\",{\"1\":{\"302\":1}}],[\"java中常见的内建注解\",{\"1\":{\"298\":1}}],[\"java中反射\",{\"1\":{\"295\":1}}],[\"java中的simpledateformat\",{\"1\":{\"302\":1}}],[\"java中的notify和notifyall有什么区别\",{\"1\":{\"297\":1}}],[\"java中的泛型实现了参数类型化的概念\",{\"1\":{\"290\":1}}],[\"java中的泛型\",{\"0\":{\"290\":1}}],[\"java中的utf\",{\"1\":{\"283\":1}}],[\"java中三种常用的排序方法\",{\"0\":{\"289\":1}}],[\"java中hashmap关键字transient的疑惑\",{\"1\":{\"280\":1}}],[\"java中init和clinit区别完全解析\",{\"1\":{\"279\":1}}],[\"java中重写onclick\",{\"1\":{\"56\":1}}],[\"java中\",{\"1\":{\"56\":1,\"263\":1}}],[\"java笔记之序列化与反序列化\",{\"0\":{\"303\":1}}],[\"java笔记之yyyy格式化日期\",{\"0\":{\"302\":1}}],[\"java笔记之threadlocal\",{\"0\":{\"288\":1}}],[\"java笔记之匿名内部类和final\",{\"0\":{\"281\":1}}],[\"java笔记之计算java对象的大小及其应用\",{\"0\":{\"282\":1},\"1\":{\"52\":1}}],[\"java笔记之hashmap保存数据\",{\"0\":{\"280\":1},\"1\":{\"52\":1}}],[\"java这个文件简单分析一下\",{\"1\":{\"40\":1}}],[\"java都放到aidl文件夹下\",{\"1\":{\"32\":1}}],[\"java\",{\"0\":{\"252\":1},\"1\":{\"13\":2,\"17\":2,\"32\":2,\"35\":4,\"36\":3,\"40\":4,\"41\":1,\"43\":3,\"52\":3,\"54\":2,\"56\":2,\"58\":7,\"61\":1,\"64\":4,\"66\":2,\"71\":3,\"79\":3,\"249\":1,\"254\":1,\"272\":2,\"275\":1,\"277\":1,\"279\":4,\"280\":4,\"282\":7,\"283\":1,\"285\":3,\"287\":1,\"291\":1,\"293\":2,\"295\":2,\"297\":1,\"302\":2,\"303\":2,\"306\":3,\"309\":2,\"312\":1,\"316\":3,\"329\":1,\"345\":1,\"348\":4,\"402\":1,\"424\":1,\"427\":3}}],[\"jre\",{\"1\":{\"272\":2}}],[\"jvm会自动取出不必要的锁\",{\"1\":{\"320\":1}}],[\"jvm中的read\",{\"1\":{\"317\":1}}],[\"jvm中gc会根据不同情况采取以下一系列算法组合进行内存回收\",{\"1\":{\"260\":1}}],[\"jvm系列3\",{\"1\":{\"279\":1}}],[\"jvms\",{\"1\":{\"274\":2}}],[\"jvm将文件\",{\"1\":{\"274\":1}}],[\"jvm类加载过程\",{\"1\":{\"279\":1}}],[\"jvm类加载一共7步\",{\"1\":{\"273\":1}}],[\"jvm类加载机制详解\",{\"1\":{\"279\":1}}],[\"jvm类加载机制解析\",{\"0\":{\"273\":1}}],[\"jvm类加载机制之classloader\",{\"0\":{\"272\":1}}],[\"jvm有三种类加载器\",{\"1\":{\"272\":1}}],[\"jvm可以自由实现它\",{\"1\":{\"253\":1}}],[\"jvm区域总体分两类\",{\"1\":{\"249\":1}}],[\"jvm\",{\"1\":{\"249\":2,\"273\":1,\"308\":1}}],[\"jvm高级特性与最佳实践\",{\"1\":{\"249\":1,\"320\":1}}],[\"jvm内存分配\",{\"0\":{\"249\":1}}],[\"jpeg\",{\"1\":{\"188\":1}}],[\"jpg\",{\"1\":{\"58\":2}}],[\"job\",{\"1\":{\"330\":1,\"331\":1}}],[\"jobs\",{\"1\":{\"3\":1}}],[\"jobscheduler\",{\"1\":{\"3\":1}}],[\"jonathan\",{\"1\":{\"291\":1,\"293\":1}}],[\"joindeadworkerslocked\",{\"1\":{\"391\":1}}],[\"joined\",{\"1\":{\"115\":1,\"391\":1}}],[\"join\",{\"1\":{\"115\":1,\"201\":3,\"297\":6,\"391\":6}}],[\"jul\",{\"1\":{\"302\":1}}],[\"july\",{\"1\":{\"302\":1}}],[\"jumpto\",{\"1\":{\"212\":1,\"223\":1,\"225\":1}}],[\"just\",{\"1\":{\"102\":1,\"115\":1,\"133\":1,\"198\":1,\"225\":1,\"392\":1,\"395\":1,\"468\":1}}],[\"juejin\",{\"1\":{\"58\":2,\"59\":1,\"137\":1,\"306\":1}}],[\"js会返回\",{\"1\":{\"378\":1}}],[\"jsonoutput\",{\"1\":{\"371\":1}}],[\"json为后面的客户端做准备\",{\"1\":{\"370\":1}}],[\"json\",{\"1\":{\"136\":1,\"370\":2,\"371\":3,\"415\":1}}],[\"jsonplaceholder\",{\"1\":{\"136\":1}}],[\"js\",{\"1\":{\"61\":1,\"136\":1,\"415\":1}}],[\"jni\",{\"1\":{\"60\":1}}],[\"jit则在性能方面不行\",{\"1\":{\"396\":1}}],[\"jit峰值性能更优\",{\"1\":{\"396\":1}}],[\"jit和aot\",{\"1\":{\"392\":1}}],[\"jit等\",{\"1\":{\"392\":1}}],[\"jit\",{\"1\":{\"387\":1,\"392\":2,\"396\":3}}],[\"jianshu\",{\"1\":{\"15\":1,\"41\":2,\"55\":1,\"59\":1,\"282\":1,\"346\":1}}],[\"jixiaoyong1995\",{\"1\":{\"35\":1,\"36\":1,\"81\":1,\"308\":1,\"407\":1}}],[\"jixiaoyong\",{\"1\":{\"1\":1,\"35\":1,\"36\":1,\"41\":1,\"56\":4,\"61\":1,\"81\":1,\"95\":1,\"172\":1,\"308\":2,\"322\":1,\"367\":1,\"407\":10,\"417\":2}}],[\"b中较大的那个与c按照2的规则比较\",{\"1\":{\"455\":1}}],[\"b→c\",{\"1\":{\"438\":1}}],[\"bfsqueue\",{\"1\":{\"438\":1}}],[\"bfs的思想是\",{\"1\":{\"438\":1}}],[\"bfs\",{\"0\":{\"438\":1},\"1\":{\"436\":1,\"438\":2}}],[\"b调用一次resume即可\",{\"1\":{\"375\":1}}],[\"bs4\",{\"1\":{\"371\":1}}],[\"b忽略最前面的空格\",{\"1\":{\"361\":1}}],[\"b的引用不为0所以无法被回收\",{\"1\":{\"265\":1}}],[\"b的地方\",{\"1\":{\"265\":1}}],[\"b的宽度为0\",{\"1\":{\"74\":1}}],[\"biginteger\",{\"1\":{\"322\":5}}],[\"big\",{\"1\":{\"216\":1,\"242\":1,\"462\":1}}],[\"bitmapdrawable\",{\"1\":{\"211\":2}}],[\"bitmap\",{\"1\":{\"211\":5}}],[\"binaries\",{\"1\":{\"392\":1}}],[\"binarynode\",{\"1\":{\"429\":3,\"430\":1}}],[\"binary先经过tfa收集变量\",{\"1\":{\"396\":1}}],[\"binary中解析的调用\",{\"1\":{\"395\":1}}],[\"binary中的ast中解析产生对应的control\",{\"1\":{\"395\":1}}],[\"binary中读取出了class\",{\"1\":{\"394\":1}}],[\"binary生成machine\",{\"1\":{\"395\":1}}],[\"binary创建il然后转化为machine\",{\"1\":{\"394\":1}}],[\"binary加载到vm中之后\",{\"1\":{\"394\":1}}],[\"binary然后交给main\",{\"1\":{\"393\":1}}],[\"binary\",{\"1\":{\"274\":2,\"276\":1,\"382\":1,\"387\":4,\"392\":2,\"393\":2,\"395\":2,\"396\":1}}],[\"binarysearchhashes\",{\"1\":{\"49\":1}}],[\"binarysearch\",{\"1\":{\"45\":2,\"46\":1,\"47\":1,\"287\":1}}],[\"bin\",{\"1\":{\"100\":1,\"108\":4,\"111\":2,\"112\":3,\"114\":1,\"115\":3,\"305\":1,\"347\":1,\"348\":5,\"349\":2,\"369\":1,\"382\":2,\"387\":2}}],[\"bindviews\",{\"1\":{\"300\":1,\"301\":1}}],[\"bindview\",{\"1\":{\"299\":1,\"300\":5,\"301\":1}}],[\"bindingadapter\",{\"1\":{\"401\":1}}],[\"bindingbase\",{\"1\":{\"118\":4,\"119\":1}}],[\"binding\",{\"1\":{\"117\":1,\"118\":4,\"119\":1,\"120\":1,\"121\":1,\"278\":1,\"401\":2}}],[\"bindinjectorfactory\",{\"1\":{\"91\":1}}],[\"bindunarycallbackguarded<timer>\",{\"1\":{\"104\":1}}],[\"bindcallback\",{\"1\":{\"96\":1}}],[\"bindcallbackguarded\",{\"1\":{\"96\":2,\"104\":1}}],[\"binds要求方法是抽象的\",{\"1\":{\"91\":1}}],[\"binds\",{\"1\":{\"91\":1}}],[\"bindservicedata\",{\"1\":{\"58\":2}}],[\"bindservice\",{\"1\":{\"17\":3,\"19\":1,\"21\":1,\"35\":1,\"58\":1}}],[\"bindwaitforinjectclass\",{\"1\":{\"91\":1}}],[\"bindactivity\",{\"1\":{\"19\":1}}],[\"binder驱动会为这个binder在内核空间创建对应实体节点及其引用\",{\"1\":{\"58\":1}}],[\"binder驱动\",{\"1\":{\"58\":1}}],[\"binder驱动的mmap\",{\"1\":{\"58\":1}}],[\"binder通信主要涉及一下对象\",{\"1\":{\"58\":1}}],[\"binder获取到binder对象的原因\",{\"1\":{\"43\":1}}],[\"binder之应用层总结与分析\",{\"1\":{\"40\":1}}],[\"binderdied\",{\"1\":{\"36\":2,\"38\":1}}],[\"binder\",{\"1\":{\"19\":5,\"36\":3,\"40\":1,\"43\":3,\"58\":3,\"60\":3}}],[\"bind\",{\"1\":{\"17\":1,\"19\":2,\"35\":1,\"58\":1,\"96\":1,\"104\":2}}],[\"bmp\",{\"1\":{\"188\":1}}],[\"btn\",{\"1\":{\"79\":2}}],[\"btn1\",{\"1\":{\"71\":1}}],[\"b宽度分别为父容器的2\",{\"1\":{\"74\":1}}],[\"bg\",{\"1\":{\"66\":1,\"424\":1}}],[\"b为任意正数\",{\"1\":{\"62\":1}}],[\"bc\",{\"1\":{\"61\":1}}],[\"blue\",{\"1\":{\"131\":1}}],[\"blueaccent\",{\"1\":{\"130\":1,\"172\":1}}],[\"blankj使用的resources\",{\"1\":{\"53\":1}}],[\"blob\",{\"1\":{\"41\":1,\"61\":1,\"111\":1,\"115\":1,\"172\":1,\"382\":2}}],[\"blockquotehexo\",{\"1\":{\"413\":1}}],[\"blockingqueue\",{\"1\":{\"328\":1}}],[\"blocked\",{\"1\":{\"327\":1}}],[\"blockdatalong\",{\"1\":{\"305\":1}}],[\"blockdata\",{\"1\":{\"305\":1}}],[\"blocksize大小的内容\",{\"1\":{\"111\":1}}],[\"blocksize\",{\"1\":{\"111\":2}}],[\"blocks\",{\"1\":{\"111\":1,\"396\":1}}],[\"block\",{\"1\":{\"15\":1,\"25\":1,\"111\":1,\"327\":1,\"383\":2}}],[\"blog\",{\"1\":{\"15\":3,\"35\":1,\"40\":1,\"41\":1,\"54\":2,\"58\":8,\"59\":1,\"63\":1,\"87\":2,\"115\":1,\"273\":1,\"279\":1,\"283\":1,\"287\":1,\"288\":1,\"294\":1,\"367\":5,\"407\":4,\"414\":3,\"417\":4,\"419\":4}}],[\"b\",{\"1\":{\"36\":1,\"58\":2,\"62\":2,\"78\":3,\"171\":14,\"173\":2,\"174\":3,\"265\":2,\"289\":2,\"322\":4,\"327\":2,\"344\":2,\"375\":1,\"459\":1}}],[\"bypasses\",{\"1\":{\"382\":1}}],[\"bytecontent\",{\"1\":{\"296\":2}}],[\"byte\",{\"1\":{\"282\":2,\"296\":9,\"299\":1,\"308\":1}}],[\"bytearr\",{\"1\":{\"272\":3}}],[\"bytearray\",{\"1\":{\"272\":1}}],[\"byteoutputstream\",{\"1\":{\"272\":1}}],[\"bytebuffer\",{\"1\":{\"272\":3}}],[\"bytedata\",{\"1\":{\"194\":1}}],[\"bytes的对象头+引用\",{\"1\":{\"283\":1}}],[\"bytesbuilder\",{\"1\":{\"111\":1}}],[\"bytes\",{\"1\":{\"108\":2,\"111\":9,\"115\":1,\"196\":2,\"272\":5,\"282\":8,\"283\":5,\"285\":4,\"287\":14}}],[\"byhavior\",{\"1\":{\"55\":1}}],[\"by\",{\"1\":{\"35\":1,\"36\":2,\"58\":1,\"95\":5,\"105\":1,\"106\":1,\"111\":1,\"115\":5,\"120\":1,\"136\":1,\"143\":1,\"147\":1,\"180\":1,\"193\":1,\"226\":1,\"280\":1,\"288\":1,\"297\":1,\"303\":1,\"312\":1,\"322\":7,\"326\":1,\"328\":2,\"369\":1,\"372\":1,\"381\":1,\"386\":1,\"391\":2,\"392\":1,\"395\":1,\"407\":1,\"426\":1}}],[\"become\",{\"1\":{\"396\":1}}],[\"becomes\",{\"1\":{\"387\":2}}],[\"because\",{\"1\":{\"45\":1,\"98\":1,\"105\":1,\"115\":1,\"153\":1,\"193\":1,\"198\":1,\"216\":1,\"287\":1,\"382\":1}}],[\"beautifulsoup\",{\"1\":{\"371\":3}}],[\"belong\",{\"1\":{\"308\":2,\"309\":2}}],[\"belonging\",{\"1\":{\"306\":1}}],[\"below\",{\"1\":{\"125\":1,\"198\":1,\"220\":2,\"383\":1}}],[\"between\",{\"1\":{\"118\":1,\"119\":1,\"147\":2,\"179\":1,\"184\":1,\"302\":1,\"392\":1}}],[\"beta\",{\"1\":{\"54\":5,\"137\":1}}],[\"beginactivity\",{\"0\":{\"225\":1},\"1\":{\"225\":5,\"226\":1}}],[\"begin和end可以为空\",{\"1\":{\"184\":1}}],[\"beginning\",{\"1\":{\"184\":1}}],[\"beginners\",{\"1\":{\"140\":1}}],[\"begin\",{\"1\":{\"149\":1,\"152\":1,\"153\":4,\"166\":4,\"177\":4,\"178\":3,\"181\":1,\"184\":9,\"185\":1}}],[\"begins\",{\"1\":{\"115\":1}}],[\"beginbroadcast\",{\"1\":{\"36\":1}}],[\"benefit\",{\"1\":{\"115\":1}}],[\"been\",{\"1\":{\"80\":1,\"100\":1,\"102\":2,\"109\":1,\"111\":1,\"121\":1,\"176\":1,\"179\":1,\"180\":1,\"196\":1,\"198\":1,\"211\":1,\"221\":1,\"378\":1,\"383\":2,\"391\":2}}],[\"behalf\",{\"1\":{\"75\":1}}],[\"behavior<t>\",{\"1\":{\"55\":1}}],[\"behavior\",{\"1\":{\"55\":7,\"178\":1}}],[\"behavior=\",{\"1\":{\"55\":3}}],[\"bezierpaint\",{\"1\":{\"63\":1}}],[\"bezierpath\",{\"1\":{\"63\":4}}],[\"bezier\",{\"1\":{\"61\":1,\"63\":1}}],[\"beziermaker\",{\"1\":{\"61\":1}}],[\"bezierviewanim\",{\"1\":{\"61\":1}}],[\"beforepointf\",{\"1\":{\"62\":2}}],[\"before\",{\"1\":{\"49\":1,\"65\":1,\"98\":1,\"105\":1,\"108\":1,\"109\":1,\"115\":5,\"180\":2,\"202\":1,\"281\":1,\"288\":2,\"297\":1,\"308\":1,\"327\":1,\"376\":2,\"383\":2,\"389\":1,\"391\":4}}],[\"being\",{\"1\":{\"15\":2,\"212\":1}}],[\"be\",{\"1\":{\"15\":1,\"24\":1,\"36\":1,\"49\":1,\"61\":1,\"75\":1,\"80\":2,\"87\":1,\"96\":1,\"97\":1,\"100\":1,\"101\":1,\"103\":4,\"104\":2,\"106\":1,\"107\":1,\"109\":1,\"111\":2,\"115\":9,\"118\":2,\"125\":1,\"126\":1,\"131\":2,\"147\":1,\"153\":1,\"156\":1,\"176\":1,\"177\":1,\"179\":1,\"181\":1,\"185\":1,\"186\":1,\"193\":1,\"198\":2,\"209\":2,\"212\":1,\"216\":1,\"220\":5,\"225\":1,\"226\":1,\"234\":1,\"242\":1,\"275\":1,\"276\":2,\"281\":3,\"287\":2,\"308\":2,\"309\":2,\"327\":2,\"328\":1,\"364\":1,\"373\":1,\"382\":1,\"383\":2,\"387\":4,\"389\":1,\"391\":1,\"392\":1,\"396\":3,\"426\":1}}],[\"branch\",{\"1\":{\"347\":3,\"419\":1}}],[\"bridge\",{\"1\":{\"120\":1}}],[\"breach\",{\"1\":{\"102\":1}}],[\"break\",{\"1\":{\"13\":1,\"56\":2,\"65\":2,\"72\":1,\"80\":2,\"115\":1,\"179\":2,\"181\":2,\"272\":1,\"278\":1,\"289\":1,\"297\":1,\"391\":5,\"438\":2,\"441\":3,\"451\":1,\"453\":5,\"457\":1,\"462\":1,\"467\":1}}],[\"browser\",{\"1\":{\"60\":1}}],[\"broadcast\",{\"1\":{\"10\":1,\"11\":1}}],[\"broadcast等等\",{\"1\":{\"7\":1}}],[\"broadcastreceiver\",{\"1\":{\"3\":1,\"58\":1}}],[\"bodies\",{\"1\":{\"395\":1}}],[\"body内部没有scrolling\",{\"1\":{\"226\":1}}],[\"body部分\",{\"1\":{\"213\":1}}],[\"bodyisscrolled\",{\"1\":{\"213\":2}}],[\"body必须是能产生renderbox的widget\",{\"1\":{\"212\":1}}],[\"bodystate\",{\"1\":{\"131\":2}}],[\"bodywidget\",{\"1\":{\"131\":2,\"143\":1}}],[\"body\",{\"1\":{\"111\":2,\"132\":1,\"135\":1,\"136\":1,\"143\":1,\"212\":8,\"213\":9,\"223\":7,\"225\":1,\"226\":5,\"281\":1,\"345\":1,\"365\":2}}],[\"both\",{\"1\":{\"327\":1,\"391\":1}}],[\"bottomleft\",{\"1\":{\"170\":2}}],[\"bottom值\",{\"1\":{\"41\":1}}],[\"bottom的值并不会变化\",{\"1\":{\"41\":1}}],[\"bottom分别是view右下角顶点的x轴\",{\"1\":{\"41\":1}}],[\"bottom\",{\"1\":{\"15\":2,\"181\":2,\"212\":1,\"440\":3}}],[\"bout\",{\"1\":{\"309\":2,\"312\":3}}],[\"bouncingscrollphysics\",{\"1\":{\"226\":3}}],[\"boundingboxfor\",{\"1\":{\"177\":3}}],[\"bound\",{\"1\":{\"136\":1}}],[\"boundcallback\",{\"1\":{\"104\":2}}],[\"bounds里面保存着要画的字的一些属性\",{\"1\":{\"64\":1}}],[\"bounds\",{\"1\":{\"13\":1,\"64\":3}}],[\"bold\",{\"1\":{\"126\":1}}],[\"boldtextoverride\",{\"1\":{\"126\":1}}],[\"boxing\",{\"1\":{\"287\":1}}],[\"boxhittestresult\",{\"1\":{\"240\":2}}],[\"boxconstraints\",{\"1\":{\"238\":3,\"241\":2,\"242\":2}}],[\"boxscrollview\",{\"1\":{\"233\":1}}],[\"boxfit\",{\"1\":{\"206\":1}}],[\"boxdecoration\",{\"1\":{\"188\":1}}],[\"boxpainter\",{\"1\":{\"188\":1}}],[\"box\",{\"1\":{\"117\":1,\"176\":4,\"212\":1,\"227\":1,\"230\":1,\"233\":2,\"234\":1}}],[\"bool\",{\"1\":{\"96\":1,\"98\":1,\"102\":1,\"103\":3,\"105\":2,\"111\":2,\"115\":12,\"119\":1,\"130\":1,\"149\":3,\"161\":1,\"164\":1,\"165\":1,\"167\":1,\"175\":1,\"176\":3,\"179\":1,\"180\":1,\"181\":1,\"191\":1,\"192\":1,\"198\":2,\"201\":3,\"202\":1,\"209\":2,\"213\":1,\"223\":1,\"224\":1,\"225\":1,\"230\":1,\"240\":1,\"378\":17,\"381\":1,\"382\":2,\"383\":6,\"387\":4,\"389\":12,\"391\":6}}],[\"boolean>\",{\"1\":{\"287\":1}}],[\"boolean\",{\"1\":{\"13\":16,\"21\":1,\"24\":1,\"30\":2,\"36\":1,\"40\":1,\"42\":1,\"44\":1,\"49\":1,\"55\":3,\"58\":1,\"65\":1,\"72\":1,\"78\":1,\"211\":5,\"272\":1,\"287\":1,\"299\":1,\"305\":2,\"309\":1,\"401\":2}}],[\"bootstarp\",{\"1\":{\"419\":1}}],[\"bootstrap\",{\"1\":{\"272\":1,\"383\":1}}],[\"boot\",{\"1\":{\"9\":1,\"60\":3,\"349\":1}}],[\"bad\",{\"1\":{\"382\":1}}],[\"bababbaab\",{\"1\":{\"322\":1}}],[\"ballisticscrollactivity\",{\"1\":{\"225\":2}}],[\"ballistic\",{\"1\":{\"225\":2}}],[\"bashrc\",{\"1\":{\"361\":4}}],[\"bash\",{\"1\":{\"357\":2,\"361\":4}}],[\"bash是用户和内容交互的桥梁\",{\"1\":{\"357\":1}}],[\"basic\",{\"1\":{\"122\":2,\"127\":1}}],[\"bassy的博客\",{\"1\":{\"116\":1}}],[\"basewirehandle\",{\"1\":{\"309\":1}}],[\"baseline的竖坐标和文字上下实际中心的偏移量\",{\"1\":{\"15\":1}}],[\"baseline的y坐标\",{\"1\":{\"15\":1}}],[\"baseline\",{\"1\":{\"15\":2}}],[\"based\",{\"1\":{\"15\":1,\"396\":1}}],[\"base\",{\"1\":{\"13\":1,\"14\":2,\"43\":1,\"52\":6,\"297\":2}}],[\"baidu\",{\"1\":{\"54\":5,\"63\":1,\"362\":2}}],[\"bar\",{\"1\":{\"53\":1,\"56\":2}}],[\"barutils\",{\"1\":{\"53\":1}}],[\"baeseline\",{\"1\":{\"15\":1}}],[\"backed\",{\"1\":{\"387\":1}}],[\"backup\",{\"1\":{\"367\":2}}],[\"backingarray是一个\",{\"1\":{\"291\":1}}],[\"backingarray的类型实际上就是\",{\"1\":{\"291\":1}}],[\"backingarray时没有产生\",{\"1\":{\"291\":1}}],[\"backingarray\",{\"1\":{\"291\":2}}],[\"backgrounddimenabled\",{\"1\":{\"66\":1}}],[\"backgrounddimenabled则可以去除半透明遮罩效果\",{\"1\":{\"66\":1}}],[\"background=\",{\"1\":{\"66\":1,\"79\":2}}],[\"backgroundrectf\",{\"1\":{\"65\":2}}],[\"background\",{\"1\":{\"65\":1,\"136\":1,\"396\":1}}],[\"back\",{\"1\":{\"13\":2,\"65\":1,\"111\":1,\"112\":1,\"179\":1,\"180\":1,\"389\":1}}],[\"backwards\",{\"1\":{\"3\":1}}],[\"batch\",{\"1\":{\"3\":1}}],[\"battery\",{\"1\":{\"3\":1}}],[\"bug\",{\"1\":{\"389\":1}}],[\"buzz\",{\"1\":{\"334\":3}}],[\"buy\",{\"1\":{\"299\":1}}],[\"bubblesort\",{\"1\":{\"455\":1}}],[\"bubble\",{\"1\":{\"289\":2}}],[\"buckets\",{\"1\":{\"280\":2}}],[\"built经过处理后赋值给element的\",{\"1\":{\"126\":1}}],[\"built\",{\"1\":{\"126\":5,\"128\":4,\"180\":1,\"387\":1}}],[\"buildcall\",{\"1\":{\"365\":1}}],[\"buildcontext\",{\"1\":{\"120\":1,\"122\":2,\"126\":2,\"127\":1,\"130\":6,\"131\":1,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"143\":1,\"152\":1,\"153\":2,\"154\":1,\"155\":2,\"156\":2,\"172\":1,\"175\":1,\"176\":1,\"177\":2,\"178\":1,\"180\":5,\"181\":2,\"188\":1,\"193\":1,\"205\":1,\"206\":2,\"207\":2,\"212\":1,\"213\":3,\"227\":3,\"228\":5,\"233\":3,\"235\":2,\"236\":2,\"241\":1,\"242\":1}}],[\"buildrequest\",{\"1\":{\"364\":2}}],[\"buildrequestbody\",{\"1\":{\"364\":1}}],[\"buildtree\",{\"1\":{\"346\":4}}],[\"buildtypes\",{\"1\":{\"14\":1}}],[\"buildviewport\",{\"0\":{\"228\":1},\"1\":{\"227\":2,\"228\":3}}],[\"buildviewportchrome创建蓝色波纹效果\",{\"1\":{\"221\":1}}],[\"buildslivers的主轴尺寸为header的scrollextent+viewport主轴尺寸\",{\"1\":{\"213\":1}}],[\"buildslivers\",{\"0\":{\"233\":1},\"1\":{\"213\":4,\"226\":1,\"227\":4,\"233\":4}}],[\"buildscope\",{\"1\":{\"121\":1}}],[\"build源码可以确定\",{\"1\":{\"207\":1}}],[\"buildimage\",{\"1\":{\"206\":2}}],[\"buildoverscrollindicator\",{\"1\":{\"221\":1}}],[\"buildoverlay创建的过渡\",{\"1\":{\"181\":1}}],[\"buildoverlay的样式\",{\"1\":{\"181\":1}}],[\"buildoverlay\",{\"1\":{\"181\":4}}],[\"buildowner在widgetsbinding\",{\"1\":{\"119\":1}}],[\"buildowner\",{\"1\":{\"117\":1,\"119\":1,\"121\":1,\"122\":2,\"125\":1,\"126\":1}}],[\"buildowner之类的字段\",{\"1\":{\"117\":1}}],[\"buildwidgetapp\",{\"1\":{\"178\":1}}],[\"build$\",{\"1\":{\"130\":2}}],[\"build方法中的\",{\"1\":{\"221\":1}}],[\"build方法中\",{\"1\":{\"200\":1}}],[\"build方法中被传入rawimage\",{\"1\":{\"195\":1}}],[\"build方法中创建rawimage\",{\"1\":{\"189\":1}}],[\"build方法获得的ui\",{\"1\":{\"194\":1}}],[\"build方法创建widget\",{\"1\":{\"155\":1}}],[\"build方法\",{\"1\":{\"126\":1}}],[\"builder的子类\",{\"1\":{\"404\":1}}],[\"builder对象生成对应的request\",{\"1\":{\"364\":1}}],[\"builder用于生成request\",{\"1\":{\"364\":1}}],[\"builder会返回错误详细信息fluttererrordetails\",{\"1\":{\"143\":1}}],[\"builder返回一个widget替代出错的widget\",{\"1\":{\"143\":1}}],[\"builder<mainfragment>\",{\"1\":{\"94\":1}}],[\"builder<mainactivity>\",{\"1\":{\"90\":1}}],[\"builder实例生成了一个androidinjector\",{\"1\":{\"91\":1}}],[\"builder\",{\"0\":{\"143\":1},\"1\":{\"69\":2,\"84\":1,\"90\":3,\"91\":2,\"111\":3,\"126\":1,\"131\":1,\"143\":2,\"153\":3,\"156\":8,\"170\":1,\"181\":2,\"213\":2,\"241\":1,\"242\":1,\"362\":2,\"364\":1}}],[\"build>generate\",{\"1\":{\"54\":1}}],[\"build\",{\"0\":{\"193\":1},\"1\":{\"2\":4,\"14\":2,\"40\":1,\"54\":4,\"81\":2,\"84\":1,\"126\":5,\"128\":9,\"130\":6,\"131\":1,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"140\":1,\"141\":1,\"143\":1,\"152\":2,\"153\":2,\"154\":1,\"155\":5,\"156\":2,\"172\":1,\"176\":1,\"178\":1,\"184\":1,\"193\":2,\"198\":1,\"205\":1,\"206\":1,\"207\":3,\"212\":1,\"213\":2,\"226\":1,\"227\":2,\"233\":2,\"235\":1,\"362\":3,\"363\":2,\"364\":4,\"383\":2}}],[\"buffer为null\",{\"1\":{\"387\":1}}],[\"buffer\",{\"1\":{\"327\":3,\"344\":1,\"379\":1,\"382\":1,\"383\":7,\"384\":2,\"387\":19}}],[\"buf\",{\"1\":{\"108\":2,\"296\":3}}],[\"but\",{\"1\":{\"97\":1,\"102\":1,\"103\":1,\"131\":1,\"180\":1,\"181\":1,\"198\":2,\"202\":1,\"220\":1,\"225\":1,\"230\":1,\"242\":1,\"276\":1,\"281\":2,\"287\":1,\"294\":1,\"322\":2,\"347\":1,\"391\":1}}],[\"button\",{\"1\":{\"13\":1,\"71\":1,\"79\":7,\"130\":1}}],[\"bundle\",{\"1\":{\"1\":1,\"20\":5,\"43\":1,\"79\":1,\"93\":1,\"211\":1}}],[\"还保存着下一个节点的引用next\",{\"1\":{\"451\":1}}],[\"还使用了parent\",{\"1\":{\"387\":1}}],[\"还可以有\",{\"1\":{\"467\":1}}],[\"还可以进行堆排序\",{\"1\":{\"439\":1}}],[\"还可以对\",{\"1\":{\"403\":1}}],[\"还可以将viewmodel于livedata结合\",{\"1\":{\"402\":1}}],[\"还可以更简洁\",{\"1\":{\"345\":1}}],[\"还可以使用objectoutputstream的putfields\",{\"1\":{\"306\":1}}],[\"还可以使用\",{\"1\":{\"153\":1,\"156\":1}}],[\"还用it代替\",{\"1\":{\"345\":1}}],[\"还应用了scrollposition改变而变化的\",{\"1\":{\"239\":1}}],[\"还改动了extendedimageprovider\",{\"1\":{\"202\":1}}],[\"还没有加载完成的\",{\"1\":{\"197\":1}}],[\"还提供了\",{\"1\":{\"175\":1}}],[\"还提供了如下方法\",{\"1\":{\"161\":1}}],[\"还希望能够控制动画开始\",{\"1\":{\"156\":1}}],[\"还调用了componentelement\",{\"1\":{\"126\":1}}],[\"还会执行\",{\"1\":{\"201\":1}}],[\"还会是live的\",{\"1\":{\"197\":1}}],[\"还会触发\",{\"1\":{\"121\":1}}],[\"还会调用的element\",{\"1\":{\"121\":1}}],[\"还会缩减数组的大小为osize\",{\"1\":{\"52\":1}}],[\"还多出来好几个widget\",{\"1\":{\"117\":1}}],[\"还需要使用其返回值供自己使用\",{\"1\":{\"322\":1}}],[\"还需要\",{\"1\":{\"213\":1}}],[\"还需要注意一个新的角色buildowner\",{\"1\":{\"119\":1}}],[\"还需要添加一个\",{\"1\":{\"79\":1}}],[\"还需要告诉as将这些类添加到主dex文件中\",{\"1\":{\"14\":1}}],[\"还要留出接口\",{\"1\":{\"64\":1}}],[\"还映射进了内核空间\",{\"1\":{\"58\":1}}],[\"还有递归在汉诺塔问题上的应用\",{\"1\":{\"459\":1}}],[\"还有其他邻接点\",{\"1\":{\"438\":1}}],[\"还有其他的代码要执行\",{\"1\":{\"322\":1}}],[\"还有个计数器\",{\"1\":{\"395\":1}}],[\"还有轻量级锁的开销\",{\"1\":{\"320\":1}}],[\"还有android\",{\"1\":{\"287\":1}}],[\"还有以下可以替换hashmap的\",{\"1\":{\"287\":1}}],[\"还有以下几类方法内部也是基于\",{\"1\":{\"161\":1}}],[\"还有用户自定义的类加载器\",{\"1\":{\"272\":1}}],[\"还有剩下的\",{\"1\":{\"226\":1}}],[\"还有几个属性可以供我们自定义\",{\"1\":{\"174\":1}}],[\"还有如下子类\",{\"1\":{\"159\":1}}],[\"还有就是该挂件的布局文件\",{\"1\":{\"79\":1}}],[\"还有一种可能就是序列化流被篡改了\",{\"1\":{\"306\":1}}],[\"还有一种方法\",{\"1\":{\"54\":1}}],[\"还有一部分同样重要的流程\",{\"1\":{\"195\":1}}],[\"还有一个链接两个\",{\"1\":{\"183\":1}}],[\"还有一个非常重要的问题\",{\"1\":{\"85\":1}}],[\"还有一个独有的ipc方式即binder\",{\"1\":{\"40\":1}}],[\"还有一点需注意\",{\"1\":{\"55\":1}}],[\"还有最近的workmanager和我们要用到的alarmmanager\",{\"1\":{\"3\":1}}],[\"还是为他们写一个索引文章\",{\"1\":{\"398\":1}}],[\"还是runlightweight\",{\"1\":{\"389\":1}}],[\"还是isolate\",{\"1\":{\"378\":1}}],[\"还是有异常发生\",{\"1\":{\"343\":1}}],[\"还是使用枚举\",{\"1\":{\"305\":1}}],[\"还是第三方的extende\",{\"1\":{\"203\":1}}],[\"还是相反\",{\"1\":{\"172\":1}}],[\"还是character\",{\"1\":{\"111\":1}}],[\"还是\",{\"1\":{\"106\":1,\"109\":1,\"178\":1,\"186\":1,\"223\":1,\"228\":1,\"230\":2}}],[\"还是会出现同一dp在有些屏幕上刚好占满全屏\",{\"1\":{\"53\":1}}],[\"还是由子view消耗该事件\",{\"1\":{\"13\":1}}],[\"还是裁剪之后保存的图片都给第三方app赋予了权限\",{\"1\":{\"2\":1}}],[\"拆分需求\",{\"1\":{\"3\":1}}],[\"需判断\",{\"1\":{\"225\":1}}],[\"需求刚好需要用到这些功能的话\",{\"1\":{\"202\":1}}],[\"需求需要实现\",{\"1\":{\"3\":1}}],[\"需要对先对当前节点的父节点进行右旋\",{\"1\":{\"458\":1}}],[\"需要对堆进行向上或向下的遍历\",{\"1\":{\"439\":1}}],[\"需要一个堆的数据结构\",{\"1\":{\"449\":1}}],[\"需要辅助存储空间\",{\"1\":{\"449\":1}}],[\"需要二者有相同的shareduserid\",{\"1\":{\"421\":1}}],[\"需要androidx\",{\"1\":{\"400\":1}}],[\"需要重新判断\",{\"1\":{\"394\":1}}],[\"需要重写的方法有\",{\"1\":{\"55\":2}}],[\"需要单独下载\",{\"1\":{\"371\":1}}],[\"需要手动调用\",{\"1\":{\"369\":1}}],[\"需要系统支持该格式\",{\"1\":{\"368\":1}}],[\"需要系统权限\",{\"1\":{\"41\":1}}],[\"需要满足三个条件\",{\"1\":{\"322\":1}}],[\"需要自己实现对象的序列化内容\",{\"1\":{\"316\":1}}],[\"需要自己实现具体细节\",{\"1\":{\"303\":2}}],[\"需要获得本地的密钥\",{\"1\":{\"306\":1}}],[\"需要给出对应的值的名字\",{\"1\":{\"299\":1}}],[\"需要先初始化对应的类\",{\"1\":{\"279\":1}}],[\"需要先初始化主类\",{\"1\":{\"279\":1}}],[\"需要传入\",{\"1\":{\"233\":1}}],[\"需要判断是否此widget是否有directionality可以用来判断文本布局方向\",{\"1\":{\"228\":1}}],[\"需要处理一下\",{\"1\":{\"211\":1}}],[\"需要\",{\"1\":{\"185\":1}}],[\"需要使用者自己创建\",{\"1\":{\"146\":1,\"157\":1}}],[\"需要的话安排一次frame\",{\"1\":{\"119\":1}}],[\"需要用到expanded\",{\"1\":{\"242\":1}}],[\"需要用\",{\"1\":{\"79\":1}}],[\"需要请求权限\",{\"1\":{\"78\":1}}],[\"需要解释为什么需要这个权限\",{\"1\":{\"69\":1}}],[\"需要说明的是\",{\"1\":{\"68\":1,\"324\":1}}],[\"需要指定其behavior\",{\"1\":{\"55\":1}}],[\"需要更深入了解原理可以阅读文末参考文献\",{\"1\":{\"53\":1}}],[\"需要在加载图片之前\",{\"1\":{\"211\":1}}],[\"需要在服务端实现\",{\"1\":{\"40\":1}}],[\"需要在计算出来的文字上下中心的y坐标基础上加上baseline到文字中线的偏移量\",{\"1\":{\"15\":1}}],[\"需要serviceconnection类\",{\"1\":{\"17\":1}}],[\"需要注意oom\",{\"1\":{\"259\":1}}],[\"需要注意android的坐标原点位于屏幕左上角\",{\"1\":{\"63\":1}}],[\"需要注意\",{\"1\":{\"57\":1,\"70\":1,\"153\":1,\"213\":1}}],[\"需要注意过渡activity尽量少的使用类\",{\"1\":{\"14\":1}}],[\"需要注意的是原先的页面布局信息<constraintlayout\",{\"1\":{\"401\":1}}],[\"需要注意的是提供给\",{\"1\":{\"21\":1}}],[\"需要注意的是\",{\"1\":{\"3\":1,\"57\":1,\"128\":1,\"143\":1,\"317\":1}}],[\"需要将app打包为多个dex文件\",{\"1\":{\"14\":1}}],[\"需要通过其他app分享的uri读写文件\",{\"1\":{\"2\":1}}],[\"近期有一个实现定时启动app提醒用户的需求\",{\"1\":{\"3\":1}}],[\"|叫做管道\",{\"1\":{\"361\":1}}],[\"|delta|~maxscrollextent之间\",{\"1\":{\"220\":1}}],[\"|delta|~maxscrollextent\",{\"1\":{\"220\":1}}],[\"|delta|~0之间\",{\"1\":{\"220\":1}}],[\"|delta|~0\",{\"1\":{\"220\":1}}],[\"|delta|\",{\"1\":{\"220\":4}}],[\"||\",{\"1\":{\"13\":2,\"46\":1,\"65\":2,\"80\":2,\"100\":1,\"102\":2,\"108\":1,\"115\":1,\"126\":1,\"127\":1,\"143\":1,\"176\":1,\"180\":1,\"185\":1,\"186\":1,\"191\":2,\"206\":1,\"211\":2,\"213\":1,\"223\":1,\"361\":1,\"383\":3,\"389\":3,\"391\":3}}],[\"|\",{\"1\":{\"2\":1,\"58\":1,\"60\":1,\"103\":1,\"115\":1,\"116\":1,\"121\":4,\"126\":16,\"127\":2,\"192\":1,\"279\":1,\"280\":1,\"345\":2,\"358\":2,\"361\":1,\"398\":1,\"423\":1}}],[\"q键退出\",{\"1\":{\"349\":1}}],[\"qlee\",{\"1\":{\"111\":1}}],[\"qq\",{\"1\":{\"41\":1,\"408\":1}}],[\"qian520ao\",{\"1\":{\"40\":1}}],[\"quicksort1\",{\"1\":{\"467\":3}}],[\"quickarray\",{\"1\":{\"467\":11}}],[\"quickly\",{\"1\":{\"395\":1}}],[\"quick\",{\"0\":{\"244\":1}}],[\"quit\",{\"1\":{\"391\":1}}],[\"quits\",{\"1\":{\"115\":1}}],[\"quitallowed\",{\"1\":{\"24\":2}}],[\"qualifier的注解来实现和\",{\"1\":{\"86\":1}}],[\"qualifier注解可以知道\",{\"1\":{\"86\":1}}],[\"qualifier才是他实现标识限定符注解\",{\"1\":{\"86\":1}}],[\"qualifier\",{\"0\":{\"86\":1},\"1\":{\"86\":4}}],[\"quadto\",{\"1\":{\"61\":1}}],[\"question\",{\"1\":{\"58\":1}}],[\"queue消息\",{\"1\":{\"376\":1}}],[\"queue队列中\",{\"1\":{\"266\":1}}],[\"queuefromtimeoutevent\",{\"1\":{\"109\":1}}],[\"queuefromzeroevent\",{\"1\":{\"109\":1}}],[\"queued\",{\"1\":{\"106\":1}}],[\"queue中\",{\"1\":{\"95\":1,\"389\":1}}],[\"queue中的任务\",{\"1\":{\"95\":1}}],[\"queue\",{\"1\":{\"25\":2,\"28\":1,\"95\":5,\"109\":1,\"115\":2,\"375\":1,\"376\":5,\"389\":1,\"391\":14,\"438\":7}}],[\"querylocalinterface\",{\"1\":{\"40\":1,\"58\":1}}],[\"queryintentactivities\",{\"1\":{\"2\":1}}],[\"query\",{\"1\":{\"2\":1}}],[\"q\",{\"1\":{\"2\":1,\"327\":2}}],[\"对排序速度影响较大\",{\"1\":{\"462\":1}}],[\"对这些小数组进行插入排序\",{\"1\":{\"462\":1}}],[\"对获得的结果\",{\"1\":{\"458\":1}}],[\"对获取到的数据进行解析\",{\"1\":{\"371\":1}}],[\"对获取到的内容进行分析\",{\"1\":{\"371\":1}}],[\"对指定下标元素读写快o\",{\"1\":{\"450\":1}}],[\"对网站静态化处理后\",{\"1\":{\"418\":1}}],[\"对网页数据进行解析\",{\"1\":{\"371\":1}}],[\"对其进行相应的编辑即可\",{\"1\":{\"417\":1}}],[\"对不同的hexo项目分别新建文件夹存放\",{\"1\":{\"406\":1}}],[\"对dao的封装\",{\"1\":{\"399\":1}}],[\"对sunflower的整体分析\",{\"1\":{\"399\":1}}],[\"对查找到的文本显示颜色\",{\"1\":{\"361\":1}}],[\"对\",{\"1\":{\"335\":1}}],[\"对整数做平方\",{\"1\":{\"328\":1}}],[\"对文章进行静态化处理\",{\"1\":{\"419\":1}}],[\"对文本进行加密和解密\",{\"1\":{\"296\":1}}],[\"对文件的操作引用\",{\"1\":{\"111\":1}}],[\"对as的初始化进行同步锁呢\",{\"1\":{\"294\":1}}],[\"对android工程的影响极小\",{\"1\":{\"88\":1}}],[\"对判断是否需要初始化进行了同步锁\",{\"1\":{\"294\":1}}],[\"对上面的代码稍作优化\",{\"1\":{\"294\":1}}],[\"对threadlocal对象的弱引用\",{\"1\":{\"288\":1}}],[\"对比一下差异\",{\"1\":{\"378\":1}}],[\"对比scrollposition变化的值\",{\"1\":{\"220\":1}}],[\"对比两种代码发现获取状态栏高度的代码逻辑几乎一样\",{\"1\":{\"53\":1}}],[\"对传入的\",{\"1\":{\"216\":2}}],[\"对官方\",{\"1\":{\"198\":1}}],[\"对外提供更多的接口\",{\"1\":{\"365\":1}}],[\"对外提供一个公有\",{\"1\":{\"294\":1}}],[\"对外提供宽高以及image\",{\"1\":{\"194\":1}}],[\"对外暴露操纵\",{\"1\":{\"212\":1}}],[\"对外发出scrollnotification\",{\"1\":{\"234\":1}}],[\"对外发出\",{\"1\":{\"212\":1,\"227\":1}}],[\"对外分享有权限的uri\",{\"1\":{\"2\":1}}],[\"对齐\",{\"1\":{\"171\":1}}],[\"对象还没有被构造完成\",{\"1\":{\"317\":1}}],[\"对象实际包含的数据\",{\"1\":{\"282\":1}}],[\"对象头\",{\"1\":{\"282\":3,\"283\":1,\"285\":2}}],[\"对象过多导致head内存溢出\",{\"1\":{\"256\":1}}],[\"对象引用\",{\"0\":{\"267\":1},\"1\":{\"252\":1}}],[\"对象展示图片\",{\"1\":{\"207\":1}}],[\"对象全局唯一\",{\"1\":{\"197\":1}}],[\"对象的缓存\",{\"1\":{\"197\":1}}],[\"对象会传入\",{\"1\":{\"188\":1}}],[\"对象为\",{\"1\":{\"79\":1}}],[\"对象创建一个\",{\"1\":{\"79\":1}}],[\"对象\",{\"1\":{\"79\":9,\"111\":1,\"149\":1,\"154\":1,\"182\":1,\"191\":1,\"205\":2,\"207\":1,\"211\":3,\"213\":1,\"254\":1}}],[\"对启动proxyintent事件做拦截\",{\"1\":{\"72\":1}}],[\"对申请结果进行处理\",{\"1\":{\"69\":1}}],[\"对信号量进行发送操作v\",{\"1\":{\"58\":1}}],[\"对信号量的操作只有一下p\",{\"1\":{\"58\":1}}],[\"对该文件进行io操作可以绕过内核直接在用户态完成\",{\"1\":{\"58\":1}}],[\"对要监听点击事件的控件设置监听\",{\"1\":{\"56\":1}}],[\"对child进行相应处理\",{\"1\":{\"55\":1}}],[\"对child进行想要实现的变化\",{\"1\":{\"55\":1}}],[\"对数组进行扩容\",{\"1\":{\"50\":1}}],[\"对mhashes中最后一个与key的hash一致的后一位index取反\",{\"1\":{\"49\":1}}],[\"对mfirsttouchtarget\",{\"1\":{\"13\":1}}],[\"对二分法查找到的值再取反\",{\"1\":{\"45\":1}}],[\"对应下文的rawicdata\",{\"1\":{\"395\":1}}],[\"对应hotspot虚拟机来说\",{\"1\":{\"274\":1}}],[\"对应页面上原先\",{\"1\":{\"176\":1}}],[\"对应我们在之前遇到的用来管理rendering\",{\"1\":{\"119\":1}}],[\"对应的scrollbehavior\",{\"1\":{\"221\":1}}],[\"对应的state\",{\"1\":{\"181\":1}}],[\"对应的类之外\",{\"1\":{\"208\":1}}],[\"对应的\",{\"1\":{\"197\":1,\"211\":1}}],[\"对应的图片\",{\"1\":{\"195\":1}}],[\"对应的navigatorstate\",{\"1\":{\"178\":1}}],[\"对应的属性\",{\"1\":{\"156\":1}}],[\"对应的element添加为renderobjecttowidgetelement的子节点\",{\"1\":{\"127\":1}}],[\"对应的element是singlechildrenderobjectelement\",{\"1\":{\"122\":1}}],[\"对应的节点目前还没有分析到\",{\"1\":{\"126\":1}}],[\"对应的数据\",{\"1\":{\"111\":1,\"112\":1}}],[\"对应的demo\",{\"1\":{\"41\":1}}],[\"对应于sdefaultexecutor\",{\"1\":{\"80\":1}}],[\"对应一个activity\",{\"1\":{\"41\":1}}],[\"对应context\",{\"1\":{\"2\":1}}],[\"对项目改动少并且逻辑较为简单\",{\"1\":{\"14\":1}}],[\"对点击事件进行处理\",{\"1\":{\"13\":1}}],[\"对于这些小于3的数组可以用插入排序法进行排序\",{\"1\":{\"467\":1}}],[\"对于这种lambda函数需要添加\",{\"1\":{\"322\":1}}],[\"对于这种情况\",{\"1\":{\"240\":1}}],[\"对于这种场景\",{\"1\":{\"2\":1}}],[\"对于数组arr中的元素来说\",{\"1\":{\"460\":1}}],[\"对于数组的大小计算\",{\"1\":{\"282\":1}}],[\"对于case\",{\"1\":{\"458\":1}}],[\"对于在数组中保存的堆\",{\"1\":{\"439\":1}}],[\"对于有环存在\",{\"1\":{\"438\":1}}],[\"对于app等来说\",{\"1\":{\"378\":1}}],[\"对于android来说\",{\"1\":{\"108\":1}}],[\"对于异步返回多个值的需求\",{\"1\":{\"335\":1}}],[\"对于异步方法产生异常等flutter框架没有捕获的情况\",{\"1\":{\"141\":1}}],[\"对于作用域的并发\",{\"1\":{\"332\":1}}],[\"对于不能直接修改的类\",{\"1\":{\"321\":1}}],[\"对于不同的调用请求\",{\"1\":{\"211\":1}}],[\"对于kotlin语言来说\",{\"1\":{\"313\":1}}],[\"对于network\",{\"1\":{\"196\":1}}],[\"对于pop事件\",{\"1\":{\"179\":1}}],[\"对于动画的控制则由\",{\"1\":{\"155\":1}}],[\"对于\",{\"1\":{\"142\":1,\"146\":1,\"157\":1,\"184\":1,\"417\":1}}],[\"对于普通的错误\",{\"1\":{\"142\":1}}],[\"对于上述的\",{\"1\":{\"159\":1}}],[\"对于上述的结论\",{\"1\":{\"131\":1}}],[\"对于上述步骤获取到的图片uri赋予权限有两种方式\",{\"1\":{\"2\":1}}],[\"对于我们自己定义的类\",{\"1\":{\"84\":1}}],[\"对于其他每个密度\",{\"1\":{\"53\":1}}],[\"3之间的增量是2\",{\"1\":{\"460\":1}}],[\"3当祖父节点没有左节点无法右旋时的特殊处理\",{\"1\":{\"458\":1}}],[\"3的规则处理\",{\"1\":{\"432\":2}}],[\"3的话\",{\"1\":{\"52\":1}}],[\"3以上时候读写性能会很差\",{\"1\":{\"428\":1}}],[\"3b\",{\"1\":{\"344\":1}}],[\"3c\",{\"1\":{\"344\":2}}],[\"3s发射一次\",{\"1\":{\"344\":2}}],[\"3都是保证将对共享变量的操作限制在同一个线程中\",{\"1\":{\"334\":1}}],[\"3步\",{\"1\":{\"273\":1}}],[\"3向上查询\",{\"1\":{\"272\":1}}],[\"3中\",{\"1\":{\"144\":1}}],[\"38\",{\"1\":{\"115\":1}}],[\"384\",{\"1\":{\"58\":1}}],[\"37\",{\"1\":{\"115\":1}}],[\"375为设计稿宽度\",{\"1\":{\"81\":1}}],[\"375\",{\"1\":{\"81\":2}}],[\"375dp始终都能够占满屏幕宽度\",{\"1\":{\"53\":1}}],[\"375dp\",{\"1\":{\"53\":2}}],[\"35\",{\"1\":{\"115\":1}}],[\"33\",{\"1\":{\"115\":1}}],[\"30以yyyy格式化为什么会出现问题\",{\"1\":{\"302\":1}}],[\"30的bug\",{\"1\":{\"302\":1}}],[\"30时出现2020\",{\"1\":{\"302\":1}}],[\"30\",{\"1\":{\"115\":1,\"131\":1,\"302\":3,\"398\":1}}],[\"300dp\",{\"1\":{\"79\":1}}],[\"300\",{\"1\":{\"66\":2,\"327\":6,\"348\":2,\"370\":1}}],[\"3245399\",{\"1\":{\"458\":1}}],[\"32位\",{\"1\":{\"280\":1}}],[\"320\",{\"1\":{\"242\":1}}],[\"32\",{\"1\":{\"112\":1,\"115\":1,\"285\":1,\"458\":1}}],[\"31uv\",{\"1\":{\"413\":1}}],[\"31\",{\"1\":{\"115\":1,\"302\":2}}],[\"315\",{\"1\":{\"81\":1}}],[\"3187320\",{\"1\":{\"58\":1,\"59\":1}}],[\"39\",{\"1\":{\"115\":1}}],[\"391137\",{\"1\":{\"58\":1}}],[\"39440766\",{\"1\":{\"58\":1}}],[\"36097\",{\"1\":{\"372\":1}}],[\"360dp\",{\"1\":{\"53\":1}}],[\"36\",{\"1\":{\"115\":1,\"370\":2}}],[\"36778087\",{\"1\":{\"36\":1}}],[\"34\",{\"1\":{\"5\":1,\"115\":1,\"458\":1}}],[\"3\",{\"0\":{\"21\":1,\"254\":1,\"258\":1,\"264\":1},\"1\":{\"2\":1,\"14\":2,\"17\":1,\"52\":1,\"53\":1,\"55\":2,\"58\":1,\"60\":1,\"66\":1,\"69\":1,\"74\":2,\"95\":3,\"115\":5,\"117\":1,\"126\":1,\"130\":1,\"141\":1,\"142\":1,\"143\":1,\"198\":1,\"211\":1,\"231\":3,\"276\":1,\"277\":1,\"281\":1,\"294\":1,\"299\":1,\"302\":1,\"305\":1,\"318\":1,\"321\":1,\"322\":2,\"325\":1,\"327\":15,\"336\":2,\"341\":1,\"344\":2,\"346\":3,\"347\":1,\"352\":1,\"362\":1,\"369\":8,\"370\":1,\"376\":1,\"377\":1,\"378\":2,\"389\":2,\"394\":1,\"396\":1,\"407\":1,\"428\":1,\"432\":4,\"437\":4,\"438\":4,\"453\":4,\"458\":2,\"459\":4,\"460\":1,\"462\":7}}],[\"83\",{\"1\":{\"458\":1}}],[\"8389461\",{\"1\":{\"282\":1,\"286\":1}}],[\"8ares\",{\"1\":{\"413\":1}}],[\"85\",{\"1\":{\"413\":1}}],[\"854\",{\"1\":{\"327\":1}}],[\"87\",{\"1\":{\"370\":1}}],[\"8方式\",{\"1\":{\"345\":1}}],[\"822\",{\"1\":{\"302\":1}}],[\"82715741\",{\"1\":{\"288\":1}}],[\"8601的标准\",{\"1\":{\"302\":1}}],[\"8601\",{\"1\":{\"302\":2}}],[\"8601兼容\",{\"1\":{\"302\":1}}],[\"8byte对齐\",{\"1\":{\"283\":1}}],[\"8格式来存放字符的\",{\"1\":{\"283\":1}}],[\"8编码的unicode字符串在常量池中以constant\",{\"1\":{\"283\":1}}],[\"8比特对齐\",{\"1\":{\"282\":7,\"285\":2}}],[\"8系列之重新认识hashmap\",{\"1\":{\"280\":1}}],[\"8有哪些区别\",{\"1\":{\"280\":1}}],[\"8中的原理及不同\",{\"1\":{\"280\":1}}],[\"8中则新增了红黑树\",{\"1\":{\"280\":1}}],[\"8新增\",{\"1\":{\"280\":1}}],[\"8对比查看这里\",{\"1\":{\"280\":1}}],[\"8采用尾插法\",{\"1\":{\"280\":1}}],[\"8072\",{\"1\":{\"287\":1}}],[\"80\",{\"1\":{\"131\":1,\"212\":1}}],[\"8080\",{\"1\":{\"76\":1}}],[\"800f\",{\"1\":{\"63\":2}}],[\"89210950\",{\"1\":{\"58\":1}}],[\"8888则会发生一次\",{\"1\":{\"211\":1}}],[\"88计算时就会只有24dp\",{\"1\":{\"53\":1}}],[\"88\",{\"1\":{\"53\":4}}],[\"84418369http\",{\"1\":{\"15\":1}}],[\"84418369\",{\"1\":{\"15\":1}}],[\"8\",{\"1\":{\"2\":1,\"35\":1,\"36\":1,\"56\":2,\"57\":2,\"66\":1,\"81\":1,\"115\":1,\"280\":1,\"281\":2,\"282\":8,\"283\":1,\"285\":2,\"287\":1,\"288\":1,\"295\":1,\"296\":1,\"369\":1,\"371\":2,\"401\":1,\"413\":1,\"421\":1}}],[\"umask\",{\"1\":{\"352\":1}}],[\"umeninfo\",{\"1\":{\"54\":1}}],[\"umeng\",{\"1\":{\"54\":9}}],[\"ugo\",{\"1\":{\"351\":1}}],[\"u用户\",{\"1\":{\"351\":1}}],[\"uk\",{\"1\":{\"321\":4}}],[\"u\",{\"1\":{\"302\":1}}],[\"u013380694\",{\"1\":{\"283\":1,\"287\":1}}],[\"u013309870\",{\"1\":{\"279\":1}}],[\"u2\",{\"1\":{\"283\":1}}],[\"u1\",{\"1\":{\"283\":2}}],[\"uword\",{\"1\":{\"115\":4,\"391\":1}}],[\"uint8\",{\"1\":{\"383\":3,\"387\":1,\"388\":2}}],[\"uint8list>\",{\"1\":{\"202\":2}}],[\"uint8list\",{\"1\":{\"111\":2,\"188\":1,\"196\":1,\"201\":3,\"210\":1,\"211\":1}}],[\"ui\",{\"0\":{\"128\":1},\"1\":{\"80\":1,\"81\":1,\"134\":1,\"136\":1,\"167\":2,\"192\":1,\"194\":4,\"195\":2,\"196\":3,\"201\":2,\"210\":4,\"211\":8,\"213\":1,\"401\":1,\"402\":1}}],[\"ui线程\",{\"1\":{\"80\":2}}],[\"ui给的设计稿一般都是以像素px为单位\",{\"1\":{\"53\":1}}],[\"ui要求app在不同手机上展示效果和设计稿保持\",{\"1\":{\"53\":1}}],[\"uid\",{\"1\":{\"39\":1}}],[\"utils\",{\"0\":{\"72\":1},\"1\":{\"71\":2,\"72\":1,\"382\":4,\"383\":2,\"389\":2}}],[\"util\",{\"1\":{\"35\":3,\"36\":3,\"53\":1,\"58\":4,\"72\":1,\"280\":1,\"287\":3,\"302\":1}}],[\"utf8\",{\"1\":{\"283\":2,\"379\":2,\"384\":4}}],[\"utf8类型表示\",{\"1\":{\"283\":1}}],[\"utf\",{\"1\":{\"2\":1,\"56\":2,\"66\":1,\"296\":1,\"369\":1,\"371\":1,\"401\":1,\"421\":1}}],[\"unoptimizing\",{\"1\":{\"395\":1}}],[\"unoptimized\",{\"0\":{\"395\":1},\"1\":{\"394\":1,\"395\":1,\"396\":2}}],[\"unexpected\",{\"1\":{\"378\":1}}],[\"unable\",{\"1\":{\"378\":1}}],[\"unaryfunction\",{\"1\":{\"378\":1}}],[\"unalias\",{\"1\":{\"359\":1}}],[\"unavailable\",{\"1\":{\"209\":1,\"387\":1}}],[\"unfocus\",{\"1\":{\"227\":1,\"235\":1}}],[\"unmounted\",{\"1\":{\"193\":1}}],[\"unlike\",{\"1\":{\"136\":1}}],[\"unlimited\",{\"1\":{\"117\":1}}],[\"undef\",{\"1\":{\"383\":1}}],[\"undefined\",{\"1\":{\"115\":1}}],[\"underlying\",{\"1\":{\"295\":1}}],[\"underscroll\",{\"1\":{\"220\":2}}],[\"understand\",{\"1\":{\"127\":1}}],[\"untrackedpendingimage\",{\"1\":{\"198\":4}}],[\"untracked\",{\"1\":{\"197\":1}}],[\"untitled\",{\"1\":{\"126\":1,\"131\":1,\"372\":1}}],[\"until\",{\"1\":{\"126\":1,\"383\":2,\"389\":1,\"391\":2,\"455\":2,\"456\":2,\"457\":1,\"462\":3}}],[\"untag\",{\"1\":{\"116\":2}}],[\"unbounded\",{\"1\":{\"161\":1}}],[\"unblocksigprof\",{\"1\":{\"115\":1}}],[\"unbindservice\",{\"1\":{\"17\":1,\"19\":1}}],[\"unreachable\",{\"1\":{\"108\":1,\"115\":1,\"376\":1}}],[\"unregistereventhandler\",{\"1\":{\"211\":1}}],[\"unregister\",{\"1\":{\"36\":2,\"382\":1}}],[\"unregistercallback\",{\"1\":{\"35\":2,\"36\":1}}],[\"unconfined\",{\"1\":{\"324\":2}}],[\"uncaughtexceptionhandler\",{\"1\":{\"145\":2,\"329\":1}}],[\"uncaught\",{\"1\":{\"102\":2}}],[\"unchecked\",{\"1\":{\"80\":1,\"298\":1}}],[\"unwinding\",{\"1\":{\"102\":1}}],[\"unsupported\",{\"1\":{\"378\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"305\":1}}],[\"unsupportederror\",{\"1\":{\"99\":1,\"105\":2}}],[\"unshared\",{\"1\":{\"305\":4,\"309\":5,\"312\":4}}],[\"unspecified\",{\"1\":{\"65\":2}}],[\"uninstalled\",{\"1\":{\"422\":1}}],[\"unix内核\",{\"1\":{\"357\":1}}],[\"unimplementederror\",{\"1\":{\"186\":1}}],[\"uniquekey\",{\"1\":{\"211\":5}}],[\"unique\",{\"1\":{\"115\":6,\"379\":1,\"380\":1,\"384\":1,\"388\":1,\"389\":2,\"390\":1,\"391\":6}}],[\"universus\",{\"1\":{\"58\":4,\"59\":1}}],[\"unit\",{\"1\":{\"53\":8,\"81\":1,\"322\":1,\"328\":2,\"345\":3,\"383\":2}}],[\"unusual\",{\"1\":{\"36\":1,\"202\":1}}],[\"usr\",{\"1\":{\"348\":2,\"349\":4,\"369\":1}}],[\"usa\",{\"1\":{\"321\":3}}],[\"usage\",{\"1\":{\"286\":1}}],[\"usually\",{\"1\":{\"216\":1}}],[\"us\",{\"1\":{\"110\":1,\"202\":1,\"225\":1}}],[\"useful\",{\"1\":{\"147\":1,\"154\":1}}],[\"uses\",{\"1\":{\"126\":1,\"278\":1}}],[\"usertag\",{\"1\":{\"383\":4}}],[\"usermod\",{\"1\":{\"353\":1}}],[\"userdel\",{\"1\":{\"353\":1}}],[\"useradd\",{\"1\":{\"353\":1}}],[\"users\",{\"1\":{\"353\":1}}],[\"username$\",{\"1\":{\"358\":1}}],[\"username在删除用户时\",{\"1\":{\"353\":1}}],[\"username\",{\"1\":{\"347\":1,\"353\":2,\"354\":1,\"358\":1,\"401\":2}}],[\"user\",{\"1\":{\"58\":1,\"179\":1,\"181\":1,\"272\":1,\"347\":2,\"370\":1,\"407\":2,\"421\":1}}],[\"use\",{\"1\":{\"49\":1,\"102\":1,\"111\":1,\"112\":2,\"115\":1,\"136\":1,\"154\":1,\"185\":1,\"198\":2,\"281\":1,\"295\":1,\"317\":1,\"327\":1,\"345\":1,\"369\":1,\"378\":1,\"387\":1,\"391\":2,\"426\":1}}],[\"usedports\",{\"1\":{\"112\":7}}],[\"used\",{\"1\":{\"15\":1,\"100\":1,\"115\":6,\"120\":1,\"125\":1,\"186\":1,\"198\":1,\"220\":1,\"281\":2,\"283\":1,\"322\":1,\"327\":1,\"328\":1,\"383\":1,\"389\":2,\"396\":1}}],[\"using\",{\"1\":{\"15\":1,\"105\":1,\"130\":2,\"188\":1,\"220\":1,\"233\":1,\"243\":1,\"383\":1,\"391\":1,\"392\":1,\"396\":1}}],[\"upperbound\",{\"1\":{\"161\":3,\"162\":1,\"163\":1,\"168\":1}}],[\"updateuionmainthread\",{\"1\":{\"322\":1}}],[\"updateuserscrolldirection\",{\"1\":{\"225\":1,\"226\":1}}],[\"updateparent\",{\"1\":{\"216\":1}}],[\"updateparentdata\",{\"1\":{\"121\":1,\"127\":1}}],[\"updatecandrag\",{\"1\":{\"212\":1,\"216\":1,\"223\":3}}],[\"updatechild方法\",{\"1\":{\"126\":1}}],[\"updatechild的逻辑分为4种情况\",{\"1\":{\"126\":1}}],[\"updatechild\",{\"1\":{\"121\":1,\"122\":1,\"126\":3,\"128\":4}}],[\"updateshadow\",{\"1\":{\"216\":2}}],[\"updateshouldnotify\",{\"1\":{\"130\":1}}],[\"updatesourcestream\",{\"0\":{\"191\":1},\"1\":{\"190\":2}}],[\"updateeffectiveobservers\",{\"1\":{\"178\":1}}],[\"updateherocontroller方法中会使用其获取\",{\"1\":{\"178\":1}}],[\"updatetween\",{\"1\":{\"150\":1}}],[\"updatedelegate\",{\"1\":{\"219\":1}}],[\"updated\",{\"1\":{\"126\":1,\"128\":2,\"176\":1}}],[\"updaterenderobject\",{\"1\":{\"122\":1,\"228\":2,\"236\":1}}],[\"updateinheritance\",{\"1\":{\"121\":1}}],[\"updateappwidget\",{\"1\":{\"79\":1}}],[\"update\",{\"1\":{\"78\":3,\"79\":2,\"126\":1,\"128\":2,\"134\":1,\"136\":1,\"202\":1,\"226\":2,\"348\":2,\"368\":1,\"370\":1,\"407\":1}}],[\"up时调用对应的方法即可\",{\"1\":{\"64\":1}}],[\"uptimemillis\",{\"1\":{\"28\":1,\"30\":1}}],[\"up的时候调用monclicklistener\",{\"1\":{\"13\":1}}],[\"up\",{\"1\":{\"13\":2,\"105\":1,\"106\":1,\"108\":1,\"179\":1,\"220\":1,\"225\":1,\"226\":1,\"228\":1,\"239\":1,\"297\":1,\"327\":1,\"376\":1,\"383\":2,\"396\":1}}],[\"uri等等\",{\"1\":{\"389\":1}}],[\"uris\",{\"1\":{\"382\":1}}],[\"uri\",{\"1\":{\"2\":7,\"345\":4,\"373\":4,\"378\":14,\"379\":1,\"382\":6,\"384\":6,\"387\":16,\"388\":2,\"389\":5}}],[\"urlparse\",{\"1\":{\"371\":1}}],[\"urlopen\",{\"1\":{\"370\":1,\"371\":1}}],[\"urllib2\",{\"1\":{\"370\":2,\"371\":2}}],[\"urls\",{\"1\":{\"370\":18}}],[\"url\",{\"1\":{\"1\":1,\"42\":2,\"188\":1,\"196\":2,\"201\":2,\"347\":1,\"362\":2,\"364\":9,\"367\":1,\"370\":14,\"371\":16,\"382\":1,\"386\":1,\"417\":3}}],[\"兼容适配\",{\"1\":{\"2\":2}}],[\"746510375\",{\"1\":{\"372\":1}}],[\"777\",{\"1\":{\"352\":1}}],[\"77\",{\"1\":{\"305\":1,\"316\":1}}],[\"7767430\",{\"1\":{\"115\":1}}],[\"7默认算法\",{\"1\":{\"302\":1}}],[\"7和1\",{\"1\":{\"280\":1}}],[\"7与jdk1\",{\"1\":{\"280\":1}}],[\"7与1\",{\"1\":{\"280\":1}}],[\"7采用采用头插法\",{\"1\":{\"280\":1}}],[\"7中\",{\"1\":{\"280\":1}}],[\"75\",{\"1\":{\"280\":2}}],[\"75是对空间和时间效率的一个平衡选择\",{\"1\":{\"280\":1}}],[\"75f\",{\"1\":{\"280\":1}}],[\"75009663\",{\"1\":{\"54\":1}}],[\"7及以上输出true\",{\"1\":{\"254\":1}}],[\"7及以上\",{\"1\":{\"254\":1}}],[\"71333103\",{\"1\":{\"294\":1}}],[\"71aa1\",{\"1\":{\"117\":1}}],[\"71513385\",{\"1\":{\"58\":1}}],[\"70\",{\"1\":{\"58\":1}}],[\"70082302\",{\"1\":{\"58\":1}}],[\"72975536\",{\"1\":{\"279\":1}}],[\"72947\",{\"1\":{\"180\":1}}],[\"72513985\",{\"1\":{\"58\":1}}],[\"72\",{\"1\":{\"53\":1}}],[\"78074983\",{\"1\":{\"40\":1}}],[\"785\",{\"1\":{\"5\":1}}],[\"765\",{\"1\":{\"5\":1}}],[\"7\",{\"1\":{\"2\":2,\"53\":3,\"81\":1,\"108\":1,\"115\":1,\"231\":3,\"279\":1,\"302\":7,\"352\":1,\"366\":1,\"371\":1,\"410\":1,\"413\":1}}],[\">中\",{\"1\":{\"401\":1}}],[\">包裹在<layout\",{\"1\":{\"401\":1}}],[\">updatestartidletime\",{\"1\":{\"391\":1}}],[\">unregister\",{\"1\":{\"382\":1}}],[\">unit\",{\"1\":{\"322\":2}}],[\">addexitlistener\",{\"1\":{\"389\":1}}],[\">adderrorlistener\",{\"1\":{\"389\":1}}],[\">addresumecapability\",{\"1\":{\"389\":1}}],[\">api\",{\"1\":{\"389\":1}}],[\">alignment\",{\"1\":{\"125\":1}}],[\">zone\",{\"1\":{\"389\":3}}],[\">verify\",{\"1\":{\"383\":1}}],[\">version\",{\"1\":{\"382\":1,\"387\":1}}],[\">lowlevelshutdown\",{\"1\":{\"383\":1}}],[\">message\",{\"1\":{\"383\":3,\"389\":1}}],[\">metric\",{\"1\":{\"383\":1}}],[\">markreadytouse\",{\"1\":{\"383\":1}}],[\">main\",{\"1\":{\"115\":1,\"377\":1,\"383\":2,\"389\":1}}],[\">makerunnable\",{\"1\":{\"389\":1}}],[\">make\",{\"1\":{\"40\":1}}],[\">heap\",{\"1\":{\"383\":3}}],[\">handleinterrupts\",{\"1\":{\"376\":1}}],[\">exit\",{\"1\":{\"391\":2}}],[\">exitapiscope\",{\"1\":{\"383\":1}}],[\">errors\",{\"1\":{\"389\":1}}],[\">enable\",{\"1\":{\"384\":1}}],[\">enter\",{\"1\":{\"391\":2}}],[\">entersafepoint\",{\"1\":{\"383\":1}}],[\">enterapiscope\",{\"1\":{\"383\":1}}],[\">enqueue\",{\"1\":{\"115\":2}}],[\">end\",{\"1\":{\"115\":1}}],[\">kernel\",{\"1\":{\"382\":1,\"383\":2}}],[\">group\",{\"1\":{\"379\":2,\"383\":1,\"384\":2,\"391\":1}}],[\">500\",{\"1\":{\"353\":1}}],[\">1依次返回结果\",{\"1\":{\"272\":1}}],[\">buildmessage\",{\"1\":{\"389\":1}}],[\">buildargs\",{\"1\":{\"389\":1}}],[\">build\",{\"1\":{\"383\":6}}],[\">buildname\",{\"1\":{\"383\":1}}],[\">b\",{\"1\":{\"264\":1}}],[\">workerloop\",{\"1\":{\"115\":1,\"391\":1}}],[\">join\",{\"1\":{\"115\":1}}],[\">on\",{\"1\":{\"389\":2}}],[\">onresume\",{\"1\":{\"14\":1}}],[\">out\",{\"1\":{\"383\":1}}],[\">object\",{\"1\":{\"383\":11,\"384\":1}}],[\">o\",{\"1\":{\"321\":1}}],[\">origin\",{\"1\":{\"116\":2,\"379\":1,\"383\":1,\"389\":2}}],[\">os\",{\"1\":{\"115\":2}}],[\">owning\",{\"1\":{\"115\":2}}],[\">field\",{\"1\":{\"383\":1}}],[\">flags\",{\"1\":{\"383\":1}}],[\">function\",{\"1\":{\"115\":1,\"380\":1,\"386\":1}}],[\">false<\",{\"1\":{\"66\":1}}],[\">closure\",{\"1\":{\"389\":2}}],[\">clone\",{\"1\":{\"383\":1}}],[\">class\",{\"1\":{\"383\":1}}],[\">cleanup\",{\"1\":{\"382\":2}}],[\">createheap\",{\"1\":{\"388\":1}}],[\">create\",{\"1\":{\"382\":1}}],[\">copy\",{\"1\":{\"379\":1,\"384\":1}}],[\">contains\",{\"1\":{\"115\":2}}],[\">c\",{\"1\":{\"264\":2}}],[\">checkaccess\",{\"1\":{\"115\":1}}],[\">nativeargat\",{\"1\":{\"376\":2}}],[\">name\",{\"1\":{\"115\":3,\"383\":2}}],[\">notifyisolatecreated\",{\"1\":{\"383\":1}}],[\">notify\",{\"1\":{\"115\":2,\"390\":2}}],[\">nextuint64\",{\"1\":{\"115\":1,\"383\":2}}],[\">increment\",{\"1\":{\"389\":1}}],[\">incrementspawncount\",{\"1\":{\"380\":1}}],[\">initial\",{\"1\":{\"383\":1}}],[\">initialize\",{\"1\":{\"382\":1}}],[\">init\",{\"1\":{\"383\":2,\"386\":1,\"387\":1}}],[\">initgrowthcontrol\",{\"1\":{\"383\":2}}],[\">insert\",{\"1\":{\"115\":1}}],[\">id\",{\"1\":{\"116\":1}}],[\">idle\",{\"1\":{\"115\":1,\"391\":1}}],[\">isempty\",{\"1\":{\"391\":4}}],[\">is\",{\"1\":{\"389\":2}}],[\">iswellformed\",{\"1\":{\"115\":1}}],[\">isolate\",{\"1\":{\"379\":1,\"380\":1,\"381\":1,\"383\":5,\"384\":2,\"386\":2,\"389\":2}}],[\">isownedbycurrentthread\",{\"1\":{\"115\":1}}],[\">isoob\",{\"1\":{\"115\":1}}],[\">isarray\",{\"1\":{\"115\":1}}],[\">issendport\",{\"1\":{\"115\":1}}],[\">isint32\",{\"1\":{\"115\":2}}],[\">root\",{\"1\":{\"384\":1}}],[\">random\",{\"1\":{\"383\":2}}],[\">resolvefunction\",{\"1\":{\"389\":1}}],[\">registerisolate\",{\"1\":{\"383\":1}}],[\">register\",{\"1\":{\"382\":1}}],[\">renderobject\",{\"1\":{\"117\":2,\"122\":1,\"125\":1}}],[\">retain\",{\"1\":{\"108\":1}}],[\">runfromappsnapshot\",{\"1\":{\"382\":1}}],[\">run<spawnisolatetask>\",{\"1\":{\"379\":1}}],[\">run<messagehandlertask>→threadpool\",{\"1\":{\"391\":1}}],[\">run<messagehandlertask>\",{\"1\":{\"115\":2,\"389\":1}}],[\">run\",{\"1\":{\"115\":3,\"389\":2,\"391\":2}}],[\">print\",{\"1\":{\"383\":1}}],[\">priority\",{\"1\":{\"115\":1,\"391\":1}}],[\">preallocateobjects\",{\"1\":{\"383\":2}}],[\">program\",{\"1\":{\"383\":3}}],[\">parent\",{\"1\":{\"389\":1}}],[\">parameter\",{\"1\":{\"115\":1}}],[\">package\",{\"1\":{\"386\":1}}],[\">paused\",{\"1\":{\"389\":1}}],[\">pause\",{\"1\":{\"377\":1,\"389\":1}}],[\">pool\",{\"1\":{\"115\":2,\"391\":1}}],[\">ports\",{\"1\":{\"115\":1}}],[\">postmessage\",{\"1\":{\"115\":1}}],[\">sticky\",{\"1\":{\"391\":1}}],[\">startthread\",{\"1\":{\"115\":2}}],[\">snapshot\",{\"1\":{\"383\":2,\"387\":1}}],[\">script\",{\"1\":{\"382\":1,\"386\":1}}],[\">shutdown\",{\"1\":{\"382\":1}}],[\">source\",{\"1\":{\"381\":2,\"383\":1}}],[\">size\",{\"1\":{\"115\":2,\"391\":1}}],[\">senddata\",{\"1\":{\"108\":1}}],[\">seterrorsfatal\",{\"1\":{\"389\":1}}],[\">setkernelbuffernewlyowned\",{\"1\":{\"387\":1}}],[\">setkernelbufferalreadyowned\",{\"1\":{\"387\":1}}],[\">set\",{\"1\":{\"108\":1,\"115\":1,\"381\":1,\"383\":15,\"388\":1,\"389\":2}}],[\">dequeue\",{\"1\":{\"391\":2}}],[\">decrementspawncount\",{\"1\":{\"381\":1,\"386\":1}}],[\">debugger\",{\"1\":{\"383\":2}}],[\">debug\",{\"1\":{\"380\":2,\"386\":2}}],[\">dest\",{\"1\":{\"115\":3,\"391\":2}}],[\">dropfinalizers\",{\"1\":{\"115\":1}}],[\">thread\",{\"1\":{\"379\":1,\"384\":1,\"389\":1}}],[\">terminate\",{\"1\":{\"377\":1,\"389\":1}}],[\">textdirection\",{\"1\":{\"125\":1}}],[\">taskcallback\",{\"1\":{\"115\":1,\"391\":1}}],[\">trylookup\",{\"1\":{\"115\":1}}],[\">type\",{\"1\":{\"115\":1}}],[\">的抽象方法的mainfragmentmodule\",{\"1\":{\"94\":1}}],[\">客户端通信\",{\"1\":{\"43\":2}}],[\">服务端通信\",{\"1\":{\"43\":1}}],[\">>>\",{\"1\":{\"280\":2}}],[\">>\",{\"1\":{\"41\":1,\"280\":1,\"288\":1,\"361\":1}}],[\">\",{\"1\":{\"2\":5,\"14\":3,\"17\":2,\"20\":1,\"29\":2,\"52\":4,\"54\":6,\"55\":4,\"56\":13,\"60\":7,\"63\":4,\"66\":13,\"69\":5,\"72\":1,\"78\":5,\"79\":11,\"80\":2,\"91\":2,\"96\":3,\"97\":1,\"98\":2,\"99\":1,\"100\":2,\"101\":1,\"102\":5,\"103\":2,\"104\":1,\"105\":6,\"106\":3,\"107\":1,\"108\":6,\"109\":5,\"111\":7,\"112\":2,\"114\":2,\"115\":21,\"116\":2,\"117\":9,\"118\":3,\"119\":1,\"120\":1,\"121\":3,\"122\":12,\"125\":5,\"126\":10,\"127\":7,\"153\":1,\"176\":2,\"177\":1,\"184\":2,\"198\":2,\"201\":1,\"208\":1,\"211\":2,\"213\":2,\"220\":4,\"225\":2,\"226\":4,\"230\":1,\"272\":5,\"273\":2,\"280\":1,\"288\":5,\"289\":1,\"295\":1,\"309\":1,\"312\":1,\"314\":1,\"321\":5,\"322\":12,\"325\":1,\"327\":17,\"328\":6,\"334\":6,\"341\":5,\"343\":2,\"345\":7,\"347\":4,\"356\":1,\"361\":1,\"376\":5,\"377\":2,\"378\":3,\"379\":1,\"380\":1,\"381\":3,\"382\":5,\"383\":4,\"384\":2,\"386\":2,\"387\":2,\"388\":1,\"389\":8,\"390\":2,\"391\":8,\"400\":7,\"401\":14,\"412\":5,\"417\":2,\"421\":2,\"432\":6,\"437\":1,\"438\":3,\"440\":2,\"441\":3,\"445\":3,\"449\":4,\"451\":3,\"453\":2,\"455\":1,\"459\":2,\"462\":4,\"467\":2}}],[\">=\",{\"1\":{\"2\":3,\"13\":1,\"45\":2,\"47\":1,\"49\":1,\"50\":1,\"51\":1,\"64\":1,\"81\":1,\"115\":3,\"163\":1,\"167\":1,\"186\":1,\"213\":1,\"289\":2,\"322\":1,\"390\":3,\"441\":1,\"451\":1,\"453\":1}}],[\"<framelayout\",{\"1\":{\"401\":1}}],[\"<fragment\",{\"1\":{\"400\":3}}],[\"<variable\",{\"1\":{\"401\":2}}],[\"<navigation\",{\"1\":{\"400\":1}}],[\"<native\",{\"1\":{\"115\":1}}],[\"<和<<\",{\"1\":{\"361\":1}}],[\"<500\",{\"1\":{\"353\":1}}],[\"<github端分支>\",{\"1\":{\"347\":1}}],[\"<分支名称>\",{\"1\":{\"347\":1}}],[\"<地址>\",{\"1\":{\"347\":1}}],[\"<远程端名字>\",{\"1\":{\"347\":1}}],[\"<新分支名>\",{\"1\":{\"347\":2}}],[\"<新分支名字>\",{\"1\":{\"347\":1}}],[\"<本地仓库名>\",{\"1\":{\"347\":2}}],[\"<本地仓库>\",{\"1\":{\"347\":1}}],[\"<y>\",{\"1\":{\"290\":1}}],[\"<layout\",{\"1\":{\"401\":2}}],[\"<long\",{\"1\":{\"287\":2}}],[\"<linearlayout\",{\"1\":{\"56\":1,\"66\":1,\"79\":2,\"400\":1}}],[\"<widget>\",{\"1\":{\"213\":1,\"241\":1,\"242\":1}}],[\"<>如果图片不是argb\",{\"1\":{\"211\":1}}],[\"<object\",{\"1\":{\"178\":1,\"180\":2}}],[\"<unit>\",{\"1\":{\"334\":1}}],[\"<unnamednativeport>\",{\"1\":{\"115\":1}}],[\"<uses\",{\"1\":{\"78\":2}}],[\"<data>\",{\"1\":{\"401\":2}}],[\"<double>\",{\"1\":{\"226\":1}}],[\"<diagnosticsnode>\",{\"1\":{\"196\":1,\"230\":1}}],[\"<dynamic>\",{\"1\":{\"111\":1,\"112\":1,\"115\":2}}],[\"<declare\",{\"1\":{\"56\":1}}],[\"<=\",{\"1\":{\"103\":1,\"186\":1,\"211\":3,\"297\":1,\"322\":1,\"328\":1,\"341\":2,\"453\":1,\"467\":1}}],[\"<button\",{\"1\":{\"79\":1}}],[\"<t\",{\"1\":{\"364\":1}}],[\"<type\",{\"1\":{\"223\":2}}],[\"<typename\",{\"1\":{\"115\":1}}],[\"<textview\",{\"1\":{\"79\":2,\"401\":2}}],[\"<t>\",{\"1\":{\"45\":1,\"102\":1,\"322\":1}}],[\"<constraintlayout\",{\"1\":{\"401\":1}}],[\"<corners\",{\"1\":{\"66\":1}}],[\"<cf\",{\"1\":{\"56\":2}}],[\"<string\",{\"1\":{\"198\":1,\"202\":1,\"211\":2}}],[\"<style\",{\"1\":{\"66\":1}}],[\"<sendport>\",{\"1\":{\"112\":2}}],[\"<service\",{\"1\":{\"17\":1,\"20\":1}}],[\"<solid\",{\"1\":{\"66\":1}}],[\"<shape\",{\"1\":{\"66\":1}}],[\"<reified\",{\"1\":{\"322\":1}}],[\"<receiver\",{\"1\":{\"79\":1}}],[\"<resources>\",{\"1\":{\"56\":1}}],[\"<root\",{\"1\":{\"2\":1}}],[\"<extendedimageprovider<dynamic>\",{\"1\":{\"202\":1}}],[\"<external\",{\"1\":{\"2\":1}}],[\"<edittext\",{\"1\":{\"56\":1}}],[\"<int\",{\"1\":{\"378\":1}}],[\"<integer\",{\"1\":{\"287\":4}}],[\"<intent\",{\"1\":{\"17\":1,\"79\":1}}],[\"<inlinespan>\",{\"1\":{\"126\":1}}],[\"<item\",{\"1\":{\"66\":4}}],[\"<imageview\",{\"1\":{\"55\":1,\"56\":2,\"66\":1}}],[\"<<\",{\"1\":{\"49\":2,\"280\":1}}],[\"<argument\",{\"1\":{\"400\":1}}],[\"<activity\",{\"1\":{\"79\":1}}],[\"<action\",{\"1\":{\"17\":1,\"79\":1,\"400\":1}}],[\"<appwidget\",{\"1\":{\"79\":1}}],[\"<application\",{\"1\":{\"54\":1}}],[\"<application>\",{\"1\":{\"2\":1,\"17\":1,\"54\":1,\"79\":1}}],[\"<animation\",{\"1\":{\"66\":1}}],[\"<androidx\",{\"1\":{\"401\":1}}],[\"<android\",{\"1\":{\"55\":5}}],[\"<attr\",{\"1\":{\"56\":2}}],[\"<powerimagerequest>\",{\"1\":{\"211\":1}}],[\"<paths>\",{\"1\":{\"2\":1}}],[\"<provider\",{\"1\":{\"2\":1}}],[\"<\",{\"1\":{\"2\":5,\"17\":3,\"36\":2,\"37\":1,\"45\":1,\"46\":1,\"48\":1,\"49\":2,\"50\":1,\"52\":2,\"54\":2,\"55\":3,\"56\":9,\"64\":2,\"65\":1,\"66\":5,\"72\":1,\"79\":9,\"95\":1,\"105\":3,\"108\":1,\"109\":2,\"112\":1,\"127\":1,\"211\":2,\"220\":7,\"225\":2,\"226\":4,\"289\":12,\"292\":1,\"296\":3,\"297\":1,\"391\":2,\"400\":4,\"401\":8,\"421\":2,\"432\":2,\"441\":1,\"451\":3,\"453\":3,\"456\":1,\"457\":1,\"459\":5,\"462\":4,\"465\":2,\"467\":5}}],[\"<manifest\",{\"1\":{\"421\":1}}],[\"<manifest>\",{\"1\":{\"2\":1}}],[\"<meta\",{\"1\":{\"2\":1,\"54\":3,\"79\":1}}],[\"一轮比较完毕后交换他和最后一位的位置\",{\"1\":{\"456\":1}}],[\"一些\",{\"0\":{\"416\":1}}],[\"一路点击确定就可以\",{\"1\":{\"409\":1}}],[\"一路奔忙\",{\"1\":{\"408\":1}}],[\"一直听说\",{\"1\":{\"408\":1}}],[\"一直以来\",{\"1\":{\"408\":1}}],[\"一直取低位值而可能导致的索引一直的重复问题\",{\"1\":{\"280\":1}}],[\"一起使用\",{\"1\":{\"345\":1}}],[\"一起决定了view的measurespec\",{\"1\":{\"65\":1}}],[\"一致时才去更新数据\",{\"1\":{\"320\":1}}],[\"一周从周一开始\",{\"1\":{\"302\":1}}],[\"一周从周日\",{\"1\":{\"302\":1}}],[\"一年第一周所需最小的天数\",{\"1\":{\"302\":1}}],[\"一年中第一个星期四的星期\",{\"1\":{\"302\":1}}],[\"一文读懂java之hashmap索引位置计算\",{\"1\":{\"280\":1}}],[\"一看你就懂\",{\"1\":{\"272\":1}}],[\"一次真正的执行layout\",{\"1\":{\"242\":1}}],[\"一次获取intrinsic\",{\"1\":{\"242\":1}}],[\"一样可以被\",{\"1\":{\"211\":1}}],[\"一级缓存\",{\"1\":{\"198\":1}}],[\"一成不变\",{\"1\":{\"132\":1}}],[\"一旦有子协程失败\",{\"1\":{\"323\":1}}],[\"一旦有一个future执行完毕\",{\"1\":{\"102\":1}}],[\"一旦某个任务触发异常\",{\"1\":{\"141\":1}}],[\"一旦native通过\",{\"1\":{\"112\":1}}],[\"一旦成功创建会回调onstartcommand\",{\"1\":{\"17\":1}}],[\"一种compose中屏幕适配的解决方案\",{\"1\":{\"81\":1}}],[\"一种极低成本的android屏幕适配方式\",{\"1\":{\"53\":1,\"81\":1}}],[\"一书的内容\",{\"1\":{\"80\":1}}],[\"一\",{\"1\":{\"72\":1,\"279\":1,\"458\":1}}],[\"一定已经确定了\",{\"1\":{\"228\":1}}],[\"一定大于\",{\"1\":{\"213\":1}}],[\"一定要调用canvas\",{\"1\":{\"65\":1}}],[\"一定要做这一步\",{\"1\":{\"56\":1}}],[\"一定范围内他比hashmap内存效率高\",{\"1\":{\"49\":1}}],[\"一步一步深入理解coordinatorlayout\",{\"1\":{\"55\":1}}],[\"一个元素就是有序的\",{\"1\":{\"465\":1}}],[\"一个常用的间隔序列计算公式\",{\"1\":{\"461\":1}}],[\"一个节点只能有0~2个子节点的树叫做二叉树\",{\"1\":{\"429\":1}}],[\"一个天气预报app\",{\"1\":{\"398\":1}}],[\"一个实时新闻软件\",{\"1\":{\"398\":1}}],[\"一个共享的lookup\",{\"1\":{\"395\":1}}],[\"一个共享的占位符\",{\"1\":{\"211\":1}}],[\"一个call\",{\"1\":{\"395\":1}}],[\"一个被称为kernel\",{\"1\":{\"393\":1}}],[\"一个osthread一次只能进入一个isolate\",{\"1\":{\"392\":1}}],[\"一个mutator\",{\"1\":{\"392\":1}}],[\"一个\",{\"1\":{\"334\":2}}],[\"一个协程的多个子协程抛出异常将会发生什么\",{\"1\":{\"329\":1}}],[\"一个协程在流中开始生产无穷多个元素\",{\"1\":{\"328\":1}}],[\"一个父协程总是等待所有的子协程执行结束\",{\"1\":{\"322\":1}}],[\"一个线程更改了共享变量的值时\",{\"1\":{\"317\":1}}],[\"一个类中只能有一个伴生对象\",{\"1\":{\"321\":1}}],[\"一个类没有实现serializable接口\",{\"1\":{\"303\":1}}],[\"一个类只能有一个构造方法被\",{\"1\":{\"85\":1}}],[\"一个thread可以有多个threadlocal变量\",{\"1\":{\"288\":1}}],[\"一个threadlocal只能保存一个值\",{\"1\":{\"288\":1}}],[\"一个isolate有一个heap\",{\"1\":{\"392\":1}}],[\"一个isolate有自己的heap\",{\"1\":{\"95\":1}}],[\"一个int类型\",{\"1\":{\"283\":1}}],[\"一个数组对象的引用\",{\"1\":{\"283\":1}}],[\"一个string对象\",{\"1\":{\"283\":1}}],[\"一个scrollwidget\",{\"1\":{\"227\":1}}],[\"一个空的class占用了4+8=12个byte的内存\",{\"1\":{\"282\":1}}],[\"一个java对象到底占用多大内存\",{\"1\":{\"282\":1}}],[\"一个java对象在内存中的大小包括以下\",{\"1\":{\"282\":1}}],[\"一个java程序\",{\"1\":{\"249\":1}}],[\"一个key对应的索引index是由这个key的hash\",{\"1\":{\"280\":1}}],[\"一个对象具有12\",{\"1\":{\"283\":1}}],[\"一个对象调用该对象类的\",{\"1\":{\"279\":1}}],[\"一个对象被映射到虚拟内存的一个区域\",{\"1\":{\"58\":1}}],[\"一个不可达对象在\",{\"1\":{\"266\":1}}],[\"一个将child调整为child固有高度的widget\",{\"1\":{\"242\":1}}],[\"一个或多个slivers\",{\"1\":{\"227\":1}}],[\"一个viewport\",{\"1\":{\"227\":1}}],[\"一个是值为str的字符串\",{\"1\":{\"254\":1}}],[\"一个是字符串str本身\",{\"1\":{\"254\":1}}],[\"一个是事件\",{\"1\":{\"141\":1}}],[\"一个是微任务\",{\"1\":{\"141\":1}}],[\"一个是系统的\",{\"1\":{\"53\":1}}],[\"一个预制的app界面结构\",{\"1\":{\"132\":1}}],[\"一个标准的material\",{\"1\":{\"132\":1}}],[\"一个持有color\",{\"1\":{\"130\":1}}],[\"一个供依赖注入的类\",{\"1\":{\"91\":1}}],[\"一个典型的messenger服务如下所示\",{\"1\":{\"43\":1}}],[\"一个管理类\",{\"1\":{\"35\":1}}],[\"一番比较之后觉得用闹钟alarmmanager实现比较合适\",{\"1\":{\"3\":1}}],[\"一般要求这些增量之间互质\",{\"1\":{\"461\":1}}],[\"一般先以二叉搜索树的规则将数据插入表中\",{\"1\":{\"458\":1}}],[\"一般先恢复\",{\"1\":{\"226\":1}}],[\"一般使用排序优先级\",{\"1\":{\"449\":1}}],[\"一般在message中传入sendport以便从entrypoint中向来时的isolate发送消息\",{\"1\":{\"373\":1}}],[\"一般在activity可见生命周期内绑定\",{\"1\":{\"21\":1}}],[\"一般只去其后3位\",{\"1\":{\"352\":1}}],[\"一般只需要重写其build\",{\"1\":{\"133\":1}}],[\"一般只需要修改authorities即可\",{\"1\":{\"2\":1}}],[\"一般都是给定中序排序\",{\"1\":{\"346\":1}}],[\"一般需要持久化保存数据或在网络间传输时推荐使用serializable或者externalizable\",{\"1\":{\"316\":1}}],[\"一般默认为0\",{\"1\":{\"314\":1}}],[\"一般子类也只需要重写此方法即可\",{\"1\":{\"233\":1}}],[\"一般子类只需要实现后者即可\",{\"1\":{\"186\":1}}],[\"一般用于\",{\"1\":{\"188\":1}}],[\"一般用来执行\",{\"1\":{\"95\":1}}],[\"一般可以在\",{\"1\":{\"186\":1}}],[\"一般情况下将构造方法私有化既可以实现\",{\"1\":{\"294\":1}}],[\"一般情况下这个animation<double>的值范围是\",{\"1\":{\"183\":1}}],[\"一般情况下是flutter的根view\",{\"1\":{\"122\":1}}],[\"一般会是\",{\"1\":{\"182\":1}}],[\"一般以\",{\"1\":{\"146\":1,\"157\":1,\"184\":1}}],[\"一般是调用自身的代码后面\",{\"1\":{\"322\":1}}],[\"一般是图片\",{\"1\":{\"170\":1}}],[\"一般是\",{\"1\":{\"146\":1,\"157\":1}}],[\"一般是当前window也就是手机屏幕的逻辑像素size\",{\"1\":{\"122\":1}}],[\"一般来说一个app只需要一个okhttpclient对象即可\",{\"1\":{\"363\":1}}],[\"一般来说flutter\",{\"1\":{\"238\":1}}],[\"一般来说\",{\"1\":{\"128\":1,\"141\":1,\"156\":1,\"392\":1}}],[\"一般由parent传给child\",{\"1\":{\"119\":1}}],[\"一般执行跑完即弃的小任务\",{\"1\":{\"95\":1}}],[\"一般的future\",{\"1\":{\"95\":1}}],[\"一般就需要提示用户到设置中开启对应权限\",{\"1\":{\"68\":1}}],[\"一般流程\",{\"0\":{\"68\":1}}],[\"一般为了效率都会先打包\",{\"1\":{\"357\":1}}],[\"一般为当前binder的类目\",{\"1\":{\"40\":1}}],[\"一般为存储卡中android\",{\"1\":{\"2\":1}}],[\"一般有两种方式\",{\"1\":{\"38\":1}}],[\"一般不会使用\",{\"1\":{\"21\":1}}],[\"一般还需要一个outputuri用于保存裁剪之后的图片\",{\"1\":{\"2\":1}}],[\"一不小心立了个\",{\"1\":{\"0\":1}}],[\"要移动的层数\",{\"1\":{\"459\":1}}],[\"要同时更新start和end两个顶点对应的链表\",{\"1\":{\"434\":1}}],[\"要删除的节点有两个子节点\",{\"1\":{\"432\":2}}],[\"要删除的节点有且只有一个节点\",{\"1\":{\"432\":2}}],[\"要删除的节点是叶节点\",{\"1\":{\"432\":2}}],[\"要读取文件夹中的内容\",{\"1\":{\"351\":1}}],[\"要获取当前状态时\",{\"1\":{\"334\":1}}],[\"要递增状态时\",{\"1\":{\"334\":1}}],[\"要在协程中使用\",{\"1\":{\"323\":1}}],[\"要在doinbackground\",{\"1\":{\"80\":1}}],[\"要想使得这些值也可以支持序列化\",{\"1\":{\"307\":1}}],[\"要解密的字符串\",{\"1\":{\"306\":2}}],[\"要解决这个问题也很简单\",{\"1\":{\"171\":1}}],[\"要确保该类的所有实例域都为基本类型\",{\"1\":{\"305\":1}}],[\"要不在使用注解时指定\",{\"1\":{\"299\":1}}],[\"要不在定义注解时指定默认值\",{\"1\":{\"299\":1}}],[\"要被执行的方法以及通过符号引用的变量\",{\"1\":{\"278\":1}}],[\"要stoptheworld防止标记的时候新new的对象未被标记而出错\",{\"1\":{\"263\":1}}],[\"要么使用自己的controller\",{\"1\":{\"227\":1}}],[\"要么是作为私有对象的\",{\"1\":{\"58\":1}}],[\"要么是作为共享对象\",{\"1\":{\"58\":1}}],[\"要跳转的\",{\"1\":{\"171\":1}}],[\"要访问电脑的本地网址则需要访问10\",{\"1\":{\"76\":1}}],[\"要显示\",{\"1\":{\"74\":1}}],[\"要避免这种情况\",{\"1\":{\"65\":1}}],[\"要注意这个周不一定是自然周\",{\"1\":{\"302\":1}}],[\"要注意\",{\"1\":{\"64\":1}}],[\"要有合适的透明区域\",{\"1\":{\"57\":1}}],[\"要实现可以序列化的单例最简单安全的\",{\"1\":{\"305\":1}}],[\"要实现hero动画的widget\",{\"1\":{\"175\":1}}],[\"要实现如上效果\",{\"1\":{\"57\":1}}],[\"要实现点击事件监听接口\",{\"1\":{\"56\":1}}],[\"要能完全覆盖另外一张图片的图形区域\",{\"1\":{\"57\":1}}],[\"要求互质\",{\"1\":{\"462\":1}}],[\"要求对齐到8的倍数\",{\"1\":{\"283\":1}}],[\"要求依赖\",{\"1\":{\"54\":1}}],[\"要求客户端和服务在同一应用的同一进程内\",{\"1\":{\"19\":1}}],[\"要使得dp在不同屏幕上对应的像素等比例变化\",{\"1\":{\"53\":1}}],[\"要使用fileprovider可以参考定义fileprovider操作\",{\"1\":{\"2\":1}}],[\"要是排序不生效时可以试一下\",{\"1\":{\"361\":1}}],[\"要是超了范围\",{\"1\":{\"220\":1}}],[\"要是相邻的页面\",{\"1\":{\"170\":1}}],[\"要是child想要小一些的话\",{\"1\":{\"131\":1}}],[\"要是为\",{\"1\":{\"79\":1}}],[\"要是进行耗时操作\",{\"1\":{\"17\":1}}],[\"要是希望将此图片分享给第三方app进一步加工处理\",{\"1\":{\"2\":1}}],[\"要了解详情\",{\"1\":{\"3\":1}}],[\"v5\",{\"1\":{\"410\":1}}],[\"v=novyi94mjio\",{\"1\":{\"372\":2}}],[\"vcs\",{\"1\":{\"347\":1}}],[\"v类型的对象\",{\"1\":{\"291\":1}}],[\"v对象仍然保存在threadlocals中但是没有办法再访问到\",{\"1\":{\"288\":1}}],[\"ve\",{\"1\":{\"347\":1,\"383\":1}}],[\"vetoable\",{\"1\":{\"322\":2}}],[\"velocity=0\",{\"1\":{\"225\":1}}],[\"velocity\",{\"1\":{\"161\":1,\"225\":13}}],[\"veroable\",{\"1\":{\"322\":1}}],[\"verifybuiltinvtables\",{\"1\":{\"383\":1}}],[\"verifyoriginid\",{\"1\":{\"383\":1}}],[\"verify\",{\"1\":{\"378\":1,\"383\":1}}],[\"verifying\",{\"1\":{\"275\":1}}],[\"verifier\",{\"1\":{\"383\":2}}],[\"verified\",{\"1\":{\"276\":1,\"279\":1}}],[\"verification\",{\"0\":{\"276\":1},\"1\":{\"276\":2}}],[\"very\",{\"1\":{\"243\":1}}],[\"vertical的\",{\"1\":{\"228\":1}}],[\"vertical\",{\"1\":{\"55\":1,\"79\":1,\"228\":1,\"238\":3}}],[\"versioncode\",{\"1\":{\"54\":1}}],[\"version=\",{\"1\":{\"2\":1,\"56\":2,\"66\":1,\"401\":1,\"421\":1}}],[\"version\",{\"1\":{\"2\":4,\"81\":1,\"147\":11,\"154\":7,\"312\":1,\"347\":1,\"363\":1,\"382\":4,\"387\":1,\"413\":1,\"416\":1}}],[\"vsync\",{\"1\":{\"147\":1,\"161\":2,\"164\":2}}],[\"vs\",{\"0\":{\"131\":1,\"287\":1},\"1\":{\"287\":1,\"428\":2}}],[\"vm可以将heap\",{\"1\":{\"396\":1}}],[\"vm使用内联缓存\",{\"1\":{\"395\":1}}],[\"vm将运行产生的内核二进制文件\",{\"1\":{\"393\":1}}],[\"vm执行分为下面几步\",{\"1\":{\"392\":1}}],[\"vm执行dart代码有两种方式\",{\"1\":{\"392\":1}}],[\"vm中将他与虚拟机栈合并\",{\"1\":{\"253\":1}}],[\"vm同级目录还有js等实现\",{\"1\":{\"111\":1}}],[\"vm目录下\",{\"1\":{\"111\":1}}],[\"vmlibraryhooks\",{\"1\":{\"105\":4,\"106\":1,\"108\":3,\"109\":1}}],[\"vm启动的时候\",{\"1\":{\"100\":1}}],[\"vm\",{\"0\":{\"392\":1},\"1\":{\"96\":1,\"99\":3,\"100\":3,\"101\":6,\"102\":2,\"105\":4,\"106\":2,\"107\":1,\"108\":6,\"109\":2,\"111\":3,\"112\":5,\"115\":17,\"116\":2,\"255\":1,\"372\":3,\"376\":3,\"377\":4,\"378\":5,\"381\":1,\"382\":10,\"383\":13,\"387\":3,\"388\":2,\"389\":8,\"390\":1,\"391\":7,\"392\":4,\"395\":1,\"396\":2,\"397\":1}}],[\"volatile保证\",{\"1\":{\"317\":1}}],[\"volatile修饰的变量则会插入内存屏障\",{\"1\":{\"317\":1}}],[\"volatile修饰的变量执行效率和普通变量差别不大\",{\"1\":{\"317\":1}}],[\"volatile修饰的变量会在修改后通知其他线程该变量已经被更改\",{\"1\":{\"317\":1}}],[\"volatile修饰的变量有两个特性\",{\"1\":{\"317\":1}}],[\"volatile和synchronize因此而生\",{\"1\":{\"317\":1}}],[\"volatile\",{\"1\":{\"80\":1}}],[\"voidcallback\",{\"1\":{\"128\":1,\"147\":1,\"172\":1,\"226\":1}}],[\"void\",{\"0\":{\"45\":1,\"47\":1},\"1\":{\"13\":1,\"14\":1,\"15\":1,\"17\":5,\"19\":4,\"20\":4,\"24\":1,\"25\":1,\"29\":1,\"35\":14,\"36\":6,\"37\":2,\"40\":3,\"43\":2,\"44\":1,\"45\":1,\"47\":2,\"48\":1,\"52\":1,\"55\":1,\"56\":4,\"58\":4,\"64\":9,\"65\":3,\"71\":2,\"72\":1,\"78\":1,\"79\":6,\"80\":8,\"96\":6,\"97\":1,\"98\":4,\"99\":6,\"100\":2,\"101\":1,\"102\":4,\"103\":1,\"104\":4,\"105\":12,\"106\":4,\"107\":1,\"108\":7,\"109\":2,\"111\":2,\"112\":2,\"114\":1,\"115\":8,\"117\":1,\"118\":3,\"119\":1,\"121\":4,\"122\":1,\"126\":2,\"127\":4,\"130\":2,\"134\":1,\"135\":2,\"150\":1,\"151\":1,\"152\":3,\"153\":2,\"155\":4,\"163\":1,\"164\":3,\"176\":2,\"178\":1,\"179\":1,\"180\":2,\"181\":1,\"190\":1,\"192\":2,\"198\":1,\"202\":1,\"210\":1,\"211\":15,\"213\":2,\"216\":1,\"217\":1,\"219\":1,\"223\":4,\"225\":2,\"226\":1,\"228\":2,\"230\":1,\"236\":1,\"237\":3,\"238\":1,\"239\":2,\"280\":1,\"281\":6,\"282\":2,\"288\":5,\"289\":3,\"290\":1,\"293\":1,\"294\":5,\"295\":2,\"297\":4,\"300\":1,\"306\":5,\"308\":1,\"309\":5,\"311\":2,\"362\":2,\"365\":6,\"373\":1,\"376\":3,\"378\":4,\"380\":1,\"381\":2,\"382\":2,\"383\":2,\"386\":2,\"387\":2,\"388\":2,\"389\":3,\"391\":3}}],[\"violated\",{\"1\":{\"396\":1}}],[\"via\",{\"1\":{\"220\":3,\"389\":1,\"392\":1}}],[\"visitisolates\",{\"1\":{\"383\":1}}],[\"visitor\",{\"1\":{\"151\":1,\"152\":2,\"153\":2}}],[\"visiblefortesting\",{\"1\":{\"211\":2}}],[\"visible\",{\"1\":{\"180\":1,\"401\":3}}],[\"visibility\",{\"1\":{\"80\":1,\"401\":1}}],[\"virtual\",{\"0\":{\"252\":1},\"1\":{\"115\":1,\"249\":1,\"275\":1,\"277\":1,\"279\":2,\"391\":1}}],[\"viewmodel通过这个xxxrepository类来操作数据\",{\"1\":{\"403\":1}}],[\"viewmodelprovider\",{\"1\":{\"402\":1}}],[\"viewmodelproviders\",{\"1\":{\"402\":1}}],[\"viewmodel是设计用来以一种可以感知生命周期\",{\"1\":{\"402\":1}}],[\"viewmodel管理数据与页面的交互\",{\"0\":{\"402\":1}}],[\"viewmodel\",{\"1\":{\"401\":7,\"402\":1}}],[\"viewmodel的数据来源\",{\"1\":{\"399\":1}}],[\"viewid\",{\"1\":{\"300\":3}}],[\"viewinject\",{\"1\":{\"299\":1}}],[\"view能够比较方便的实现scroll效果\",{\"1\":{\"234\":1}}],[\"view滑动时隐藏键盘的逻辑\",{\"1\":{\"227\":1}}],[\"view滑动效果常用属性详解\",{\"1\":{\"41\":1}}],[\"view先消耗delta\",{\"1\":{\"226\":1}}],[\"view消耗\",{\"1\":{\"226\":1}}],[\"view计算对应的newinneractivity\",{\"1\":{\"225\":1}}],[\"views\",{\"1\":{\"212\":3,\"228\":1}}],[\"viewportconstraints\",{\"1\":{\"241\":2,\"242\":3}}],[\"viewport前后缓存区域的内容\",{\"1\":{\"240\":1}}],[\"viewport会只创建屏幕可见部分\",{\"1\":{\"240\":1}}],[\"viewportextent是取值主轴方向的size大小\",{\"1\":{\"238\":1}}],[\"viewportextent以及\",{\"1\":{\"238\":1}}],[\"viewportextent\",{\"1\":{\"238\":2}}],[\"viewportextent作为offset的viewport范围\",{\"1\":{\"238\":1}}],[\"viewportelement\",{\"1\":{\"228\":1}}],[\"viewport的offset\",{\"1\":{\"234\":1}}],[\"viewport的nestedscrollviewviewport\",{\"1\":{\"213\":1}}],[\"viewportoffset\",{\"1\":{\"227\":2,\"228\":1,\"235\":1,\"237\":1}}],[\"viewportmainaxisextent\",{\"1\":{\"213\":1}}],[\"viewportbuilder中传入的是\",{\"1\":{\"235\":1}}],[\"viewportbuilder\",{\"1\":{\"212\":1,\"227\":2,\"234\":1,\"235\":1}}],[\"viewport\",{\"1\":{\"212\":2,\"213\":11,\"217\":2,\"223\":2,\"226\":1,\"227\":5,\"228\":8,\"230\":2,\"232\":1,\"233\":7,\"242\":1}}],[\"viewparent\",{\"1\":{\"55\":1}}],[\"viewpager就是本案例中触发子view联动效果的dependency\",{\"1\":{\"55\":1}}],[\"viewpager\",{\"1\":{\"55\":1}}],[\"viewtreeobserver\",{\"1\":{\"65\":1}}],[\"view可以是这个值以内的任意大小\",{\"1\":{\"65\":1}}],[\"view内容\",{\"1\":{\"41\":1}}],[\"viewconfiguration\",{\"1\":{\"41\":1}}],[\"view的物理属性\",{\"1\":{\"234\":1}}],[\"view的最终大小就是这个值\",{\"1\":{\"65\":1}}],[\"view的绘制分为3部分\",{\"1\":{\"65\":1}}],[\"view的坐标信息有以下几种\",{\"1\":{\"41\":1}}],[\"view的点击事件分发主要涉及到两个方法\",{\"1\":{\"13\":1}}],[\"viewgroup\",{\"1\":{\"13\":1}}],[\"viewgroup会回调该方法\",{\"1\":{\"13\":1}}],[\"viewgroup与事件分发的方法有三个\",{\"1\":{\"13\":1}}],[\"viewgroup到view的一系列过程\",{\"1\":{\"13\":1}}],[\"view\",{\"1\":{\"13\":9,\"41\":1,\"42\":2,\"55\":14,\"56\":6,\"57\":4,\"61\":1,\"63\":1,\"64\":6,\"65\":3,\"66\":5,\"71\":2,\"77\":1,\"79\":1,\"81\":1,\"212\":6,\"213\":1,\"219\":1,\"223\":6,\"224\":1,\"225\":2,\"226\":8,\"227\":2,\"228\":1,\"345\":4,\"399\":1,\"401\":5}}],[\"v4\",{\"1\":{\"55\":1}}],[\"v\",{\"0\":{\"50\":2,\"51\":1,\"52\":1},\"1\":{\"51\":2,\"52\":1,\"71\":1,\"115\":44,\"280\":2,\"288\":2,\"291\":3,\"321\":1,\"356\":1,\"357\":1,\"361\":1}}],[\"v>数组\",{\"1\":{\"291\":1}}],[\"v>数组中\",{\"1\":{\"287\":1}}],[\"v>>\",{\"1\":{\"280\":1,\"287\":1}}],[\"v>\",{\"1\":{\"49\":1,\"280\":6,\"287\":4}}],[\"v>接口\",{\"1\":{\"49\":1}}],[\"vaule\",{\"1\":{\"369\":1}}],[\"variant\",{\"1\":{\"396\":1}}],[\"variables\",{\"1\":{\"136\":1,\"278\":1,\"281\":1}}],[\"variable\",{\"1\":{\"102\":1,\"111\":1,\"112\":1,\"198\":1,\"281\":2,\"298\":1,\"383\":2}}],[\"various\",{\"1\":{\"382\":1}}],[\"var和\",{\"1\":{\"349\":1}}],[\"varying\",{\"1\":{\"226\":1}}],[\"var\",{\"1\":{\"13\":1,\"43\":1,\"54\":3,\"63\":3,\"69\":3,\"81\":5,\"82\":1,\"83\":1,\"85\":2,\"86\":1,\"92\":1,\"93\":1,\"98\":2,\"101\":1,\"102\":4,\"104\":1,\"106\":1,\"108\":1,\"109\":5,\"110\":5,\"111\":4,\"130\":5,\"135\":1,\"142\":2,\"172\":1,\"212\":1,\"272\":12,\"314\":1,\"321\":7,\"322\":9,\"328\":1,\"334\":2,\"345\":4,\"346\":4,\"373\":6,\"376\":1,\"378\":4,\"422\":3,\"424\":5,\"425\":1,\"426\":2,\"427\":7,\"429\":2,\"432\":4,\"437\":5,\"438\":11,\"440\":3,\"441\":4,\"451\":3,\"455\":3,\"456\":4,\"457\":3,\"459\":8,\"462\":4,\"467\":3}}],[\"val修饰\",{\"1\":{\"321\":1}}],[\"val$anobj1指向的仍然是旧的anobj对象\",{\"1\":{\"281\":1}}],[\"val$anobj1\",{\"1\":{\"281\":4}}],[\"validatereponse\",{\"1\":{\"365\":1}}],[\"valid\",{\"1\":{\"115\":1,\"180\":2}}],[\"valueof\",{\"1\":{\"285\":1,\"321\":3,\"322\":3}}],[\"value的\",{\"1\":{\"186\":1}}],[\"value的值从double转化为u\",{\"1\":{\"158\":1}}],[\"valuenotifier\",{\"1\":{\"154\":1}}],[\"valuelistenable\",{\"1\":{\"158\":1}}],[\"valuelistenable<t>\",{\"1\":{\"158\":1}}],[\"valuelist\",{\"1\":{\"102\":8}}],[\"valueanimator\",{\"1\":{\"63\":2}}],[\"valueat\",{\"1\":{\"48\":1}}],[\"value=\",{\"1\":{\"54\":3}}],[\"value保存到了同一个数组marray中\",{\"1\":{\"49\":1}}],[\"values\",{\"1\":{\"48\":4,\"80\":2,\"102\":8,\"103\":1,\"112\":1,\"115\":1,\"180\":1,\"211\":1,\"277\":1,\"285\":1,\"287\":1,\"302\":2,\"322\":1,\"327\":1,\"328\":2,\"372\":2,\"378\":1}}],[\"valueifkeynotfound\",{\"1\":{\"46\":2}}],[\"value\",{\"0\":{\"45\":1,\"50\":1},\"1\":{\"20\":1,\"44\":1,\"45\":4,\"49\":1,\"50\":1,\"53\":7,\"54\":2,\"78\":2,\"86\":2,\"95\":5,\"101\":4,\"102\":11,\"103\":6,\"106\":1,\"110\":2,\"111\":2,\"115\":3,\"118\":3,\"147\":1,\"150\":1,\"152\":4,\"153\":2,\"155\":1,\"156\":2,\"157\":6,\"158\":5,\"159\":1,\"161\":3,\"162\":1,\"163\":3,\"168\":1,\"179\":6,\"180\":2,\"181\":3,\"182\":2,\"183\":4,\"184\":1,\"185\":1,\"186\":2,\"217\":2,\"223\":4,\"230\":1,\"237\":4,\"280\":1,\"281\":2,\"283\":4,\"288\":17,\"297\":1,\"299\":1,\"300\":1,\"302\":1,\"308\":1,\"322\":8,\"325\":5,\"327\":11,\"328\":8,\"334\":2,\"341\":8,\"343\":4,\"379\":1,\"383\":1,\"384\":3}}],[\"val\",{\"1\":{\"10\":3,\"11\":4,\"12\":1,\"41\":1,\"43\":6,\"48\":3,\"57\":1,\"62\":4,\"63\":10,\"78\":4,\"81\":8,\"82\":2,\"84\":1,\"86\":1,\"137\":1,\"211\":4,\"302\":4,\"321\":2,\"322\":12,\"325\":1,\"326\":1,\"327\":6,\"328\":5,\"330\":1,\"334\":1,\"345\":1,\"346\":9,\"400\":2,\"401\":1,\"402\":1,\"425\":2,\"429\":2,\"438\":1,\"459\":1,\"462\":1,\"467\":3}}],[\"v7\",{\"1\":{\"1\":1,\"55\":2}}],[\"为他们生成一个父节点\",{\"1\":{\"432\":1}}],[\"为okhttp3\",{\"1\":{\"364\":1}}],[\"为你的分支加入一个新的远程端\",{\"1\":{\"347\":1}}],[\"为null\",{\"1\":{\"343\":1}}],[\"为一个流\",{\"1\":{\"327\":1}}],[\"为类添加新的方法\",{\"1\":{\"321\":1}}],[\"为真则执行invokereadresolve\",{\"1\":{\"305\":1}}],[\"为注解和使用注解的类搭建一个桥梁\",{\"1\":{\"300\":1}}],[\"为简便起见\",{\"1\":{\"294\":1}}],[\"为何这些代码在访问\",{\"1\":{\"291\":1}}],[\"为24\",{\"1\":{\"283\":1}}],[\"为空时\",{\"1\":{\"280\":1}}],[\"为0则删除\",{\"1\":{\"265\":1}}],[\"为column的children安全应用expanded\",{\"0\":{\"242\":1}}],[\"为column的children安全应用spacedaround\",{\"0\":{\"241\":1}}],[\"为负时\",{\"1\":{\"220\":1}}],[\"为正值\",{\"1\":{\"220\":1}}],[\"为header的滑动scrollextent\",{\"1\":{\"213\":1}}],[\"为我们预置了很多丰富的\",{\"1\":{\"186\":1}}],[\"为我提供了一个尚且不错的博客\",{\"1\":{\"0\":1}}],[\"为这两个\",{\"1\":{\"170\":1}}],[\"为\",{\"1\":{\"166\":1,\"171\":2,\"183\":1,\"198\":1,\"207\":1,\"213\":1,\"226\":4,\"227\":1,\"230\":1,\"231\":2}}],[\"为例\",{\"1\":{\"152\":1,\"178\":1,\"186\":1,\"211\":1,\"254\":1,\"255\":1}}],[\"为什么\",{\"1\":{\"141\":1}}],[\"为renderview创建并绑定了对应的widget\",{\"1\":{\"127\":1}}],[\"为按钮绑定事件处理器\",{\"1\":{\"79\":1}}],[\"为发送方添加了uid\",{\"1\":{\"58\":1}}],[\"为this\",{\"1\":{\"56\":1}}],[\"为了有一个合适的在线写字的地方\",{\"1\":{\"408\":1}}],[\"为了满足上述要求\",{\"1\":{\"396\":1}}],[\"为了保证直接从源代码执行dart的便利性\",{\"1\":{\"393\":1}}],[\"为了符合json规范\",{\"1\":{\"371\":1}}],[\"为了优化该问题\",{\"1\":{\"322\":1}}],[\"为了优化性能\",{\"1\":{\"156\":1}}],[\"为了与\",{\"1\":{\"224\":1}}],[\"为了便于分析\",{\"1\":{\"157\":1}}],[\"为了性能\",{\"1\":{\"153\":1}}],[\"为了实现这一点\",{\"1\":{\"291\":1}}],[\"为了实现动画效果\",{\"1\":{\"152\":1}}],[\"为了实现用户空间到用户空间的拷贝\",{\"1\":{\"58\":1}}],[\"为了让文本居中显得更清晰\",{\"1\":{\"117\":1}}],[\"为了让path看起来是从起点慢慢绘制到终点去的\",{\"1\":{\"63\":1}}],[\"为了确保绘制效果\",{\"1\":{\"63\":1}}],[\"为了解决这个问题\",{\"1\":{\"397\":1}}],[\"为了解决上述问题\",{\"1\":{\"198\":1}}],[\"为了解决多个构造函数导致的问题\",{\"1\":{\"86\":1}}],[\"为了解决第三方依赖的问题\",{\"1\":{\"85\":1}}],[\"为了解决view坐标原点在左上角而做的特殊处理\",{\"1\":{\"63\":1}}],[\"为了解决方法1存在的问题\",{\"1\":{\"63\":1}}],[\"为了使文字高度居中\",{\"1\":{\"15\":1}}],[\"为了定义此fileprovider可以使用的文件目录范围\",{\"1\":{\"2\":1}}],[\"为了避免在某些机型上面无法使用这些方法\",{\"1\":{\"57\":1}}],[\"为了避免每次删除时都需要缩减数组\",{\"1\":{\"44\":1}}],[\"为了避免这种浪费\",{\"1\":{\"44\":1}}],[\"为了避免这种情况\",{\"1\":{\"2\":1,\"309\":1,\"320\":1,\"372\":1}}],[\"为了避免一些启动期间需要的任何类未在主\",{\"1\":{\"14\":1}}],[\"为了避免与主工程已有的fileprovider冲突\",{\"1\":{\"2\":1}}],[\"从左到右依次比较max和其他元素\",{\"1\":{\"456\":1}}],[\"从左到右依次遍历中缀表达式\",{\"1\":{\"453\":1}}],[\"从左到右\",{\"1\":{\"455\":1}}],[\"从前端front删除\",{\"1\":{\"452\":1}}],[\"从数组末尾开始依次减小\",{\"1\":{\"442\":1}}],[\"从堆中移除根元素时都会在数组末尾空出一个位置\",{\"1\":{\"442\":1}}],[\"从下向上遍历\",{\"1\":{\"440\":1}}],[\"从图中删除并保存的排序结果中\",{\"1\":{\"438\":1}}],[\"从队列头取出一个顶点\",{\"1\":{\"438\":2}}],[\"从栈中弹出一个顶点\",{\"1\":{\"437\":1}}],[\"从栈中推出\",{\"1\":{\"437\":1}}],[\"从哈夫曼树的根开始\",{\"1\":{\"432\":1}}],[\"从根到任何一个节点有且只有一条路径\",{\"1\":{\"429\":1}}],[\"从其他系统向\",{\"1\":{\"416\":1}}],[\"从其源码可以看出\",{\"1\":{\"186\":1}}],[\"从最初的\",{\"1\":{\"408\":1}}],[\"从官网的表述中我们知道\",{\"1\":{\"401\":1}}],[\"从底层开始依次分为表entity\",{\"1\":{\"399\":1}}],[\"从底层开始依次是1\",{\"1\":{\"60\":1}}],[\"从sunflower开始学习优雅的jetpack架构\",{\"0\":{\"399\":1}}],[\"从sthreadlocal中取出mlooper\",{\"1\":{\"31\":1}}],[\"从kernel\",{\"1\":{\"394\":1,\"395\":2}}],[\"从dart\",{\"0\":{\"393\":1},\"1\":{\"392\":1}}],[\"从data中可以读取参数\",{\"1\":{\"40\":1}}],[\"从线程池中获取task\",{\"1\":{\"389\":1}}],[\"从本地删除一个分支\",{\"1\":{\"347\":1}}],[\"从树的最左边的节点开始遍历\",{\"1\":{\"346\":1}}],[\"从两个生产者接收数据\",{\"1\":{\"334\":1}}],[\"从parcel中恢复数据\",{\"1\":{\"314\":1}}],[\"从powerimageloader\",{\"1\":{\"211\":1}}],[\"从周日到周一\",{\"1\":{\"302\":1}}],[\"从12月29日至1月4日的星期一开始的一周\",{\"1\":{\"302\":1}}],[\"从第01周开始到该年最后一周\",{\"1\":{\"302\":1}}],[\"从0开始\",{\"1\":{\"285\":1}}],[\"从0到1之旅\",{\"0\":{\"82\":1}}],[\"从gc\",{\"1\":{\"263\":1}}],[\"从获取到的图片生成\",{\"1\":{\"211\":1}}],[\"从completers中取回对应的请求\",{\"1\":{\"211\":1}}],[\"从context中找到对应的renderobject并转化得到其在ancestorcontext坐标系中的rect\",{\"1\":{\"177\":1}}],[\"从中获取\",{\"1\":{\"193\":1}}],[\"从当前页面\",{\"1\":{\"181\":1}}],[\"从当前activity获取\",{\"1\":{\"53\":1}}],[\"从父类navigatorobserver继承\",{\"1\":{\"178\":1}}],[\"从\",{\"1\":{\"157\":1,\"179\":1,\"184\":1,\"328\":2}}],[\"从上向下遍历\",{\"1\":{\"441\":1}}],[\"从上图可以看出\",{\"1\":{\"396\":1}}],[\"从上图可以看到\",{\"1\":{\"157\":1}}],[\"从上述代码我们看到\",{\"1\":{\"226\":1}}],[\"从上述代码分析可知\",{\"1\":{\"223\":1}}],[\"从上述代码可以看到\",{\"1\":{\"201\":1,\"211\":1}}],[\"从上面的代码可以看到\",{\"1\":{\"288\":1}}],[\"从上面的分析我们也可以看出\",{\"1\":{\"237\":1}}],[\"从上面的分析中\",{\"1\":{\"116\":1,\"165\":1}}],[\"从上面代码我们可以看到\",{\"1\":{\"106\":1}}],[\"从isolategroup中引用一些通用的变量\",{\"1\":{\"383\":1}}],[\"从io\",{\"1\":{\"111\":1}}],[\"从index开始\",{\"1\":{\"49\":1}}],[\"从mainactivitysubcomponent中查找提供waitforinjectclass的实例方法完成注入\",{\"1\":{\"94\":1}}],[\"从application中的activityinjector\",{\"1\":{\"94\":1}}],[\"从activity\",{\"1\":{\"13\":1}}],[\"从读端流出\",{\"1\":{\"58\":1}}],[\"从而回退到未优化的代码\",{\"1\":{\"396\":1}}],[\"从而最终保证了counter++方法是依次执行的\",{\"1\":{\"334\":1}}],[\"从而保证线程安全\",{\"1\":{\"334\":1}}],[\"从而保证性能\",{\"1\":{\"240\":1}}],[\"从而不会阻塞当前协程\",{\"1\":{\"328\":1}}],[\"从而将其与数据的具体实现解耦\",{\"1\":{\"403\":1}}],[\"从而将其插入到flutter的渲染树中\",{\"1\":{\"121\":1}}],[\"从而将对于value赋值给属性\",{\"1\":{\"322\":1}}],[\"从而避免栈溢出\",{\"1\":{\"322\":1}}],[\"从而避免stack\",{\"1\":{\"322\":1}}],[\"从而避免了上述情况\",{\"1\":{\"198\":1}}],[\"从而让其他线程再去主内存中读取最新的值\",{\"1\":{\"317\":1}}],[\"从而出现了对\",{\"1\":{\"281\":1}}],[\"从而进行对应处理\",{\"1\":{\"237\":1}}],[\"从而展示对应的内容\",{\"1\":{\"234\":1}}],[\"从而分别实现按照父级指定\",{\"1\":{\"233\":1}}],[\"从而优化性能\",{\"1\":{\"233\":1}}],[\"从而无法与\",{\"1\":{\"226\":1}}],[\"从而当用户手势在\",{\"1\":{\"223\":1}}],[\"从而计算出\",{\"1\":{\"213\":1}}],[\"从而影响用户体验\",{\"1\":{\"198\":1}}],[\"从而刷新\",{\"1\":{\"192\":1}}],[\"从而使其被catch捕获\",{\"1\":{\"341\":1}}],[\"从而使得其他scrollable\",{\"1\":{\"234\":1}}],[\"从而使得其他\",{\"1\":{\"212\":1,\"227\":1}}],[\"从而使得\",{\"1\":{\"183\":1}}],[\"从而使flutter在下一次更新界面时依据state更新statewidget\",{\"1\":{\"134\":1}}],[\"从而触发\",{\"1\":{\"178\":1}}],[\"从而可以从\",{\"1\":{\"182\":1}}],[\"从而可以得到可以随时间变化过渡的\",{\"1\":{\"168\":1}}],[\"从而可以通过\",{\"1\":{\"168\":1}}],[\"从而控制动画播放\",{\"1\":{\"156\":1}}],[\"从而调用此build\",{\"1\":{\"155\":1}}],[\"从而在不同\",{\"1\":{\"181\":1}}],[\"从而在不同的地方共享一些数据\",{\"1\":{\"87\":1}}],[\"从而在监听到\",{\"1\":{\"148\":1}}],[\"从而间接更新了statelesswidget的状态\",{\"1\":{\"134\":1}}],[\"从而会导致错误\",{\"1\":{\"291\":1}}],[\"从而会更新noname\",{\"1\":{\"130\":1}}],[\"从而会在需要回收内存时杀死进程以及其中的thread\",{\"1\":{\"59\":1}}],[\"从而导致反序列化失败\",{\"1\":{\"304\":1}}],[\"从而导致flutter\",{\"1\":{\"198\":1}}],[\"从而导致\",{\"1\":{\"181\":1}}],[\"从而导致inheritedwidget的子widget重建\",{\"1\":{\"128\":1}}],[\"从而导致app第一次启动时长时间白屏\",{\"1\":{\"14\":1}}],[\"从而更新那些依赖了inheritedwidget的子widget\",{\"1\":{\"128\":1}}],[\"从而更新界面\",{\"1\":{\"128\":1}}],[\"从而完成文件操作的流程\",{\"1\":{\"111\":1}}],[\"从而获取到了mainactivitysubcomponent的实例供activity使用\",{\"1\":{\"94\":1}}],[\"从而支持有多个构造函数的service类的初始化\",{\"1\":{\"86\":1}}],[\"从而达到目的\",{\"1\":{\"72\":1}}],[\"从而实现屏蔽指令重排的效果\",{\"1\":{\"317\":1}}],[\"从而实现跨进程传输\",{\"1\":{\"313\":1}}],[\"从而实现滑动效果\",{\"1\":{\"239\":1}}],[\"从而实现\",{\"1\":{\"226\":1}}],[\"从而实现了这两处滑动事件的联动\",{\"1\":{\"212\":1}}],[\"从而实现更丰富的动画效果\",{\"1\":{\"172\":1}}],[\"从而实现动画的视觉效果\",{\"1\":{\"157\":1}}],[\"从而实现调用statelesswidget中的方法也可以刷新ui\",{\"1\":{\"134\":1}}],[\"从而实现调用未在androidmanifest\",{\"1\":{\"70\":1}}],[\"从而实现对文件的读写\",{\"1\":{\"110\":1}}],[\"从而实现子view之间的联动\",{\"1\":{\"55\":1}}],[\"从而实现多渠道打包不同项目名\",{\"1\":{\"54\":1}}],[\"从系统获取\",{\"1\":{\"53\":1}}],[\"从系统表中查询指定uri对应的照片\",{\"1\":{\"2\":1}}],[\"从开机后多久\",{\"1\":{\"11\":1}}],[\"从实际运行来看\",{\"1\":{\"5\":1}}],[\"从相册中获取到的图片uri一般如\",{\"1\":{\"2\":1}}],[\"从相册中获取图片\",{\"1\":{\"2\":1}}],[\"f3这三个文件\",{\"1\":{\"349\":1}}],[\"f3和f\",{\"1\":{\"349\":1}}],[\"f2\",{\"1\":{\"349\":2}}],[\"f强制\",{\"1\":{\"349\":1}}],[\"fens\",{\"1\":{\"419\":1}}],[\"fetch\",{\"1\":{\"322\":4,\"347\":1}}],[\"feature\",{\"1\":{\"13\":1}}],[\"fbknrtu\",{\"1\":{\"361\":1}}],[\"fb\",{\"1\":{\"321\":1}}],[\"fs\",{\"1\":{\"201\":2}}],[\"ffi获取\",{\"1\":{\"211\":1}}],[\"ffi方案\",{\"1\":{\"211\":1}}],[\"ffi\",{\"1\":{\"116\":1,\"202\":1,\"205\":1,\"207\":1,\"211\":10}}],[\"ff00ff\",{\"1\":{\"79\":1}}],[\"fds\",{\"1\":{\"108\":1}}],[\"fdutils\",{\"1\":{\"108\":1}}],[\"f\",{\"1\":{\"96\":8,\"103\":4,\"105\":4,\"282\":1,\"295\":1,\"302\":1,\"322\":1,\"346\":1,\"349\":1,\"357\":3,\"361\":1,\"369\":1}}],[\"furthest\",{\"1\":{\"220\":2,\"225\":1}}],[\"futrue\",{\"1\":{\"103\":1}}],[\"futurelistener\",{\"1\":{\"103\":2}}],[\"futurelistener<t\",{\"1\":{\"103\":1}}],[\"futureor<powertextureimageinfo>\",{\"1\":{\"210\":1}}],[\"futureor<imageinfo>\",{\"1\":{\"210\":1,\"211\":1}}],[\"futureor<r>\",{\"1\":{\"103\":1}}],[\"futureor<t>\",{\"1\":{\"95\":1,\"96\":1,\"102\":1}}],[\"future<isolate>\",{\"1\":{\"378\":6}}],[\"future<imageinfo>\",{\"1\":{\"209\":1,\"211\":1}}],[\"future<uint8list\",{\"1\":{\"201\":1}}],[\"future<uint8list>\",{\"1\":{\"111\":4}}],[\"future<ui\",{\"1\":{\"196\":2,\"201\":2,\"210\":1}}],[\"future<networkimage>\",{\"1\":{\"196\":1}}],[\"future<void>\",{\"1\":{\"188\":1}}],[\"future<randomaccessfile>\",{\"1\":{\"111\":1}}],[\"future<r>\",{\"1\":{\"103\":3}}],[\"future<list<t>>\",{\"1\":{\"102\":3}}],[\"future<t>\",{\"1\":{\"96\":2,\"102\":3,\"103\":2}}],[\"futures\",{\"1\":{\"102\":7}}],[\"future\",{\"0\":{\"103\":1},\"1\":{\"80\":1,\"95\":19,\"96\":3,\"101\":16,\"102\":26,\"103\":11,\"111\":9,\"112\":2,\"209\":2,\"210\":1,\"211\":2,\"373\":2,\"378\":1}}],[\"futuretask\",{\"1\":{\"80\":1}}],[\"futuretask<result>\",{\"1\":{\"80\":1}}],[\"fun0\",{\"1\":{\"369\":1}}],[\"fun2\",{\"1\":{\"322\":2}}],[\"funname\",{\"1\":{\"321\":2}}],[\"fun1\",{\"1\":{\"321\":2,\"322\":2,\"369\":1}}],[\"func1\",{\"1\":{\"322\":1}}],[\"func\",{\"1\":{\"115\":1,\"116\":1,\"389\":4}}],[\"functions追踪代码的热点区域\",{\"1\":{\"396\":1}}],[\"functions\",{\"1\":{\"345\":1,\"395\":1,\"396\":1}}],[\"function\",{\"1\":{\"96\":1,\"98\":2,\"100\":2,\"103\":5,\"104\":2,\"105\":2,\"108\":1,\"111\":2,\"114\":1,\"115\":6,\"130\":1,\"134\":1,\"198\":1,\"225\":1,\"373\":1,\"378\":2,\"383\":1,\"389\":5,\"391\":3,\"394\":1,\"396\":2}}],[\"fun\",{\"1\":{\"7\":1,\"10\":1,\"11\":1,\"13\":1,\"41\":2,\"42\":1,\"43\":4,\"59\":1,\"69\":4,\"78\":1,\"81\":4,\"84\":1,\"85\":4,\"86\":1,\"87\":3,\"89\":1,\"91\":2,\"92\":2,\"93\":1,\"211\":4,\"272\":2,\"290\":1,\"293\":1,\"314\":4,\"321\":6,\"322\":20,\"325\":2,\"326\":1,\"327\":8,\"328\":3,\"334\":3,\"336\":3,\"339\":1,\"341\":2,\"345\":3,\"346\":2,\"369\":9,\"401\":1,\"427\":1,\"429\":1,\"430\":1,\"432\":1,\"437\":1,\"438\":3,\"440\":1,\"441\":1,\"451\":2,\"455\":1,\"456\":1,\"457\":1,\"459\":4,\"462\":3,\"467\":2}}],[\"f点的运动轨迹就是一个贝塞尔曲线\",{\"1\":{\"61\":1}}],[\"facilities\",{\"1\":{\"396\":1}}],[\"factor规定的容量\",{\"1\":{\"280\":1}}],[\"factor的值\",{\"1\":{\"280\":1}}],[\"factory\",{\"1\":{\"91\":1,\"94\":2,\"96\":1,\"102\":1,\"104\":2,\"105\":11,\"111\":1,\"201\":1,\"402\":1}}],[\"factory<\",{\"1\":{\"91\":2,\"94\":1}}],[\"fact\",{\"1\":{\"101\":1,\"389\":1}}],[\"father\",{\"1\":{\"369\":5,\"440\":5}}],[\"fatal2\",{\"1\":{\"115\":1}}],[\"fatal1\",{\"1\":{\"108\":1,\"115\":1,\"389\":1}}],[\"fatal\",{\"1\":{\"101\":1,\"379\":1,\"384\":1,\"387\":2,\"389\":4}}],[\"fallthrough\",{\"1\":{\"298\":1}}],[\"false不允许更改\",{\"1\":{\"322\":1}}],[\"false\",{\"1\":{\"2\":1,\"13\":5,\"17\":1,\"36\":2,\"44\":1,\"48\":1,\"63\":1,\"66\":1,\"69\":2,\"78\":1,\"95\":1,\"98\":2,\"102\":2,\"105\":2,\"109\":1,\"111\":4,\"115\":5,\"117\":5,\"121\":1,\"122\":11,\"126\":7,\"127\":1,\"149\":1,\"153\":1,\"161\":1,\"163\":1,\"167\":1,\"175\":1,\"176\":2,\"180\":2,\"181\":1,\"191\":1,\"197\":1,\"198\":1,\"210\":1,\"211\":1,\"213\":1,\"227\":2,\"235\":1,\"240\":1,\"272\":2,\"287\":1,\"305\":1,\"309\":1,\"312\":1,\"322\":1,\"376\":2,\"378\":6,\"381\":3,\"382\":2,\"383\":3,\"384\":1,\"386\":2,\"387\":4,\"388\":1,\"389\":13,\"391\":18}}],[\"fadeinimage\",{\"1\":{\"188\":1}}],[\"fadetransition\",{\"1\":{\"154\":1,\"181\":1}}],[\"fades\",{\"1\":{\"147\":2}}],[\"fail\",{\"1\":{\"209\":1,\"383\":1}}],[\"failedspawn\",{\"1\":{\"381\":3,\"386\":2}}],[\"failed\",{\"1\":{\"111\":2,\"115\":1,\"180\":1,\"201\":1,\"365\":1,\"382\":6,\"383\":1,\"389\":6}}],[\"failure\",{\"1\":{\"108\":2,\"115\":4,\"383\":1,\"387\":1}}],[\"fastoutslowin\",{\"1\":{\"177\":2}}],[\"fast\",{\"1\":{\"49\":1,\"109\":1,\"395\":1,\"396\":1}}],[\"following\",{\"1\":{\"392\":1}}],[\"fold\",{\"1\":{\"337\":1}}],[\"folder\",{\"1\":{\"201\":1}}],[\"fout\",{\"1\":{\"371\":10}}],[\"foundation\",{\"1\":{\"118\":1}}],[\"found\",{\"1\":{\"49\":2,\"202\":1,\"272\":2}}],[\"foo\",{\"1\":{\"327\":7,\"328\":3}}],[\"footween\",{\"1\":{\"184\":1}}],[\"footranslation\",{\"1\":{\"146\":1,\"157\":1}}],[\"footransition\",{\"1\":{\"146\":1,\"154\":1,\"155\":1,\"156\":3,\"157\":1}}],[\"focusnode\",{\"1\":{\"235\":3}}],[\"focusscope\",{\"1\":{\"227\":4,\"235\":1}}],[\"focusscopenode\",{\"1\":{\"227\":1,\"235\":1}}],[\"focusable\",{\"1\":{\"41\":1}}],[\"fontweight\",{\"1\":{\"126\":2}}],[\"fontsize\",{\"1\":{\"58\":1,\"131\":1,\"143\":1}}],[\"font\",{\"1\":{\"58\":1}}],[\"fontmetrics中存储的文字的各种信息\",{\"1\":{\"15\":1}}],[\"forwarding\",{\"1\":{\"376\":1}}],[\"forward\",{\"1\":{\"150\":2,\"153\":1,\"158\":1,\"161\":1,\"162\":2,\"163\":1,\"167\":1,\"168\":1,\"181\":1,\"226\":1}}],[\"forward<args>\",{\"1\":{\"115\":1,\"389\":1}}],[\"format\",{\"1\":{\"302\":2,\"305\":1,\"378\":1,\"396\":1}}],[\"format=\",{\"1\":{\"56\":2}}],[\"formal\",{\"1\":{\"281\":1}}],[\"form\",{\"1\":{\"136\":1,\"308\":1,\"369\":2,\"373\":1}}],[\"force\",{\"1\":{\"387\":1}}],[\"forcepixels\",{\"1\":{\"220\":1,\"221\":1}}],[\"forced\",{\"1\":{\"131\":1,\"220\":1}}],[\"forcelayout\",{\"1\":{\"65\":2}}],[\"forrequestid\",{\"1\":{\"112\":7}}],[\"foreachtween方法由子类实现\",{\"1\":{\"149\":1}}],[\"foreachtween\",{\"0\":{\"151\":1},\"1\":{\"149\":2,\"150\":1,\"151\":1,\"152\":1,\"153\":1}}],[\"foreach\",{\"1\":{\"95\":2}}],[\"foreachindexed\",{\"1\":{\"63\":1,\"462\":2}}],[\"forgets\",{\"1\":{\"87\":1}}],[\"forname\",{\"1\":{\"72\":4,\"272\":1,\"295\":1,\"363\":1}}],[\"for\",{\"1\":{\"2\":1,\"13\":3,\"15\":1,\"25\":1,\"36\":2,\"37\":1,\"48\":1,\"49\":7,\"64\":1,\"72\":1,\"79\":1,\"98\":1,\"100\":1,\"102\":6,\"106\":2,\"107\":1,\"108\":1,\"109\":2,\"111\":3,\"112\":1,\"114\":1,\"115\":5,\"127\":1,\"136\":1,\"140\":2,\"154\":1,\"160\":1,\"165\":1,\"180\":6,\"181\":1,\"188\":5,\"197\":1,\"211\":3,\"216\":2,\"220\":2,\"221\":1,\"223\":1,\"225\":3,\"226\":4,\"233\":2,\"243\":1,\"277\":2,\"278\":1,\"282\":1,\"283\":2,\"287\":2,\"289\":10,\"296\":2,\"300\":1,\"302\":1,\"322\":2,\"327\":8,\"328\":2,\"334\":2,\"336\":1,\"341\":1,\"369\":2,\"370\":2,\"371\":3,\"376\":1,\"378\":2,\"382\":1,\"384\":1,\"389\":3,\"391\":4,\"392\":2,\"396\":3,\"422\":1,\"453\":4,\"455\":2,\"456\":2,\"457\":2,\"462\":4,\"467\":1}}],[\"frequency\",{\"1\":{\"395\":1,\"396\":1}}],[\"free\",{\"1\":{\"381\":2,\"386\":1}}],[\"freeports\",{\"1\":{\"112\":6}}],[\"freekiteyu\",{\"1\":{\"58\":1}}],[\"front\",{\"1\":{\"392\":1}}],[\"froname\",{\"1\":{\"295\":1}}],[\"fromparts\",{\"1\":{\"230\":1}}],[\"fromaddress\",{\"1\":{\"211\":1}}],[\"fromlist\",{\"1\":{\"210\":1}}],[\"fromsize\",{\"1\":{\"181\":1}}],[\"fromsubtreecontext\",{\"1\":{\"180\":3}}],[\"fromherocontext\",{\"1\":{\"180\":1}}],[\"fromhero指定的flightshuttlebuilder\",{\"1\":{\"180\":1}}],[\"fromheroentry\",{\"1\":{\"180\":3}}],[\"fromheroes\",{\"1\":{\"180\":2}}],[\"fromherolocation\",{\"1\":{\"177\":1,\"181\":1}}],[\"fromhero\",{\"1\":{\"177\":3,\"180\":5,\"181\":2}}],[\"fromroute\",{\"1\":{\"177\":3,\"179\":4,\"180\":1}}],[\"from正向\",{\"1\":{\"161\":1}}],[\"frome\",{\"1\":{\"111\":1,\"112\":1}}],[\"from\",{\"1\":{\"56\":1,\"58\":1,\"101\":1,\"102\":6,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"120\":1,\"136\":1,\"147\":1,\"161\":2,\"172\":1,\"179\":4,\"180\":4,\"188\":5,\"198\":2,\"201\":1,\"213\":1,\"216\":1,\"225\":1,\"228\":1,\"272\":1,\"274\":1,\"280\":1,\"282\":1,\"287\":1,\"302\":2,\"303\":1,\"321\":1,\"322\":4,\"327\":6,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"378\":2,\"382\":2,\"383\":2,\"387\":4,\"389\":1,\"391\":1,\"392\":4,\"395\":1,\"396\":1,\"459\":4}}],[\"fromfilepath\",{\"1\":{\"349\":3}}],[\"fromfile\",{\"1\":{\"2\":1}}],[\"fruit>\",{\"1\":{\"292\":1}}],[\"fruits2\",{\"1\":{\"292\":2}}],[\"fruits\",{\"1\":{\"291\":1,\"292\":1}}],[\"fruit\",{\"1\":{\"291\":2,\"292\":1,\"293\":1}}],[\"friction\",{\"1\":{\"221\":1}}],[\"fragment或其他地方\",{\"1\":{\"400\":1}}],[\"fragment>\",{\"1\":{\"400\":2}}],[\"fragment\",{\"1\":{\"400\":9}}],[\"fragment类过多的时候\",{\"1\":{\"94\":1}}],[\"frank\",{\"1\":{\"55\":2}}],[\"frame等\",{\"1\":{\"396\":1}}],[\"frameinfo\",{\"1\":{\"196\":3}}],[\"framebuilder\",{\"1\":{\"193\":2,\"206\":2,\"207\":2}}],[\"framenumber\",{\"1\":{\"192\":3,\"193\":1}}],[\"frames\",{\"1\":{\"134\":1}}],[\"frame\",{\"1\":{\"118\":1,\"179\":1,\"180\":1,\"198\":1,\"216\":1,\"252\":2,\"278\":1,\"389\":1}}],[\"framework绑定到flutter\",{\"1\":{\"127\":1}}],[\"framework每次需要往屏幕上绘制内容时会依次遍历这四个列表\",{\"1\":{\"118\":1}}],[\"framework层\",{\"1\":{\"60\":1}}],[\"framework\",{\"1\":{\"60\":3,\"121\":2,\"122\":1,\"125\":2,\"126\":3,\"127\":5,\"132\":1,\"162\":1}}],[\"frameworks\",{\"1\":{\"13\":1,\"43\":1}}],[\"framelayout>\",{\"1\":{\"401\":1}}],[\"framelayout\",{\"1\":{\"13\":1}}],[\"fizz\",{\"1\":{\"334\":3}}],[\"fixed\",{\"1\":{\"241\":4,\"242\":2,\"328\":2}}],[\"fittedbox\",{\"1\":{\"206\":1}}],[\"fit\",{\"1\":{\"131\":2,\"193\":2,\"206\":4,\"207\":2,\"242\":2}}],[\"fires\",{\"1\":{\"105\":1}}],[\"firstdayofweek有关\",{\"1\":{\"302\":1}}],[\"firstdayofweek\",{\"1\":{\"302\":3}}],[\"firstvalue\",{\"1\":{\"288\":2}}],[\"firstheropage\",{\"1\":{\"170\":2,\"172\":1}}],[\"firstbuild\",{\"1\":{\"126\":1}}],[\"firstzerotimer\",{\"1\":{\"106\":3,\"108\":1,\"109\":1}}],[\"first\",{\"1\":{\"10\":1,\"13\":1,\"40\":1,\"58\":1,\"63\":2,\"98\":1,\"102\":1,\"108\":1,\"159\":4,\"170\":1,\"180\":1,\"225\":1,\"226\":2,\"243\":1,\"302\":3,\"337\":1,\"378\":1,\"383\":1}}],[\"fields\",{\"1\":{\"136\":1,\"277\":3,\"295\":2,\"300\":2,\"306\":1,\"307\":1,\"372\":1}}],[\"field\",{\"1\":{\"72\":5,\"86\":2,\"165\":1,\"295\":1,\"298\":1,\"299\":1,\"300\":6,\"302\":1,\"383\":5}}],[\"fifo\",{\"1\":{\"58\":1,\"106\":1,\"447\":1,\"452\":1}}],[\"fingerprints\",{\"1\":{\"383\":1}}],[\"finger\",{\"1\":{\"353\":1}}],[\"findnavcontroller\",{\"1\":{\"400\":2}}],[\"findplatform\",{\"1\":{\"363\":2}}],[\"finding\",{\"1\":{\"274\":1}}],[\"findclass\",{\"1\":{\"272\":3}}],[\"findbootstrapclassornull\",{\"1\":{\"272\":1}}],[\"findloadedclass\",{\"1\":{\"272\":1}}],[\"find\",{\"1\":{\"180\":1,\"243\":1,\"272\":1,\"371\":3}}],[\"findrenderobject\",{\"1\":{\"176\":1,\"180\":1}}],[\"findancestorwidgetofexacttype<hero>\",{\"1\":{\"176\":1}}],[\"findancestorwidgetofexacttype<appcolor>\",{\"1\":{\"130\":1}}],[\"findancestorwidgetofexacttype<t\",{\"1\":{\"129\":1}}],[\"findancestorparentdataelement\",{\"1\":{\"121\":1,\"127\":1}}],[\"findancestorrenderobjectelement\",{\"1\":{\"121\":1,\"127\":2}}],[\"findviewbyid\",{\"1\":{\"56\":1,\"66\":1,\"71\":1,\"300\":4}}],[\"finishes\",{\"1\":{\"180\":1}}],[\"finished\",{\"1\":{\"80\":2}}],[\"finishbroadcast\",{\"1\":{\"36\":1}}],[\"finish\",{\"1\":{\"13\":1,\"69\":1,\"80\":2,\"110\":2,\"111\":1,\"198\":2,\"368\":1,\"373\":2}}],[\"final的\",{\"1\":{\"377\":1}}],[\"finalcallback\",{\"1\":{\"365\":8}}],[\"final要保证可见性的前提是要被安全的构建出来\",{\"1\":{\"317\":1}}],[\"final和volatile保证\",{\"1\":{\"317\":1}}],[\"final修饰的常量除外\",{\"1\":{\"279\":1}}],[\"final对象中以便在需要的地方共享同一个对象\",{\"1\":{\"184\":1}}],[\"finalize\",{\"1\":{\"111\":2,\"112\":2}}],[\"final类型的measure\",{\"1\":{\"65\":1}}],[\"finally或者其他方法更好的实现\",{\"1\":{\"266\":1}}],[\"finally\",{\"1\":{\"36\":1,\"40\":1,\"58\":1,\"80\":3,\"98\":2,\"109\":1,\"126\":1,\"142\":1,\"209\":1,\"298\":1,\"305\":1,\"327\":2,\"328\":1,\"343\":1,\"365\":1}}],[\"final\",{\"1\":{\"13\":6,\"20\":1,\"24\":1,\"25\":2,\"30\":2,\"40\":2,\"43\":3,\"49\":2,\"51\":1,\"52\":2,\"58\":5,\"65\":1,\"72\":1,\"80\":6,\"99\":1,\"101\":2,\"102\":1,\"105\":2,\"106\":2,\"111\":4,\"112\":6,\"119\":1,\"121\":2,\"122\":1,\"125\":1,\"126\":1,\"127\":5,\"130\":5,\"131\":2,\"134\":1,\"147\":4,\"154\":1,\"155\":3,\"156\":2,\"162\":1,\"163\":1,\"166\":1,\"167\":3,\"172\":3,\"176\":2,\"177\":3,\"178\":2,\"179\":2,\"180\":15,\"181\":5,\"183\":4,\"190\":2,\"196\":3,\"198\":5,\"201\":8,\"202\":2,\"206\":1,\"207\":1,\"209\":1,\"210\":2,\"211\":6,\"213\":4,\"217\":1,\"220\":8,\"221\":4,\"223\":1,\"224\":2,\"225\":4,\"226\":10,\"227\":6,\"230\":1,\"233\":1,\"235\":3,\"238\":1,\"239\":1,\"280\":5,\"281\":8,\"282\":1,\"283\":1,\"285\":7,\"287\":2,\"288\":2,\"296\":2,\"297\":2,\"304\":1,\"309\":2,\"314\":1,\"365\":9,\"377\":1,\"378\":6}}],[\"filo\",{\"1\":{\"446\":1,\"452\":1}}],[\"fills\",{\"1\":{\"131\":1}}],[\"filled\",{\"1\":{\"102\":1,\"127\":1,\"210\":1,\"376\":1}}],[\"fill\",{\"1\":{\"58\":1,\"63\":1,\"131\":1}}],[\"filtercheck\",{\"1\":{\"305\":2}}],[\"filter\",{\"1\":{\"305\":1,\"321\":1,\"327\":1,\"338\":1,\"346\":2}}],[\"filterquality\",{\"1\":{\"155\":5,\"193\":2}}],[\"filter也无法隐式调用\",{\"1\":{\"17\":1}}],[\"filter则默认为true\",{\"1\":{\"17\":1}}],[\"filter>\",{\"1\":{\"17\":2,\"79\":2}}],[\"filterequals\",{\"1\":{\"12\":1}}],[\"file或者重新登录使其立即生效\",{\"1\":{\"361\":1}}],[\"filename\",{\"1\":{\"349\":4,\"351\":1,\"356\":1,\"361\":3}}],[\"filenotfoundexception\",{\"1\":{\"308\":1,\"309\":1}}],[\"fileoutputstream\",{\"1\":{\"308\":1,\"309\":1}}],[\"fileopen\",{\"1\":{\"111\":1}}],[\"filed=\",{\"1\":{\"308\":2,\"309\":2}}],[\"filed\",{\"1\":{\"308\":9,\"309\":2}}],[\"fileinputstream\",{\"1\":{\"272\":3,\"308\":1,\"309\":1}}],[\"fileimage\",{\"1\":{\"196\":1}}],[\"file等构造函数从网络\",{\"1\":{\"204\":1}}],[\"filemode\",{\"1\":{\"111\":8}}],[\"fileread\",{\"1\":{\"111\":1}}],[\"fileresourceinfo\",{\"1\":{\"111\":2}}],[\"file下面的目录\",{\"1\":{\"2\":1}}],[\"filestat\",{\"1\":{\"201\":1}}],[\"filesystemexception\",{\"1\":{\"111\":3}}],[\"filesystementity\",{\"1\":{\"111\":3}}],[\"files\",{\"0\":{\"247\":1},\"1\":{\"2\":2,\"383\":1,\"392\":2,\"426\":4}}],[\"filepath\",{\"1\":{\"110\":2}}],[\"filepathcolumn\",{\"1\":{\"2\":2}}],[\"fileprovider是fileprovider的authorities\",{\"1\":{\"2\":1}}],[\"fileprovider\",{\"1\":{\"2\":7}}],[\"file\",{\"1\":{\"2\":6,\"14\":1,\"40\":2,\"110\":6,\"111\":30,\"115\":32,\"188\":2,\"200\":1,\"201\":4,\"209\":1,\"211\":3,\"272\":2,\"308\":5,\"309\":5,\"314\":2,\"321\":1,\"345\":2,\"349\":1,\"356\":3,\"368\":1,\"370\":16,\"373\":2,\"382\":4,\"387\":1,\"389\":1,\"417\":1,\"426\":4}}],[\"fliter\",{\"1\":{\"327\":1}}],[\"flippedcurve\",{\"1\":{\"186\":1}}],[\"flipped\",{\"1\":{\"177\":1,\"186\":1}}],[\"flightdirection\",{\"1\":{\"180\":1}}],[\"flightcontext\",{\"1\":{\"180\":1}}],[\"flighttype\",{\"1\":{\"179\":5,\"180\":2}}],[\"flights\",{\"1\":{\"178\":1,\"180\":5}}],[\"flightshuttlebuilder\",{\"1\":{\"174\":2,\"175\":1,\"180\":2}}],[\"flight\",{\"1\":{\"176\":1,\"177\":1,\"180\":6}}],[\"fling\",{\"1\":{\"55\":1,\"161\":1,\"168\":2}}],[\"flexfit\",{\"1\":{\"131\":4}}],[\"flex\",{\"1\":{\"131\":7}}],[\"flexible的child最大可以是父容器分配给flexible的大小\",{\"1\":{\"131\":1}}],[\"flexible\",{\"0\":{\"131\":1},\"1\":{\"131\":12,\"242\":2}}],[\"flush\",{\"1\":{\"115\":1,\"309\":2}}],[\"flutter使用封装过的cfe以及一个flutter独有的kernel\",{\"1\":{\"393\":1}}],[\"flutter滑动分析之singlechildscrollview\",{\"0\":{\"234\":1}}],[\"flutter滑动分析之scrollview\",{\"0\":{\"227\":1}}],[\"flutter滑动分析之nestedscrollview\",{\"0\":{\"212\":1}}],[\"fluttersingleframeimage\",{\"1\":{\"211\":1}}],[\"flutteractivity\",{\"1\":{\"211\":1}}],[\"flutterassetstream\",{\"1\":{\"137\":1}}],[\"flutterimage\",{\"1\":{\"211\":1}}],[\"flutterpluginbinding\",{\"1\":{\"211\":6}}],[\"flutterplugin\",{\"1\":{\"211\":1}}],[\"flutterpixelformat\",{\"1\":{\"211\":1}}],[\"flutter图片加载方案分析之power\",{\"0\":{\"203\":1}}],[\"flutter图片加载方案分析之extended\",{\"0\":{\"199\":1}}],[\"flutter图片加载方案分析之image\",{\"0\":{\"187\":1}}],[\"flutter动画分析之tween\",{\"0\":{\"182\":1}}],[\"flutter动画分析之hero\",{\"0\":{\"169\":1}}],[\"flutter动画分析之animationcontroller\",{\"0\":{\"157\":1}}],[\"flutter动画分析之animatedwidget\",{\"0\":{\"146\":1}}],[\"flutter各种动画底层类关系\",{\"1\":{\"157\":1,\"182\":1}}],[\"flutter中animationcontroller与ticker关系\",{\"1\":{\"157\":1}}],[\"flutter中与动画有关的widget\",{\"1\":{\"146\":1,\"157\":1}}],[\"flutter中的scrollable\",{\"1\":{\"234\":1}}],[\"flutter中的错误处理分为以下几种\",{\"1\":{\"141\":1}}],[\"flutter中的错误都会被fluttererror\",{\"1\":{\"141\":1}}],[\"flutter中的错误不会导致应用程序奔溃\",{\"1\":{\"141\":1}}],[\"flutter中的异常处理\",{\"0\":{\"141\":1}}],[\"flutter中的\",{\"1\":{\"140\":1}}],[\"flutter异常处理\",{\"1\":{\"145\":1}}],[\"fluttererror\",{\"0\":{\"144\":1},\"1\":{\"144\":2,\"230\":2}}],[\"fluttererrordetails\",{\"1\":{\"143\":2}}],[\"flutter框架会调用errorwidget\",{\"1\":{\"143\":1}}],[\"flutter有布局widget如\",{\"1\":{\"139\":1}}],[\"flutter生命周期没有android中那么\",{\"1\":{\"138\":1}}],[\"flutter可以间接访问android资源\",{\"1\":{\"137\":1}}],[\"flutter是单线程的\",{\"1\":{\"136\":1}}],[\"flutter是google提出的跨平台开发框架\",{\"1\":{\"132\":1}}],[\"flutter对此相应\",{\"1\":{\"135\":1}}],[\"flutter项目启动后会首先加载\",{\"1\":{\"132\":1}}],[\"flutter工程的配置信息\",{\"1\":{\"132\":1}}],[\"flutter以dart开发\",{\"1\":{\"132\":1}}],[\"flutter一个重要的概念即是\",{\"1\":{\"132\":1}}],[\"flutter学习\",{\"1\":{\"130\":1}}],[\"flutter的渲染流程如图\",{\"1\":{\"128\":1}}],[\"flutter的widget分为statefulwidget和statelesswidget\",{\"1\":{\"128\":1}}],[\"flutter\",{\"0\":{\"117\":1,\"128\":1,\"131\":1,\"132\":1},\"1\":{\"111\":1,\"116\":2,\"117\":2,\"118\":1,\"119\":1,\"125\":1,\"127\":6,\"128\":3,\"130\":2,\"132\":2,\"135\":1,\"136\":1,\"137\":2,\"140\":4,\"141\":2,\"145\":1,\"146\":9,\"152\":1,\"156\":4,\"157\":13,\"162\":1,\"168\":8,\"169\":1,\"170\":1,\"171\":3,\"172\":2,\"174\":1,\"180\":2,\"181\":2,\"182\":1,\"183\":1,\"186\":6,\"187\":3,\"188\":2,\"198\":5,\"199\":2,\"202\":4,\"203\":11,\"205\":1,\"207\":2,\"208\":2,\"211\":21,\"212\":1,\"226\":1,\"227\":2,\"231\":1,\"233\":2,\"242\":1,\"373\":1,\"393\":1}}],[\"flutter之timer原理解析\",{\"1\":{\"109\":1}}],[\"flutter之future原理解析\",{\"1\":{\"109\":1}}],[\"floor\",{\"1\":{\"184\":1}}],[\"flow则支持挂起函数异步返回多个值\",{\"1\":{\"335\":1}}],[\"flow是kotlin协程库中的库\",{\"1\":{\"335\":1}}],[\"flow是用来异步返回多个值\",{\"1\":{\"328\":1}}],[\"flowon\",{\"1\":{\"327\":1,\"339\":1}}],[\"flowof\",{\"1\":{\"327\":3,\"336\":2}}],[\"flow<int>\",{\"1\":{\"327\":4,\"336\":4,\"339\":1,\"341\":1}}],[\"flow\",{\"1\":{\"128\":2,\"327\":6,\"328\":1,\"336\":1,\"339\":1,\"341\":1,\"342\":1,\"344\":1,\"395\":1,\"396\":1}}],[\"floitsch\",{\"1\":{\"101\":1}}],[\"floated\",{\"1\":{\"226\":1}}],[\"floating\",{\"1\":{\"221\":1}}],[\"floatheaderslivers为true\",{\"1\":{\"226\":1}}],[\"floatheaderslivers\",{\"1\":{\"213\":1,\"224\":1,\"226\":2}}],[\"float\",{\"1\":{\"15\":2,\"53\":2,\"56\":2,\"61\":10,\"63\":1,\"64\":7,\"226\":1,\"280\":1,\"287\":1,\"299\":1,\"311\":1}}],[\"flattenmerge\",{\"1\":{\"340\":1}}],[\"flattenconcat\",{\"1\":{\"340\":1}}],[\"flattonmerge\",{\"1\":{\"327\":1}}],[\"flatmaplatest\",{\"1\":{\"327\":1,\"340\":1}}],[\"flatmapmerge\",{\"1\":{\"327\":2,\"340\":1}}],[\"flatmapconcat\",{\"1\":{\"327\":1,\"340\":1}}],[\"flatmap\",{\"1\":{\"321\":3,\"345\":2}}],[\"flavordimensions\",{\"1\":{\"54\":1}}],[\"flavor\",{\"1\":{\"54\":2}}],[\"flagsinitialize\",{\"1\":{\"388\":1}}],[\"flags有三个常用选项\",{\"1\":{\"41\":1}}],[\"flags则是指定绑定时是否自动创建service\",{\"1\":{\"19\":1}}],[\"flags\",{\"1\":{\"17\":2,\"40\":2,\"58\":2,\"314\":1,\"379\":1,\"383\":5,\"384\":5,\"386\":5,\"387\":16,\"388\":8}}],[\"flag\",{\"1\":{\"0\":1,\"2\":4,\"13\":3,\"17\":2,\"36\":1,\"41\":3,\"57\":1,\"63\":1,\"65\":2,\"115\":6,\"383\":6,\"389\":1,\"391\":5}}],[\"fly\",{\"1\":{\"1\":1}}],[\"=12\",{\"1\":{\"282\":1}}],[\"=overscroll的结果是outerdelta是outer消耗的那一部分内容\",{\"1\":{\"226\":1}}],[\"=>load\",{\"1\":{\"196\":1}}],[\"=>\",{\"1\":{\"95\":4,\"101\":2,\"103\":3,\"120\":2,\"125\":1,\"126\":1,\"128\":4,\"130\":4,\"131\":1,\"132\":1,\"147\":2,\"152\":1,\"155\":2,\"165\":1,\"183\":2,\"184\":1,\"185\":1,\"186\":2,\"192\":1,\"196\":1,\"202\":3,\"207\":1,\"212\":3,\"213\":3,\"226\":1,\"228\":1,\"233\":1,\"234\":1,\"239\":1,\"377\":1}}],[\"==\",{\"0\":{\"107\":1},\"1\":{\"13\":8,\"36\":3,\"40\":1,\"45\":1,\"46\":1,\"49\":3,\"55\":1,\"58\":1,\"64\":2,\"65\":4,\"69\":1,\"72\":1,\"80\":8,\"81\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":2,\"101\":2,\"102\":8,\"103\":2,\"104\":2,\"105\":3,\"106\":4,\"108\":3,\"109\":5,\"110\":1,\"111\":6,\"112\":4,\"115\":12,\"116\":1,\"118\":1,\"119\":1,\"121\":2,\"126\":4,\"127\":1,\"128\":2,\"130\":1,\"131\":2,\"162\":1,\"163\":1,\"166\":2,\"176\":2,\"177\":2,\"179\":4,\"180\":3,\"181\":5,\"184\":2,\"185\":3,\"186\":2,\"191\":2,\"192\":1,\"198\":1,\"201\":4,\"205\":2,\"206\":1,\"209\":1,\"211\":4,\"220\":1,\"221\":1,\"223\":2,\"225\":1,\"226\":1,\"227\":1,\"230\":1,\"235\":1,\"237\":1,\"238\":2,\"240\":1,\"254\":1,\"272\":2,\"280\":1,\"294\":4,\"296\":1,\"297\":5,\"305\":1,\"309\":6,\"312\":1,\"322\":2,\"363\":2,\"364\":1,\"365\":2,\"378\":1,\"380\":2,\"381\":4,\"382\":1,\"383\":4,\"384\":1,\"386\":4,\"387\":9,\"388\":2,\"389\":1,\"391\":12,\"430\":1,\"432\":7,\"438\":3,\"441\":1,\"451\":3,\"453\":5,\"459\":5,\"462\":3}}],[\"=\",{\"1\":{\"2\":5,\"10\":4,\"11\":4,\"12\":1,\"13\":29,\"15\":6,\"17\":2,\"19\":6,\"20\":10,\"24\":4,\"25\":3,\"28\":4,\"29\":2,\"30\":2,\"32\":1,\"35\":10,\"36\":12,\"37\":3,\"40\":8,\"41\":3,\"42\":1,\"43\":13,\"44\":1,\"45\":8,\"46\":1,\"47\":4,\"48\":13,\"49\":6,\"50\":4,\"51\":1,\"52\":3,\"53\":13,\"54\":8,\"56\":9,\"57\":3,\"58\":19,\"61\":2,\"62\":4,\"63\":19,\"64\":17,\"65\":16,\"66\":3,\"69\":5,\"72\":28,\"77\":1,\"78\":11,\"79\":4,\"80\":23,\"81\":32,\"82\":2,\"84\":1,\"85\":7,\"86\":2,\"87\":3,\"89\":1,\"91\":3,\"92\":1,\"96\":6,\"97\":6,\"98\":12,\"99\":2,\"100\":3,\"101\":4,\"102\":22,\"103\":10,\"104\":1,\"105\":12,\"106\":14,\"108\":19,\"109\":18,\"110\":5,\"111\":32,\"112\":21,\"114\":3,\"115\":79,\"116\":4,\"118\":11,\"119\":3,\"121\":19,\"122\":6,\"125\":2,\"126\":18,\"127\":19,\"128\":7,\"130\":10,\"131\":5,\"135\":6,\"136\":3,\"137\":1,\"142\":2,\"143\":3,\"144\":1,\"147\":3,\"149\":6,\"150\":4,\"152\":1,\"153\":5,\"154\":1,\"155\":3,\"156\":2,\"161\":5,\"162\":6,\"163\":4,\"164\":1,\"165\":1,\"166\":1,\"167\":3,\"172\":5,\"173\":1,\"175\":1,\"176\":10,\"177\":3,\"178\":4,\"179\":4,\"180\":20,\"181\":16,\"185\":1,\"186\":1,\"188\":2,\"190\":5,\"191\":5,\"192\":7,\"193\":9,\"196\":4,\"198\":18,\"201\":19,\"202\":7,\"205\":2,\"206\":1,\"207\":3,\"209\":7,\"210\":6,\"211\":65,\"212\":1,\"213\":13,\"217\":1,\"220\":13,\"221\":7,\"223\":4,\"225\":8,\"226\":24,\"227\":8,\"230\":1,\"235\":10,\"236\":3,\"237\":2,\"238\":3,\"239\":6,\"240\":1,\"254\":2,\"265\":2,\"268\":1,\"269\":1,\"272\":21,\"277\":3,\"280\":12,\"281\":9,\"282\":18,\"283\":3,\"285\":7,\"287\":2,\"288\":14,\"289\":26,\"291\":8,\"292\":1,\"294\":6,\"295\":4,\"296\":24,\"297\":6,\"299\":1,\"300\":8,\"302\":7,\"304\":1,\"305\":7,\"306\":5,\"308\":11,\"309\":9,\"311\":8,\"314\":3,\"317\":1,\"321\":6,\"322\":20,\"325\":3,\"326\":1,\"327\":14,\"328\":15,\"330\":1,\"334\":6,\"336\":3,\"339\":1,\"341\":2,\"345\":6,\"346\":15,\"351\":1,\"362\":3,\"363\":3,\"364\":10,\"365\":6,\"367\":5,\"369\":3,\"370\":19,\"371\":21,\"373\":5,\"376\":8,\"377\":3,\"378\":18,\"379\":1,\"380\":3,\"381\":10,\"382\":32,\"383\":42,\"384\":9,\"386\":9,\"387\":25,\"388\":5,\"389\":63,\"390\":1,\"391\":55,\"400\":2,\"401\":3,\"402\":1,\"422\":4,\"424\":5,\"425\":3,\"426\":2,\"427\":7,\"428\":2,\"429\":2,\"432\":25,\"437\":10,\"438\":19,\"440\":7,\"441\":13,\"450\":1,\"451\":6,\"453\":12,\"455\":5,\"456\":7,\"457\":5,\"459\":17,\"460\":1,\"462\":9,\"467\":9}}],[\"c→a的情况\",{\"1\":{\"438\":1}}],[\"css\",{\"1\":{\"417\":1}}],[\"csdn博客\",{\"1\":{\"21\":1,\"22\":1,\"55\":2,\"116\":1,\"272\":1,\"279\":2,\"296\":1,\"421\":1,\"427\":1}}],[\"csdn\",{\"1\":{\"15\":3,\"35\":1,\"40\":1,\"41\":1,\"54\":3,\"58\":7,\"59\":1,\"63\":1,\"115\":1,\"273\":1,\"279\":1,\"283\":1,\"287\":1,\"288\":1,\"294\":1}}],[\"ctrl+c\",{\"1\":{\"414\":1}}],[\"cthread\",{\"1\":{\"297\":1}}],[\"cmd\",{\"1\":{\"368\":1,\"411\":1}}],[\"cmd脚本内容\",{\"1\":{\"368\":1}}],[\"cmd脚本\",{\"1\":{\"368\":1}}],[\"cmd1\",{\"1\":{\"361\":2}}],[\"cmd0\",{\"1\":{\"361\":2}}],[\"cdtv\",{\"1\":{\"356\":1}}],[\"cd\",{\"1\":{\"349\":5,\"407\":8,\"414\":1}}],[\"cparentnode\",{\"1\":{\"432\":3}}],[\"cp\",{\"1\":{\"349\":1,\"407\":2}}],[\"cp拷贝\",{\"1\":{\"349\":1}}],[\"cpu\",{\"1\":{\"327\":2,\"339\":1}}],[\"cpu获取到虚拟地址\",{\"1\":{\"58\":1}}],[\"ci\",{\"1\":{\"407\":2}}],[\"cinv\",{\"1\":{\"361\":1}}],[\"city\",{\"1\":{\"321\":6,\"369\":1}}],[\"cipher\",{\"1\":{\"296\":12}}],[\"cycle\",{\"1\":{\"302\":1,\"372\":1}}],[\"craw\",{\"1\":{\"370\":2,\"371\":2}}],[\"crash\",{\"1\":{\"112\":1,\"211\":1}}],[\"crossinline\",{\"1\":{\"322\":2}}],[\"cross\",{\"1\":{\"147\":1,\"228\":2}}],[\"creating\",{\"1\":{\"274\":1,\"277\":1,\"426\":1}}],[\"creation\",{\"1\":{\"115\":1,\"383\":1,\"389\":1}}],[\"creator<aparcelable>\",{\"1\":{\"314\":1}}],[\"creator<book>\",{\"1\":{\"314\":2}}],[\"creator\",{\"1\":{\"58\":1,\"314\":2}}],[\"createandsetupserviceisolate\",{\"1\":{\"387\":1}}],[\"createandsetupdartdevisolate\",{\"1\":{\"387\":1}}],[\"createandsetupkernelisolate\",{\"1\":{\"387\":1}}],[\"creategroupcallback\",{\"0\":{\"387\":1},\"1\":{\"386\":2}}],[\"createwithinexistingisolategroup\",{\"0\":{\"383\":1},\"1\":{\"381\":2,\"383\":1}}],[\"createfromparcel\",{\"1\":{\"314\":1}}],[\"createfile\",{\"1\":{\"111\":1}}],[\"createmap\",{\"1\":{\"288\":3}}],[\"creatematerialherocontroller\",{\"1\":{\"178\":2}}],[\"createballisticsimulation\",{\"1\":{\"225\":3}}],[\"createballisticscrollactivity\",{\"1\":{\"225\":3}}],[\"createisolategroup的过程\",{\"1\":{\"388\":1}}],[\"createisolategroup\",{\"0\":{\"388\":1},\"1\":{\"387\":2,\"388\":1}}],[\"createisolategroupfromkernel\",{\"1\":{\"387\":1}}],[\"createisolategroupandsetuphelper按照是jit还是aot的编译方式\",{\"1\":{\"387\":1}}],[\"createisolategroupandsetuphelper\",{\"1\":{\"387\":4}}],[\"createisolategroupandsetup\",{\"1\":{\"382\":1,\"387\":1}}],[\"createisolate创建了isolate\",{\"1\":{\"383\":1}}],[\"createisolate\",{\"1\":{\"381\":1,\"383\":5,\"388\":1}}],[\"createinnerballisticscrollactivity\",{\"1\":{\"225\":2}}],[\"createimage\",{\"1\":{\"210\":2}}],[\"createimageinfo\",{\"1\":{\"208\":1,\"209\":1,\"210\":1,\"211\":2}}],[\"createouterballisticscrollactivity\",{\"1\":{\"225\":2}}],[\"createosthread\",{\"1\":{\"115\":3}}],[\"createlocalimageconfiguration\",{\"1\":{\"188\":1,\"190\":1}}],[\"createlink\",{\"1\":{\"115\":1}}],[\"createherorecttween\",{\"1\":{\"177\":1,\"181\":1}}],[\"createrecttween\",{\"1\":{\"174\":1,\"175\":1,\"177\":6,\"178\":4,\"180\":2}}],[\"createrenderobject\",{\"1\":{\"120\":2,\"121\":1,\"122\":1,\"127\":3,\"228\":2,\"236\":1}}],[\"createcurve\",{\"1\":{\"147\":2,\"150\":1}}],[\"createelement和text对应的element\",{\"1\":{\"126\":1}}],[\"createelement方法创建element\",{\"1\":{\"122\":1}}],[\"createelement\",{\"1\":{\"120\":1,\"121\":1,\"122\":1,\"125\":1,\"126\":1,\"228\":1}}],[\"createviewconfiguration\",{\"1\":{\"118\":1}}],[\"create参数含义\",{\"1\":{\"115\":1}}],[\"createpackagecontext\",{\"1\":{\"423\":1}}],[\"createport中\",{\"1\":{\"378\":1}}],[\"createport的实现\",{\"1\":{\"115\":1}}],[\"createport\",{\"1\":{\"115\":2,\"383\":1}}],[\"createperiodictimer\",{\"1\":{\"104\":2,\"105\":5}}],[\"create之类的操作会调用这个方法\",{\"1\":{\"111\":1}}],[\"createticker\",{\"1\":{\"161\":1}}],[\"createtimerhandler\",{\"1\":{\"106\":4,\"107\":1,\"108\":1}}],[\"createtimer方法\",{\"1\":{\"105\":1}}],[\"createtimer\",{\"1\":{\"104\":2,\"105\":8}}],[\"createtemp\",{\"1\":{\"115\":1}}],[\"createtypedarraylist\",{\"1\":{\"58\":1}}],[\"createscrollposition\",{\"1\":{\"215\":1,\"223\":1}}],[\"createstate\",{\"1\":{\"130\":3,\"131\":1,\"134\":1,\"147\":2,\"206\":1,\"207\":1,\"213\":1}}],[\"creates\",{\"1\":{\"80\":1,\"105\":2,\"115\":1,\"118\":1,\"120\":1,\"122\":1,\"131\":1,\"132\":1,\"156\":1,\"185\":1,\"225\":1,\"233\":2,\"378\":3,\"387\":2}}],[\"created\",{\"1\":{\"24\":1,\"35\":1,\"36\":1,\"75\":1,\"95\":5,\"105\":1,\"118\":1,\"345\":1,\"383\":1,\"387\":6,\"395\":1,\"426\":1}}],[\"create则代表自动创建\",{\"1\":{\"19\":1}}],[\"create\",{\"0\":{\"245\":1},\"1\":{\"17\":1,\"19\":1,\"20\":1,\"35\":1,\"58\":2,\"69\":2,\"84\":1,\"92\":1,\"106\":1,\"111\":1,\"112\":1,\"115\":4,\"201\":2,\"210\":2,\"211\":2,\"228\":1,\"314\":1,\"378\":1,\"381\":1,\"382\":1,\"383\":4,\"386\":4,\"387\":1,\"389\":1,\"426\":1}}],[\"c790f8d46bec0975f565e211\",{\"1\":{\"63\":1}}],[\"cup调度t2开始执行tag1\",{\"1\":{\"294\":1}}],[\"cupertinotabview\",{\"1\":{\"178\":1}}],[\"cupertinoapp\",{\"1\":{\"178\":1,\"181\":1}}],[\"customscrollview等\",{\"1\":{\"242\":1}}],[\"customscrollview等基于sliver\",{\"1\":{\"240\":1}}],[\"customscrollview\",{\"1\":{\"212\":4,\"213\":3,\"226\":4,\"227\":2,\"233\":6}}],[\"custompainter\",{\"1\":{\"146\":1,\"156\":1,\"157\":1}}],[\"customerwidget\",{\"1\":{\"133\":1,\"134\":1}}],[\"custom\",{\"1\":{\"115\":1,\"172\":1,\"202\":1,\"233\":1,\"426\":1}}],[\"cubicto\",{\"1\":{\"61\":2,\"63\":1}}],[\"curveanimation\",{\"1\":{\"186\":1}}],[\"curvetween\",{\"0\":{\"185\":1},\"1\":{\"157\":1,\"182\":3,\"183\":1,\"185\":6,\"186\":3}}],[\"curvedanimation\",{\"1\":{\"147\":2,\"150\":1,\"159\":1,\"177\":1,\"182\":1}}],[\"curves\",{\"1\":{\"147\":1,\"161\":2,\"166\":1,\"177\":2,\"186\":2}}],[\"curve\",{\"0\":{\"182\":1,\"186\":1},\"1\":{\"146\":1,\"147\":8,\"150\":3,\"154\":1,\"156\":1,\"157\":2,\"159\":1,\"161\":4,\"166\":3,\"167\":1,\"168\":1,\"177\":1,\"182\":4,\"185\":11,\"186\":14}}],[\"currentisolategroupdata\",{\"1\":{\"382\":1}}],[\"currentisolate是static\",{\"1\":{\"377\":1}}],[\"currentisolate\",{\"1\":{\"377\":2,\"382\":1}}],[\"currentcoroutinecontext\",{\"1\":{\"342\":1}}],[\"currentdrag\",{\"1\":{\"225\":2,\"226\":2}}],[\"currently\",{\"1\":{\"97\":1,\"98\":1,\"109\":1,\"111\":1,\"220\":1,\"225\":1}}],[\"current\",{\"1\":{\"96\":3,\"97\":1,\"103\":1,\"104\":8,\"110\":1,\"111\":1,\"115\":5,\"116\":3,\"144\":1,\"147\":1,\"153\":1,\"158\":2,\"278\":1,\"302\":1,\"306\":1,\"370\":2,\"373\":7,\"376\":1,\"377\":4,\"378\":2,\"381\":4,\"382\":2,\"383\":4,\"384\":1,\"386\":1,\"387\":3,\"388\":1,\"389\":4,\"391\":3,\"432\":30,\"438\":3}}],[\"currentzone\",{\"1\":{\"96\":6,\"103\":4}}],[\"currentactivitythread\",{\"1\":{\"72\":4}}],[\"currentsize\",{\"1\":{\"45\":1}}],[\"currenttween\",{\"1\":{\"153\":9}}],[\"currenttimems\",{\"1\":{\"110\":3}}],[\"currenttimemillis\",{\"1\":{\"10\":1,\"297\":2,\"309\":1,\"327\":2}}],[\"currentthread\",{\"1\":{\"24\":1,\"72\":1,\"272\":4,\"288\":4,\"325\":1}}],[\"curry\",{\"1\":{\"41\":1}}],[\"currx\",{\"1\":{\"41\":1}}],[\"cursor\",{\"1\":{\"2\":5}}],[\"c++\",{\"1\":{\"60\":1}}],[\"c\",{\"1\":{\"60\":1,\"64\":2,\"80\":3,\"272\":8,\"317\":1,\"321\":1,\"344\":2,\"347\":1,\"356\":2,\"357\":3,\"361\":1,\"369\":5}}],[\"cchildnode\",{\"1\":{\"432\":10}}],[\"cc中\",{\"1\":{\"372\":1}}],[\"cc\",{\"1\":{\"58\":2,\"100\":1,\"108\":2,\"114\":1,\"115\":13,\"116\":2,\"288\":1,\"376\":1,\"377\":2,\"379\":1,\"380\":1,\"381\":2,\"382\":4,\"383\":4,\"384\":1,\"387\":2,\"388\":1,\"389\":6,\"390\":1,\"391\":4}}],[\"cbc\",{\"1\":{\"296\":1}}],[\"cb\",{\"1\":{\"36\":3,\"115\":6}}],[\"cfg由intermediate\",{\"1\":{\"395\":1}}],[\"cfg\",{\"1\":{\"395\":1}}],[\"cfe\",{\"1\":{\"387\":4,\"392\":1,\"393\":1}}],[\"cfm\",{\"1\":{\"282\":2}}],[\"cf\",{\"1\":{\"17\":1,\"34\":2,\"35\":9,\"36\":4,\"40\":11,\"41\":1,\"54\":2,\"56\":2,\"61\":1,\"295\":2,\"421\":2,\"423\":1,\"427\":1}}],[\"c1575636741ehttps\",{\"1\":{\"15\":1}}],[\"centerkey\",{\"1\":{\"451\":3}}],[\"centerindex\",{\"1\":{\"451\":5}}],[\"center等效果\",{\"0\":{\"241\":1}}],[\"center等都是widget\",{\"1\":{\"132\":1}}],[\"center对应的element的\",{\"1\":{\"126\":1}}],[\"center是在创建center的时候默认设置的对齐方式\",{\"1\":{\"123\":1}}],[\"center的父类可以创建自己的renderobject\",{\"1\":{\"122\":1}}],[\"center代码十分简单\",{\"1\":{\"122\":1}}],[\"centerslice\",{\"1\":{\"193\":2}}],[\"centers\",{\"1\":{\"122\":1}}],[\"center非必须\",{\"1\":{\"117\":1}}],[\"centery\",{\"1\":{\"64\":1}}],[\"centery等\",{\"1\":{\"64\":1}}],[\"centerx\",{\"1\":{\"64\":1}}],[\"center\",{\"0\":{\"123\":1,\"125\":1},\"1\":{\"15\":3,\"58\":1,\"64\":1,\"66\":1,\"117\":11,\"122\":9,\"124\":1,\"125\":4,\"126\":1,\"127\":1,\"131\":1,\"135\":1,\"155\":1,\"172\":2,\"212\":1,\"225\":1,\"228\":2,\"231\":7,\"234\":1,\"241\":2,\"242\":2}}],[\"cls=clear\",{\"1\":{\"359\":1}}],[\"cls\",{\"1\":{\"357\":1}}],[\"cl\",{\"1\":{\"312\":1}}],[\"cleaned\",{\"1\":{\"376\":1}}],[\"clean\",{\"1\":{\"126\":1,\"282\":2,\"297\":1,\"407\":2}}],[\"cleanupvalue\",{\"1\":{\"102\":2}}],[\"cleanup\",{\"1\":{\"102\":7,\"382\":2}}],[\"clearoobqueue\",{\"1\":{\"391\":1}}],[\"clear\",{\"1\":{\"57\":1,\"357\":1,\"391\":1}}],[\"clazza>则会被擦除为clazza\",{\"1\":{\"290\":1}}],[\"clazz\",{\"1\":{\"272\":6,\"295\":6,\"300\":3,\"308\":3,\"309\":4,\"322\":2,\"424\":2}}],[\"clampeddelta\",{\"1\":{\"220\":2,\"226\":1}}],[\"clampingscrollphysics\",{\"1\":{\"213\":3}}],[\"clamp\",{\"1\":{\"63\":1,\"152\":1,\"162\":1,\"163\":1,\"166\":1,\"220\":1}}],[\"classb\",{\"1\":{\"322\":3}}],[\"classa\",{\"1\":{\"322\":1}}],[\"classdesc\",{\"1\":{\"305\":1}}],[\"class类型\",{\"1\":{\"299\":1}}],[\"class打包为sizeof\",{\"1\":{\"282\":1}}],[\"class对象没有明确规定实在java堆中\",{\"1\":{\"274\":1}}],[\"class对象\",{\"1\":{\"274\":1,\"279\":1}}],[\"classformaterror\",{\"1\":{\"272\":1}}],[\"classfile\",{\"1\":{\"272\":2}}],[\"classpath\",{\"1\":{\"272\":2}}],[\"classnotfoundexception\",{\"1\":{\"272\":3,\"306\":2,\"308\":1,\"309\":1,\"311\":1,\"363\":1}}],[\"classname\",{\"1\":{\"20\":1,\"272\":3,\"321\":2,\"322\":1}}],[\"classloader如果没有指定父加载器\",{\"1\":{\"272\":1}}],[\"classloader\",{\"1\":{\"272\":10,\"313\":1,\"321\":1,\"424\":2,\"426\":1}}],[\"classkey\",{\"1\":{\"91\":1}}],[\"class<\",{\"1\":{\"72\":1,\"272\":3,\"295\":1,\"300\":1}}],[\"classes\",{\"1\":{\"14\":1,\"276\":1,\"278\":1,\"283\":1,\"295\":1,\"322\":2,\"372\":1,\"396\":1}}],[\"class\",{\"1\":{\"14\":7,\"17\":2,\"19\":4,\"20\":4,\"35\":2,\"36\":1,\"40\":3,\"43\":3,\"44\":1,\"54\":1,\"56\":1,\"58\":3,\"71\":2,\"72\":12,\"75\":1,\"79\":3,\"80\":3,\"81\":2,\"82\":3,\"83\":2,\"85\":6,\"86\":1,\"87\":2,\"89\":2,\"90\":1,\"91\":6,\"92\":1,\"93\":2,\"96\":1,\"98\":1,\"99\":2,\"101\":1,\"103\":1,\"105\":3,\"106\":1,\"108\":2,\"111\":5,\"112\":3,\"115\":1,\"118\":2,\"120\":1,\"121\":3,\"122\":2,\"125\":1,\"126\":3,\"127\":5,\"130\":9,\"131\":3,\"132\":1,\"133\":1,\"134\":2,\"135\":1,\"143\":1,\"147\":2,\"152\":2,\"153\":1,\"154\":1,\"155\":2,\"156\":1,\"158\":1,\"159\":1,\"160\":1,\"165\":1,\"172\":1,\"175\":1,\"177\":1,\"178\":2,\"181\":3,\"183\":2,\"184\":2,\"185\":1,\"186\":3,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"201\":2,\"205\":1,\"206\":2,\"207\":2,\"210\":2,\"211\":11,\"213\":2,\"217\":2,\"224\":1,\"227\":1,\"228\":2,\"229\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":1,\"235\":1,\"236\":1,\"237\":1,\"272\":11,\"273\":1,\"274\":3,\"275\":4,\"276\":1,\"277\":1,\"279\":2,\"281\":11,\"282\":7,\"283\":1,\"285\":3,\"287\":3,\"288\":1,\"290\":1,\"291\":4,\"294\":7,\"295\":4,\"298\":1,\"300\":2,\"305\":2,\"306\":1,\"308\":3,\"309\":4,\"311\":1,\"314\":3,\"321\":6,\"322\":17,\"326\":2,\"345\":1,\"346\":1,\"363\":2,\"369\":3,\"370\":1,\"371\":6,\"380\":1,\"383\":1,\"386\":1,\"389\":2,\"391\":3,\"402\":2,\"424\":1,\"427\":3,\"429\":1}}],[\"cloned\",{\"1\":{\"383\":4}}],[\"clonearray\",{\"1\":{\"305\":1}}],[\"cloneable\",{\"1\":{\"44\":1,\"287\":2}}],[\"clone\",{\"1\":{\"193\":1,\"194\":1,\"198\":1,\"210\":2,\"347\":2,\"383\":1,\"407\":1,\"419\":1}}],[\"cloneresult\",{\"1\":{\"103\":1}}],[\"closure\",{\"1\":{\"99\":8,\"100\":5,\"102\":1,\"379\":2,\"389\":6}}],[\"closefile\",{\"1\":{\"382\":1}}],[\"closeport\",{\"1\":{\"115\":1}}],[\"closed\",{\"1\":{\"111\":4}}],[\"close\",{\"1\":{\"63\":1,\"108\":2,\"111\":1,\"115\":1,\"196\":1,\"209\":1,\"328\":1,\"365\":1,\"373\":1,\"378\":3,\"382\":1}}],[\"closing\",{\"1\":{\"13\":1}}],[\"cli\",{\"1\":{\"413\":1}}],[\"clinit\",{\"1\":{\"279\":4}}],[\"clip\",{\"1\":{\"239\":1}}],[\"clipbehavior\",{\"1\":{\"213\":2,\"228\":4,\"235\":2,\"236\":4,\"239\":3}}],[\"cliprectlayer\",{\"1\":{\"239\":3}}],[\"cliprectsize\",{\"1\":{\"172\":3,\"173\":3}}],[\"cliprect\",{\"1\":{\"172\":2,\"173\":7,\"206\":1}}],[\"clipoval与cliprect相交部分是cliprect形状\",{\"1\":{\"172\":1}}],[\"clipoval与cliprect相交部分是clipoval形状\",{\"1\":{\"172\":1}}],[\"clipoval\",{\"1\":{\"172\":2,\"173\":8}}],[\"clicklistener等\",{\"1\":{\"399\":1}}],[\"clicklistener\",{\"1\":{\"345\":3}}],[\"click\",{\"1\":{\"56\":1}}],[\"clickable会在设置点击事件时被设置为true\",{\"1\":{\"13\":1}}],[\"clickable默认为false\",{\"1\":{\"13\":1}}],[\"clickable\",{\"1\":{\"13\":3}}],[\"clients\",{\"1\":{\"115\":1}}],[\"clientmodule\",{\"1\":{\"85\":4,\"87\":2}}],[\"client和service通过clientcomponent联系在一起\",{\"1\":{\"84\":1}}],[\"clientcomponent\",{\"1\":{\"84\":1,\"85\":1,\"87\":1}}],[\"client类的代码只需要这样写成类似下面这样\",{\"1\":{\"82\":1}}],[\"client获取到内核binder的引用进行操作\",{\"1\":{\"58\":1}}],[\"client将需要的binder的名字发给servermanager\",{\"1\":{\"58\":1}}],[\"client通过0号引用binder和servermanager通信\",{\"1\":{\"58\":1}}],[\"client如何与servermanager通信并注册\",{\"1\":{\"58\":1}}],[\"client以及servermanager一般都在不同的进程之中\",{\"1\":{\"58\":1}}],[\"client\",{\"1\":{\"20\":2,\"40\":2,\"43\":2,\"58\":1,\"82\":3,\"83\":1,\"84\":2,\"85\":2,\"87\":2,\"110\":1}}],[\"chrome\",{\"1\":{\"370\":1}}],[\"chmod\",{\"0\":{\"351\":1},\"1\":{\"351\":2}}],[\"chenguolinhttp\",{\"1\":{\"347\":1}}],[\"chenguolin\",{\"1\":{\"347\":1}}],[\"checkdown\",{\"1\":{\"441\":1}}],[\"checkup\",{\"1\":{\"440\":1}}],[\"checkfunctionfingerprints\",{\"1\":{\"383\":1}}],[\"checked\",{\"1\":{\"378\":4,\"384\":3}}],[\"checkout\",{\"1\":{\"347\":1}}],[\"checkresolve\",{\"1\":{\"305\":1}}],[\"checkavailable\",{\"1\":{\"111\":1}}],[\"checknotnull\",{\"1\":{\"111\":2}}],[\"checkstatuschanged\",{\"1\":{\"162\":1,\"163\":1}}],[\"checks\",{\"1\":{\"103\":1}}],[\"checkselfpermission\",{\"1\":{\"69\":1}}],[\"checkcameradeviceandpremissions\",{\"1\":{\"69\":3}}],[\"check\",{\"1\":{\"13\":2,\"116\":1,\"198\":1,\"209\":1,\"221\":1,\"243\":1,\"328\":1,\"341\":2,\"378\":1,\"381\":1,\"383\":2,\"387\":1,\"389\":1,\"391\":1}}],[\"china\",{\"1\":{\"321\":2}}],[\"child内容超出viewport部分时\",{\"1\":{\"242\":1}}],[\"child将按照父级的最小高度设置\",{\"1\":{\"242\":1}}],[\"child的最大固有高度时\",{\"1\":{\"242\":1}}],[\"child的赋值过程\",{\"1\":{\"126\":1}}],[\"child保持自身大小\",{\"1\":{\"239\":1}}],[\"childtype\",{\"1\":{\"230\":3}}],[\"child是hero动画会作用的地方\",{\"1\":{\"170\":1}}],[\"child是一个statelesselement\",{\"1\":{\"126\":1}}],[\"child也没有被重新\",{\"1\":{\"130\":1}}],[\"child与\",{\"1\":{\"130\":1}}],[\"children\",{\"0\":{\"230\":1},\"1\":{\"126\":1,\"127\":7,\"130\":2,\"131\":3,\"147\":1,\"212\":2,\"229\":3,\"231\":1,\"232\":2,\"233\":1,\"234\":1,\"241\":1,\"242\":1}}],[\"childrencount\",{\"1\":{\"13\":1}}],[\"child并不是我们预期的text\",{\"1\":{\"124\":1}}],[\"childheight\",{\"1\":{\"64\":6}}],[\"child\",{\"0\":{\"126\":1,\"389\":1},\"1\":{\"13\":9,\"55\":8,\"64\":1,\"117\":2,\"119\":1,\"120\":1,\"121\":5,\"122\":11,\"124\":1,\"125\":4,\"126\":17,\"127\":4,\"128\":14,\"130\":15,\"131\":22,\"135\":1,\"140\":2,\"143\":4,\"152\":2,\"153\":4,\"155\":4,\"156\":8,\"158\":2,\"168\":1,\"170\":9,\"171\":9,\"172\":10,\"173\":2,\"174\":2,\"175\":1,\"176\":8,\"178\":2,\"180\":2,\"181\":10,\"193\":1,\"206\":4,\"212\":5,\"213\":7,\"227\":2,\"230\":13,\"234\":3,\"235\":5,\"238\":6,\"239\":4,\"240\":2,\"241\":7,\"242\":8,\"369\":5,\"381\":3,\"382\":2,\"383\":4,\"389\":5,\"417\":2}}],[\"chunkevents\",{\"1\":{\"196\":4,\"201\":9,\"209\":1}}],[\"chunks\",{\"1\":{\"111\":1}}],[\"choose\",{\"1\":{\"87\":1}}],[\"chooseid\",{\"1\":{\"64\":5}}],[\"chapter\",{\"1\":{\"279\":2}}],[\"charsets\",{\"1\":{\"272\":1}}],[\"chart\",{\"1\":{\"128\":2}}],[\"char\",{\"1\":{\"115\":5,\"283\":1,\"299\":1,\"380\":1,\"381\":4,\"382\":7,\"383\":4,\"384\":4,\"386\":3,\"387\":9,\"388\":4,\"389\":5,\"453\":4}}],[\"character\",{\"1\":{\"111\":3,\"283\":1}}],[\"chacknetwork\",{\"1\":{\"78\":1}}],[\"chang\",{\"1\":{\"308\":1}}],[\"changenotifier\",{\"1\":{\"154\":2}}],[\"changes\",{\"1\":{\"147\":1,\"156\":1,\"179\":1,\"226\":1,\"278\":1}}],[\"changestatebuttonstate\",{\"1\":{\"130\":4}}],[\"changestatebutton\",{\"1\":{\"130\":2}}],[\"change\",{\"1\":{\"130\":1,\"147\":1,\"216\":1,\"308\":2,\"345\":1}}],[\"changed\",{\"1\":{\"13\":2,\"45\":1,\"155\":1,\"201\":1,\"391\":1}}],[\"chance\",{\"1\":{\"102\":1,\"109\":1,\"209\":2,\"297\":1}}],[\"channel=flutterly\",{\"1\":{\"372\":2}}],[\"channel<int>\",{\"1\":{\"328\":1}}],[\"channels\",{\"1\":{\"328\":1}}],[\"channel提供了在协程之间传递多个值的方法\",{\"1\":{\"328\":1}}],[\"channel\",{\"1\":{\"54\":3,\"135\":2,\"141\":1,\"211\":4,\"328\":7,\"334\":1}}],[\"chainsource\",{\"1\":{\"103\":1}}],[\"chaining\",{\"1\":{\"103\":1}}],[\"chainedevaluation\",{\"1\":{\"183\":3}}],[\"chainedevaluation<t>\",{\"1\":{\"183\":2}}],[\"chained\",{\"1\":{\"103\":1}}],[\"chain\",{\"1\":{\"49\":1,\"183\":2}}],[\"capability\",{\"1\":{\"375\":2,\"377\":8,\"383\":2,\"389\":12}}],[\"capabilities\",{\"1\":{\"373\":2,\"378\":6,\"389\":5}}],[\"capacity规定的长度\",{\"1\":{\"280\":1}}],[\"capacity\",{\"1\":{\"280\":5,\"328\":1}}],[\"cat\",{\"1\":{\"349\":1}}],[\"catch来捕获\",{\"1\":{\"142\":1}}],[\"catch\",{\"0\":{\"142\":1},\"1\":{\"20\":1,\"35\":3,\"36\":2,\"43\":1,\"72\":2,\"80\":1,\"96\":1,\"101\":1,\"102\":2,\"111\":1,\"112\":1,\"121\":1,\"126\":2,\"142\":2,\"198\":1,\"201\":2,\"209\":1,\"272\":1,\"296\":1,\"300\":1,\"306\":3,\"308\":3,\"309\":5,\"327\":2,\"328\":2,\"329\":1,\"341\":5,\"363\":1,\"365\":1,\"378\":2,\"453\":4}}],[\"cares\",{\"1\":{\"294\":1}}],[\"care\",{\"1\":{\"225\":1}}],[\"card\",{\"1\":{\"143\":1}}],[\"caching\",{\"1\":{\"197\":1,\"395\":2,\"397\":1}}],[\"cache收集在调用点的receiver类型\",{\"1\":{\"396\":1}}],[\"cacheextent等属性的时候会触发layout外\",{\"1\":{\"237\":1}}],[\"cacheextent等三个属性的时候会触发markneedslayout\",{\"1\":{\"237\":1}}],[\"cacheextent\",{\"1\":{\"228\":2}}],[\"cacheflie\",{\"1\":{\"201\":6}}],[\"cachemaxage\",{\"1\":{\"201\":3}}],[\"cacherawdata\",{\"1\":{\"201\":1,\"202\":1}}],[\"cachekey\",{\"1\":{\"201\":2}}],[\"cache的最大个数和总大小限制都不会管理这部分图片\",{\"1\":{\"198\":1}}],[\"cache中\",{\"1\":{\"198\":1}}],[\"cache中已经有了\",{\"1\":{\"198\":1}}],[\"cacheimagefoldername\",{\"1\":{\"201\":1}}],[\"cacheimagesdirectory\",{\"1\":{\"201\":5}}],[\"cacheimages\",{\"1\":{\"198\":1}}],[\"cacheindex\",{\"1\":{\"65\":2}}],[\"cache保存\",{\"1\":{\"197\":1}}],[\"cacheheight\",{\"1\":{\"188\":2}}],[\"cachewidth\",{\"1\":{\"188\":2}}],[\"cachednetworkimage等都存在此问题\",{\"1\":{\"198\":1}}],[\"cachedimage\",{\"1\":{\"198\":4}}],[\"cachedimagebase\",{\"1\":{\"197\":1}}],[\"cachedimage和\",{\"1\":{\"197\":1}}],[\"cachedimage>\",{\"1\":{\"197\":1}}],[\"cached\",{\"1\":{\"187\":1,\"198\":1,\"199\":1,\"202\":2,\"203\":2,\"280\":1}}],[\"cache\",{\"1\":{\"111\":1,\"197\":2,\"198\":12,\"201\":3,\"202\":2,\"209\":4,\"249\":1,\"283\":1,\"395\":2}}],[\"cause\",{\"1\":{\"276\":2,\"328\":3,\"391\":1}}],[\"caused\",{\"1\":{\"36\":1}}],[\"caught\",{\"1\":{\"102\":1,\"143\":1,\"328\":2,\"341\":3}}],[\"came\",{\"1\":{\"102\":1}}],[\"cameraid\",{\"1\":{\"69\":2}}],[\"camera\",{\"1\":{\"2\":2,\"69\":9}}],[\"canonical\",{\"1\":{\"384\":3}}],[\"canonicalizeuri\",{\"1\":{\"384\":1}}],[\"canonicalize\",{\"1\":{\"384\":1}}],[\"canupdate\",{\"1\":{\"126\":1}}],[\"cannot\",{\"1\":{\"80\":2,\"111\":1,\"115\":3,\"136\":1,\"176\":1,\"220\":1,\"308\":2,\"309\":2,\"322\":1,\"386\":1,\"387\":2,\"389\":1}}],[\"can\",{\"1\":{\"75\":2,\"80\":1,\"100\":1,\"101\":1,\"109\":1,\"111\":1,\"112\":1,\"125\":1,\"131\":1,\"136\":2,\"147\":1,\"180\":1,\"183\":1,\"186\":1,\"198\":1,\"212\":1,\"220\":3,\"225\":1,\"234\":1,\"243\":2,\"275\":1,\"287\":1,\"308\":1,\"322\":3,\"327\":1,\"328\":1,\"364\":1,\"369\":1,\"372\":3,\"376\":1,\"389\":1,\"391\":2,\"396\":1,\"426\":3}}],[\"canvas\",{\"1\":{\"57\":5,\"63\":2,\"64\":11,\"65\":10,\"195\":1,\"211\":1}}],[\"cancellable\",{\"1\":{\"342\":1}}],[\"cancellationexception\",{\"1\":{\"329\":2}}],[\"cancellationtoken\",{\"1\":{\"201\":1}}],[\"cancelchildren\",{\"1\":{\"328\":2}}],[\"canceltoken\",{\"1\":{\"201\":1}}],[\"cancelwakeup\",{\"1\":{\"108\":2}}],[\"canceled\",{\"1\":{\"13\":2,\"109\":2,\"163\":1,\"164\":3,\"365\":1}}],[\"cancels\",{\"1\":{\"13\":1}}],[\"cancel\",{\"1\":{\"8\":1,\"12\":1,\"13\":1,\"101\":1,\"108\":1,\"109\":1,\"326\":1,\"327\":2,\"328\":2}}],[\"castisolate\",{\"1\":{\"383\":1}}],[\"cast<dart\",{\"1\":{\"383\":2}}],[\"cast<isolategroupdata\",{\"1\":{\"382\":1}}],[\"cast<isolate\",{\"1\":{\"381\":1,\"386\":1}}],[\"cast<int64\",{\"1\":{\"115\":1}}],[\"cast<intptr\",{\"1\":{\"108\":1}}],[\"cast<worker\",{\"1\":{\"115\":1,\"391\":1}}],[\"cast<threadstartdata\",{\"1\":{\"115\":1}}],[\"cast<uword>\",{\"1\":{\"115\":2,\"389\":2}}],[\"cast<objectptr>\",{\"1\":{\"115\":1}}],[\"cast\",{\"1\":{\"40\":1,\"58\":1,\"389\":1}}],[\"cases\",{\"1\":{\"154\":1,\"395\":1}}],[\"case\",{\"1\":{\"13\":3,\"36\":1,\"40\":2,\"49\":1,\"53\":6,\"56\":2,\"58\":2,\"65\":3,\"80\":4,\"115\":3,\"179\":2,\"181\":5,\"202\":1,\"211\":1,\"220\":1,\"226\":1,\"228\":4,\"238\":6,\"239\":4,\"305\":1}}],[\"calculated\",{\"1\":{\"302\":1}}],[\"calculatepaintoffset\",{\"1\":{\"213\":1}}],[\"call的enqueue\",{\"1\":{\"365\":1}}],[\"call的封装类requestcall\",{\"1\":{\"364\":1}}],[\"call对象\",{\"1\":{\"365\":1}}],[\"call类的进一步封装\",{\"1\":{\"365\":1}}],[\"callsites\",{\"1\":{\"396\":1}}],[\"calls\",{\"0\":{\"397\":1},\"1\":{\"198\":1,\"209\":1,\"327\":1,\"395\":1,\"397\":1}}],[\"calling\",{\"1\":{\"111\":1,\"112\":1,\"126\":1,\"136\":1,\"202\":1}}],[\"caller\",{\"1\":{\"115\":1}}],[\"callers\",{\"1\":{\"102\":1,\"391\":1}}],[\"called\",{\"1\":{\"97\":2,\"101\":1,\"103\":3,\"118\":1,\"147\":1,\"153\":1,\"156\":1,\"180\":1,\"198\":1,\"297\":1,\"392\":2}}],[\"callable\",{\"1\":{\"80\":6}}],[\"callable<v>\",{\"1\":{\"80\":2}}],[\"call\",{\"1\":{\"40\":1,\"58\":1,\"80\":3,\"96\":1,\"99\":2,\"100\":1,\"101\":2,\"102\":3,\"103\":1,\"105\":1,\"108\":2,\"115\":5,\"130\":1,\"136\":1,\"144\":1,\"177\":1,\"180\":2,\"211\":7,\"216\":1,\"362\":4,\"365\":9,\"378\":2,\"379\":1,\"383\":1,\"384\":1,\"387\":1,\"391\":1}}],[\"callback的基础上增加了before\",{\"1\":{\"364\":1}}],[\"callback是在okhttp3\",{\"1\":{\"364\":1}}],[\"callback增加更多功能\",{\"1\":{\"364\":1}}],[\"callbackdata\",{\"1\":{\"115\":1,\"389\":1,\"391\":1}}],[\"callbacks\",{\"1\":{\"101\":1,\"103\":1,\"108\":1,\"109\":1,\"111\":1,\"112\":1}}],[\"callbacklooper\",{\"1\":{\"80\":8}}],[\"callbacklist\",{\"1\":{\"36\":8}}],[\"callback>\",{\"1\":{\"36\":2}}],[\"callback\",{\"1\":{\"28\":1,\"29\":2,\"30\":2,\"31\":1,\"35\":7,\"36\":14,\"70\":1,\"72\":5,\"96\":5,\"97\":3,\"98\":4,\"99\":3,\"100\":4,\"101\":3,\"102\":2,\"103\":2,\"104\":10,\"105\":20,\"109\":7,\"115\":12,\"116\":1,\"128\":1,\"180\":1,\"181\":1,\"362\":4,\"364\":5,\"365\":21,\"381\":6,\"382\":2,\"383\":1,\"386\":6,\"387\":5,\"389\":11,\"391\":21}}],[\"calendar\",{\"1\":{\"5\":1,\"10\":7,\"302\":14}}],[\"cn官网hero示意图\",{\"1\":{\"174\":1}}],[\"cnblogs\",{\"1\":{\"41\":1,\"58\":3,\"59\":1,\"61\":1,\"111\":1,\"458\":1}}],[\"cn\",{\"1\":{\"2\":1,\"43\":2,\"58\":2,\"59\":2,\"87\":1,\"156\":1,\"168\":1,\"172\":1,\"286\":1,\"287\":2,\"291\":1,\"306\":1,\"309\":1,\"314\":1,\"417\":1}}],[\"covertinfixtopostfix\",{\"1\":{\"453\":1}}],[\"covariant\",{\"1\":{\"130\":1}}],[\"coding\",{\"1\":{\"369\":1}}],[\"code在被分配到内存后可以立即成为heap的一部分\",{\"1\":{\"396\":1}}],[\"code不需要deserizlization\",{\"1\":{\"396\":1}}],[\"code和普通的snapshot基本一致\",{\"1\":{\"396\":1}}],[\"code使得vm可以在那些jit受限的设备上运行\",{\"1\":{\"396\":1}}],[\"code主要分为2步\",{\"1\":{\"395\":1}}],[\"code运行\",{\"1\":{\"394\":1}}],[\"code并运行\",{\"1\":{\"394\":1}}],[\"code到dart\",{\"1\":{\"392\":1}}],[\"code为true的话\",{\"1\":{\"387\":1}}],[\"codec>\",{\"1\":{\"201\":2}}],[\"codec>和\",{\"1\":{\"196\":1}}],[\"codec\",{\"1\":{\"196\":4,\"201\":2}}],[\"code>\",{\"1\":{\"115\":1}}],[\"code\",{\"0\":{\"395\":1,\"396\":1},\"1\":{\"40\":3,\"49\":1,\"58\":3,\"95\":1,\"249\":1,\"273\":1,\"277\":1,\"278\":4,\"283\":1,\"287\":1,\"305\":1,\"327\":3,\"365\":2,\"372\":2,\"373\":2,\"378\":2,\"379\":2,\"382\":1,\"383\":13,\"384\":2,\"387\":8,\"389\":4,\"392\":2,\"395\":2,\"396\":10,\"423\":1}}],[\"codes\",{\"1\":{\"2\":2}}],[\"cobjectsendport\",{\"1\":{\"115\":1}}],[\"cobjectint32\",{\"1\":{\"115\":2}}],[\"cobjectarray\",{\"1\":{\"115\":3}}],[\"cobject\",{\"1\":{\"115\":7}}],[\"co\",{\"1\":{\"110\":1}}],[\"copyright\",{\"1\":{\"401\":1}}],[\"copyargument\",{\"1\":{\"383\":1}}],[\"copyarray\",{\"1\":{\"322\":2}}],[\"copyofrange\",{\"1\":{\"346\":4,\"451\":2,\"459\":2}}],[\"copywith\",{\"1\":{\"213\":1}}],[\"copy\",{\"1\":{\"103\":1,\"111\":1,\"115\":2,\"379\":1,\"384\":1,\"386\":1,\"387\":1}}],[\"copied\",{\"1\":{\"49\":1,\"287\":1}}],[\"coroutineexceptionhandler\",{\"1\":{\"329\":2}}],[\"coroutinecontext\",{\"1\":{\"328\":2,\"330\":1}}],[\"coroutine\",{\"1\":{\"327\":2,\"328\":3}}],[\"coroutinescope\",{\"0\":{\"323\":1},\"1\":{\"323\":1,\"326\":3,\"328\":3,\"330\":1,\"332\":2,\"334\":2}}],[\"coroutines\",{\"1\":{\"322\":2,\"325\":1,\"326\":1,\"327\":1,\"328\":2}}],[\"correct\",{\"1\":{\"276\":1}}],[\"corresponding\",{\"1\":{\"102\":1,\"192\":1}}],[\"core\",{\"1\":{\"2\":2,\"13\":1,\"43\":1,\"80\":1,\"322\":1,\"382\":1,\"387\":1,\"392\":1}}],[\"counters以及basic\",{\"1\":{\"396\":1}}],[\"counters\",{\"1\":{\"395\":1,\"396\":1}}],[\"counter++\",{\"1\":{\"334\":1}}],[\"counteractor\",{\"1\":{\"334\":1}}],[\"counter\",{\"1\":{\"334\":7,\"395\":1}}],[\"counterparts\",{\"1\":{\"295\":1}}],[\"country\",{\"1\":{\"321\":3}}],[\"count\",{\"0\":{\"255\":1},\"1\":{\"69\":7,\"115\":4,\"131\":3,\"321\":1,\"390\":4}}],[\"could\",{\"1\":{\"36\":1,\"115\":1,\"383\":1,\"389\":1,\"396\":2}}],[\"coordinator获取的\",{\"1\":{\"213\":1}}],[\"coordinator\",{\"0\":{\"216\":1},\"1\":{\"213\":11,\"215\":3,\"216\":2,\"217\":2,\"223\":1}}],[\"coordinatorlayout在最外层\",{\"1\":{\"55\":1}}],[\"coordinatorlayout>\",{\"1\":{\"55\":2}}],[\"coordinatorlayout类\",{\"1\":{\"55\":1}}],[\"coordinatorlayout\",{\"1\":{\"55\":12}}],[\"coordinate\",{\"1\":{\"15\":2}}],[\"cookie等既可\",{\"1\":{\"365\":1}}],[\"cookie\",{\"1\":{\"36\":2}}],[\"column的尺寸为children的尺寸之和\",{\"1\":{\"241\":1}}],[\"column\",{\"1\":{\"130\":2,\"131\":4,\"139\":1,\"234\":1,\"241\":1,\"242\":1}}],[\"columnindex\",{\"1\":{\"2\":3}}],[\"collect后的代码只有在collect执行完后才能执行\",{\"1\":{\"328\":1}}],[\"collected\",{\"1\":{\"327\":2,\"328\":1,\"341\":2}}],[\"collecting\",{\"1\":{\"327\":4}}],[\"collection\",{\"1\":{\"392\":2}}],[\"collections\",{\"1\":{\"291\":2}}],[\"collection<v>\",{\"1\":{\"287\":1}}],[\"collectlatest\",{\"1\":{\"327\":2,\"337\":1}}],[\"collectlatest可以保证每次都获取最新的值\",{\"1\":{\"327\":1}}],[\"collect会被取消\",{\"1\":{\"327\":1}}],[\"collector\",{\"1\":{\"327\":3}}],[\"collect则在调用协程运行\",{\"1\":{\"327\":1}}],[\"collect\",{\"1\":{\"327\":7,\"328\":3,\"337\":1,\"341\":3,\"343\":2,\"370\":1,\"371\":2}}],[\"collects\",{\"1\":{\"102\":1}}],[\"collapsemode\",{\"1\":{\"55\":1}}],[\"collapsemode=\",{\"1\":{\"55\":2}}],[\"collapsingtoolbarlayout的子view需要指定layout\",{\"1\":{\"55\":1}}],[\"collapsingtoolbarlayout必须设置layout\",{\"1\":{\"55\":1}}],[\"collapsingtoolbarlayout>\",{\"1\":{\"55\":1}}],[\"collapsingtoolbarlayout类\",{\"1\":{\"55\":1}}],[\"collapsingtoolbarlayout\",{\"1\":{\"55\":2}}],[\"colorblendmode\",{\"1\":{\"193\":2}}],[\"colortween\",{\"1\":{\"184\":3}}],[\"colors\",{\"1\":{\"130\":3,\"131\":6,\"132\":1,\"143\":2,\"172\":1}}],[\"colorfulcontainerstate\",{\"1\":{\"130\":1}}],[\"colorfulcontainer\",{\"1\":{\"130\":5}}],[\"color=auto\",{\"1\":{\"361\":1}}],[\"color=\",{\"1\":{\"66\":1}}],[\"colorprimarydark\",{\"1\":{\"56\":2}}],[\"color\",{\"1\":{\"15\":1,\"56\":3,\"63\":2,\"64\":1,\"66\":1,\"130\":43,\"131\":6,\"143\":2,\"172\":1,\"184\":5,\"193\":2,\"241\":4,\"242\":4}}],[\"conan\",{\"1\":{\"419\":1}}],[\"concern\",{\"1\":{\"306\":1}}],[\"concrete\",{\"1\":{\"278\":1}}],[\"concurrently\",{\"1\":{\"115\":2,\"327\":1}}],[\"converts\",{\"1\":{\"272\":1}}],[\"conflation\",{\"1\":{\"327\":1}}],[\"conflate\",{\"1\":{\"327\":1,\"344\":1}}],[\"confusion\",{\"1\":{\"130\":1}}],[\"config=\",{\"1\":{\"382\":1}}],[\"configured\",{\"1\":{\"226\":1}}],[\"configuration\",{\"1\":{\"81\":3,\"118\":1,\"196\":2,\"202\":1,\"221\":1,\"427\":1}}],[\"configtask\",{\"1\":{\"211\":1}}],[\"configrequestswitharguments\",{\"1\":{\"211\":2}}],[\"configwithtextureregistry\",{\"1\":{\"211\":1}}],[\"config\",{\"1\":{\"14\":4,\"347\":2,\"370\":3,\"378\":1,\"379\":1,\"384\":2,\"386\":1,\"387\":9,\"407\":2,\"415\":1,\"416\":2,\"417\":1}}],[\"consider\",{\"1\":{\"391\":1}}],[\"consists\",{\"1\":{\"279\":1}}],[\"consumeeach\",{\"1\":{\"328\":1}}],[\"consumer\",{\"1\":{\"110\":1}}],[\"consumed\",{\"1\":{\"55\":2,\"109\":1}}],[\"constant\",{\"1\":{\"278\":1,\"283\":1,\"322\":1,\"428\":3}}],[\"constrainedbox\",{\"1\":{\"241\":2,\"242\":1}}],[\"constrain\",{\"1\":{\"238\":1}}],[\"constraints\",{\"1\":{\"213\":10,\"238\":8,\"241\":1,\"242\":1,\"404\":1}}],[\"constructtweens\",{\"0\":{\"149\":1},\"1\":{\"148\":1,\"149\":3,\"150\":1}}],[\"constructors\",{\"1\":{\"125\":1,\"186\":1,\"295\":2}}],[\"constructor\",{\"1\":{\"80\":1,\"81\":1,\"83\":1,\"85\":2,\"125\":2,\"149\":2,\"150\":1,\"153\":1,\"186\":1,\"233\":1,\"279\":1,\"295\":1,\"298\":1,\"310\":1,\"314\":1}}],[\"construct\",{\"1\":{\"40\":1,\"58\":1}}],[\"const\",{\"1\":{\"95\":1,\"101\":4,\"111\":1,\"112\":1,\"115\":8,\"117\":1,\"122\":2,\"125\":4,\"126\":3,\"130\":3,\"131\":3,\"135\":2,\"143\":1,\"147\":1,\"153\":2,\"154\":1,\"155\":1,\"156\":1,\"170\":3,\"172\":3,\"175\":1,\"178\":1,\"180\":2,\"186\":5,\"196\":1,\"206\":1,\"207\":1,\"211\":2,\"213\":3,\"223\":2,\"233\":1,\"241\":4,\"242\":4,\"373\":1,\"376\":1,\"377\":1,\"380\":1,\"381\":3,\"382\":5,\"383\":14,\"384\":5,\"386\":2,\"387\":8,\"388\":5,\"389\":19,\"391\":4}}],[\"connecttimeout\",{\"1\":{\"362\":1}}],[\"connected\",{\"1\":{\"111\":2}}],[\"connectivity\",{\"1\":{\"78\":1}}],[\"connectivitymanager\",{\"1\":{\"78\":2}}],[\"conn\",{\"1\":{\"19\":3}}],[\"cont\",{\"1\":{\"370\":2,\"371\":5}}],[\"controlport\",{\"1\":{\"373\":3,\"376\":1,\"378\":7}}],[\"controlport``\",{\"1\":{\"373\":1}}],[\"controlpoint2y\",{\"1\":{\"62\":1,\"63\":1}}],[\"controlpoint2x\",{\"1\":{\"62\":1,\"63\":1}}],[\"controlpoint2\",{\"1\":{\"62\":1}}],[\"controlpoint1y\",{\"1\":{\"62\":1,\"63\":1}}],[\"controlpoint1x\",{\"1\":{\"62\":1,\"63\":1}}],[\"controlpoint1\",{\"1\":{\"62\":1}}],[\"control\",{\"1\":{\"347\":1,\"391\":1}}],[\"controller可以在activity等不再需要数据时\",{\"1\":{\"402\":1}}],[\"controller都来自\",{\"1\":{\"213\":1}}],[\"controller变化并触发\",{\"1\":{\"148\":1}}],[\"controller的状态\",{\"1\":{\"148\":1}}],[\"controller\",{\"1\":{\"147\":4,\"150\":2,\"152\":1,\"153\":1,\"156\":2,\"160\":1,\"178\":1,\"181\":1,\"196\":2,\"213\":6,\"220\":1,\"227\":2,\"235\":2}}],[\"continue\",{\"1\":{\"115\":1,\"211\":1,\"225\":2,\"391\":1}}],[\"continues\",{\"1\":{\"13\":2}}],[\"contained\",{\"1\":{\"387\":2}}],[\"containerrenderobjectmixin\",{\"1\":{\"230\":1}}],[\"containerrenderobjectmixin<childtype\",{\"1\":{\"230\":1}}],[\"containerrenderobjectmixin<renderobject\",{\"1\":{\"230\":1}}],[\"containerrenderobjectmixin<rendersliver\",{\"1\":{\"229\":2,\"230\":1}}],[\"containerrenderobjectmixin<renderbox\",{\"1\":{\"127\":1}}],[\"containerparentdatamixin<renderobject>>\",{\"1\":{\"230\":1}}],[\"containerparentdatamixin<rendersliver>>\",{\"1\":{\"229\":1}}],[\"containerparentdatamixin<childtype>>\",{\"1\":{\"230\":1}}],[\"container\",{\"1\":{\"119\":1,\"120\":3,\"130\":1,\"131\":7,\"143\":3,\"147\":3,\"156\":1,\"172\":1,\"193\":1,\"212\":1,\"241\":2,\"242\":2}}],[\"containerhelpers\",{\"1\":{\"45\":1,\"46\":1,\"47\":1,\"287\":1}}],[\"containscompressedpointers\",{\"1\":{\"116\":1}}],[\"containsfordebugging\",{\"1\":{\"115\":1}}],[\"contains\",{\"1\":{\"112\":1,\"278\":1,\"302\":1,\"346\":2}}],[\"containskey\",{\"1\":{\"111\":1,\"112\":2}}],[\"contain\",{\"1\":{\"85\":1,\"206\":1,\"322\":1,\"392\":2,\"396\":1}}],[\"contactslistview\",{\"1\":{\"64\":5}}],[\"contextclassloader\",{\"1\":{\"272\":5}}],[\"contextwrap\",{\"1\":{\"2\":1}}],[\"context\",{\"1\":{\"2\":5,\"7\":3,\"8\":1,\"10\":5,\"11\":5,\"12\":1,\"14\":1,\"17\":1,\"35\":10,\"41\":1,\"53\":1,\"54\":4,\"56\":6,\"58\":3,\"64\":11,\"66\":1,\"69\":1,\"72\":1,\"75\":4,\"78\":4,\"79\":18,\"81\":13,\"102\":1,\"120\":1,\"122\":4,\"126\":4,\"127\":4,\"128\":1,\"130\":9,\"131\":3,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"143\":2,\"152\":1,\"153\":3,\"154\":1,\"155\":3,\"156\":3,\"170\":3,\"172\":1,\"175\":2,\"176\":4,\"177\":3,\"178\":2,\"180\":1,\"181\":5,\"188\":1,\"190\":2,\"193\":5,\"205\":1,\"206\":2,\"207\":3,\"211\":3,\"212\":2,\"213\":7,\"215\":3,\"223\":1,\"227\":8,\"228\":6,\"233\":3,\"235\":5,\"236\":2,\"239\":5,\"241\":1,\"242\":1,\"372\":1,\"420\":1,\"423\":4,\"426\":1}}],[\"contents\",{\"1\":{\"235\":4,\"242\":1,\"314\":1}}],[\"contentequals\",{\"1\":{\"135\":1}}],[\"content时view对应的大小\",{\"1\":{\"65\":1}}],[\"content时候控件的大小\",{\"1\":{\"65\":1}}],[\"content的效果和match\",{\"1\":{\"65\":1}}],[\"content对应的specmode是at\",{\"1\":{\"65\":1}}],[\"contentprovider\",{\"1\":{\"58\":1}}],[\"contentprovider等等之外\",{\"1\":{\"40\":1}}],[\"contentview就是平时在activity的oncreate\",{\"1\":{\"13\":1}}],[\"content\",{\"1\":{\"1\":1,\"2\":3,\"35\":4,\"36\":1,\"56\":2,\"65\":1,\"66\":2,\"79\":2,\"81\":3,\"223\":1,\"241\":2,\"242\":2,\"371\":1}}],[\"come\",{\"1\":{\"391\":2}}],[\"com第一页内容并输出json\",{\"1\":{\"371\":1}}],[\"com的内容\",{\"1\":{\"371\":1}}],[\"com的图可以很形象的解释\",{\"1\":{\"57\":1}}],[\"com数据并输出json\",{\"0\":{\"371\":1}}],[\"com所有有效文章列表\",{\"1\":{\"370\":1}}],[\"com网站所有文章列表并输出json\",{\"1\":{\"370\":1}}],[\"command\",{\"1\":{\"378\":1}}],[\"communicate\",{\"1\":{\"372\":1}}],[\"commit\",{\"1\":{\"347\":1,\"407\":1}}],[\"commonly\",{\"1\":{\"154\":1}}],[\"common\",{\"1\":{\"54\":1,\"108\":1,\"392\":1}}],[\"combine\",{\"1\":{\"327\":3,\"344\":1}}],[\"combined\",{\"1\":{\"225\":1}}],[\"combining\",{\"1\":{\"275\":1}}],[\"combination\",{\"1\":{\"3\":1}}],[\"com关于porterduff\",{\"1\":{\"57\":1}}],[\"compiling\",{\"1\":{\"396\":1}}],[\"compilations\",{\"1\":{\"396\":1}}],[\"compilation\",{\"1\":{\"392\":1,\"395\":1,\"396\":1}}],[\"compiled\",{\"1\":{\"387\":1,\"396\":1}}],[\"compiledebugaidl\",{\"1\":{\"40\":1}}],[\"compiler和snapshot\",{\"1\":{\"396\":1}}],[\"compiler的出现\",{\"1\":{\"396\":1}}],[\"compiler开始的步骤类似\",{\"1\":{\"396\":1}}],[\"compiler可以执行任意dart代码\",{\"1\":{\"396\":1}}],[\"compiler\",{\"1\":{\"88\":1,\"392\":1,\"395\":1,\"396\":1}}],[\"compile\",{\"1\":{\"1\":1,\"14\":1,\"54\":2,\"281\":2,\"383\":1,\"394\":1}}],[\"computetimeout\",{\"1\":{\"391\":1}}],[\"computescrolloffset\",{\"1\":{\"41\":1}}],[\"computescroll\",{\"1\":{\"41\":1}}],[\"computation\",{\"1\":{\"96\":2,\"102\":5}}],[\"comparable<e>\",{\"1\":{\"285\":1}}],[\"companion\",{\"1\":{\"81\":1,\"314\":1,\"321\":3}}],[\"compatible\",{\"1\":{\"3\":1}}],[\"compoundanimation\",{\"1\":{\"159\":2}}],[\"composepx\",{\"1\":{\"81\":1}}],[\"compose\",{\"1\":{\"81\":3,\"327\":1}}],[\"composedp\",{\"1\":{\"81\":4}}],[\"compose屏幕适配\",{\"0\":{\"81\":1}}],[\"componentelement类中的方法\",{\"1\":{\"126\":1}}],[\"componentelement\",{\"1\":{\"126\":2}}],[\"component中\",{\"1\":{\"94\":1}}],[\"component并添加androidinjectionmodule\",{\"1\":{\"94\":1}}],[\"component和\",{\"1\":{\"94\":1}}],[\"component接口暴露的公共性的依赖\",{\"1\":{\"87\":1}}],[\"component只能访问在基类\",{\"1\":{\"87\":1}}],[\"component有以上相同的项\",{\"1\":{\"87\":1}}],[\"component可以分别拥有相同名称的\",{\"1\":{\"87\":1}}],[\"component可以有多个\",{\"1\":{\"86\":1}}],[\"component可以有多个module类\",{\"1\":{\"85\":1}}],[\"component应该和他所包含的\",{\"1\":{\"87\":1}}],[\"component产生了迷失\",{\"1\":{\"85\":1}}],[\"component在产生依赖的时候会先到\",{\"1\":{\"85\":1}}],[\"component关联到了一起\",{\"1\":{\"85\":1}}],[\"component类\",{\"1\":{\"85\":1}}],[\"component类只需要找到\",{\"1\":{\"85\":1}}],[\"component类传入使用该依赖的类的引用即可\",{\"1\":{\"84\":1}}],[\"component标记的类是将一个类和他的依赖联系在一起的桥梁\",{\"1\":{\"84\":1}}],[\"component\",{\"0\":{\"84\":1,\"89\":1},\"1\":{\"84\":2,\"85\":2,\"87\":1,\"89\":2,\"91\":1,\"94\":2,\"302\":1}}],[\"components\",{\"1\":{\"43\":1,\"59\":1,\"392\":2,\"396\":1}}],[\"componentname\",{\"1\":{\"17\":2,\"19\":2,\"20\":1,\"35\":4,\"43\":2,\"54\":1,\"58\":2}}],[\"completabledeferred\",{\"1\":{\"334\":1}}],[\"completabledeferred<int>\",{\"1\":{\"334\":1}}],[\"completionstatemask\",{\"1\":{\"103\":1}}],[\"complete返回给dart中的调用方\",{\"1\":{\"112\":1}}],[\"complete返回\",{\"1\":{\"111\":1,\"112\":1}}],[\"completewithvalue\",{\"1\":{\"102\":2}}],[\"completewitherrorcallback\",{\"1\":{\"96\":1,\"102\":1}}],[\"completes\",{\"1\":{\"102\":1,\"103\":2,\"147\":1,\"179\":1}}],[\"completeerror`\",{\"1\":{\"102\":1}}],[\"completeerror\",{\"1\":{\"102\":4,\"111\":1,\"378\":2}}],[\"completers找出并完成之前的请求\",{\"1\":{\"211\":1}}],[\"completers中并返回给调用者\",{\"1\":{\"211\":1}}],[\"completers\",{\"1\":{\"211\":3}}],[\"completer>\",{\"1\":{\"111\":2,\"112\":2}}],[\"completer<isolate>\",{\"1\":{\"378\":1}}],[\"completer<imageinfo>\",{\"1\":{\"211\":2}}],[\"completer<map>\",{\"1\":{\"211\":1}}],[\"completer<ui\",{\"1\":{\"210\":2}}],[\"completer<uint8list>\",{\"1\":{\"111\":1}}],[\"completer<t>\",{\"1\":{\"102\":1}}],[\"completer\",{\"1\":{\"102\":6,\"111\":9,\"112\":5,\"198\":5,\"202\":8,\"209\":3,\"210\":3,\"211\":13,\"378\":5}}],[\"complete\",{\"1\":{\"96\":1,\"102\":3,\"103\":1,\"111\":3,\"112\":2,\"210\":1,\"211\":2,\"334\":1,\"378\":1}}],[\"completed时回调implicitlyanimatedwidget\",{\"1\":{\"148\":1}}],[\"completed\",{\"1\":{\"9\":1,\"103\":1,\"158\":1,\"161\":1,\"163\":1,\"179\":1,\"181\":2,\"328\":1}}],[\"complex\",{\"1\":{\"53\":6,\"154\":1}}],[\"com\",{\"1\":{\"1\":2,\"2\":3,\"13\":1,\"14\":7,\"15\":2,\"35\":1,\"36\":1,\"41\":4,\"54\":2,\"55\":1,\"56\":2,\"58\":15,\"59\":2,\"60\":1,\"61\":2,\"63\":1,\"66\":3,\"79\":3,\"81\":1,\"88\":3,\"95\":1,\"111\":3,\"115\":1,\"136\":1,\"172\":1,\"180\":1,\"211\":2,\"274\":1,\"280\":1,\"281\":2,\"282\":5,\"286\":2,\"287\":1,\"291\":1,\"295\":1,\"302\":2,\"306\":1,\"308\":1,\"309\":1,\"345\":1,\"346\":1,\"347\":5,\"362\":3,\"364\":3,\"365\":2,\"370\":2,\"371\":2,\"372\":3,\"400\":4,\"401\":6,\"407\":2,\"417\":2,\"418\":1,\"421\":1,\"458\":1}}],[\"db\",{\"1\":{\"415\":1}}],[\"d展示当前目录本身信息\",{\"1\":{\"350\":1}}],[\"ddata\",{\"1\":{\"429\":1}}],[\"dd\",{\"1\":{\"302\":5}}],[\"dlmalloc\",{\"1\":{\"282\":1}}],[\"dummy创建powertextureimageinfo\",{\"1\":{\"210\":1}}],[\"dummy\",{\"1\":{\"206\":1,\"210\":5}}],[\"dumperrortoconsole\",{\"1\":{\"144\":1}}],[\"during\",{\"1\":{\"126\":1,\"181\":1,\"216\":1,\"221\":1,\"389\":1,\"391\":3,\"396\":3}}],[\"durationinseconds\",{\"1\":{\"166\":1}}],[\"duration=\",{\"1\":{\"66\":2}}],[\"duration\",{\"1\":{\"11\":1,\"63\":1,\"95\":1,\"101\":5,\"102\":3,\"104\":9,\"105\":21,\"147\":9,\"150\":3,\"153\":2,\"154\":1,\"156\":1,\"157\":1,\"161\":8,\"162\":1,\"163\":2,\"166\":2,\"167\":1,\"179\":1,\"201\":3,\"216\":1,\"373\":2,\"381\":1,\"387\":1,\"388\":1}}],[\"d437877c500c77d6e08372ba2dbda9c598f5bd8e\",{\"1\":{\"115\":1}}],[\"drafts\",{\"1\":{\"415\":1}}],[\"drain\",{\"1\":{\"376\":1,\"391\":1}}],[\"dragdetails\",{\"1\":{\"227\":1,\"235\":1}}],[\"dragging\",{\"1\":{\"226\":2}}],[\"dragscrollactivity\",{\"1\":{\"226\":2}}],[\"dragstartdetails\",{\"1\":{\"226\":1}}],[\"dragstartbehavior\",{\"1\":{\"213\":2,\"227\":2,\"235\":2}}],[\"dragcancelcallback\",{\"1\":{\"226\":2}}],[\"drag链路调用\",{\"1\":{\"226\":1}}],[\"drag方法创建了scrolldragcontroller\",{\"1\":{\"226\":1}}],[\"drag\",{\"1\":{\"212\":1,\"223\":1,\"225\":1,\"226\":14}}],[\"drawimagenine绘制图片\",{\"1\":{\"193\":1}}],[\"drawimagerect方法第一个参数\",{\"1\":{\"194\":1}}],[\"drawimagerect或者canvas\",{\"1\":{\"193\":1}}],[\"drawimagerect绘制图片内容\",{\"1\":{\"198\":1}}],[\"drawimagerect绘制图片\",{\"1\":{\"189\":1}}],[\"drawroundrect\",{\"1\":{\"65\":1}}],[\"drawrect\",{\"1\":{\"64\":1,\"65\":1}}],[\"drawcircle\",{\"1\":{\"64\":1}}],[\"drawpath\",{\"1\":{\"63\":2}}],[\"drawxxx\",{\"1\":{\"57\":1}}],[\"drawbitmap\",{\"1\":{\"57\":2}}],[\"drawableclazz\",{\"1\":{\"427\":2}}],[\"drawable=\",{\"1\":{\"66\":2}}],[\"drawable\",{\"1\":{\"54\":2,\"66\":4,\"211\":4,\"427\":1}}],[\"drawtext\",{\"1\":{\"15\":2,\"64\":3}}],[\"drawn\",{\"1\":{\"15\":3}}],[\"draw\",{\"1\":{\"15\":1,\"65\":4}}],[\"driving\",{\"1\":{\"181\":1}}],[\"drive方法中获取一个新的\",{\"1\":{\"185\":1}}],[\"drive<u>\",{\"1\":{\"158\":1,\"168\":1}}],[\"drive\",{\"1\":{\"158\":1}}],[\"driver是以不定长度的字元传送资料\",{\"1\":{\"111\":1}}],[\"driver是以固定大小长度来传送转移资料\",{\"1\":{\"111\":1}}],[\"driver通常成为块设备\",{\"1\":{\"111\":1}}],[\"driver又被称为字符设备或裸设备raw\",{\"1\":{\"111\":1}}],[\"driver和character\",{\"1\":{\"111\":1}}],[\"drive两类\",{\"1\":{\"111\":1}}],[\"dropped\",{\"1\":{\"221\":1}}],[\"drop\",{\"1\":{\"103\":1}}],[\"dfsstacks\",{\"1\":{\"437\":1}}],[\"dfs的思想是\",{\"1\":{\"437\":1}}],[\"dfs\",{\"0\":{\"437\":1},\"1\":{\"437\":1}}],[\"dfe\",{\"1\":{\"387\":1}}],[\"df\",{\"1\":{\"61\":1}}],[\"dstr\",{\"1\":{\"296\":1}}],[\"dstpath\",{\"1\":{\"63\":2}}],[\"dstpaint\",{\"1\":{\"57\":1}}],[\"dst\",{\"1\":{\"57\":8}}],[\"dynamicloadapk\",{\"1\":{\"421\":1}}],[\"dynamic>>\",{\"1\":{\"378\":1}}],[\"dynamic>\",{\"1\":{\"198\":1,\"211\":4}}],[\"dynamic\",{\"1\":{\"103\":2,\"149\":2,\"150\":1,\"152\":1,\"153\":1,\"184\":3,\"211\":1,\"278\":2,\"396\":1,\"421\":1}}],[\"dy\",{\"1\":{\"55\":2}}],[\"dx\",{\"1\":{\"55\":2,\"165\":1}}],[\"dpheightscale\",{\"1\":{\"81\":3}}],[\"dpwidthscale\",{\"1\":{\"81\":5}}],[\"dpx\",{\"1\":{\"81\":16}}],[\"dpi表示\",{\"1\":{\"53\":1}}],[\"dpi\",{\"1\":{\"53\":3,\"81\":2}}],[\"dp在屏幕上实际对应的像素px计算方式如下\",{\"1\":{\"53\":1}}],[\"dp\",{\"1\":{\"53\":10,\"81\":7}}],[\"dichotomy\",{\"1\":{\"451\":3}}],[\"dill\",{\"1\":{\"392\":2}}],[\"div\",{\"1\":{\"322\":2,\"371\":10}}],[\"divert\",{\"1\":{\"180\":2}}],[\"diverted\",{\"1\":{\"177\":1}}],[\"diagnosticsproperty<image\",{\"1\":{\"196\":2}}],[\"dialog圆角背景\",{\"1\":{\"66\":1}}],[\"dialog\",{\"1\":{\"66\":4}}],[\"different\",{\"1\":{\"179\":1,\"302\":1,\"372\":1,\"392\":1}}],[\"differs\",{\"1\":{\"108\":1}}],[\"didoverscrollby\",{\"1\":{\"221\":1}}],[\"didstopusergesture\",{\"1\":{\"178\":1,\"179\":1}}],[\"didstartusergesture\",{\"1\":{\"178\":1}}],[\"didreplace\",{\"1\":{\"178\":1}}],[\"didremove\",{\"1\":{\"178\":1}}],[\"didpop\",{\"1\":{\"178\":1}}],[\"didpush\",{\"1\":{\"178\":1}}],[\"didupdatescrollpositionby\",{\"1\":{\"220\":1,\"221\":1}}],[\"didupdatetweens\",{\"0\":{\"152\":1},\"1\":{\"150\":1}}],[\"didupdatewidget\",{\"0\":{\"150\":1},\"1\":{\"150\":3,\"155\":2,\"190\":1,\"213\":1}}],[\"didchangeapplifecyclestate\",{\"1\":{\"138\":1}}],[\"didchangedependencies\",{\"1\":{\"128\":1,\"188\":1,\"190\":1,\"213\":1}}],[\"didn\",{\"1\":{\"109\":1}}],[\"died\",{\"1\":{\"389\":1,\"391\":2}}],[\"die\",{\"1\":{\"108\":1}}],[\"dip\",{\"1\":{\"53\":1}}],[\"dimensions的压力\",{\"1\":{\"242\":1}}],[\"dimensions\",{\"1\":{\"242\":1}}],[\"dimensions问题\",{\"1\":{\"54\":1}}],[\"dimension\",{\"1\":{\"56\":1,\"65\":1}}],[\"dimen\",{\"1\":{\"53\":1}}],[\"diydialog\",{\"1\":{\"66\":1}}],[\"diydialogstyle\",{\"1\":{\"66\":1}}],[\"diycode\",{\"1\":{\"58\":1}}],[\"diy\",{\"1\":{\"41\":1}}],[\"diywidget\",{\"1\":{\"41\":1}}],[\"dirpath\",{\"1\":{\"358\":1}}],[\"dirname\",{\"1\":{\"349\":1}}],[\"dirtyelements\",{\"1\":{\"128\":1}}],[\"dirty\",{\"1\":{\"117\":1,\"121\":1,\"122\":2,\"126\":2,\"127\":1}}],[\"direct\",{\"1\":{\"275\":2}}],[\"directly\",{\"1\":{\"194\":1,\"396\":1}}],[\"direction是down的话\",{\"1\":{\"239\":1}}],[\"direction相反的方法offset的pixels\",{\"1\":{\"239\":1}}],[\"directionsetter\",{\"1\":{\"167\":3}}],[\"direction\",{\"1\":{\"162\":1,\"163\":1,\"220\":2,\"228\":2,\"236\":1,\"400\":2}}],[\"directionality\",{\"1\":{\"122\":2,\"126\":1,\"127\":1,\"228\":1}}],[\"directory\",{\"1\":{\"115\":9,\"201\":2,\"426\":3}}],[\"directtargetchild\",{\"1\":{\"55\":1}}],[\"dir\",{\"1\":{\"40\":1,\"272\":1,\"367\":4,\"370\":1,\"378\":1}}],[\"disable\",{\"1\":{\"391\":1}}],[\"disableidletimerscope\",{\"1\":{\"391\":1}}],[\"disabled\",{\"1\":{\"198\":2}}],[\"disallow\",{\"1\":{\"13\":3,\"115\":1,\"220\":1}}],[\"disallowintercept\",{\"1\":{\"13\":4}}],[\"dismissed\",{\"1\":{\"158\":1,\"161\":1,\"163\":1}}],[\"disk\",{\"1\":{\"136\":1}}],[\"distinguish\",{\"1\":{\"106\":1,\"107\":1}}],[\"discard\",{\"1\":{\"101\":1}}],[\"dissolve\",{\"1\":{\"58\":1}}],[\"disposed\",{\"1\":{\"193\":1}}],[\"dispose\",{\"1\":{\"150\":1,\"155\":2,\"164\":1,\"192\":1,\"194\":1,\"198\":2,\"210\":2,\"225\":1}}],[\"displaylist\",{\"1\":{\"438\":3}}],[\"displays\",{\"1\":{\"188\":1,\"194\":1}}],[\"display\",{\"1\":{\"81\":3}}],[\"displaymetrics\",{\"1\":{\"53\":7,\"81\":10,\"427\":1}}],[\"dispatchers\",{\"1\":{\"322\":2,\"324\":2,\"325\":1,\"326\":1,\"327\":1,\"334\":1,\"339\":1}}],[\"dispatched\",{\"1\":{\"115\":1}}],[\"dispatch方法的\",{\"1\":{\"115\":1}}],[\"dispatch方法中获取的id\",{\"1\":{\"111\":1,\"112\":1}}],[\"dispatch方法在不同的机器上面实现不同\",{\"1\":{\"111\":1}}],[\"dispatch发送指令\",{\"1\":{\"111\":1}}],[\"dispatchwithnamespace\",{\"1\":{\"111\":2}}],[\"dispatchingandroidinjector\",{\"1\":{\"94\":1}}],[\"dispatchingandroidinjector<activity>\",{\"1\":{\"92\":1,\"94\":1}}],[\"dispatchactivityinjector\",{\"1\":{\"92\":2}}],[\"dispatchdraw\",{\"1\":{\"65\":1}}],[\"dispatchmessage\",{\"0\":{\"29\":1},\"1\":{\"25\":2,\"29\":1,\"31\":1}}],[\"dispatchtransformedtouchevent\",{\"1\":{\"13\":5}}],[\"dispatchtouchevent\",{\"1\":{\"13\":13}}],[\"dispatch\",{\"1\":{\"13\":1,\"111\":8,\"112\":2,\"115\":3}}],[\"dispatchkeyevent\",{\"1\":{\"13\":2}}],[\"dog>\",{\"1\":{\"322\":1}}],[\"dofinal\",{\"1\":{\"296\":2}}],[\"dosth\",{\"1\":{\"281\":5,\"294\":1}}],[\"dosomething\",{\"1\":{\"19\":2}}],[\"does\",{\"1\":{\"130\":1,\"277\":1,\"306\":1,\"347\":1,\"391\":1,\"396\":1}}],[\"doesn\",{\"1\":{\"102\":1,\"287\":1,\"387\":1,\"391\":1}}],[\"doc\",{\"1\":{\"369\":2}}],[\"documentation\",{\"1\":{\"243\":1}}],[\"documented\",{\"1\":{\"86\":1,\"87\":1,\"298\":1}}],[\"docstring\",{\"1\":{\"370\":1}}],[\"docs\",{\"1\":{\"127\":1,\"274\":1,\"281\":1,\"295\":2,\"302\":4}}],[\"double=num\",{\"1\":{\"184\":1}}],[\"double\",{\"1\":{\"122\":2,\"131\":1,\"153\":1,\"157\":1,\"159\":2,\"161\":16,\"163\":1,\"165\":5,\"166\":4,\"167\":7,\"182\":1,\"183\":3,\"184\":5,\"185\":2,\"186\":14,\"188\":1,\"201\":1,\"212\":1,\"213\":2,\"220\":18,\"221\":6,\"223\":1,\"225\":3,\"226\":9,\"238\":3,\"239\":1,\"299\":1,\"429\":1}}],[\"dont\",{\"1\":{\"387\":1}}],[\"dontneed\",{\"1\":{\"387\":5}}],[\"don\",{\"1\":{\"102\":5,\"108\":1,\"112\":1,\"136\":1,\"170\":1,\"180\":2,\"198\":3,\"327\":1,\"384\":1,\"391\":2}}],[\"done\",{\"1\":{\"80\":1,\"165\":1,\"198\":1,\"327\":2,\"328\":2,\"343\":2,\"391\":4}}],[\"dowhile\",{\"1\":{\"95\":2}}],[\"downto\",{\"1\":{\"457\":1,\"462\":1,\"467\":1}}],[\"download2\",{\"1\":{\"370\":1}}],[\"download\",{\"1\":{\"370\":1,\"371\":3}}],[\"downloader\",{\"1\":{\"370\":3,\"371\":5}}],[\"down都会被重置\",{\"1\":{\"13\":1}}],[\"down事件\",{\"1\":{\"13\":1}}],[\"down事件都需要调用onintercepttouchevent\",{\"1\":{\"13\":1}}],[\"down\",{\"1\":{\"13\":6,\"64\":1,\"105\":1,\"108\":1,\"115\":1,\"220\":1,\"226\":1,\"228\":1,\"231\":1,\"239\":1,\"389\":1,\"391\":3}}],[\"doinbackground\",{\"1\":{\"80\":2}}],[\"doing\",{\"1\":{\"59\":1,\"136\":1,\"198\":1,\"396\":1}}],[\"dorequestcamerapermission\",{\"1\":{\"69\":3}}],[\"do\",{\"1\":{\"20\":2,\"40\":1,\"56\":1,\"78\":1,\"106\":1,\"111\":1,\"112\":1,\"115\":1,\"136\":1,\"193\":1,\"216\":2,\"225\":1,\"378\":1,\"383\":2,\"391\":1}}],[\"d\",{\"1\":{\"17\":5,\"36\":2,\"37\":2,\"69\":1,\"78\":3,\"93\":1,\"115\":3,\"225\":1,\"302\":2,\"321\":1,\"322\":3,\"346\":1,\"347\":1,\"356\":1,\"361\":2,\"370\":4,\"389\":1}}],[\"deoptimization\",{\"1\":{\"396\":3}}],[\"deepin\",{\"1\":{\"366\":1}}],[\"deeporange\",{\"1\":{\"132\":1}}],[\"death\",{\"1\":{\"391\":1}}],[\"deathrecipient\",{\"1\":{\"36\":1}}],[\"deadlocks\",{\"1\":{\"391\":1}}],[\"dead\",{\"1\":{\"391\":7}}],[\"deal\",{\"1\":{\"216\":1,\"226\":1}}],[\"denth\",{\"1\":{\"125\":1}}],[\"densitydpi\",{\"1\":{\"81\":3}}],[\"density=2\",{\"1\":{\"53\":2}}],[\"density\",{\"1\":{\"53\":11,\"81\":18}}],[\"deprecation\",{\"1\":{\"298\":1}}],[\"deprecated\",{\"1\":{\"298\":1,\"378\":1}}],[\"deployment\",{\"1\":{\"248\":1}}],[\"deploy\",{\"0\":{\"248\":1},\"1\":{\"248\":1,\"418\":4}}],[\"depending\",{\"1\":{\"209\":1}}],[\"dependoninheritedwidgetofexacttype<appcolor>\",{\"1\":{\"130\":2}}],[\"dependoninheritedwidgetofexacttype<t\",{\"1\":{\"129\":1}}],[\"dependents只有1个\",{\"1\":{\"130\":1}}],[\"dependents也只有1个\",{\"1\":{\"130\":1}}],[\"dependents会加入colorfulcontainer\",{\"1\":{\"130\":1}}],[\"dependents\",{\"1\":{\"128\":1}}],[\"dependency\",{\"1\":{\"55\":5,\"87\":1,\"236\":1}}],[\"dependencies\",{\"1\":{\"14\":1,\"54\":1,\"87\":3,\"117\":1,\"122\":2,\"126\":1,\"130\":3}}],[\"depth是2\",{\"1\":{\"122\":1}}],[\"depth\",{\"1\":{\"117\":1,\"121\":2,\"122\":2,\"126\":1,\"305\":1,\"309\":2}}],[\"determine\",{\"1\":{\"228\":2}}],[\"detecting\",{\"1\":{\"105\":1}}],[\"detail\",{\"1\":{\"400\":2}}],[\"details\",{\"1\":{\"15\":3,\"35\":1,\"40\":1,\"41\":1,\"54\":2,\"58\":6,\"59\":1,\"63\":1,\"115\":1,\"117\":1,\"122\":1,\"125\":1,\"126\":1,\"144\":4,\"226\":3,\"233\":1,\"273\":1,\"279\":1,\"283\":1,\"287\":1,\"288\":1,\"294\":1}}],[\"detach方法中也有对应操作\",{\"1\":{\"237\":1}}],[\"detach\",{\"1\":{\"216\":2,\"217\":1,\"237\":2}}],[\"dequeuemessage则是按照优先级\",{\"1\":{\"391\":1}}],[\"dequeuemessage\",{\"1\":{\"391\":3}}],[\"deque\",{\"1\":{\"80\":1}}],[\"de\",{\"1\":{\"61\":1,\"321\":1}}],[\"delat\",{\"1\":{\"220\":2}}],[\"delay\",{\"1\":{\"101\":2,\"126\":1,\"297\":3,\"327\":8,\"334\":1,\"336\":1}}],[\"delayed\",{\"1\":{\"95\":1,\"101\":3,\"102\":2,\"373\":2,\"389\":2}}],[\"delaymillis\",{\"1\":{\"30\":2,\"328\":2}}],[\"delta为正值时\",{\"1\":{\"220\":1}}],[\"delta为正\",{\"1\":{\"220\":1}}],[\"delta为负时\",{\"1\":{\"220\":1}}],[\"delta为负\",{\"1\":{\"220\":1}}],[\"delta\",{\"1\":{\"220\":17,\"221\":4,\"222\":1,\"226\":17}}],[\"deletion\",{\"1\":{\"115\":1}}],[\"deleteisolategroupdata\",{\"1\":{\"382\":1}}],[\"deleteisolatedata\",{\"1\":{\"382\":1}}],[\"deletesync\",{\"1\":{\"201\":1}}],[\"deletelink\",{\"1\":{\"115\":1}}],[\"delete\",{\"1\":{\"47\":2,\"115\":5,\"383\":2,\"387\":2,\"389\":1,\"391\":7,\"432\":1}}],[\"deleted\",{\"1\":{\"45\":1,\"46\":1,\"47\":2,\"48\":1,\"115\":1,\"287\":1,\"391\":2}}],[\"delegates\",{\"1\":{\"322\":1}}],[\"delegate<t>\",{\"1\":{\"322\":1}}],[\"delegate\",{\"1\":{\"103\":1,\"108\":1,\"219\":1,\"226\":2,\"322\":6}}],[\"deliberately\",{\"1\":{\"102\":1}}],[\"debugging\",{\"1\":{\"392\":1}}],[\"debugger\",{\"1\":{\"383\":1}}],[\"debugname\",{\"1\":{\"373\":6,\"378\":8,\"384\":2}}],[\"debugvalidatechild方法校验child类型\",{\"1\":{\"230\":1}}],[\"debugvalidatechild\",{\"1\":{\"230\":4}}],[\"debugimagelabel\",{\"1\":{\"193\":1}}],[\"debugbuilderrorwidget\",{\"1\":{\"193\":1}}],[\"debugbuiltonce\",{\"1\":{\"117\":1,\"122\":2,\"126\":1}}],[\"debuglabel\",{\"1\":{\"147\":1,\"192\":1,\"193\":1,\"196\":1,\"215\":2}}],[\"debug模式下如onpressed中的未捕获错误等都会被widget等捕获\",{\"1\":{\"144\":1}}],[\"debug模式下\",{\"1\":{\"143\":2}}],[\"debug模式下errorwidget\",{\"1\":{\"143\":1}}],[\"debug模式返回的是红底黄字的错误提示\",{\"1\":{\"143\":1}}],[\"debugprint\",{\"1\":{\"143\":1}}],[\"debug下为红底黄字错误信息\",{\"1\":{\"143\":1}}],[\"debugcheckhasdirectionality\",{\"1\":{\"127\":1,\"228\":1}}],[\"debugsetallowignoredcallstomarkneedsbuild\",{\"1\":{\"126\":1}}],[\"debugshortdescription\",{\"1\":{\"119\":1,\"120\":1}}],[\"debugallowignoredcallstomarkneedsbuild\",{\"1\":{\"126\":1}}],[\"debuga1lowignoredcallstomarkneedsbuild\",{\"1\":{\"117\":1,\"122\":2}}],[\"debugdoingbuild\",{\"1\":{\"117\":1,\"122\":2,\"126\":1}}],[\"debugforgottenchildrenwithglobalkey\",{\"1\":{\"117\":1,\"122\":2,\"126\":1}}],[\"debugreassembleconfig\",{\"1\":{\"117\":1,\"122\":2,\"125\":1,\"126\":1}}],[\"debug\",{\"1\":{\"40\":1,\"115\":2,\"228\":1,\"379\":1,\"383\":4,\"384\":2,\"387\":1,\"416\":1}}],[\"demo的github链接\",{\"1\":{\"56\":1}}],[\"demo2\",{\"1\":{\"37\":1}}],[\"demo\",{\"1\":{\"35\":2,\"36\":1}}],[\"decide\",{\"1\":{\"391\":1}}],[\"decrypt\",{\"1\":{\"296\":2}}],[\"decodeimagefrompixels分析\",{\"1\":{\"211\":1}}],[\"decodeimagefrompixels方法从\",{\"1\":{\"211\":1}}],[\"decodeimagefrompixels\",{\"1\":{\"210\":1,\"211\":1}}],[\"decodeimagefromlist\",{\"1\":{\"196\":1}}],[\"decodercallback\",{\"1\":{\"196\":2,\"201\":2,\"209\":1,\"211\":1}}],[\"decoded\",{\"1\":{\"194\":1}}],[\"decode\",{\"1\":{\"136\":1,\"196\":3,\"201\":5,\"209\":1,\"211\":1}}],[\"decoratedbox\",{\"1\":{\"154\":1}}],[\"decoratedboxtransition\",{\"1\":{\"154\":1}}],[\"decoration\",{\"1\":{\"64\":1,\"195\":1}}],[\"decor\",{\"1\":{\"77\":3}}],[\"decorview则是窗口的尺寸\",{\"1\":{\"65\":1}}],[\"decorview到达viewgroup\",{\"1\":{\"13\":1}}],[\"decorview\",{\"1\":{\"13\":1}}],[\"decorview是一个framelayout\",{\"1\":{\"13\":1}}],[\"decorview为顶层view\",{\"1\":{\"13\":1}}],[\"declared\",{\"1\":{\"281\":3}}],[\"declare\",{\"1\":{\"34\":1,\"56\":1,\"58\":1}}],[\"deserialized\",{\"1\":{\"394\":1}}],[\"deserialize\",{\"1\":{\"389\":3}}],[\"deserializes\",{\"1\":{\"308\":1}}],[\"designator\",{\"1\":{\"302\":1}}],[\"design\",{\"1\":{\"55\":10}}],[\"desiredpointeridbits\",{\"1\":{\"13\":1}}],[\"destructive\",{\"1\":{\"387\":1}}],[\"destructors\",{\"1\":{\"115\":2}}],[\"destroyed\",{\"1\":{\"115\":1}}],[\"destroy\",{\"1\":{\"115\":1,\"297\":1,\"326\":1}}],[\"dest\",{\"1\":{\"115\":1,\"391\":2}}],[\"destination=\",{\"1\":{\"400\":1}}],[\"destination\",{\"1\":{\"114\":1,\"171\":1,\"400\":1}}],[\"desty的值如果是正的话\",{\"1\":{\"41\":1}}],[\"desty\",{\"1\":{\"41\":2}}],[\"destx\",{\"1\":{\"41\":3}}],[\"desc\",{\"1\":{\"305\":2,\"312\":6}}],[\"descendant\",{\"1\":{\"176\":1}}],[\"descenter\",{\"1\":{\"15\":1}}],[\"descent的值就是baseline到center的距离\",{\"1\":{\"15\":1}}],[\"descent\",{\"1\":{\"15\":7}}],[\"describecontents\",{\"1\":{\"314\":1}}],[\"described\",{\"1\":{\"75\":1}}],[\"description\",{\"1\":{\"75\":1,\"81\":1,\"308\":1,\"417\":1}}],[\"descriptor\",{\"1\":{\"40\":9,\"58\":11,\"314\":2}}],[\"dexclassloader\",{\"1\":{\"426\":2,\"427\":1}}],[\"dex\",{\"1\":{\"14\":1,\"426\":1}}],[\"definite\",{\"1\":{\"281\":1}}],[\"definitely\",{\"1\":{\"281\":1}}],[\"definition\",{\"1\":{\"32\":1}}],[\"defining\",{\"1\":{\"272\":1}}],[\"defineclass\",{\"1\":{\"272\":1}}],[\"defined\",{\"1\":{\"115\":2,\"383\":18,\"387\":11,\"391\":4}}],[\"define\",{\"1\":{\"115\":2,\"376\":1,\"377\":2,\"379\":1,\"383\":1,\"384\":1}}],[\"defstyle\",{\"1\":{\"64\":2}}],[\"defstyleattr\",{\"1\":{\"56\":2}}],[\"defaultnavhost=\",{\"1\":{\"400\":1}}],[\"defaultreadobject一起使用\",{\"1\":{\"306\":1}}],[\"defaultreadobject\",{\"1\":{\"306\":1}}],[\"defaultwriteobject\",{\"1\":{\"280\":1,\"306\":1}}],[\"defaultglobalrendertype\",{\"1\":{\"211\":1}}],[\"defaultheroflightshuttlebuilder\",{\"1\":{\"180\":2}}],[\"defaulttag\",{\"1\":{\"383\":1}}],[\"defaulttabcontroller\",{\"1\":{\"212\":1}}],[\"defaulttolerance\",{\"1\":{\"165\":1}}],[\"defaulttextstyletransition\",{\"1\":{\"154\":1}}],[\"defaulttextstyle\",{\"1\":{\"126\":5,\"147\":1,\"154\":1}}],[\"defaultonerror\",{\"1\":{\"144\":2}}],[\"defaultdisplay\",{\"1\":{\"81\":1}}],[\"default\",{\"1\":{\"34\":1,\"40\":1,\"58\":2,\"85\":2,\"86\":1,\"115\":1,\"126\":1,\"277\":1,\"280\":1,\"283\":1,\"291\":1,\"299\":1,\"305\":1,\"325\":1,\"326\":1,\"327\":1,\"334\":1,\"339\":1,\"365\":1,\"383\":3,\"384\":1,\"387\":1}}],[\"defaultconfig\",{\"1\":{\"14\":1}}],[\"def\",{\"1\":{\"11\":2,\"369\":15,\"370\":4,\"371\":7}}],[\"devidearraybyn1\",{\"1\":{\"467\":2}}],[\"devicu\",{\"1\":{\"413\":1}}],[\"device\",{\"1\":{\"111\":8}}],[\"devices\",{\"1\":{\"3\":1,\"111\":1}}],[\"devirtualized\",{\"1\":{\"397\":1}}],[\"development\",{\"1\":{\"392\":1}}],[\"developerworks\",{\"1\":{\"58\":2,\"291\":1,\"306\":1,\"309\":1}}],[\"developers\",{\"1\":{\"53\":1,\"403\":1}}],[\"developer\",{\"1\":{\"0\":1,\"2\":1,\"43\":1,\"53\":1,\"59\":1,\"287\":2,\"314\":1}}],[\"dev京东在flutter加载大量图片导致的内存溢出的优化实践\",{\"1\":{\"198\":1}}],[\"dev\",{\"1\":{\"168\":4,\"186\":5,\"226\":1,\"233\":1,\"242\":1,\"349\":1,\"387\":2,\"392\":1}}],[\"devtools看一下实际生成的widget\",{\"1\":{\"117\":1}}],[\"dao进行进一步的封装得到一个xxxrepository类\",{\"1\":{\"403\":1}}],[\"dao\",{\"1\":{\"399\":1,\"403\":2}}],[\"daemon\",{\"1\":{\"297\":1}}],[\"dartanalyzeror\",{\"1\":{\"396\":1}}],[\"dart2js\",{\"1\":{\"392\":1,\"396\":1}}],[\"dartentry\",{\"1\":{\"389\":1}}],[\"dartinit中已经被设置\",{\"1\":{\"386\":1}}],[\"dartinit\",{\"1\":{\"382\":2,\"383\":1}}],[\"dart获取\",{\"1\":{\"170\":1,\"172\":1}}],[\"dart内容如下\",{\"1\":{\"132\":1}}],[\"dartscope\",{\"1\":{\"116\":1}}],[\"dartworker\",{\"1\":{\"115\":1,\"389\":1}}],[\"dart代码拿到返回的dart\",{\"1\":{\"114\":1}}],[\"dart的\",{\"1\":{\"112\":1}}],[\"dart端发起文件读写请求\",{\"0\":{\"111\":1}}],[\"dart读取文件时\",{\"1\":{\"110\":1}}],[\"dartutils\",{\"1\":{\"100\":2,\"108\":1,\"382\":6}}],[\"dart中的实现\",{\"1\":{\"377\":1}}],[\"dart中的main\",{\"1\":{\"132\":1}}],[\"dart中的方法总共有3种\",{\"1\":{\"109\":1}}],[\"dart中\",{\"1\":{\"99\":1,\"105\":1,\"378\":2}}],[\"dart\",{\"0\":{\"95\":1,\"110\":1,\"115\":1,\"116\":1,\"372\":1,\"388\":1,\"392\":1},\"1\":{\"95\":5,\"96\":3,\"97\":1,\"98\":2,\"99\":1,\"100\":8,\"101\":1,\"102\":1,\"103\":2,\"104\":1,\"105\":7,\"106\":2,\"107\":1,\"108\":29,\"109\":5,\"110\":1,\"111\":10,\"112\":3,\"114\":14,\"115\":46,\"116\":10,\"117\":1,\"118\":3,\"119\":1,\"120\":1,\"121\":3,\"122\":3,\"125\":2,\"126\":4,\"127\":7,\"130\":1,\"132\":3,\"140\":1,\"172\":1,\"192\":1,\"194\":1,\"195\":1,\"201\":1,\"372\":6,\"373\":5,\"376\":2,\"377\":3,\"378\":4,\"381\":3,\"382\":34,\"383\":24,\"384\":1,\"386\":4,\"387\":25,\"388\":8,\"389\":12,\"391\":4,\"392\":8,\"395\":1,\"396\":2,\"397\":2}}],[\"darken\",{\"1\":{\"57\":1}}],[\"daggerappcomponent\",{\"1\":{\"92\":1}}],[\"dagger2\",{\"1\":{\"93\":1}}],[\"dagger2version\",{\"1\":{\"88\":3}}],[\"dagger2使用详解\",{\"1\":{\"87\":1}}],[\"daggerclientcomponent\",{\"1\":{\"84\":2}}],[\"dagger\",{\"0\":{\"82\":1,\"88\":1},\"1\":{\"82\":2,\"87\":1,\"88\":6,\"94\":2}}],[\"datetime\",{\"1\":{\"105\":1,\"110\":1,\"201\":2}}],[\"date\",{\"1\":{\"81\":1,\"302\":3,\"308\":1}}],[\"data>\",{\"1\":{\"401\":2}}],[\"data>元素的值\",{\"1\":{\"54\":1}}],[\"databinding通过标记的形式将数据和组件绑定\",{\"1\":{\"402\":1}}],[\"databindingutil\",{\"1\":{\"401\":1}}],[\"databinding在xml中的形式如下\",{\"1\":{\"401\":1}}],[\"databinding使用在xml中声明的方式\",{\"1\":{\"401\":1}}],[\"databinding则充当布局view和数据\",{\"1\":{\"401\":1}}],[\"databinding绑定布局和数据\",{\"0\":{\"401\":1}}],[\"database\",{\"1\":{\"399\":1,\"403\":1}}],[\"data等绑定\",{\"1\":{\"387\":1}}],[\"data创建isolatedata\",{\"1\":{\"387\":1}}],[\"data=\",{\"1\":{\"381\":1}}],[\"data中\",{\"1\":{\"371\":1}}],[\"dataclass\",{\"1\":{\"321\":1}}],[\"datas\",{\"1\":{\"371\":3}}],[\"datasource\",{\"1\":{\"211\":2}}],[\"datashared\",{\"1\":{\"135\":3}}],[\"dataurl\",{\"1\":{\"136\":2}}],[\"data传给参数threadstart的参数\",{\"1\":{\"115\":1}}],[\"data则是数据\",{\"1\":{\"111\":1}}],[\"data\",{\"1\":{\"2\":2,\"40\":9,\"43\":2,\"54\":8,\"58\":12,\"64\":1,\"79\":1,\"108\":11,\"111\":21,\"112\":10,\"115\":18,\"125\":1,\"126\":2,\"134\":1,\"135\":3,\"194\":1,\"201\":14,\"202\":1,\"282\":1,\"287\":1,\"312\":1,\"321\":2,\"322\":1,\"370\":3,\"371\":13,\"381\":4,\"382\":14,\"383\":9,\"386\":1,\"387\":29,\"388\":6,\"389\":4,\"391\":5,\"396\":1,\"401\":1,\"403\":1,\"426\":1,\"437\":1,\"438\":3}}],[\"da15d26d1a\",{\"1\":{\"54\":1}}],[\"dasusu\",{\"1\":{\"41\":1}}],[\"days\",{\"1\":{\"302\":2}}],[\"daysize\",{\"1\":{\"285\":2}}],[\"day的大小\",{\"1\":{\"285\":1}}],[\"day为例\",{\"1\":{\"285\":1}}],[\"day\",{\"1\":{\"10\":3,\"285\":2,\"302\":8}}],[\"dcim\",{\"1\":{\"2\":1}}],[\"0zlib\",{\"1\":{\"413\":1}}],[\"05\",{\"1\":{\"398\":1,\"417\":2}}],[\"0~2个入参\",{\"1\":{\"373\":1}}],[\"03\",{\"1\":{\"347\":2}}],[\"0个或多个都会报错\",{\"1\":{\"337\":1}}],[\"02x\",{\"1\":{\"305\":1}}],[\"02都属于2010年的第52周\",{\"1\":{\"302\":1}}],[\"00\",{\"1\":{\"302\":2}}],[\"00ff00\",{\"1\":{\"79\":1}}],[\"0800\",{\"1\":{\"302\":2}}],[\"08\",{\"1\":{\"302\":3}}],[\"04的week\",{\"1\":{\"302\":1}}],[\"04都会得到2020\",{\"1\":{\"302\":1}}],[\"04都属于是2020年的第01周\",{\"1\":{\"302\":1}}],[\"01都被划到了2011年的第一周\",{\"1\":{\"302\":1}}],[\"01所在的周为2020的第一周\",{\"1\":{\"302\":1}}],[\"01\",{\"1\":{\"274\":1,\"302\":8,\"371\":1}}],[\"0之间的最大值\",{\"1\":{\"238\":1}}],[\"0或者1\",{\"1\":{\"186\":1}}],[\"09\",{\"1\":{\"116\":1,\"302\":1}}],[\"0x3\",{\"1\":{\"115\":1}}],[\"0xff\",{\"1\":{\"296\":1}}],[\"0xffee0000\",{\"1\":{\"242\":1}}],[\"0xffeeee00\",{\"1\":{\"241\":1,\"242\":1}}],[\"0xff008000\",{\"1\":{\"241\":1}}],[\"0xfffffffffffff\",{\"1\":{\"115\":1}}],[\"0xff152648\",{\"1\":{\"64\":1}}],[\"0的时候直接返回t\",{\"1\":{\"186\":1}}],[\"0的时候\",{\"1\":{\"108\":1}}],[\"0的hope主题\",{\"1\":{\"0\":1}}],[\"0等级最高\",{\"1\":{\"74\":1}}],[\"07\",{\"1\":{\"59\":1,\"111\":1,\"302\":1,\"347\":1,\"398\":3,\"417\":1}}],[\"0号引用binder\",{\"1\":{\"58\":1}}],[\"0f\",{\"1\":{\"53\":2,\"57\":6,\"63\":5,\"81\":4}}],[\"0后必须显示的启动服务\",{\"1\":{\"35\":1}}],[\"0代表不自动创建\",{\"1\":{\"19\":1}}],[\"06\",{\"1\":{\"5\":5,\"280\":1}}],[\"0\",{\"0\":{\"107\":1,\"108\":1},\"1\":{\"2\":6,\"7\":1,\"10\":1,\"13\":5,\"14\":1,\"17\":1,\"20\":2,\"21\":1,\"30\":1,\"36\":3,\"37\":1,\"40\":2,\"41\":2,\"45\":1,\"46\":1,\"47\":1,\"48\":2,\"49\":3,\"50\":2,\"51\":1,\"53\":1,\"56\":2,\"58\":3,\"64\":20,\"65\":8,\"66\":1,\"69\":4,\"72\":2,\"76\":3,\"79\":3,\"80\":1,\"100\":2,\"102\":7,\"103\":1,\"105\":8,\"106\":4,\"108\":3,\"109\":8,\"111\":10,\"112\":6,\"115\":12,\"117\":1,\"127\":1,\"131\":2,\"140\":1,\"150\":2,\"153\":1,\"155\":1,\"156\":1,\"161\":4,\"162\":2,\"163\":2,\"166\":9,\"167\":3,\"179\":7,\"181\":4,\"183\":3,\"184\":6,\"185\":3,\"186\":10,\"188\":1,\"192\":2,\"193\":1,\"196\":1,\"198\":2,\"210\":1,\"211\":6,\"212\":1,\"213\":8,\"220\":25,\"221\":8,\"223\":2,\"225\":6,\"226\":28,\"238\":10,\"239\":9,\"241\":2,\"242\":2,\"272\":2,\"277\":1,\"280\":2,\"282\":6,\"283\":1,\"288\":2,\"289\":10,\"291\":3,\"296\":3,\"297\":11,\"302\":4,\"309\":2,\"311\":1,\"314\":1,\"322\":2,\"328\":2,\"334\":1,\"346\":2,\"351\":1,\"361\":1,\"363\":1,\"369\":1,\"370\":4,\"376\":5,\"377\":6,\"378\":3,\"379\":1,\"383\":3,\"384\":1,\"387\":6,\"389\":6,\"390\":1,\"391\":2,\"401\":1,\"413\":3,\"421\":1,\"433\":1,\"437\":4,\"438\":6,\"440\":1,\"450\":1,\"451\":3,\"453\":6,\"455\":2,\"456\":4,\"457\":2,\"459\":7,\"462\":6,\"467\":2}}],[\"rf\",{\"1\":{\"407\":4}}],[\"rfc\",{\"1\":{\"302\":1}}],[\"r表示递归\",{\"1\":{\"349\":1}}],[\"rsa\",{\"1\":{\"347\":2}}],[\"rm删除\",{\"1\":{\"349\":1}}],[\"rm\",{\"1\":{\"282\":1,\"349\":2,\"407\":2}}],[\"rtl\",{\"1\":{\"228\":1}}],[\"rtc\",{\"1\":{\"4\":2,\"5\":1,\"10\":1}}],[\"rgba8888\",{\"1\":{\"210\":1}}],[\"richtext的textspan和children都是null\",{\"1\":{\"127\":1}}],[\"richtext继承自multichildrenderobjectwidget\",{\"1\":{\"127\":1}}],[\"richtext\",{\"0\":{\"127\":1},\"1\":{\"117\":1,\"126\":4,\"127\":2}}],[\"right指针向左移动查找比c小的值\",{\"1\":{\"464\":1}}],[\"rightindex\",{\"1\":{\"441\":7,\"467\":10}}],[\"rightpreorder\",{\"1\":{\"346\":2}}],[\"righttree\",{\"1\":{\"346\":3}}],[\"right\",{\"1\":{\"41\":3,\"64\":1,\"181\":2,\"228\":1,\"239\":1,\"346\":2,\"400\":1,\"429\":1,\"430\":1,\"432\":18,\"464\":1,\"467\":8}}],[\"r>\",{\"1\":{\"103\":1}}],[\"rpx\",{\"1\":{\"81\":1}}],[\"rdp\",{\"1\":{\"81\":8}}],[\"raise\",{\"1\":{\"369\":1}}],[\"radial\",{\"0\":{\"172\":1},\"1\":{\"172\":1,\"173\":1,\"181\":1}}],[\"radius=\",{\"1\":{\"66\":1}}],[\"ratio\",{\"1\":{\"153\":1}}],[\"rather\",{\"1\":{\"115\":1,\"308\":1}}],[\"range\",{\"1\":{\"186\":1,\"302\":1,\"462\":3}}],[\"rangeerror\",{\"1\":{\"142\":1}}],[\"randomaccessfile中\",{\"1\":{\"111\":1}}],[\"randomaccessfileops\",{\"1\":{\"111\":2}}],[\"randomaccessfile的open\",{\"1\":{\"111\":1}}],[\"randomaccessfile\",{\"1\":{\"111\":6}}],[\"race\",{\"1\":{\"115\":1}}],[\"rawcast\",{\"1\":{\"389\":1}}],[\"rawgesturedetector\",{\"1\":{\"212\":1,\"226\":1,\"227\":1,\"234\":1}}],[\"rawiamge\",{\"1\":{\"207\":1}}],[\"rawimagedatamap\",{\"1\":{\"202\":1}}],[\"rawimage\",{\"0\":{\"194\":1},\"1\":{\"189\":1,\"193\":2,\"194\":2,\"195\":1,\"198\":2,\"207\":2,\"211\":1}}],[\"rawpath\",{\"1\":{\"111\":1}}],[\"rawreceiveport\",{\"1\":{\"101\":1,\"111\":2,\"112\":2,\"378\":6}}],[\"rawreceiveportimpl的static\",{\"1\":{\"378\":1}}],[\"rawreceiveportimpl\",{\"1\":{\"101\":1,\"106\":2}}],[\"rawuseofparameterizedtype\",{\"1\":{\"80\":1}}],[\"rawy\",{\"1\":{\"41\":1}}],[\"rawx\",{\"1\":{\"41\":1}}],[\"raw\",{\"1\":{\"2\":1,\"116\":2,\"194\":1,\"202\":1,\"394\":1}}],[\"robert\",{\"1\":{\"444\":1,\"451\":1}}],[\"ro\",{\"1\":{\"369\":1}}],[\"rocks\",{\"1\":{\"345\":1}}],[\"route\",{\"1\":{\"179\":4,\"180\":2,\"376\":1}}],[\"route<dynamic>\",{\"1\":{\"179\":2}}],[\"routes\",{\"1\":{\"179\":1}}],[\"round\",{\"1\":{\"105\":1,\"184\":1,\"185\":1}}],[\"rotation\",{\"1\":{\"154\":1}}],[\"rotationtransition\",{\"1\":{\"154\":1,\"155\":2}}],[\"rotate\",{\"1\":{\"147\":1,\"155\":1,\"156\":1,\"170\":1}}],[\"rowbytes\",{\"1\":{\"211\":4}}],[\"row\",{\"1\":{\"131\":3,\"139\":1,\"140\":2}}],[\"romainguy\",{\"1\":{\"282\":2,\"286\":1,\"287\":1}}],[\"rom\",{\"1\":{\"60\":1}}],[\"root用户可以访问任何用户文件\",{\"1\":{\"351\":1}}],[\"root用户可以更改\",{\"1\":{\"349\":1}}],[\"root用户为\",{\"1\":{\"349\":2}}],[\"roots\",{\"1\":{\"383\":2}}],[\"roots可以是以下几种\",{\"1\":{\"263\":1}}],[\"roots开始遍历\",{\"1\":{\"263\":1}}],[\"rootschedulemicrotask\",{\"1\":{\"96\":4}}],[\"rootchildslot\",{\"1\":{\"121\":1}}],[\"rootrenderobjectelement\",{\"1\":{\"121\":2}}],[\"rootwidget\",{\"1\":{\"119\":3}}],[\"rootnode\",{\"1\":{\"118\":1}}],[\"rootzone的同名方法\",{\"1\":{\"96\":1}}],[\"rootzone\",{\"0\":{\"97\":1,\"98\":1},\"1\":{\"96\":7,\"97\":1,\"103\":1,\"105\":2}}],[\"root\",{\"1\":{\"56\":1,\"96\":2,\"104\":6,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"346\":3,\"349\":1,\"370\":3,\"371\":4,\"378\":1,\"384\":2,\"387\":2,\"401\":1,\"417\":3,\"432\":2}}],[\"room需要3个元素\",{\"1\":{\"403\":1}}],[\"room持久性库在sqlite上提供了一个抽象层\",{\"1\":{\"403\":1}}],[\"room保存数据\",{\"0\":{\"403\":1}}],[\"room\",{\"1\":{\"45\":1,\"376\":1}}],[\"r\",{\"1\":{\"30\":5,\"56\":9,\"64\":2,\"66\":3,\"71\":2,\"79\":4,\"80\":2,\"93\":1,\"110\":1,\"299\":1,\"301\":1,\"349\":3,\"351\":2,\"352\":2,\"353\":1,\"361\":1,\"371\":2,\"373\":1,\"400\":1,\"401\":2,\"411\":1,\"424\":2,\"427\":2}}],[\"runloopasync的主要功能是触发isolate的message\",{\"1\":{\"391\":1}}],[\"runloopasync开始isolate处理消息\",{\"1\":{\"389\":1}}],[\"runloopasync方法中正式开始isolate处理event\",{\"1\":{\"389\":1}}],[\"runloopasync\",{\"1\":{\"389\":4,\"391\":1}}],[\"runlightweight\",{\"0\":{\"381\":1},\"1\":{\"380\":1,\"381\":1,\"386\":1}}],[\"run方法中指定的messagehandlertask\",{\"1\":{\"391\":1}}],[\"run方法中\",{\"1\":{\"385\":1}}],[\"run<spawnisolatetask>\",{\"1\":{\"384\":1}}],[\"runheavyweight方法的最后也调用了\",{\"1\":{\"381\":1}}],[\"runheavyweight\",{\"0\":{\"386\":1},\"1\":{\"380\":1,\"386\":2}}],[\"runblocking<unit>\",{\"1\":{\"325\":1,\"327\":3,\"341\":1}}],[\"runblocking\",{\"0\":{\"323\":1},\"1\":{\"323\":1,\"328\":1,\"329\":1}}],[\"runoob\",{\"1\":{\"281\":1}}],[\"runzonedguarded\",{\"0\":{\"145\":1},\"1\":{\"145\":2}}],[\"runapp方法执行之后\",{\"1\":{\"122\":1}}],[\"runapp\",{\"1\":{\"117\":2,\"131\":1,\"132\":1,\"143\":1,\"145\":1}}],[\"runapp是怎么将我们编写的widget等添加到手机上的呢\",{\"1\":{\"117\":1}}],[\"runimpl\",{\"1\":{\"115\":2,\"389\":2,\"391\":3}}],[\"runs\",{\"1\":{\"115\":1,\"136\":1,\"372\":1,\"378\":1,\"389\":1}}],[\"runpendingimmediatecallback则会执行\",{\"1\":{\"101\":1}}],[\"runpendingimmediatecallback\",{\"1\":{\"101\":3,\"109\":1}}],[\"runtimetype\",{\"1\":{\"180\":1,\"205\":2}}],[\"runtimers方法中执行callback\",{\"1\":{\"109\":1}}],[\"runtimers中执行\",{\"1\":{\"109\":1}}],[\"runtimers\",{\"1\":{\"109\":2}}],[\"runtime\",{\"1\":{\"86\":2,\"87\":1,\"100\":1,\"108\":2,\"114\":2,\"115\":18,\"116\":2,\"278\":1,\"298\":1,\"299\":1,\"376\":2,\"377\":2,\"379\":1,\"380\":1,\"381\":2,\"382\":4,\"383\":9,\"384\":1,\"387\":7,\"388\":1,\"389\":6,\"390\":1,\"391\":5,\"392\":1,\"396\":1}}],[\"runtimeexception\",{\"1\":{\"24\":1}}],[\"run\",{\"0\":{\"246\":1,\"389\":1},\"1\":{\"66\":1,\"80\":3,\"101\":9,\"104\":2,\"110\":2,\"115\":6,\"117\":1,\"275\":1,\"278\":1,\"288\":2,\"365\":1,\"372\":1,\"380\":1,\"381\":1,\"382\":2,\"386\":2,\"387\":6,\"389\":8,\"391\":7,\"396\":1}}],[\"runningtoidlelocked\",{\"1\":{\"391\":1}}],[\"running\",{\"1\":{\"59\":1,\"80\":3,\"101\":1,\"115\":6,\"376\":1,\"389\":5,\"390\":2,\"391\":10,\"414\":1}}],[\"runnable\",{\"1\":{\"30\":3,\"31\":1,\"65\":1,\"80\":3,\"288\":2,\"322\":1,\"365\":1,\"389\":1}}],[\"r3\",{\"1\":{\"13\":1}}],[\"regions\",{\"1\":{\"396\":1}}],[\"registerisolategroup\",{\"1\":{\"388\":1}}],[\"registerimageloader\",{\"1\":{\"211\":2}}],[\"registerimageloader注册具体的实现\",{\"1\":{\"211\":1}}],[\"registerstaticfield\",{\"1\":{\"383\":1}}],[\"registerglobalkey\",{\"1\":{\"121\":1}}],[\"registereventhandler\",{\"1\":{\"211\":1}}],[\"registererrorhandler\",{\"1\":{\"103\":1}}],[\"registered\",{\"1\":{\"100\":1,\"105\":1,\"111\":1,\"112\":1,\"211\":1,\"383\":1}}],[\"registerunarycallback<futureor<r>\",{\"1\":{\"103\":1}}],[\"register\",{\"1\":{\"36\":2,\"103\":1,\"106\":1,\"108\":1,\"383\":1}}],[\"registercallback注册回调方法\",{\"1\":{\"36\":1}}],[\"registercallback\",{\"1\":{\"35\":2,\"36\":1,\"96\":1}}],[\"reevaluate\",{\"1\":{\"391\":1}}],[\"reentrantlock\",{\"1\":{\"318\":1}}],[\"reverted\",{\"1\":{\"389\":1}}],[\"reversed\",{\"1\":{\"438\":1}}],[\"reverseduration\",{\"1\":{\"161\":1}}],[\"reversecurve\",{\"1\":{\"177\":1}}],[\"reverseanimation\",{\"1\":{\"159\":1,\"181\":1}}],[\"reverse\",{\"1\":{\"158\":1,\"161\":2,\"162\":1,\"167\":3,\"168\":1,\"181\":2,\"213\":2,\"226\":1,\"383\":1}}],[\"reverselookup\",{\"1\":{\"115\":1}}],[\"reusing\",{\"1\":{\"383\":1}}],[\"req\",{\"1\":{\"370\":2}}],[\"require\",{\"1\":{\"211\":2,\"277\":1}}],[\"required\",{\"1\":{\"120\":1,\"130\":5,\"131\":2,\"147\":1,\"154\":1,\"155\":1,\"156\":2,\"172\":3,\"175\":2,\"177\":13,\"185\":1,\"192\":2,\"240\":1,\"389\":1}}],[\"requestbody\",{\"1\":{\"364\":4}}],[\"requestcall对象的execute\",{\"1\":{\"365\":1}}],[\"requestcall类则是对okhttp3\",{\"1\":{\"365\":1}}],[\"requestcall\",{\"1\":{\"362\":1,\"364\":4,\"365\":5}}],[\"requestcode\",{\"1\":{\"7\":2,\"8\":1,\"10\":1,\"11\":1,\"69\":2}}],[\"requestlistener<drawable>\",{\"1\":{\"211\":1}}],[\"requesting\",{\"1\":{\"383\":1}}],[\"requestinfo\",{\"1\":{\"211\":3}}],[\"requestid\",{\"1\":{\"211\":3}}],[\"request标记请求操作的类型\",{\"1\":{\"111\":1}}],[\"requests中去除对应的请求并尝试终止任务\",{\"1\":{\"211\":1}}],[\"requests\",{\"1\":{\"111\":1,\"211\":7,\"382\":1,\"383\":1,\"391\":1}}],[\"requested\",{\"1\":{\"108\":1,\"118\":1}}],[\"requestpermissions\",{\"1\":{\"69\":1}}],[\"request\",{\"1\":{\"69\":6,\"111\":10,\"112\":4,\"115\":23,\"211\":24,\"362\":4,\"364\":8,\"365\":3,\"370\":3,\"376\":1,\"391\":1}}],[\"requestwindowfeature\",{\"1\":{\"13\":1}}],[\"rebuilt\",{\"1\":{\"130\":1,\"148\":1,\"154\":1,\"155\":2}}],[\"rebuild的机制导致的\",{\"1\":{\"130\":1}}],[\"rebuild方法中\",{\"1\":{\"121\":1}}],[\"rebuild\",{\"1\":{\"121\":2,\"126\":1,\"128\":1,\"130\":2,\"152\":1,\"176\":2}}],[\"renderxxx\",{\"1\":{\"230\":1}}],[\"renderabstractviewport\",{\"1\":{\"229\":1,\"237\":1}}],[\"renderaligningshiftedbox\",{\"1\":{\"124\":1}}],[\"rendernestedscrollviewviewport\",{\"1\":{\"212\":1,\"213\":1}}],[\"rendersinglechildview完成了支持内部单个box\",{\"1\":{\"240\":1}}],[\"rendersinglechildviewport将hittest直接转发给了child\",{\"1\":{\"240\":1}}],[\"rendersinglechildviewport接收传入的child\",{\"1\":{\"239\":1}}],[\"rendersinglechildviewport收到通知\",{\"1\":{\"237\":1}}],[\"rendersinglechildviewport的继承关系\",{\"1\":{\"237\":1}}],[\"rendersinglechildviewport这个renderobject中\",{\"1\":{\"236\":1}}],[\"rendersinglechildviewport\",{\"0\":{\"237\":1},\"1\":{\"236\":4,\"237\":2}}],[\"rendershrinkwrappingviewport\",{\"0\":{\"232\":1},\"1\":{\"228\":4,\"230\":1,\"232\":3}}],[\"rendershiftedbox\",{\"1\":{\"124\":1}}],[\"rendersliver的widget\",{\"1\":{\"213\":1}}],[\"rendersliverfillremainingwithscrollable\",{\"1\":{\"213\":1}}],[\"rendersliver\",{\"0\":{\"230\":1},\"1\":{\"212\":2,\"213\":1,\"227\":3,\"229\":1,\"230\":4,\"233\":2}}],[\"rendertype\",{\"1\":{\"211\":3}}],[\"renderimage\",{\"0\":{\"195\":1},\"1\":{\"194\":1,\"195\":1,\"198\":1}}],[\"renderingtype表示图片渲染方式\",{\"1\":{\"211\":1}}],[\"renderingtype\",{\"1\":{\"211\":3}}],[\"renderingtype的值\",{\"1\":{\"208\":1}}],[\"renderingtype指定了\",{\"1\":{\"204\":1}}],[\"rendering\",{\"1\":{\"118\":2,\"122\":1,\"127\":1}}],[\"renderboxcontainerdefaultsmixin<renderbox\",{\"1\":{\"127\":1}}],[\"renderbox\",{\"1\":{\"124\":1,\"127\":1,\"176\":2,\"180\":1,\"195\":1,\"212\":2,\"227\":1,\"229\":3,\"237\":1}}],[\"rendered\",{\"1\":{\"118\":1}}],[\"rendererbinding\",{\"1\":{\"118\":2,\"119\":1}}],[\"render\",{\"1\":{\"118\":1,\"128\":2,\"195\":1,\"211\":2}}],[\"renderparagraph赋值给renderobject\",{\"1\":{\"127\":1}}],[\"renderparagraph\",{\"1\":{\"117\":1,\"124\":1,\"126\":1,\"127\":5}}],[\"renderpositionedbox可以按照给定的alignmentgeometry定位child\",{\"1\":{\"124\":1}}],[\"renderpositionedbox是center\",{\"1\":{\"124\":1}}],[\"renderpositionedbox\",{\"0\":{\"124\":1},\"1\":{\"117\":2,\"122\":5,\"124\":2,\"125\":1,\"126\":1,\"127\":1}}],[\"renderviewportbase<sliverlogicalcontainerparentdata>\",{\"1\":{\"232\":1}}],[\"renderviewportbase<sliverphysicalcontainerparentdata>\",{\"1\":{\"231\":1}}],[\"renderviewportbase<parentdataclass\",{\"1\":{\"229\":1}}],[\"renderviewportbase\",{\"0\":{\"229\":1},\"1\":{\"228\":1,\"229\":1,\"230\":3}}],[\"renderviewport\",{\"0\":{\"231\":1},\"1\":{\"213\":1,\"228\":4,\"230\":2,\"231\":2}}],[\"renderview和buildowner\",{\"1\":{\"127\":1}}],[\"renderview有且仅有一个renderbox类型的child\",{\"1\":{\"122\":1}}],[\"renderview是renderobject\",{\"1\":{\"122\":1}}],[\"renderviewelement\",{\"1\":{\"119\":3}}],[\"renderview\",{\"1\":{\"117\":1,\"118\":7,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"124\":1,\"126\":1,\"127\":1}}],[\"renderobjects\",{\"1\":{\"127\":1}}],[\"renderobject插入到rendering\",{\"1\":{\"127\":1}}],[\"renderobjectelement类的方法\",{\"1\":{\"127\":1}}],[\"renderobjectelement\",{\"1\":{\"121\":1,\"125\":1,\"126\":1,\"127\":6,\"230\":1}}],[\"renderobjectwithchildmixin为renderobject提供一套管理单个child的模式\",{\"1\":{\"237\":1}}],[\"renderobjectwithchildmixin<renderbox>\",{\"1\":{\"237\":2}}],[\"renderobjectwithchildmixin<renderobject>\",{\"1\":{\"127\":2}}],[\"renderobjectwithchildmixin<t>\",{\"1\":{\"120\":1}}],[\"renderobjectwidget\",{\"1\":{\"120\":1,\"121\":2,\"125\":1,\"127\":1}}],[\"renderobject>\",{\"1\":{\"120\":1,\"121\":2}}],[\"renderobjecttowidgetadapter在attachtorendertree\",{\"1\":{\"121\":1}}],[\"renderobjecttowidgetadapter<t>\",{\"1\":{\"121\":1}}],[\"renderobjecttowidgetadapter<t\",{\"1\":{\"120\":1,\"121\":1}}],[\"renderobjecttowidgetadapter<renderbox>\",{\"1\":{\"119\":1}}],[\"renderobjecttowidgetadapter\",{\"0\":{\"120\":1},\"1\":{\"120\":3,\"121\":2,\"122\":1,\"126\":1,\"127\":2}}],[\"renderobjecttowidgetelement下面\",{\"1\":{\"121\":1}}],[\"renderobjecttowidgetelement<t\",{\"1\":{\"121\":1}}],[\"renderobjecttowidgetelement<t>\",{\"1\":{\"120\":2,\"121\":2}}],[\"renderobjecttowidgetelement<renderbox>\",{\"1\":{\"119\":1}}],[\"renderobjecttowidgetelement\",{\"1\":{\"117\":2,\"121\":1,\"122\":2,\"125\":1,\"126\":1,\"127\":2}}],[\"renderobject\",{\"0\":{\"124\":1},\"1\":{\"117\":3,\"118\":1,\"119\":1,\"120\":1,\"121\":3,\"122\":5,\"124\":1,\"126\":3,\"127\":9,\"128\":1,\"180\":2,\"213\":1,\"228\":5,\"230\":12,\"236\":2}}],[\"renderobject这三个tree的关系\",{\"1\":{\"117\":1}}],[\"renderobjet三者的关系来梳理一下flutter的绘制过程\",{\"1\":{\"117\":1}}],[\"renamelink\",{\"1\":{\"115\":1}}],[\"rename\",{\"1\":{\"115\":2}}],[\"re\",{\"1\":{\"109\":2,\"112\":1,\"136\":2,\"179\":1,\"180\":1,\"181\":1,\"198\":2,\"371\":1,\"383\":1,\"391\":2}}],[\"reinterpreting\",{\"1\":{\"115\":1}}],[\"reinterpret\",{\"1\":{\"108\":1,\"115\":3,\"381\":1,\"382\":1,\"383\":2,\"386\":1,\"389\":2,\"391\":1}}],[\"reflect\",{\"1\":{\"295\":3}}],[\"reflected\",{\"1\":{\"295\":1}}],[\"reflection\",{\"1\":{\"295\":1}}],[\"reflect反射调用类\",{\"1\":{\"279\":1}}],[\"refcount\",{\"1\":{\"108\":1}}],[\"references\",{\"1\":{\"275\":1,\"278\":2,\"283\":1}}],[\"reference\",{\"1\":{\"2\":1,\"278\":1,\"287\":1,\"305\":1,\"309\":1,\"314\":1,\"328\":1}}],[\"remember\",{\"1\":{\"327\":1,\"391\":1}}],[\"remains\",{\"1\":{\"115\":1}}],[\"remainingdelta\",{\"1\":{\"226\":3}}],[\"remainingpaintextent\",{\"1\":{\"213\":2}}],[\"remaining++\",{\"1\":{\"102\":1}}],[\"remaining\",{\"1\":{\"102\":13,\"180\":1}}],[\"removefirst\",{\"1\":{\"391\":1}}],[\"removeonexitlistener这些指令消息都是压入到obb\",{\"1\":{\"376\":1}}],[\"remove操作\",{\"1\":{\"288\":1}}],[\"remove都只是更新了本线程中threadlocal对象对应的值\",{\"1\":{\"288\":1}}],[\"remove方法\",{\"1\":{\"288\":1}}],[\"remove的时候都需要使用二分法\",{\"1\":{\"287\":1}}],[\"removestatuslistener\",{\"1\":{\"158\":1,\"168\":1}}],[\"removelistener\",{\"1\":{\"155\":2,\"158\":1,\"168\":1,\"198\":2,\"237\":2}}],[\"removelast\",{\"1\":{\"112\":1}}],[\"removed\",{\"1\":{\"126\":1,\"180\":1,\"198\":1,\"209\":1}}],[\"removeviews\",{\"1\":{\"79\":1}}],[\"removeat\",{\"1\":{\"52\":1}}],[\"remove\",{\"0\":{\"47\":1,\"52\":1},\"1\":{\"36\":1,\"47\":1,\"52\":1,\"111\":4,\"112\":3,\"128\":1,\"180\":2,\"198\":3,\"209\":1,\"211\":1,\"297\":1,\"438\":1}}],[\"removenotification\",{\"1\":{\"21\":1}}],[\"remoteview\",{\"1\":{\"79\":1}}],[\"remoteviews对象\",{\"1\":{\"79\":1}}],[\"remoteviews\",{\"1\":{\"79\":8}}],[\"remotecallbacklist可以在客户端死亡的时候自动注销掉对应的listener\",{\"1\":{\"36\":1}}],[\"remotecallbacklist<>\",{\"1\":{\"36\":1}}],[\"remotecallbacklist<taskcallback>\",{\"1\":{\"36\":1}}],[\"remotecallbacklist\",{\"1\":{\"36\":2}}],[\"remoteexception\",{\"1\":{\"35\":6,\"36\":7,\"40\":3,\"58\":3,\"322\":1}}],[\"remote\",{\"0\":{\"248\":1},\"1\":{\"17\":3,\"20\":1,\"40\":2,\"58\":2,\"347\":2}}],[\"releasing\",{\"1\":{\"391\":1}}],[\"released\",{\"1\":{\"391\":1}}],[\"releaserequestswitharguments\",{\"1\":{\"211\":1}}],[\"releaseimagerequests\",{\"1\":{\"211\":4}}],[\"releaseimagerequest\",{\"1\":{\"210\":1,\"211\":1}}],[\"release模式下会\",{\"1\":{\"143\":1}}],[\"release下则不会\",{\"1\":{\"143\":1}}],[\"release会显示为灰色布局\",{\"1\":{\"143\":1}}],[\"release\",{\"1\":{\"14\":1,\"110\":1,\"115\":1,\"390\":1,\"391\":4}}],[\"reload\",{\"1\":{\"371\":1,\"392\":1}}],[\"rely\",{\"1\":{\"287\":1,\"396\":1}}],[\"related\",{\"1\":{\"382\":1}}],[\"relativerect\",{\"1\":{\"181\":2}}],[\"relativepositionedtransition\",{\"1\":{\"154\":1}}],[\"relative\",{\"1\":{\"147\":1,\"154\":1,\"382\":1}}],[\"relationship\",{\"1\":{\"128\":1}}],[\"relayoutwhensystemfontschangemixin\",{\"1\":{\"127\":1}}],[\"relies\",{\"1\":{\"101\":1}}],[\"red\",{\"1\":{\"242\":1}}],[\"reduce\",{\"1\":{\"49\":1,\"220\":1,\"337\":1,\"396\":1}}],[\"redeliver\",{\"1\":{\"17\":2}}],[\"redelivery\",{\"1\":{\"17\":1}}],[\"repo\",{\"1\":{\"418\":1}}],[\"reporterror\",{\"1\":{\"389\":5}}],[\"report\",{\"1\":{\"389\":1}}],[\"reponse\",{\"1\":{\"365\":1}}],[\"repos\",{\"1\":{\"322\":2}}],[\"rep\",{\"1\":{\"305\":11}}],[\"represented\",{\"1\":{\"305\":1}}],[\"representation\",{\"1\":{\"274\":2,\"276\":1}}],[\"representative\",{\"1\":{\"225\":1}}],[\"representable\",{\"1\":{\"115\":1}}],[\"representing\",{\"1\":{\"220\":1,\"322\":1}}],[\"replace\",{\"1\":{\"322\":1}}],[\"replacement\",{\"1\":{\"305\":1}}],[\"replaceimage\",{\"1\":{\"192\":2}}],[\"replyhandler\",{\"1\":{\"43\":1}}],[\"replymessenger\",{\"1\":{\"43\":2}}],[\"replymsg\",{\"1\":{\"20\":3}}],[\"reply\",{\"1\":{\"40\":11,\"58\":10,\"115\":6}}],[\"replytoport发送处理结果\",{\"1\":{\"112\":1}}],[\"replytoport来发消息触发\",{\"1\":{\"111\":1,\"112\":1}}],[\"replytoport触发在root\",{\"1\":{\"111\":1,\"112\":1}}],[\"replytoport\",{\"1\":{\"111\":5,\"112\":5,\"115\":2,\"116\":1}}],[\"replyto\",{\"1\":{\"20\":2,\"43\":2}}],[\"repaintboundary\",{\"1\":{\"181\":1}}],[\"repeatingsimulation\",{\"0\":{\"167\":1},\"1\":{\"167\":1}}],[\"repeating\",{\"1\":{\"105\":5,\"109\":3}}],[\"repeatcounter++\",{\"1\":{\"95\":1}}],[\"repeatcount\",{\"1\":{\"63\":1}}],[\"repeat\",{\"1\":{\"10\":2,\"11\":1,\"95\":1,\"161\":1,\"168\":1,\"193\":2,\"328\":1}}],[\"retval\",{\"1\":{\"382\":3}}],[\"rethrow\",{\"1\":{\"209\":1,\"378\":1}}],[\"retrofitapi\",{\"1\":{\"322\":1}}],[\"retries\",{\"1\":{\"201\":1}}],[\"retrieve\",{\"1\":{\"101\":1,\"426\":1}}],[\"retry\",{\"1\":{\"17\":1}}],[\"retentionpolicy\",{\"1\":{\"299\":1}}],[\"retention\",{\"1\":{\"86\":2,\"87\":1,\"298\":1,\"299\":1}}],[\"returnaddress\",{\"1\":{\"252\":1}}],[\"returnport\",{\"1\":{\"111\":1,\"112\":2}}],[\"returns\",{\"1\":{\"92\":1,\"114\":2,\"126\":4,\"128\":1,\"220\":1,\"305\":1,\"314\":1,\"328\":1,\"387\":1,\"389\":2,\"391\":1}}],[\"returned\",{\"1\":{\"49\":1,\"75\":1,\"103\":1,\"426\":1}}],[\"return\",{\"1\":{\"2\":2,\"7\":1,\"11\":1,\"13\":11,\"17\":1,\"19\":2,\"20\":1,\"26\":1,\"29\":1,\"30\":3,\"35\":1,\"36\":6,\"40\":9,\"42\":1,\"43\":3,\"45\":1,\"46\":3,\"49\":7,\"51\":1,\"53\":8,\"55\":4,\"58\":12,\"65\":3,\"72\":2,\"78\":1,\"80\":4,\"81\":3,\"95\":2,\"96\":3,\"100\":3,\"101\":6,\"102\":5,\"103\":3,\"104\":4,\"105\":9,\"108\":3,\"109\":1,\"110\":1,\"111\":18,\"112\":3,\"114\":3,\"115\":28,\"116\":4,\"118\":1,\"121\":1,\"122\":2,\"126\":1,\"127\":2,\"128\":3,\"130\":6,\"131\":3,\"132\":1,\"133\":1,\"134\":2,\"135\":1,\"143\":3,\"147\":1,\"149\":3,\"150\":1,\"152\":1,\"153\":3,\"155\":1,\"156\":2,\"158\":1,\"162\":1,\"166\":3,\"167\":2,\"170\":1,\"172\":1,\"176\":4,\"177\":2,\"178\":3,\"179\":2,\"180\":3,\"181\":4,\"183\":3,\"184\":4,\"185\":2,\"186\":3,\"191\":1,\"193\":3,\"196\":3,\"198\":4,\"201\":4,\"202\":3,\"205\":4,\"206\":4,\"207\":2,\"209\":1,\"210\":4,\"211\":10,\"212\":2,\"213\":3,\"215\":1,\"220\":2,\"221\":3,\"223\":3,\"225\":4,\"226\":1,\"227\":4,\"228\":6,\"230\":2,\"235\":3,\"236\":1,\"237\":1,\"238\":8,\"239\":4,\"240\":3,\"241\":1,\"242\":1,\"272\":2,\"280\":2,\"281\":1,\"282\":1,\"288\":3,\"294\":5,\"295\":1,\"296\":4,\"305\":3,\"308\":1,\"309\":5,\"311\":1,\"314\":3,\"321\":2,\"322\":7,\"346\":1,\"363\":3,\"364\":3,\"365\":3,\"369\":2,\"370\":4,\"371\":5,\"376\":1,\"377\":2,\"378\":4,\"379\":1,\"381\":5,\"382\":8,\"383\":11,\"384\":1,\"386\":2,\"387\":6,\"388\":1,\"389\":15,\"390\":3,\"391\":6,\"427\":1,\"429\":1,\"430\":1,\"432\":3,\"438\":6,\"451\":4,\"453\":2,\"455\":1,\"456\":1,\"457\":1,\"459\":5,\"462\":5,\"467\":2}}],[\"record\",{\"1\":{\"272\":1}}],[\"recognised\",{\"1\":{\"102\":1}}],[\"recognized\",{\"1\":{\"102\":1}}],[\"recursive\",{\"1\":{\"201\":1}}],[\"recently\",{\"1\":{\"198\":1}}],[\"receivechannel<string>\",{\"1\":{\"334\":2}}],[\"receivechannel<int>\",{\"1\":{\"328\":2}}],[\"receivechannel<e>\",{\"1\":{\"328\":1}}],[\"receivechannel\",{\"1\":{\"328\":2}}],[\"receivebroadcaststream\",{\"1\":{\"211\":1}}],[\"received\",{\"1\":{\"111\":1,\"112\":1,\"115\":1,\"230\":1,\"373\":3}}],[\"receiveport依然可以收到消息\",{\"1\":{\"376\":1}}],[\"receiveport的sendport\",{\"1\":{\"112\":1}}],[\"receiveport的回调\",{\"1\":{\"112\":1}}],[\"receiveport的hander也就是\",{\"1\":{\"108\":1}}],[\"receiveport的handler也就是在\",{\"1\":{\"107\":1}}],[\"receiveport监听\",{\"1\":{\"111\":1}}],[\"receiveport对应的sendport\",{\"1\":{\"106\":1}}],[\"receiveportactive\",{\"1\":{\"106\":3,\"107\":1,\"108\":1}}],[\"receiveport\",{\"1\":{\"106\":6,\"108\":1,\"111\":8,\"112\":7,\"116\":2,\"372\":1,\"373\":11,\"376\":1}}],[\"receiver\",{\"1\":{\"396\":1}}],[\"receiver>\",{\"1\":{\"79\":1}}],[\"receiver中的meta\",{\"1\":{\"54\":1}}],[\"receive\",{\"1\":{\"13\":1,\"106\":1,\"108\":2,\"115\":1,\"328\":6,\"329\":1}}],[\"recreatelistener\",{\"1\":{\"191\":2}}],[\"recttween\",{\"1\":{\"177\":1}}],[\"rectclip\",{\"1\":{\"172\":1,\"181\":1}}],[\"rectf\",{\"1\":{\"65\":4}}],[\"rect\",{\"1\":{\"64\":3,\"177\":6,\"178\":2,\"181\":4}}],[\"reclaim\",{\"1\":{\"59\":1}}],[\"recycleview的layoutmanager\",{\"1\":{\"399\":1}}],[\"recycleview滑动\",{\"1\":{\"41\":1}}],[\"recycle\",{\"1\":{\"25\":2,\"40\":2,\"58\":2}}],[\"recyclerreplymsghandler\",{\"1\":{\"20\":2}}],[\"recyclerview\",{\"1\":{\"1\":1,\"55\":1,\"64\":8,\"401\":3}}],[\"recyclerview添加依赖\",{\"1\":{\"1\":1}}],[\"reacquire\",{\"1\":{\"391\":2}}],[\"reachable\",{\"1\":{\"396\":2}}],[\"reach\",{\"1\":{\"226\":1}}],[\"realnode\",{\"1\":{\"438\":2}}],[\"real\",{\"1\":{\"396\":1}}],[\"realsize\",{\"1\":{\"285\":1}}],[\"realtime\",{\"1\":{\"4\":2,\"11\":1}}],[\"reassemble\",{\"1\":{\"190\":1}}],[\"reader\",{\"1\":{\"383\":1}}],[\"readexternal\",{\"1\":{\"311\":1}}],[\"readexception\",{\"1\":{\"40\":1,\"58\":1}}],[\"readymessage\",{\"1\":{\"378\":8}}],[\"ready\",{\"1\":{\"378\":3}}],[\"readyport\",{\"1\":{\"378\":15}}],[\"readytoproduceframes\",{\"1\":{\"119\":1}}],[\"readtimeout\",{\"1\":{\"362\":1,\"365\":1}}],[\"readtext\",{\"1\":{\"321\":1}}],[\"readin\",{\"1\":{\"322\":1}}],[\"readint\",{\"1\":{\"311\":1,\"314\":1}}],[\"readinto\",{\"1\":{\"115\":1}}],[\"readparcelable\",{\"1\":{\"313\":1}}],[\"readfile\",{\"1\":{\"382\":1}}],[\"readfields\",{\"1\":{\"306\":4}}],[\"readfloat\",{\"1\":{\"311\":1}}],[\"readlong\",{\"1\":{\"311\":1}}],[\"readandwriteobject2\",{\"1\":{\"309\":1}}],[\"readasbytes\",{\"1\":{\"110\":5,\"111\":8,\"201\":2}}],[\"readout\",{\"1\":{\"322\":1}}],[\"readordinaryobject\",{\"1\":{\"305\":2}}],[\"readobjectgraphcopymessage\",{\"1\":{\"389\":1}}],[\"readobject自己处理这些值的序列化\",{\"1\":{\"307\":1}}],[\"readobjectnodata方法主要用在序列化流和我们要反序列化的类不一致时初始化一些必要的状态\",{\"1\":{\"306\":1}}],[\"readobjectnodata\",{\"1\":{\"306\":2}}],[\"readobject0\",{\"1\":{\"305\":1}}],[\"readobject\",{\"1\":{\"305\":2,\"306\":2,\"308\":1,\"309\":2,\"311\":1}}],[\"readresolve\",{\"0\":{\"305\":1},\"1\":{\"305\":2}}],[\"reads\",{\"1\":{\"236\":1}}],[\"readsync\",{\"1\":{\"111\":2}}],[\"readbyte\",{\"1\":{\"115\":1}}],[\"readdatachunked\",{\"1\":{\"111\":2}}],[\"read\",{\"1\":{\"2\":2,\"111\":12,\"115\":2,\"272\":1,\"308\":1,\"322\":1,\"370\":1,\"371\":1,\"382\":1}}],[\"respositoy\",{\"1\":{\"417\":3}}],[\"respone\",{\"1\":{\"371\":3}}],[\"responsibility\",{\"1\":{\"196\":1}}],[\"responsible\",{\"1\":{\"100\":1}}],[\"responseport\",{\"1\":{\"376\":3}}],[\"response在上面的io\",{\"1\":{\"115\":1}}],[\"response\",{\"1\":{\"111\":9,\"115\":3,\"136\":3,\"211\":7,\"334\":4,\"362\":2,\"365\":7,\"370\":2,\"376\":4}}],[\"respect\",{\"1\":{\"384\":1}}],[\"restart\",{\"1\":{\"327\":2}}],[\"restricted\",{\"1\":{\"322\":2,\"378\":1}}],[\"restrictions\",{\"1\":{\"295\":1}}],[\"restorationid\",{\"1\":{\"213\":2,\"227\":2,\"235\":2}}],[\"restoring\",{\"1\":{\"180\":1}}],[\"restores\",{\"1\":{\"134\":1}}],[\"restoretocount\",{\"1\":{\"57\":1,\"65\":1}}],[\"restore\",{\"1\":{\"13\":2,\"65\":1}}],[\"resizeifneeded\",{\"1\":{\"188\":1}}],[\"resizeimage\",{\"1\":{\"188\":2}}],[\"resinfolist\",{\"1\":{\"2\":2}}],[\"resync\",{\"1\":{\"164\":1}}],[\"resumecapability多次pause\",{\"1\":{\"375\":1}}],[\"resumecapability\",{\"1\":{\"375\":5}}],[\"resume\",{\"1\":{\"180\":1,\"376\":1}}],[\"resumed\",{\"1\":{\"138\":1}}],[\"resultarr\",{\"1\":{\"459\":6}}],[\"resulting\",{\"1\":{\"328\":1,\"396\":1}}],[\"results\",{\"1\":{\"211\":8}}],[\"resultorlisteners\",{\"1\":{\"103\":2}}],[\"result>\",{\"1\":{\"80\":3}}],[\"result\",{\"1\":{\"13\":4,\"58\":5,\"65\":4,\"80\":16,\"96\":4,\"102\":5,\"103\":3,\"108\":4,\"110\":1,\"111\":9,\"112\":1,\"115\":28,\"116\":7,\"126\":2,\"135\":3,\"162\":2,\"178\":2,\"193\":8,\"198\":12,\"201\":7,\"207\":4,\"211\":10,\"216\":1,\"240\":4,\"296\":5,\"305\":1,\"322\":2,\"361\":1,\"377\":5,\"382\":12,\"383\":31,\"389\":16,\"391\":2,\"438\":2,\"453\":2,\"455\":9,\"456\":9,\"457\":8}}],[\"resetinitializing\",{\"1\":{\"382\":1}}],[\"resetactiveapicall\",{\"1\":{\"115\":1}}],[\"reset\",{\"1\":{\"109\":1,\"391\":1}}],[\"res\",{\"1\":{\"54\":2,\"56\":2,\"66\":3,\"79\":5,\"81\":2,\"272\":1,\"371\":3,\"400\":2,\"401\":4,\"421\":1}}],[\"resolution\",{\"0\":{\"278\":1},\"1\":{\"275\":1}}],[\"resolved\",{\"1\":{\"279\":1,\"382\":4,\"395\":1}}],[\"resolveclass\",{\"1\":{\"272\":1}}],[\"resolve方法时\",{\"1\":{\"196\":1}}],[\"resolve方法获取\",{\"1\":{\"196\":1}}],[\"resolve方法创建并更新imagestream\",{\"1\":{\"195\":1}}],[\"resolve方法创建并返回\",{\"1\":{\"188\":1}}],[\"resolve\",{\"1\":{\"190\":1,\"198\":2,\"209\":1,\"272\":2,\"378\":1,\"382\":1,\"389\":2,\"394\":1}}],[\"resolveimage\",{\"0\":{\"190\":1},\"1\":{\"190\":3,\"196\":1}}],[\"resolveinfo\",{\"1\":{\"2\":3}}],[\"resolvescript\",{\"1\":{\"382\":1}}],[\"resolvestreamforkey\",{\"1\":{\"202\":1}}],[\"resolvestreamforkey等一系列通用方法\",{\"1\":{\"201\":1}}],[\"resolvestreamforkey方法以使用指定的\",{\"1\":{\"202\":1}}],[\"resolvestreamforkey方法获取\",{\"1\":{\"197\":1}}],[\"resolvestreamforkey方法\",{\"1\":{\"196\":1}}],[\"resolvestreamforkey方法从\",{\"1\":{\"188\":1}}],[\"resolvesymboliclinks\",{\"1\":{\"115\":1}}],[\"resolver\",{\"1\":{\"188\":1}}],[\"resource也是通过反射获取到\",{\"1\":{\"427\":1}}],[\"resource目录下的文件读取\",{\"1\":{\"321\":1}}],[\"resource\",{\"1\":{\"211\":6,\"296\":1,\"349\":1}}],[\"resourceinfo\",{\"1\":{\"111\":4}}],[\"resourceid\",{\"1\":{\"53\":2}}],[\"resources>\",{\"1\":{\"56\":1}}],[\"resources\",{\"1\":{\"53\":8,\"81\":10,\"272\":1,\"376\":1,\"424\":1,\"427\":6}}],[\"resource=\",{\"1\":{\"2\":1,\"79\":1}}],[\"1和\",{\"1\":{\"460\":2}}],[\"1个数\",{\"1\":{\"459\":1}}],[\"1个元素都是无序的\",{\"1\":{\"289\":1}}],[\"1项移动到目标层\",{\"1\":{\"459\":1}}],[\"1项移动到过渡层\",{\"1\":{\"459\":1}}],[\"1项\",{\"1\":{\"459\":2}}],[\"1+2\",{\"1\":{\"453\":1}}],[\"1表示没有这样的点\",{\"1\":{\"438\":1}}],[\"1modules\",{\"1\":{\"413\":1}}],[\"1v8\",{\"1\":{\"413\":1}}],[\"1os\",{\"1\":{\"413\":1}}],[\"1a\",{\"1\":{\"344\":2}}],[\"1这样的语句\",{\"1\":{\"317\":1}}],[\"1l\",{\"1\":{\"304\":1,\"322\":3}}],[\"1月4日这一周\",{\"1\":{\"302\":1}}],[\"1次\",{\"1\":{\"289\":2}}],[\"1轮\",{\"1\":{\"289\":1}}],[\"1d44bcfa\",{\"1\":{\"272\":1}}],[\"1网格加载平均大小几mb的网络图片\",{\"1\":{\"198\":1}}],[\"183\",{\"1\":{\"458\":1}}],[\"183008\",{\"1\":{\"2\":1}}],[\"189\",{\"1\":{\"302\":1}}],[\"18b4aac2\",{\"1\":{\"272\":1}}],[\"18\",{\"1\":{\"115\":1,\"211\":1,\"299\":1,\"322\":2,\"417\":2}}],[\"1112l\",{\"1\":{\"369\":1}}],[\"11~14则就是步骤3执行网络请求的过程\",{\"1\":{\"362\":1}}],[\"11\",{\"1\":{\"115\":1,\"302\":1}}],[\"1176px\",{\"1\":{\"53\":1}}],[\"1176\",{\"1\":{\"53\":1}}],[\"1996\",{\"1\":{\"302\":1}}],[\"19\",{\"1\":{\"81\":1,\"115\":1,\"308\":1}}],[\"1访问本地网址\",{\"1\":{\"76\":1}}],[\"1的变化值\",{\"1\":{\"63\":1}}],[\"1f\",{\"1\":{\"63\":1}}],[\"17881581\",{\"1\":{\"273\":1}}],[\"17的说法\",{\"1\":{\"211\":1}}],[\"17\",{\"1\":{\"59\":1,\"95\":1,\"115\":1,\"211\":1,\"370\":1,\"372\":1}}],[\"1~99\",{\"1\":{\"41\":1}}],[\"1541\",{\"1\":{\"110\":1}}],[\"150dp\",{\"1\":{\"79\":1}}],[\"15807167\",{\"1\":{\"41\":1}}],[\"15\",{\"1\":{\"14\":1,\"115\":1,\"459\":1}}],[\"160\",{\"1\":{\"53\":5,\"81\":2}}],[\"160dpi\",{\"1\":{\"53\":1}}],[\"16\",{\"1\":{\"5\":1,\"81\":1,\"115\":3,\"280\":1,\"281\":1,\"282\":4,\"296\":3,\"398\":1}}],[\"137\",{\"1\":{\"458\":1}}],[\"136\",{\"1\":{\"53\":1}}],[\"130fdd755471\",{\"1\":{\"41\":1}}],[\"13\",{\"1\":{\"5\":1,\"56\":2,\"115\":1,\"458\":1,\"461\":1}}],[\"14316\",{\"1\":{\"413\":1}}],[\"14j\",{\"1\":{\"369\":1}}],[\"141\",{\"1\":{\"173\":3}}],[\"1440\",{\"1\":{\"53\":1}}],[\"1440px\",{\"1\":{\"53\":1}}],[\"14\",{\"1\":{\"5\":5,\"115\":1,\"369\":1}}],[\"14+\",{\"1\":{\"3\":1}}],[\"12permalink\",{\"1\":{\"417\":1}}],[\"12updated\",{\"1\":{\"417\":1}}],[\"123\",{\"1\":{\"349\":3}}],[\"123456\",{\"1\":{\"296\":1}}],[\"1256\",{\"1\":{\"327\":1}}],[\"128\",{\"1\":{\"285\":1,\"296\":2}}],[\"12193259\",{\"1\":{\"282\":1}}],[\"120\",{\"1\":{\"241\":2,\"242\":1}}],[\"12211553\",{\"1\":{\"58\":1}}],[\"12\",{\"1\":{\"5\":5,\"115\":1,\"274\":1,\"281\":1,\"283\":1,\"302\":19,\"308\":1,\"384\":1}}],[\"1\",{\"0\":{\"19\":1,\"71\":1,\"250\":1,\"256\":1,\"262\":1,\"418\":1},\"1\":{\"2\":2,\"10\":1,\"13\":3,\"14\":2,\"17\":1,\"20\":1,\"39\":1,\"43\":2,\"49\":4,\"53\":6,\"54\":2,\"55\":1,\"56\":2,\"57\":3,\"58\":2,\"63\":2,\"64\":4,\"65\":1,\"66\":3,\"69\":2,\"74\":1,\"81\":5,\"95\":3,\"100\":2,\"101\":7,\"105\":1,\"108\":4,\"109\":1,\"110\":1,\"111\":4,\"112\":2,\"115\":8,\"121\":2,\"122\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"131\":3,\"142\":1,\"144\":1,\"153\":1,\"161\":2,\"166\":3,\"167\":1,\"179\":3,\"181\":2,\"183\":1,\"184\":2,\"185\":1,\"186\":4,\"188\":1,\"192\":2,\"193\":1,\"196\":1,\"198\":2,\"201\":2,\"210\":2,\"211\":2,\"213\":1,\"220\":5,\"231\":3,\"250\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"272\":2,\"280\":5,\"281\":2,\"282\":2,\"283\":2,\"288\":5,\"289\":14,\"291\":1,\"294\":1,\"296\":4,\"299\":1,\"300\":1,\"302\":14,\"305\":2,\"309\":1,\"312\":1,\"318\":1,\"321\":3,\"322\":6,\"325\":1,\"326\":1,\"327\":12,\"328\":6,\"334\":3,\"336\":3,\"341\":3,\"344\":2,\"346\":6,\"347\":2,\"361\":1,\"362\":2,\"369\":9,\"370\":3,\"372\":1,\"373\":1,\"375\":1,\"376\":2,\"377\":2,\"378\":3,\"383\":1,\"388\":1,\"389\":4,\"390\":1,\"391\":1,\"394\":2,\"395\":2,\"396\":1,\"401\":1,\"407\":1,\"410\":1,\"413\":6,\"421\":1,\"428\":4,\"432\":1,\"433\":1,\"437\":3,\"438\":3,\"439\":1,\"440\":2,\"441\":2,\"450\":1,\"451\":5,\"453\":3,\"455\":5,\"456\":6,\"457\":3,\"459\":12,\"460\":1,\"461\":1,\"462\":12,\"467\":7}}],[\"10f\",{\"1\":{\"311\":1}}],[\"10l\",{\"1\":{\"311\":1}}],[\"102739636\",{\"1\":{\"283\":1,\"287\":1}}],[\"1024\",{\"1\":{\"111\":1}}],[\"100这些数\",{\"1\":{\"327\":1}}],[\"100l\",{\"1\":{\"308\":1}}],[\"100mb\",{\"1\":{\"197\":1}}],[\"100\",{\"1\":{\"65\":1,\"72\":1,\"130\":1,\"131\":1,\"170\":2,\"172\":1,\"173\":3,\"212\":1,\"327\":5,\"328\":1,\"334\":2,\"336\":2}}],[\"10000l\",{\"1\":{\"362\":2}}],[\"10000\",{\"1\":{\"63\":1}}],[\"1000~1999\",{\"1\":{\"41\":1}}],[\"1000\",{\"1\":{\"5\":1,\"11\":1,\"41\":1,\"327\":1,\"328\":1}}],[\"10dp\",{\"1\":{\"56\":1}}],[\"1080\",{\"1\":{\"53\":3}}],[\"1080px\",{\"1\":{\"53\":2}}],[\"10\",{\"1\":{\"2\":1,\"5\":1,\"115\":1,\"140\":1,\"143\":1,\"276\":1,\"282\":2,\"291\":3,\"302\":1,\"308\":1,\"314\":1,\"328\":1,\"334\":3,\"336\":1,\"379\":1,\"413\":2,\"417\":1,\"450\":1,\"459\":1}}],[\"本来按照case\",{\"1\":{\"458\":1}}],[\"本来是希望删除f\",{\"1\":{\"349\":1}}],[\"本质是将该节点a向下进一位插入到其右节点b原先的位置\",{\"1\":{\"458\":1}}],[\"本质上只是将controlport\",{\"1\":{\"378\":1}}],[\"本质上并没有在native层孵化一个新的isolate\",{\"1\":{\"373\":1}}],[\"本质上还是对\",{\"1\":{\"212\":1}}],[\"本质上还是更新了一个可以在多帧之间存活的state\",{\"1\":{\"134\":1}}],[\"本类也很重要\",{\"1\":{\"371\":1}}],[\"本路径用于备份post源文件到github\",{\"1\":{\"367\":1}}],[\"本次shell有效\",{\"1\":{\"360\":1}}],[\"本线程中threadlocal没有赋值\",{\"1\":{\"288\":1}}],[\"本hashmap实际保存的键值对个数\",{\"1\":{\"280\":1}}],[\"本笔记基于\",{\"1\":{\"249\":1}}],[\"本身不是挂起函数\",{\"1\":{\"327\":1}}],[\"本身不持有\",{\"1\":{\"229\":1}}],[\"本身是对\",{\"1\":{\"227\":1}}],[\"本身还提供了诸如图片缩放拖拽\",{\"1\":{\"202\":1}}],[\"本身的缓存外\",{\"1\":{\"201\":1}}],[\"本身并不会产生可以在屏幕上绘制的renderobject\",{\"1\":{\"127\":1}}],[\"本地hexo项目2的所有文件\",{\"1\":{\"406\":1}}],[\"本地hexo项目1的所有文件\",{\"1\":{\"406\":1}}],[\"本地hexo博客文章源文件路径\",{\"1\":{\"367\":1}}],[\"本地hexo博客输出路径\",{\"1\":{\"367\":1}}],[\"本地hexo博客路径\",{\"1\":{\"367\":1}}],[\"本地直接内存溢出\",{\"0\":{\"260\":1}}],[\"本地方法栈中jni引用的对象\",{\"1\":{\"263\":1}}],[\"本地方\",{\"1\":{\"249\":1}}],[\"本地资源不容易出现是因为从load到图片加载完成间隔比较短\",{\"1\":{\"198\":1}}],[\"本地资源\",{\"0\":{\"137\":1}}],[\"本地文件共享\",{\"1\":{\"40\":1}}],[\"本应该会重建colorfulcontainer\",{\"1\":{\"130\":1}}],[\"本应用正常运行需要相机权限\",{\"1\":{\"69\":1}}],[\"本例中传入fun2\",{\"1\":{\"322\":1}}],[\"本例中每一个枚举类值占用24\",{\"1\":{\"285\":1}}],[\"本例中就是用richtext创建了renderparagraph\",{\"1\":{\"127\":1}}],[\"本例中不涉及children\",{\"1\":{\"127\":1}}],[\"本例中\",{\"1\":{\"126\":1}}],[\"本例中center的child是text\",{\"1\":{\"126\":1}}],[\"本例中这里实际上获取到的是renderview\",{\"1\":{\"121\":1}}],[\"本方法只在api<26下有效\",{\"1\":{\"70\":1}}],[\"本方法会在服务创建ibinder对象的时候调用\",{\"1\":{\"58\":1}}],[\"本案例中是一张图片\",{\"1\":{\"55\":1}}],[\"本文汇总了数据结构的优缺点及应用场景\",{\"1\":{\"445\":1}}],[\"本文内容是根据我建立博客时的做法整理而成\",{\"1\":{\"419\":1}}],[\"本文参考这篇文章\",{\"1\":{\"405\":1}}],[\"本文中的大部分代码\",{\"1\":{\"399\":1}}],[\"本文中代码经二次处理\",{\"1\":{\"371\":1}}],[\"本文涉及源代码已上传github\",{\"1\":{\"371\":1}}],[\"本文即上述过程整理\",{\"1\":{\"371\":1}}],[\"本文只讲述实现部署多个hexo工程到同一github项目不同目录下需要注意的地方\",{\"1\":{\"405\":1}}],[\"本文只为学术研究\",{\"1\":{\"370\":1}}],[\"本文只对singlechildscrollview的源码实现做一简单分析\",{\"1\":{\"234\":1}}],[\"本文只对\",{\"1\":{\"212\":1}}],[\"本文是对dart官方vm的介绍的总结摘要\",{\"1\":{\"392\":1}}],[\"本文是对张鸿洋的okhttp辅助类okhttputils简要分析\",{\"1\":{\"362\":1}}],[\"本文是对此过程的梳理\",{\"1\":{\"3\":1}}],[\"本文不详细介绍\",{\"1\":{\"303\":1}}],[\"本文来简单分析一下为什么会出现这个情况\",{\"1\":{\"302\":1}}],[\"本文讲述如何自定义注解替换findviewbyid\",{\"1\":{\"298\":1}}],[\"本文对\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"本文对其原理和应用做一简单分析\",{\"1\":{\"169\":1}}],[\"本文对这二者的差异做一分析\",{\"1\":{\"131\":1}}],[\"本文对这两个类的实现进行分析比较\",{\"1\":{\"44\":1}}],[\"本文将对另外一种遵循\",{\"1\":{\"227\":1}}],[\"本文将对\",{\"1\":{\"146\":1}}],[\"本文讨论的正是几种多线程的情况下实现单例的方法\",{\"1\":{\"294\":1}}],[\"本文讨论的\",{\"1\":{\"146\":1,\"157\":1}}],[\"本文简单从widget\",{\"1\":{\"117\":1}}],[\"本文根据dart\",{\"1\":{\"95\":1}}],[\"本文基于python2\",{\"1\":{\"371\":1}}],[\"本文基于flutter\",{\"1\":{\"117\":1,\"141\":1}}],[\"本文基于dart\",{\"1\":{\"95\":1,\"372\":1}}],[\"本文基于android系统开篇\",{\"1\":{\"60\":1}}],[\"本文有关dagger\",{\"1\":{\"88\":1}}],[\"本文跟随官方文档实践一下dagger\",{\"1\":{\"88\":1}}],[\"本文介绍两种高级排序\",{\"1\":{\"460\":1}}],[\"本文介绍栈\",{\"1\":{\"452\":1}}],[\"本文介绍了递归\",{\"1\":{\"459\":1}}],[\"本文介绍了数组\",{\"1\":{\"450\":1}}],[\"本文介绍了二叉树\",{\"1\":{\"429\":1}}],[\"本文介绍了一个只需要更新markdown文档到github\",{\"1\":{\"405\":1}}],[\"本文介绍了java虚拟机类加载机制\",{\"1\":{\"273\":1}}],[\"本文介绍了android运行时权限的一些处理流程\",{\"1\":{\"67\":1}}],[\"本文介绍使用贝塞尔曲线绘制折线图\",{\"1\":{\"61\":1}}],[\"本文代码链接\",{\"1\":{\"61\":1}}],[\"本文为\",{\"1\":{\"272\":1}}],[\"本文为csdn博主\",{\"1\":{\"58\":1,\"288\":1}}],[\"本文为笔记性质\",{\"1\":{\"41\":1,\"327\":1}}],[\"本文实现的多渠道打包可实现不同渠道\",{\"1\":{\"54\":1}}],[\"本文主要参考flow中文文档\",{\"1\":{\"335\":1}}],[\"本文主要讨论android和java中实现序列化的4种方式\",{\"1\":{\"303\":1}}],[\"本文主要介绍aes的加密\",{\"1\":{\"296\":1}}],[\"本文主要记录java泛型一些比较特殊的知识点\",{\"1\":{\"290\":1}}],[\"本文主要记录一下flutter中两个重要的控件\",{\"1\":{\"132\":1}}],[\"本文主要对其加载缓存网络图片的流程做一分析\",{\"1\":{\"199\":1}}],[\"本文主要分析\",{\"1\":{\"157\":1}}],[\"本文主要是结合sunflower中的示例代码\",{\"1\":{\"399\":1}}],[\"本文主要是简单梳理dagger\",{\"1\":{\"82\":1}}],[\"本文主要是通过hook\",{\"1\":{\"70\":1}}],[\"本文主要简单分析其适配原理\",{\"1\":{\"53\":1}}],[\"本文主要探索一下messenger源码实现\",{\"1\":{\"43\":1}}],[\"本文以从相册中获取图片\",{\"1\":{\"2\":1}}],[\"本博客使用了大约五六年的主题是基于hexo的next主题\",{\"1\":{\"0\":1}}],[\"同一个局部变量\",{\"1\":{\"281\":1}}],[\"同一个页面\",{\"1\":{\"170\":1}}],[\"同一进程不同线程间\",{\"1\":{\"60\":1}}],[\"同样这样子比较n次就可以完成排序\",{\"1\":{\"456\":1}}],[\"同样是在构造函数中指定并创建\",{\"1\":{\"200\":1}}],[\"同样\",{\"1\":{\"126\":1}}],[\"同样要留出接口以便获取当前置顶的item对应的字母\",{\"1\":{\"64\":1}}],[\"同样先用二分法查找对应位置\",{\"1\":{\"47\":1}}],[\"同级\",{\"1\":{\"54\":1}}],[\"同步的目录下找到上次建好的项目yourname\",{\"1\":{\"419\":1}}],[\"同步的方法很多\",{\"1\":{\"419\":1}}],[\"同步到本地\",{\"1\":{\"419\":1}}],[\"同步到github上面删除这个分支\",{\"1\":{\"347\":1}}],[\"同步读取文件是对文件直接操作\",{\"1\":{\"111\":1}}],[\"同步读取文件\",{\"1\":{\"111\":1}}],[\"同步方法包括普通的方法\",{\"1\":{\"95\":1}}],[\"同步\",{\"1\":{\"53\":1}}],[\"同时可以访问其他apk的数据目录下的数据库和文件\",{\"1\":{\"421\":1}}],[\"同时可以从xml布局文件中获取itemdecoration的自定义属性\",{\"1\":{\"64\":1}}],[\"同时多了一个数据域<data\",{\"1\":{\"401\":1}}],[\"同时databinding还通过与adapter\",{\"1\":{\"399\":1}}],[\"同时由于初始化过程加锁\",{\"1\":{\"294\":1}}],[\"同时存在两份图片资源造成内存浪费\",{\"1\":{\"203\":1}}],[\"同时计算器过渡到\",{\"1\":{\"171\":1}}],[\"同时维护了\",{\"1\":{\"118\":1}}],[\"同时也是堆的最后一个节点\",{\"1\":{\"441\":1}}],[\"同时也是我的第一款游戏app\",{\"1\":{\"398\":1}}],[\"同时也会更新child\",{\"1\":{\"126\":1}}],[\"同时也知道了有一个构造方法来实例化service对象\",{\"1\":{\"83\":1}}],[\"同时也方便之后查阅\",{\"1\":{\"0\":1,\"398\":1}}],[\"同时enteralways也定义了\",{\"1\":{\"55\":1}}],[\"同时会开启flag\",{\"1\":{\"41\":1}}],[\"同时创建messagequeue对象\",{\"1\":{\"24\":1}}],[\"同时\",{\"1\":{\"2\":1,\"43\":1,\"334\":1,\"402\":1}}],[\"同时如果是开发android库\",{\"1\":{\"2\":1}}],[\"同理要给其余app分享文件也许要通过fileprovider生成uri并赋予对应的权限\",{\"1\":{\"2\":1}}],[\"或需要频繁插入删除元素时使用\",{\"1\":{\"445\":1}}],[\"或等于\",{\"1\":{\"439\":1}}],[\"或对应的左子节点\",{\"1\":{\"432\":2}}],[\"或fragment\",{\"1\":{\"402\":1}}],[\"或可能是单个\",{\"1\":{\"345\":1}}],[\"或已有key相同的值\",{\"1\":{\"280\":1}}],[\"或按照子级计算\",{\"1\":{\"233\":1}}],[\"或子级的\",{\"1\":{\"122\":1}}],[\"或静态方法\",{\"1\":{\"82\":1}}],[\"或setexact\",{\"1\":{\"3\":1}}],[\"或设备本身处于休眠状态\",{\"1\":{\"3\":1}}],[\"或间隔触发\",{\"1\":{\"3\":1}}],[\"或者栈已经空了\",{\"1\":{\"453\":1}}],[\"或者优先级比x高\",{\"1\":{\"453\":1}}],[\"或者叶子节点\",{\"1\":{\"441\":1}}],[\"或者指向了根节点\",{\"1\":{\"440\":1}}],[\"或者指向了根目录\",{\"1\":{\"440\":1}}],[\"或者邻接点已经被删除\",{\"1\":{\"438\":1}}],[\"或者左子树中最大的\",{\"1\":{\"432\":2}}],[\"或者你也可以直接自己在对应位置新建\",{\"1\":{\"417\":1}}],[\"或者你也可以到这里查看源码\",{\"1\":{\"94\":1}}],[\"或者也可以通过bundle或safe\",{\"1\":{\"400\":1}}],[\"或者也可以在这里找到\",{\"1\":{\"93\":1,\"94\":1}}],[\"或者adderrorlistener之类的监听\",{\"1\":{\"372\":1}}],[\"或者依次输入多个关键词参数\",{\"1\":{\"369\":1}}],[\"或者依次输入多个参数\",{\"1\":{\"369\":1}}],[\"或者直接定义这个变量\",{\"1\":{\"345\":1}}],[\"或者发送到\",{\"1\":{\"334\":1}}],[\"或者将它们暴露给用户\",{\"1\":{\"329\":1}}],[\"或者通过伴生对象\",{\"1\":{\"321\":1}}],[\"或者没有\",{\"1\":{\"321\":1}}],[\"或者没有越界内容\",{\"1\":{\"220\":1}}],[\"或者可以使用writeunshared方法\",{\"1\":{\"309\":1}}],[\"或者可以再订一个结束时间的闹钟\",{\"1\":{\"12\":1}}],[\"或者在当前环境外\",{\"1\":{\"396\":1}}],[\"或者在序列化的时候只处理部分变量\",{\"1\":{\"306\":1}}],[\"或者在gc时删除\",{\"1\":{\"287\":1}}],[\"或者是transient的\",{\"1\":{\"305\":1}}],[\"或者包含没有实现serializable接口的变量\",{\"1\":{\"303\":1}}],[\"或者notifyall\",{\"1\":{\"297\":1}}],[\"或者setinitialvalue\",{\"1\":{\"288\":1}}],[\"或者当前存储的数据总数size大于阈值threshold时才会扩容resize\",{\"1\":{\"280\":1}}],[\"或者为重写该方法\",{\"1\":{\"266\":1}}],[\"或者使用powerimage\",{\"1\":{\"204\":1}}],[\"或者使用系统默认操作\",{\"1\":{\"58\":1}}],[\"或者磁盘\",{\"1\":{\"198\":1}}],[\"或者已有缓存被清理\",{\"1\":{\"198\":1}}],[\"或者子类指定的途径\",{\"1\":{\"188\":1}}],[\"或者被inheritedwidget外层的widget\",{\"1\":{\"128\":1}}],[\"或者onloadfailed\",{\"1\":{\"211\":1}}],[\"或者onpostexecute\",{\"1\":{\"80\":1}}],[\"或者ontransact\",{\"1\":{\"39\":1}}],[\"或者view树内部view可见性发生变化就会被回调\",{\"1\":{\"65\":1}}],[\"或者重写了layout\",{\"1\":{\"65\":1}}],[\"或者打成aar文件供二者依赖\",{\"1\":{\"32\":1}}],[\"或者如intentservice本身就是等其子类\",{\"1\":{\"17\":1}}],[\"或者控件的上下中心\",{\"1\":{\"15\":1}}],[\"或者\",{\"1\":{\"2\":1,\"147\":1,\"152\":1,\"158\":2,\"181\":1,\"188\":1,\"197\":1,\"220\":2,\"223\":1,\"227\":1,\"228\":1,\"342\":1,\"418\":1,\"419\":1}}],[\"或\",{\"1\":{\"2\":1,\"166\":1,\"182\":1,\"329\":1,\"346\":1,\"399\":1}}],[\"及部分在线博客整理\",{\"1\":{\"249\":1}}],[\"及占位\",{\"1\":{\"176\":1}}],[\"及其应用\",{\"1\":{\"429\":1}}],[\"及其相关类\",{\"1\":{\"157\":1}}],[\"及其子类实现加载\",{\"1\":{\"233\":1}}],[\"及其子类可以实现对\",{\"1\":{\"233\":1}}],[\"及其子类定义了一个曲线\",{\"1\":{\"186\":1}}],[\"及其子类\",{\"1\":{\"147\":1,\"154\":1,\"212\":1,\"227\":1}}],[\"及\",{\"1\":{\"55\":2}}],[\"及以后时\",{\"1\":{\"2\":1}}],[\"及时总结\",{\"1\":{\"0\":1}}],[\"h+1\",{\"1\":{\"462\":1}}],[\"h=3\",{\"1\":{\"462\":1}}],[\"h=3h+1\",{\"1\":{\"461\":1}}],[\"hs\",{\"1\":{\"389\":1}}],[\"h以及runtime\",{\"1\":{\"372\":1}}],[\"h2\",{\"1\":{\"371\":1}}],[\"href\",{\"1\":{\"371\":1}}],[\"hist\",{\"1\":{\"358\":1}}],[\"hierarchies\",{\"1\":{\"322\":1}}],[\"high\",{\"1\":{\"296\":2}}],[\"hit\",{\"1\":{\"229\":1}}],[\"hittest\",{\"0\":{\"240\":1},\"1\":{\"240\":2}}],[\"hittestchildren\",{\"1\":{\"229\":1,\"240\":1}}],[\"hittestable\",{\"1\":{\"118\":1}}],[\"hint\",{\"1\":{\"228\":1}}],[\"hidden\",{\"1\":{\"180\":1,\"280\":1}}],[\"hide\",{\"1\":{\"43\":1,\"58\":1,\"80\":1}}],[\"h\",{\"1\":{\"114\":1,\"115\":5,\"280\":3,\"302\":2,\"309\":2,\"346\":1,\"350\":1,\"376\":1,\"389\":1,\"391\":1,\"462\":12}}],[\"hl=zh\",{\"1\":{\"43\":1,\"59\":1}}],[\"htm\",{\"1\":{\"347\":1}}],[\"htmlparser\",{\"1\":{\"371\":1}}],[\"htmldownloader\",{\"1\":{\"371\":2}}],[\"htmlhttps\",{\"1\":{\"63\":1}}],[\"html\",{\"1\":{\"58\":3,\"59\":1,\"61\":2,\"111\":1,\"274\":2,\"280\":1,\"281\":3,\"291\":1,\"295\":1,\"302\":2,\"306\":1,\"309\":1,\"314\":1,\"370\":8,\"371\":14,\"458\":1}}],[\"html滑动展示删除按钮https\",{\"1\":{\"41\":1}}],[\"https\",{\"1\":{\"2\":1,\"15\":2,\"35\":1,\"40\":1,\"41\":3,\"43\":1,\"54\":1,\"55\":1,\"58\":11,\"59\":5,\"61\":4,\"63\":1,\"95\":1,\"111\":3,\"115\":1,\"136\":1,\"137\":1,\"172\":1,\"180\":1,\"211\":2,\"274\":1,\"280\":1,\"281\":2,\"282\":2,\"283\":1,\"286\":3,\"287\":2,\"288\":1,\"291\":1,\"295\":1,\"302\":2,\"306\":2,\"308\":1,\"309\":1,\"314\":1,\"346\":1,\"347\":1,\"362\":1,\"372\":3,\"407\":1,\"417\":1,\"418\":1}}],[\"http\",{\"1\":{\"1\":1,\"13\":1,\"54\":1,\"56\":2,\"59\":1,\"66\":3,\"79\":3,\"108\":1,\"136\":2,\"273\":1,\"279\":1,\"294\":1,\"362\":2,\"364\":3,\"365\":2,\"367\":1,\"370\":2,\"371\":3,\"400\":3,\"401\":5,\"414\":2,\"417\":3,\"421\":1,\"458\":1}}],[\"half\",{\"1\":{\"459\":5}}],[\"had\",{\"1\":{\"198\":1,\"209\":1,\"216\":1}}],[\"hadunsatisfieddependencies\",{\"1\":{\"117\":1,\"122\":2,\"126\":1}}],[\"happens\",{\"1\":{\"383\":1}}],[\"happen\",{\"1\":{\"180\":1,\"216\":1,\"376\":1,\"378\":1}}],[\"having\",{\"1\":{\"180\":1,\"209\":1}}],[\"havedimensions\",{\"1\":{\"223\":2}}],[\"have\",{\"1\":{\"45\":1,\"49\":1,\"101\":1,\"102\":2,\"109\":1,\"112\":1,\"115\":4,\"121\":1,\"136\":1,\"153\":1,\"179\":1,\"180\":3,\"198\":2,\"209\":1,\"221\":1,\"226\":1,\"302\":2,\"322\":3,\"372\":1,\"378\":1,\"383\":3,\"390\":1,\"391\":9}}],[\"hasplantings\",{\"1\":{\"401\":2}}],[\"hasliveports\",{\"1\":{\"391\":1}}],[\"hasreadresolvemethod\",{\"1\":{\"305\":1}}],[\"hasfocus\",{\"1\":{\"227\":1,\"235\":1}}],[\"hasscrolled\",{\"1\":{\"237\":5}}],[\"hasscrolledbody\",{\"1\":{\"213\":1}}],[\"hassize\",{\"1\":{\"176\":1,\"180\":1,\"238\":3}}],[\"hasvisualoverflow\",{\"1\":{\"213\":1}}],[\"hasn\",{\"1\":{\"198\":1}}],[\"haserrorhandler\",{\"1\":{\"96\":2}}],[\"hasactivityinjector\",{\"0\":{\"92\":1},\"1\":{\"92\":1}}],[\"has\",{\"1\":{\"80\":1,\"100\":1,\"109\":1,\"111\":1,\"115\":1,\"134\":1,\"176\":1,\"179\":1,\"180\":1,\"196\":1,\"202\":1,\"211\":1,\"216\":1,\"308\":1,\"370\":1,\"372\":2,\"381\":2,\"383\":2,\"386\":1,\"389\":2,\"391\":1,\"392\":1}}],[\"hash表容器大小未知时\",{\"1\":{\"428\":1}}],[\"hash表有两种存储方式\",{\"1\":{\"428\":1}}],[\"hash表是一种可以快速插入和查找的数据结构\",{\"1\":{\"428\":1}}],[\"hash表\",{\"0\":{\"428\":1}}],[\"hash>>n\",{\"1\":{\"280\":1}}],[\"hashset\",{\"1\":{\"115\":1,\"117\":1,\"122\":2,\"126\":1}}],[\"hashcode计算扰动分析\",{\"1\":{\"280\":1}}],[\"hashcode\",{\"1\":{\"49\":1,\"130\":7,\"280\":1}}],[\"hash\",{\"1\":{\"49\":8,\"50\":1,\"280\":12,\"283\":3}}],[\"hashmap源码要点浅析\",{\"1\":{\"280\":1}}],[\"hashmap的删除涉及到数组\",{\"1\":{\"287\":1}}],[\"hashmap的数据是经过包装后保存在hashmap\",{\"1\":{\"287\":1}}],[\"hashmap的结构\",{\"1\":{\"280\":1}}],[\"hashmap的很多变量都被标记为transient\",{\"1\":{\"280\":1}}],[\"hashmap在jdk1\",{\"1\":{\"280\":1}}],[\"hashmap在writeobject\",{\"1\":{\"280\":1}}],[\"hashmap基于hash值保存数据\",{\"1\":{\"280\":1}}],[\"hashmap修改的次数\",{\"1\":{\"280\":1}}],[\"hashmap使用由node<k\",{\"1\":{\"280\":1}}],[\"hashmap<k\",{\"1\":{\"287\":1}}],[\"hashmap<>\",{\"1\":{\"211\":1}}],[\"hashmap<int\",{\"1\":{\"111\":2,\"112\":3}}],[\"hashmap与sparearray及其衍生类对应关系\",{\"0\":{\"49\":1}}],[\"hashmap存储键值对会占用比较多的内存控件\",{\"1\":{\"44\":1}}],[\"hashmap\",{\"0\":{\"287\":1},\"1\":{\"33\":1,\"280\":2,\"287\":2,\"437\":6,\"438\":11}}],[\"haniotower\",{\"1\":{\"459\":3}}],[\"haniostepnum++\",{\"1\":{\"459\":2}}],[\"haniostepnum\",{\"1\":{\"459\":1}}],[\"hand\",{\"1\":{\"386\":1}}],[\"handing\",{\"1\":{\"115\":1}}],[\"handling\",{\"1\":{\"108\":1,\"376\":1,\"378\":1,\"391\":2}}],[\"handlingcallbacks\",{\"1\":{\"108\":1,\"109\":2}}],[\"handle对应我们在dart中isolate\",{\"1\":{\"379\":1}}],[\"handlescope\",{\"1\":{\"383\":1,\"389\":2}}],[\"handles\",{\"1\":{\"305\":2,\"309\":2,\"383\":1,\"389\":1}}],[\"handlesemanticsaction\",{\"1\":{\"118\":1}}],[\"handlesemanticsenabledchanged\",{\"1\":{\"118\":2}}],[\"handlesemanticsownerdisposed\",{\"1\":{\"118\":1}}],[\"handlesemanticsownercreated\",{\"1\":{\"118\":1}}],[\"handlehasscrolledbodychanged\",{\"1\":{\"213\":1}}],[\"handleimagechunk\",{\"1\":{\"191\":1}}],[\"handleimageframe\",{\"0\":{\"192\":1},\"1\":{\"191\":1,\"192\":2}}],[\"handleflightended\",{\"1\":{\"180\":2}}],[\"handlechange\",{\"1\":{\"155\":5}}],[\"handlecallback\",{\"1\":{\"29\":1}}],[\"handleanimationchanged\",{\"1\":{\"152\":2}}],[\"handleuncaughterror\",{\"1\":{\"144\":1}}],[\"handlewebfirstframe\",{\"1\":{\"118\":1}}],[\"handlepersistentframecallback\",{\"1\":{\"118\":1}}],[\"handleplatformbrightnesschanged\",{\"1\":{\"118\":1}}],[\"handletable\",{\"1\":{\"309\":1}}],[\"handletextscalefactorchanged\",{\"1\":{\"118\":1}}],[\"handletimeout\",{\"1\":{\"108\":1}}],[\"handlemetricschanged\",{\"1\":{\"118\":1}}],[\"handlemessages方法\",{\"1\":{\"391\":1}}],[\"handlemessages\",{\"1\":{\"391\":6}}],[\"handlemessage中按照msg的类型取出对应的pendingtimers然后再\",{\"1\":{\"109\":1}}],[\"handlemessage处理消息\",{\"1\":{\"109\":1}}],[\"handlemessage方法在\",{\"1\":{\"109\":1}}],[\"handlemessage方法处理消息\",{\"1\":{\"108\":1}}],[\"handlemessage方法\",{\"1\":{\"106\":1}}],[\"handlemessage方法中\",{\"1\":{\"101\":1}}],[\"handlemessage\",{\"0\":{\"109\":1},\"1\":{\"20\":3,\"29\":3,\"43\":2,\"72\":2,\"80\":1,\"101\":1,\"106\":3,\"107\":1,\"109\":1,\"389\":1,\"391\":1}}],[\"handle也就是sendport\",{\"1\":{\"114\":1}}],[\"handleevents通过\",{\"1\":{\"108\":1}}],[\"handleerror\",{\"1\":{\"102\":3,\"196\":1,\"202\":3}}],[\"handle\",{\"1\":{\"100\":5,\"101\":1,\"102\":2,\"103\":1,\"108\":8,\"114\":5,\"115\":2,\"116\":2,\"194\":1,\"211\":3,\"213\":2,\"309\":4,\"376\":2,\"377\":4,\"379\":1,\"382\":1,\"383\":9,\"384\":2,\"389\":19,\"391\":3}}],[\"handlelaunchactivity\",{\"1\":{\"72\":2}}],[\"handlebindservice\",{\"1\":{\"58\":2}}],[\"handler处理消息分发\",{\"1\":{\"391\":1}}],[\"handlerequest方法内部通过请求的imagetype找到\",{\"1\":{\"211\":1}}],[\"handlerequest方法获取图片\",{\"1\":{\"211\":1}}],[\"handlerequest\",{\"1\":{\"211\":8}}],[\"handlerimagestreamcompleterhandle\",{\"1\":{\"197\":1}}],[\"handler回调事件\",{\"1\":{\"116\":1}}],[\"handler是当这个dart\",{\"1\":{\"115\":1}}],[\"handler方法中根据当时请求的id找到completer将结果传递回去\",{\"1\":{\"111\":1}}],[\"handler或者关闭timerhandler\",{\"1\":{\"109\":1}}],[\"handlers\",{\"1\":{\"102\":1,\"129\":1,\"391\":1}}],[\"handlerthread\",{\"1\":{\"80\":1}}],[\"handler在指定的时间唤起isolate\",{\"1\":{\"108\":1}}],[\"handler在\",{\"1\":{\"31\":1}}],[\"handler的io线程通过isolate中的messagehandler来执行任务\",{\"1\":{\"109\":1}}],[\"handler的子线程中通过异步io执行任务\",{\"1\":{\"108\":1}}],[\"handler的handlemessage\",{\"1\":{\"29\":1}}],[\"handler的dispatchmessage\",{\"1\":{\"29\":1}}],[\"handler指定的回调方法\",{\"1\":{\"29\":1}}],[\"handler构造方法会获取到mlooper和mqueue以及mcallback\",{\"1\":{\"28\":1}}],[\"handler\",{\"0\":{\"22\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1},\"1\":{\"20\":2,\"22\":1,\"28\":1,\"30\":1,\"31\":1,\"43\":5,\"60\":2,\"72\":7,\"80\":4,\"101\":6,\"102\":1,\"103\":1,\"106\":4,\"108\":4,\"109\":1,\"111\":2,\"112\":2,\"115\":27,\"376\":2,\"378\":1,\"383\":10,\"389\":7,\"391\":27}}],[\"handledragupdate\",{\"1\":{\"226\":1}}],[\"handledragstart\",{\"1\":{\"226\":2}}],[\"handled\",{\"1\":{\"13\":3,\"378\":1,\"391\":1,\"392\":1}}],[\"handed\",{\"1\":{\"75\":1,\"196\":1}}],[\"hanlder\",{\"1\":{\"20\":1}}],[\"hanyongbai\",{\"1\":{\"15\":2}}],[\"hot\",{\"1\":{\"392\":1,\"396\":1}}],[\"hotspot\",{\"1\":{\"253\":1,\"255\":1}}],[\"host\",{\"1\":{\"387\":1}}],[\"horizontal的\",{\"1\":{\"228\":1}}],[\"horizontal\",{\"1\":{\"131\":1,\"238\":3}}],[\"how\",{\"1\":{\"102\":1,\"127\":1,\"326\":1,\"396\":1}}],[\"holds\",{\"1\":{\"280\":1}}],[\"holder\",{\"1\":{\"211\":2}}],[\"holding\",{\"1\":{\"111\":1,\"112\":1,\"391\":1}}],[\"hold\",{\"1\":{\"100\":1,\"111\":1,\"112\":1,\"115\":1,\"212\":1,\"223\":1,\"225\":1}}],[\"hook\",{\"1\":{\"115\":2}}],[\"hook技术之activity的启动过程拦截\",{\"1\":{\"72\":1}}],[\"hookiactivitymanagerservice\",{\"1\":{\"72\":2}}],[\"hooksingleton\",{\"1\":{\"72\":2}}],[\"hookhandle\",{\"1\":{\"71\":1,\"72\":2}}],[\"hookactivitymanagernative\",{\"1\":{\"72\":2}}],[\"hookams\",{\"1\":{\"71\":1,\"72\":2}}],[\"hookapplication\",{\"1\":{\"71\":2}}],[\"hook的过程是通过反射\",{\"1\":{\"70\":1}}],[\"hook是钩子的意思\",{\"1\":{\"70\":1}}],[\"hoyouly\",{\"1\":{\"59\":1}}],[\"hour\",{\"1\":{\"10\":1,\"285\":2,\"302\":5}}],[\"home=\",{\"1\":{\"348\":1}}],[\"homescreen\",{\"1\":{\"79\":1}}],[\"home\",{\"1\":{\"1\":1,\"131\":1,\"132\":1,\"143\":1,\"272\":2,\"347\":1,\"349\":1,\"369\":2}}],[\"hexstr\",{\"1\":{\"296\":6}}],[\"hex\",{\"1\":{\"296\":5}}],[\"hexo+github=blog\",{\"0\":{\"408\":1}}],[\"hexo遇上travis\",{\"1\":{\"407\":1}}],[\"hexo分支的结构\",{\"0\":{\"406\":1}}],[\"hexo\",{\"0\":{\"413\":1,\"414\":1,\"416\":1},\"1\":{\"243\":2,\"245\":1,\"246\":1,\"247\":1,\"248\":1,\"367\":7,\"406\":2,\"407\":4,\"413\":5,\"414\":8,\"415\":1,\"416\":3,\"417\":3,\"418\":4,\"419\":4}}],[\"headarray是保存堆元素的数组\",{\"1\":{\"440\":1}}],[\"headarray\",{\"1\":{\"440\":5,\"441\":16}}],[\"heading\",{\"1\":{\"225\":1}}],[\"head\",{\"0\":{\"250\":1},\"1\":{\"198\":1}}],[\"header是否悬浮\",{\"1\":{\"224\":1}}],[\"header+body\",{\"1\":{\"213\":2}}],[\"header部分\",{\"1\":{\"213\":1}}],[\"header\",{\"1\":{\"212\":12,\"213\":11,\"223\":2,\"226\":9,\"227\":1,\"370\":2}}],[\"header等一致的话才会被认为命中缓存\",{\"1\":{\"196\":1}}],[\"headersliverbuilder\",{\"1\":{\"212\":2,\"213\":4,\"226\":1}}],[\"headers\",{\"1\":{\"188\":2,\"196\":1,\"201\":1,\"364\":5}}],[\"heap等\",{\"1\":{\"383\":1}}],[\"heap区\",{\"1\":{\"249\":1}}],[\"heap区和非heap区\",{\"1\":{\"249\":1}}],[\"heap中第一个\",{\"1\":{\"108\":1}}],[\"heap中\",{\"1\":{\"106\":1,\"108\":1}}],[\"heap\",{\"1\":{\"106\":4,\"108\":3,\"109\":1,\"116\":2,\"136\":1,\"396\":1}}],[\"heroopacity\",{\"1\":{\"181\":1}}],[\"herorecttween\",{\"1\":{\"181\":2}}],[\"heroflight>\",{\"1\":{\"178\":2}}],[\"heroflightdirection\",{\"1\":{\"177\":1,\"179\":4,\"180\":2,\"181\":5}}],[\"heroflightmanifest\",{\"0\":{\"177\":1},\"1\":{\"176\":1,\"177\":4,\"180\":2,\"181\":2}}],[\"heroflight\",{\"0\":{\"181\":1},\"1\":{\"176\":1,\"180\":3,\"181\":6}}],[\"herostate\",{\"0\":{\"176\":1},\"1\":{\"176\":2,\"177\":1,\"180\":3,\"181\":2}}],[\"herostate>\",{\"1\":{\"175\":1,\"180\":5}}],[\"herocontrollerscope\",{\"1\":{\"178\":2,\"181\":1}}],[\"herocontroller传给herocontrollerscope\",{\"1\":{\"178\":1}}],[\"herocontroller\",{\"0\":{\"178\":1},\"1\":{\"175\":1,\"176\":1,\"178\":15,\"179\":2,\"181\":2}}],[\"heroclippedchildwidget\",{\"1\":{\"172\":4,\"173\":5}}],[\"herochildwidget\",{\"1\":{\"170\":3,\"172\":1}}],[\"hero动画进行中的图解\",{\"1\":{\"171\":1}}],[\"herotag\",{\"1\":{\"170\":2}}],[\"heroes\",{\"1\":{\"170\":1,\"179\":1,\"180\":1}}],[\"hero\",{\"0\":{\"170\":1,\"172\":1,\"175\":1},\"1\":{\"169\":1,\"170\":19,\"171\":17,\"172\":11,\"173\":5,\"174\":5,\"175\":5,\"176\":8,\"177\":2,\"178\":2,\"179\":1,\"180\":7,\"181\":10}}],[\"here\",{\"1\":{\"34\":1,\"49\":1,\"58\":1,\"111\":1,\"112\":1,\"115\":2,\"198\":2,\"383\":3,\"391\":3}}],[\"hencoder\",{\"1\":{\"57\":4}}],[\"heightconstraints\",{\"1\":{\"238\":1}}],[\"heightfactor\",{\"1\":{\"117\":2,\"122\":9,\"125\":2}}],[\"heightpixels\",{\"1\":{\"81\":2}}],[\"height的大小\",{\"1\":{\"65\":1}}],[\"heightmeasurespec\",{\"1\":{\"65\":5}}],[\"height=\",{\"1\":{\"56\":2,\"66\":2,\"79\":5,\"400\":1,\"401\":1}}],[\"height=2033\",{\"1\":{\"53\":2}}],[\"height\",{\"1\":{\"53\":1,\"57\":1,\"64\":3,\"81\":1,\"130\":1,\"131\":2,\"172\":3,\"176\":4,\"190\":2,\"192\":1,\"193\":2,\"195\":1,\"206\":9,\"207\":2,\"210\":12,\"211\":5,\"212\":2,\"234\":1,\"238\":3,\"239\":2,\"241\":6,\"242\":4}}],[\"heic\",{\"1\":{\"2\":1}}],[\"held\",{\"1\":{\"391\":1}}],[\"hello\",{\"0\":{\"243\":1},\"1\":{\"43\":1,\"79\":2,\"95\":6,\"101\":4,\"117\":5,\"125\":1,\"130\":1,\"212\":1,\"254\":1,\"272\":3,\"301\":1,\"324\":3,\"325\":4,\"373\":1,\"408\":1}}],[\"helper兜底\",{\"1\":{\"395\":1}}],[\"helper\",{\"1\":{\"387\":1}}],[\"help\",{\"1\":{\"3\":1,\"416\":1}}],[\"ect\",{\"1\":{\"361\":1}}],[\"echo\",{\"1\":{\"358\":1}}],[\"eu\",{\"1\":{\"321\":1}}],[\"europe\",{\"1\":{\"127\":1}}],[\"era\",{\"1\":{\"302\":1}}],[\"err\",{\"1\":{\"453\":1}}],[\"errmsg\",{\"1\":{\"211\":1}}],[\"errno\",{\"1\":{\"115\":2}}],[\"errorptr\",{\"1\":{\"383\":1}}],[\"errorcallbacksamplingrate\",{\"1\":{\"211\":2}}],[\"errorcallback\",{\"1\":{\"211\":2}}],[\"errorbuilder\",{\"1\":{\"191\":1,\"193\":2,\"205\":1,\"206\":2,\"207\":2}}],[\"errordetails\",{\"1\":{\"143\":4}}],[\"errordetails在release模式下为空\",{\"1\":{\"143\":1}}],[\"errorwidgetbuilder\",{\"1\":{\"205\":2}}],[\"errorwidget\",{\"0\":{\"143\":1},\"1\":{\"126\":1,\"143\":1}}],[\"errorsarefatal\",{\"1\":{\"378\":8}}],[\"errors\",{\"1\":{\"101\":1,\"102\":2,\"114\":1,\"379\":1,\"384\":1,\"389\":2}}],[\"error\",{\"1\":{\"95\":4,\"100\":1,\"102\":20,\"103\":2,\"108\":1,\"111\":5,\"112\":2,\"114\":1,\"143\":4,\"145\":1,\"191\":1,\"196\":1,\"198\":1,\"201\":1,\"281\":2,\"293\":1,\"369\":1,\"376\":5,\"378\":4,\"379\":1,\"381\":9,\"382\":3,\"383\":28,\"384\":4,\"386\":4,\"387\":11,\"388\":2,\"389\":16,\"391\":8}}],[\"estr\",{\"1\":{\"296\":2}}],[\"efficient\",{\"1\":{\"287\":1}}],[\"effectively\",{\"1\":{\"281\":2,\"391\":1}}],[\"effectivetextstyle\",{\"1\":{\"126\":5}}],[\"effects\",{\"1\":{\"227\":1,\"233\":1}}],[\"equivalent\",{\"1\":{\"220\":1}}],[\"equals\",{\"1\":{\"49\":3,\"64\":1,\"72\":1,\"211\":4,\"422\":2}}],[\"eden\",{\"1\":{\"249\":1,\"250\":1}}],[\"edge\",{\"1\":{\"202\":1}}],[\"edgeinsetsgeometry\",{\"1\":{\"152\":2}}],[\"edgeinsetsgeometrytween\",{\"1\":{\"152\":3}}],[\"edgeinsets\",{\"1\":{\"140\":1,\"143\":1,\"152\":1}}],[\"edit\",{\"1\":{\"69\":1}}],[\"edittext\",{\"1\":{\"56\":1}}],[\"either\",{\"1\":{\"115\":1,\"180\":1,\"181\":1,\"225\":1,\"281\":1,\"389\":1,\"391\":1}}],[\"easier\",{\"1\":{\"378\":1}}],[\"easylist\",{\"1\":{\"132\":1}}],[\"ea\",{\"1\":{\"282\":2}}],[\"earlier\",{\"1\":{\"109\":1}}],[\"earliest\",{\"1\":{\"109\":1,\"302\":1}}],[\"early\",{\"1\":{\"105\":1}}],[\"eager\",{\"1\":{\"396\":1}}],[\"eagerly\",{\"1\":{\"102\":1}}],[\"eagererror\",{\"1\":{\"102\":6}}],[\"each\",{\"1\":{\"102\":1,\"106\":1,\"107\":1,\"111\":1,\"112\":1,\"278\":1,\"287\":1,\"322\":1,\"396\":1}}],[\"e点时\",{\"1\":{\"61\":1}}],[\"emissions\",{\"1\":{\"327\":1}}],[\"emitted\",{\"1\":{\"327\":1}}],[\"emitter\",{\"1\":{\"327\":1}}],[\"emitting\",{\"1\":{\"327\":1,\"341\":1}}],[\"emit\",{\"1\":{\"327\":7,\"336\":1,\"341\":2}}],[\"empty\",{\"1\":{\"282\":1,\"389\":1}}],[\"embedder\",{\"1\":{\"100\":1,\"105\":1,\"115\":2,\"381\":1,\"386\":1}}],[\"email\",{\"1\":{\"35\":1,\"36\":1,\"81\":1,\"308\":1,\"347\":3,\"407\":1}}],[\"emulated\",{\"1\":{\"2\":1}}],[\"e\",{\"0\":{\"45\":1,\"46\":1},\"1\":{\"15\":1,\"35\":6,\"36\":4,\"43\":2,\"45\":1,\"46\":4,\"48\":1,\"72\":4,\"78\":3,\"96\":2,\"102\":5,\"126\":2,\"142\":2,\"147\":1,\"201\":4,\"209\":1,\"211\":3,\"212\":2,\"220\":1,\"272\":1,\"296\":2,\"300\":2,\"302\":1,\"306\":6,\"308\":6,\"309\":6,\"321\":1,\"328\":2,\"341\":3,\"346\":1,\"362\":1,\"365\":4,\"370\":2,\"373\":1,\"376\":1,\"378\":3,\"383\":1,\"392\":1,\"453\":4}}],[\"evict\",{\"1\":{\"209\":2}}],[\"evict方法从缓存中清除指定图片\",{\"1\":{\"197\":1}}],[\"evaluatable\",{\"1\":{\"183\":7}}],[\"evaluatable属性创建了\",{\"1\":{\"183\":1}}],[\"evaluate\",{\"1\":{\"148\":1,\"152\":1,\"153\":1,\"181\":1,\"182\":1,\"183\":3}}],[\"everything\",{\"1\":{\"177\":1,\"316\":1}}],[\"every\",{\"1\":{\"106\":1,\"147\":1,\"156\":1,\"314\":1,\"327\":3,\"391\":1,\"396\":1}}],[\"even\",{\"1\":{\"98\":1,\"391\":1}}],[\"eventname\",{\"1\":{\"211\":8}}],[\"eventchannel\",{\"1\":{\"211\":10}}],[\"event消息\",{\"1\":{\"109\":1}}],[\"events\",{\"1\":{\"106\":1,\"115\":5,\"391\":1}}],[\"eventhandlers\",{\"1\":{\"211\":5}}],[\"eventhandlersenddata\",{\"1\":{\"106\":1,\"108\":3}}],[\"eventhandlerimplementation\",{\"1\":{\"108\":2}}],[\"eventhandler\",{\"1\":{\"106\":1,\"107\":1,\"108\":13,\"211\":9}}],[\"event事件\",{\"1\":{\"106\":1}}],[\"event\",{\"0\":{\"95\":1},\"1\":{\"13\":20,\"41\":4,\"64\":1,\"95\":3,\"97\":1,\"98\":2,\"100\":1,\"106\":5,\"107\":4,\"108\":5,\"109\":5,\"129\":1,\"136\":1,\"141\":1,\"211\":8,\"372\":1,\"375\":1,\"387\":1}}],[\"ev\",{\"1\":{\"13\":19}}],[\"elf\",{\"1\":{\"387\":2}}],[\"elif\",{\"1\":{\"369\":1,\"387\":1}}],[\"elapse\",{\"1\":{\"110\":1}}],[\"elapsedinseconds\",{\"1\":{\"163\":4}}],[\"elapsedrealtime\",{\"1\":{\"11\":1}}],[\"elapsed\",{\"1\":{\"4\":2,\"11\":1,\"163\":3}}],[\"elye的dagger\",{\"1\":{\"87\":1}}],[\"elementtype\",{\"1\":{\"299\":1}}],[\"element代表在树中详细的位置\",{\"1\":{\"128\":1}}],[\"elements\",{\"1\":{\"127\":1,\"328\":1}}],[\"element的performrebuild\",{\"1\":{\"128\":1}}],[\"element的inflatewidget方法\",{\"1\":{\"122\":1}}],[\"element的方法\",{\"1\":{\"121\":1}}],[\"elementlifecycle\",{\"1\":{\"117\":1,\"121\":1,\"122\":2,\"126\":1}}],[\"element\",{\"1\":{\"45\":2,\"80\":1,\"95\":1,\"98\":1,\"117\":2,\"119\":1,\"120\":1,\"121\":14,\"122\":1,\"125\":2,\"126\":8,\"127\":7,\"128\":6,\"275\":1,\"401\":1}}],[\"else\",{\"1\":{\"2\":1,\"13\":8,\"29\":1,\"45\":1,\"46\":1,\"63\":1,\"64\":2,\"65\":1,\"69\":4,\"78\":2,\"80\":1,\"81\":3,\"96\":1,\"97\":1,\"102\":5,\"103\":2,\"106\":3,\"108\":2,\"109\":2,\"111\":1,\"115\":2,\"121\":1,\"149\":1,\"166\":2,\"167\":1,\"179\":1,\"180\":2,\"198\":2,\"201\":3,\"202\":1,\"205\":1,\"207\":1,\"211\":12,\"223\":1,\"225\":1,\"226\":2,\"227\":1,\"238\":1,\"239\":1,\"272\":2,\"288\":2,\"289\":1,\"297\":1,\"305\":1,\"309\":3,\"312\":5,\"322\":1,\"369\":1,\"378\":2,\"380\":1,\"382\":1,\"383\":5,\"386\":1,\"387\":6,\"389\":1,\"391\":4,\"401\":1,\"432\":9,\"437\":1,\"438\":2,\"441\":5,\"451\":1,\"453\":8,\"457\":1,\"459\":4,\"462\":1}}],[\"encounter\",{\"1\":{\"391\":1}}],[\"encounters\",{\"1\":{\"391\":1}}],[\"encountered\",{\"1\":{\"378\":1,\"383\":1,\"391\":1}}],[\"encodedkey\",{\"1\":{\"296\":2}}],[\"encode\",{\"1\":{\"211\":1}}],[\"encoderequests\",{\"1\":{\"211\":2}}],[\"encoding=\",{\"1\":{\"2\":1,\"56\":2,\"66\":1,\"401\":1,\"421\":1}}],[\"encryption\",{\"1\":{\"306\":3}}],[\"encrypt\",{\"1\":{\"296\":2}}],[\"enum<\",{\"1\":{\"312\":1}}],[\"enum<e>>\",{\"1\":{\"285\":1}}],[\"enum<e\",{\"1\":{\"285\":1}}],[\"enum<enumclazz>\",{\"1\":{\"285\":1}}],[\"enum声明\",{\"1\":{\"298\":1}}],[\"enum类型\",{\"1\":{\"299\":1}}],[\"enum类\",{\"1\":{\"285\":1}}],[\"enum类的每个值实际上都继承自java\",{\"1\":{\"285\":1}}],[\"enumclasssize\",{\"1\":{\"285\":2}}],[\"enumclazz\",{\"1\":{\"285\":10}}],[\"enum\",{\"1\":{\"285\":1,\"286\":1,\"294\":2,\"305\":1,\"312\":1,\"321\":3,\"322\":3}}],[\"enableoverride\",{\"1\":{\"309\":1}}],[\"enable\",{\"1\":{\"186\":1}}],[\"enables\",{\"1\":{\"125\":1}}],[\"enabled\",{\"1\":{\"115\":1,\"176\":1,\"198\":1}}],[\"enabled=\",{\"1\":{\"36\":1}}],[\"engine的粘合剂\",{\"1\":{\"127\":1}}],[\"engine\",{\"1\":{\"111\":1,\"118\":1,\"119\":1}}],[\"en\",{\"1\":{\"110\":1,\"302\":1,\"438\":1}}],[\"enqueueentrypointinvocationandnotifyspawner\",{\"1\":{\"389\":3}}],[\"enqueued\",{\"1\":{\"106\":1,\"109\":1}}],[\"enqueue方法把timer放入到相应的队列中\",{\"1\":{\"105\":1}}],[\"enqueue\",{\"0\":{\"106\":1},\"1\":{\"105\":2,\"106\":4,\"107\":1,\"109\":3,\"115\":1,\"362\":1,\"365\":1,\"389\":2,\"390\":1}}],[\"enqueuemessage\",{\"1\":{\"28\":1}}],[\"enqueuemessage方法\",{\"1\":{\"28\":1}}],[\"ensureisrunnable\",{\"1\":{\"389\":1}}],[\"ensureinitialized方法中\",{\"1\":{\"118\":1}}],[\"ensureinitialized\",{\"0\":{\"118\":1},\"1\":{\"117\":1,\"118\":1}}],[\"ensureinitialize\",{\"1\":{\"111\":2,\"112\":3}}],[\"ensureactive\",{\"1\":{\"342\":1}}],[\"ensures\",{\"1\":{\"276\":1,\"389\":1}}],[\"ensurescheduleimmediate\",{\"1\":{\"99\":1,\"100\":2}}],[\"ensurevisualupdate\",{\"1\":{\"118\":1,\"119\":1}}],[\"ensure\",{\"1\":{\"80\":1,\"102\":2,\"111\":1,\"115\":3,\"376\":1,\"383\":2}}],[\"entire\",{\"1\":{\"426\":1}}],[\"entity中的数据的操作\",{\"1\":{\"403\":1}}],[\"entity\",{\"1\":{\"399\":1,\"403\":1}}],[\"enteranim等指定执行action时的动画\",{\"1\":{\"400\":1}}],[\"enteranim=\",{\"1\":{\"400\":1}}],[\"enteralwayscollapsed\",{\"1\":{\"55\":1}}],[\"enteralways\",{\"1\":{\"55\":1}}],[\"enterisolate\",{\"1\":{\"383\":1,\"386\":1}}],[\"enterscope\",{\"1\":{\"382\":1}}],[\"entered\",{\"1\":{\"220\":1,\"383\":1}}],[\"enter\",{\"1\":{\"220\":1,\"383\":2,\"391\":1}}],[\"entropysource\",{\"1\":{\"382\":1}}],[\"entropy\",{\"1\":{\"382\":1}}],[\"entrant\",{\"1\":{\"198\":1}}],[\"entries\",{\"1\":{\"49\":1,\"180\":2}}],[\"entrypoint\",{\"1\":{\"373\":1,\"378\":6,\"389\":9}}],[\"entry对threadlocal是弱引用\",{\"1\":{\"288\":1}}],[\"entryset\",{\"1\":{\"280\":2,\"287\":1}}],[\"entry<k\",{\"1\":{\"280\":3,\"287\":1}}],[\"entry访问\",{\"1\":{\"115\":1}}],[\"entry\",{\"1\":{\"49\":2,\"59\":1,\"96\":1,\"98\":5,\"99\":2,\"100\":1,\"101\":3,\"105\":1,\"108\":1,\"111\":2,\"115\":11,\"198\":2,\"280\":1,\"287\":1,\"288\":5,\"314\":1,\"376\":1,\"377\":2,\"379\":1,\"384\":1,\"389\":6,\"396\":1}}],[\"endblockdata\",{\"1\":{\"312\":1}}],[\"endblockdata等等类型\",{\"1\":{\"305\":1}}],[\"ending\",{\"1\":{\"184\":1}}],[\"endif\",{\"1\":{\"115\":2,\"383\":11,\"387\":5,\"391\":2}}],[\"endflight\",{\"1\":{\"176\":3,\"180\":3}}],[\"endcallback\",{\"1\":{\"115\":1,\"389\":1,\"391\":1}}],[\"endpoint之间的贝塞尔曲线首尾点的坐标必定落在起点和终点上\",{\"1\":{\"63\":1}}],[\"endpoint\",{\"1\":{\"62\":5,\"63\":10}}],[\"end++\",{\"1\":{\"49\":1}}],[\"end\",{\"1\":{\"49\":7,\"80\":1,\"106\":1,\"115\":4,\"147\":1,\"149\":2,\"153\":11,\"166\":3,\"177\":4,\"178\":3,\"179\":1,\"180\":1,\"181\":1,\"184\":9,\"185\":1,\"220\":1,\"272\":1,\"370\":3,\"387\":2,\"389\":4,\"391\":11,\"392\":1}}],[\"enforceinterface\",{\"1\":{\"40\":1,\"58\":1}}],[\"environment\",{\"1\":{\"348\":1,\"378\":4,\"425\":1}}],[\"env\",{\"1\":{\"1\":1,\"357\":1}}],[\"ex\",{\"1\":{\"309\":6}}],[\"extractor\",{\"1\":{\"383\":8}}],[\"extra\",{\"1\":{\"272\":1,\"287\":1}}],[\"extclassloader的父加载器为null\",{\"1\":{\"272\":1}}],[\"ext目录下的jar包和class文件\",{\"1\":{\"272\":1}}],[\"extension\",{\"1\":{\"322\":1}}],[\"extention\",{\"1\":{\"272\":1}}],[\"extent\",{\"1\":{\"213\":5}}],[\"extented\",{\"1\":{\"200\":1}}],[\"extendednetworkimageprovider>\",{\"1\":{\"201\":2}}],[\"extendednetworkimageprovider中\",{\"1\":{\"201\":1}}],[\"extendednetworkimageprovider\",{\"0\":{\"201\":1},\"1\":{\"201\":13}}],[\"extendedimageprovider\",{\"0\":{\"202\":1},\"1\":{\"202\":1}}],[\"extendedimageprovider<t\",{\"1\":{\"202\":1}}],[\"extendedimageprovider<image\",{\"1\":{\"201\":1}}],[\"extendedimageprovider<extendednetworkimageprovider>\",{\"1\":{\"201\":1}}],[\"extendedimagestate\",{\"1\":{\"200\":2}}],[\"extendedimage\",{\"0\":{\"200\":1},\"1\":{\"198\":1,\"200\":6}}],[\"extended\",{\"1\":{\"187\":1,\"198\":1,\"199\":6,\"200\":1,\"201\":1,\"202\":6,\"203\":1}}],[\"extends\",{\"1\":{\"13\":1,\"14\":2,\"17\":1,\"19\":3,\"20\":4,\"36\":1,\"40\":2,\"43\":1,\"56\":1,\"58\":2,\"64\":2,\"71\":1,\"79\":2,\"80\":1,\"96\":1,\"105\":1,\"111\":2,\"118\":1,\"120\":2,\"121\":5,\"122\":2,\"125\":1,\"126\":3,\"127\":5,\"129\":2,\"130\":9,\"131\":3,\"132\":1,\"133\":1,\"134\":2,\"135\":1,\"143\":1,\"147\":3,\"152\":3,\"153\":2,\"154\":1,\"155\":2,\"156\":1,\"158\":1,\"159\":2,\"160\":1,\"172\":1,\"175\":1,\"178\":2,\"183\":2,\"184\":3,\"185\":1,\"186\":2,\"196\":1,\"201\":2,\"202\":1,\"205\":1,\"206\":2,\"207\":2,\"210\":2,\"211\":2,\"213\":2,\"217\":1,\"227\":1,\"228\":2,\"229\":2,\"230\":3,\"231\":1,\"232\":1,\"233\":1,\"235\":1,\"236\":1,\"237\":1,\"285\":2,\"287\":1,\"288\":1,\"290\":1,\"291\":2,\"292\":4,\"300\":1,\"312\":1,\"364\":1}}],[\"externalizable序列化和反序列化\",{\"1\":{\"316\":1}}],[\"externalizable继承自serializable\",{\"1\":{\"310\":1}}],[\"externalizable\",{\"1\":{\"303\":1,\"311\":1,\"312\":3}}],[\"externalizable和parcelable\",{\"0\":{\"303\":1}}],[\"external\",{\"1\":{\"2\":3,\"98\":1,\"105\":2,\"108\":4,\"111\":3,\"112\":2,\"115\":1,\"211\":1,\"376\":3,\"377\":2,\"378\":6}}],[\"excludes\",{\"1\":{\"396\":1}}],[\"exclude\",{\"1\":{\"387\":5}}],[\"excludefromsemantics\",{\"1\":{\"193\":1,\"206\":2,\"207\":2}}],[\"exclusive\",{\"1\":{\"378\":1}}],[\"except\",{\"1\":{\"370\":1,\"387\":1}}],[\"exceptionally\",{\"1\":{\"328\":1}}],[\"exceptionfromresponse\",{\"1\":{\"111\":2}}],[\"exceptions\",{\"1\":{\"101\":1,\"364\":1,\"376\":1}}],[\"exception\",{\"1\":{\"43\":1,\"80\":1,\"95\":1,\"101\":1,\"102\":1,\"121\":1,\"144\":1,\"154\":1,\"209\":4,\"281\":1,\"300\":1,\"305\":1,\"328\":1,\"365\":1,\"453\":4}}],[\"experience\",{\"1\":{\"392\":1}}],[\"expected\",{\"1\":{\"230\":1}}],[\"expects\",{\"1\":{\"115\":1,\"392\":1}}],[\"expect\",{\"1\":{\"102\":1}}],[\"exposing\",{\"1\":{\"220\":2}}],[\"exported=true\",{\"1\":{\"17\":1}}],[\"exported=\",{\"1\":{\"2\":1,\"17\":1,\"36\":1}}],[\"export\",{\"1\":{\"1\":1,\"114\":1,\"115\":3,\"116\":1,\"360\":1,\"382\":1,\"388\":1,\"389\":1}}],[\"expression\",{\"1\":{\"345\":1}}],[\"expressions\",{\"1\":{\"125\":1,\"186\":1}}],[\"expressed\",{\"1\":{\"147\":1}}],[\"expanding\",{\"1\":{\"227\":1}}],[\"expands\",{\"1\":{\"131\":1}}],[\"expandedheight\",{\"1\":{\"212\":1}}],[\"expanded和flexible没有差别\",{\"1\":{\"131\":1}}],[\"expanded和flexible默认情况下都会按照flex占据父容器剩余的可用空间\",{\"1\":{\"131\":1}}],[\"expanded会强制child改变大小为父容器分配的大小\",{\"1\":{\"131\":1}}],[\"expanded\",{\"0\":{\"131\":1},\"1\":{\"131\":3,\"242\":2}}],[\"explained\",{\"1\":{\"127\":1,\"316\":1}}],[\"explicitly\",{\"1\":{\"383\":1}}],[\"explicit\",{\"1\":{\"115\":1,\"277\":1,\"391\":1}}],[\"existssync\",{\"1\":{\"201\":2}}],[\"exists\",{\"1\":{\"115\":2,\"322\":1,\"383\":2}}],[\"existingflight\",{\"1\":{\"180\":5}}],[\"existingflights\",{\"1\":{\"180\":1}}],[\"existing\",{\"1\":{\"80\":1,\"112\":1,\"115\":1,\"180\":2,\"198\":1,\"383\":4,\"390\":1}}],[\"exitisolate\",{\"1\":{\"382\":1,\"383\":1,\"389\":1}}],[\"exiting\",{\"1\":{\"115\":1,\"389\":1,\"391\":1}}],[\"exitscope\",{\"1\":{\"382\":2}}],[\"exits\",{\"1\":{\"115\":1,\"297\":1,\"391\":1}}],[\"exit\",{\"1\":{\"109\":1,\"115\":6,\"144\":1,\"297\":1,\"379\":1,\"383\":4,\"384\":1,\"387\":8,\"389\":5,\"391\":2}}],[\"exituntilcollapsed\",{\"1\":{\"55\":1}}],[\"exec是execute\",{\"1\":{\"80\":1}}],[\"exec\",{\"1\":{\"80\":2}}],[\"executable\",{\"1\":{\"395\":1,\"396\":2}}],[\"executing\",{\"1\":{\"279\":1,\"378\":1,\"392\":1}}],[\"execution\",{\"1\":{\"136\":2,\"277\":1,\"327\":1,\"372\":1,\"383\":1,\"396\":4}}],[\"executr\",{\"1\":{\"80\":1}}],[\"executor\",{\"1\":{\"80\":11}}],[\"executes\",{\"1\":{\"80\":2}}],[\"executed\",{\"1\":{\"80\":2,\"105\":2,\"275\":1,\"277\":1,\"327\":1}}],[\"executeonexecutor\",{\"1\":{\"80\":2}}],[\"execute\",{\"1\":{\"80\":10,\"100\":1,\"109\":1,\"327\":2,\"362\":1,\"365\":4,\"392\":1}}],[\"exactly\",{\"1\":{\"65\":3}}],[\"examples\",{\"1\":{\"302\":1}}],[\"example\",{\"1\":{\"14\":6,\"58\":10,\"136\":1,\"220\":1,\"316\":1,\"392\":1}}],[\"etc\",{\"1\":{\"1\":1,\"348\":1,\"349\":1,\"361\":4}}],[\"srv\",{\"1\":{\"349\":1}}],[\"srcstring\",{\"1\":{\"211\":1}}],[\"srcpaint\",{\"1\":{\"57\":3}}],[\"src和dst符合要求\",{\"1\":{\"57\":1}}],[\"src\",{\"1\":{\"32\":2,\"40\":1,\"41\":1,\"54\":2,\"57\":8,\"61\":1,\"65\":1,\"117\":1,\"118\":3,\"119\":1,\"120\":1,\"121\":3,\"122\":3,\"125\":2,\"126\":4,\"127\":6,\"188\":2,\"195\":1,\"211\":2,\"272\":1}}],[\"srcdirs\",{\"1\":{\"32\":1}}],[\"sbin\",{\"1\":{\"349\":1}}],[\"ssa\",{\"1\":{\"396\":2}}],[\"ssh\",{\"1\":{\"347\":9}}],[\"sslfilter\",{\"1\":{\"115\":2}}],[\"s=\",{\"1\":{\"283\":1}}],[\"sf\",{\"1\":{\"269\":1}}],[\"s2\",{\"1\":{\"250\":1,\"254\":3}}],[\"s1\",{\"1\":{\"250\":1}}],[\"skip\",{\"1\":{\"327\":1}}],[\"skimage\",{\"1\":{\"203\":1}}],[\"skywang12345\",{\"1\":{\"458\":1}}],[\"sky\",{\"1\":{\"111\":1}}],[\"sky0014\",{\"1\":{\"65\":1}}],[\"skyroben\",{\"1\":{\"58\":2}}],[\"sqrt2\",{\"1\":{\"172\":1,\"173\":1}}],[\"squares\",{\"1\":{\"328\":2}}],[\"square\",{\"1\":{\"170\":2,\"172\":2,\"328\":2}}],[\"slow\",{\"1\":{\"327\":3}}],[\"slot\",{\"1\":{\"102\":1,\"117\":1,\"121\":2,\"122\":2,\"125\":1,\"126\":3,\"127\":2,\"128\":2,\"230\":2}}],[\"sleep\",{\"1\":{\"327\":2,\"336\":1,\"370\":2,\"391\":1}}],[\"slide\",{\"1\":{\"400\":1}}],[\"slide=67\",{\"1\":{\"286\":1}}],[\"slide=42\",{\"1\":{\"282\":1}}],[\"slide=34\",{\"1\":{\"282\":1}}],[\"slidetransition\",{\"1\":{\"154\":1}}],[\"sliverchilddelegate\",{\"1\":{\"233\":1}}],[\"sliverconstraints\",{\"1\":{\"213\":1}}],[\"slivermultiboxadaptorwidget\",{\"1\":{\"233\":3}}],[\"sliverxxx\",{\"1\":{\"227\":1}}],[\"slivergrid\",{\"1\":{\"226\":1}}],[\"slivergeometry\",{\"1\":{\"212\":1,\"213\":1,\"227\":1}}],[\"sliverlist\",{\"1\":{\"226\":1,\"227\":1,\"233\":1}}],[\"sliveroverlapinjector\",{\"1\":{\"213\":1}}],[\"sliveroverlapabsorber\",{\"1\":{\"213\":1}}],[\"sliveroverlapabsorberhandle\",{\"1\":{\"212\":1,\"213\":2}}],[\"sliverfillremainingwithscrollable\",{\"1\":{\"213\":2}}],[\"sliverfillremaining只能容纳可以产生renderbox的widget\",{\"1\":{\"213\":1}}],[\"sliverfillremaining\",{\"1\":{\"213\":2,\"226\":1}}],[\"sliverfillviewport\",{\"1\":{\"212\":1,\"227\":1}}],[\"slivers\",{\"1\":{\"212\":1,\"213\":2,\"226\":1,\"227\":6,\"228\":6,\"231\":5,\"233\":5}}],[\"sliverappbar\",{\"1\":{\"212\":1,\"233\":1}}],[\"sliver\",{\"1\":{\"212\":1,\"226\":2,\"227\":3,\"233\":1}}],[\"snprintf\",{\"1\":{\"115\":1}}],[\"snapshot加载到vm中运行\",{\"1\":{\"396\":1}}],[\"snapshot主要用于减少大型dart\",{\"1\":{\"396\":1}}],[\"snapshots\",{\"1\":{\"387\":1,\"392\":2,\"396\":1}}],[\"snapshot等数据\",{\"1\":{\"387\":1}}],[\"snapshot\",{\"1\":{\"382\":6,\"383\":5,\"387\":13,\"388\":4,\"392\":2,\"396\":7}}],[\"snap\",{\"1\":{\"55\":1}}],[\"sdpath\",{\"1\":{\"425\":1}}],[\"sdefaultexecutor\",{\"1\":{\"80\":2}}],[\"sdk中调用isolate\",{\"1\":{\"377\":1}}],[\"sdk源码分析一下event\",{\"1\":{\"95\":1}}],[\"sdk\",{\"1\":{\"1\":1,\"2\":2,\"54\":2,\"81\":1,\"96\":3,\"97\":1,\"98\":2,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":2,\"104\":1,\"105\":6,\"106\":2,\"107\":1,\"108\":3,\"109\":3,\"111\":9,\"112\":3,\"115\":3,\"363\":1,\"372\":1,\"376\":1,\"377\":3,\"378\":3,\"397\":2}}],[\"sudo\",{\"1\":{\"347\":1,\"348\":2}}],[\"sum\",{\"1\":{\"345\":1}}],[\"summary\",{\"1\":{\"295\":1,\"371\":3}}],[\"suspend\",{\"1\":{\"334\":1}}],[\"suspending\",{\"1\":{\"138\":1}}],[\"sunflower\",{\"1\":{\"400\":1}}],[\"sunflower只有简单的3个页面\",{\"1\":{\"399\":1}}],[\"sunflower则是google用来演示如何使用jetpack进行android开发的demo\",{\"1\":{\"399\":1}}],[\"sunday\",{\"1\":{\"302\":2}}],[\"sun\",{\"1\":{\"272\":4}}],[\"survivor\",{\"1\":{\"249\":1}}],[\"sure\",{\"1\":{\"198\":2,\"376\":1}}],[\"surface\",{\"1\":{\"122\":1}}],[\"succeed\",{\"1\":{\"389\":1}}],[\"successorkey\",{\"1\":{\"438\":4}}],[\"successful\",{\"1\":{\"388\":1}}],[\"successfully\",{\"1\":{\"115\":2,\"347\":1,\"394\":1}}],[\"success\",{\"1\":{\"135\":1,\"209\":3,\"211\":5,\"381\":2,\"383\":3,\"387\":1,\"389\":3}}],[\"successvalue\",{\"1\":{\"102\":1}}],[\"such\",{\"1\":{\"115\":1,\"136\":1,\"193\":1,\"277\":1}}],[\"suffix\",{\"1\":{\"110\":3,\"111\":1}}],[\"subdirectory\",{\"1\":{\"417\":1}}],[\"subgraphs\",{\"1\":{\"400\":1}}],[\"subtitle\",{\"1\":{\"417\":1}}],[\"subt>\",{\"1\":{\"292\":1}}],[\"subtract\",{\"1\":{\"201\":1}}],[\"subtreecontext\",{\"1\":{\"177\":2,\"180\":2}}],[\"subtree\",{\"1\":{\"153\":1}}],[\"submit\",{\"1\":{\"211\":1}}],[\"subset\",{\"1\":{\"373\":1}}],[\"subscribe\",{\"1\":{\"321\":2}}],[\"subscription\",{\"1\":{\"211\":3}}],[\"subs\",{\"1\":{\"309\":1}}],[\"substring\",{\"1\":{\"64\":2,\"296\":2}}],[\"subclasses\",{\"1\":{\"125\":1,\"147\":1,\"154\":1,\"165\":1,\"186\":1,\"233\":1,\"306\":1}}],[\"subclass\",{\"1\":{\"111\":1,\"322\":1}}],[\"subcomponent\",{\"0\":{\"90\":1},\"1\":{\"90\":3,\"94\":1}}],[\"subcomponent从它的父类访问所有依赖\",{\"1\":{\"87\":1}}],[\"subcomponents为刚刚创建的mainactivitysubcomponent\",{\"1\":{\"91\":1}}],[\"subcomponents和component\",{\"1\":{\"87\":2}}],[\"subcomponents\",{\"1\":{\"87\":1,\"91\":1}}],[\"supplied\",{\"1\":{\"115\":1}}],[\"suppresswarnings\",{\"1\":{\"80\":1,\"298\":1}}],[\"suppresslint\",{\"1\":{\"56\":1}}],[\"supported\",{\"1\":{\"99\":1,\"105\":2,\"378\":1,\"381\":1,\"386\":1}}],[\"support\",{\"1\":{\"1\":1,\"2\":1,\"14\":1,\"36\":1,\"55\":13,\"88\":1,\"278\":1,\"383\":1}}],[\"support包版本保持一致\",{\"1\":{\"1\":1}}],[\"supervisorscope\",{\"1\":{\"332\":1}}],[\"supervisor取消的话\",{\"1\":{\"330\":1}}],[\"supervisor\",{\"1\":{\"330\":2}}],[\"supervisorjob\",{\"1\":{\"330\":2,\"331\":2}}],[\"superinterfaces\",{\"1\":{\"275\":1}}],[\"superclasses\",{\"1\":{\"306\":1}}],[\"superclass\",{\"1\":{\"275\":1}}],[\"super\",{\"1\":{\"13\":2,\"14\":1,\"15\":1,\"17\":2,\"40\":1,\"43\":1,\"55\":1,\"56\":1,\"58\":1,\"64\":3,\"71\":1,\"79\":6,\"80\":1,\"81\":1,\"92\":1,\"93\":1,\"118\":1,\"120\":1,\"121\":1,\"122\":2,\"125\":1,\"126\":3,\"127\":2,\"130\":7,\"131\":2,\"135\":1,\"147\":1,\"150\":1,\"152\":1,\"153\":1,\"154\":1,\"155\":4,\"156\":1,\"172\":1,\"175\":1,\"178\":1,\"184\":1,\"186\":1,\"188\":1,\"206\":1,\"207\":1,\"210\":2,\"211\":1,\"213\":1,\"219\":1,\"223\":2,\"233\":1,\"237\":2,\"288\":1,\"293\":2,\"369\":1}}],[\"superdispatchkeyevent\",{\"1\":{\"13\":3}}],[\"superdispatchtouchevent\",{\"1\":{\"13\":3}}],[\"swapper进程\",{\"1\":{\"60\":1}}],[\"swiplerefreshlayout\",{\"1\":{\"55\":1}}],[\"swiperecyclerview\",{\"1\":{\"41\":1}}],[\"switchable\",{\"0\":{\"397\":1},\"1\":{\"397\":1}}],[\"switchablecallmiss\",{\"1\":{\"383\":1}}],[\"switchmap\",{\"1\":{\"78\":2}}],[\"switch\",{\"1\":{\"13\":1,\"40\":1,\"53\":1,\"56\":1,\"58\":1,\"65\":1,\"80\":2,\"115\":1,\"179\":1,\"181\":2,\"228\":1,\"238\":3,\"239\":1,\"305\":1}}],[\"safari\",{\"1\":{\"370\":1}}],[\"safeargs的支持\",{\"1\":{\"400\":1}}],[\"safely\",{\"1\":{\"136\":1}}],[\"safepoint的含义是\",{\"1\":{\"396\":1}}],[\"safepointwriterwlocker\",{\"1\":{\"383\":2}}],[\"safepointreadrwlocker\",{\"1\":{\"383\":1}}],[\"safepointing\",{\"1\":{\"383\":1}}],[\"safepoint\",{\"1\":{\"116\":1,\"383\":2,\"389\":1,\"391\":2}}],[\"safe\",{\"1\":{\"87\":1,\"383\":1,\"387\":5,\"416\":1}}],[\"safeopencamera\",{\"1\":{\"69\":2}}],[\"saferequestcamerapermission\",{\"1\":{\"69\":4}}],[\"saynum\",{\"1\":{\"321\":1}}],[\"say\",{\"1\":{\"272\":6,\"321\":1,\"369\":3}}],[\"samples\",{\"1\":{\"400\":1}}],[\"sampleapppagestate\",{\"1\":{\"135\":1}}],[\"same\",{\"1\":{\"106\":1,\"302\":1,\"372\":1,\"376\":1,\"378\":1,\"389\":1,\"391\":1}}],[\"sa\",{\"1\":{\"58\":1,\"288\":1}}],[\"saver对象在构造方法中退出了调用方法的分支\",{\"1\":{\"115\":1}}],[\"saver\",{\"1\":{\"115\":1}}],[\"saved\",{\"1\":{\"115\":3,\"391\":5}}],[\"savedinstancestate\",{\"1\":{\"79\":2,\"93\":2,\"211\":1}}],[\"save\",{\"1\":{\"57\":1,\"65\":3}}],[\"savelayer\",{\"1\":{\"57\":1,\"65\":2}}],[\"savecount\",{\"1\":{\"57\":2}}],[\"smi\",{\"1\":{\"376\":2}}],[\"smallest\",{\"1\":{\"238\":1}}],[\"smaller\",{\"1\":{\"108\":1,\"131\":1}}],[\"small\",{\"1\":{\"221\":1,\"396\":1,\"462\":1}}],[\"smgr提供的binder比较特殊\",{\"1\":{\"58\":1}}],[\"smoothscrollby\",{\"1\":{\"41\":1}}],[\"sv\",{\"1\":{\"58\":5}}],[\"s\",{\"1\":{\"49\":1,\"58\":1,\"87\":1,\"92\":1,\"96\":3,\"102\":2,\"103\":1,\"104\":2,\"115\":7,\"116\":2,\"131\":1,\"132\":1,\"140\":1,\"155\":1,\"176\":1,\"177\":1,\"179\":1,\"181\":1,\"196\":2,\"216\":1,\"225\":1,\"254\":1,\"280\":5,\"283\":1,\"297\":1,\"302\":3,\"321\":6,\"322\":1,\"353\":2,\"365\":1,\"369\":1,\"370\":2,\"376\":1,\"378\":1,\"379\":1,\"383\":2,\"384\":1,\"386\":1,\"389\":2,\"391\":10,\"396\":1,\"401\":1,\"417\":1,\"424\":1}}],[\"spwanuri创建的时候会创建单独的isolategroup和isolate\",{\"1\":{\"372\":1}}],[\"spider1\",{\"1\":{\"370\":1}}],[\"spidermain\",{\"1\":{\"370\":1,\"371\":2}}],[\"spider\",{\"1\":{\"370\":2,\"371\":2}}],[\"spin\",{\"1\":{\"109\":1}}],[\"split\",{\"1\":{\"321\":1,\"345\":1,\"453\":1}}],[\"spends\",{\"1\":{\"396\":1}}],[\"spent\",{\"1\":{\"396\":1}}],[\"speed\",{\"1\":{\"327\":1}}],[\"speakerdeck\",{\"1\":{\"282\":3,\"286\":1}}],[\"speculative\",{\"1\":{\"396\":2}}],[\"specs\",{\"1\":{\"274\":1,\"281\":1}}],[\"specsize\",{\"1\":{\"65\":2}}],[\"specsize决定于父容器的尺寸\",{\"1\":{\"65\":1}}],[\"special\",{\"1\":{\"111\":1,\"112\":1,\"115\":1,\"396\":1}}],[\"specification\",{\"1\":{\"279\":1}}],[\"specific\",{\"1\":{\"102\":1,\"106\":1,\"108\":1,\"111\":1,\"395\":1}}],[\"specified\",{\"1\":{\"15\":1,\"45\":1,\"80\":1,\"147\":1,\"378\":1}}],[\"specmode\",{\"1\":{\"65\":2}}],[\"specmode有3种可能值\",{\"1\":{\"65\":1}}],[\"springsimulation\",{\"0\":{\"168\":1}}],[\"springdescription\",{\"1\":{\"161\":2}}],[\"spoolworkqueue\",{\"1\":{\"80\":1}}],[\"spawn默认会创建在同一个isolategroup中的isolate\",{\"1\":{\"391\":1}}],[\"spawn的entrypoint或者isolate\",{\"1\":{\"389\":1}}],[\"spawn的spawn或者isolate\",{\"1\":{\"389\":1}}],[\"spawn最后调用了\",{\"1\":{\"378\":1,\"379\":1}}],[\"spawn状态\",{\"1\":{\"378\":1}}],[\"spawncommon\",{\"1\":{\"378\":4}}],[\"spawncreate\",{\"1\":{\"378\":1}}],[\"spawnfunction方法中主要还是解析收到的各种参数\",{\"1\":{\"379\":1}}],[\"spawnfunction方法\",{\"1\":{\"378\":1,\"379\":1}}],[\"spawnfunction\",{\"0\":{\"379\":1},\"1\":{\"378\":4,\"379\":2,\"389\":1}}],[\"spawn和isolate\",{\"1\":{\"378\":1}}],[\"spawn<t>\",{\"1\":{\"378\":2}}],[\"spawns\",{\"1\":{\"378\":4}}],[\"spawnuri会从制定的uri中创建一个新的isolategroup和对应的isolate\",{\"1\":{\"391\":1}}],[\"spawnuri的main方法\",{\"1\":{\"389\":2}}],[\"spawnuri的时候\",{\"1\":{\"387\":1}}],[\"spawnuri的实现都在vm下面的isolate\",{\"1\":{\"378\":1}}],[\"spawnuri还是执行了spawnisolatetask\",{\"1\":{\"384\":1}}],[\"spawnuri来创建isolate\",{\"1\":{\"384\":1}}],[\"spawnuri方法\",{\"1\":{\"378\":1}}],[\"spawnuri最后调用了\",{\"1\":{\"378\":1}}],[\"spawnuricreate\",{\"1\":{\"378\":1}}],[\"spawnuri\",{\"0\":{\"384\":1},\"1\":{\"373\":2,\"378\":9,\"384\":3}}],[\"spawnisolatetask\",{\"0\":{\"380\":1,\"385\":1},\"1\":{\"380\":2,\"386\":1}}],[\"spawnisolate\",{\"1\":{\"373\":1}}],[\"spawning\",{\"1\":{\"136\":1,\"378\":1,\"381\":3,\"389\":1}}],[\"spawn创建新isolate的时候使用isolategroup\",{\"1\":{\"372\":1}}],[\"spawn\",{\"1\":{\"112\":1,\"373\":3,\"378\":4,\"379\":2,\"381\":1,\"383\":1,\"386\":2,\"388\":1,\"389\":4}}],[\"spawneduri\",{\"1\":{\"378\":1}}],[\"spawned\",{\"1\":{\"59\":1}}],[\"spacer等非renderobjectwidget本身没有高度\",{\"1\":{\"242\":1}}],[\"space等填充column剩余的空间以展示某些内容\",{\"1\":{\"242\":1}}],[\"space等效果\",{\"0\":{\"242\":1}}],[\"spacearound原则分配\",{\"1\":{\"241\":1}}],[\"spacearound\",{\"1\":{\"241\":1}}],[\"space\",{\"1\":{\"109\":1,\"116\":6,\"131\":3,\"225\":2,\"249\":2}}],[\"sparselongarray\",{\"1\":{\"287\":1}}],[\"sparseintarray\",{\"1\":{\"287\":1}}],[\"sparsebooleanarray\",{\"1\":{\"287\":1}}],[\"sparsearray在删除时只是将对于的值标记为deleted\",{\"1\":{\"287\":1}}],[\"sparsearray有以下局限性\",{\"1\":{\"287\":1}}],[\"sparsearray类的key要占用更少的内存\",{\"1\":{\"287\":1}}],[\"sparsearray类很明显要比hashmap占用更少的内存\",{\"1\":{\"287\":1}}],[\"sparsearray类\",{\"1\":{\"287\":1}}],[\"sparsearray\",{\"0\":{\"287\":1},\"1\":{\"48\":1,\"52\":3,\"287\":7}}],[\"sparsearray<e>\",{\"1\":{\"44\":1,\"287\":1}}],[\"sparearray在删除数组时只会将其赋值为deleted\",{\"1\":{\"44\":1}}],[\"sparearray以及他的衍生类主要用于以基本类型为key保存非大量数据的场景\",{\"1\":{\"44\":1}}],[\"sparearray以及他的衍生类都是以基本类型为key\",{\"1\":{\"44\":1}}],[\"sp\",{\"1\":{\"53\":1,\"370\":2,\"371\":2}}],[\"sh\",{\"1\":{\"347\":1,\"348\":1,\"361\":2}}],[\"shellsort\",{\"1\":{\"462\":2}}],[\"shell\",{\"0\":{\"361\":1},\"1\":{\"347\":1,\"357\":1,\"360\":1}}],[\"shrinkwrappingviewport\",{\"1\":{\"227\":1,\"228\":4,\"230\":1,\"233\":1}}],[\"shrinkwrap\",{\"1\":{\"227\":1,\"228\":3,\"232\":1,\"233\":1}}],[\"shift\",{\"1\":{\"213\":1}}],[\"shlould\",{\"1\":{\"130\":1}}],[\"shuttle\",{\"1\":{\"181\":3}}],[\"shuttlebuilder\",{\"1\":{\"177\":1,\"180\":1,\"181\":1}}],[\"shutting\",{\"1\":{\"115\":1,\"389\":1,\"391\":3}}],[\"shutdownisolate\",{\"1\":{\"381\":1,\"383\":2,\"389\":3}}],[\"shutdown\",{\"1\":{\"109\":1,\"382\":1,\"383\":2,\"391\":2}}],[\"shutdowntimerhandler\",{\"1\":{\"108\":1}}],[\"shayn\",{\"1\":{\"322\":1}}],[\"shany\",{\"1\":{\"322\":1}}],[\"shandler是一个类变量\",{\"1\":{\"80\":1}}],[\"shandler\",{\"1\":{\"80\":3}}],[\"shape>\",{\"1\":{\"66\":1}}],[\"shade200\",{\"1\":{\"131\":1}}],[\"shader\",{\"1\":{\"63\":6}}],[\"shadowpath\",{\"1\":{\"63\":6}}],[\"shadowpaint\",{\"1\":{\"63\":4}}],[\"shares\",{\"1\":{\"378\":1}}],[\"share\",{\"1\":{\"136\":2,\"347\":1}}],[\"shareduid\",{\"1\":{\"422\":1}}],[\"shareduserid与当前app相同\",{\"1\":{\"422\":1}}],[\"shareduserid=\",{\"1\":{\"421\":1}}],[\"shareduserid\",{\"0\":{\"421\":1},\"1\":{\"422\":2}}],[\"shareddata\",{\"1\":{\"135\":3}}],[\"sharedtext\",{\"1\":{\"135\":2}}],[\"shared\",{\"1\":{\"135\":2,\"392\":1}}],[\"sharedpreferences\",{\"1\":{\"11\":1}}],[\"sharepreferencesutils\",{\"1\":{\"11\":1}}],[\"short\",{\"1\":{\"56\":1,\"78\":1,\"299\":1,\"438\":1}}],[\"shouldpauseonexit\",{\"1\":{\"391\":3}}],[\"shouldpauseonstart\",{\"1\":{\"391\":2}}],[\"shouldclipatpaintoffset\",{\"1\":{\"239\":1}}],[\"shouldacceptuseroffset\",{\"1\":{\"223\":1}}],[\"shouldanimatetween\",{\"1\":{\"149\":3}}],[\"shouldn\",{\"1\":{\"198\":1,\"378\":1}}],[\"shouldincludechildinplaceholder\",{\"1\":{\"181\":4}}],[\"shouldincludechild\",{\"1\":{\"176\":2}}],[\"shouldincludedchildinplaceholder\",{\"1\":{\"176\":2,\"181\":1}}],[\"shouldstartanimation\",{\"1\":{\"149\":4}}],[\"shouldshowrequestpermissionrationale\",{\"1\":{\"68\":2,\"69\":1}}],[\"should\",{\"1\":{\"49\":1,\"65\":1,\"87\":1,\"100\":1,\"115\":1,\"121\":1,\"130\":1,\"181\":1,\"202\":1,\"220\":2,\"233\":1,\"373\":1,\"383\":2,\"387\":2}}],[\"shouldoverrideurlloading\",{\"1\":{\"42\":1}}],[\"showprogressonmainthread\",{\"1\":{\"322\":1}}],[\"showplaceholder\",{\"1\":{\"176\":5}}],[\"show\",{\"1\":{\"41\":1,\"56\":1,\"69\":2,\"78\":1}}],[\"scontext\",{\"1\":{\"211\":2}}],[\"scope范围一致\",{\"1\":{\"87\":1}}],[\"scope修饰的类会在实例构造完毕后\",{\"1\":{\"87\":1}}],[\"scope修饰的实例在构造完毕后就会失去控制\",{\"1\":{\"87\":1}}],[\"scope的作用是限定其修饰的类的范围\",{\"1\":{\"87\":1}}],[\"scope在起作用\",{\"1\":{\"87\":1}}],[\"scope\",{\"0\":{\"87\":1},\"1\":{\"87\":2,\"383\":5,\"389\":4}}],[\"scaletransition\",{\"1\":{\"154\":1}}],[\"scale\",{\"1\":{\"147\":1,\"154\":1,\"166\":1,\"188\":3,\"192\":2,\"193\":2,\"196\":4,\"201\":3}}],[\"scaleddensity\",{\"1\":{\"53\":1}}],[\"scaleddensity=2\",{\"1\":{\"53\":2}}],[\"scaledtouchslop\",{\"1\":{\"41\":1}}],[\"scaffolds\",{\"1\":{\"415\":1}}],[\"scaffold\",{\"1\":{\"132\":1,\"135\":1,\"143\":4,\"212\":1}}],[\"script\",{\"1\":{\"378\":1,\"379\":1,\"382\":6,\"387\":15,\"388\":2,\"407\":3}}],[\"scripts\",{\"0\":{\"361\":1},\"1\":{\"360\":1,\"415\":1}}],[\"scrapy\",{\"1\":{\"347\":1}}],[\"screen\",{\"1\":{\"57\":1,\"135\":1}}],[\"scrollupdatenotification\",{\"1\":{\"227\":1,\"235\":1}}],[\"scrolls\",{\"1\":{\"227\":1}}],[\"scrollviewkeyboarddismissbehavior\",{\"1\":{\"227\":1,\"235\":1}}],[\"scrollview\",{\"1\":{\"227\":10,\"228\":1,\"230\":1,\"233\":9}}],[\"scrolldragcontroller\",{\"1\":{\"226\":3}}],[\"scrolldirection\",{\"1\":{\"131\":1,\"213\":2,\"225\":1,\"226\":2}}],[\"scrollholdcontroller\",{\"1\":{\"224\":1}}],[\"scrollbars\",{\"1\":{\"213\":1}}],[\"scrollbehavior\",{\"1\":{\"178\":1,\"213\":3,\"227\":2}}],[\"scrolloffset\",{\"1\":{\"213\":1}}],[\"scrolled\",{\"1\":{\"234\":1}}],[\"scrollextent\",{\"1\":{\"212\":1,\"213\":8}}],[\"scroller不能使view滑动\",{\"1\":{\"41\":1}}],[\"scroller\",{\"1\":{\"41\":1}}],[\"scrollnotification\",{\"1\":{\"212\":1,\"227\":2}}],[\"scrollphysics\",{\"1\":{\"212\":2,\"213\":3,\"215\":1,\"222\":1,\"227\":1,\"234\":1}}],[\"scrollposition和\",{\"1\":{\"240\":1}}],[\"scrollposition作为这里的入参offset\",{\"1\":{\"227\":1}}],[\"scrollpositionwithsinglecontext类\",{\"1\":{\"223\":1}}],[\"scrollpositionwithsinglecontext\",{\"1\":{\"223\":2}}],[\"scrollposition实际将要产生的变化\",{\"1\":{\"220\":1}}],[\"scrollposition上的值\",{\"1\":{\"220\":1}}],[\"scrollposition\",{\"0\":{\"216\":1},\"1\":{\"212\":3,\"213\":1,\"215\":2,\"216\":4,\"217\":1,\"219\":2,\"220\":1,\"223\":1,\"226\":2,\"227\":2,\"234\":1}}],[\"scrollcontext\",{\"1\":{\"215\":1}}],[\"scrollcontroller要么使用最近的primaryscrollcontroller\",{\"1\":{\"227\":1}}],[\"scrollcontroller\",{\"1\":{\"212\":4,\"213\":3,\"214\":1,\"217\":2,\"218\":3,\"223\":5,\"224\":1,\"226\":1,\"227\":5,\"235\":4}}],[\"scrollconfiguration\",{\"1\":{\"178\":1,\"213\":1}}],[\"scrollactivitydelegate\",{\"1\":{\"217\":1,\"224\":2}}],[\"scrollactivity\",{\"1\":{\"212\":1,\"225\":5,\"227\":1,\"234\":1}}],[\"scrollableresult\",{\"1\":{\"227\":3}}],[\"scrollablestate类\",{\"1\":{\"223\":1}}],[\"scrollablestate\",{\"1\":{\"223\":2,\"226\":2}}],[\"scrollable\",{\"1\":{\"212\":5,\"223\":1,\"225\":2,\"226\":2,\"227\":14,\"233\":2,\"235\":6}}],[\"scrollawarecontext\",{\"1\":{\"190\":1}}],[\"scrollawareimageprovider<object>\",{\"1\":{\"190\":1}}],[\"scrollawareimageprovider\",{\"1\":{\"190\":1}}],[\"scrollawareimageprovider用于防止在快速滑动的时候加载图片\",{\"1\":{\"190\":1}}],[\"scrollflags说明如下\",{\"1\":{\"55\":1}}],[\"scrollflags\",{\"1\":{\"55\":1}}],[\"scrollflags=\",{\"1\":{\"55\":1}}],[\"scroll|exituntilcollapsed\",{\"1\":{\"55\":1}}],[\"scrolling\",{\"1\":{\"55\":3,\"212\":6,\"213\":1,\"217\":1,\"220\":1,\"223\":6,\"224\":1,\"225\":7,\"226\":4,\"227\":2}}],[\"scrollingviewbehavior的实例\",{\"1\":{\"55\":1}}],[\"scroll\",{\"1\":{\"41\":1,\"55\":3,\"212\":3,\"220\":4,\"225\":5,\"226\":1,\"227\":2,\"228\":2,\"231\":1,\"233\":1}}],[\"scrollto\",{\"1\":{\"41\":1}}],[\"scrolly\",{\"1\":{\"41\":1}}],[\"scrolly表示的是view的x\",{\"1\":{\"41\":1}}],[\"scrollx<0表示view内容向右移动\",{\"1\":{\"41\":1}}],[\"scrollx\",{\"1\":{\"41\":2}}],[\"scheduling\",{\"1\":{\"391\":1}}],[\"scheduleupdateshadow\",{\"1\":{\"216\":6}}],[\"scheduleframecallback\",{\"1\":{\"162\":1,\"168\":1}}],[\"schedulerbinding\",{\"1\":{\"118\":2,\"119\":2,\"168\":1,\"216\":1}}],[\"schedulewarmupframe\",{\"0\":{\"122\":1},\"1\":{\"117\":1}}],[\"schedulewakeup\",{\"1\":{\"106\":1,\"108\":2}}],[\"scheduleattachrootwidget\",{\"0\":{\"119\":1},\"1\":{\"117\":1}}],[\"scheduleasynccallback方法\",{\"1\":{\"97\":1}}],[\"scheduleasynccallback\",{\"0\":{\"97\":1},\"1\":{\"96\":1,\"97\":1}}],[\"scheduletasklocked获取到new\",{\"1\":{\"391\":1}}],[\"scheduletasklocked方法\",{\"1\":{\"390\":1}}],[\"scheduletasklocked方法获取new\",{\"1\":{\"389\":1}}],[\"scheduletasklocked\",{\"0\":{\"390\":1},\"1\":{\"115\":2,\"389\":2,\"390\":1}}],[\"scheduleimmediateclosure并保存在\",{\"1\":{\"100\":1}}],[\"scheduleimmediateclosure执行回调事件\",{\"1\":{\"100\":1}}],[\"scheduleimmediateclosure调用的\",{\"1\":{\"100\":1}}],[\"scheduleimmediateclosure\",{\"0\":{\"100\":1},\"1\":{\"99\":3,\"100\":1}}],[\"scheduleimmediate方法的实现在schedule\",{\"1\":{\"99\":1}}],[\"scheduleimmediate方法则是触发处理microtask的方法\",{\"1\":{\"98\":1}}],[\"scheduleimmediate\",{\"0\":{\"99\":1},\"1\":{\"97\":1,\"98\":2,\"99\":5,\"100\":1}}],[\"scheduledwakeuptime\",{\"1\":{\"106\":2,\"108\":3,\"109\":1}}],[\"scheduled\",{\"1\":{\"97\":1,\"103\":1,\"108\":2,\"109\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"3\":1}}],[\"schedules\",{\"1\":{\"97\":1}}],[\"schedule\",{\"1\":{\"96\":1,\"97\":1,\"98\":4,\"99\":1,\"100\":3,\"209\":1}}],[\"schedulemicrotask\",{\"1\":{\"95\":1,\"96\":7,\"103\":1,\"209\":2}}],[\"schedulenext\",{\"1\":{\"80\":3}}],[\"scheme\",{\"1\":{\"154\":1}}],[\"schemas\",{\"1\":{\"56\":2,\"66\":3,\"79\":3,\"400\":3,\"401\":5,\"421\":1}}],[\"silent\",{\"1\":{\"416\":1}}],[\"sivachandra\",{\"1\":{\"387\":1}}],[\"sitetitle\",{\"1\":{\"417\":1}}],[\"site\",{\"1\":{\"395\":1,\"417\":1}}],[\"sites\",{\"0\":{\"248\":1},\"1\":{\"397\":1}}],[\"situation\",{\"1\":{\"220\":3,\"225\":1}}],[\"simulators\",{\"1\":{\"392\":1}}],[\"simulation获取当前动画的\",{\"1\":{\"163\":1}}],[\"simulation\",{\"0\":{\"165\":1},\"1\":{\"157\":2,\"161\":3,\"162\":6,\"163\":3,\"165\":6,\"168\":2}}],[\"simpledateformat\",{\"1\":{\"302\":8}}],[\"simple\",{\"1\":{\"170\":1,\"181\":1,\"336\":3,\"339\":1,\"341\":4,\"343\":2}}],[\"singletickerproviderstatemixin\",{\"1\":{\"161\":1,\"168\":1}}],[\"singletickerproviderstatemixin<t>\",{\"1\":{\"147\":1}}],[\"singletonenum\",{\"1\":{\"294\":1}}],[\"singleton是用来标记类在其范围内只能被实例化一次\",{\"1\":{\"87\":1}}],[\"singleton和他的幕后英雄\",{\"1\":{\"87\":1}}],[\"singleton和\",{\"0\":{\"87\":1}}],[\"singleton\",{\"1\":{\"72\":1,\"87\":3}}],[\"singleton<iactivitymanager>\",{\"1\":{\"58\":2}}],[\"singlechildviewport继承自singlechildrenderobjectwidget\",{\"1\":{\"236\":1}}],[\"singlechildviewport\",{\"0\":{\"236\":1},\"1\":{\"235\":3,\"236\":1}}],[\"singlechildscrollview作为遵守box\",{\"1\":{\"242\":1}}],[\"singlechildscrollview都会将其layout\",{\"1\":{\"240\":1}}],[\"singlechildscrollview使用起来也比较方便\",{\"1\":{\"240\":1}}],[\"singlechildscrollview使用简单\",{\"1\":{\"240\":1}}],[\"singlechildscrollview可以保证在父级无法完整显示child的时候使其支持滑动\",{\"1\":{\"240\":1}}],[\"singlechildscrollview基于scrollable\",{\"1\":{\"240\":1}}],[\"singlechildscrollview自身的尺寸是父级给定的最大尺寸\",{\"1\":{\"238\":1}}],[\"singlechildscrollview是依赖于封装scrollable实现滑动效果\",{\"1\":{\"235\":1}}],[\"singlechildscrollview是遵守box\",{\"1\":{\"234\":1}}],[\"singlechildscrollview实现其实也就是对scrollable的\",{\"1\":{\"235\":1}}],[\"singlechildscrollview的主要逻辑在他的build\",{\"1\":{\"235\":1}}],[\"singlechildscrollview中容纳了一个叫column的child\",{\"1\":{\"234\":1}}],[\"singlechildscrollview\",{\"0\":{\"235\":1},\"1\":{\"143\":1,\"227\":3,\"234\":1,\"235\":1,\"241\":1,\"242\":2}}],[\"singlechildrenderobjectwidget\",{\"1\":{\"122\":1,\"125\":2,\"126\":1,\"236\":1}}],[\"singlechildrenderobjectelement\",{\"1\":{\"122\":2,\"125\":3,\"126\":4,\"127\":2}}],[\"single\",{\"1\":{\"136\":1,\"234\":1,\"322\":1,\"327\":1,\"337\":1,\"396\":1}}],[\"since\",{\"1\":{\"102\":2,\"108\":1,\"115\":1,\"136\":1,\"198\":1,\"216\":1,\"378\":2,\"379\":1,\"384\":1,\"391\":2}}],[\"sinyuk\",{\"1\":{\"87\":2}}],[\"signoremeasurecache\",{\"1\":{\"65\":1}}],[\"signal\",{\"1\":{\"58\":2}}],[\"signed\",{\"1\":{\"54\":1}}],[\"side\",{\"1\":{\"40\":1,\"58\":1,\"111\":1,\"112\":1,\"220\":1,\"334\":3}}],[\"size++\",{\"1\":{\"451\":1}}],[\"sizeof\",{\"1\":{\"282\":12,\"287\":1}}],[\"size在父级约束内就直接应用\",{\"1\":{\"238\":1}}],[\"sizebytes为null\",{\"1\":{\"198\":1}}],[\"sizebytes\",{\"1\":{\"192\":1,\"198\":9}}],[\"sizetransition\",{\"1\":{\"154\":1}}],[\"sizes\",{\"1\":{\"147\":1}}],[\"sizedbox\",{\"1\":{\"131\":2,\"172\":2,\"176\":2,\"205\":1,\"206\":3,\"212\":1,\"234\":1}}],[\"sizeetx\",{\"1\":{\"81\":8}}],[\"size<<1\",{\"1\":{\"52\":1}}],[\"size等涉及到数组大小查询\",{\"1\":{\"48\":1}}],[\"size\",{\"1\":{\"15\":1,\"35\":4,\"37\":2,\"52\":8,\"65\":3,\"80\":2,\"81\":1,\"111\":1,\"115\":3,\"131\":1,\"147\":1,\"153\":1,\"154\":1,\"168\":1,\"170\":5,\"172\":9,\"176\":1,\"180\":1,\"182\":1,\"188\":2,\"190\":2,\"198\":1,\"211\":4,\"212\":1,\"227\":1,\"232\":1,\"233\":2,\"238\":9,\"239\":6,\"272\":1,\"280\":2,\"282\":2,\"283\":1,\"287\":1,\"291\":1,\"314\":2,\"346\":3,\"383\":3,\"387\":7,\"390\":2,\"437\":2,\"438\":3,\"441\":2,\"451\":6,\"453\":9,\"455\":4,\"456\":6,\"457\":3,\"459\":13,\"462\":1}}],[\"synthetic\",{\"1\":{\"281\":2}}],[\"synccall\",{\"1\":{\"198\":1}}],[\"synchronize\",{\"1\":{\"318\":1}}],[\"synchronize实现的原理是锁定指定的对象\",{\"1\":{\"317\":1}}],[\"synchronized\",{\"1\":{\"36\":2,\"43\":1,\"80\":3,\"272\":1,\"294\":2,\"297\":3,\"363\":1}}],[\"synchronously\",{\"1\":{\"216\":1,\"376\":1}}],[\"synchronousfuture<networkimage>\",{\"1\":{\"196\":1}}],[\"synchronouscall\",{\"1\":{\"192\":2}}],[\"sync\",{\"1\":{\"95\":2,\"102\":3,\"115\":1,\"302\":1,\"378\":1}}],[\"symbolic\",{\"1\":{\"275\":1,\"278\":1}}],[\"sys\",{\"1\":{\"369\":4,\"371\":3}}],[\"sysdir\",{\"1\":{\"272\":1}}],[\"syscall\",{\"1\":{\"60\":1}}],[\"systemserver\",{\"1\":{\"60\":1}}],[\"systemserver进程\",{\"1\":{\"60\":1}}],[\"systemclock\",{\"1\":{\"11\":1,\"30\":1}}],[\"system\",{\"1\":{\"10\":1,\"49\":2,\"59\":1,\"97\":1,\"254\":1,\"272\":3,\"281\":2,\"282\":1,\"288\":4,\"289\":6,\"294\":4,\"295\":2,\"297\":3,\"306\":3,\"308\":1,\"309\":4,\"327\":2,\"345\":1,\"349\":1,\"386\":1,\"392\":1,\"395\":1,\"453\":3}}],[\"sylvanassun\",{\"1\":{\"58\":1}}],[\"syif88\",{\"1\":{\"54\":1}}],[\"sortarr\",{\"1\":{\"451\":6}}],[\"sort\",{\"1\":{\"361\":1}}],[\"softreference\",{\"1\":{\"269\":2}}],[\"softwrap\",{\"1\":{\"117\":2,\"125\":1,\"127\":2}}],[\"software\",{\"1\":{\"57\":1}}],[\"solt\",{\"1\":{\"128\":1}}],[\"soup\",{\"1\":{\"371\":6}}],[\"sounds\",{\"1\":{\"133\":1}}],[\"sound\",{\"1\":{\"111\":2}}],[\"source加载到vm的过程\",{\"1\":{\"394\":1}}],[\"source加载到vm中\",{\"0\":{\"393\":1}}],[\"source编译为kernel\",{\"1\":{\"393\":1}}],[\"source编译为为kernel\",{\"1\":{\"393\":1}}],[\"source的唯一方式\",{\"1\":{\"393\":1}}],[\"sources\",{\"1\":{\"367\":1}}],[\"sourcesets\",{\"1\":{\"32\":1}}],[\"source是要加密的内容\",{\"1\":{\"296\":1}}],[\"source\",{\"1\":{\"13\":1,\"40\":1,\"103\":7,\"115\":4,\"287\":1,\"296\":2,\"298\":1,\"367\":1,\"373\":1,\"381\":2,\"382\":2,\"383\":10,\"387\":1,\"388\":2,\"392\":3,\"415\":3,\"417\":1}}],[\"soon\",{\"1\":{\"101\":1}}],[\"somewhat\",{\"1\":{\"225\":1}}],[\"someone\",{\"1\":{\"202\":1}}],[\"someotherapplication\",{\"1\":{\"14\":1}}],[\"some\",{\"1\":{\"111\":1,\"383\":1,\"391\":1}}],[\"sometime\",{\"1\":{\"80\":1}}],[\"socket机制\",{\"1\":{\"60\":1}}],[\"socket用于进程间\",{\"1\":{\"60\":1}}],[\"socket\",{\"1\":{\"58\":2,\"60\":1,\"108\":6,\"115\":4,\"370\":1}}],[\"so\",{\"1\":{\"13\":3,\"59\":2,\"75\":1,\"101\":1,\"105\":1,\"112\":1,\"115\":1,\"118\":1,\"125\":1,\"126\":1,\"131\":1,\"186\":1,\"198\":3,\"216\":1,\"221\":1,\"225\":1,\"275\":1,\"308\":1,\"376\":1,\"391\":2}}],[\"sealed\",{\"1\":{\"322\":4}}],[\"searchbar\",{\"1\":{\"56\":2}}],[\"search\",{\"1\":{\"45\":1,\"49\":2,\"56\":2}}],[\"sequence多级操作是逐个item依次完整执行多级操作的\",{\"1\":{\"328\":1}}],[\"sequence\",{\"1\":{\"327\":1,\"328\":1,\"335\":1}}],[\"sequence<int>\",{\"1\":{\"327\":1}}],[\"sequences\",{\"1\":{\"308\":1}}],[\"sequeue\",{\"1\":{\"95\":1}}],[\"seven\",{\"1\":{\"302\":1}}],[\"several\",{\"1\":{\"220\":1}}],[\"se5被引入\",{\"1\":{\"290\":1}}],[\"se13\",{\"1\":{\"281\":1}}],[\"se9\",{\"1\":{\"274\":1}}],[\"selectsort\",{\"1\":{\"456\":1}}],[\"select延迟值可以使用\",{\"1\":{\"334\":1}}],[\"select<unit>\",{\"1\":{\"334\":2}}],[\"selectfizzbuzz\",{\"1\":{\"334\":1}}],[\"select\",{\"1\":{\"289\":2,\"334\":4}}],[\"selectiverebuildwidgetstate\",{\"1\":{\"130\":2}}],[\"selectiverebuildwidget\",{\"1\":{\"130\":3}}],[\"self\",{\"1\":{\"96\":1,\"115\":1,\"369\":9,\"370\":16,\"371\":15,\"387\":2}}],[\"semanticchildcount\",{\"1\":{\"227\":2}}],[\"semanticlabel\",{\"1\":{\"193\":2,\"206\":2,\"207\":2}}],[\"semantics\",{\"1\":{\"193\":1}}],[\"semanticslabel\",{\"1\":{\"125\":1}}],[\"semanticsbinding\",{\"1\":{\"118\":2,\"119\":1}}],[\"semaphore\",{\"1\":{\"58\":1}}],[\"secretkey\",{\"1\":{\"296\":1}}],[\"secretkeyspec\",{\"1\":{\"296\":4}}],[\"securerandom\",{\"1\":{\"296\":1}}],[\"securitykey\",{\"1\":{\"296\":2}}],[\"security\",{\"1\":{\"295\":1,\"423\":1}}],[\"section\",{\"1\":{\"108\":1}}],[\"secondheropage\",{\"1\":{\"170\":3,\"172\":1}}],[\"seconds\",{\"1\":{\"80\":2,\"95\":1,\"101\":5,\"153\":1,\"373\":2}}],[\"second\",{\"1\":{\"10\":2,\"101\":1,\"170\":1,\"285\":2,\"302\":1}}],[\"see\",{\"1\":{\"108\":1,\"121\":1,\"220\":1,\"233\":1,\"308\":1,\"372\":1}}],[\"sense\",{\"1\":{\"322\":1}}],[\"sentineltimer\",{\"1\":{\"106\":1}}],[\"sendoob\",{\"1\":{\"376\":4}}],[\"sendsuccessresultcallback\",{\"1\":{\"365\":2}}],[\"sendfailresultcallback\",{\"1\":{\"365\":4}}],[\"sendchannel<int>\",{\"1\":{\"334\":1}}],[\"sendchannel\",{\"1\":{\"334\":1}}],[\"sendisolatestartupmessage\",{\"1\":{\"383\":1}}],[\"sendimagestateevent向\",{\"1\":{\"211\":1}}],[\"sending\",{\"1\":{\"108\":1,\"328\":1,\"372\":1,\"391\":1}}],[\"sendinguid\",{\"1\":{\"43\":1}}],[\"sender\",{\"1\":{\"108\":4}}],[\"senddata\",{\"1\":{\"108\":7}}],[\"sendport等绑定\",{\"1\":{\"383\":1}}],[\"sendport等传递数据\",{\"1\":{\"136\":1}}],[\"sendport发送response消息\",{\"1\":{\"376\":1}}],[\"sendportptr\",{\"1\":{\"116\":2}}],[\"sendport>\",{\"1\":{\"112\":2}}],[\"sendport进行跨isolate通信\",{\"1\":{\"111\":1}}],[\"sendportgetid\",{\"1\":{\"108\":1}}],[\"sendport是由\",{\"1\":{\"114\":1}}],[\"sendport是\",{\"1\":{\"106\":1}}],[\"sendport\",{\"1\":{\"106\":7,\"107\":2,\"108\":4,\"109\":1,\"111\":3,\"112\":9,\"114\":2,\"116\":9,\"372\":1,\"373\":3,\"376\":4,\"377\":2,\"378\":18,\"389\":6}}],[\"sendtotarget\",{\"1\":{\"80\":1}}],[\"sendmessageattime\",{\"1\":{\"30\":1}}],[\"sendmessagedelayed\",{\"1\":{\"30\":2}}],[\"sendmessage\",{\"0\":{\"28\":1},\"1\":{\"28\":1,\"31\":1,\"43\":1}}],[\"send\",{\"1\":{\"20\":3,\"43\":4,\"106\":2,\"107\":3,\"108\":5,\"109\":1,\"111\":2,\"112\":2,\"114\":3,\"115\":3,\"328\":3,\"334\":3,\"373\":1,\"376\":1,\"382\":1,\"389\":3}}],[\"separate\",{\"1\":{\"98\":1,\"136\":1,\"327\":1}}],[\"serialized\",{\"1\":{\"308\":3,\"309\":2,\"392\":2}}],[\"serializableclass1\",{\"1\":{\"309\":5}}],[\"serializableclass\",{\"1\":{\"305\":3,\"308\":10,\"309\":12}}],[\"serializable接口没有任何方法\",{\"1\":{\"303\":1}}],[\"serializable\",{\"0\":{\"303\":1},\"1\":{\"285\":1,\"287\":1,\"303\":1,\"305\":1,\"308\":1,\"312\":2}}],[\"serialization\",{\"1\":{\"80\":1,\"316\":2}}],[\"serialversionuid\",{\"0\":{\"304\":1},\"1\":{\"304\":1}}],[\"serialexecutor主要的作用是将这些线程放到线程池中\",{\"1\":{\"80\":1}}],[\"serialexecutor\",{\"1\":{\"80\":2}}],[\"serial\",{\"1\":{\"80\":3,\"298\":1,\"303\":1,\"306\":1,\"309\":1}}],[\"server通过持有的0号引用binder和servermanager通信\",{\"1\":{\"58\":1}}],[\"server创建一个binder和对应名字\",{\"1\":{\"58\":1}}],[\"servermanager查询到已经注册的内核binder引用并将其发给client\",{\"1\":{\"58\":1}}],[\"servermanager收到内核中的binder对象引用及名字后将其保存到查找表中\",{\"1\":{\"58\":1}}],[\"servermanager\",{\"1\":{\"58\":1}}],[\"server\",{\"0\":{\"246\":1},\"1\":{\"40\":2,\"58\":2,\"209\":1,\"246\":2,\"414\":1}}],[\"service的isolate使用cfe将dart\",{\"1\":{\"393\":1}}],[\"serviceisolate\",{\"1\":{\"383\":5}}],[\"servicesbinding\",{\"1\":{\"118\":2,\"119\":1}}],[\"service同通信\",{\"1\":{\"114\":1}}],[\"service是做什么的\",{\"1\":{\"112\":1}}],[\"service中转\",{\"0\":{\"112\":1}}],[\"service中的方法\",{\"1\":{\"17\":1}}],[\"serviceport时\",{\"1\":{\"115\":1}}],[\"serviceport之后\",{\"1\":{\"114\":1}}],[\"serviceport的获取过程\",{\"1\":{\"112\":1}}],[\"serviceport和native层通信\",{\"1\":{\"112\":1}}],[\"serviceport\",{\"1\":{\"111\":2,\"112\":2,\"115\":2,\"116\":1}}],[\"serviceports以便获取sendport\",{\"1\":{\"112\":1}}],[\"serviceports对native层发送消息触发io操作\",{\"1\":{\"111\":1}}],[\"serviceports获取一个新的sendport以便向ioservice发送消息\",{\"1\":{\"111\":1,\"112\":1}}],[\"serviceports\",{\"1\":{\"111\":3,\"112\":4,\"115\":1}}],[\"service返回给dart用来向他发消息的\",{\"1\":{\"111\":1,\"112\":1}}],[\"service发送消息\",{\"1\":{\"111\":1,\"112\":2}}],[\"service进行异步通信\",{\"1\":{\"111\":1}}],[\"service通信\",{\"1\":{\"111\":1}}],[\"service那里异步获得文件句柄response和path\",{\"1\":{\"111\":1}}],[\"service而发送请求到native端\",{\"1\":{\"110\":1}}],[\"servicemanager\",{\"1\":{\"58\":1}}],[\"service真正的完全详解\",{\"1\":{\"21\":1}}],[\"service实现一个handler\",{\"1\":{\"20\":1}}],[\"service与不同进程通信\",{\"1\":{\"20\":1}}],[\"service服务端\",{\"1\":{\"19\":1}}],[\"service绑定服务的三种方式\",{\"0\":{\"18\":1}}],[\"service因内存不足被杀死\",{\"1\":{\"17\":2}}],[\"service在handler接收并处理message\",{\"1\":{\"20\":1}}],[\"service在内存不足被杀死后\",{\"1\":{\"17\":1}}],[\"service在androidmanifest\",{\"1\":{\"17\":1}}],[\"service默认运行在创建他的线程中\",{\"1\":{\"17\":1}}],[\"service也会被销毁\",{\"1\":{\"17\":1}}],[\"serviceconnection\",{\"1\":{\"17\":2,\"19\":2,\"20\":1,\"35\":5,\"43\":1,\"58\":2}}],[\"service>\",{\"1\":{\"17\":1}}],[\"service\",{\"1\":{\"10\":1,\"11\":1,\"12\":1,\"17\":4,\"19\":4,\"20\":4,\"35\":2,\"36\":2,\"43\":3,\"54\":1,\"58\":4,\"78\":1,\"81\":1,\"82\":7,\"83\":3,\"84\":1,\"85\":5,\"86\":3,\"87\":2,\"111\":6,\"112\":8,\"114\":5,\"115\":9,\"116\":1,\"382\":1,\"387\":5,\"391\":2,\"392\":1,\"393\":2}}],[\"setkernelisolate\",{\"1\":{\"383\":1}}],[\"setunregisterkernelblobcallback\",{\"1\":{\"382\":1}}],[\"setupcorelibraries\",{\"1\":{\"382\":1}}],[\"setup注册\",{\"1\":{\"211\":1}}],[\"setup\",{\"1\":{\"211\":3,\"383\":1}}],[\"setuphooks\",{\"1\":{\"105\":1,\"108\":1}}],[\"setuprepeatalarmclock\",{\"1\":{\"11\":1}}],[\"setupdailyalarmclock\",{\"1\":{\"10\":1}}],[\"setgroupcleanupcallback\",{\"1\":{\"382\":1}}],[\"setvalue\",{\"1\":{\"322\":2}}],[\"set方法放到一个地方实现\",{\"1\":{\"322\":1}}],[\"setobject\",{\"1\":{\"305\":1}}],[\"setonclickpendingintent\",{\"1\":{\"79\":1}}],[\"setonclicklistener\",{\"1\":{\"56\":1,\"71\":1,\"345\":2}}],[\"setonindexclicklistener\",{\"1\":{\"64\":1}}],[\"setblockdatamode\",{\"1\":{\"305\":1,\"312\":2}}],[\"setbackgroundresource\",{\"1\":{\"66\":1}}],[\"setinitializecallback\",{\"1\":{\"382\":1}}],[\"setinitialized\",{\"1\":{\"382\":1}}],[\"setinitializing\",{\"1\":{\"382\":1}}],[\"setinitialvalue\",{\"1\":{\"288\":1}}],[\"setimagebitmap\",{\"1\":{\"77\":1}}],[\"setimgleftonclicklistener\",{\"1\":{\"56\":2}}],[\"set<k>\",{\"1\":{\"287\":1}}],[\"set<map\",{\"1\":{\"280\":1,\"287\":1}}],[\"setnumarguments\",{\"1\":{\"383\":1}}],[\"setnewonclicklistener\",{\"1\":{\"345\":2}}],[\"setnegativebutton\",{\"1\":{\"69\":1}}],[\"setname\",{\"1\":{\"115\":2}}],[\"setlastmodified\",{\"1\":{\"115\":1}}],[\"setlastaccessed\",{\"1\":{\"115\":1}}],[\"setlayertype\",{\"1\":{\"57\":1}}],[\"setat\",{\"1\":{\"115\":2,\"376\":1,\"377\":3,\"389\":8}}],[\"setactiveapicall\",{\"1\":{\"115\":1}}],[\"setactive\",{\"1\":{\"106\":1}}],[\"setaction\",{\"1\":{\"13\":2,\"78\":1}}],[\"setaccessible\",{\"1\":{\"72\":6,\"295\":3,\"300\":2}}],[\"setregisterkernelblobcallback\",{\"1\":{\"382\":1}}],[\"setreturnvalue\",{\"1\":{\"114\":2}}],[\"setrepeating\",{\"1\":{\"5\":1,\"6\":1,\"10\":1,\"11\":1}}],[\"setserviceisolate\",{\"1\":{\"383\":1}}],[\"setshutdowncallback\",{\"1\":{\"382\":1}}],[\"setshader\",{\"1\":{\"63\":1}}],[\"sets\",{\"1\":{\"225\":1,\"391\":1}}],[\"setstreamhandler\",{\"1\":{\"211\":1}}],[\"setstate\",{\"1\":{\"128\":1,\"130\":2,\"134\":1,\"135\":1,\"136\":2,\"152\":1,\"155\":1,\"176\":2,\"192\":1,\"216\":1}}],[\"setstacksize\",{\"1\":{\"115\":1}}],[\"setscheduleimmediateclosure返回\",{\"1\":{\"100\":1}}],[\"setscheduleimmediateclosure\",{\"1\":{\"99\":1,\"100\":3}}],[\"setparent\",{\"0\":{\"218\":1},\"1\":{\"213\":2,\"217\":1,\"218\":1}}],[\"setpriority\",{\"1\":{\"115\":1}}],[\"setportstate\",{\"1\":{\"115\":1}}],[\"setposition\",{\"1\":{\"115\":1}}],[\"setpositivebutton\",{\"1\":{\"69\":2}}],[\"setpendingintent\",{\"1\":{\"79\":1}}],[\"setdefaultencoding\",{\"1\":{\"371\":1}}],[\"setdrawingcacheenabled\",{\"1\":{\"77\":1}}],[\"setdata\",{\"1\":{\"20\":1}}],[\"setdataandtype\",{\"1\":{\"2\":1}}],[\"setmethodcallhandler\",{\"1\":{\"135\":1,\"211\":1}}],[\"setmessage\",{\"1\":{\"69\":2}}],[\"setmeasureddimension\",{\"1\":{\"65\":1}}],[\"setxfermode\",{\"1\":{\"65\":2}}],[\"setflags\",{\"1\":{\"65\":1}}],[\"setwillnotdraw\",{\"1\":{\"65\":2}}],[\"setwindow\",{\"1\":{\"3\":1}}],[\"setcleanupcallback\",{\"1\":{\"382\":1}}],[\"setcreategroupcallback\",{\"1\":{\"382\":1}}],[\"setcandrag\",{\"1\":{\"223\":4}}],[\"setcancelable\",{\"1\":{\"69\":2}}],[\"setchildparentdata\",{\"1\":{\"213\":1}}],[\"setchooseid\",{\"1\":{\"64\":1}}],[\"setcurrent\",{\"1\":{\"115\":1}}],[\"setcompleter\",{\"1\":{\"202\":1}}],[\"setcomponent\",{\"1\":{\"35\":1,\"72\":1}}],[\"setcolor\",{\"1\":{\"64\":4,\"65\":2}}],[\"setcontentview\",{\"1\":{\"13\":2,\"66\":1,\"79\":1,\"93\":1,\"401\":2}}],[\"setter\",{\"1\":{\"236\":1}}],[\"settext\",{\"1\":{\"301\":1}}],[\"settextalign\",{\"1\":{\"64\":1}}],[\"settextsize\",{\"1\":{\"56\":1,\"64\":1}}],[\"settitle\",{\"1\":{\"69\":2}}],[\"settings\",{\"1\":{\"78\":2,\"345\":1,\"347\":1,\"378\":1,\"417\":1}}],[\"setting\",{\"1\":{\"15\":1,\"115\":1}}],[\"set\",{\"1\":{\"1\":1,\"10\":4,\"24\":1,\"58\":1,\"64\":3,\"65\":1,\"72\":2,\"80\":1,\"102\":3,\"109\":1,\"111\":1,\"115\":2,\"118\":1,\"136\":1,\"198\":1,\"220\":1,\"237\":1,\"288\":8,\"295\":1,\"300\":1,\"302\":2,\"322\":4,\"325\":2,\"358\":3,\"369\":2,\"378\":2,\"383\":2,\"389\":2,\"396\":1,\"417\":1,\"426\":1}}],[\"stepsize\",{\"1\":{\"428\":2}}],[\"step\",{\"1\":{\"389\":3}}],[\"steptween\",{\"1\":{\"184\":1}}],[\"still\",{\"1\":{\"181\":1,\"202\":1,\"242\":1,\"272\":1,\"383\":1,\"391\":4}}],[\"sticky\",{\"1\":{\"17\":2}}],[\"stderr\",{\"1\":{\"361\":1}}],[\"stdout\",{\"1\":{\"361\":1}}],[\"stdin\",{\"1\":{\"361\":1}}],[\"std\",{\"1\":{\"115\":12,\"379\":2,\"380\":2,\"384\":2,\"387\":1,\"388\":2,\"389\":4,\"390\":1,\"391\":7}}],[\"st\",{\"1\":{\"102\":3,\"378\":2}}],[\"strcmp\",{\"1\":{\"383\":1,\"387\":3}}],[\"strdup\",{\"1\":{\"382\":4,\"383\":2,\"389\":2}}],[\"strs\",{\"1\":{\"327\":4}}],[\"str\",{\"1\":{\"254\":1,\"370\":2,\"371\":1}}],[\"streamcorruptedexception\",{\"1\":{\"305\":1}}],[\"streamcontroller<imagechunkevent>\",{\"1\":{\"196\":2,\"201\":4}}],[\"streamsubscription\",{\"1\":{\"211\":2}}],[\"streamlistener\",{\"1\":{\"198\":4}}],[\"stream\",{\"1\":{\"193\":1,\"196\":2,\"201\":1,\"202\":5,\"309\":1,\"328\":2}}],[\"stream流等\",{\"1\":{\"95\":1}}],[\"structurally\",{\"1\":{\"276\":1}}],[\"structure\",{\"1\":{\"105\":1,\"198\":1,\"199\":1,\"279\":1,\"287\":1,\"383\":1}}],[\"strutstyle\",{\"1\":{\"125\":1,\"127\":2}}],[\"stringbuilder\",{\"1\":{\"453\":8}}],[\"stringbuffer\",{\"1\":{\"296\":5}}],[\"stringtocstring\",{\"1\":{\"382\":1}}],[\"stringtag\",{\"1\":{\"58\":1}}],[\"string2utf8\",{\"1\":{\"379\":1,\"384\":2}}],[\"string等\",{\"1\":{\"369\":1}}],[\"strings\",{\"1\":{\"327\":1}}],[\"string=\",{\"1\":{\"311\":1}}],[\"string类型\",{\"1\":{\"299\":1}}],[\"string数组\",{\"1\":{\"291\":1}}],[\"string在运行期有没有限制呢\",{\"1\":{\"283\":1}}],[\"string>\",{\"1\":{\"69\":1,\"201\":1,\"364\":4,\"378\":2}}],[\"string\",{\"0\":{\"283\":1},\"1\":{\"2\":2,\"7\":1,\"15\":1,\"40\":3,\"42\":1,\"55\":3,\"58\":3,\"64\":3,\"72\":1,\"78\":2,\"85\":4,\"86\":2,\"110\":2,\"111\":2,\"126\":1,\"135\":1,\"136\":1,\"165\":1,\"172\":1,\"185\":1,\"188\":1,\"201\":5,\"202\":1,\"211\":10,\"254\":3,\"272\":4,\"281\":1,\"282\":2,\"283\":2,\"285\":2,\"291\":2,\"295\":5,\"296\":7,\"305\":2,\"306\":1,\"308\":4,\"311\":8,\"312\":2,\"321\":4,\"322\":18,\"327\":1,\"345\":3,\"364\":2,\"378\":11,\"384\":3,\"389\":2,\"400\":2,\"427\":1,\"429\":1,\"453\":3,\"459\":3}}],[\"stuff\",{\"1\":{\"220\":2,\"280\":1}}],[\"studio自动生成的parcelable代码不会处理val变量\",{\"1\":{\"313\":1}}],[\"studio\",{\"1\":{\"54\":1,\"347\":5,\"348\":3}}],[\"stub查询是否有entry与receiver的类匹配\",{\"1\":{\"395\":1}}],[\"stubcode\",{\"1\":{\"383\":3}}],[\"stub类我们可以联想到这里应该有一个aidl实现\",{\"1\":{\"43\":1}}],[\"stub\",{\"1\":{\"35\":4,\"36\":2,\"40\":6,\"43\":3,\"58\":12,\"79\":5,\"295\":2,\"395\":1}}],[\"store\",{\"1\":{\"202\":1,\"317\":1,\"383\":15,\"384\":1}}],[\"stores\",{\"1\":{\"134\":1}}],[\"storenonpointer\",{\"1\":{\"116\":2}}],[\"storage\",{\"1\":{\"2\":3,\"283\":1,\"383\":1}}],[\"stopping\",{\"1\":{\"391\":2}}],[\"stopped\",{\"1\":{\"383\":1}}],[\"stopimagerequests\",{\"1\":{\"211\":1}}],[\"stop\",{\"1\":{\"163\":1,\"164\":1,\"168\":1,\"322\":1,\"414\":1}}],[\"stopwatch\",{\"1\":{\"105\":1}}],[\"stopd\",{\"1\":{\"63\":2}}],[\"stopforeground\",{\"1\":{\"21\":1}}],[\"sthreadfactory\",{\"1\":{\"80\":1}}],[\"sthreadlocal\",{\"1\":{\"24\":2,\"26\":1}}],[\"sth\",{\"1\":{\"20\":2,\"56\":1,\"78\":1}}],[\"style>\",{\"1\":{\"66\":1}}],[\"styleable>\",{\"1\":{\"56\":1}}],[\"styleable\",{\"1\":{\"56\":5,\"64\":2}}],[\"style\",{\"1\":{\"15\":1,\"63\":2,\"66\":1,\"125\":1,\"126\":6,\"131\":1,\"143\":1}}],[\"star\",{\"1\":{\"322\":1,\"326\":1}}],[\"startdestination定义了在这个导航图中首次启动展示的界面\",{\"1\":{\"400\":1}}],[\"startdestination=\",{\"1\":{\"400\":1}}],[\"start方法中创建了一个新的系统线程\",{\"1\":{\"391\":1}}],[\"start中使用\",{\"1\":{\"389\":1}}],[\"start=\",{\"1\":{\"382\":1}}],[\"startup\",{\"0\":{\"361\":1},\"1\":{\"360\":1,\"396\":1}}],[\"startloadingwitharguments执行刚刚上一步创建的请求\",{\"1\":{\"211\":1}}],[\"startloadingwitharguments\",{\"1\":{\"211\":2}}],[\"startloading\",{\"1\":{\"211\":3}}],[\"startlistening\",{\"1\":{\"211\":2}}],[\"start执行动画\",{\"1\":{\"181\":1}}],[\"startherotransition方法中通过hero\",{\"1\":{\"181\":1}}],[\"startherotransition\",{\"0\":{\"180\":1},\"1\":{\"179\":2,\"180\":1}}],[\"startfunction\",{\"1\":{\"389\":1}}],[\"startflight方法\",{\"1\":{\"181\":1}}],[\"startflight\",{\"1\":{\"176\":3,\"181\":2}}],[\"startforeground\",{\"1\":{\"21\":2}}],[\"started\",{\"1\":{\"115\":3,\"177\":1,\"391\":1}}],[\"start每个端不一样\",{\"1\":{\"115\":1}}],[\"startisolatescope\",{\"1\":{\"391\":2}}],[\"startisolate\",{\"1\":{\"378\":2,\"389\":1}}],[\"startimagerequests的情况\",{\"1\":{\"211\":1}}],[\"startimagerequests\",{\"1\":{\"211\":6}}],[\"starting\",{\"1\":{\"115\":1,\"181\":1,\"302\":1,\"378\":1,\"383\":1,\"389\":1}}],[\"startid\",{\"1\":{\"17\":1}}],[\"startcallback\",{\"1\":{\"115\":1,\"389\":1}}],[\"startmicrotaskloop触发的实际是通过\",{\"1\":{\"100\":1}}],[\"startmicrotaskloop方法在\",{\"1\":{\"100\":1}}],[\"startmicrotaskloop方法是实际上处理microtask的地方\",{\"1\":{\"98\":1}}],[\"startmicrotaskloop\",{\"0\":{\"98\":1},\"1\":{\"97\":1,\"98\":2,\"99\":1,\"100\":1,\"101\":1}}],[\"startactivity做了拦截\",{\"1\":{\"72\":1}}],[\"startactivity\",{\"1\":{\"71\":1,\"72\":1,\"78\":1}}],[\"startpoint\",{\"1\":{\"62\":4,\"63\":10}}],[\"starts\",{\"1\":{\"198\":1,\"378\":1,\"387\":1}}],[\"startsimulation\",{\"0\":{\"162\":1},\"1\":{\"161\":2,\"162\":2}}],[\"startscroll\",{\"1\":{\"41\":3}}],[\"startservice\",{\"1\":{\"17\":2}}],[\"start后检测到已经超时或其他满足取消条件的情况\",{\"1\":{\"12\":1}}],[\"start后去开启任务\",{\"1\":{\"11\":1}}],[\"startthread的第二个参数\",{\"1\":{\"391\":1}}],[\"startthread\",{\"1\":{\"115\":1,\"389\":2,\"391\":1}}],[\"startt\",{\"1\":{\"11\":1}}],[\"starttime\",{\"1\":{\"10\":3,\"11\":1,\"110\":2,\"111\":1,\"327\":2}}],[\"start\",{\"0\":{\"244\":1},\"1\":{\"10\":2,\"11\":2,\"17\":5,\"48\":1,\"63\":1,\"110\":1,\"115\":17,\"126\":1,\"162\":2,\"179\":1,\"180\":3,\"181\":1,\"288\":2,\"327\":7,\"345\":1,\"368\":1,\"370\":3,\"383\":2,\"387\":1,\"389\":7,\"390\":2,\"391\":11}}],[\"stage\",{\"1\":{\"181\":1}}],[\"standard\",{\"0\":{\"170\":1},\"1\":{\"302\":1}}],[\"stable\",{\"1\":{\"141\":1}}],[\"stacks\",{\"1\":{\"437\":6}}],[\"stackzone\",{\"1\":{\"383\":2,\"389\":2}}],[\"stack是为native方法服务\",{\"1\":{\"253\":1}}],[\"stackoverflow\",{\"1\":{\"251\":1,\"253\":1,\"281\":1,\"282\":1,\"286\":1}}],[\"stack\",{\"0\":{\"251\":1,\"252\":1,\"253\":1},\"1\":{\"102\":3,\"121\":1,\"126\":2,\"139\":1,\"144\":1,\"145\":1,\"170\":1,\"171\":1,\"249\":1,\"252\":2,\"257\":1,\"391\":1,\"396\":1}}],[\"stacktrace\",{\"1\":{\"95\":1,\"102\":10,\"103\":3,\"145\":1,\"191\":2,\"198\":1}}],[\"stats\",{\"1\":{\"272\":1}}],[\"statsync\",{\"1\":{\"201\":1}}],[\"statck\",{\"1\":{\"249\":1}}],[\"stat\",{\"1\":{\"115\":1}}],[\"states\",{\"1\":{\"226\":1}}],[\"stateerror\",{\"1\":{\"153\":1,\"201\":1}}],[\"state<nestedscrollview>\",{\"1\":{\"213\":1}}],[\"state<powerexternalimage>\",{\"1\":{\"207\":1}}],[\"state<powertextureimage>\",{\"1\":{\"206\":1}}],[\"state<powerimage>\",{\"1\":{\"205\":1}}],[\"state<productmanager>\",{\"1\":{\"134\":1}}],[\"state<materialapp>\",{\"1\":{\"178\":1}}],[\"state<animatedwidget>\",{\"1\":{\"155\":1}}],[\"state<alwaysrebuildwidget>\",{\"1\":{\"130\":2}}],[\"state<t>\",{\"1\":{\"147\":1}}],[\"state<bodywidget>\",{\"1\":{\"131\":1}}],[\"state<sampleapppage>\",{\"1\":{\"135\":1}}],[\"state<statefulwidget>\",{\"1\":{\"131\":1,\"134\":1}}],[\"state<selectiverebuildwidget>\",{\"1\":{\"130\":2}}],[\"state<changestatebutton>\",{\"1\":{\"130\":2}}],[\"statefulwidget中可以调用setstate\",{\"1\":{\"134\":1}}],[\"statefulwidget可以通过动态更改其包含的state\",{\"1\":{\"134\":1}}],[\"statefulwidget\",{\"0\":{\"134\":1},\"1\":{\"130\":4,\"131\":1,\"134\":3,\"147\":2,\"154\":1,\"175\":2,\"189\":1,\"206\":1,\"207\":1,\"213\":2}}],[\"statefulelement\",{\"1\":{\"128\":2}}],[\"state之类的持有\",{\"1\":{\"128\":1}}],[\"stateless\",{\"1\":{\"193\":1}}],[\"statelesswidget要想实现动态更新其内容\",{\"1\":{\"134\":1}}],[\"statelesswidget一旦创建便不会更改\",{\"1\":{\"133\":1}}],[\"statelesswidget和statefulwidget区别在于\",{\"1\":{\"132\":1}}],[\"statelesswidget和statefulwidget\",{\"1\":{\"132\":1}}],[\"statelesswidget和statefulwidget在创建之后就不会再变化\",{\"1\":{\"128\":1}}],[\"statelesswidget\",{\"0\":{\"133\":1},\"1\":{\"126\":4,\"130\":2,\"132\":1,\"133\":2,\"134\":1,\"143\":1,\"172\":1,\"227\":2,\"235\":1}}],[\"statelesselement应该是text\",{\"1\":{\"126\":1}}],[\"statelesselement\",{\"0\":{\"126\":1},\"1\":{\"117\":1,\"122\":2,\"126\":7,\"127\":1,\"128\":2}}],[\"stateignoreerror\",{\"1\":{\"103\":1}}],[\"stateincomplete\",{\"1\":{\"103\":1}}],[\"statependingcomplete\",{\"1\":{\"103\":2}}],[\"state\",{\"1\":{\"64\":7,\"78\":1,\"80\":2,\"103\":3,\"115\":1,\"116\":1,\"128\":1,\"130\":2,\"133\":1,\"134\":2,\"155\":2,\"161\":2,\"178\":1,\"184\":1,\"188\":1,\"193\":1,\"213\":2,\"224\":1,\"275\":1,\"306\":1,\"322\":1,\"379\":3,\"380\":7,\"381\":1,\"382\":4,\"383\":2,\"384\":5,\"386\":8,\"389\":17,\"391\":1}}],[\"statements\",{\"1\":{\"34\":1,\"58\":1}}],[\"statusforkey或者imageprovider\",{\"1\":{\"197\":1}}],[\"status\",{\"1\":{\"53\":1,\"80\":3,\"158\":4,\"162\":1,\"163\":1,\"167\":1,\"168\":1,\"181\":3,\"391\":28}}],[\"static\",{\"0\":{\"247\":1},\"1\":{\"2\":1,\"20\":2,\"24\":1,\"25\":1,\"26\":1,\"30\":1,\"35\":2,\"36\":1,\"40\":5,\"45\":1,\"49\":4,\"53\":2,\"58\":7,\"65\":1,\"72\":1,\"80\":5,\"98\":1,\"99\":2,\"101\":1,\"102\":2,\"104\":1,\"105\":6,\"106\":8,\"107\":1,\"108\":4,\"109\":2,\"111\":10,\"112\":11,\"115\":7,\"118\":1,\"130\":1,\"135\":1,\"136\":1,\"175\":1,\"177\":1,\"178\":1,\"210\":2,\"211\":5,\"273\":1,\"277\":3,\"280\":1,\"281\":1,\"282\":4,\"285\":7,\"287\":1,\"288\":3,\"294\":10,\"295\":1,\"296\":5,\"300\":1,\"304\":1,\"306\":1,\"308\":11,\"309\":5,\"311\":1,\"314\":1,\"363\":2,\"376\":1,\"377\":4,\"378\":7,\"382\":1,\"383\":3,\"387\":2,\"396\":1,\"453\":1}}],[\"ok\",{\"1\":{\"391\":1}}],[\"okhttp3\",{\"1\":{\"365\":1}}],[\"okhttp\",{\"1\":{\"362\":1,\"364\":3,\"365\":2}}],[\"okhttpclient相关\",{\"0\":{\"363\":1},\"1\":{\"362\":1}}],[\"okhttpclient\",{\"1\":{\"362\":8,\"363\":3}}],[\"okhttp是可以用于android和java的http框架\",{\"1\":{\"362\":1}}],[\"okhttprequest类的build方法则只是将其自身传递给okhttp3\",{\"1\":{\"364\":1}}],[\"okhttprequest\",{\"1\":{\"362\":1,\"364\":3}}],[\"okhttprequestbuilder的build\",{\"1\":{\"365\":1}}],[\"okhttprequestbuilder>的子类来收集\",{\"1\":{\"364\":1}}],[\"okhttprequestbuilder\",{\"1\":{\"362\":1}}],[\"okhttputils将初始化okhttpclient的动作提取出来\",{\"1\":{\"365\":1}}],[\"okhttputils本质上只是对okhttpclient的方法进行了一次封装\",{\"1\":{\"363\":1}}],[\"okhttputils就做到了这一点\",{\"1\":{\"362\":1}}],[\"okhttputils\",{\"1\":{\"362\":3,\"363\":3,\"365\":2}}],[\"okhttputils分析\",{\"0\":{\"362\":1}}],[\"occasionally\",{\"1\":{\"391\":1}}],[\"occur\",{\"1\":{\"391\":1}}],[\"occurred\",{\"1\":{\"389\":1}}],[\"occurs\",{\"1\":{\"114\":1,\"281\":2,\"389\":2}}],[\"o其他\",{\"1\":{\"351\":1}}],[\"oom\",{\"1\":{\"376\":1}}],[\"oop引用\",{\"1\":{\"285\":1}}],[\"oop指针\",{\"1\":{\"282\":2}}],[\"oob\",{\"1\":{\"115\":1,\"376\":3,\"391\":10}}],[\"oldvalue\",{\"1\":{\"322\":1}}],[\"oldmode\",{\"1\":{\"305\":1}}],[\"oldlayer\",{\"1\":{\"239\":1}}],[\"oldpixels\",{\"1\":{\"220\":2,\"221\":4}}],[\"oldposition\",{\"1\":{\"215\":3}}],[\"oldwidget\",{\"1\":{\"128\":2,\"130\":2,\"150\":3,\"155\":4,\"190\":1}}],[\"old\",{\"1\":{\"126\":2,\"128\":3,\"146\":1,\"157\":1}}],[\"oldams\",{\"1\":{\"72\":2}}],[\"owner\",{\"1\":{\"117\":1,\"121\":9,\"122\":2,\"124\":1,\"125\":1,\"126\":1,\"237\":2}}],[\"ownership\",{\"1\":{\"115\":1,\"121\":1,\"196\":1}}],[\"owning\",{\"1\":{\"115\":1}}],[\"owns\",{\"1\":{\"115\":1}}],[\"own\",{\"1\":{\"106\":1,\"154\":1,\"372\":5,\"426\":2}}],[\"otherwise\",{\"1\":{\"114\":1,\"115\":2,\"180\":1,\"389\":1,\"390\":1}}],[\"other\",{\"1\":{\"75\":1,\"97\":1,\"98\":1,\"102\":1,\"111\":2,\"112\":2,\"212\":1,\"219\":2,\"220\":2,\"278\":1,\"322\":1,\"327\":1,\"372\":1,\"382\":1,\"383\":1,\"387\":1,\"391\":3}}],[\"others\",{\"0\":{\"59\":1},\"1\":{\"373\":1}}],[\"our\",{\"1\":{\"108\":1,\"155\":1}}],[\"ourselves\",{\"1\":{\"65\":1}}],[\"outfilename\",{\"1\":{\"357\":1}}],[\"outmethod\",{\"1\":{\"281\":3}}],[\"outclass$1\",{\"1\":{\"281\":3}}],[\"outclass\",{\"1\":{\"281\":10}}],[\"out遵守box\",{\"1\":{\"237\":1}}],[\"outscrollposition\",{\"1\":{\"213\":1}}],[\"outside\",{\"1\":{\"186\":1,\"383\":1}}],[\"outerdelta\",{\"1\":{\"226\":15}}],[\"outer直接应用scrollactivity\",{\"1\":{\"225\":1}}],[\"outerscrollposition\",{\"1\":{\"223\":1}}],[\"outerposition调用了updatecandrag方法\",{\"1\":{\"223\":1}}],[\"outerposition\",{\"1\":{\"213\":3,\"223\":3,\"225\":7,\"226\":12}}],[\"outer\",{\"1\":{\"212\":2,\"217\":1,\"223\":1,\"225\":7,\"226\":5}}],[\"outercontroller\",{\"1\":{\"212\":1,\"213\":5,\"224\":1,\"226\":2}}],[\"outpoint\",{\"1\":{\"81\":4}}],[\"outputpath\",{\"1\":{\"357\":1}}],[\"output\",{\"1\":{\"40\":1,\"95\":1,\"302\":2,\"308\":1,\"309\":1,\"327\":3,\"370\":8,\"371\":7}}],[\"outputuri\",{\"1\":{\"2\":1}}],[\"outrect\",{\"1\":{\"64\":5}}],[\"out目录下生成ibookmanager\",{\"1\":{\"40\":1}}],[\"out\",{\"1\":{\"34\":1,\"57\":3,\"108\":2,\"115\":1,\"179\":1,\"180\":1,\"226\":1,\"237\":1,\"254\":1,\"280\":1,\"281\":2,\"282\":1,\"288\":4,\"289\":6,\"294\":4,\"295\":2,\"306\":8,\"308\":1,\"309\":3,\"310\":1,\"311\":5,\"322\":2,\"345\":1,\"370\":2,\"371\":1,\"383\":3,\"390\":1,\"391\":1,\"453\":2}}],[\"overhead\",{\"1\":{\"282\":1}}],[\"overscrolls\",{\"1\":{\"226\":3}}],[\"overscrollnotification\",{\"1\":{\"221\":1}}],[\"overscroll为0或者应用了delta之后会出现的越界值\",{\"1\":{\"220\":1}}],[\"overscroll时\",{\"1\":{\"220\":1}}],[\"overscrolled\",{\"1\":{\"220\":3,\"225\":1}}],[\"overscroll\",{\"1\":{\"220\":15,\"221\":8,\"226\":11}}],[\"overlap\",{\"1\":{\"213\":2}}],[\"overlay本质上是一个特殊的stack\",{\"1\":{\"181\":1}}],[\"overlayentry\",{\"1\":{\"181\":3}}],[\"overlaystate\",{\"1\":{\"180\":1}}],[\"overlay\",{\"1\":{\"57\":1,\"169\":1,\"170\":1,\"171\":4,\"173\":2,\"177\":1,\"180\":6,\"181\":4}}],[\"overflow异常\",{\"1\":{\"257\":1}}],[\"overflow\",{\"1\":{\"117\":1,\"125\":1,\"127\":2,\"252\":1,\"256\":1,\"257\":1,\"322\":1,\"391\":1}}],[\"overdue\",{\"1\":{\"109\":3}}],[\"over\",{\"1\":{\"57\":2,\"102\":1,\"147\":2,\"225\":1}}],[\"overrides\",{\"1\":{\"111\":3,\"387\":1}}],[\"override\",{\"1\":{\"13\":2,\"14\":1,\"17\":5,\"35\":4,\"36\":6,\"37\":2,\"40\":4,\"41\":1,\"42\":1,\"43\":4,\"55\":4,\"56\":2,\"58\":7,\"64\":4,\"69\":1,\"71\":2,\"72\":1,\"79\":6,\"80\":2,\"81\":1,\"92\":2,\"93\":1,\"118\":1,\"120\":2,\"121\":2,\"122\":2,\"125\":1,\"126\":3,\"127\":5,\"130\":10,\"131\":2,\"132\":1,\"133\":1,\"134\":2,\"135\":3,\"143\":1,\"147\":1,\"152\":3,\"153\":3,\"155\":5,\"156\":1,\"165\":1,\"172\":1,\"178\":2,\"183\":3,\"184\":2,\"185\":2,\"186\":2,\"196\":2,\"201\":1,\"205\":1,\"206\":2,\"207\":3,\"210\":2,\"211\":12,\"213\":2,\"219\":1,\"223\":2,\"226\":1,\"228\":5,\"230\":1,\"233\":2,\"236\":2,\"237\":2,\"239\":1,\"240\":1,\"272\":1,\"288\":1,\"298\":1,\"308\":1,\"311\":3,\"314\":4,\"345\":1,\"362\":2,\"364\":1,\"365\":3,\"380\":1,\"384\":1,\"386\":1,\"429\":1}}],[\"o++\",{\"1\":{\"48\":1}}],[\"o\",{\"1\":{\"48\":5,\"129\":1,\"136\":1,\"281\":2,\"282\":2,\"300\":2,\"321\":2,\"365\":2,\"442\":3,\"455\":1,\"456\":1,\"457\":1}}],[\"observed\",{\"1\":{\"396\":2}}],[\"observable\",{\"1\":{\"321\":1}}],[\"observatory\",{\"1\":{\"115\":1,\"391\":2}}],[\"objarr2\",{\"1\":{\"291\":2}}],[\"objarr1\",{\"1\":{\"291\":2}}],[\"objarr\",{\"1\":{\"291\":2}}],[\"obj\",{\"1\":{\"40\":4,\"58\":4,\"72\":1,\"80\":1,\"305\":7,\"309\":14,\"312\":11,\"383\":3,\"389\":10}}],[\"object修饰的类\",{\"1\":{\"321\":1}}],[\"object伴生对象\",{\"1\":{\"321\":1}}],[\"objectinput\",{\"1\":{\"310\":1,\"311\":1}}],[\"objectinputstream\",{\"1\":{\"305\":1,\"306\":2,\"308\":4,\"309\":5}}],[\"objectinputstream实现具体细节\",{\"1\":{\"303\":1}}],[\"objectoutput\",{\"1\":{\"310\":1,\"311\":1}}],[\"objectoutputfile\",{\"1\":{\"308\":1,\"309\":1}}],[\"objectoutputstream\",{\"1\":{\"280\":1,\"306\":2,\"308\":4,\"309\":8}}],[\"object数组\",{\"1\":{\"291\":1}}],[\"object数组赋给\",{\"1\":{\"291\":1}}],[\"object代替了\",{\"1\":{\"291\":1}}],[\"objectstreamclass\",{\"1\":{\"309\":2}}],[\"objectstreamexception\",{\"1\":{\"305\":1,\"306\":1}}],[\"objects\",{\"1\":{\"283\":1,\"383\":2}}],[\"object是内部比实际要大\",{\"1\":{\"237\":1}}],[\"object>>\",{\"1\":{\"211\":3}}],[\"object>\",{\"1\":{\"202\":1,\"211\":2,\"287\":2}}],[\"objectruntimetype\",{\"1\":{\"165\":1,\"185\":1}}],[\"objectptr\",{\"1\":{\"116\":1}}],[\"object\",{\"0\":{\"51\":1,\"52\":1},\"1\":{\"36\":1,\"40\":1,\"42\":1,\"43\":1,\"44\":1,\"48\":2,\"49\":4,\"51\":1,\"52\":1,\"58\":1,\"72\":14,\"75\":1,\"81\":1,\"102\":3,\"103\":6,\"108\":1,\"115\":3,\"116\":2,\"117\":1,\"118\":1,\"121\":3,\"122\":1,\"125\":1,\"126\":1,\"127\":4,\"129\":1,\"134\":1,\"145\":1,\"153\":1,\"180\":1,\"183\":1,\"184\":1,\"191\":1,\"192\":1,\"193\":1,\"198\":1,\"211\":1,\"280\":3,\"282\":2,\"287\":4,\"288\":6,\"291\":5,\"297\":1,\"300\":1,\"305\":9,\"306\":3,\"308\":4,\"309\":7,\"312\":1,\"314\":1,\"321\":3,\"322\":2,\"328\":1,\"345\":1,\"364\":2,\"365\":4,\"369\":2,\"370\":1,\"371\":4,\"376\":4,\"378\":1,\"379\":1,\"383\":6,\"384\":1,\"389\":6,\"392\":2,\"403\":1,\"426\":2}}],[\"obtained\",{\"1\":{\"391\":1}}],[\"obtaindeadworkerslocked\",{\"1\":{\"391\":2}}],[\"obtaincachestatus获取图片状态imagecachestatus\",{\"1\":{\"197\":1}}],[\"obtainkey获取图片对应的\",{\"1\":{\"196\":1}}],[\"obtainkey\",{\"1\":{\"196\":2}}],[\"obtaining\",{\"1\":{\"188\":5}}],[\"obtainmessage\",{\"1\":{\"80\":1}}],[\"obtainstyledattributes\",{\"1\":{\"56\":2,\"64\":1}}],[\"obtain\",{\"1\":{\"13\":1,\"20\":2,\"30\":1,\"31\":1,\"40\":2,\"43\":2,\"58\":2,\"126\":1}}],[\"osthread\",{\"1\":{\"115\":21,\"382\":1,\"389\":2}}],[\"oserror\",{\"1\":{\"111\":1}}],[\"osize>>1\",{\"1\":{\"52\":2}}],[\"osize\",{\"1\":{\"52\":3}}],[\"os\",{\"1\":{\"35\":2,\"36\":3,\"40\":18,\"43\":3,\"58\":18,\"81\":1,\"115\":16,\"303\":1,\"314\":1,\"363\":1,\"383\":1,\"387\":1,\"389\":2,\"391\":6}}],[\"or和not运算\",{\"1\":{\"369\":1}}],[\"org\",{\"1\":{\"302\":1,\"322\":2,\"407\":1}}],[\"oracle\",{\"1\":{\"274\":1,\"281\":1,\"293\":1,\"295\":1,\"302\":2}}],[\"or\",{\"1\":{\"80\":1,\"102\":1,\"103\":1,\"106\":1,\"109\":2,\"111\":1,\"115\":2,\"126\":1,\"128\":1,\"131\":2,\"135\":1,\"136\":3,\"143\":1,\"154\":1,\"177\":1,\"179\":1,\"180\":5,\"181\":1,\"193\":1,\"196\":1,\"209\":1,\"220\":1,\"225\":1,\"243\":1,\"274\":2,\"275\":4,\"276\":2,\"277\":1,\"279\":2,\"281\":4,\"302\":1,\"306\":1,\"368\":1,\"382\":1,\"387\":1,\"389\":1,\"391\":5,\"392\":1,\"395\":1}}],[\"orientation\",{\"1\":{\"81\":2}}],[\"orientation=\",{\"1\":{\"79\":1}}],[\"origin是本地仓库\",{\"1\":{\"347\":1}}],[\"original\",{\"1\":{\"40\":1,\"211\":2,\"373\":1}}],[\"origin\",{\"1\":{\"15\":3,\"116\":2,\"347\":5,\"383\":2,\"389\":2}}],[\"ordinal\",{\"1\":{\"285\":2}}],[\"ordinary\",{\"1\":{\"13\":1}}],[\"order\",{\"1\":{\"80\":1,\"106\":2,\"115\":1,\"236\":1,\"272\":1}}],[\"ordered值大的window会覆盖掉低值的window\",{\"1\":{\"41\":1}}],[\"ordered\",{\"1\":{\"41\":3,\"106\":1}}],[\"off\",{\"1\":{\"196\":1,\"395\":1}}],[\"offstage\",{\"1\":{\"176\":2,\"179\":2,\"180\":3}}],[\"offset就是scrollable处理的scrollposition\",{\"1\":{\"235\":1}}],[\"offset为0时\",{\"1\":{\"226\":1}}],[\"offset为负值\",{\"1\":{\"220\":1}}],[\"offset为正值\",{\"1\":{\"220\":1}}],[\"offset表示经过上述计算之后\",{\"1\":{\"220\":1}}],[\"offsets\",{\"1\":{\"181\":5}}],[\"offset\",{\"1\":{\"157\":1,\"168\":1,\"182\":1,\"212\":1,\"217\":1,\"220\":7,\"226\":1,\"227\":3,\"228\":6,\"229\":2,\"231\":1,\"235\":3,\"236\":5,\"237\":9,\"238\":2,\"239\":17,\"240\":3}}],[\"offer\",{\"1\":{\"80\":2}}],[\"offers\",{\"1\":{\"3\":1}}],[\"offloat\",{\"1\":{\"63\":1}}],[\"of\",{\"1\":{\"3\":1,\"10\":1,\"15\":4,\"49\":2,\"75\":2,\"80\":2,\"92\":1,\"97\":1,\"100\":1,\"102\":3,\"103\":3,\"106\":3,\"107\":1,\"108\":1,\"109\":4,\"111\":2,\"112\":3,\"115\":3,\"118\":1,\"126\":2,\"127\":1,\"130\":2,\"131\":2,\"132\":1,\"136\":1,\"147\":15,\"154\":11,\"158\":3,\"176\":1,\"178\":1,\"180\":2,\"183\":1,\"185\":1,\"186\":1,\"196\":1,\"212\":1,\"213\":1,\"220\":2,\"225\":1,\"226\":1,\"227\":2,\"228\":1,\"230\":2,\"233\":2,\"235\":2,\"272\":3,\"274\":2,\"275\":4,\"276\":1,\"277\":2,\"278\":3,\"279\":3,\"281\":1,\"282\":1,\"295\":2,\"302\":6,\"305\":1,\"306\":1,\"312\":1,\"314\":2,\"322\":4,\"327\":1,\"328\":2,\"345\":1,\"373\":1,\"378\":3,\"383\":5,\"386\":1,\"389\":2,\"390\":1,\"391\":6,\"392\":3,\"396\":6,\"402\":1,\"426\":2}}],[\"opaque\",{\"1\":{\"194\":1}}],[\"opacity\",{\"1\":{\"147\":1,\"154\":1,\"181\":1,\"193\":2}}],[\"optionally\",{\"1\":{\"279\":1}}],[\"optional\",{\"1\":{\"272\":1,\"275\":1,\"389\":1}}],[\"optionaltypeargs\",{\"1\":{\"158\":1}}],[\"options\",{\"1\":{\"209\":1,\"210\":3,\"211\":16,\"387\":1}}],[\"options生产powerimageprovider\",{\"1\":{\"208\":1}}],[\"options等自定义通道获取图片并展示\",{\"1\":{\"204\":1}}],[\"optimizing\",{\"1\":{\"396\":2}}],[\"optimizations\",{\"1\":{\"396\":1}}],[\"optimization\",{\"1\":{\"52\":1,\"98\":1}}],[\"optimized\",{\"0\":{\"396\":1},\"1\":{\"394\":1,\"396\":5}}],[\"optimize\",{\"1\":{\"1\":1,\"3\":1}}],[\"ops\",{\"1\":{\"111\":3}}],[\"operate\",{\"1\":{\"295\":1}}],[\"operations\",{\"1\":{\"376\":1}}],[\"operation\",{\"1\":{\"111\":2,\"383\":1,\"391\":1}}],[\"operatorstack\",{\"1\":{\"453\":16}}],[\"operator\",{\"1\":{\"78\":1,\"322\":4,\"327\":1}}],[\"openfile\",{\"1\":{\"382\":1}}],[\"opening\",{\"1\":{\"115\":1}}],[\"openinputstream\",{\"1\":{\"2\":1}}],[\"open\",{\"1\":{\"78\":1,\"111\":4,\"115\":1,\"137\":1,\"367\":1,\"370\":1,\"371\":1,\"382\":1}}],[\"onbefore\",{\"1\":{\"365\":2}}],[\"onbind\",{\"1\":{\"17\":3,\"19\":1,\"20\":1,\"36\":2,\"43\":1,\"58\":2}}],[\"onfailure\",{\"1\":{\"362\":1,\"365\":1}}],[\"onnotification\",{\"1\":{\"227\":1,\"235\":1}}],[\"onneedvisualupdate\",{\"1\":{\"118\":1}}],[\"onnestedprescroll\",{\"1\":{\"55\":2}}],[\"onloadfailed\",{\"1\":{\"211\":1}}],[\"onloadfailed返回结果\",{\"1\":{\"211\":1}}],[\"onloadsuccess\",{\"1\":{\"211\":1}}],[\"onloadresult方法也就是powerimageexternalrequest和powerimagetexturerequest的onloadresult\",{\"1\":{\"211\":1}}],[\"onloadresult\",{\"1\":{\"211\":3}}],[\"only\",{\"1\":{\"24\":1,\"80\":2,\"85\":1,\"108\":2,\"115\":3,\"121\":1,\"180\":1,\"198\":1,\"209\":1,\"281\":1,\"322\":1,\"372\":1,\"383\":2,\"387\":1,\"391\":1,\"426\":2}}],[\"onafter\",{\"1\":{\"365\":2}}],[\"onawait\",{\"1\":{\"334\":1}}],[\"onattachedtoengine\",{\"1\":{\"211\":1}}],[\"onactionup\",{\"1\":{\"64\":1}}],[\"ongoing\",{\"1\":{\"180\":1}}],[\"onmethodcall方法\",{\"1\":{\"211\":2}}],[\"onmethodcall\",{\"1\":{\"135\":1,\"211\":2}}],[\"onmetricschanged\",{\"1\":{\"118\":1}}],[\"onmeasure\",{\"1\":{\"65\":2}}],[\"onvalue\",{\"1\":{\"102\":2,\"103\":1}}],[\"onupdate\",{\"1\":{\"79\":3}}],[\"onuserinteraction\",{\"1\":{\"13\":1}}],[\"onresponse\",{\"1\":{\"362\":1,\"365\":2}}],[\"onresourceready\",{\"1\":{\"211\":1}}],[\"onresult方法\",{\"1\":{\"211\":1}}],[\"onresult\",{\"1\":{\"211\":5}}],[\"onresume\",{\"1\":{\"14\":1,\"65\":2}}],[\"onreceiveornull\",{\"1\":{\"334\":1}}],[\"onreceiveimageevent\",{\"1\":{\"211\":1}}],[\"onreceive\",{\"1\":{\"79\":2,\"334\":3}}],[\"onrequestpermissionsresult\",{\"1\":{\"69\":1}}],[\"onwindowfocuschanged\",{\"1\":{\"65\":1}}],[\"ondrag\",{\"1\":{\"227\":1,\"235\":1}}],[\"ondragcanceled\",{\"1\":{\"226\":1}}],[\"ondrawforeground\",{\"1\":{\"65\":1}}],[\"ondrawover\",{\"1\":{\"64\":1}}],[\"ondraw\",{\"1\":{\"64\":3,\"65\":1}}],[\"ondisabled\",{\"1\":{\"79\":2}}],[\"ondeleted\",{\"1\":{\"79\":2}}],[\"ondependentviewchanged\",{\"1\":{\"55\":2}}],[\"ondestroy\",{\"1\":{\"17\":3}}],[\"onid\",{\"1\":{\"427\":2}}],[\"onisolateshutdown\",{\"1\":{\"382\":1}}],[\"onisolateinitialize\",{\"1\":{\"382\":2}}],[\"onimagecomplete\",{\"1\":{\"211\":3}}],[\"onimgclicklistener\",{\"1\":{\"56\":4}}],[\"onindexclick\",{\"1\":{\"64\":1}}],[\"onindexclicklistener\",{\"1\":{\"64\":2}}],[\"onintercepttouchevent\",{\"1\":{\"13\":5}}],[\"ontick方法监听处理动画进度\",{\"1\":{\"181\":1}}],[\"ontick\",{\"1\":{\"181\":1}}],[\"ontap\",{\"1\":{\"140\":1,\"170\":2,\"172\":4}}],[\"ontap等等\",{\"1\":{\"140\":1}}],[\"ontextscalefactorchanged\",{\"1\":{\"118\":1}}],[\"onto\",{\"1\":{\"111\":1,\"112\":1}}],[\"ontouch\",{\"1\":{\"13\":2}}],[\"ontouchevent\",{\"1\":{\"13\":6}}],[\"ontransact\",{\"1\":{\"40\":2,\"58\":2}}],[\"onplatformbrightnesschanged\",{\"1\":{\"118\":1}}],[\"onpostexecute\",{\"1\":{\"80\":2}}],[\"onpressed\",{\"1\":{\"130\":2,\"140\":1}}],[\"onpreexecute\",{\"1\":{\"80\":2}}],[\"onprogressupdate\",{\"1\":{\"80\":2}}],[\"onpeoplelistchange\",{\"1\":{\"35\":2,\"37\":1}}],[\"onpeoplechange\",{\"1\":{\"35\":2,\"36\":3}}],[\"onpause\",{\"1\":{\"14\":1,\"21\":1,\"65\":1}}],[\"onepng\",{\"1\":{\"427\":2}}],[\"onexit\",{\"1\":{\"378\":8}}],[\"oneach\",{\"1\":{\"327\":2,\"328\":1,\"341\":1,\"342\":1}}],[\"oneclazz<t>\",{\"1\":{\"290\":1}}],[\"onevent\",{\"1\":{\"211\":2}}],[\"onenteridlelocked\",{\"1\":{\"391\":1}}],[\"onend方法\",{\"1\":{\"148\":1}}],[\"onend\",{\"1\":{\"147\":2,\"153\":1}}],[\"onenabled\",{\"1\":{\"79\":2}}],[\"onerror捕获并处理\",{\"1\":{\"141\":1}}],[\"onerror\",{\"0\":{\"144\":1,\"145\":1},\"1\":{\"95\":1,\"102\":4,\"103\":11,\"111\":1,\"143\":2,\"144\":2,\"145\":1,\"191\":1,\"196\":1,\"198\":1,\"202\":2,\"378\":8}}],[\"oneshot=\",{\"1\":{\"66\":1}}],[\"oneway\",{\"1\":{\"43\":3}}],[\"one\",{\"1\":{\"24\":1,\"80\":2,\"85\":1,\"102\":1,\"103\":3,\"105\":1,\"106\":1,\"107\":1,\"109\":2,\"112\":1,\"115\":1,\"147\":1,\"180\":1,\"220\":1,\"225\":2,\"322\":1,\"327\":6,\"387\":1,\"390\":1,\"391\":4}}],[\"onstage\",{\"1\":{\"179\":1}}],[\"onstartnestedscroll\",{\"1\":{\"55\":2}}],[\"onstartcommand\",{\"1\":{\"17\":1}}],[\"onstart\",{\"1\":{\"14\":1,\"65\":1}}],[\"onswitchedtrain\",{\"1\":{\"159\":2}}],[\"onsend\",{\"1\":{\"334\":3}}],[\"onsemanticsaction\",{\"1\":{\"118\":1}}],[\"onsemanticsenabledchanged\",{\"1\":{\"118\":1}}],[\"onsemanticsownerdisposed\",{\"1\":{\"118\":1}}],[\"onsemanticsownercreated\",{\"1\":{\"118\":1}}],[\"onservicedisconnected\",{\"1\":{\"17\":2,\"19\":1,\"35\":1,\"38\":1,\"43\":1,\"58\":1}}],[\"onserviceconnected\",{\"1\":{\"17\":2,\"19\":1,\"20\":1,\"35\":1,\"43\":1,\"58\":1}}],[\"oncompletion的可空参数\",{\"1\":{\"343\":1}}],[\"oncompletion\",{\"1\":{\"328\":3,\"343\":1}}],[\"oncolorchanged\",{\"1\":{\"130\":5}}],[\"onchunk\",{\"1\":{\"191\":1}}],[\"oncancelled\",{\"1\":{\"80\":1}}],[\"oncallbackdied\",{\"1\":{\"36\":1}}],[\"oncallback\",{\"1\":{\"35\":2}}],[\"once\",{\"1\":{\"80\":1,\"101\":1,\"108\":1,\"111\":2,\"112\":1,\"115\":1,\"179\":1,\"198\":1}}],[\"oncreate中注册的\",{\"1\":{\"211\":1}}],[\"oncreate方法中\",{\"1\":{\"211\":1}}],[\"oncreate\",{\"1\":{\"14\":1,\"17\":4,\"19\":1,\"20\":1,\"35\":2,\"37\":1,\"69\":1,\"71\":2,\"79\":2,\"81\":3,\"92\":2,\"93\":2,\"211\":1}}],[\"onclick等通用的属性可以直接绑定外\",{\"1\":{\"401\":1}}],[\"onclicklistener\",{\"1\":{\"56\":1,\"71\":1}}],[\"onclick\",{\"1\":{\"13\":2,\"56\":6,\"71\":1,\"140\":1,\"345\":2}}],[\"on\",{\"1\":{\"1\":2,\"3\":1,\"15\":1,\"35\":1,\"36\":1,\"56\":1,\"75\":1,\"80\":1,\"101\":1,\"102\":2,\"106\":1,\"112\":1,\"115\":8,\"118\":1,\"119\":1,\"142\":1,\"180\":1,\"198\":1,\"202\":1,\"209\":3,\"220\":1,\"226\":1,\"230\":1,\"233\":1,\"243\":1,\"287\":1,\"295\":1,\"297\":1,\"302\":1,\"327\":1,\"347\":1,\"376\":1,\"378\":2,\"379\":2,\"383\":7,\"384\":2,\"387\":2,\"389\":9,\"391\":3,\"396\":3,\"398\":4}}],[\"n∗\",{\"1\":{\"460\":1}}],[\"n∗log\",{\"1\":{\"459\":1}}],[\"n∗logn\",{\"1\":{\"439\":1,\"460\":1}}],[\"n次就可以排序完成\",{\"1\":{\"456\":1}}],[\"n2\",{\"1\":{\"449\":1,\"454\":1,\"455\":1,\"456\":1,\"457\":1}}],[\"n^2\",{\"1\":{\"442\":1}}],[\"n顶点是否邻接\",{\"1\":{\"433\":1}}],[\"n的数组保存图中所有的顶点\",{\"1\":{\"433\":1}}],[\"nindex\",{\"1\":{\"467\":4}}],[\"nicenews\",{\"1\":{\"398\":1}}],[\"niecenews我制作的第二款app\",{\"1\":{\"398\":1}}],[\"nt\",{\"1\":{\"370\":1,\"413\":1}}],[\"nthreads\",{\"1\":{\"297\":2}}],[\"ngroups\",{\"1\":{\"297\":1}}],[\"ns\",{\"1\":{\"273\":1}}],[\"n$errordetails\",{\"1\":{\"143\":1}}],[\"npm\",{\"1\":{\"412\":1,\"413\":1}}],[\"npm之后\",{\"1\":{\"411\":1}}],[\"np\",{\"1\":{\"115\":2}}],[\"nmh包裹要处理的回调\",{\"1\":{\"115\":2}}],[\"nmh\",{\"1\":{\"115\":5}}],[\"nfile\",{\"1\":{\"110\":1,\"111\":1}}],[\"n请赋予相机权限\",{\"1\":{\"69\":1}}],[\"navcontroller\",{\"1\":{\"400\":1}}],[\"navgraph=\",{\"1\":{\"400\":1}}],[\"navhostfragment\",{\"1\":{\"400\":1}}],[\"nav\",{\"1\":{\"400\":3}}],[\"navigate\",{\"1\":{\"400\":1}}],[\"navigation解决了不同的布局间交互的逻辑\",{\"1\":{\"401\":1}}],[\"navigation>\",{\"1\":{\"400\":1}}],[\"navigation可以和appbar\",{\"1\":{\"400\":1}}],[\"navigation\",{\"1\":{\"400\":8,\"404\":1}}],[\"navigation是app设计中的关键部分\",{\"1\":{\"400\":1}}],[\"navigation控制界面切换\",{\"0\":{\"400\":1}}],[\"navigationmenuview\",{\"1\":{\"55\":1}}],[\"navigatorrenderobject\",{\"1\":{\"180\":5}}],[\"navigatorobserver\",{\"1\":{\"178\":1,\"179\":1}}],[\"navigatorsize\",{\"1\":{\"177\":1,\"180\":1,\"181\":1}}],[\"navigatorstate\",{\"1\":{\"175\":1,\"178\":1,\"180\":1}}],[\"navigator\",{\"1\":{\"143\":3,\"170\":2,\"171\":2,\"175\":1,\"178\":4,\"180\":9,\"181\":2}}],[\"navigator类似于android中的activity栈\",{\"1\":{\"135\":1}}],[\"nanotime\",{\"1\":{\"272\":2}}],[\"naming\",{\"1\":{\"154\":1}}],[\"nameequals\",{\"1\":{\"383\":2}}],[\"name的参数\",{\"1\":{\"370\":1}}],[\"names\",{\"1\":{\"115\":1}}],[\"namespacepointer\",{\"1\":{\"111\":1}}],[\"named实现标识不同注解的作用\",{\"1\":{\"86\":1}}],[\"named完全一致的功能\",{\"1\":{\"86\":1}}],[\"named源码\",{\"1\":{\"86\":1}}],[\"named\",{\"1\":{\"86\":5}}],[\"named以及幕后英雄\",{\"1\":{\"86\":1}}],[\"named和\",{\"0\":{\"86\":1}}],[\"name\",{\"1\":{\"17\":2,\"19\":2,\"35\":2,\"43\":2,\"54\":6,\"58\":2,\"86\":2,\"108\":3,\"112\":1,\"114\":1,\"115\":20,\"136\":1,\"170\":2,\"172\":3,\"272\":8,\"274\":1,\"285\":2,\"295\":7,\"302\":1,\"321\":1,\"322\":13,\"347\":2,\"368\":1,\"369\":2,\"370\":14,\"376\":1,\"377\":1,\"378\":2,\"379\":1,\"380\":7,\"381\":4,\"383\":12,\"384\":2,\"385\":1,\"386\":9,\"387\":10,\"388\":7,\"389\":5,\"391\":5,\"405\":1,\"406\":1,\"407\":1,\"417\":1}}],[\"name=\",{\"1\":{\"2\":4,\"17\":3,\"20\":1,\"54\":3,\"56\":3,\"66\":3,\"78\":2,\"79\":4,\"400\":3,\"401\":2}}],[\"natively\",{\"1\":{\"392\":1}}],[\"native加载失败\",{\"1\":{\"211\":2}}],[\"nativeasset\",{\"1\":{\"211\":3}}],[\"nativearguments\",{\"1\":{\"108\":1,\"114\":1}}],[\"nativeresult\",{\"1\":{\"209\":1}}],[\"nativemessagehandler\",{\"1\":{\"115\":5}}],[\"native处理dart的指令\",{\"0\":{\"113\":1}}],[\"native层实现为isolate\",{\"1\":{\"378\":2}}],[\"native层\",{\"1\":{\"60\":1}}],[\"native\",{\"0\":{\"253\":1},\"1\":{\"60\":1,\"111\":1,\"112\":1,\"114\":1,\"115\":7,\"116\":1,\"202\":2,\"203\":1,\"208\":3,\"211\":14,\"376\":3,\"377\":2,\"379\":1,\"384\":1,\"389\":2,\"391\":1,\"392\":1,\"396\":1}}],[\"nunstartedthreads\",{\"1\":{\"297\":1}}],[\"nums\",{\"1\":{\"327\":2}}],[\"num\",{\"1\":{\"321\":1,\"334\":3,\"370\":5,\"459\":10}}],[\"num>\",{\"1\":{\"159\":2}}],[\"numbers\",{\"1\":{\"327\":4,\"328\":4}}],[\"number\",{\"1\":{\"49\":1,\"81\":2,\"112\":2,\"115\":3,\"302\":15,\"325\":1,\"327\":2,\"390\":1}}],[\"nul1\",{\"1\":{\"122\":2,\"125\":1}}],[\"nullelement\",{\"1\":{\"127\":1}}],[\"null的时候需要判断一下\",{\"1\":{\"126\":1}}],[\"null或者child\",{\"1\":{\"126\":1}}],[\"nullptr\",{\"1\":{\"115\":20,\"380\":3,\"381\":8,\"382\":3,\"383\":16,\"384\":1,\"386\":8,\"387\":2,\"388\":4,\"389\":12,\"390\":2,\"391\":8}}],[\"nullpointerexception\",{\"1\":{\"80\":1}}],[\"nullability\",{\"1\":{\"111\":2}}],[\"nullable\",{\"1\":{\"17\":1,\"36\":2,\"56\":1,\"64\":2,\"80\":2,\"102\":1}}],[\"null其内部调用child\",{\"1\":{\"13\":1}}],[\"null\",{\"1\":{\"2\":3,\"13\":7,\"17\":1,\"19\":1,\"20\":2,\"24\":1,\"29\":2,\"36\":5,\"40\":3,\"43\":3,\"46\":1,\"48\":1,\"51\":1,\"56\":2,\"57\":3,\"58\":3,\"64\":2,\"65\":3,\"66\":1,\"72\":5,\"78\":1,\"80\":8,\"96\":6,\"97\":1,\"98\":6,\"99\":1,\"100\":2,\"101\":4,\"102\":14,\"103\":3,\"105\":2,\"106\":4,\"108\":3,\"109\":6,\"110\":1,\"111\":6,\"112\":2,\"114\":1,\"115\":13,\"117\":16,\"118\":3,\"119\":1,\"121\":11,\"122\":12,\"125\":20,\"126\":19,\"127\":4,\"128\":6,\"135\":2,\"147\":1,\"149\":2,\"153\":3,\"154\":1,\"155\":1,\"156\":3,\"161\":2,\"162\":1,\"174\":1,\"176\":6,\"177\":1,\"180\":11,\"181\":4,\"185\":2,\"186\":1,\"190\":4,\"191\":7,\"192\":4,\"193\":5,\"197\":1,\"198\":7,\"201\":7,\"202\":3,\"206\":1,\"207\":2,\"209\":1,\"210\":1,\"211\":9,\"213\":2,\"225\":3,\"226\":1,\"227\":2,\"235\":3,\"237\":1,\"238\":2,\"239\":3,\"240\":1,\"272\":4,\"280\":3,\"283\":1,\"288\":3,\"294\":4,\"296\":2,\"297\":2,\"300\":1,\"305\":4,\"308\":1,\"309\":3,\"314\":1,\"328\":1,\"345\":1,\"346\":3,\"363\":2,\"364\":3,\"365\":4,\"376\":4,\"378\":3,\"379\":1,\"382\":5,\"383\":15,\"384\":5,\"387\":14,\"388\":4,\"389\":2,\"391\":10,\"422\":1,\"426\":1,\"429\":2,\"430\":1,\"432\":12,\"438\":4,\"441\":3}}],[\"n+1位保存value\",{\"1\":{\"49\":2}}],[\"n+1位为value\",{\"1\":{\"44\":1}}],[\"n位保存key\",{\"1\":{\"49\":2}}],[\"n位为key\",{\"1\":{\"44\":1}}],[\"nesetedscrollposition\",{\"1\":{\"223\":1}}],[\"nestedballisticscrollactivitymode\",{\"1\":{\"225\":3}}],[\"nestedscrollmetrics\",{\"1\":{\"225\":1}}],[\"nestedscrollactivitygetter\",{\"1\":{\"225\":1}}],[\"nestedscrollcontroller\",{\"0\":{\"214\":1},\"1\":{\"212\":1,\"213\":1,\"214\":1,\"223\":1,\"224\":2}}],[\"nestedscrollcoordinator类\",{\"1\":{\"223\":1}}],[\"nestedscrollcoordinator\",{\"0\":{\"224\":1},\"1\":{\"212\":8,\"213\":6,\"216\":1,\"217\":2,\"223\":5,\"224\":2,\"226\":15}}],[\"nestedscrollposition>\",{\"1\":{\"226\":1}}],[\"nestedscrollposition类\",{\"1\":{\"223\":1}}],[\"nestedscrollposition\",{\"0\":{\"215\":1,\"217\":1},\"1\":{\"212\":5,\"213\":1,\"215\":2,\"217\":2,\"218\":1,\"223\":2,\"224\":1,\"225\":5,\"226\":6}}],[\"nestedscrollviewviewport\",{\"1\":{\"212\":1,\"213\":2}}],[\"nestedscrollviewstate\",{\"0\":{\"213\":1},\"1\":{\"212\":1,\"213\":8,\"224\":1,\"226\":1}}],[\"nestedscrollviewcustomscrollview的scrollcontroller\",{\"1\":{\"217\":1}}],[\"nestedscrollviewcustomscrollview创建的viewport是继承自\",{\"1\":{\"213\":1}}],[\"nestedscrollviewcustomscrollview\",{\"1\":{\"212\":6,\"213\":8,\"224\":1,\"226\":3}}],[\"nestedscrollview\",{\"1\":{\"55\":1,\"212\":10,\"213\":8,\"216\":1,\"223\":2,\"226\":10,\"227\":1}}],[\"nested\",{\"1\":{\"212\":1,\"400\":1}}],[\"necessary\",{\"1\":{\"105\":1,\"242\":1,\"275\":1}}],[\"nearest\",{\"1\":{\"105\":1}}],[\"never\",{\"1\":{\"98\":1,\"115\":2,\"153\":2,\"383\":1,\"387\":1}}],[\"needscompositing\",{\"1\":{\"239\":1}}],[\"needs\",{\"1\":{\"115\":1,\"198\":1}}],[\"needslayout\",{\"1\":{\"65\":1}}],[\"need\",{\"1\":{\"49\":1,\"96\":1,\"98\":1,\"101\":1,\"104\":2,\"108\":1,\"198\":1,\"276\":1,\"306\":1,\"316\":1,\"382\":1,\"383\":1,\"387\":2}}],[\"needed\",{\"1\":{\"40\":1,\"58\":1,\"65\":1,\"193\":1,\"198\":1,\"426\":1}}],[\"negativeinfinity\",{\"1\":{\"161\":1}}],[\"negative\",{\"1\":{\"49\":1,\"105\":1,\"220\":3,\"297\":1}}],[\"net高阶函数和lambda表达式\",{\"1\":{\"345\":1}}],[\"networkimage>\",{\"1\":{\"196\":2}}],[\"networkimage对象\",{\"1\":{\"196\":2}}],[\"networkimage\",{\"1\":{\"188\":3,\"196\":6}}],[\"network为例\",{\"1\":{\"188\":1,\"200\":1}}],[\"network\",{\"1\":{\"78\":3,\"136\":1,\"187\":1,\"188\":2,\"196\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":3,\"202\":1,\"203\":1,\"204\":1,\"209\":2,\"211\":4}}],[\"net\",{\"1\":{\"15\":3,\"35\":1,\"40\":1,\"41\":1,\"54\":2,\"58\":7,\"59\":1,\"63\":1,\"108\":1,\"115\":1,\"273\":1,\"279\":1,\"283\":1,\"286\":1,\"287\":1,\"288\":1,\"294\":1}}],[\"nextid\",{\"1\":{\"105\":1}}],[\"nextlistener\",{\"1\":{\"103\":2}}],[\"nextcallback\",{\"1\":{\"97\":1,\"98\":4}}],[\"next\",{\"1\":{\"13\":1,\"25\":1,\"31\":1,\"97\":1,\"98\":4,\"109\":2,\"118\":1,\"159\":5,\"280\":1,\"327\":1,\"370\":1,\"438\":2}}],[\"nexus\",{\"1\":{\"1\":1}}],[\"newisolate\",{\"1\":{\"373\":4}}],[\"newinstancefactory\",{\"1\":{\"402\":1}}],[\"newinstance\",{\"1\":{\"272\":2,\"295\":1,\"427\":1}}],[\"newinneractivity\",{\"1\":{\"225\":3}}],[\"newvalue\",{\"1\":{\"322\":1}}],[\"newouteractivity\",{\"1\":{\"225\":3}}],[\"nework\",{\"1\":{\"203\":1}}],[\"newpixels\",{\"1\":{\"220\":4,\"221\":4,\"226\":2}}],[\"newpixels的值不会越界\",{\"1\":{\"220\":1}}],[\"newpixels会在minscrollextent和pixels之间\",{\"1\":{\"220\":1}}],[\"newpixels会等于pixels\",{\"1\":{\"220\":1}}],[\"newpixels不会越界\",{\"1\":{\"220\":1}}],[\"newpixels在pixels\",{\"1\":{\"220\":2}}],[\"newpixels是可以应用到scrollposition的pixels\",{\"1\":{\"220\":1}}],[\"newproxyinstance\",{\"1\":{\"72\":1}}],[\"newcall\",{\"1\":{\"362\":1}}],[\"newcmd\",{\"1\":{\"359\":1}}],[\"newcmd=oldcmd使用newcmd表示oldcmd\",{\"1\":{\"359\":1}}],[\"newclass\",{\"1\":{\"311\":3}}],[\"newcolor\",{\"1\":{\"130\":2}}],[\"newchild\",{\"1\":{\"122\":3,\"127\":3}}],[\"newwidget\",{\"1\":{\"121\":1,\"122\":3,\"126\":5,\"128\":3}}],[\"newhandle\",{\"1\":{\"116\":1}}],[\"newerror\",{\"1\":{\"116\":1}}],[\"newentry\",{\"1\":{\"97\":4}}],[\"newarray\",{\"1\":{\"115\":1,\"314\":1}}],[\"newnativeport将要处理的事件handler封装起来\",{\"1\":{\"116\":1}}],[\"newnativeport创建一个nativemessagehandler\",{\"1\":{\"115\":1}}],[\"newnativeport执行完毕再切换回当前isolate\",{\"1\":{\"115\":1}}],[\"newnativeport的实现如下\",{\"1\":{\"115\":1}}],[\"newnativeport的调用参数\",{\"1\":{\"115\":1}}],[\"newnativeport总共有3个参数\",{\"1\":{\"115\":1}}],[\"newnativeport\",{\"0\":{\"115\":1},\"1\":{\"114\":2,\"115\":4}}],[\"newly\",{\"1\":{\"105\":1,\"387\":1}}],[\"newsinglethreadcontext\",{\"1\":{\"324\":1}}],[\"newstream\",{\"1\":{\"190\":3}}],[\"newstringfromcstring\",{\"1\":{\"382\":1}}],[\"newstring\",{\"1\":{\"100\":2}}],[\"newslot\",{\"1\":{\"121\":9,\"122\":2,\"126\":2,\"127\":9}}],[\"newsendport如何将创建好的dart\",{\"1\":{\"116\":1}}],[\"newsendport将dart\",{\"1\":{\"114\":1}}],[\"newsendport\",{\"0\":{\"116\":1},\"1\":{\"114\":2,\"116\":1}}],[\"newserviceport\",{\"0\":{\"114\":1},\"1\":{\"112\":4,\"114\":5}}],[\"newservice\",{\"1\":{\"82\":1,\"84\":1}}],[\"newtouchtarget\",{\"1\":{\"13\":1}}],[\"new\",{\"0\":{\"245\":1},\"1\":{\"13\":1,\"17\":2,\"19\":3,\"20\":7,\"24\":3,\"30\":1,\"31\":1,\"35\":6,\"36\":6,\"40\":1,\"43\":1,\"49\":1,\"52\":2,\"56\":1,\"58\":5,\"64\":1,\"65\":4,\"71\":2,\"72\":4,\"78\":1,\"79\":2,\"80\":17,\"96\":1,\"97\":1,\"99\":1,\"102\":8,\"103\":2,\"104\":1,\"105\":5,\"106\":1,\"109\":2,\"111\":17,\"112\":6,\"114\":2,\"115\":20,\"116\":4,\"126\":2,\"128\":2,\"132\":1,\"146\":1,\"152\":1,\"157\":1,\"180\":2,\"188\":1,\"193\":1,\"211\":11,\"216\":1,\"245\":2,\"268\":1,\"269\":1,\"279\":2,\"281\":7,\"282\":4,\"287\":1,\"288\":9,\"291\":5,\"292\":3,\"293\":3,\"294\":5,\"296\":4,\"297\":1,\"305\":1,\"308\":6,\"309\":5,\"314\":2,\"327\":2,\"328\":1,\"345\":1,\"362\":5,\"363\":3,\"364\":2,\"365\":4,\"370\":10,\"371\":5,\"372\":1,\"373\":2,\"376\":2,\"377\":5,\"378\":11,\"379\":1,\"381\":1,\"382\":1,\"383\":11,\"384\":2,\"387\":8,\"388\":3,\"389\":18,\"390\":7,\"391\":2,\"417\":2,\"426\":1,\"450\":1,\"453\":2}}],[\"normally\",{\"1\":{\"389\":1}}],[\"normal\",{\"1\":{\"147\":1,\"154\":1,\"382\":1,\"389\":1,\"391\":8}}],[\"norbert\",{\"1\":{\"127\":1}}],[\"nodes\",{\"1\":{\"371\":2,\"395\":1}}],[\"nodesneedingsemantics四个列表\",{\"1\":{\"118\":1}}],[\"nodesneedingpaint\",{\"1\":{\"118\":1}}],[\"nodesneedingcompositingbitsupdate\",{\"1\":{\"118\":1}}],[\"nodesneedinglayout\",{\"1\":{\"118\":1}}],[\"node不为空且key不一致\",{\"1\":{\"280\":1}}],[\"node不为空且key一致\",{\"1\":{\"280\":1}}],[\"node<k\",{\"1\":{\"280\":3,\"287\":2}}],[\"node\",{\"0\":{\"410\":1},\"1\":{\"121\":1,\"136\":1,\"371\":2,\"408\":1,\"410\":3,\"411\":2,\"412\":1,\"418\":1,\"419\":1,\"430\":4,\"438\":5}}],[\"nosafepointscope\",{\"1\":{\"116\":1}}],[\"nosuchalgorithmexception\",{\"1\":{\"296\":1}}],[\"nosuchmethoderror\",{\"1\":{\"111\":1}}],[\"nosuchfieldexception\",{\"1\":{\"72\":1}}],[\"now\",{\"1\":{\"105\":5,\"109\":2,\"110\":1,\"201\":3,\"220\":1,\"226\":1,\"297\":3,\"383\":1}}],[\"nocameradialog\",{\"1\":{\"69\":2}}],[\"nocamerapermissiondialog\",{\"1\":{\"69\":2}}],[\"noclassdeffounderror的同时\",{\"1\":{\"14\":1}}],[\"noclassdeffounderror\",{\"1\":{\"14\":2}}],[\"nongeneric\",{\"1\":{\"383\":4}}],[\"noname\",{\"1\":{\"130\":6}}],[\"non\",{\"1\":{\"34\":1,\"58\":1,\"101\":1,\"111\":2,\"115\":1,\"121\":1,\"153\":1,\"272\":1,\"306\":2,\"376\":2,\"383\":1,\"388\":4,\"391\":1}}],[\"nonnull\",{\"1\":{\"13\":1,\"15\":2,\"55\":8}}],[\"nonetheless\",{\"1\":{\"220\":1}}],[\"none\",{\"1\":{\"1\":1,\"227\":1,\"235\":1,\"239\":1,\"369\":1,\"370\":5,\"371\":5}}],[\"notably\",{\"1\":{\"392\":1}}],[\"notable\",{\"1\":{\"154\":1}}],[\"noting>\",{\"1\":{\"322\":1}}],[\"notimplemented\",{\"1\":{\"211\":1}}],[\"notified\",{\"1\":{\"106\":1,\"109\":1}}],[\"notificationlistener<scrollupdatenotification>\",{\"1\":{\"227\":1,\"235\":1}}],[\"notifications\",{\"1\":{\"216\":1}}],[\"notificationtree\",{\"1\":{\"117\":1,\"122\":2,\"125\":1,\"126\":1}}],[\"notification\",{\"1\":{\"21\":2,\"108\":1,\"115\":1,\"227\":2,\"235\":2,\"391\":1}}],[\"notifyall\",{\"1\":{\"297\":2}}],[\"notifylisteners\",{\"1\":{\"163\":1,\"218\":1}}],[\"notifyeventhandler\",{\"1\":{\"106\":3,\"108\":3,\"109\":3}}],[\"notifyzerohandler\",{\"1\":{\"106\":4,\"107\":1}}],[\"notify\",{\"1\":{\"105\":1,\"108\":1,\"109\":1,\"115\":4,\"297\":1,\"389\":2,\"390\":1}}],[\"notes\",{\"1\":{\"116\":1}}],[\"note\",{\"1\":{\"81\":1,\"426\":1}}],[\"nothing>\",{\"1\":{\"322\":1}}],[\"nothing\",{\"1\":{\"49\":2,\"198\":1,\"391\":1}}],[\"not\",{\"1\":{\"13\":2,\"17\":1,\"40\":1,\"41\":3,\"49\":1,\"65\":1,\"99\":1,\"102\":2,\"103\":1,\"105\":3,\"108\":2,\"109\":1,\"111\":1,\"115\":4,\"130\":2,\"136\":1,\"156\":1,\"180\":1,\"185\":1,\"193\":2,\"198\":2,\"209\":1,\"211\":1,\"220\":3,\"226\":1,\"272\":2,\"276\":1,\"277\":2,\"281\":2,\"287\":1,\"306\":1,\"308\":1,\"309\":2,\"327\":2,\"345\":1,\"347\":1,\"364\":1,\"368\":1,\"371\":2,\"378\":3,\"381\":1,\"386\":2,\"389\":2,\"390\":1,\"391\":2,\"395\":1,\"396\":2,\"426\":1}}],[\"no\",{\"1\":{\"13\":4,\"45\":1,\"49\":1,\"69\":1,\"96\":1,\"104\":2,\"108\":2,\"109\":3,\"111\":1,\"114\":1,\"116\":1,\"133\":1,\"135\":1,\"180\":2,\"198\":1,\"216\":1,\"310\":1,\"378\":1,\"381\":1,\"383\":2,\"389\":1,\"391\":6}}],[\"n\",{\"1\":{\"2\":3,\"48\":2,\"49\":4,\"52\":2,\"63\":3,\"79\":1,\"81\":9,\"115\":17,\"129\":1,\"289\":3,\"294\":4,\"322\":8,\"338\":1,\"361\":2,\"368\":2,\"369\":2,\"381\":1,\"383\":2,\"386\":1,\"389\":2,\"391\":14,\"433\":2,\"438\":2,\"442\":2,\"450\":2,\"451\":3,\"455\":1,\"456\":1,\"459\":5,\"465\":1,\"467\":7}}],[\"ndkroot=\",{\"1\":{\"1\":1}}],[\"ndk\",{\"1\":{\"1\":2}}],[\"pclassloader\",{\"1\":{\"424\":1}}],[\"py就行\",{\"1\":{\"367\":1}}],[\"py\",{\"0\":{\"368\":1},\"1\":{\"367\":1,\"368\":2,\"369\":1,\"370\":8,\"371\":10}}],[\"py的一下变量\",{\"0\":{\"367\":1}}],[\"python脚本实现一键自动新建文章\",{\"1\":{\"468\":1}}],[\"python自动化部署文章\",{\"0\":{\"468\":1}}],[\"python自动创建发布hexo文章并同步github\",{\"0\":{\"366\":1}}],[\"python爬虫爬取gityuan\",{\"0\":{\"371\":1}}],[\"python爬取gityuan所有文章列表\",{\"0\":{\"370\":1}}],[\"python文件默认格式\",{\"1\":{\"369\":1}}],[\"python入门知识\",{\"0\":{\"369\":1}}],[\"python\",{\"1\":{\"366\":1,\"368\":2,\"369\":1}}],[\"psi\",{\"1\":{\"358\":1}}],[\"pst\",{\"1\":{\"302\":1}}],[\"p2\",{\"1\":{\"322\":1}}],[\"pm\",{\"1\":{\"302\":4}}],[\"pkcs5padding\",{\"1\":{\"296\":1}}],[\"pkg\",{\"1\":{\"111\":1}}],[\"physics不支持overscroll\",{\"1\":{\"226\":1}}],[\"physics\",{\"1\":{\"213\":2,\"215\":3,\"220\":2,\"221\":2,\"223\":1,\"225\":3,\"226\":1,\"227\":2,\"235\":2}}],[\"physicalmodel\",{\"1\":{\"147\":1}}],[\"phony\",{\"1\":{\"282\":1}}],[\"phone\",{\"1\":{\"60\":1}}],[\"phonewindow\",{\"1\":{\"13\":2}}],[\"photo\",{\"1\":{\"280\":1,\"303\":1}}],[\"photos\",{\"1\":{\"2\":1}}],[\"png\",{\"1\":{\"137\":1,\"188\":1,\"198\":1}}],[\"pd64\",{\"1\":{\"115\":4,\"116\":1,\"391\":2}}],[\"pd\",{\"1\":{\"108\":1,\"115\":2,\"391\":2}}],[\"please\",{\"1\":{\"389\":1}}],[\"plantdetailviewmodelfactory\",{\"1\":{\"402\":1}}],[\"plantdetailfragment\",{\"1\":{\"399\":1}}],[\"planting\",{\"1\":{\"401\":1}}],[\"plantid\",{\"1\":{\"400\":2}}],[\"plant\",{\"1\":{\"400\":2}}],[\"plantlistfragment\",{\"1\":{\"399\":1}}],[\"play\",{\"1\":{\"322\":1}}],[\"player\",{\"1\":{\"322\":4}}],[\"playground\",{\"1\":{\"61\":2}}],[\"place\",{\"1\":{\"233\":2,\"426\":1}}],[\"placeholdersize不为null则展示占位widget\",{\"1\":{\"176\":1}}],[\"placeholdersize\",{\"1\":{\"176\":11}}],[\"placeholderbuilder\",{\"1\":{\"174\":2,\"175\":1,\"176\":2}}],[\"platform\",{\"1\":{\"135\":2,\"363\":3,\"387\":16}}],[\"platformdispatcher\",{\"1\":{\"118\":1}}],[\"plugincontext\",{\"1\":{\"424\":4}}],[\"pluginapp\",{\"1\":{\"423\":1,\"427\":1}}],[\"plugin\",{\"1\":{\"88\":1,\"425\":2}}],[\"ptr\",{\"1\":{\"115\":2,\"116\":1,\"377\":1,\"383\":3,\"387\":2,\"389\":2}}],[\"ptr<isolategroupsource>\",{\"1\":{\"388\":1}}],[\"ptr<isolatespawnstate>\",{\"1\":{\"379\":1,\"380\":1,\"384\":1}}],[\"ptr<task>\",{\"1\":{\"115\":3,\"389\":2,\"390\":1,\"391\":3}}],[\"ptr<message>\",{\"1\":{\"115\":3,\"391\":3}}],[\"pthread\",{\"1\":{\"115\":14}}],[\"pt\",{\"1\":{\"53\":1}}],[\"pxheightscale\",{\"1\":{\"81\":2}}],[\"pxwidthscale\",{\"1\":{\"81\":3}}],[\"px都可\",{\"1\":{\"81\":1}}],[\"px\",{\"1\":{\"53\":6,\"81\":3}}],[\"potentially\",{\"1\":{\"391\":1,\"396\":1}}],[\"potentialouterdelta\",{\"1\":{\"226\":2}}],[\"pony\",{\"1\":{\"288\":1}}],[\"powerexteralstate\",{\"1\":{\"207\":3}}],[\"powerexternalimage\",{\"0\":{\"207\":1},\"1\":{\"205\":1,\"207\":4}}],[\"powerexternalimageprovider类型\",{\"1\":{\"205\":1}}],[\"powerexternalimageprovider\",{\"0\":{\"211\":1},\"1\":{\"205\":2,\"207\":2,\"211\":2}}],[\"powertexturestate\",{\"1\":{\"206\":3}}],[\"powertextureimageinfo\",{\"1\":{\"206\":2,\"210\":4}}],[\"powertextureimage和powerexternalimage\",{\"1\":{\"205\":1,\"207\":1}}],[\"powertextureimage\",{\"0\":{\"206\":1},\"1\":{\"205\":2,\"206\":2,\"207\":2}}],[\"powertextureimageprovider\",{\"0\":{\"210\":1},\"1\":{\"205\":3,\"206\":1,\"210\":2,\"211\":1}}],[\"powerimagenetworkloader继承自powerimageloaderprotocol\",{\"1\":{\"211\":1}}],[\"powerimagenetworkloader\",{\"1\":{\"211\":2}}],[\"powerimageresult\",{\"1\":{\"211\":8}}],[\"powerimageresponse\",{\"1\":{\"211\":3}}],[\"powerimagerequestconfig\",{\"1\":{\"211\":2}}],[\"powerimagerequestmanager\",{\"1\":{\"211\":6}}],[\"powerimagerequest\",{\"1\":{\"211\":5}}],[\"powerimagerequestoptions\",{\"1\":{\"210\":1,\"211\":3}}],[\"powerimagetexturerequest或者powerimageexternalrequest\",{\"1\":{\"211\":1}}],[\"powerimagetexturerequest\",{\"1\":{\"211\":2}}],[\"powerimageexternalrequest和powerimagetexturerequest两个类\",{\"1\":{\"211\":1}}],[\"powerimageexternalrequest\",{\"1\":{\"211\":2}}],[\"powerimageeventsink\",{\"1\":{\"211\":2}}],[\"powerimagebaserequest类内部\",{\"1\":{\"211\":1}}],[\"powerimagebaserequest\",{\"1\":{\"211\":5}}],[\"powerimagebaserequest>\",{\"1\":{\"211\":1}}],[\"powerimagedispatcher\",{\"1\":{\"211\":1}}],[\"powerimagesetupoptions\",{\"1\":{\"211\":1}}],[\"powerimagestate\",{\"0\":{\"205\":1},\"1\":{\"205\":2}}],[\"powerimageplugin\",{\"1\":{\"211\":3}}],[\"powerimageplatformchannel\",{\"1\":{\"211\":4}}],[\"powerimageprovider主要有以下几点改变\",{\"1\":{\"208\":1}}],[\"powerimageprovider\",{\"0\":{\"208\":1},\"1\":{\"208\":1,\"209\":2,\"210\":1,\"211\":5}}],[\"powerimagechannelimpl\",{\"1\":{\"211\":1}}],[\"powerimagechannel\",{\"1\":{\"211\":2}}],[\"powerimagecompleter>\",{\"1\":{\"211\":2}}],[\"powerimagecompleter\",{\"1\":{\"209\":3,\"211\":8}}],[\"powerimagemonitor\",{\"1\":{\"209\":1,\"211\":2}}],[\"powerimageloadexception\",{\"1\":{\"209\":2}}],[\"powerimageloaderprotocol>\",{\"1\":{\"211\":1}}],[\"powerimageloaderprotocol\",{\"1\":{\"211\":9}}],[\"powerimageloader\",{\"1\":{\"209\":1,\"210\":1,\"211\":20}}],[\"powerimageinfo\",{\"1\":{\"208\":1,\"209\":2,\"210\":1,\"211\":1}}],[\"powerimage使用从powerimageprovider\",{\"1\":{\"207\":1}}],[\"powerimage继承自statefulwidget\",{\"1\":{\"204\":1}}],[\"powerimage\",{\"0\":{\"204\":1},\"1\":{\"204\":3,\"207\":1,\"211\":1}}],[\"power\",{\"1\":{\"198\":1,\"203\":3,\"208\":1,\"211\":8}}],[\"powermanager\",{\"1\":{\"60\":1}}],[\"pop\",{\"1\":{\"135\":1,\"170\":1,\"177\":1,\"179\":3,\"180\":1,\"181\":3,\"369\":2,\"437\":2,\"438\":2,\"453\":9}}],[\"portandcapabilities\",{\"1\":{\"377\":4}}],[\"portion\",{\"1\":{\"220\":1}}],[\"port转变为dart的sendport的\",{\"1\":{\"116\":1}}],[\"port转化为dart\",{\"1\":{\"114\":1}}],[\"port并且添加到portmap中\",{\"1\":{\"115\":1}}],[\"port收到消息的时候\",{\"1\":{\"115\":1}}],[\"port以后得回调方法\",{\"1\":{\"114\":1}}],[\"port的名称\",{\"1\":{\"114\":1}}],[\"port返回给调用方\",{\"1\":{\"114\":1}}],[\"port创建了dart里面的sendport对象\",{\"1\":{\"114\":1}}],[\"portset<entry>\",{\"1\":{\"115\":2}}],[\"portsetentry\",{\"1\":{\"115\":1}}],[\"ports\",{\"1\":{\"112\":5,\"115\":10,\"372\":1,\"389\":1,\"391\":1}}],[\"port发送消息\",{\"1\":{\"108\":1}}],[\"port\",{\"1\":{\"106\":5,\"108\":22,\"109\":1,\"112\":12,\"114\":17,\"115\":75,\"116\":13,\"376\":3,\"377\":1,\"379\":3,\"383\":3,\"384\":3,\"389\":27,\"391\":5}}],[\"portmap\",{\"1\":{\"101\":1,\"115\":10,\"376\":1,\"378\":1,\"382\":1,\"383\":1,\"389\":1}}],[\"portrait\",{\"1\":{\"81\":1}}],[\"porterduff\",{\"1\":{\"57\":2,\"65\":1}}],[\"porterduffxfermode\",{\"1\":{\"57\":1,\"65\":1}}],[\"poll\",{\"1\":{\"80\":1}}],[\"pooled\",{\"1\":{\"80\":1}}],[\"pool\",{\"1\":{\"80\":6,\"115\":30,\"278\":1,\"379\":1,\"384\":1,\"389\":11,\"390\":3,\"391\":6}}],[\"posix\",{\"1\":{\"282\":1}}],[\"positive\",{\"1\":{\"220\":2,\"226\":2}}],[\"position的applyfulldragupdate方法\",{\"1\":{\"226\":1}}],[\"position的pixels为0且向下滑动时这里clampeddelta为0\",{\"1\":{\"220\":1}}],[\"positions\",{\"1\":{\"212\":1,\"218\":1,\"226\":1}}],[\"positionedtransition\",{\"1\":{\"154\":1}}],[\"positioneddirectional\",{\"1\":{\"147\":1}}],[\"positioned\",{\"1\":{\"147\":1,\"154\":2,\"181\":1}}],[\"position\",{\"1\":{\"64\":5,\"102\":1,\"115\":1,\"147\":2,\"154\":2,\"170\":1,\"198\":1,\"216\":4,\"220\":1,\"223\":4,\"225\":16,\"226\":12,\"239\":5,\"240\":5}}],[\"pos\",{\"1\":{\"102\":2}}],[\"possible\",{\"1\":{\"101\":1,\"126\":1,\"128\":1,\"391\":1}}],[\"posted\",{\"1\":{\"398\":4}}],[\"poster\",{\"1\":{\"115\":1}}],[\"post等方法获取并配置相应builder\",{\"1\":{\"362\":1}}],[\"posts\",{\"0\":{\"469\":1},\"1\":{\"136\":1,\"286\":1,\"367\":2,\"415\":1,\"417\":1}}],[\"posting\",{\"1\":{\"115\":2}}],[\"postinvalidate\",{\"1\":{\"41\":1}}],[\"postmessage\",{\"1\":{\"115\":3,\"376\":1,\"389\":1}}],[\"postmessage处理\",{\"1\":{\"107\":1}}],[\"postcobject方法将结果压入消息栈中\",{\"1\":{\"116\":1}}],[\"postcobjecthelper\",{\"1\":{\"115\":2}}],[\"postcobject返回的\",{\"1\":{\"115\":1}}],[\"postcobject\",{\"1\":{\"115\":2}}],[\"postresult\",{\"1\":{\"80\":1}}],[\"post\",{\"0\":{\"30\":1,\"245\":1},\"1\":{\"30\":2,\"31\":1,\"58\":2,\"65\":1,\"80\":3,\"115\":1,\"137\":1,\"243\":1,\"245\":1,\"306\":1,\"367\":1,\"368\":3,\"371\":19}}],[\"points\",{\"1\":{\"396\":1}}],[\"point触达的\",{\"1\":{\"396\":1}}],[\"pointing\",{\"1\":{\"383\":1}}],[\"point\",{\"1\":{\"81\":2,\"96\":1,\"99\":2,\"100\":1,\"101\":3,\"105\":1,\"108\":1,\"111\":2,\"180\":1,\"221\":1,\"383\":3,\"389\":4,\"391\":2}}],[\"pointlist\",{\"1\":{\"63\":5}}],[\"pointer<uint8>\",{\"1\":{\"211\":2}}],[\"pointerscroll\",{\"1\":{\"212\":1,\"223\":1,\"225\":1}}],[\"pointers\",{\"1\":{\"115\":1}}],[\"pointeridbits\",{\"1\":{\"13\":2}}],[\"pointer\",{\"1\":{\"13\":1,\"111\":3,\"115\":1,\"211\":2}}],[\"pull\",{\"1\":{\"347\":1}}],[\"pushcliprect\",{\"1\":{\"239\":1}}],[\"pushes\",{\"1\":{\"193\":1}}],[\"push\",{\"1\":{\"135\":1,\"170\":1,\"177\":2,\"179\":1,\"181\":3,\"347\":3,\"407\":1,\"437\":2,\"438\":2}}],[\"pub\",{\"1\":{\"347\":1}}],[\"pubspec\",{\"1\":{\"132\":1}}],[\"publish\",{\"1\":{\"407\":5}}],[\"publishprogress\",{\"1\":{\"80\":1}}],[\"publishservice\",{\"1\":{\"58\":1}}],[\"public目录下生成的\",{\"1\":{\"419\":1}}],[\"public\",{\"1\":{\"1\":1,\"2\":1,\"13\":10,\"14\":2,\"15\":1,\"17\":6,\"19\":7,\"20\":7,\"24\":1,\"25\":1,\"26\":1,\"29\":1,\"30\":2,\"35\":10,\"36\":9,\"37\":2,\"40\":10,\"43\":3,\"44\":1,\"45\":2,\"46\":2,\"47\":2,\"51\":1,\"52\":1,\"53\":2,\"55\":4,\"56\":7,\"58\":13,\"64\":10,\"65\":3,\"71\":3,\"72\":5,\"79\":7,\"80\":13,\"86\":1,\"87\":1,\"108\":1,\"115\":2,\"135\":1,\"211\":12,\"281\":11,\"282\":5,\"285\":7,\"287\":3,\"288\":3,\"291\":1,\"294\":7,\"295\":5,\"296\":3,\"297\":2,\"299\":2,\"300\":1,\"307\":1,\"308\":5,\"309\":2,\"310\":1,\"311\":8,\"312\":1,\"362\":2,\"363\":1,\"364\":4,\"365\":6,\"367\":2,\"380\":1,\"386\":1,\"391\":2,\"407\":2,\"419\":3,\"453\":1}}],[\"purple\",{\"1\":{\"131\":1}}],[\"putfield\",{\"1\":{\"306\":1}}],[\"putfields\",{\"1\":{\"306\":6}}],[\"putifabsent方法中\",{\"1\":{\"211\":1}}],[\"putifabsent方法获取\",{\"1\":{\"198\":1}}],[\"putifabsent方法优先获取image\",{\"1\":{\"197\":1}}],[\"putifabsent\",{\"0\":{\"198\":1},\"1\":{\"196\":1,\"198\":1,\"202\":3}}],[\"putifabsent优先从\",{\"1\":{\"196\":1}}],[\"putint\",{\"1\":{\"69\":1}}],[\"putting\",{\"1\":{\"179\":1}}],[\"putextra\",{\"1\":{\"72\":2}}],[\"put\",{\"0\":{\"45\":1,\"50\":1},\"1\":{\"36\":1,\"45\":1,\"102\":1,\"211\":3,\"279\":1,\"280\":1,\"306\":3,\"417\":1}}],[\"putstring\",{\"1\":{\"20\":1,\"43\":1}}],[\"p\",{\"1\":{\"15\":1,\"41\":3,\"55\":1,\"58\":1,\"59\":2,\"61\":1,\"63\":1,\"268\":1,\"269\":1,\"282\":1,\"327\":1,\"346\":1,\"458\":1}}],[\"pixabay\",{\"1\":{\"280\":1,\"303\":1}}],[\"pixelformat\",{\"1\":{\"210\":1,\"211\":4}}],[\"pixels计算出对应的paintoffset\",{\"1\":{\"239\":1}}],[\"pixels表示child沿着与轴方向axis\",{\"1\":{\"239\":1}}],[\"pixels和minscrollextent较小值\",{\"1\":{\"220\":1}}],[\"pixels比maxscrollextent大可能是由于jumpto等情况\",{\"1\":{\"220\":1}}],[\"pixels\",{\"1\":{\"194\":1,\"211\":2,\"220\":24,\"221\":2,\"225\":4,\"226\":3,\"239\":1}}],[\"pi\",{\"1\":{\"155\":1,\"156\":1}}],[\"pid=1\",{\"1\":{\"60\":1}}],[\"pid=2\",{\"1\":{\"60\":1}}],[\"pid=0\",{\"1\":{\"60\":1}}],[\"pid身份\",{\"1\":{\"58\":1}}],[\"pid等做验证\",{\"1\":{\"39\":1}}],[\"pipelines\",{\"1\":{\"392\":1}}],[\"pipeline\",{\"1\":{\"122\":1}}],[\"pipeline是用来管理rendering\",{\"1\":{\"118\":1}}],[\"pipeline的根节点\",{\"1\":{\"118\":1}}],[\"pipelineowner的根节点\",{\"1\":{\"118\":1,\"127\":1}}],[\"pipelineowner\",{\"1\":{\"118\":4,\"124\":1,\"127\":2,\"237\":1}}],[\"pipeline也就是我们app中所有的renderobject\",{\"1\":{\"118\":1}}],[\"pipe\",{\"1\":{\"58\":1,\"108\":3}}],[\"pick\",{\"1\":{\"225\":3,\"383\":1}}],[\"pic002\",{\"1\":{\"58\":1}}],[\"picturepath\",{\"1\":{\"2\":1}}],[\"ping方法是一个external方法\",{\"1\":{\"376\":1}}],[\"ping可以正常发送的原因是\",{\"1\":{\"376\":1}}],[\"ping\",{\"0\":{\"376\":1},\"1\":{\"376\":4}}],[\"pinned\",{\"1\":{\"212\":1}}],[\"pin\",{\"1\":{\"55\":1}}],[\"pintent\",{\"1\":{\"12\":1}}],[\"prng\",{\"1\":{\"115\":1}}],[\"press\",{\"1\":{\"414\":1}}],[\"presentation\",{\"1\":{\"302\":1}}],[\"present\",{\"1\":{\"109\":1}}],[\"preorder\",{\"1\":{\"346\":9}}],[\"pretend\",{\"1\":{\"327\":3}}],[\"premain\",{\"1\":{\"282\":1}}],[\"preparation\",{\"0\":{\"277\":1},\"1\":{\"277\":2}}],[\"preparing\",{\"1\":{\"275\":1}}],[\"prepared\",{\"1\":{\"276\":1,\"279\":1}}],[\"prepareinitialframe\",{\"1\":{\"118\":1}}],[\"prepareasynclibrary\",{\"1\":{\"100\":1}}],[\"prepareasynclibrary方法会在dart虚拟机启动的时候被调用\",{\"1\":{\"100\":1}}],[\"prepare\",{\"1\":{\"24\":1,\"211\":1}}],[\"preconditions\",{\"1\":{\"389\":1}}],[\"precompiled\",{\"1\":{\"383\":6,\"387\":5,\"396\":1}}],[\"precedence\",{\"1\":{\"226\":1}}],[\"precacheimage\",{\"1\":{\"188\":1}}],[\"pre\",{\"1\":{\"211\":1}}],[\"preview\",{\"1\":{\"371\":2}}],[\"previously\",{\"1\":{\"181\":1,\"391\":2}}],[\"previous\",{\"1\":{\"180\":1}}],[\"previouschild\",{\"1\":{\"127\":3}}],[\"prevents\",{\"1\":{\"98\":1}}],[\"prefixes\",{\"1\":{\"383\":1}}],[\"prefix\",{\"1\":{\"110\":1,\"383\":8}}],[\"pragma\",{\"1\":{\"96\":1,\"99\":2,\"100\":1,\"101\":3,\"102\":1,\"105\":1,\"108\":3,\"111\":2,\"112\":1,\"376\":1,\"377\":1,\"378\":2}}],[\"prio\",{\"1\":{\"115\":1}}],[\"priority\",{\"1\":{\"13\":1,\"115\":8,\"373\":1,\"376\":3,\"391\":14}}],[\"print表示引用该方法\",{\"1\":{\"345\":1}}],[\"printvalue\",{\"1\":{\"325\":7}}],[\"println\",{\"1\":{\"254\":1,\"272\":2,\"281\":2,\"282\":1,\"288\":4,\"289\":3,\"295\":2,\"302\":2,\"306\":3,\"308\":1,\"309\":3,\"322\":5,\"325\":1,\"327\":11,\"328\":10,\"334\":3,\"341\":6,\"343\":4,\"345\":1,\"438\":1,\"453\":3,\"459\":2}}],[\"printerror\",{\"1\":{\"201\":3}}],[\"printerr\",{\"1\":{\"115\":5,\"383\":1,\"389\":1,\"391\":5}}],[\"printcurrenttimems\",{\"1\":{\"110\":4,\"111\":1}}],[\"print\",{\"1\":{\"95\":7,\"101\":6,\"110\":1,\"130\":6,\"140\":1,\"142\":3,\"143\":1,\"145\":1,\"201\":2,\"272\":1,\"289\":3,\"294\":4,\"321\":2,\"322\":3,\"327\":1,\"345\":6,\"346\":1,\"369\":5,\"370\":1,\"373\":6,\"383\":1,\"430\":1,\"437\":1,\"438\":2}}],[\"printstacktrace\",{\"1\":{\"35\":3,\"36\":1,\"43\":1,\"72\":2,\"296\":1,\"300\":1,\"306\":3,\"308\":3,\"309\":3}}],[\"primaryscrollcontroller\",{\"1\":{\"213\":1,\"227\":2,\"235\":3}}],[\"primaryswatch\",{\"1\":{\"132\":1}}],[\"primary\",{\"1\":{\"13\":1,\"227\":2,\"235\":2}}],[\"private与final\",{\"1\":{\"288\":1}}],[\"private和构造方法是前期绑定的\",{\"1\":{\"273\":1}}],[\"private\",{\"1\":{\"7\":1,\"10\":1,\"13\":2,\"19\":1,\"20\":2,\"24\":1,\"30\":1,\"35\":8,\"36\":5,\"40\":3,\"41\":1,\"43\":6,\"44\":4,\"48\":1,\"52\":1,\"56\":1,\"58\":8,\"64\":1,\"69\":4,\"72\":1,\"78\":1,\"80\":5,\"81\":2,\"115\":1,\"211\":8,\"280\":1,\"281\":1,\"282\":1,\"283\":2,\"285\":2,\"287\":5,\"288\":3,\"291\":1,\"294\":7,\"295\":2,\"296\":2,\"297\":1,\"301\":1,\"305\":3,\"306\":6,\"308\":1,\"309\":4,\"321\":1,\"326\":1,\"363\":2,\"422\":2,\"426\":1,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"467\":1}}],[\"profiling\",{\"1\":{\"392\":1}}],[\"profile会执行~\",{\"1\":{\"361\":1}}],[\"profile这三个只要其中一个成功执行了\",{\"1\":{\"361\":1}}],[\"profile\",{\"1\":{\"1\":1,\"361\":4,\"396\":2}}],[\"proc\",{\"1\":{\"349\":1}}],[\"proceed\",{\"1\":{\"180\":1}}],[\"processing\",{\"1\":{\"327\":3,\"389\":3,\"391\":1}}],[\"processfilter\",{\"1\":{\"115\":1}}],[\"processed\",{\"1\":{\"108\":1,\"391\":2}}],[\"process\",{\"1\":{\"59\":3,\"80\":1,\"115\":1,\"274\":1,\"275\":1,\"327\":1,\"391\":5}}],[\"process=\",{\"1\":{\"17\":1,\"20\":1,\"36\":1}}],[\"programmatic\",{\"1\":{\"295\":1}}],[\"program\",{\"0\":{\"255\":1},\"1\":{\"387\":2,\"396\":1}}],[\"progress和对请求结果的处理等的回调\",{\"1\":{\"364\":1}}],[\"progressrectf\",{\"1\":{\"65\":2}}],[\"progress\",{\"1\":{\"63\":2,\"66\":4,\"80\":5}}],[\"problems\",{\"1\":{\"243\":1}}],[\"proper\",{\"1\":{\"387\":1}}],[\"propertyget\",{\"1\":{\"395\":1}}],[\"property\",{\"1\":{\"147\":1,\"322\":5}}],[\"properties\",{\"1\":{\"147\":1}}],[\"properly\",{\"1\":{\"115\":1}}],[\"propagateerror\",{\"1\":{\"108\":1,\"376\":1}}],[\"propagatetolisteners\",{\"1\":{\"103\":2}}],[\"propagates\",{\"1\":{\"103\":1}}],[\"propagate\",{\"1\":{\"102\":1,\"108\":1}}],[\"producer\",{\"1\":{\"334\":1}}],[\"produce<int>\",{\"1\":{\"328\":1,\"334\":1}}],[\"producenumbers\",{\"1\":{\"328\":2,\"334\":1}}],[\"produced\",{\"1\":{\"328\":1}}],[\"produce\",{\"1\":{\"183\":1,\"328\":4,\"329\":1,\"334\":1,\"395\":1}}],[\"produces\",{\"1\":{\"115\":1}}],[\"productmanagerstate\",{\"1\":{\"134\":2}}],[\"productmanager\",{\"1\":{\"132\":1,\"134\":1}}],[\"product\",{\"1\":{\"132\":1,\"383\":6,\"391\":4}}],[\"productflavors\",{\"1\":{\"54\":3}}],[\"protectiondomain\",{\"1\":{\"272\":1}}],[\"protected\",{\"1\":{\"14\":1,\"19\":1,\"58\":1,\"64\":1,\"65\":3,\"79\":1,\"80\":3,\"115\":1,\"118\":1,\"126\":1,\"154\":1,\"184\":1,\"186\":1,\"223\":1,\"233\":1,\"272\":1,\"288\":1,\"307\":1,\"364\":6}}],[\"protocol的scrollable\",{\"1\":{\"240\":1,\"242\":1}}],[\"protocol的widget\",{\"1\":{\"234\":1}}],[\"protocol实现的\",{\"1\":{\"234\":2}}],[\"protocol\",{\"1\":{\"102\":1,\"212\":2,\"227\":4,\"233\":1,\"237\":1,\"240\":1,\"312\":2,\"392\":1}}],[\"provide\",{\"1\":{\"125\":1,\"186\":1,\"213\":1,\"347\":1}}],[\"provided\",{\"1\":{\"114\":1,\"115\":2,\"153\":2,\"386\":1}}],[\"provides又要求类不能是抽象的\",{\"1\":{\"91\":1}}],[\"provides而不会被merge\",{\"1\":{\"87\":1}}],[\"provides的\",{\"1\":{\"87\":1}}],[\"provides方法使用另外一个带参构造函数\",{\"1\":{\"85\":1}}],[\"provides方法中查找\",{\"1\":{\"85\":1}}],[\"provides方法的\",{\"1\":{\"85\":1}}],[\"provides提供的方法\",{\"1\":{\"85\":1}}],[\"provides提供的这个方法\",{\"1\":{\"85\":1}}],[\"provides用来提供一个方法\",{\"1\":{\"85\":1}}],[\"provides\",{\"0\":{\"85\":1},\"1\":{\"85\":4,\"86\":1,\"87\":2,\"91\":1}}],[\"provider会根据native数据创建含有对应的ui\",{\"1\":{\"207\":1}}],[\"provider>\",{\"1\":{\"2\":1,\"79\":1}}],[\"provider\",{\"1\":{\"2\":1,\"79\":6,\"190\":2,\"196\":9,\"198\":2,\"201\":6,\"205\":2,\"206\":2,\"207\":2}}],[\"proxyclassdesc\",{\"1\":{\"305\":1}}],[\"proxyanimation\",{\"1\":{\"159\":2,\"181\":5}}],[\"proxyactivity\",{\"1\":{\"72\":1}}],[\"proxywidget\",{\"1\":{\"125\":1}}],[\"proxyintent\",{\"1\":{\"72\":6}}],[\"proxy中对应的方法进行跨进程通信\",{\"1\":{\"58\":1}}],[\"proxy类持有ibinder的引用\",{\"1\":{\"40\":1}}],[\"proxy代理类对象\",{\"1\":{\"40\":1}}],[\"proxy\",{\"1\":{\"40\":4,\"58\":4,\"72\":4}}],[\"project2\",{\"1\":{\"406\":1}}],[\"project1\",{\"1\":{\"406\":1}}],[\"projects\",{\"1\":{\"396\":1}}],[\"projections\",{\"1\":{\"326\":1}}],[\"projection\",{\"1\":{\"322\":1}}],[\"project\",{\"1\":{\"40\":1,\"347\":1}}],[\"pro\",{\"1\":{\"14\":2}}],[\"peek\",{\"1\":{\"437\":1,\"438\":2,\"453\":6}}],[\"pexels\",{\"1\":{\"280\":1,\"303\":1}}],[\"pendingtimers\",{\"1\":{\"109\":11}}],[\"pendingimage\",{\"1\":{\"198\":8}}],[\"pendingimages同样保存了加载中的图片\",{\"1\":{\"211\":1}}],[\"pendingimages急速增大\",{\"1\":{\"198\":1}}],[\"pendingimages中会累计很多正在下载中的图片\",{\"1\":{\"198\":1}}],[\"pendingimages中下载图片所占大小是没有被imagecache追踪的\",{\"1\":{\"198\":1}}],[\"pendingimages中都没有指定图片时\",{\"1\":{\"198\":1}}],[\"pendingimages\",{\"1\":{\"197\":2,\"198\":6}}],[\"pendingimage>\",{\"1\":{\"197\":1}}],[\"pendingimmediatecallback的内容\",{\"1\":{\"101\":1}}],[\"pendingimmediatecallback\",{\"0\":{\"101\":1},\"1\":{\"100\":7,\"101\":3}}],[\"pendingintent是封装后的intent\",{\"1\":{\"75\":1}}],[\"pendingintent\",{\"0\":{\"75\":1},\"1\":{\"3\":2,\"7\":2,\"75\":1,\"79\":13}}],[\"pending\",{\"1\":{\"80\":1,\"108\":3,\"109\":8,\"111\":1,\"115\":3,\"197\":3,\"390\":3,\"391\":6}}],[\"people变化了\",{\"1\":{\"37\":1}}],[\"peoplelist\",{\"1\":{\"35\":5,\"37\":3}}],[\"peoplemanager\",{\"1\":{\"35\":7,\"37\":5}}],[\"peoples\",{\"1\":{\"35\":5,\"36\":2,\"37\":2}}],[\"people\",{\"1\":{\"34\":3,\"35\":9,\"36\":7,\"37\":1,\"268\":2}}],[\"perm\",{\"1\":{\"249\":1}}],[\"permissions\",{\"1\":{\"69\":1}}],[\"permission验证\",{\"1\":{\"39\":1}}],[\"permission\",{\"1\":{\"2\":4,\"69\":9,\"78\":4}}],[\"perror\",{\"1\":{\"108\":1}}],[\"periodinseconds\",{\"1\":{\"167\":2}}],[\"periodic\",{\"1\":{\"101\":2,\"104\":1,\"105\":3}}],[\"period\",{\"1\":{\"105\":1,\"161\":1,\"167\":1,\"302\":1,\"328\":2}}],[\"perfcounter\",{\"1\":{\"272\":3}}],[\"performlayout\",{\"1\":{\"213\":2,\"238\":1}}],[\"performloadimage方法中\",{\"1\":{\"211\":1}}],[\"performloadimage\",{\"1\":{\"211\":1}}],[\"performance\",{\"1\":{\"130\":1}}],[\"performrebuild\",{\"1\":{\"126\":2}}],[\"perform\",{\"1\":{\"75\":2,\"382\":1}}],[\"performclick\",{\"1\":{\"13\":2}}],[\"perfare\",{\"1\":{\"31\":1}}],[\"per\",{\"1\":{\"24\":1,\"112\":1}}],[\"perpare\",{\"0\":{\"24\":1},\"1\":{\"24\":1}}],[\"pause\",{\"0\":{\"375\":1},\"1\":{\"375\":1,\"376\":2,\"383\":5,\"389\":1,\"391\":1}}],[\"pausecapability\",{\"1\":{\"373\":1,\"377\":1,\"378\":5}}],[\"pausedonexitlocked\",{\"1\":{\"391\":3}}],[\"pausedonstartlocked\",{\"1\":{\"391\":2}}],[\"paused\",{\"1\":{\"115\":1,\"138\":1,\"372\":1,\"378\":8,\"379\":1,\"384\":1,\"389\":1,\"391\":9}}],[\"paeser\",{\"1\":{\"371\":1}}],[\"pacific\",{\"1\":{\"302\":1}}],[\"packageresourcepath\",{\"1\":{\"424\":1}}],[\"packageroot\",{\"1\":{\"378\":2}}],[\"packageinfobean\",{\"1\":{\"422\":1}}],[\"packageinfolist\",{\"1\":{\"422\":4}}],[\"packagebeanlist\",{\"1\":{\"422\":2}}],[\"package=\",{\"1\":{\"421\":1}}],[\"packageconfigstring\",{\"1\":{\"378\":2}}],[\"packageconfig\",{\"1\":{\"378\":6,\"384\":2}}],[\"packages\",{\"1\":{\"378\":1,\"382\":1,\"387\":3,\"422\":1}}],[\"package\",{\"1\":{\"14\":1,\"34\":1,\"35\":4,\"36\":1,\"40\":2,\"43\":1,\"58\":1,\"132\":1,\"295\":2,\"298\":1,\"307\":1,\"378\":1,\"379\":1,\"384\":2,\"387\":8}}],[\"packagemanager\",{\"1\":{\"2\":1,\"54\":4,\"69\":2,\"422\":3,\"425\":2}}],[\"packagename\",{\"1\":{\"2\":6,\"17\":1,\"54\":1,\"69\":1,\"422\":3,\"424\":1}}],[\"passwd\",{\"1\":{\"354\":1}}],[\"password\",{\"1\":{\"306\":7}}],[\"passwprd\",{\"1\":{\"296\":2}}],[\"passhandle\",{\"1\":{\"305\":2}}],[\"passed\",{\"1\":{\"226\":1,\"378\":1,\"384\":1,\"389\":3}}],[\"pass\",{\"1\":{\"156\":1,\"306\":2,\"369\":10}}],[\"paste\",{\"1\":{\"1\":1}}],[\"padding\",{\"1\":{\"140\":2,\"143\":1,\"147\":1,\"148\":1,\"152\":7,\"235\":4,\"282\":1}}],[\"padding=\",{\"1\":{\"56\":1}}],[\"pages\",{\"1\":{\"405\":1,\"417\":2}}],[\"pageview\",{\"1\":{\"212\":1,\"227\":1}}],[\"pageroute<dynamic>\",{\"1\":{\"179\":4,\"180\":2}}],[\"page\",{\"1\":{\"135\":1,\"170\":1,\"171\":6,\"176\":1,\"179\":1,\"370\":2,\"417\":1}}],[\"patch\",{\"1\":{\"99\":4,\"100\":1,\"101\":1,\"105\":5,\"108\":4,\"111\":2,\"112\":4,\"115\":1,\"372\":1,\"376\":2,\"377\":4,\"378\":4}}],[\"pathclassloader\",{\"1\":{\"424\":1}}],[\"pathmeasure\",{\"1\":{\"63\":2}}],[\"path=\",{\"1\":{\"2\":2}}],[\"path=ndkroot\",{\"1\":{\"1\":1}}],[\"paths>\",{\"1\":{\"2\":1}}],[\"paths\",{\"1\":{\"2\":3,\"382\":1}}],[\"path\",{\"1\":{\"1\":1,\"2\":2,\"61\":2,\"63\":4,\"111\":11,\"201\":3,\"298\":1,\"321\":1,\"361\":1,\"367\":5,\"395\":1,\"412\":1}}],[\"pandingintent\",{\"1\":{\"79\":1}}],[\"pareclable实现原理\",{\"1\":{\"316\":1}}],[\"parentusessize\",{\"1\":{\"238\":1}}],[\"parent绑定\",{\"1\":{\"217\":1}}],[\"parentwidget\",{\"1\":{\"143\":7}}],[\"parent和\",{\"1\":{\"122\":1}}],[\"parentdatatype\",{\"1\":{\"230\":1}}],[\"parentdataclass>的\",{\"1\":{\"230\":1}}],[\"parentdataclass>类\",{\"1\":{\"229\":1}}],[\"parentdataclass>\",{\"1\":{\"229\":1,\"230\":1}}],[\"parentdatawidget<parentdata>\",{\"1\":{\"121\":1,\"127\":1}}],[\"parentdataelement\",{\"1\":{\"121\":3,\"127\":3}}],[\"parentdataelement<parentdata>\",{\"1\":{\"121\":1,\"127\":1}}],[\"parent=\",{\"1\":{\"66\":1}}],[\"parent的效果是一样的\",{\"1\":{\"65\":1}}],[\"parent或者具体数值\",{\"1\":{\"65\":1}}],[\"parent\",{\"1\":{\"55\":2,\"56\":2,\"64\":4,\"79\":4,\"96\":1,\"117\":1,\"121\":11,\"122\":2,\"124\":1,\"125\":1,\"126\":3,\"127\":7,\"147\":1,\"177\":1,\"181\":2,\"182\":1,\"183\":10,\"186\":2,\"217\":4,\"224\":1,\"272\":5,\"378\":1,\"379\":2,\"380\":4,\"381\":2,\"384\":2,\"386\":3,\"387\":1,\"389\":3,\"400\":2,\"401\":2,\"432\":18}}],[\"parser\",{\"1\":{\"370\":1,\"371\":4,\"413\":1}}],[\"parsenetworkresponse\",{\"1\":{\"365\":1}}],[\"parse\",{\"1\":{\"321\":1,\"370\":1,\"371\":2}}],[\"parseint\",{\"1\":{\"296\":2}}],[\"parsehexstr2byte\",{\"1\":{\"296\":2}}],[\"parsebyte2hexstr\",{\"1\":{\"296\":2}}],[\"partsortarr\",{\"1\":{\"462\":2}}],[\"parts\",{\"1\":{\"382\":1,\"396\":1}}],[\"participating\",{\"1\":{\"383\":1}}],[\"participate\",{\"1\":{\"180\":1}}],[\"particular\",{\"1\":{\"80\":1,\"274\":1}}],[\"part\",{\"1\":{\"97\":1,\"109\":1,\"275\":1,\"277\":1,\"391\":1,\"396\":1}}],[\"part2\",{\"1\":{\"58\":1}}],[\"part3\",{\"1\":{\"58\":1}}],[\"parallel\",{\"1\":{\"372\":2}}],[\"parallax\",{\"1\":{\"55\":1}}],[\"paragraph\",{\"1\":{\"127\":1}}],[\"parametric\",{\"1\":{\"186\":1}}],[\"parametriccurve<double>\",{\"1\":{\"186\":2}}],[\"parametriccurve<t>\",{\"1\":{\"186\":1}}],[\"parametriccurve<t>是\",{\"1\":{\"186\":1}}],[\"parametriccurve\",{\"1\":{\"182\":1,\"186\":4}}],[\"parameters\",{\"1\":{\"115\":1,\"147\":2}}],[\"parameter\",{\"1\":{\"102\":1,\"115\":4,\"281\":2,\"298\":1}}],[\"params\",{\"1\":{\"80\":7,\"364\":7,\"382\":31}}],[\"param\",{\"1\":{\"15\":4,\"81\":2,\"114\":1,\"453\":1,\"459\":7}}],[\"parcel\",{\"1\":{\"40\":6,\"58\":6,\"314\":9}}],[\"parcelable源码分析\",{\"1\":{\"316\":1}}],[\"parcelable使用\",{\"1\":{\"316\":1}}],[\"parcelable最强解析\",{\"1\":{\"316\":1}}],[\"parcelable接口比serializable接口效率更高\",{\"1\":{\"316\":1}}],[\"parcelable在反序列化时\",{\"1\":{\"313\":1}}],[\"parcelable通过parcel传输到ibinder中\",{\"1\":{\"313\":1}}],[\"parcelable是android为了解决serializable性能问题而推出的\",{\"1\":{\"313\":1}}],[\"parcelable\",{\"1\":{\"34\":1,\"35\":1,\"303\":1,\"314\":5}}],[\"pairs\",{\"1\":{\"180\":1}}],[\"pair<int\",{\"1\":{\"10\":1}}],[\"paintchild\",{\"1\":{\"239\":1}}],[\"paintcontents\",{\"1\":{\"239\":3}}],[\"paintoffset是根据scrollposition计算出来的真正的child和singlechildscrollview的偏移offset\",{\"1\":{\"239\":1}}],[\"paintoffsetforposition\",{\"1\":{\"239\":2}}],[\"paintoffset\",{\"1\":{\"239\":6,\"240\":2}}],[\"paint三步\",{\"1\":{\"238\":1}}],[\"paintextent\",{\"1\":{\"213\":1}}],[\"paintedchildsize\",{\"1\":{\"213\":5}}],[\"paint方法中调用系统的paintimage\",{\"1\":{\"198\":1}}],[\"paint方法中\",{\"1\":{\"195\":1}}],[\"paintimage\",{\"1\":{\"195\":1}}],[\"paintimage方法通过canvas\",{\"1\":{\"189\":1}}],[\"paintingcontext\",{\"1\":{\"239\":2}}],[\"painting\",{\"1\":{\"195\":1}}],[\"painting以及hit\",{\"1\":{\"122\":1}}],[\"paintingbinding\",{\"1\":{\"118\":1,\"196\":2,\"202\":2,\"209\":2}}],[\"paint根据之前获取的信息调用decorationimagepainter\",{\"1\":{\"189\":1}}],[\"paint\",{\"0\":{\"239\":1},\"1\":{\"15\":7,\"57\":1,\"63\":3,\"64\":1,\"65\":9,\"188\":1,\"229\":1,\"239\":1,\"240\":1}}],[\"paint绘制text\",{\"0\":{\"15\":1}}],[\"i是排序次数\",{\"1\":{\"455\":1,\"456\":1}}],[\"i看知乎\",{\"1\":{\"398\":1}}],[\"iweather\",{\"1\":{\"398\":2}}],[\"il优化为optimized\",{\"1\":{\"396\":1}}],[\"il转化为\",{\"1\":{\"396\":1}}],[\"il\",{\"1\":{\"394\":1,\"395\":4,\"396\":6}}],[\"illegalargument\",{\"1\":{\"364\":1}}],[\"illegalargumentexception\",{\"1\":{\"211\":2,\"297\":1}}],[\"illegalargumenterror\",{\"1\":{\"115\":1}}],[\"illegalaccessexception\",{\"1\":{\"72\":1}}],[\"illegal\",{\"1\":{\"108\":1,\"114\":1,\"115\":8,\"116\":3,\"389\":5}}],[\"illegalstateexception\",{\"1\":{\"80\":2,\"211\":1}}],[\"ic\",{\"1\":{\"383\":1}}],[\"icons\",{\"1\":{\"153\":1}}],[\"iconbutton\",{\"1\":{\"153\":1}}],[\"icon\",{\"1\":{\"54\":2,\"153\":1}}],[\"ia32\",{\"1\":{\"383\":3}}],[\"iactivitymanagersingleton\",{\"1\":{\"58\":2}}],[\"iactivitymanager\",{\"1\":{\"58\":4,\"72\":1}}],[\"ig\",{\"1\":{\"383\":16}}],[\"ignore\",{\"1\":{\"383\":1,\"389\":1,\"423\":1}}],[\"ignorepointer\",{\"1\":{\"181\":1}}],[\"ignored\",{\"1\":{\"126\":1,\"363\":1}}],[\"ignores\",{\"1\":{\"115\":1}}],[\"iid\",{\"1\":{\"429\":1,\"432\":15}}],[\"iii\",{\"0\":{\"279\":1}}],[\"ii\",{\"0\":{\"275\":1}}],[\"iin\",{\"1\":{\"40\":4,\"58\":4}}],[\"iinterface接口\",{\"1\":{\"40\":1}}],[\"iinterface\",{\"1\":{\"40\":2,\"58\":2}}],[\"io上面\",{\"1\":{\"405\":1}}],[\"io博客的全过程\",{\"1\":{\"366\":1}}],[\"ioexception\",{\"1\":{\"280\":1,\"305\":3,\"306\":4,\"308\":1,\"309\":7,\"311\":2,\"362\":2,\"365\":3}}],[\"io操作等时\",{\"1\":{\"136\":1}}],[\"io操作的类型\",{\"1\":{\"111\":1,\"112\":1}}],[\"ios\",{\"1\":{\"132\":1,\"138\":1,\"140\":1}}],[\"ios系统\",{\"1\":{\"132\":1}}],[\"ioservice中serviceport将用户需要的io操作和与自己通信的\",{\"1\":{\"116\":1}}],[\"ioservice通过一些列操作\",{\"1\":{\"116\":1}}],[\"ioservice进行消息中转\",{\"1\":{\"116\":1}}],[\"ioservice主要处理的方法有四类\",{\"1\":{\"115\":1}}],[\"ioservice具体的执行是在io\",{\"1\":{\"115\":1}}],[\"ioservicecallback\",{\"1\":{\"114\":2,\"115\":3}}],[\"ioservice关联起来呢\",{\"1\":{\"112\":1}}],[\"ioservice如何与native层的\",{\"1\":{\"112\":1}}],[\"ioservice立马可以收到并通过completer\",{\"1\":{\"112\":1}}],[\"ioservice在\",{\"1\":{\"112\":1}}],[\"ioservice还在\",{\"1\":{\"112\":1}}],[\"ioservice持有\",{\"1\":{\"112\":1}}],[\"ioservice是一个中转站\",{\"1\":{\"112\":1}}],[\"ioservice使用\",{\"1\":{\"111\":1}}],[\"ioservice类中定义\",{\"1\":{\"111\":1,\"112\":1}}],[\"ioserviceports\",{\"1\":{\"111\":2,\"112\":7}}],[\"ioservice的sendport\",{\"1\":{\"114\":1}}],[\"ioservice的源码后发现这是个external\",{\"1\":{\"111\":1}}],[\"ioservice的\",{\"1\":{\"111\":1,\"116\":1}}],[\"ioservice\",{\"0\":{\"114\":1},\"1\":{\"111\":7,\"112\":4,\"114\":5,\"115\":5}}],[\"iooverrides\",{\"1\":{\"111\":2}}],[\"io\",{\"0\":{\"112\":1},\"1\":{\"61\":1,\"95\":1,\"110\":1,\"111\":12,\"112\":8,\"114\":1,\"115\":7,\"280\":1,\"303\":2,\"306\":2,\"308\":1,\"312\":1,\"322\":1,\"367\":3,\"406\":1,\"407\":8,\"417\":3,\"418\":1,\"419\":4}}],[\"i0jbqkfcma==\",{\"1\":{\"58\":1}}],[\"ibm\",{\"1\":{\"58\":2,\"291\":1,\"306\":1,\"309\":1}}],[\"ibookmanager\",{\"1\":{\"40\":12}}],[\"ibinder\",{\"1\":{\"17\":3,\"19\":3,\"20\":2,\"35\":2,\"36\":4,\"40\":7,\"43\":5,\"58\":13}}],[\"i++\",{\"1\":{\"36\":2,\"37\":1,\"48\":1,\"64\":1,\"72\":1,\"79\":1,\"109\":3,\"211\":2,\"289\":7,\"296\":2,\"453\":3}}],[\"ipc\",{\"1\":{\"20\":1,\"32\":1,\"40\":1,\"58\":4,\"60\":1}}],[\"id的多个apk可以配置成运行在同一个进程中\",{\"1\":{\"421\":1}}],[\"ideally\",{\"1\":{\"225\":1}}],[\"identify\",{\"1\":{\"111\":1,\"112\":1}}],[\"identifies\",{\"1\":{\"86\":1}}],[\"identical\",{\"1\":{\"96\":3,\"103\":1,\"115\":1,\"202\":1}}],[\"identityhashcode\",{\"1\":{\"49\":4}}],[\"id与之绑定\",{\"1\":{\"116\":1}}],[\"id和当前的isolate\",{\"1\":{\"116\":1}}],[\"id并返回给dart用来触发消息\",{\"1\":{\"115\":1}}],[\"idcount\",{\"1\":{\"109\":1}}],[\"idletodeadlocked\",{\"1\":{\"391\":2}}],[\"idletorunninglocked\",{\"1\":{\"391\":1}}],[\"idle\",{\"1\":{\"60\":1,\"115\":7,\"225\":1,\"390\":8,\"391\":9}}],[\"id=\",{\"1\":{\"56\":1,\"66\":1,\"79\":1,\"400\":3,\"401\":1}}],[\"id=tuijian\",{\"1\":{\"15\":1}}],[\"id\",{\"1\":{\"21\":2,\"40\":1,\"54\":1,\"56\":3,\"66\":1,\"71\":1,\"79\":3,\"101\":2,\"105\":1,\"108\":12,\"109\":1,\"111\":9,\"112\":9,\"114\":3,\"115\":30,\"116\":14,\"282\":1,\"299\":2,\"301\":1,\"347\":1,\"353\":1,\"364\":5,\"365\":11,\"376\":1,\"379\":2,\"383\":5,\"384\":1,\"389\":5,\"400\":2,\"421\":1,\"424\":2,\"427\":1}}],[\"idbitstoassign\",{\"1\":{\"13\":2}}],[\"ids\",{\"1\":{\"13\":1,\"115\":2}}],[\"i\",{\"0\":{\"274\":1},\"1\":{\"13\":3,\"36\":7,\"37\":3,\"45\":11,\"46\":4,\"47\":4,\"48\":6,\"49\":6,\"64\":6,\"72\":5,\"79\":3,\"95\":6,\"101\":8,\"109\":5,\"127\":6,\"136\":1,\"211\":6,\"226\":4,\"277\":1,\"280\":1,\"281\":5,\"288\":1,\"289\":25,\"296\":10,\"314\":3,\"327\":9,\"328\":1,\"336\":2,\"341\":2,\"361\":1,\"369\":3,\"370\":5,\"383\":23,\"453\":6,\"455\":1,\"456\":1,\"462\":8,\"467\":4}}],[\"isvisited\",{\"1\":{\"437\":2,\"438\":2}}],[\"isvalid\",{\"1\":{\"180\":1}}],[\"isgone=\",{\"1\":{\"401\":1}}],[\"isgone\",{\"1\":{\"401\":1}}],[\"isinstance\",{\"1\":{\"389\":2}}],[\"isinstanceof<string>\",{\"1\":{\"322\":1}}],[\"isinstanceof\",{\"1\":{\"322\":1}}],[\"isincallbackloop\",{\"1\":{\"97\":1,\"98\":3}}],[\"iswhitespace\",{\"1\":{\"321\":1}}],[\"isserviceorkernelisolatename\",{\"1\":{\"388\":1}}],[\"issystemisolate\",{\"1\":{\"383\":1}}],[\"isscrolling\",{\"1\":{\"225\":2}}],[\"isscrollable\",{\"1\":{\"212\":1}}],[\"issuecomment\",{\"1\":{\"372\":1}}],[\"issues\",{\"1\":{\"111\":1,\"180\":1,\"211\":2,\"372\":1}}],[\"issued\",{\"1\":{\"111\":1}}],[\"ismultiframe\",{\"1\":{\"209\":2}}],[\"islisteningtostream的值执行\",{\"1\":{\"191\":1}}],[\"isdiverted\",{\"1\":{\"177\":2,\"180\":1}}],[\"isdone\",{\"1\":{\"163\":1,\"165\":1,\"167\":1}}],[\"isusergesturetransition\",{\"1\":{\"175\":1,\"177\":1,\"179\":4,\"180\":5,\"181\":1}}],[\"isarray\",{\"1\":{\"305\":2,\"312\":1}}],[\"isalive\",{\"1\":{\"297\":2}}],[\"isafter\",{\"1\":{\"201\":1}}],[\"isantialias\",{\"1\":{\"193\":2}}],[\"isanimating\",{\"1\":{\"162\":1}}],[\"isavailable\",{\"1\":{\"78\":1}}],[\"isbootstrapframe\",{\"1\":{\"119\":2}}],[\"isbuttonpressed\",{\"1\":{\"13\":1}}],[\"isnotempty\",{\"1\":{\"211\":1,\"346\":1,\"422\":1}}],[\"isn\",{\"1\":{\"181\":1,\"225\":1,\"378\":1,\"387\":1}}],[\"isnull\",{\"1\":{\"108\":1,\"376\":1,\"383\":4,\"384\":3,\"389\":3}}],[\"isnetavailable\",{\"1\":{\"78\":3}}],[\"isexternalizable\",{\"1\":{\"312\":1}}],[\"iserrorresponse\",{\"1\":{\"111\":2}}],[\"iserror\",{\"1\":{\"108\":1,\"382\":5,\"389\":5}}],[\"isempty\",{\"1\":{\"108\":2,\"109\":1,\"112\":2,\"115\":2,\"211\":2,\"226\":1,\"390\":2,\"391\":6}}],[\"isfunction\",{\"1\":{\"389\":2}}],[\"isfinite\",{\"1\":{\"213\":1}}],[\"isfirstresource\",{\"1\":{\"211\":2}}],[\"isfirst\",{\"1\":{\"106\":1}}],[\"isfromsource\",{\"1\":{\"13\":1}}],[\"ispre\",{\"1\":{\"453\":2}}],[\"isproxy\",{\"1\":{\"312\":1}}],[\"isplayingreverse\",{\"1\":{\"167\":2}}],[\"ispendingcomplete\",{\"1\":{\"103\":1}}],[\"isportrait\",{\"1\":{\"81\":7}}],[\"isoob\",{\"1\":{\"391\":1}}],[\"isownedbycurrentthread\",{\"1\":{\"391\":1}}],[\"isodd\",{\"1\":{\"167\":1}}],[\"iso\",{\"1\":{\"110\":1,\"302\":2}}],[\"isolate执行\",{\"1\":{\"393\":1}}],[\"isolate中有两种thread\",{\"1\":{\"392\":1}}],[\"isolate内部维持一个event\",{\"1\":{\"391\":1}}],[\"isolate是dart代码运行的地方\",{\"1\":{\"391\":1}}],[\"isolate的mutator\",{\"1\":{\"392\":1}}],[\"isolate的创建工作已经完成\",{\"1\":{\"389\":1}}],[\"isolate的resumecapability\",{\"1\":{\"375\":1}}],[\"isolatelibrary\",{\"1\":{\"389\":1}}],[\"isolateleavescope\",{\"1\":{\"115\":2}}],[\"isolate包装isolate\",{\"1\":{\"387\":1}}],[\"isolatename\",{\"1\":{\"383\":1}}],[\"isolatemessagehandler\",{\"1\":{\"383\":1}}],[\"isolateflags\",{\"1\":{\"383\":2,\"384\":1,\"386\":1,\"387\":2,\"388\":2}}],[\"isolate>\",{\"1\":{\"383\":2}}],[\"isolategroupsource\",{\"1\":{\"388\":1}}],[\"isolategroupdata\",{\"1\":{\"387\":1}}],[\"isolategroup\",{\"1\":{\"381\":1,\"382\":1,\"383\":5,\"388\":2}}],[\"isolate=\",{\"1\":{\"381\":2,\"386\":1,\"388\":1}}],[\"isolate创建会占用内存\",{\"1\":{\"372\":1}}],[\"isolatedata\",{\"1\":{\"382\":1,\"387\":4}}],[\"isolated\",{\"1\":{\"372\":1}}],[\"isolate源码分析\",{\"0\":{\"372\":1}}],[\"isolatesetuphelper\",{\"1\":{\"387\":1}}],[\"isolatespawnstate\",{\"1\":{\"379\":1,\"384\":1}}],[\"isolatespawnexception\",{\"1\":{\"378\":2}}],[\"isolates\",{\"1\":{\"115\":3,\"136\":2,\"372\":2,\"383\":4,\"386\":1,\"387\":2,\"389\":1,\"391\":3}}],[\"isolatescheduleimmediate\",{\"1\":{\"100\":3}}],[\"isolate\",{\"0\":{\"379\":1,\"382\":1,\"384\":1,\"387\":1,\"389\":1},\"1\":{\"100\":3,\"101\":1,\"106\":1,\"108\":1,\"111\":1,\"112\":2,\"115\":12,\"116\":1,\"372\":15,\"373\":24,\"375\":2,\"376\":11,\"377\":19,\"378\":34,\"379\":10,\"380\":6,\"381\":23,\"382\":31,\"383\":64,\"384\":7,\"386\":13,\"387\":69,\"388\":11,\"389\":32,\"391\":17,\"392\":1}}],[\"isonscrollbarthumb\",{\"1\":{\"13\":1}}],[\"iscanceled\",{\"1\":{\"365\":1}}],[\"iscancelled\",{\"1\":{\"80\":2}}],[\"iscomplete\",{\"1\":{\"103\":2}}],[\"iscompleted\",{\"1\":{\"102\":2}}],[\"ischained\",{\"1\":{\"103\":1}}],[\"isclick\",{\"1\":{\"64\":1}}],[\"is\",{\"1\":{\"13\":2,\"15\":1,\"37\":1,\"40\":1,\"45\":1,\"49\":1,\"75\":1,\"78\":1,\"79\":1,\"80\":3,\"93\":1,\"97\":1,\"100\":1,\"102\":6,\"103\":5,\"105\":4,\"108\":2,\"111\":6,\"112\":1,\"115\":11,\"118\":2,\"121\":3,\"126\":2,\"127\":1,\"131\":2,\"133\":1,\"136\":1,\"143\":5,\"147\":11,\"153\":1,\"154\":8,\"155\":1,\"158\":1,\"165\":1,\"179\":2,\"180\":4,\"186\":1,\"193\":3,\"196\":3,\"198\":5,\"202\":1,\"206\":1,\"211\":3,\"216\":2,\"220\":6,\"225\":3,\"226\":3,\"230\":1,\"243\":1,\"272\":1,\"274\":1,\"275\":3,\"276\":1,\"280\":1,\"281\":1,\"283\":1,\"287\":2,\"297\":2,\"302\":4,\"316\":1,\"322\":3,\"327\":5,\"334\":2,\"365\":1,\"370\":1,\"371\":3,\"376\":1,\"378\":4,\"379\":1,\"381\":3,\"382\":1,\"383\":11,\"384\":1,\"386\":3,\"387\":11,\"388\":2,\"389\":9,\"391\":6,\"392\":2,\"395\":1,\"396\":1,\"414\":1,\"417\":1}}],[\"iterating\",{\"1\":{\"102\":1}}],[\"iterable<future<t>>\",{\"1\":{\"102\":2}}],[\"item\",{\"1\":{\"232\":1,\"233\":1,\"234\":1,\"401\":1,\"453\":13}}],[\"itemcount\",{\"1\":{\"131\":1}}],[\"itembuilder\",{\"1\":{\"131\":1}}],[\"item><\",{\"1\":{\"66\":2}}],[\"itemtouchhelper源码分析\",{\"1\":{\"41\":1}}],[\"itself\",{\"1\":{\"115\":1,\"147\":1,\"306\":1}}],[\"its\",{\"1\":{\"13\":1,\"102\":1,\"103\":2,\"106\":1,\"111\":2,\"115\":2,\"122\":1,\"147\":2,\"154\":2,\"179\":2,\"180\":1,\"192\":1,\"242\":1,\"275\":3,\"279\":1,\"287\":1,\"306\":1,\"312\":1,\"372\":4,\"391\":1,\"426\":1}}],[\"it\",{\"1\":{\"13\":2,\"40\":1,\"58\":1,\"59\":1,\"75\":1,\"78\":3,\"87\":2,\"102\":1,\"111\":1,\"115\":7,\"118\":2,\"133\":1,\"134\":1,\"155\":1,\"176\":1,\"180\":2,\"193\":2,\"196\":1,\"198\":3,\"216\":2,\"220\":1,\"221\":1,\"225\":2,\"226\":3,\"275\":3,\"287\":1,\"297\":1,\"308\":2,\"321\":4,\"327\":4,\"345\":4,\"346\":2,\"376\":1,\"382\":1,\"383\":3,\"386\":1,\"387\":1,\"389\":3,\"391\":5,\"392\":1,\"396\":1,\"400\":1,\"438\":3}}],[\"if\",{\"1\":{\"2\":3,\"13\":18,\"24\":1,\"29\":3,\"36\":5,\"40\":3,\"41\":1,\"43\":1,\"45\":4,\"46\":1,\"47\":2,\"48\":2,\"49\":8,\"52\":1,\"56\":2,\"58\":3,\"64\":6,\"65\":4,\"69\":4,\"72\":5,\"78\":2,\"80\":8,\"81\":3,\"95\":1,\"96\":4,\"97\":2,\"98\":4,\"99\":1,\"100\":1,\"101\":3,\"102\":17,\"103\":8,\"104\":2,\"105\":8,\"106\":6,\"107\":1,\"108\":13,\"109\":12,\"111\":13,\"112\":6,\"114\":2,\"115\":38,\"116\":1,\"118\":2,\"119\":1,\"121\":6,\"126\":4,\"127\":1,\"128\":1,\"131\":1,\"135\":2,\"136\":1,\"143\":1,\"149\":2,\"150\":2,\"153\":1,\"155\":1,\"163\":1,\"166\":2,\"167\":1,\"176\":5,\"179\":5,\"180\":8,\"184\":2,\"185\":1,\"186\":1,\"191\":1,\"193\":6,\"198\":13,\"201\":13,\"202\":3,\"205\":2,\"206\":1,\"207\":1,\"209\":2,\"210\":1,\"211\":16,\"213\":2,\"220\":10,\"221\":3,\"223\":4,\"225\":7,\"226\":12,\"227\":2,\"228\":1,\"230\":1,\"235\":3,\"237\":3,\"238\":2,\"239\":2,\"240\":1,\"243\":1,\"272\":7,\"275\":2,\"288\":2,\"289\":3,\"294\":4,\"296\":2,\"297\":6,\"300\":2,\"305\":5,\"307\":1,\"309\":7,\"312\":6,\"322\":2,\"328\":1,\"346\":1,\"363\":3,\"364\":2,\"365\":6,\"369\":2,\"370\":1,\"371\":5,\"376\":1,\"378\":3,\"380\":1,\"381\":4,\"382\":11,\"383\":43,\"384\":3,\"386\":4,\"387\":20,\"388\":2,\"389\":25,\"390\":5,\"391\":40,\"401\":1,\"417\":1,\"422\":2,\"426\":1,\"430\":1,\"432\":13,\"437\":1,\"438\":5,\"441\":6,\"451\":4,\"453\":8,\"455\":1,\"456\":1,\"457\":1,\"459\":5,\"462\":6,\"467\":3}}],[\"inprogress等回调能够在ui线程进行\",{\"1\":{\"365\":1}}],[\"input\",{\"1\":{\"183\":1,\"321\":3,\"368\":1}}],[\"inputfilter\",{\"1\":{\"36\":1}}],[\"inputdevice\",{\"1\":{\"13\":1}}],[\"inorder\",{\"1\":{\"346\":7}}],[\"inout\",{\"1\":{\"34\":1}}],[\"inmicroseconds\",{\"1\":{\"163\":1}}],[\"inmilliseconds\",{\"1\":{\"105\":2}}],[\"inheritednestedscrollview\",{\"1\":{\"213\":1}}],[\"inherited\",{\"1\":{\"130\":1,\"298\":1}}],[\"inheritedelement\",{\"1\":{\"128\":2}}],[\"inheritedwidget下面的所有子类\",{\"1\":{\"130\":1}}],[\"inheritedwidget>\",{\"1\":{\"129\":1}}],[\"inheritedwidget的获取方式\",{\"0\":{\"129\":1}}],[\"inheritedwidget持有的状态是final的\",{\"1\":{\"128\":1}}],[\"inheritedwidget是持有状态的widget\",{\"1\":{\"128\":1}}],[\"inheritedwidget→proxywidget\",{\"1\":{\"128\":1}}],[\"inheritedwidget\",{\"1\":{\"128\":2,\"130\":2,\"178\":1}}],[\"inheritedwidgets\",{\"1\":{\"117\":1,\"122\":2,\"126\":1,\"130\":1}}],[\"inherit\",{\"1\":{\"126\":1,\"378\":1}}],[\"inactive\",{\"1\":{\"109\":1,\"138\":1}}],[\"inner会先向上滑动\",{\"1\":{\"226\":1}}],[\"innerdelta\",{\"1\":{\"226\":9}}],[\"innerposition\",{\"1\":{\"225\":7}}],[\"innerpositions\",{\"1\":{\"223\":1,\"225\":3,\"226\":10}}],[\"inneractivitygetter\",{\"1\":{\"225\":3}}],[\"inner和outer\",{\"1\":{\"213\":1}}],[\"innercontroller\",{\"1\":{\"212\":1,\"213\":5,\"224\":1}}],[\"innerscrollposition\",{\"1\":{\"223\":1}}],[\"innerscroll\",{\"1\":{\"212\":1}}],[\"inner\",{\"1\":{\"95\":1,\"101\":1,\"212\":2,\"213\":1,\"217\":1,\"223\":1,\"225\":8,\"226\":11,\"281\":10}}],[\"innermodule\",{\"1\":{\"91\":2}}],[\"inccounter\",{\"1\":{\"334\":2}}],[\"inclusive\",{\"1\":{\"302\":1}}],[\"including\",{\"1\":{\"115\":1,\"154\":1}}],[\"include\",{\"1\":{\"114\":1,\"115\":2,\"306\":1,\"423\":1}}],[\"includes\",{\"1\":{\"91\":1,\"392\":1}}],[\"incurred\",{\"1\":{\"216\":1}}],[\"inc\",{\"1\":{\"108\":1}}],[\"incremental\",{\"1\":{\"387\":1}}],[\"incrementandget\",{\"1\":{\"334\":1}}],[\"increment\",{\"1\":{\"102\":2,\"272\":1}}],[\"incominghandler\",{\"1\":{\"20\":1}}],[\"incominghanlder\",{\"1\":{\"20\":1}}],[\"incominghanler\",{\"1\":{\"20\":1}}],[\"injection\",{\"1\":{\"87\":1}}],[\"inject后service类变成如下\",{\"1\":{\"85\":1}}],[\"inject修饰\",{\"1\":{\"85\":1}}],[\"inject修饰其构造函数的\",{\"1\":{\"84\":1}}],[\"inject注解已经没用了\",{\"1\":{\"85\":1}}],[\"inject注解\",{\"1\":{\"85\":1}}],[\"inject构造方法其实是失效了的\",{\"1\":{\"85\":1}}],[\"inject中查找\",{\"1\":{\"85\":1}}],[\"inject标记该对象\",{\"1\":{\"84\":1}}],[\"inject标记其构造方法\",{\"1\":{\"84\":1}}],[\"inject主要做两件事❶标记依赖类的构造方法\",{\"1\":{\"83\":1}}],[\"inject\",{\"0\":{\"83\":1},\"1\":{\"83\":3,\"84\":3,\"85\":3,\"86\":1,\"87\":2,\"89\":1,\"92\":2,\"93\":2,\"94\":2}}],[\"inline函数可以结合reified实现实体化类型参数\",{\"1\":{\"322\":1}}],[\"inline修饰的函数的lambda参数如果运行在该函数内部的\",{\"1\":{\"322\":1}}],[\"inline修饰的函数在被调用时将字节码动态插入到被到调用的地方\",{\"1\":{\"322\":1}}],[\"inline\",{\"1\":{\"81\":2,\"322\":2,\"395\":3,\"396\":1,\"397\":1}}],[\"infilename\",{\"1\":{\"357\":1}}],[\"infix\",{\"1\":{\"322\":1,\"453\":3}}],[\"infix声明\",{\"1\":{\"322\":1}}],[\"infinity无限大时\",{\"1\":{\"242\":1}}],[\"infinity\",{\"1\":{\"152\":1,\"161\":1,\"212\":1,\"220\":11,\"225\":1,\"226\":1}}],[\"infinite\",{\"1\":{\"63\":1}}],[\"inf\",{\"1\":{\"282\":2}}],[\"info描述的\",{\"1\":{\"283\":1}}],[\"informationcollector\",{\"1\":{\"196\":1,\"201\":1}}],[\"information\",{\"1\":{\"133\":1,\"202\":1,\"295\":1}}],[\"info\",{\"1\":{\"79\":4,\"192\":3,\"198\":4,\"243\":1,\"245\":1,\"246\":1,\"247\":1,\"248\":1,\"283\":1,\"371\":9,\"414\":1,\"425\":1}}],[\"inflatewidget\",{\"1\":{\"127\":1}}],[\"inflatewidget方法中大概会执行下面几步\",{\"1\":{\"122\":1}}],[\"inflate\",{\"1\":{\"56\":1,\"66\":1}}],[\"in的动画解释\",{\"1\":{\"57\":1}}],[\"independent\",{\"1\":{\"225\":1}}],[\"indexc++\",{\"1\":{\"459\":4}}],[\"indexc\",{\"1\":{\"459\":1}}],[\"indexb++\",{\"1\":{\"459\":2}}],[\"indexb\",{\"1\":{\"459\":4}}],[\"indexa++\",{\"1\":{\"459\":2}}],[\"indexa\",{\"1\":{\"459\":4}}],[\"indexactivity\",{\"1\":{\"71\":1}}],[\"indexedslot<element\",{\"1\":{\"127\":1,\"230\":1}}],[\"indexornext指向自己\",{\"1\":{\"106\":1}}],[\"indexornext\",{\"1\":{\"106\":1,\"109\":1}}],[\"indexofroot\",{\"1\":{\"346\":3}}],[\"indexofkey\",{\"1\":{\"51\":1,\"65\":1}}],[\"indexof\",{\"1\":{\"49\":3,\"346\":1}}],[\"index1\",{\"1\":{\"58\":1}}],[\"index<<1\",{\"1\":{\"49\":2,\"50\":2,\"51\":1}}],[\"index\",{\"1\":{\"45\":2,\"49\":10,\"50\":4,\"51\":2,\"52\":1,\"58\":1,\"63\":3,\"72\":3,\"131\":3,\"212\":1,\"234\":1,\"280\":5,\"289\":7,\"306\":1,\"309\":1,\"397\":1,\"437\":5,\"438\":3,\"440\":3,\"441\":2,\"455\":2,\"456\":4,\"457\":5,\"462\":5}}],[\"individual\",{\"1\":{\"426\":1}}],[\"indirpath\",{\"1\":{\"357\":1}}],[\"indirtylist\",{\"1\":{\"117\":1,\"122\":2,\"126\":1}}],[\"indicates\",{\"1\":{\"389\":1}}],[\"indicate\",{\"1\":{\"115\":1}}],[\"indicating\",{\"1\":{\"49\":1,\"102\":1}}],[\"indices\",{\"1\":{\"45\":1}}],[\"invertcolors\",{\"1\":{\"193\":2}}],[\"inventory\",{\"1\":{\"10\":1,\"11\":3}}],[\"invalid\",{\"1\":{\"111\":1,\"180\":1,\"305\":1,\"382\":1}}],[\"invalidate\",{\"1\":{\"41\":1,\"63\":1,\"64\":1}}],[\"invocation\",{\"1\":{\"389\":2,\"395\":2,\"396\":1}}],[\"invocationhandler\",{\"1\":{\"72\":1}}],[\"invoking\",{\"1\":{\"312\":1}}],[\"invokefunction\",{\"1\":{\"389\":1}}],[\"invokes\",{\"1\":{\"305\":1}}],[\"invokestatic的方法句柄对应的类未被初始化时\",{\"1\":{\"279\":1}}],[\"invokereadresolve\",{\"1\":{\"305\":2}}],[\"invokelistmethod\",{\"1\":{\"211\":2}}],[\"invokemethod\",{\"1\":{\"135\":1}}],[\"invoked\",{\"1\":{\"80\":1,\"96\":1,\"104\":2,\"396\":1}}],[\"invoke\",{\"1\":{\"72\":3,\"100\":2,\"111\":1,\"115\":1,\"272\":3,\"279\":1,\"295\":1,\"300\":1,\"345\":1,\"378\":2,\"394\":1,\"427\":1}}],[\"involves\",{\"1\":{\"275\":1,\"277\":1}}],[\"instertval\",{\"1\":{\"289\":3}}],[\"instertvalue\",{\"1\":{\"289\":3}}],[\"instead\",{\"1\":{\"103\":1,\"106\":1,\"107\":1,\"378\":1,\"383\":1,\"391\":1}}],[\"inst\",{\"1\":{\"282\":2}}],[\"instruction\",{\"1\":{\"395\":1}}],[\"instructions\",{\"1\":{\"382\":2,\"383\":3,\"387\":2,\"388\":2,\"396\":1}}],[\"instrumentation\",{\"1\":{\"282\":6}}],[\"instrument\",{\"1\":{\"282\":1}}],[\"instrinsicwidth因为至少需要对child进行两次layout\",{\"1\":{\"242\":1}}],[\"instrinsicwidth来解决此问题\",{\"1\":{\"242\":1}}],[\"instrinsicheight会强制其child的大小为固有高度\",{\"1\":{\"242\":1}}],[\"instantiateimagecodec\",{\"1\":{\"196\":2,\"201\":4,\"202\":1}}],[\"instance为null则会先用构造方法创建\",{\"1\":{\"118\":1}}],[\"instance\",{\"1\":{\"108\":1,\"118\":3,\"119\":1,\"127\":1,\"162\":1,\"168\":1,\"179\":1,\"196\":3,\"197\":1,\"202\":2,\"209\":4,\"210\":1,\"211\":9,\"216\":1,\"272\":1,\"294\":1,\"322\":1,\"383\":1,\"389\":2}}],[\"instancesize\",{\"1\":{\"116\":1}}],[\"instances\",{\"1\":{\"75\":1,\"132\":1,\"322\":1,\"396\":1}}],[\"instanceof\",{\"1\":{\"40\":1,\"55\":2,\"58\":1,\"72\":1,\"211\":2,\"309\":2,\"312\":3}}],[\"installing\",{\"1\":{\"102\":1}}],[\"install\",{\"1\":{\"14\":6,\"102\":1,\"347\":1,\"348\":2,\"413\":1}}],[\"inside\",{\"1\":{\"98\":2,\"212\":1,\"233\":3}}],[\"insameerrorzone\",{\"1\":{\"96\":2}}],[\"insertpoint\",{\"1\":{\"457\":3}}],[\"insertindex\",{\"1\":{\"451\":7,\"457\":3}}],[\"inserting\",{\"1\":{\"49\":1}}],[\"insertrenderobjectchild\",{\"1\":{\"121\":1,\"127\":2,\"230\":2}}],[\"insertsort\",{\"1\":{\"289\":2,\"451\":1,\"457\":1,\"462\":3}}],[\"inserts\",{\"1\":{\"45\":1,\"80\":1}}],[\"insert\",{\"1\":{\"1\":1,\"45\":3,\"109\":1,\"115\":1,\"181\":1,\"230\":1,\"322\":1,\"369\":1,\"453\":5}}],[\"initforsnapshot\",{\"1\":{\"382\":2}}],[\"initvm\",{\"1\":{\"382\":1}}],[\"init的时候就已经设置了的\",{\"1\":{\"382\":1}}],[\"initbuilder\",{\"1\":{\"364\":1}}],[\"initclient\",{\"1\":{\"362\":1,\"363\":1}}],[\"initkey\",{\"1\":{\"296\":2}}],[\"init是对象构造器方法\",{\"1\":{\"279\":1}}],[\"initstate方法中创建\",{\"1\":{\"181\":1}}],[\"initstate方法中\",{\"1\":{\"148\":1}}],[\"initstate\",{\"0\":{\"148\":1},\"1\":{\"130\":4,\"135\":2,\"152\":2,\"153\":2,\"155\":2,\"178\":3,\"213\":2}}],[\"initserviceextensions\",{\"1\":{\"118\":1}}],[\"initmousetracker\",{\"1\":{\"118\":1}}],[\"initrenderview\",{\"1\":{\"118\":2}}],[\"initinstance\",{\"1\":{\"383\":1}}],[\"initinstances方法创建\",{\"1\":{\"119\":2}}],[\"initinstances\",{\"1\":{\"118\":4}}],[\"initisolatefromsnapshot\",{\"1\":{\"383\":1}}],[\"initisolate方法中\",{\"1\":{\"383\":1}}],[\"initisolate创建虚拟机对应的isolate\",{\"1\":{\"383\":1}}],[\"initisolate\",{\"1\":{\"383\":3}}],[\"initialdelaymillis\",{\"1\":{\"328\":2}}],[\"initialization\",{\"0\":{\"279\":1},\"1\":{\"277\":1,\"279\":2,\"382\":1}}],[\"initializing\",{\"1\":{\"277\":1,\"279\":1,\"382\":1}}],[\"initialize中配置的\",{\"1\":{\"387\":1}}],[\"initializeisolate初始化isolate\",{\"1\":{\"383\":1}}],[\"initializeisolate\",{\"1\":{\"383\":5}}],[\"initializeparams\",{\"1\":{\"382\":6}}],[\"initializecallback\",{\"0\":{\"382\":1},\"1\":{\"381\":2,\"382\":2,\"387\":1}}],[\"initialize\",{\"1\":{\"381\":4,\"382\":9,\"383\":2,\"391\":1}}],[\"initializer\",{\"1\":{\"322\":4}}],[\"initializers\",{\"1\":{\"277\":1}}],[\"initialized\",{\"1\":{\"216\":1,\"314\":1,\"382\":2,\"383\":3}}],[\"initializes\",{\"1\":{\"118\":1,\"165\":1}}],[\"initialpixels\",{\"1\":{\"215\":1}}],[\"initialscrolloffset\",{\"1\":{\"213\":1,\"215\":1}}],[\"initially\",{\"1\":{\"198\":1}}],[\"initiallayout=\",{\"1\":{\"79\":1}}],[\"initialmanifest\",{\"1\":{\"181\":5}}],[\"initialt\",{\"1\":{\"167\":1}}],[\"initialvalue\",{\"1\":{\"167\":1,\"288\":2}}],[\"initial\",{\"1\":{\"13\":2,\"179\":1,\"181\":8,\"280\":2,\"288\":1,\"337\":1,\"373\":1,\"383\":1,\"388\":1}}],[\"init进程孵化出用户守护进程\",{\"1\":{\"60\":1}}],[\"init进程\",{\"1\":{\"60\":1}}],[\"init\",{\"1\":{\"35\":1,\"37\":1,\"81\":4,\"82\":2,\"84\":1,\"115\":1,\"294\":4,\"295\":2,\"296\":4,\"322\":1,\"347\":1,\"369\":5,\"371\":3,\"381\":1,\"382\":25,\"383\":5,\"414\":1,\"416\":1}}],[\"initwindowdecoractionbar\",{\"1\":{\"13\":1}}],[\"in\",{\"1\":{\"13\":2,\"14\":1,\"15\":1,\"34\":1,\"35\":5,\"43\":1,\"49\":1,\"52\":1,\"53\":1,\"57\":2,\"59\":2,\"65\":1,\"80\":4,\"96\":1,\"98\":1,\"102\":7,\"103\":1,\"104\":2,\"105\":3,\"106\":3,\"109\":2,\"111\":2,\"115\":6,\"125\":2,\"130\":2,\"136\":1,\"147\":1,\"179\":1,\"180\":7,\"181\":1,\"186\":1,\"195\":1,\"198\":2,\"209\":1,\"213\":1,\"220\":5,\"223\":1,\"225\":3,\"226\":7,\"234\":1,\"243\":1,\"272\":1,\"275\":1,\"278\":1,\"281\":3,\"282\":1,\"302\":14,\"306\":4,\"310\":1,\"311\":5,\"322\":3,\"327\":9,\"328\":2,\"334\":2,\"336\":1,\"341\":1,\"345\":1,\"369\":2,\"370\":1,\"371\":4,\"372\":4,\"378\":1,\"383\":6,\"387\":1,\"389\":1,\"391\":7,\"392\":2,\"395\":2,\"400\":1,\"417\":1,\"422\":1,\"426\":2,\"455\":2,\"456\":2,\"457\":2,\"462\":4,\"467\":1}}],[\"intarrb\",{\"1\":{\"459\":8}}],[\"intarra\",{\"1\":{\"459\":8}}],[\"intarrayof\",{\"1\":{\"346\":2}}],[\"intarray\",{\"1\":{\"69\":1,\"346\":2,\"451\":1,\"455\":4,\"456\":4,\"457\":4,\"459\":6,\"462\":19,\"467\":1}}],[\"intarr\",{\"1\":{\"459\":7}}],[\"intraversing\",{\"1\":{\"430\":3}}],[\"introduced\",{\"1\":{\"396\":1}}],[\"intrinsicheight\",{\"1\":{\"242\":2}}],[\"intrinsically\",{\"1\":{\"212\":1}}],[\"inttween\",{\"1\":{\"184\":1}}],[\"int64\",{\"1\":{\"108\":4,\"115\":1,\"387\":1,\"391\":1}}],[\"intptr\",{\"1\":{\"108\":5,\"383\":1,\"387\":1,\"391\":1}}],[\"intomap\",{\"1\":{\"91\":1}}],[\"into\",{\"1\":{\"40\":1,\"45\":1,\"58\":1,\"102\":1,\"272\":1,\"275\":1,\"347\":1,\"383\":4,\"392\":1,\"396\":1}}],[\"int>\",{\"1\":{\"10\":1,\"322\":1}}],[\"integer\",{\"1\":{\"291\":1,\"296\":3}}],[\"integer>数组\",{\"1\":{\"291\":1}}],[\"integer>\",{\"1\":{\"287\":2,\"291\":3}}],[\"integration\",{\"1\":{\"54\":2}}],[\"intended\",{\"1\":{\"287\":1}}],[\"intentservice以及普通的线程thread\",{\"1\":{\"80\":1}}],[\"intent中使用bundle\",{\"1\":{\"40\":1}}],[\"intent\",{\"0\":{\"135\":1},\"1\":{\"2\":8,\"3\":3,\"7\":2,\"9\":1,\"17\":15,\"19\":6,\"20\":2,\"35\":6,\"36\":3,\"39\":2,\"43\":4,\"58\":5,\"71\":1,\"72\":12,\"75\":5,\"78\":5,\"79\":15}}],[\"intermediate\",{\"1\":{\"327\":1}}],[\"inter\",{\"1\":{\"115\":1,\"459\":4}}],[\"interrupts\",{\"1\":{\"376\":2}}],[\"interruptedexception\",{\"1\":{\"297\":2}}],[\"interrupt\",{\"1\":{\"108\":3,\"391\":1}}],[\"interruptmessage\",{\"1\":{\"108\":1}}],[\"intern\",{\"1\":{\"254\":3,\"258\":1}}],[\"internalwriteentries\",{\"1\":{\"280\":1}}],[\"internal创建的\",{\"1\":{\"106\":1}}],[\"internal创建timer\",{\"1\":{\"105\":1}}],[\"internal只是简单创建了timer\",{\"1\":{\"105\":1}}],[\"internal\",{\"1\":{\"99\":1,\"100\":1,\"101\":1,\"105\":5,\"106\":2,\"107\":1,\"108\":3,\"109\":2,\"111\":2,\"112\":3,\"115\":1,\"372\":1,\"376\":1,\"377\":3,\"378\":2}}],[\"internalhandler\",{\"1\":{\"80\":3}}],[\"internet\",{\"1\":{\"78\":1}}],[\"interpreter\",{\"1\":{\"387\":1,\"392\":1}}],[\"interpreted\",{\"1\":{\"15\":1}}],[\"interpolation\",{\"1\":{\"184\":1}}],[\"interpolationsimulation\",{\"0\":{\"166\":1},\"1\":{\"166\":1,\"182\":1}}],[\"interpolator\",{\"1\":{\"63\":1}}],[\"interfaces\",{\"1\":{\"276\":1}}],[\"interface\",{\"1\":{\"32\":1,\"35\":3,\"40\":5,\"43\":1,\"56\":1,\"58\":5,\"64\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":2,\"89\":1,\"90\":1,\"105\":2,\"274\":2,\"275\":4,\"276\":1,\"277\":1,\"279\":2,\"281\":1,\"299\":1,\"312\":1,\"322\":6,\"345\":1}}],[\"intercept每次action\",{\"1\":{\"13\":1}}],[\"intercept\",{\"1\":{\"13\":4,\"102\":1}}],[\"intercepted\",{\"1\":{\"13\":9}}],[\"interception\",{\"1\":{\"13\":2}}],[\"interval\",{\"1\":{\"6\":1,\"10\":1}}],[\"int\",{\"0\":{\"45\":1,\"46\":1,\"47\":1},\"1\":{\"2\":3,\"3\":2,\"7\":1,\"13\":4,\"17\":3,\"20\":1,\"21\":1,\"35\":3,\"36\":3,\"37\":1,\"40\":3,\"41\":2,\"44\":2,\"45\":4,\"46\":3,\"47\":3,\"48\":4,\"49\":10,\"51\":1,\"52\":4,\"53\":3,\"55\":6,\"56\":1,\"58\":3,\"64\":6,\"65\":18,\"69\":1,\"72\":2,\"75\":8,\"79\":3,\"81\":5,\"101\":1,\"102\":2,\"105\":8,\"106\":1,\"108\":3,\"109\":2,\"110\":2,\"111\":11,\"112\":6,\"115\":3,\"127\":1,\"131\":2,\"184\":3,\"188\":2,\"192\":1,\"198\":1,\"201\":1,\"210\":9,\"211\":7,\"226\":1,\"277\":1,\"280\":8,\"281\":4,\"282\":7,\"283\":1,\"285\":1,\"287\":5,\"289\":19,\"295\":3,\"296\":4,\"299\":3,\"300\":2,\"308\":1,\"309\":1,\"311\":1,\"314\":3,\"321\":1,\"322\":3,\"325\":1,\"345\":2,\"346\":1,\"363\":1,\"364\":2,\"365\":2,\"376\":2,\"382\":1,\"387\":2,\"389\":1,\"429\":1,\"432\":1,\"440\":1,\"441\":1,\"450\":2,\"451\":3,\"453\":6,\"459\":3,\"460\":1,\"462\":3,\"467\":6}}],[\"imissyou\",{\"1\":{\"407\":4}}],[\"immediately\",{\"1\":{\"101\":2,\"103\":1}}],[\"immediatecallback\",{\"1\":{\"100\":1}}],[\"immediate\",{\"1\":{\"100\":4,\"101\":1,\"373\":1,\"376\":3}}],[\"im\",{\"1\":{\"58\":2,\"59\":1,\"137\":1,\"306\":1}}],[\"imessenger\",{\"1\":{\"43\":7}}],[\"improve\",{\"1\":{\"130\":1}}],[\"implicitstaticclosure\",{\"1\":{\"389\":1}}],[\"implicitclosurefunction\",{\"1\":{\"389\":1}}],[\"implicitly\",{\"1\":{\"147\":12,\"180\":1}}],[\"implicitlyanimatedwidget>\",{\"1\":{\"147\":1,\"152\":1}}],[\"implicitlyanimatedwidgetstate<t>\",{\"1\":{\"152\":1}}],[\"implicitlyanimatedwidgetstate<t\",{\"1\":{\"147\":1}}],[\"implicitlyanimatedwidgetstate<implicitlyanimatedwidget>\",{\"1\":{\"147\":1}}],[\"implicitlyanimatedwidgetstate\",{\"1\":{\"147\":3,\"150\":1,\"152\":2}}],[\"implicitlyanimatedwidgets\",{\"1\":{\"147\":1}}],[\"implicitlyanimatedwidget\",{\"0\":{\"146\":1,\"147\":1},\"1\":{\"146\":1,\"147\":6,\"150\":2,\"152\":3,\"153\":3,\"154\":2,\"155\":1,\"156\":2,\"157\":2}}],[\"impl\",{\"1\":{\"103\":2,\"105\":2,\"106\":2,\"107\":1,\"108\":1,\"109\":2,\"111\":5,\"115\":3,\"116\":1,\"211\":1,\"381\":1,\"382\":1,\"383\":1,\"388\":1,\"389\":1}}],[\"implemented\",{\"1\":{\"345\":1}}],[\"implementation\",{\"1\":{\"40\":1,\"58\":1,\"87\":1,\"88\":2,\"96\":2,\"111\":1,\"115\":1,\"322\":2}}],[\"implements\",{\"1\":{\"35\":1,\"36\":1,\"40\":2,\"44\":1,\"56\":1,\"58\":2,\"72\":2,\"80\":1,\"101\":1,\"103\":1,\"106\":1,\"111\":4,\"158\":1,\"196\":1,\"201\":1,\"211\":2,\"217\":1,\"224\":1,\"229\":1,\"237\":1,\"280\":1,\"281\":1,\"285\":1,\"287\":2,\"308\":1,\"311\":1}}],[\"importnew\",{\"1\":{\"301\":1}}],[\"important\",{\"1\":{\"49\":1}}],[\"import\",{\"1\":{\"34\":2,\"35\":12,\"36\":13,\"43\":1,\"58\":1,\"81\":7,\"110\":1,\"132\":2,\"201\":1,\"282\":1,\"328\":2,\"347\":1,\"369\":4,\"370\":1,\"371\":6}}],[\"imports\",{\"1\":{\"1\":2}}],[\"imooc\",{\"1\":{\"15\":1}}],[\"image默认的\",{\"1\":{\"211\":1}}],[\"imageloader\",{\"1\":{\"211\":4}}],[\"imageloaders\",{\"1\":{\"211\":4}}],[\"imageleft\",{\"1\":{\"56\":1}}],[\"imagerequestconfig\",{\"1\":{\"211\":1}}],[\"imageright\",{\"1\":{\"56\":1}}],[\"imagetype表示获取图片的方式\",{\"1\":{\"211\":1}}],[\"imagetype\",{\"1\":{\"211\":6}}],[\"imageheight\",{\"1\":{\"211\":2}}],[\"imagewidth\",{\"1\":{\"211\":2}}],[\"image中分析的加载大量高清网图会出现的内存爆炸\",{\"1\":{\"211\":1}}],[\"image展示图片\",{\"1\":{\"209\":1}}],[\"image类型会返回不同的\",{\"1\":{\"205\":1}}],[\"image类的封装\",{\"1\":{\"194\":1}}],[\"imagebuilder\",{\"1\":{\"205\":2,\"206\":1,\"207\":4}}],[\"imageextstate\",{\"1\":{\"207\":2}}],[\"imageext\",{\"1\":{\"205\":1,\"206\":1,\"207\":4}}],[\"imageerrorwidgetbuilder\",{\"1\":{\"205\":1}}],[\"imageerrorlistener\",{\"1\":{\"198\":1,\"202\":1}}],[\"image属性\",{\"1\":{\"204\":1}}],[\"image可以大体划分为flutter\",{\"1\":{\"203\":1}}],[\"image能够较好的解决上述问题\",{\"1\":{\"203\":1}}],[\"image都是在\",{\"1\":{\"203\":1}}],[\"image则是一款为\",{\"1\":{\"202\":1}}],[\"image则是借助flutter\",{\"1\":{\"202\":1}}],[\"image创建extendedrawimage以展示图片内容\",{\"1\":{\"200\":1}}],[\"image创建了rawimage来展示图片\",{\"1\":{\"193\":1}}],[\"image传入\",{\"1\":{\"198\":1}}],[\"image>\",{\"1\":{\"196\":1,\"210\":3}}],[\"image参数\",{\"1\":{\"195\":1}}],[\"image的关键类之一\",{\"1\":{\"208\":1}}],[\"image的\",{\"1\":{\"207\":1}}],[\"image的封装类\",{\"1\":{\"195\":1}}],[\"image的包装类\",{\"1\":{\"195\":1}}],[\"image的内容\",{\"1\":{\"194\":1}}],[\"image实际是ui\",{\"1\":{\"195\":1}}],[\"image代表的图片\",{\"1\":{\"195\":1}}],[\"image之后\",{\"1\":{\"195\":1,\"211\":1}}],[\"image对应的实现\",{\"1\":{\"195\":1}}],[\"image对应的\",{\"1\":{\"194\":1}}],[\"image对象传入\",{\"1\":{\"207\":1}}],[\"image对象转化为bytedata\",{\"1\":{\"194\":1}}],[\"image对象\",{\"1\":{\"193\":1}}],[\"image和其对应的scale\",{\"1\":{\"192\":1}}],[\"imageinfo并刷新页面\",{\"1\":{\"200\":1}}],[\"imageinfo类内部持有ui\",{\"1\":{\"192\":1}}],[\"imageinfo\",{\"1\":{\"192\":9,\"193\":8,\"195\":1,\"198\":3,\"206\":5,\"207\":7,\"211\":7}}],[\"image是阿里巴巴出品的\",{\"1\":{\"203\":1}}],[\"image是基于官方\",{\"1\":{\"199\":1}}],[\"image是\",{\"1\":{\"189\":1,\"205\":2}}],[\"image用于获取图片\",{\"1\":{\"188\":1}}],[\"imageprovider<t>\",{\"1\":{\"202\":1}}],[\"imageprovider<extendednetworkimageprovider>\",{\"1\":{\"201\":1}}],[\"imageprovider<image\",{\"1\":{\"196\":1,\"201\":1}}],[\"imageprovider>\",{\"1\":{\"196\":1}}],[\"imageprovider\",{\"0\":{\"196\":1},\"1\":{\"188\":5,\"190\":2,\"193\":1,\"196\":2,\"197\":1,\"198\":4,\"200\":5,\"202\":1,\"208\":2,\"209\":1,\"211\":1}}],[\"imageconfiguration\",{\"1\":{\"188\":3,\"196\":2,\"198\":2,\"202\":1}}],[\"imagecache>\",{\"1\":{\"202\":2}}],[\"imagecaches\",{\"1\":{\"202\":3}}],[\"imagecachestatus处理\",{\"1\":{\"197\":1}}],[\"imagecachename\",{\"1\":{\"201\":1,\"202\":3}}],[\"imagecache还提供imagecache\",{\"1\":{\"197\":1}}],[\"imagecache\",{\"0\":{\"197\":1},\"1\":{\"187\":1,\"188\":4,\"196\":4,\"197\":4,\"198\":3,\"199\":1,\"201\":2,\"202\":12,\"203\":1,\"209\":3}}],[\"image等基于混合开发的解决方案\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"image等基于\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"imagestate内部其实是使用ui\",{\"1\":{\"193\":1}}],[\"imagestate\",{\"0\":{\"189\":1},\"1\":{\"189\":2,\"190\":1,\"192\":1,\"193\":1,\"194\":1,\"195\":2,\"196\":1,\"198\":2}}],[\"imagestreamcompleters\",{\"1\":{\"197\":1}}],[\"imagestreamcompleter\",{\"1\":{\"196\":1,\"198\":4,\"201\":1,\"202\":2}}],[\"imagestreamlistener\",{\"1\":{\"191\":6,\"198\":4}}],[\"imagestream\",{\"1\":{\"188\":2,\"190\":4,\"191\":4,\"192\":1,\"193\":1,\"195\":1,\"196\":1,\"197\":2,\"198\":1,\"200\":1,\"202\":1}}],[\"images0\",{\"1\":{\"58\":1}}],[\"images\",{\"1\":{\"58\":1,\"197\":1}}],[\"imageview2\",{\"1\":{\"56\":1}}],[\"imageviewleft\",{\"1\":{\"56\":1}}],[\"imageview\",{\"1\":{\"55\":3,\"56\":1,\"66\":4,\"77\":1}}],[\"image\",{\"0\":{\"188\":1,\"199\":1,\"203\":1},\"1\":{\"2\":1,\"66\":2,\"187\":2,\"188\":20,\"189\":1,\"190\":2,\"191\":1,\"192\":5,\"193\":11,\"194\":12,\"195\":5,\"196\":13,\"197\":2,\"198\":26,\"199\":9,\"200\":4,\"201\":8,\"202\":12,\"203\":4,\"205\":7,\"206\":2,\"207\":6,\"208\":1,\"209\":3,\"210\":8,\"211\":19}}],[\"imageuri\",{\"1\":{\"2\":1}}],[\"imguri\",{\"1\":{\"2\":1}}],[\"img\",{\"1\":{\"2\":1,\"58\":1}}],[\"gh\",{\"1\":{\"407\":1}}],[\"garden\",{\"1\":{\"400\":8,\"401\":2}}],[\"gardenfragmentdirections\",{\"1\":{\"400\":1}}],[\"gardenfragment\",{\"1\":{\"399\":1,\"400\":1}}],[\"gardenactivity\",{\"1\":{\"399\":1}}],[\"gardenplantinglistviewmodel\",{\"1\":{\"402\":1}}],[\"gardenplantingrepository\",{\"1\":{\"399\":1}}],[\"gardenplantingdao\",{\"1\":{\"399\":1}}],[\"gardenplanting\",{\"1\":{\"399\":1}}],[\"garbage\",{\"1\":{\"392\":1}}],[\"gat\",{\"1\":{\"347\":1}}],[\"gzip压缩会删除源文件\",{\"1\":{\"356\":1}}],[\"gzip\",{\"0\":{\"356\":1},\"1\":{\"356\":2,\"357\":1}}],[\"gz先打包后压缩的格式\",{\"1\":{\"355\":1}}],[\"gz\",{\"1\":{\"355\":1,\"356\":3,\"357\":1}}],[\"g群组\",{\"1\":{\"351\":1}}],[\"gdafemhz\",{\"1\":{\"346\":1}}],[\"gdefault\",{\"1\":{\"72\":5}}],[\"gf\",{\"1\":{\"321\":1}}],[\"gmt\",{\"1\":{\"302\":1}}],[\"gmail\",{\"1\":{\"35\":1,\"36\":1,\"81\":1,\"308\":1,\"407\":1}}],[\"glidemultiframeimage\",{\"1\":{\"211\":1}}],[\"glideexception\",{\"1\":{\"211\":1}}],[\"glide\",{\"1\":{\"211\":1}}],[\"glue\",{\"1\":{\"118\":1,\"119\":1}}],[\"globalscope\",{\"1\":{\"329\":1}}],[\"globalrendertype\",{\"1\":{\"211\":2}}],[\"globalkey\",{\"1\":{\"121\":1}}],[\"globalobjectkey\",{\"1\":{\"120\":1}}],[\"global\",{\"1\":{\"80\":1,\"101\":1,\"347\":2,\"372\":1}}],[\"guy的计算\",{\"1\":{\"287\":1}}],[\"guy在speakerdeck中的说法\",{\"1\":{\"282\":1}}],[\"guarded\",{\"1\":{\"115\":1}}],[\"guide\",{\"1\":{\"43\":1,\"59\":1}}],[\"gone\",{\"1\":{\"401\":1}}],[\"goneunless=\",{\"1\":{\"401\":1}}],[\"goneunless的解析\",{\"1\":{\"401\":1}}],[\"goneunless\",{\"1\":{\"401\":2}}],[\"goto\",{\"1\":{\"382\":5}}],[\"goballistic\",{\"1\":{\"225\":2}}],[\"goidle\",{\"1\":{\"225\":1}}],[\"going\",{\"1\":{\"179\":1,\"220\":4,\"327\":1}}],[\"good\",{\"1\":{\"98\":1,\"180\":1,\"225\":1}}],[\"google大法nb\",{\"1\":{\"399\":1}}],[\"google3\",{\"1\":{\"387\":1}}],[\"google官方示例代码\",{\"1\":{\"94\":1}}],[\"google\",{\"1\":{\"2\":1,\"43\":1,\"59\":1,\"88\":3,\"140\":1,\"287\":2,\"314\":1,\"400\":1,\"401\":1}}],[\"go\",{\"1\":{\"49\":1,\"179\":1,\"226\":1,\"369\":4}}],[\"gc发生在这里\",{\"1\":{\"392\":1}}],[\"gc或full\",{\"1\":{\"288\":1}}],[\"gc时将存活对象复制到另一半内存\",{\"1\":{\"262\":1}}],[\"gc主要场所\",{\"1\":{\"250\":1}}],[\"gc\",{\"0\":{\"48\":1},\"1\":{\"44\":2,\"45\":1,\"48\":2,\"263\":1,\"288\":1,\"383\":2}}],[\"gecko\",{\"1\":{\"370\":1}}],[\"geometry\",{\"1\":{\"213\":2}}],[\"generic\",{\"1\":{\"383\":4}}],[\"general\",{\"1\":{\"302\":1}}],[\"generator\",{\"1\":{\"417\":1}}],[\"generaterequest\",{\"1\":{\"364\":1,\"365\":1}}],[\"generatekey\",{\"1\":{\"296\":1}}],[\"generate\",{\"0\":{\"247\":1},\"1\":{\"212\":1,\"234\":1,\"247\":1,\"407\":2,\"419\":1}}],[\"generated\",{\"1\":{\"40\":2,\"79\":5,\"295\":2,\"395\":1}}],[\"generating\",{\"1\":{\"40\":1,\"58\":1,\"247\":1}}],[\"gen\",{\"1\":{\"249\":2}}],[\"gensucret\",{\"1\":{\"211\":2}}],[\"genfailret\",{\"1\":{\"211\":2}}],[\"gesturerecognizers的方法\",{\"1\":{\"223\":1}}],[\"gesturerecognizers\",{\"1\":{\"223\":5}}],[\"gesturerecognizerfactory>\",{\"1\":{\"223\":3}}],[\"gestures\",{\"1\":{\"223\":1}}],[\"gesture\",{\"1\":{\"179\":1,\"181\":1}}],[\"gesturedetector\",{\"1\":{\"140\":1,\"172\":1}}],[\"gesturebinding\",{\"1\":{\"118\":2,\"119\":1}}],[\"getuninstallapkresource\",{\"1\":{\"427\":2}}],[\"geturiforfile\",{\"1\":{\"2\":2}}],[\"getokhttprequest\",{\"1\":{\"365\":2}}],[\"getobjectsize\",{\"1\":{\"282\":1}}],[\"getvalue\",{\"1\":{\"322\":2}}],[\"getviewadapterposition\",{\"1\":{\"64\":1}}],[\"getexternalstoragedirectory\",{\"1\":{\"425\":1}}],[\"getexternalfilesdir\",{\"1\":{\"2\":1}}],[\"geterror\",{\"1\":{\"382\":1}}],[\"getencoded\",{\"1\":{\"296\":1}}],[\"getfield\",{\"1\":{\"306\":1,\"424\":1}}],[\"getfirstdayofweek\",{\"1\":{\"302\":3}}],[\"getfindclasses\",{\"1\":{\"272\":1}}],[\"getfindclasstime\",{\"1\":{\"272\":1}}],[\"getflutterview\",{\"1\":{\"135\":1}}],[\"getlength\",{\"1\":{\"305\":1}}],[\"getlistener\",{\"1\":{\"191\":2}}],[\"getlayoutparams\",{\"1\":{\"64\":1}}],[\"gettextureregistry\",{\"1\":{\"211\":1}}],[\"gettextbounds\",{\"1\":{\"64\":1}}],[\"gettemporarydirectory\",{\"1\":{\"201\":1}}],[\"gettid\",{\"1\":{\"115\":1}}],[\"getting\",{\"1\":{\"115\":1,\"202\":1}}],[\"getzone\",{\"1\":{\"115\":1}}],[\"getnextframe\",{\"1\":{\"196\":1}}],[\"getnextid\",{\"1\":{\"111\":1,\"112\":1}}],[\"getnativeargument\",{\"1\":{\"108\":3}}],[\"getname\",{\"1\":{\"72\":1,\"288\":2}}],[\"getrequest\",{\"1\":{\"364\":1}}],[\"getrepos\",{\"1\":{\"322\":1}}],[\"getrealsize\",{\"1\":{\"81\":1}}],[\"getresources\",{\"1\":{\"53\":1}}],[\"gethandler\",{\"1\":{\"80\":1}}],[\"getheight\",{\"1\":{\"64\":1}}],[\"getminimaldaysinfirstweek\",{\"1\":{\"302\":3}}],[\"getminimumheight\",{\"1\":{\"65\":1}}],[\"getminimumwidth\",{\"1\":{\"65\":1}}],[\"getmethod\",{\"1\":{\"300\":1,\"427\":1}}],[\"getmetrics\",{\"1\":{\"225\":2}}],[\"getmap\",{\"1\":{\"288\":3}}],[\"getmaxstacksize\",{\"1\":{\"115\":1}}],[\"getmainhandler\",{\"1\":{\"80\":3}}],[\"getmainlooper\",{\"1\":{\"80\":3}}],[\"getmode\",{\"1\":{\"65\":2}}],[\"getdrawable\",{\"1\":{\"424\":1,\"427\":1}}],[\"getdrawingcache\",{\"1\":{\"77\":1}}],[\"getdecorview\",{\"1\":{\"77\":1}}],[\"getdeclaredxxx\",{\"1\":{\"295\":1}}],[\"getdeclaredmethod\",{\"1\":{\"72\":1,\"272\":2,\"295\":1}}],[\"getdeclaredfields\",{\"1\":{\"300\":1}}],[\"getdeclaredfield\",{\"1\":{\"72\":5,\"295\":1,\"427\":1}}],[\"getdefaultsize\",{\"1\":{\"65\":3}}],[\"getdir\",{\"1\":{\"426\":2}}],[\"getdirection\",{\"1\":{\"227\":1,\"235\":1}}],[\"getdimension\",{\"1\":{\"56\":2}}],[\"getdimensionpixelsize\",{\"1\":{\"53\":1}}],[\"getdisplaymetrics\",{\"1\":{\"53\":1}}],[\"getwidth\",{\"1\":{\"64\":1}}],[\"getwindow\",{\"1\":{\"13\":3,\"77\":1}}],[\"getcurrentmonotonicmicros\",{\"1\":{\"391\":1}}],[\"getcurrentisolate\",{\"1\":{\"377\":3}}],[\"getcurrentthreadjoinid\",{\"1\":{\"115\":1}}],[\"getcall\",{\"1\":{\"365\":1}}],[\"getcallinguid\",{\"1\":{\"43\":1}}],[\"getclassloadinglock\",{\"1\":{\"272\":1}}],[\"getclass\",{\"1\":{\"72\":1,\"300\":1,\"305\":4}}],[\"getcode\",{\"1\":{\"371\":1}}],[\"getcounter\",{\"1\":{\"334\":2}}],[\"getcomponent\",{\"1\":{\"72\":1}}],[\"getcontextclassloader\",{\"1\":{\"72\":1}}],[\"getcontentresolver\",{\"1\":{\"2\":2}}],[\"getcolor\",{\"1\":{\"64\":1}}],[\"getcolumnindex\",{\"1\":{\"2\":1}}],[\"getisolatestream\",{\"1\":{\"383\":1}}],[\"getisolatescheduleimmediateclosure方法创建了schedule\",{\"1\":{\"100\":1}}],[\"getisolatescheduleimmediateclosure\",{\"1\":{\"100\":2}}],[\"geti\",{\"1\":{\"281\":6}}],[\"getitemoffsets\",{\"1\":{\"64\":2}}],[\"getid\",{\"1\":{\"56\":1,\"365\":2}}],[\"getidentifier\",{\"1\":{\"53\":1}}],[\"getimessenger\",{\"1\":{\"43\":2}}],[\"getinstalledpackages\",{\"1\":{\"422\":1}}],[\"getinstance\",{\"1\":{\"10\":1,\"211\":15,\"294\":5,\"296\":3,\"302\":2,\"365\":1}}],[\"getinnerconstraints\",{\"1\":{\"238\":2}}],[\"getintegervalue\",{\"1\":{\"108\":1}}],[\"getinterfacedescriptor\",{\"1\":{\"40\":1,\"58\":1}}],[\"getint\",{\"1\":{\"69\":3,\"424\":1,\"427\":1}}],[\"get\",{\"0\":{\"46\":1,\"51\":1},\"1\":{\"24\":1,\"26\":1,\"37\":1,\"41\":1,\"46\":3,\"51\":2,\"54\":2,\"58\":1,\"64\":2,\"72\":4,\"81\":2,\"100\":1,\"103\":3,\"108\":2,\"109\":1,\"136\":1,\"147\":2,\"155\":1,\"158\":2,\"159\":1,\"177\":1,\"183\":1,\"186\":1,\"192\":1,\"198\":1,\"202\":3,\"211\":7,\"213\":2,\"238\":3,\"239\":1,\"243\":1,\"279\":1,\"287\":1,\"288\":7,\"306\":1,\"322\":2,\"325\":1,\"362\":1,\"370\":3,\"371\":2,\"376\":2,\"377\":2,\"391\":1,\"402\":1,\"422\":1,\"425\":1}}],[\"getbuildnongenericmethodextractorstub\",{\"1\":{\"383\":1}}],[\"getbuildgenericmethodextractorstub\",{\"1\":{\"383\":1}}],[\"getbuilder\",{\"1\":{\"364\":1}}],[\"getbooklist\",{\"1\":{\"322\":1}}],[\"getbytes\",{\"1\":{\"296\":2}}],[\"getbinarymessenger\",{\"1\":{\"211\":2}}],[\"getbinder\",{\"1\":{\"20\":1}}],[\"getbackground\",{\"1\":{\"66\":1}}],[\"getbroadcastitem\",{\"1\":{\"36\":1}}],[\"getbroadcast\",{\"1\":{\"7\":1,\"75\":1}}],[\"getavailablenode\",{\"1\":{\"437\":1,\"438\":1}}],[\"getavailablepointtags\",{\"1\":{\"58\":1}}],[\"getannotation\",{\"1\":{\"300\":1}}],[\"getage\",{\"1\":{\"295\":2}}],[\"getallstringtags\",{\"1\":{\"58\":5}}],[\"getapplicationlabel\",{\"1\":{\"422\":1}}],[\"getapplicationcontext\",{\"1\":{\"211\":1}}],[\"getapplicationinfo\",{\"1\":{\"54\":1}}],[\"getapplication\",{\"1\":{\"14\":1}}],[\"getactivenetworkinfo\",{\"1\":{\"78\":2}}],[\"getactivities\",{\"1\":{\"75\":1}}],[\"getactivity\",{\"1\":{\"2\":1,\"75\":1,\"79\":1}}],[\"getaction\",{\"1\":{\"13\":3}}],[\"gety\",{\"1\":{\"13\":1}}],[\"getxxx\",{\"1\":{\"295\":1}}],[\"getx\",{\"1\":{\"13\":1}}],[\"getkeycode\",{\"1\":{\"13\":1}}],[\"getshellsorth\",{\"1\":{\"462\":1}}],[\"getsharedtext\",{\"1\":{\"135\":4}}],[\"getsharedpreferences\",{\"1\":{\"69\":1}}],[\"getsuccessornode\",{\"1\":{\"438\":2}}],[\"getsuggestedminimumxxx\",{\"1\":{\"65\":1}}],[\"getsuggestedminimumheight\",{\"1\":{\"65\":2}}],[\"getsuggestedminimumwidth\",{\"1\":{\"65\":2}}],[\"getscrollphysics\",{\"1\":{\"213\":1}}],[\"getscreenrealheight\",{\"1\":{\"81\":1}}],[\"getscreenrealheightpx\",{\"1\":{\"81\":3}}],[\"getsocketidnativefield\",{\"1\":{\"108\":1}}],[\"gets\",{\"1\":{\"106\":1,\"383\":1}}],[\"getsize\",{\"1\":{\"65\":2,\"81\":1}}],[\"getsegment\",{\"1\":{\"63\":1}}],[\"getserviceport\",{\"1\":{\"114\":2}}],[\"getservicewithargs\",{\"1\":{\"85\":1,\"86\":1,\"87\":1}}],[\"getserviceinfo\",{\"1\":{\"54\":1}}],[\"getservice\",{\"1\":{\"19\":2,\"58\":4,\"75\":1,\"85\":2,\"87\":1}}],[\"getsystemclassloader\",{\"1\":{\"424\":1,\"426\":1}}],[\"getsystemresource\",{\"1\":{\"321\":1}}],[\"getsystem\",{\"1\":{\"53\":2,\"81\":9}}],[\"getsystemservice\",{\"1\":{\"10\":1,\"11\":1,\"12\":1,\"78\":1,\"81\":1}}],[\"getstatusbarheight\",{\"1\":{\"53\":2}}],[\"getsth\",{\"1\":{\"40\":7}}],[\"getstring\",{\"1\":{\"2\":1,\"11\":1,\"54\":1}}],[\"getproperty\",{\"1\":{\"272\":1}}],[\"getportandcapabilitiesofcurrentisolate\",{\"1\":{\"377\":6}}],[\"getport\",{\"1\":{\"111\":1,\"112\":2,\"115\":1}}],[\"getpostmessage\",{\"1\":{\"30\":2}}],[\"getparentdelegationtime\",{\"1\":{\"272\":1}}],[\"getparcelableextra\",{\"1\":{\"72\":1}}],[\"getpackagearchiveinfo\",{\"1\":{\"425\":1}}],[\"getpackagename\",{\"1\":{\"79\":1}}],[\"getpackagemanager\",{\"1\":{\"2\":1}}],[\"getpaddingbottom\",{\"1\":{\"64\":1}}],[\"getpaddingtop\",{\"1\":{\"64\":1}}],[\"getpeoplelist\",{\"1\":{\"35\":3,\"36\":1,\"37\":1}}],[\"getpendingintent\",{\"1\":{\"7\":1,\"8\":1,\"10\":1,\"11\":1}}],[\"g\",{\"1\":{\"15\":1,\"110\":1,\"147\":1,\"220\":1,\"302\":1,\"346\":1,\"376\":1,\"383\":1,\"392\":1,\"413\":2}}],[\"gizp\",{\"1\":{\"356\":1}}],[\"gid\",{\"1\":{\"353\":2}}],[\"giving\",{\"1\":{\"102\":1}}],[\"given\",{\"1\":{\"80\":1,\"98\":1,\"108\":1,\"115\":1,\"147\":2,\"165\":1,\"183\":1,\"309\":1,\"312\":1,\"378\":1,\"392\":1}}],[\"give\",{\"1\":{\"13\":1,\"102\":1,\"209\":1,\"297\":1}}],[\"gist\",{\"1\":{\"95\":1}}],[\"gifdrawable\",{\"1\":{\"211\":2}}],[\"gif\",{\"1\":{\"64\":1,\"188\":2}}],[\"git\",{\"0\":{\"409\":1},\"1\":{\"347\":26,\"367\":2,\"407\":7,\"408\":1,\"409\":3,\"411\":2,\"412\":2,\"418\":3,\"419\":1}}],[\"gityuanurls\",{\"1\":{\"370\":3}}],[\"gityuan博客\",{\"1\":{\"60\":1,\"279\":1}}],[\"gityuan\",{\"1\":{\"58\":1,\"301\":1,\"370\":10,\"371\":2}}],[\"github项目\",{\"1\":{\"406\":1}}],[\"github为我们提供了github\",{\"1\":{\"405\":1}}],[\"github链接\",{\"1\":{\"370\":1}}],[\"githubbrowsersample\",{\"1\":{\"94\":1}}],[\"github源代码路径\",{\"1\":{\"72\":1}}],[\"github源码路径\",{\"1\":{\"66\":1}}],[\"github\",{\"1\":{\"0\":1,\"41\":1,\"55\":1,\"56\":1,\"61\":2,\"69\":1,\"87\":1,\"95\":1,\"111\":2,\"115\":1,\"172\":1,\"180\":1,\"211\":2,\"243\":1,\"308\":1,\"321\":1,\"347\":14,\"366\":1,\"367\":3,\"372\":1,\"405\":1,\"406\":1,\"407\":9,\"408\":6,\"409\":3,\"417\":7,\"418\":4,\"419\":10}}],[\"grids\",{\"1\":{\"227\":1}}],[\"gridview等继承自scrollview的widget\",{\"1\":{\"234\":1}}],[\"gridview\",{\"1\":{\"212\":1,\"227\":1,\"233\":1,\"240\":1,\"242\":1}}],[\"grep\",{\"1\":{\"358\":2,\"361\":1}}],[\"gregoriancalenda\",{\"1\":{\"302\":1}}],[\"gregoriancalendar\",{\"1\":{\"302\":1}}],[\"grey\",{\"1\":{\"131\":1}}],[\"green\",{\"1\":{\"63\":1,\"143\":1,\"241\":1}}],[\"grow\",{\"1\":{\"242\":1}}],[\"growableobjectarray\",{\"1\":{\"383\":2}}],[\"growable\",{\"1\":{\"210\":1}}],[\"growingarrayutils\",{\"1\":{\"45\":2,\"52\":1}}],[\"growing\",{\"1\":{\"45\":1}}],[\"group下的isolate共享\",{\"1\":{\"388\":1}}],[\"group持有的heap\",{\"1\":{\"388\":1}}],[\"group中的isolate可以共享常量\",{\"1\":{\"383\":1}}],[\"group创建isolate\",{\"1\":{\"388\":1}}],[\"group创建配置一个新的isolate\",{\"1\":{\"383\":1}}],[\"group创建了新的isolate\",{\"1\":{\"383\":1}}],[\"group=\",{\"1\":{\"381\":1,\"384\":1,\"388\":1}}],[\"groupmod\",{\"1\":{\"353\":1}}],[\"groupadd\",{\"1\":{\"353\":1}}],[\"group群组管理也类似\",{\"1\":{\"353\":1}}],[\"group<t\",{\"1\":{\"322\":1}}],[\"group<\",{\"1\":{\"322\":2}}],[\"group<out\",{\"1\":{\"322\":2}}],[\"group<in\",{\"1\":{\"322\":2}}],[\"groupby\",{\"1\":{\"321\":1}}],[\"group\",{\"1\":{\"13\":2,\"56\":2,\"297\":3,\"322\":6,\"376\":1,\"380\":3,\"381\":8,\"382\":10,\"383\":22,\"386\":7,\"387\":13,\"388\":8,\"389\":2}}],[\"groups\",{\"1\":{\"1\":1,\"353\":1}}],[\"graphicnode<t>\",{\"1\":{\"438\":1}}],[\"graphics\",{\"1\":{\"81\":1}}],[\"graphs\",{\"1\":{\"400\":2}}],[\"graph序列化成为snapshot\",{\"1\":{\"396\":1}}],[\"graph\",{\"1\":{\"395\":1}}],[\"gracefully\",{\"1\":{\"102\":1}}],[\"gravity=\",{\"1\":{\"66\":1}}],[\"gravity\",{\"1\":{\"58\":1}}],[\"gradle读取properties文件信息\",{\"1\":{\"54\":1}}],[\"gradle的android\",{\"1\":{\"32\":1}}],[\"gradle\",{\"1\":{\"14\":2,\"54\":4}}],[\"grantresults\",{\"1\":{\"69\":2}}],[\"granted\",{\"1\":{\"69\":2}}],[\"granturipermission\",{\"1\":{\"2\":1}}],[\"granturipermissions=\",{\"1\":{\"2\":1}}],[\"grant\",{\"1\":{\"2\":4}}],[\"在划分好的两个数组中\",{\"1\":{\"467\":1}}],[\"在数组首\",{\"1\":{\"466\":1,\"467\":1}}],[\"在数据左右两端各有一个指针指向当前元素\",{\"1\":{\"464\":1}}],[\"在数据存储结构中最快\",{\"1\":{\"445\":1}}],[\"在数据从发送方向接收方拷贝时\",{\"1\":{\"58\":1}}],[\"在所有排序中可以优先使用\",{\"1\":{\"460\":1}}],[\"在所指定的空间内居中\",{\"1\":{\"15\":1}}],[\"在满足一定条件后可以退出递归\",{\"1\":{\"459\":1}}],[\"在节点中保存一个标志位\",{\"1\":{\"458\":1}}],[\"在有序数组要找到某个元素t可以使用二分查找\",{\"1\":{\"451\":1}}],[\"在有的屏幕上会无法占满全屏或超出屏幕范围\",{\"1\":{\"53\":1}}],[\"在最后再将要临时保存的值复制到目的下标\",{\"1\":{\"439\":1}}],[\"在最终会被调用的构造方法里面将xml里面定义的布局加载进来\",{\"1\":{\"56\":1}}],[\"在插入\",{\"1\":{\"439\":1}}],[\"在装填因子小于0\",{\"1\":{\"428\":1}}],[\"在小型哈希表中\",{\"1\":{\"428\":1}}],[\"在填充质数很大时就会很耗时\",{\"1\":{\"428\":1}}],[\"在确定容量\",{\"1\":{\"428\":1}}],[\"在当前应用中加载已安装的其他应用资源\",{\"1\":{\"421\":1}}],[\"在当天下午8点整开始\",{\"1\":{\"4\":1}}],[\"在blog\",{\"1\":{\"419\":1}}],[\"在安装完\",{\"1\":{\"411\":1}}],[\"在安装的时候需要从网上下载资料\",{\"1\":{\"409\":1}}],[\"在页面activity\",{\"1\":{\"402\":1}}],[\"在中指定这些databinding与之间以及viewmodel与数据库之间的逻辑关系\",{\"1\":{\"399\":1}}],[\"在内联检查的时候\",{\"1\":{\"396\":1}}],[\"在内部类中仍然是通过外部类的引用this\",{\"1\":{\"281\":1}}],[\"在内部类和内部类外部分别有不同值的问题\",{\"1\":{\"281\":1}}],[\"在内部通过监听imagestream获得imageinfo并最终在\",{\"1\":{\"189\":1}}],[\"在内部通过notifyclients\",{\"1\":{\"128\":1}}],[\"在优化完成后\",{\"1\":{\"396\":1}}],[\"在发生调用时通过lookup\",{\"1\":{\"395\":1}}],[\"在发送消息是需要将接收服务端回复的messenger通过message的replyto传递给服务端\",{\"1\":{\"20\":1}}],[\"在自己单独的线程运行\",{\"1\":{\"391\":1}}],[\"在获取到worker之后\",{\"1\":{\"389\":1}}],[\"在linux命令行输入如下命令\",{\"1\":{\"368\":1}}],[\"在length为2n\",{\"1\":{\"280\":1}}],[\"在具体的实现中\",{\"1\":{\"365\":1}}],[\"在具体分析整个过程之前\",{\"1\":{\"106\":1}}],[\"在本文中\",{\"1\":{\"365\":1}}],[\"在本例中是center这个widget对应的singlechildrenderobjectelement\",{\"1\":{\"127\":1}}],[\"在本例中\",{\"1\":{\"124\":1,\"127\":1,\"399\":1}}],[\"在子类中使用okhttp3\",{\"1\":{\"364\":1}}],[\"在开机\",{\"1\":{\"360\":1}}],[\"在压缩\",{\"1\":{\"357\":1}}],[\"在压缩文件夹时\",{\"1\":{\"357\":1}}],[\"在遍历的时候\",{\"1\":{\"346\":1}}],[\"在新系统线程开启worker循环\",{\"1\":{\"389\":1}}],[\"在新流发出的时候\",{\"1\":{\"340\":1}}],[\"在新的协程中生产并返回了一个receivechannel<t>对象\",{\"1\":{\"328\":1}}],[\"在新的图层按照xfermode规则绘制\",{\"1\":{\"57\":1}}],[\"在新的图层绘制\",{\"1\":{\"57\":1}}],[\"在初始化的时初始化listener\",{\"1\":{\"345\":1}}],[\"在初始值initial的基础上求和\",{\"1\":{\"337\":1}}],[\"在初次创建服务时调用\",{\"1\":{\"17\":1}}],[\"在被调用时会尽快返回且不等待\",{\"1\":{\"336\":1}}],[\"在被选中的字后面画一个圆\",{\"1\":{\"64\":1}}],[\"在高负载下比锁更有效\",{\"1\":{\"334\":1}}],[\"在协程的整个层次结构之间传播\",{\"1\":{\"330\":1}}],[\"在流构建器中改变消耗\",{\"1\":{\"327\":1,\"339\":1}}],[\"在流触及相应限制的时候会将它的执行取消\",{\"1\":{\"327\":1}}],[\"在流转换操作符中\",{\"1\":{\"327\":1}}],[\"在无竞争的情况下消除同步\",{\"1\":{\"320\":1}}],[\"在升级为互斥锁\",{\"1\":{\"320\":1}}],[\"在hotspot虚拟机上实现了许多锁优化技术\",{\"1\":{\"320\":1}}],[\"在hero动画执行时\",{\"1\":{\"176\":1}}],[\"在hero动画开始时占位\",{\"1\":{\"175\":1}}],[\"在冲突发生的时候不断尝试执行所需操作\",{\"1\":{\"319\":1}}],[\"在操作时进行cas\",{\"1\":{\"319\":1}}],[\"在构造函数中生成内部类\",{\"1\":{\"317\":1}}],[\"在构造方法等地方设置监听事件\",{\"1\":{\"56\":1}}],[\"在保存同一个对象时要注意使用不同的objectoutputstream对象\",{\"1\":{\"309\":1}}],[\"在线操作红黑树\",{\"1\":{\"458\":1}}],[\"在线显示本周是一年第几周的网站\",{\"1\":{\"302\":1}}],[\"在线程复杂的情况下很容易出现问题\",{\"1\":{\"294\":1}}],[\"在线程中执行task\",{\"1\":{\"115\":1}}],[\"在国内可以简单理解为一年1月1日所在的周就是当年的第一周\",{\"1\":{\"302\":1}}],[\"在2019\",{\"1\":{\"302\":1}}],[\"在类的定义\",{\"1\":{\"321\":1}}],[\"在类中通过\",{\"1\":{\"301\":1}}],[\"在类中创建一个实现了ibinder接口的实力对象并提供公共方法给客户端使用\",{\"1\":{\"19\":1}}],[\"在类路径\",{\"1\":{\"298\":1}}],[\"在查找该注解时\",{\"1\":{\"298\":1}}],[\"在查看\",{\"1\":{\"188\":1}}],[\"在考虑多线程时\",{\"1\":{\"294\":1}}],[\"在编码中常常会用到单例\",{\"1\":{\"294\":1}}],[\"在编译的时候由于objarr1和objarr2都是object类型的数组\",{\"1\":{\"291\":1}}],[\"在编译期最多可以有65534个字符\",{\"1\":{\"283\":1}}],[\"在编译期完成内存分配\",{\"1\":{\"252\":1}}],[\"在编译之后\",{\"1\":{\"281\":1}}],[\"在接下来一轮的排序中\",{\"1\":{\"289\":1}}],[\"在不同的线程中进行set\",{\"1\":{\"288\":1}}],[\"在testreflect\",{\"1\":{\"295\":1}}],[\"在threadpool\",{\"1\":{\"391\":2}}],[\"在threadlocal\",{\"1\":{\"288\":1}}],[\"在thread有一个threadlocals\",{\"1\":{\"288\":1}}],[\"在table中保存数据时根据key的hashcode计算到一个随机保存位置\",{\"1\":{\"280\":1}}],[\"在容纳数百个项目时性能会比hashmap小大约50\",{\"1\":{\"287\":1}}],[\"在添加和删除item的时候都需要在数组中增删条目\",{\"1\":{\"287\":1}}],[\"在运行时有效\",{\"1\":{\"298\":1}}],[\"在运行时根据具体对象的类型进行绑定\",{\"1\":{\"273\":1}}],[\"在运行的时候\",{\"1\":{\"291\":1}}],[\"在运行期\",{\"1\":{\"283\":1}}],[\"在虚拟机中的状态\",{\"1\":{\"282\":1}}],[\"在第一节我们可以看到\",{\"1\":{\"280\":1}}],[\"在第一次申请该权限时会返回false\",{\"1\":{\"68\":1}}],[\"在移除数据时\",{\"1\":{\"280\":1}}],[\"在同一个类加载器中\",{\"1\":{\"279\":1}}],[\"在堆中生成一个代表该类的java\",{\"1\":{\"274\":1}}],[\"在程序执行前方法已经被绑定\",{\"1\":{\"273\":1}}],[\"在实际中有可能从其中间某一步开始\",{\"1\":{\"273\":1}}],[\"在实际开发中\",{\"1\":{\"87\":1}}],[\"在加载类时\",{\"1\":{\"272\":1}}],[\"在jdk\",{\"1\":{\"283\":1}}],[\"在jdk1\",{\"1\":{\"254\":2,\"280\":1}}],[\"在java中是public\",{\"1\":{\"314\":1}}],[\"在java中\",{\"1\":{\"273\":1,\"283\":1,\"302\":1}}],[\"在java中可以直接写成\",{\"1\":{\"86\":1}}],[\"在java中使用该控件\",{\"1\":{\"56\":1}}],[\"在java中调用service\",{\"1\":{\"17\":1}}],[\"在一些场景下\",{\"1\":{\"242\":1}}],[\"在craw\",{\"1\":{\"371\":1}}],[\"在collect执行结束后才执行\",{\"1\":{\"343\":1}}],[\"在content滑出这部分区域时dispose\",{\"1\":{\"240\":1}}],[\"在class被装载时被获取\",{\"1\":{\"298\":1}}],[\"在class文件中有效\",{\"1\":{\"298\":1}}],[\"在center对应的element\",{\"1\":{\"126\":1}}],[\"在父级约束范围内尽可能满足child的尺寸\",{\"1\":{\"238\":1}}],[\"在修改了以上文件后\",{\"1\":{\"361\":1}}],[\"在修改clipbehavior属性的时候只会触发markneedspaint\",{\"1\":{\"237\":1}}],[\"在修改axisdirection\",{\"1\":{\"237\":1}}],[\"在vm中执行\",{\"0\":{\"394\":1}}],[\"在viewport中\",{\"1\":{\"227\":1}}],[\"在values\",{\"1\":{\"56\":1}}],[\"在用户创建新的文件时\",{\"1\":{\"353\":1}}],[\"在用户滑动屏幕时\",{\"1\":{\"226\":1}}],[\"在用户看起来好像是当前页面的\",{\"1\":{\"169\":1}}],[\"在默认的\",{\"1\":{\"223\":1}}],[\"在范围内\",{\"1\":{\"220\":1}}],[\"在分析singlechildscrollview如何根据offset的变化实现scroll效果之前\",{\"1\":{\"238\":1}}],[\"在分析\",{\"1\":{\"212\":1}}],[\"在分辨率为2160\",{\"1\":{\"53\":1}}],[\"在模拟器上显示图片\",{\"1\":{\"211\":1}}],[\"在他们的onloadresult\",{\"1\":{\"211\":1}}],[\"在他们对应的\",{\"1\":{\"178\":1}}],[\"在powerimagebaserequest\",{\"1\":{\"211\":1}}],[\"在performrebuild\",{\"1\":{\"128\":1}}],[\"在从网络加载图片这部分内容来看\",{\"1\":{\"200\":1}}],[\"在从\",{\"1\":{\"195\":1}}],[\"在从定往下数第三层也就是text对应的这一级中\",{\"1\":{\"126\":1}}],[\"在okhttprequest中\",{\"1\":{\"364\":1}}],[\"在okhttputils中使用的是okhttprequestbuilder\",{\"1\":{\"364\":1}}],[\"在overlay上添加过渡组件\",{\"1\":{\"181\":1}}],[\"在oncreate\",{\"1\":{\"92\":1}}],[\"在onmeasure\",{\"1\":{\"65\":2}}],[\"在ontouch事件中\",{\"1\":{\"41\":1}}],[\"在onbind\",{\"1\":{\"19\":1}}],[\"在onstartcommand\",{\"1\":{\"17\":1}}],[\"在屏幕上面\",{\"1\":{\"176\":1}}],[\"在屏幕宽度上的比例一致性\",{\"1\":{\"53\":1}}],[\"在二者的过渡阶段\",{\"1\":{\"173\":1}}],[\"在isolate创建时会被回调\",{\"1\":{\"386\":1}}],[\"在isolate\",{\"1\":{\"383\":1}}],[\"在innerposition和outerposition组合的space之上设置overscroll\",{\"1\":{\"225\":1}}],[\"在image中\",{\"1\":{\"195\":1}}],[\"在implicitlyanimatedwidgetstate\",{\"1\":{\"148\":1}}],[\"在ioservicecallback方法中\",{\"1\":{\"115\":1}}],[\"在要写动画的时候\",{\"1\":{\"146\":1,\"157\":1}}],[\"在导致widget\",{\"1\":{\"141\":1}}],[\"在widget外面添加一个gesturedetectorwidget\",{\"1\":{\"140\":1}}],[\"在widgetsbinding\",{\"1\":{\"119\":1,\"121\":1}}],[\"在进行网络请求\",{\"1\":{\"136\":1}}],[\"在前面的text源码中\",{\"1\":{\"127\":1}}],[\"在updatechild中\",{\"1\":{\"122\":1}}],[\"在ui线程\",{\"1\":{\"80\":1}}],[\"在runapp方法中\",{\"1\":{\"127\":1}}],[\"在rootwidget中第一个renderobjectelement\",{\"1\":{\"121\":1}}],[\"在res\",{\"1\":{\"400\":1}}],[\"在readobject中只能获取到该类型的默认值\",{\"1\":{\"306\":1}}],[\"在release模式下则会调用fluttererror\",{\"1\":{\"144\":1}}],[\"在release模式则会显示为灰底区域\",{\"1\":{\"141\":1}}],[\"在renderobjecttowidgetelement的mount方法执行时\",{\"1\":{\"121\":1}}],[\"在renderobjecttowidgetelementmount的时候会用到\",{\"1\":{\"120\":1}}],[\"在remotecallbacklist中有一个以binder对象为key的map来存放这些listener对象\",{\"1\":{\"36\":1}}],[\"在执行删除操作时真正删除该点\",{\"1\":{\"458\":1}}],[\"在执行hashmap\",{\"1\":{\"280\":1}}],[\"在执行完耗时操作后\",{\"1\":{\"136\":1}}],[\"在执行完毕或者遇到错误时\",{\"1\":{\"109\":1}}],[\"在执行runapp的时候主要执行了三步\",{\"1\":{\"117\":1}}],[\"在之前学习android的过程中\",{\"1\":{\"398\":1}}],[\"在之前的文章中\",{\"1\":{\"146\":1}}],[\"在之前的代码分析中\",{\"1\":{\"112\":1}}],[\"在之前调用本方法的环境\",{\"1\":{\"115\":1}}],[\"在native这里真正负责执行的方法\",{\"1\":{\"115\":1}}],[\"在native实现\",{\"1\":{\"112\":1}}],[\"在native和kernel之间的系统调用层\",{\"1\":{\"60\":1}}],[\"在于dart层的\",{\"1\":{\"112\":1}}],[\"在方法区对类变量分配内存\",{\"1\":{\"277\":1}}],[\"在方法执行的时候\",{\"1\":{\"109\":1}}],[\"在方法数大于65536时\",{\"1\":{\"14\":1}}],[\"在创建isolate的时候可以添加addonexitlistener\",{\"1\":{\"372\":1}}],[\"在创建了新的系统线程后\",{\"1\":{\"115\":1}}],[\"在创建根据需要创建好timer之后\",{\"1\":{\"105\":1}}],[\"在创建timer的时候\",{\"1\":{\"105\":1}}],[\"在创建时分配一个page大小的内存\",{\"1\":{\"58\":1}}],[\"在后文处理结果的时候\",{\"1\":{\"103\":1}}],[\"在后台更新进度\",{\"1\":{\"80\":1}}],[\"在后台可靠的通过multidex\",{\"1\":{\"14\":1}}],[\"在element\",{\"1\":{\"122\":1}}],[\"在ensureinitialized方法中创建了\",{\"1\":{\"127\":1}}],[\"在ensureinitialized方法中\",{\"1\":{\"118\":1}}],[\"在event每次处理timer事件之后\",{\"1\":{\"101\":1}}],[\"在execute\",{\"1\":{\"80\":1}}],[\"在下次更新该key对于的值时直接覆盖\",{\"1\":{\"287\":1}}],[\"在下次gc回收之前都存在\",{\"1\":{\"270\":1}}],[\"在下次调用其private\",{\"1\":{\"44\":1}}],[\"在下一帧更新控件\",{\"1\":{\"134\":1}}],[\"在下面的分析中\",{\"1\":{\"101\":1}}],[\"在代码执行的过程中\",{\"1\":{\"95\":1}}],[\"在findclass\",{\"1\":{\"272\":1}}],[\"在flutter\",{\"1\":{\"144\":1}}],[\"在flutter中\",{\"1\":{\"131\":1}}],[\"在fragment中我们也可以这样处理\",{\"1\":{\"94\":1}}],[\"在for循环中通过mqueue\",{\"1\":{\"31\":1}}],[\"在sunflower中有类似的应用有很多处\",{\"1\":{\"401\":1}}],[\"在sunflower中navigation是怎么控制界面切换的呢\",{\"1\":{\"400\":1}}],[\"在super\",{\"1\":{\"93\":1}}],[\"在spawnisolatetask\",{\"1\":{\"385\":1}}],[\"在shrinkwrap属性为false的情况下\",{\"1\":{\"240\":1}}],[\"在singlechildscrollview外层添加expanded作为父级\",{\"1\":{\"238\":1}}],[\"在singlechildrenderobjectelement的insertrenderobjectchild方法中先是查找当前element持有的renderobject\",{\"1\":{\"127\":1}}],[\"在singlechildrenderobjectwidget\",{\"1\":{\"124\":1}}],[\"在schedulewarmupframe方法中安排在下一次屏幕刷新的时候将我们的内容展示在屏幕上面\",{\"1\":{\"127\":1}}],[\"在scheduleattachrootwidget方法中\",{\"1\":{\"127\":1}}],[\"在sdk\",{\"1\":{\"111\":1}}],[\"在service中\",{\"1\":{\"58\":1}}],[\"在需要网络请求的时候\",{\"1\":{\"362\":1}}],[\"在需要用到方法时\",{\"1\":{\"345\":1}}],[\"在需要使用该对象的地方通过\",{\"1\":{\"84\":1}}],[\"在需要根据渠道不同而变化的地方使用$\",{\"1\":{\"54\":1}}],[\"在看\",{\"1\":{\"226\":1}}],[\"在看timer实现之前\",{\"1\":{\"103\":1}}],[\"在看一下exec\",{\"1\":{\"80\":1}}],[\"在看ontouchevent\",{\"1\":{\"13\":1}}],[\"在桌面上显示的样式\",{\"1\":{\"79\":1}}],[\"在对应地方通过反射获取到对应变量\",{\"1\":{\"72\":1}}],[\"在对比了几种屏幕适配方案之后\",{\"1\":{\"53\":1}}],[\"在调用startactivity时将targetintent通过proxy伪装为proxyintent\",{\"1\":{\"70\":1}}],[\"在调用第三方app裁剪的场景中\",{\"1\":{\"2\":1}}],[\"在dart虚拟机启动\",{\"1\":{\"383\":1}}],[\"在dart中\",{\"1\":{\"378\":1}}],[\"在dart中创建isolate有3种方式\",{\"1\":{\"378\":1}}],[\"在dart中通过file进行文件操作\",{\"1\":{\"116\":1}}],[\"在dart中向native发送指令时\",{\"1\":{\"115\":1}}],[\"在dart线程池中执行\",{\"1\":{\"115\":1}}],[\"在dart层的\",{\"1\":{\"114\":1}}],[\"在dart\",{\"1\":{\"100\":1,\"115\":1,\"386\":1,\"389\":1}}],[\"在dagger\",{\"1\":{\"83\":1}}],[\"在doinbackground\",{\"1\":{\"80\":1}}],[\"在drawable下新建dialog\",{\"1\":{\"66\":1}}],[\"在dpi为320的屏幕上占2px\",{\"1\":{\"53\":1}}],[\"在dpi为160的屏幕上1dp占1px\",{\"1\":{\"53\":1}}],[\"在里面专门指定wrap\",{\"1\":{\"65\":1}}],[\"在里面替换对应的资源文件\",{\"1\":{\"54\":1}}],[\"在拼接贝塞尔曲线的path时候注意\",{\"1\":{\"63\":1}}],[\"在绘制path的时候绘制渐变背景\",{\"1\":{\"63\":1}}],[\"在绘制p\",{\"1\":{\"63\":1}}],[\"在绘制三阶贝塞尔曲线时\",{\"1\":{\"61\":1}}],[\"在绘制折线图时\",{\"1\":{\"61\":1}}],[\"在通信时\",{\"1\":{\"58\":1}}],[\"在这种情况下\",{\"1\":{\"294\":1}}],[\"在这一步只会进行到i\",{\"1\":{\"277\":1}}],[\"在这个过程中他使用的数据则是来自于viewmodel的\",{\"1\":{\"402\":1}}],[\"在这个阶段不会进行优化\",{\"1\":{\"395\":1}}],[\"在这个阶段\",{\"1\":{\"394\":1,\"395\":2}}],[\"在这个例子中\",{\"1\":{\"212\":1,\"234\":1}}],[\"在这个文件中都是我们自己定义的方法\",{\"1\":{\"58\":1}}],[\"在这过程中涉及到复制和交换\",{\"1\":{\"439\":1}}],[\"在这过程中\",{\"1\":{\"211\":1,\"317\":1}}],[\"在这两个构造方法内部\",{\"1\":{\"161\":1}}],[\"在这其中\",{\"1\":{\"196\":1}}],[\"在这其中build\",{\"1\":{\"128\":1}}],[\"在这其中我们用到了两个涉及到aidl文件\",{\"1\":{\"58\":1}}],[\"在这里再拉取master分支的文件\",{\"1\":{\"407\":1}}],[\"在这里主要是开始处理event\",{\"1\":{\"389\":1}}],[\"在这里正式启动了isolate\",{\"1\":{\"389\":1}}],[\"在这里绑定了message\",{\"1\":{\"383\":1}}],[\"在这里执行了真正的网络请求\",{\"1\":{\"365\":1}}],[\"在这里配置网络超时等全局配置\",{\"1\":{\"362\":1}}],[\"在这里仍然可以知道t是什么类型的\",{\"1\":{\"322\":1}}],[\"在这里修改了部分属性\",{\"1\":{\"309\":1}}],[\"在这里会检测是否存在readresolve\",{\"1\":{\"305\":1}}],[\"在这里可以看出\",{\"1\":{\"281\":1}}],[\"在这里可以对错误进行处理\",{\"1\":{\"144\":1}}],[\"在这里创建viewport\",{\"1\":{\"227\":1}}],[\"在这里创建了一个新的与给定的handler绑定在一起的messenger\",{\"1\":{\"43\":1}}],[\"在这里也消耗不了\",{\"1\":{\"226\":1}}],[\"在这里传入tabbar\",{\"1\":{\"212\":1}}],[\"在这里刷新imageinfo\",{\"1\":{\"192\":1}}],[\"在这里调用animatable\",{\"1\":{\"183\":1}}],[\"在这里调用了onintercepttouchevent\",{\"1\":{\"13\":1}}],[\"在这里构建一个页面并返回\",{\"1\":{\"133\":1}}],[\"在这里加上const\",{\"1\":{\"130\":1}}],[\"在这里被传入了renderview对应的renderobjecttowidgetelement的child中\",{\"1\":{\"121\":1}}],[\"在这里分析可知\",{\"1\":{\"121\":1}}],[\"在这里run\",{\"1\":{\"115\":1}}],[\"在这里处理ioservice执行完方法返回的数据\",{\"1\":{\"111\":1,\"112\":1}}],[\"在这里处理后台线程发过来的消息\",{\"1\":{\"80\":1}}],[\"在这里遍历处理所有的pendingtimers\",{\"1\":{\"109\":1}}],[\"在这里依次执行future\",{\"1\":{\"102\":1}}],[\"在这里面才是真正的执行线程的内容\",{\"1\":{\"80\":1}}],[\"在这里将proxyintent转化为targetintent\",{\"1\":{\"72\":1}}],[\"在这里定义服务需要提供的方法\",{\"1\":{\"58\":1}}],[\"在这里定义要使用的控件组布局\",{\"1\":{\"56\":1}}],[\"在布局文件main\",{\"1\":{\"56\":1}}],[\"在xxx\",{\"1\":{\"56\":1}}],[\"在打包时自动替换对应资源\",{\"1\":{\"54\":1}}],[\"在该段代码编译为汇编语言时\",{\"1\":{\"294\":1}}],[\"在该类中\",{\"1\":{\"364\":1}}],[\"在该类中build\",{\"1\":{\"134\":1}}],[\"在该类的\",{\"1\":{\"79\":1}}],[\"在该自定义控件的类xxx\",{\"1\":{\"56\":1}}],[\"在该渠道目录下新建对应的资源目录\",{\"1\":{\"54\":1}}],[\"在该方法中将自身this赋值给其他变量\",{\"1\":{\"266\":1}}],[\"在该方法中\",{\"1\":{\"13\":1}}],[\"在友盟统计平台上统计各个渠道的\",{\"1\":{\"54\":1}}],[\"在使用该方法时也类似\",{\"1\":{\"345\":1}}],[\"在使用flutter实现widget动画时\",{\"1\":{\"156\":1}}],[\"在使用它之后\",{\"1\":{\"82\":1}}],[\"在使用到本工具的所有地方\",{\"1\":{\"81\":1}}],[\"在使用到项目中之后\",{\"1\":{\"53\":1}}],[\"在使用之前检查是否有该权限checkselfpermission\",{\"1\":{\"68\":1}}],[\"在使用时可以通过country的对象调用syanum\",{\"1\":{\"321\":1}}],[\"在使用时先新建一个java类\",{\"1\":{\"282\":1}}],[\"在使用时只需要将client的引用传入即可\",{\"1\":{\"84\":1}}],[\"在使用时\",{\"1\":{\"49\":1,\"184\":1,\"334\":1}}],[\"在每轮比较完毕后max就是这轮比较出来的最大值位置\",{\"1\":{\"456\":1}}],[\"在每次插入的时候对元素进行排序\",{\"1\":{\"451\":1}}],[\"在每次移除数据时进行向下遍历\",{\"1\":{\"442\":1}}],[\"在每次符合条件时只复制参与对比的值\",{\"1\":{\"439\":1}}],[\"在每次put\",{\"1\":{\"287\":1}}],[\"在每次设置offset的时候\",{\"1\":{\"237\":1}}],[\"在每个设备上都是固定的\",{\"1\":{\"53\":1,\"81\":2}}],[\"在每天指定时间到了之后\",{\"1\":{\"10\":1}}],[\"在现实生活中面对千变万化的android屏幕\",{\"1\":{\"53\":1}}],[\"在messagehandler中有两种messagequeue\",{\"1\":{\"376\":1}}],[\"在mainactivity\",{\"1\":{\"211\":2}}],[\"在main\",{\"1\":{\"132\":1}}],[\"在mamsinvocationhandler\",{\"1\":{\"72\":1}}],[\"在multichildrenderobjectelement的mount方法中\",{\"1\":{\"127\":1}}],[\"在multidex\",{\"1\":{\"14\":1}}],[\"在mount的时候\",{\"1\":{\"126\":1}}],[\"在mhashes中进行二分法查找对应的index\",{\"1\":{\"49\":1}}],[\"在上面例子中\",{\"1\":{\"242\":1}}],[\"在上面分析powerimageprovider\",{\"1\":{\"211\":1}}],[\"在上面方分析\",{\"1\":{\"197\":1}}],[\"在上面的分析中\",{\"1\":{\"126\":1,\"209\":1,\"389\":1}}],[\"在上篇文章中\",{\"1\":{\"182\":1}}],[\"在上文中我们看到\",{\"1\":{\"48\":1}}],[\"在上个服务被杀死之前调用stopself\",{\"1\":{\"17\":1}}],[\"在删除数据时需要缩减数组\",{\"1\":{\"44\":1}}],[\"在日常编程中使用binder的主要有aidl和messenger两种方式\",{\"1\":{\"40\":1}}],[\"在客户端ui线程\",{\"1\":{\"38\":1}}],[\"在客户端的binder线程池中\",{\"1\":{\"38\":1}}],[\"在客户端的onserviceconnected\",{\"1\":{\"19\":1}}],[\"在客户端终止后自动调用该方法\",{\"1\":{\"36\":1}}],[\"在服务端实现接口各个方法\",{\"1\":{\"36\":1}}],[\"在服务端调用这些方法时执行对应操作\",{\"1\":{\"35\":1}}],[\"在连接上服务端后\",{\"1\":{\"35\":1}}],[\"在\",{\"0\":{\"216\":1},\"1\":{\"31\":1,\"54\":2,\"79\":3,\"101\":2,\"103\":1,\"109\":1,\"111\":1,\"121\":1,\"154\":1,\"165\":2,\"171\":3,\"178\":1,\"183\":1,\"184\":1,\"186\":1,\"191\":1,\"195\":1,\"198\":2,\"200\":2,\"202\":1,\"205\":1,\"211\":3,\"213\":2,\"216\":2,\"217\":1,\"219\":1,\"223\":1,\"225\":1,\"226\":2,\"228\":2,\"230\":2,\"291\":1,\"347\":1,\"371\":1,\"381\":1,\"419\":1}}],[\"在其子类中按照不同的需要实现生成request的方法\",{\"1\":{\"365\":1}}],[\"在其变化时执行\",{\"1\":{\"229\":1}}],[\"在其\",{\"1\":{\"226\":1}}],[\"在其内部判断类对象是否已经存在\",{\"1\":{\"294\":1}}],[\"在其内部使用listview等时需要开启shrinkwrap从而导致其懒创建item失效\",{\"1\":{\"242\":1}}],[\"在其内部也只能有一个box\",{\"1\":{\"234\":1}}],[\"在其内部会执行\",{\"1\":{\"196\":1}}],[\"在其内部调用\",{\"1\":{\"195\":1}}],[\"在其内部调用了element的performrebuild\",{\"1\":{\"128\":1}}],[\"在其内部调用enqueuemessage\",{\"1\":{\"28\":1}}],[\"在其中调用sizeof\",{\"1\":{\"282\":1}}],[\"在其中后台进行multidexopt\",{\"1\":{\"14\":1}}],[\"在其中加载一个activity\",{\"1\":{\"14\":1}}],[\"在绑定服务是才会被调用\",{\"1\":{\"17\":1}}],[\"在主页点击\",{\"1\":{\"417\":1}}],[\"在主线程调用execute\",{\"1\":{\"80\":1}}],[\"在主线程中更新工作进度\",{\"1\":{\"17\":1}}],[\"在主activity启动之前看到的一直是桌面的样子而非白屏\",{\"1\":{\"14\":1}}],[\"在此进行插入排序\",{\"1\":{\"460\":1}}],[\"在此和新的top比较\",{\"1\":{\"453\":1}}],[\"在此时会判断是否需要扩容\",{\"1\":{\"280\":1}}],[\"在此处\",{\"1\":{\"226\":1}}],[\"在此方法内部根据当前时间和\",{\"1\":{\"163\":1}}],[\"在此方法中创建\",{\"1\":{\"226\":1}}],[\"在此方法中\",{\"1\":{\"150\":1,\"183\":1,\"191\":1,\"226\":1}}],[\"在此之后\",{\"1\":{\"128\":1}}],[\"在此之前\",{\"1\":{\"0\":1}}],[\"在此创建或者使用已有的renderobjecttowidgetelement\",{\"1\":{\"119\":1}}],[\"在此后service的活动和activity无关\",{\"1\":{\"17\":1}}],[\"在a阶段的热点代码会被从普通il优化为ssa\",{\"1\":{\"394\":1}}],[\"在attach\",{\"1\":{\"237\":1}}],[\"在attachrenderobject方法中插入的方式很简单\",{\"1\":{\"127\":1}}],[\"在attachtorendertree方法中创建renderobjecttowidgetelement并mount到element\",{\"1\":{\"119\":1}}],[\"在activity中使用自动注入依赖\",{\"0\":{\"93\":1}}],[\"在action\",{\"1\":{\"64\":1}}],[\"在app启动之后的第一次\",{\"1\":{\"122\":1}}],[\"在application\",{\"1\":{\"81\":1,\"94\":1}}],[\"在application中检测到是第一次启动的话\",{\"1\":{\"14\":1}}],[\"在api>26时无此变量\",{\"1\":{\"72\":1}}],[\"在android程序运行时\",{\"1\":{\"94\":1}}],[\"在androidmanifest\",{\"1\":{\"68\":1,\"71\":1}}],[\"在android系统中\",{\"1\":{\"60\":1}}],[\"在android中使用\",{\"0\":{\"326\":1}}],[\"在android中使用协程\",{\"1\":{\"322\":1}}],[\"在android中activity之间等传递对象\",{\"1\":{\"316\":1}}],[\"在android中调用此方法\",{\"1\":{\"211\":1}}],[\"在android中的使用\",{\"1\":{\"88\":1}}],[\"在android中\",{\"1\":{\"40\":1}}],[\"在addtouchtarget\",{\"1\":{\"13\":1}}],[\"在收到broadcast\",{\"1\":{\"12\":1}}],[\"在广播接收器中收听到broadcast\",{\"1\":{\"11\":1}}],[\"在重启时恢复闹钟\",{\"0\":{\"9\":1}}],[\"在指定时间触发闹钟\",{\"1\":{\"4\":1}}],[\"在指定的时间触发闹钟\",{\"1\":{\"4\":1}}],[\"在系统休眠时也会唤醒系统\",{\"1\":{\"4\":1}}],[\"在时间范围内一直循环\",{\"1\":{\"3\":1}}],[\"在我们创建file时\",{\"1\":{\"111\":1}}],[\"在我对编程尚且懵懂之际\",{\"1\":{\"0\":1}}],[\"在我学习的过程中\",{\"1\":{\"0\":1}}],[\"2之间的增量是1\",{\"1\":{\"460\":1}}],[\"2元素\",{\"1\":{\"459\":1}}],[\"2序列\",{\"1\":{\"459\":1}}],[\"2直到没有待排序的项目\",{\"1\":{\"455\":1}}],[\"2k\",{\"1\":{\"443\":1}}],[\"2都无法满足时\",{\"1\":{\"437\":1}}],[\"2g\",{\"1\":{\"413\":1}}],[\"2已实现\",{\"1\":{\"368\":1}}],[\"2已经替我们做了好多事情\",{\"1\":{\"94\":1}}],[\"2已经可以自动为我们注入dispatchingandroidinjector依赖\",{\"1\":{\"92\":1}}],[\"2a\",{\"1\":{\"344\":1}}],[\"2b\",{\"1\":{\"344\":2}}],[\"2node\",{\"1\":{\"413\":1}}],[\"2n\",{\"1\":{\"280\":7}}],[\"237\",{\"1\":{\"458\":1}}],[\"23\",{\"1\":{\"115\":1,\"211\":1,\"302\":2,\"369\":1,\"458\":1}}],[\"23+\",{\"1\":{\"3\":1}}],[\"22\",{\"1\":{\"115\":1,\"302\":1}}],[\"27已经失效\",{\"1\":{\"371\":1}}],[\"27到2011\",{\"1\":{\"302\":1}}],[\"27\",{\"1\":{\"111\":1,\"115\":1,\"302\":2}}],[\"277490\",{\"1\":{\"15\":1}}],[\"21\",{\"1\":{\"115\":1,\"302\":1,\"398\":1,\"459\":1,\"461\":1}}],[\"2118406\",{\"1\":{\"111\":1}}],[\"210529\",{\"1\":{\"110\":1}}],[\"21996\",{\"1\":{\"110\":1}}],[\"2160\",{\"1\":{\"81\":1}}],[\"2在fragment的使用和在activity中的使用十分相似\",{\"1\":{\"94\":1}}],[\"2为我们注入的dispatchactivityinjector对象\",{\"1\":{\"92\":1}}],[\"2的逻辑放到一份代码里面\",{\"1\":{\"88\":1}}],[\"2的使用分为activity和fragment两部分\",{\"1\":{\"88\":1}}],[\"2的x\",{\"1\":{\"61\":1}}],[\"2中\",{\"1\":{\"83\":1}}],[\"2中各个注解的作用\",{\"1\":{\"82\":1}}],[\"2到底是如何实现的呢\",{\"1\":{\"82\":1}}],[\"2是google维护的一款可用于java和android的依赖注入框架\",{\"1\":{\"82\":1}}],[\"2是中线center的值\",{\"1\":{\"15\":1}}],[\"250dp\",{\"1\":{\"66\":2}}],[\"25\",{\"1\":{\"53\":1,\"115\":1,\"302\":1}}],[\"2582\",{\"1\":{\"13\":1}}],[\"28\",{\"1\":{\"14\":1,\"115\":1,\"302\":1}}],[\"24\",{\"1\":{\"5\":1,\"115\":1,\"280\":1,\"282\":1,\"283\":1,\"285\":1,\"302\":3,\"308\":1,\"398\":1}}],[\"2623\",{\"1\":{\"370\":1}}],[\"26属于2010年的51周\",{\"1\":{\"302\":1}}],[\"26到2011\",{\"1\":{\"302\":1}}],[\"26\",{\"1\":{\"5\":3,\"115\":1,\"302\":3}}],[\"26+\",{\"1\":{\"1\":1}}],[\"2048\",{\"1\":{\"398\":2}}],[\"2033\",{\"1\":{\"81\":1}}],[\"2009\",{\"1\":{\"302\":1}}],[\"200\",{\"1\":{\"170\":2,\"172\":1,\"173\":3,\"212\":1,\"371\":1}}],[\"200dp\",{\"1\":{\"79\":4}}],[\"2000~2999\",{\"1\":{\"41\":1}}],[\"20\",{\"1\":{\"36\":1,\"115\":1,\"131\":1,\"143\":1,\"234\":1,\"282\":1,\"285\":1,\"302\":1}}],[\"2014\",{\"1\":{\"347\":2,\"417\":2}}],[\"2010\",{\"1\":{\"302\":1}}],[\"2016\",{\"1\":{\"280\":1,\"398\":4}}],[\"20160719100800917\",{\"1\":{\"58\":1}}],[\"2011\",{\"1\":{\"111\":1,\"302\":1}}],[\"201307\",{\"1\":{\"58\":1}}],[\"2012110216160766\",{\"1\":{\"58\":1}}],[\"2012\",{\"1\":{\"58\":1}}],[\"2018\",{\"1\":{\"35\":1,\"36\":1,\"368\":1,\"401\":1}}],[\"2019\",{\"1\":{\"5\":5,\"59\":1,\"274\":1,\"302\":9}}],[\"2020\",{\"1\":{\"302\":2}}],[\"20200422115253\",{\"1\":{\"58\":1}}],[\"20200429160005\",{\"1\":{\"22\":1}}],[\"2021\",{\"1\":{\"81\":1}}],[\"20210531\",{\"1\":{\"2\":1}}],[\"29到2020\",{\"1\":{\"302\":3}}],[\"29972028\",{\"1\":{\"286\":1}}],[\"29868235\",{\"1\":{\"54\":1}}],[\"29\",{\"1\":{\"2\":1,\"115\":1,\"302\":8}}],[\"2\",{\"0\":{\"20\":1,\"72\":1,\"82\":1,\"88\":1,\"251\":1,\"257\":1,\"263\":1,\"419\":1},\"1\":{\"0\":1,\"2\":1,\"13\":2,\"14\":1,\"15\":5,\"17\":1,\"39\":1,\"43\":2,\"52\":6,\"53\":3,\"55\":1,\"57\":1,\"58\":2,\"60\":1,\"62\":1,\"63\":4,\"64\":6,\"66\":2,\"69\":1,\"74\":1,\"76\":2,\"80\":1,\"81\":3,\"82\":1,\"83\":1,\"87\":2,\"88\":2,\"94\":1,\"95\":2,\"101\":5,\"108\":2,\"111\":1,\"112\":1,\"115\":6,\"117\":1,\"122\":1,\"125\":1,\"126\":1,\"128\":1,\"130\":1,\"137\":1,\"141\":2,\"142\":1,\"144\":2,\"145\":1,\"147\":1,\"154\":1,\"155\":1,\"156\":1,\"161\":1,\"172\":2,\"173\":3,\"198\":2,\"201\":3,\"211\":1,\"213\":1,\"220\":5,\"231\":3,\"250\":1,\"262\":1,\"263\":1,\"273\":1,\"277\":2,\"278\":2,\"279\":1,\"283\":1,\"288\":2,\"294\":1,\"296\":7,\"299\":1,\"302\":5,\"305\":1,\"318\":1,\"321\":2,\"322\":4,\"325\":1,\"326\":1,\"327\":7,\"328\":1,\"334\":2,\"336\":1,\"344\":2,\"346\":3,\"347\":2,\"361\":1,\"362\":2,\"366\":1,\"368\":1,\"369\":4,\"372\":1,\"373\":1,\"375\":1,\"376\":2,\"377\":2,\"378\":4,\"389\":4,\"394\":2,\"395\":1,\"396\":1,\"407\":1,\"413\":2,\"428\":2,\"432\":1,\"437\":1,\"438\":1,\"439\":3,\"440\":2,\"441\":4,\"451\":3,\"453\":9,\"455\":1,\"456\":2,\"459\":11,\"460\":2,\"462\":4,\"467\":3}}],[\"基于python3\",{\"1\":{\"369\":1}}],[\"基于rxjava\",{\"1\":{\"321\":1}}],[\"基于rendersliver的sliver\",{\"1\":{\"234\":1}}],[\"基于renderbox的box\",{\"1\":{\"234\":1}}],[\"基于viewport等的pageview\",{\"1\":{\"234\":1}}],[\"基于vuepress\",{\"1\":{\"0\":1}}],[\"基于\",{\"1\":{\"212\":3,\"227\":3}}],[\"基于底层实现\",{\"1\":{\"157\":1}}],[\"基本思路是将根节点推出\",{\"1\":{\"441\":1}}],[\"基本上都只能定义动画的\",{\"1\":{\"154\":1}}],[\"基本数据类型\",{\"1\":{\"33\":1,\"252\":1}}],[\"基准\",{\"1\":{\"53\":1}}],[\"基线\",{\"1\":{\"15\":1}}],[\"基线到中线的距离\",{\"1\":{\"15\":2}}],[\"基础教程之类的文章\",{\"1\":{\"0\":1}}],[\"这句话也可以不修改\",{\"1\":{\"418\":1}}],[\"这句话存疑\",{\"1\":{\"274\":1}}],[\"这行语句是使用\",{\"1\":{\"418\":1}}],[\"这三者的切换逻辑通过实现\",{\"1\":{\"399\":1}}],[\"这三个主要方法关系如下\",{\"1\":{\"13\":1}}],[\"这三个可以看这里\",{\"1\":{\"3\":1}}],[\"这并不是安排cfe和vm执行dart\",{\"1\":{\"393\":1}}],[\"这其中的isolate\",{\"1\":{\"382\":1}}],[\"这才是真正创建后的结果\",{\"1\":{\"352\":1}}],[\"这篇文章写于2016年\",{\"1\":{\"408\":1}}],[\"这篇文章基于我在慕课网上面学习python简单爬虫写的内容\",{\"1\":{\"371\":1}}],[\"这篇文章是我今天在\",{\"1\":{\"347\":1}}],[\"这篇文章介绍了如何在\",{\"1\":{\"347\":1}}],[\"这篇文章主要想总结一下aidl具体为我们做了什么工作\",{\"1\":{\"40\":1}}],[\"这相当于首先执行一个顺序映射\",{\"1\":{\"327\":1}}],[\"这类操作符本身不是挂起函数\",{\"1\":{\"338\":1}}],[\"这类操作符\",{\"1\":{\"327\":1}}],[\"这类文章在我的学习过程中对我有很大的帮助\",{\"1\":{\"0\":1}}],[\"这段示例代码来自\",{\"1\":{\"306\":1}}],[\"这次我们用到的时静态内部类\",{\"1\":{\"294\":1}}],[\"这意味着每次插入或弹出时要进行排序\",{\"1\":{\"448\":1}}],[\"这意味着\",{\"1\":{\"291\":1}}],[\"这当然也包括字符串的定义\",{\"1\":{\"283\":1}}],[\"这表示在serializable序列化时不主动去序列化这些值\",{\"1\":{\"280\":1}}],[\"这导致我们在使用\",{\"1\":{\"233\":1}}],[\"这实际上与\",{\"1\":{\"207\":1}}],[\"这部分与\",{\"1\":{\"207\":1}}],[\"这部分见仁见智\",{\"1\":{\"202\":1}}],[\"这部分内容的代码在extended\",{\"1\":{\"201\":1}}],[\"这会导致一个问题\",{\"1\":{\"309\":1}}],[\"这会导致多图列表的时候图片被频繁的回收\",{\"1\":{\"198\":1}}],[\"这会触发dart层\",{\"1\":{\"116\":1}}],[\"这也告诉我们singlechildscrollview的父级需要指定指定主轴方向约束\",{\"1\":{\"238\":1}}],[\"这也是\",{\"1\":{\"230\":1}}],[\"这也是创建\",{\"1\":{\"213\":1}}],[\"这也是为什么在上一步我们简单的\",{\"1\":{\"171\":1}}],[\"这也就是为什么我们之前说singlechildscrollview的child只能是box\",{\"1\":{\"237\":1}}],[\"这也就要求\",{\"1\":{\"184\":1}}],[\"这也就证明了我们之前说的\",{\"1\":{\"101\":1}}],[\"这也就解释了在服务端和客户端可以通过两个不同的构造方法获取到有同样功能的messenger\",{\"1\":{\"43\":1}}],[\"这也就解释了在服务的onbind\",{\"1\":{\"43\":1}}],[\"这两个本地值的影响\",{\"1\":{\"302\":1}}],[\"这两个分别传入\",{\"1\":{\"212\":1}}],[\"这两个值可以随时修改\",{\"1\":{\"184\":1}}],[\"这两个\",{\"1\":{\"170\":1}}],[\"这两个owner管理着我们所说的flutter的widget\",{\"1\":{\"119\":1}}],[\"这两种构造方法主要会初始化以下变量\",{\"1\":{\"161\":1}}],[\"这一范围\",{\"1\":{\"146\":1,\"157\":1}}],[\"这一切是怎么实现的呢\",{\"0\":{\"94\":1}}],[\"这些增量的集合称为间隔序列\",{\"1\":{\"461\":1}}],[\"这些数据结构使用关键字的值存储\",{\"1\":{\"445\":1}}],[\"这些数据与操作都受着的影响\",{\"1\":{\"399\":1}}],[\"这些继承自listadapter的adapter实现了的作用\",{\"1\":{\"399\":1}}],[\"这些组件可帮助您遵循最佳做法\",{\"1\":{\"399\":1}}],[\"这些操作符也是冷操作符\",{\"1\":{\"327\":1}}],[\"这些滑动布局会内部消耗掉滑动事件\",{\"1\":{\"226\":1}}],[\"这些都需要使用者在\",{\"1\":{\"211\":1}}],[\"这些方案会在\",{\"1\":{\"203\":1}}],[\"这些方案对一般纯\",{\"1\":{\"203\":1}}],[\"这些控件会自动从之前的状态切换到新状态\",{\"1\":{\"146\":1,\"157\":1}}],[\"这些异常可以使用runzonedguarded捕获并处理\",{\"1\":{\"141\":1}}],[\"这些内容便绘制在屏幕上面\",{\"1\":{\"127\":1}}],[\"这些图片除了要绘制的图形有着色之外\",{\"1\":{\"57\":1}}],[\"这取决于我们想要给fragment绑定的依赖\",{\"1\":{\"94\":1}}],[\"这时又可以细分为以下三种情况\",{\"1\":{\"458\":1}}],[\"这时\",{\"1\":{\"306\":1}}],[\"这时如果该thread还在运行\",{\"1\":{\"288\":1}}],[\"这时就可以用到我在google官方示例代码中学到的一个小技巧了\",{\"1\":{\"94\":1}}],[\"这时就需要第五个主角\",{\"1\":{\"86\":1}}],[\"这时候可以找该子节点的右子树中最小的\",{\"1\":{\"432\":2}}],[\"这时候执行方法有两个阶段\",{\"1\":{\"394\":1}}],[\"这时候就需要用到\",{\"1\":{\"182\":1}}],[\"这时候\",{\"1\":{\"85\":1}}],[\"这时service的实例化过程被移到了client的外部某处\",{\"1\":{\"82\":1}}],[\"这就涉及到和\",{\"1\":{\"197\":1}}],[\"这就要提到第二个主角\",{\"1\":{\"84\":1}}],[\"这就是我们当前activity对应的mainactivitysubcomponent\",{\"1\":{\"94\":1}}],[\"这就是binder只需一次拷贝的\",{\"1\":{\"58\":1}}],[\"这就是那只预先造好的鸡\",{\"1\":{\"58\":1}}],[\"这几天学习\",{\"1\":{\"79\":1}}],[\"这几天的工作中用到了控件组来实现复杂布局\",{\"1\":{\"56\":1}}],[\"这几个方案中\",{\"1\":{\"3\":1}}],[\"这是一篇使用python脚本发布的文章\",{\"1\":{\"468\":1}}],[\"这是一个python脚本\",{\"1\":{\"366\":1}}],[\"这是一个external方法\",{\"1\":{\"112\":1,\"114\":1}}],[\"这是一个托管在\",{\"1\":{\"0\":1}}],[\"这是爬虫功能的重点之一\",{\"1\":{\"371\":1}}],[\"这是第二个\",{\"1\":{\"334\":1}}],[\"这是第一个\",{\"1\":{\"334\":1}}],[\"这是非常容易从示例中观察到的\",{\"1\":{\"331\":1}}],[\"这是我在学习bennyhuo\",{\"1\":{\"321\":1}}],[\"这是为什么呢\",{\"1\":{\"309\":1}}],[\"这是asynctask源码的简单分析\",{\"1\":{\"80\":1}}],[\"这是由于使用了androidautosize适配方案后\",{\"1\":{\"53\":1}}],[\"这是因为堆中每个节点的左右子节点的位置和大小无关\",{\"1\":{\"439\":1}}],[\"这是因为按照拓扑排序条件2没有后继点的顶点必然排在后面\",{\"1\":{\"438\":1}}],[\"这是因为java中object\",{\"1\":{\"291\":1}}],[\"这是因为singlechildscrollview和child都按照最长的尺寸布局\",{\"1\":{\"238\":1}}],[\"这是因为虽然在imagecache\",{\"1\":{\"211\":1}}],[\"这是因为虽然两个listener对象不同\",{\"1\":{\"36\":1}}],[\"这是因为overlay\",{\"1\":{\"171\":1}}],[\"这是因为该方法的注解\",{\"1\":{\"91\":1}}],[\"这是因为\",{\"1\":{\"65\":1,\"130\":1}}],[\"这是因为xfermode的效果\",{\"1\":{\"57\":1}}],[\"这是因为他在注册的同时也对binder的死亡就行了监听\",{\"1\":{\"36\":1}}],[\"这里面\",{\"1\":{\"459\":1}}],[\"这里面的u2\",{\"1\":{\"283\":1}}],[\"这里面的各个\",{\"1\":{\"211\":1}}],[\"这里面的\",{\"1\":{\"98\":1}}],[\"这里并没有交换\",{\"1\":{\"456\":1}}],[\"这里我选择的是使用\",{\"1\":{\"419\":1}}],[\"这里我们注意到他的\",{\"1\":{\"124\":1}}],[\"这里我们可以看到getimessenger\",{\"1\":{\"43\":1}}],[\"这里消息处理的步骤也启动了\",{\"1\":{\"391\":1}}],[\"这里执行了messagehandler\",{\"1\":{\"391\":1}}],[\"这里\",{\"1\":{\"391\":1}}],[\"这里通过threadpool\",{\"1\":{\"389\":1}}],[\"这里只是做了一些环境准备\",{\"1\":{\"389\":1}}],[\"这里分析一下\",{\"1\":{\"388\":1}}],[\"这里分析一下后面两种方式\",{\"1\":{\"378\":1}}],[\"这里也调用了run方法\",{\"1\":{\"386\":1}}],[\"这里也只需要使用当时pause\",{\"1\":{\"375\":1}}],[\"这里可以被取消\",{\"1\":{\"327\":1}}],[\"这里可以看到\",{\"1\":{\"109\":1,\"127\":1,\"387\":1}}],[\"这里匹配了tc\",{\"1\":{\"305\":1}}],[\"这里提供一个实例\",{\"1\":{\"282\":1}}],[\"这里有一份github上面的实现源码\",{\"1\":{\"282\":1}}],[\"这里有一个知识点\",{\"1\":{\"54\":1}}],[\"这里原始hash值\",{\"1\":{\"280\":1}}],[\"这里一次只读取一个字节\",{\"1\":{\"272\":1}}],[\"这里指定最小高度为父级高度\",{\"1\":{\"241\":1,\"242\":1}}],[\"这里处理了滑动时键盘隐藏的问题\",{\"1\":{\"235\":1}}],[\"这里scrollcontroller如果没有指定或者primary为true的话会使用上级最近的\",{\"1\":{\"235\":1}}],[\"这里创建isolate的时候\",{\"1\":{\"387\":1}}],[\"这里创建slivers\",{\"1\":{\"227\":1}}],[\"这里创建了pipelineowner\",{\"1\":{\"118\":1}}],[\"这里outerdelta是剩下的delta\",{\"1\":{\"226\":1}}],[\"这里offset可能会导致scrollposition内部视觉上出现越界现象\",{\"1\":{\"220\":1}}],[\"这里吧剩下的innerdelta完全给了inner\",{\"1\":{\"226\":1}}],[\"这里表示nestedscrollview中存在inner和outer\",{\"1\":{\"225\":1}}],[\"这里表示只有outer或者velocity为0\",{\"1\":{\"225\":1}}],[\"这里使用constrainedbox确保了column主轴方向最小尺寸是父级大小\",{\"1\":{\"241\":1}}],[\"这里使用了自定义的viewport来实现布局逻辑\",{\"1\":{\"235\":1}}],[\"这里使用的是viewport的主轴尺寸\",{\"1\":{\"213\":1}}],[\"这里使用该方法在\",{\"1\":{\"79\":1}}],[\"这里需要注意\",{\"1\":{\"211\":1}}],[\"这里需要时\",{\"1\":{\"88\":1}}],[\"这里会执行的是createisolategroupandsetuphelper\",{\"1\":{\"387\":1}}],[\"这里会有一个有意思的现象\",{\"1\":{\"309\":1}}],[\"这里会发生gc\",{\"1\":{\"391\":1}}],[\"这里会发生一次内存拷贝\",{\"1\":{\"211\":1}}],[\"这里会发生内存拷贝\",{\"1\":{\"211\":1}}],[\"这里会创建一个封装的texture\",{\"1\":{\"206\":1}}],[\"这里会在imagestream获取到imageinfo之后更新\",{\"1\":{\"193\":1}}],[\"这里当t为0\",{\"1\":{\"186\":1}}],[\"这里要注意\",{\"1\":{\"170\":1}}],[\"这里要处理特殊情况\",{\"1\":{\"62\":1}}],[\"这里根据shrinkwrap的不同分别创建两种viewport\",{\"1\":{\"228\":1}}],[\"这里根据service\",{\"1\":{\"114\":1}}],[\"这里根据动画的进度更改shuttle的位置和大小\",{\"1\":{\"181\":1}}],[\"这里根据turns的值计算当前的角度\",{\"1\":{\"155\":1}}],[\"这里是ui线程\",{\"1\":{\"322\":1}}],[\"这里是主线程\",{\"1\":{\"322\":2}}],[\"这里是主要创建scrollable的地方\",{\"1\":{\"227\":1}}],[\"这里是处理当scrollable\",{\"1\":{\"227\":1}}],[\"这里是使用\",{\"1\":{\"211\":1}}],[\"这里是无论如何都会执行的代码\",{\"1\":{\"142\":1}}],[\"这里是兜底的捕获异常\",{\"1\":{\"142\":1}}],[\"这里是捕获rangeerror类型的异常\",{\"1\":{\"142\":1}}],[\"这里是自定义的控件\",{\"1\":{\"132\":1}}],[\"这里是null\",{\"1\":{\"121\":1}}],[\"这里appcolor的\",{\"1\":{\"130\":1}}],[\"这里alignment默认是居中\",{\"1\":{\"122\":1}}],[\"这里将header和body传入slivers\",{\"1\":{\"213\":1}}],[\"这里将renderobjecttowidgetelement\",{\"1\":{\"121\":1}}],[\"这里将renderobjecttowidgetelement注册到owner中\",{\"1\":{\"121\":1}}],[\"这里将mworker传了进去\",{\"1\":{\"80\":1}}],[\"这里因为renderview是根节点\",{\"1\":{\"121\":1}}],[\"这里最终会通过updatechild方法将rootwidget对应的element插入到\",{\"1\":{\"121\":1}}],[\"这里切换了isolate\",{\"1\":{\"115\":1}}],[\"这里解析完收到的参数后\",{\"1\":{\"115\":1}}],[\"这里依次遍历传入的pendingtimers\",{\"1\":{\"109\":1}}],[\"这里主要触发了2步\",{\"1\":{\"391\":1}}],[\"这里主要做了3件事\",{\"1\":{\"389\":1}}],[\"这里主要做了2件事\",{\"1\":{\"118\":1}}],[\"这里主要是对isolate进行初始化\",{\"1\":{\"383\":1}}],[\"这里主要进行了2步\",{\"1\":{\"381\":1}}],[\"这里主要有两步\",{\"1\":{\"383\":1}}],[\"这里主要有2步\",{\"1\":{\"127\":1}}],[\"这里主要有3步\",{\"1\":{\"119\":1}}],[\"这里主要有3个步骤\",{\"1\":{\"114\":1}}],[\"这里主要的实现是vmlibraryhooks\",{\"1\":{\"108\":1}}],[\"这里主要调用了dart中的\",{\"1\":{\"100\":1}}],[\"这里就不再赘述了\",{\"1\":{\"94\":1}}],[\"这里就需要用到0号引用binder\",{\"1\":{\"58\":1}}],[\"这里调用对应的renderobjectwidget创建\",{\"1\":{\"127\":1}}],[\"这里调用element对应的widget的build方法创建widget\",{\"1\":{\"126\":1}}],[\"这里调用的是element的updatechild方法\",{\"1\":{\"126\":1}}],[\"这里调用的是ibookmanager的getsth\",{\"1\":{\"40\":1}}],[\"这里调用了\",{\"1\":{\"97\":1}}],[\"这里调用了常用方法之一onpreexecute\",{\"1\":{\"80\":1}}],[\"这里调用方法如下\",{\"1\":{\"80\":1}}],[\"这里才是处理申请权限的相关代码\",{\"1\":{\"69\":1}}],[\"这里实现我们服务能够提供的方法\",{\"1\":{\"58\":1}}],[\"这里实际上是调用了远程的ibinder的transact\",{\"1\":{\"40\":1}}],[\"这里写的是app\",{\"1\":{\"56\":1}}],[\"这里的activitymainbinding类是databinding根据xml文件的名字自动替我们生成的\",{\"1\":{\"401\":1}}],[\"这里的appcolor的\",{\"1\":{\"130\":1}}],[\"这里的worker要执行的任务都是在messagehandler\",{\"1\":{\"391\":1}}],[\"这里的widget是在widget创建singlechildrenderobjectelement的时候传入的\",{\"1\":{\"125\":1}}],[\"这里的widget即`renderobjecttowidgetelement`\",{\"1\":{\"121\":1}}],[\"这里的kernel\",{\"1\":{\"387\":1}}],[\"这里的参数分别是sendport\",{\"1\":{\"377\":1}}],[\"这里的参数顺序\",{\"1\":{\"115\":1}}],[\"这里的抽象方法wraprequestbody\",{\"1\":{\"364\":1}}],[\"这里的url只是一个例子\",{\"1\":{\"347\":1}}],[\"这里的from被out修饰\",{\"1\":{\"322\":1}}],[\"这里的overscroll为0\",{\"1\":{\"226\":1}}],[\"这里的逻辑是\",{\"1\":{\"220\":1,\"390\":1}}],[\"这里的列表滑动和header的滑动联动\",{\"1\":{\"212\":1}}],[\"这里的textureid是从provider创建的imageinfo中获取的\",{\"1\":{\"206\":1}}],[\"这里的tag与上一个页面的hero\",{\"1\":{\"170\":1}}],[\"这里的provider实际上创建的是一个虚假的ui\",{\"1\":{\"206\":1}}],[\"这里的主要有两个步骤\",{\"1\":{\"126\":1}}],[\"这里的过程我们下面center一节再分析\",{\"1\":{\"121\":1}}],[\"这里的实现可以参考https\",{\"1\":{\"115\":1}}],[\"这里的\",{\"1\":{\"57\":1,\"100\":1,\"119\":1,\"125\":1,\"126\":1,\"161\":1}}],[\"这里的布局决定了布局显示的样子\",{\"1\":{\"56\":1}}],[\"这里的操作只是将没有被删除的数据移动到了数组的前面\",{\"1\":{\"48\":1}}],[\"这里用来注册监听的类是remotecallbacklist\",{\"1\":{\"36\":1}}],[\"这里时在服务端调用回调方法的写法\",{\"1\":{\"36\":1}}],[\"这个枢纽的取法很关键\",{\"1\":{\"467\":1}}],[\"这个问题显然很好解决\",{\"1\":{\"459\":1}}],[\"这个算法要求如下\",{\"1\":{\"428\":1}}],[\"这个文件夹内所有的内容就是处理好的网站\",{\"1\":{\"419\":1}}],[\"这个平台的各种优点\",{\"1\":{\"408\":1}}],[\"这个阶段使用的il指令类似基于stack的虚拟机\",{\"1\":{\"395\":1}}],[\"这个阶段\",{\"1\":{\"395\":1}}],[\"这个在不同的device上面不一样\",{\"1\":{\"383\":1}}],[\"这个我们在后面回调网络请求状态的时候会用到\",{\"1\":{\"363\":1}}],[\"这个命令可以拉去最新版本并自动合并\",{\"1\":{\"347\":1}}],[\"这个例子来自importnew\",{\"1\":{\"345\":1}}],[\"这个函数启动一个新的计数器\",{\"1\":{\"334\":1}}],[\"这个异常会被所有的处理者忽略\",{\"1\":{\"329\":1}}],[\"这个时候就会调用set\",{\"1\":{\"288\":1}}],[\"这个值约等于4g\",{\"1\":{\"283\":1}}],[\"这个值可以大于1\",{\"1\":{\"280\":1}}],[\"这个引用指向局部变量引用指向的内存空间\",{\"1\":{\"281\":1}}],[\"这个接口表示render\",{\"1\":{\"237\":1}}],[\"这个类处理了scrollable传入的scrollposition也即这里的viewportoffset\",{\"1\":{\"235\":1}}],[\"这个类是用来为相应的activity提供一个androidinjector\",{\"1\":{\"92\":1}}],[\"这个也是\",{\"1\":{\"213\":1}}],[\"这个imageinfo是对ui\",{\"1\":{\"195\":1}}],[\"这个io\",{\"1\":{\"112\":1}}],[\"这个和\",{\"1\":{\"141\":1}}],[\"这个和我们最初的分析一致\",{\"1\":{\"122\":1}}],[\"这个过程会完成自动向上转型\",{\"1\":{\"292\":1}}],[\"这个过程与普通widget一致\",{\"1\":{\"128\":1}}],[\"这个过程称为内存映射\",{\"1\":{\"58\":1}}],[\"这个widget就是richtext\",{\"1\":{\"127\":1}}],[\"这个原因我们后面再分析\",{\"1\":{\"124\":1}}],[\"这个对象全局唯一\",{\"1\":{\"119\":1}}],[\"这个sendport是io\",{\"1\":{\"111\":1,\"112\":1}}],[\"这个线程会在合适的时间唤起timer执行\",{\"1\":{\"106\":1}}],[\"这个\",{\"1\":{\"101\":1}}],[\"这个构造函数\",{\"1\":{\"80\":1}}],[\"这个布局文件是\",{\"1\":{\"79\":2}}],[\"这个步骤十分重要\",{\"1\":{\"65\":1}}],[\"这个binder最终会被传输到绑定这个服务时所用的serviceconnection对象的onserviceconnected方法中\",{\"1\":{\"58\":1}}],[\"这个是外部类的引用\",{\"1\":{\"281\":1}}],[\"这个是系统实现的一个behavior\",{\"1\":{\"55\":1}}],[\"这个是我们在aidl中定义的方法\",{\"1\":{\"40\":1}}],[\"这个是我们在aidl中定义的getsth\",{\"1\":{\"40\":1}}],[\"这个flag让任意向下的滚动都会导致该view变为可见\",{\"1\":{\"55\":1}}],[\"这个center\",{\"1\":{\"15\":1}}],[\"这个方法就会被交给一个后台优化编译器\",{\"1\":{\"396\":1}}],[\"这个方法的主要作用使用new\",{\"1\":{\"391\":1}}],[\"这个方法的主要逻辑都在他的子类中\",{\"1\":{\"118\":1}}],[\"这个方法的定义在sdk\",{\"1\":{\"378\":1}}],[\"这个方法在其子类中的实现一般是调用okhttprequest子类的build方法\",{\"1\":{\"364\":1}}],[\"这个方法最终以threadlocal对象为key\",{\"1\":{\"288\":1}}],[\"这个方法内部会调用updated\",{\"1\":{\"128\":1}}],[\"这个方法内部是实际上是通过timer实现\",{\"1\":{\"102\":1}}],[\"这个方法会遍历\",{\"1\":{\"128\":1}}],[\"这个方法会将传递进来的callback赋值给\",{\"1\":{\"100\":1}}],[\"这个方法除了调用element同名方法外\",{\"1\":{\"126\":1}}],[\"这个方法则是尽快安排一个frame以便在屏幕下次刷新的时候显示app的内容\",{\"1\":{\"122\":1}}],[\"这个方法\",{\"1\":{\"13\":1}}],[\"这种方式创建一种能力受限的isolate\",{\"1\":{\"373\":1}}],[\"这种方法很慢\",{\"1\":{\"409\":1}}],[\"这种方法会在inheritedwidget更新的时候\",{\"1\":{\"130\":1}}],[\"这种方法在主进程启动时\",{\"1\":{\"14\":1}}],[\"这种差异来自于子作业的执行失败不会传播给它的父作业的事实\",{\"1\":{\"333\":1}}],[\"这种行为不能被覆盖\",{\"1\":{\"329\":1}}],[\"这种代码一般没有用到堆中的公用资源\",{\"1\":{\"320\":1}}],[\"这种字面值方式定义的时候才会有的限制\",{\"1\":{\"283\":1}}],[\"这种类型的传参一般都需传入\",{\"1\":{\"233\":1}}],[\"这种属于图片刚下载完\",{\"1\":{\"198\":1}}],[\"这种写法\",{\"1\":{\"130\":2}}],[\"这种情况可能出现在接收方使用了一个与发送方不同版本的类\",{\"1\":{\"306\":1}}],[\"这种情况\",{\"1\":{\"220\":1}}],[\"这种情况就需要另外一个角色\",{\"1\":{\"87\":1}}],[\"这种情况又该怎么处理呢\",{\"1\":{\"85\":1}}],[\"这种情况下\",{\"1\":{\"395\":1}}],[\"这种情况下服务端可以执行耗时操作而无需另建线程\",{\"1\":{\"36\":1}}],[\"这种情况下在部分低端机上\",{\"1\":{\"14\":1}}],[\"这种将虚拟内存系统集成到文件系统的方法可以简单而高效地把程序和数据加载到内存中\",{\"1\":{\"58\":1}}],[\"这种做法为内核提供了一种便利的方法来访问物理内存中任何特定的位置\",{\"1\":{\"58\":1}}],[\"这样比较\",{\"1\":{\"467\":1}}],[\"这样排序数组要>3\",{\"1\":{\"467\":1}}],[\"这样排序数组大小要>3\",{\"1\":{\"466\":1}}],[\"这样将得到的每个子数组都划分为两个子数组\",{\"1\":{\"465\":1}}],[\"这样将flow的构建\",{\"1\":{\"327\":1}}],[\"这样重复步骤1\",{\"1\":{\"456\":1}}],[\"这样等完全插入\",{\"1\":{\"442\":1}}],[\"这样需要有两倍与待排序数组大小的空间\",{\"1\":{\"442\":1}}],[\"这样需要使用\",{\"1\":{\"157\":1}}],[\"这样依次循环\",{\"1\":{\"438\":1}}],[\"这样android系统为二者分配同一个linux用户id\",{\"1\":{\"421\":1}}],[\"这样一个简单的利用\",{\"1\":{\"419\":1}}],[\"这样viewmodel只需要关心他要的操作而不必关系数据来源的具体实现\",{\"1\":{\"399\":1}}],[\"这样下次调用就不用再走runtime了\",{\"1\":{\"395\":1}}],[\"这样下载中且还未完全下载的图片所占用的内存会逐渐累计\",{\"1\":{\"198\":1}}],[\"这样只需要更改main\",{\"1\":{\"367\":1}}],[\"这样同一个应用只需要在最开始的时候配置一下诸如网络超时\",{\"1\":{\"365\":1}}],[\"这样保证了在android中\",{\"1\":{\"365\":1}}],[\"这样我们在第一次使用okhttputils的时候初始化的okhttpclient便会被保存到这里\",{\"1\":{\"363\":1}}],[\"这样我们的app启动了\",{\"1\":{\"122\":1}}],[\"这样循环直到整个树的每个节点都被遍历完毕\",{\"1\":{\"346\":1}}],[\"这样可以在关闭通道时执行特定操作\",{\"1\":{\"334\":1}}],[\"这样可以一起处理它们\",{\"1\":{\"202\":1}}],[\"这样b便可以将interface中方法的实现委托给类a的对象a\",{\"1\":{\"322\":1}}],[\"这样每次生成的key都不一样\",{\"1\":{\"296\":1}}],[\"这样每次scrollable修改scrollposition之后都会触发paint\",{\"1\":{\"239\":1}}],[\"这样实现单例的原理是类的静态变量全局唯一\",{\"1\":{\"294\":1}}],[\"这样累计下来必然影响效率\",{\"1\":{\"294\":1}}],[\"这样原本定义的是map<string\",{\"1\":{\"291\":1}}],[\"这样内部类和外部类持有的是同一个全部变量\",{\"1\":{\"281\":1}}],[\"这样他就可以被运行\",{\"1\":{\"275\":1}}],[\"这样在枢纽c两边的数组满足\",{\"1\":{\"465\":1}}],[\"这样在activity等地方对livedata进行订阅后\",{\"1\":{\"402\":1}}],[\"这样在同一个isolate\",{\"1\":{\"383\":1}}],[\"这样在第二次标记时会被移出即将回收集合\",{\"1\":{\"266\":1}}],[\"这样在startpoint\",{\"1\":{\"63\":1}}],[\"这样如果content超出viewport的部分比较多就会非常耗费性能\",{\"1\":{\"240\":1}}],[\"这样如果service构造方法有更新时\",{\"1\":{\"82\":1}}],[\"这样也为我们后续通过监听offset修改显示部分child的内容实现滑动效果提供了可能\",{\"1\":{\"238\":1}}],[\"这样最终的效果就是我们的singlechildscrollview在child不超过父级约束的时候只占据child的内容\",{\"1\":{\"238\":1}}],[\"这样其接管了外层的滑动事件\",{\"1\":{\"213\":1}}],[\"这样会创建\",{\"1\":{\"213\":1}}],[\"这样renderview\",{\"1\":{\"121\":1}}],[\"这样便可以在dart端通过消息分发接收到结果\",{\"1\":{\"115\":1}}],[\"这样的数组本身就是有序的\",{\"1\":{\"459\":1}}],[\"这样的提示\",{\"1\":{\"411\":1}}],[\"这样的步骤繁琐且没有意义\",{\"1\":{\"405\":1}}],[\"这样的重复性工作仍然是个不小的工作量\",{\"1\":{\"94\":1}}],[\"这样的代码就可以了\",{\"1\":{\"94\":1}}],[\"这样的需求\",{\"1\":{\"4\":1}}],[\"这样子这个问题就成了如何将一个bottom从一个柱子\",{\"1\":{\"459\":1}}],[\"这样子避免每次比较都要交换\",{\"1\":{\"456\":1}}],[\"这样子比较n次就可以完成排序\",{\"1\":{\"455\":1,\"456\":1}}],[\"这样子一轮比赛完毕最大的就在后面了\",{\"1\":{\"455\":1}}],[\"这样子一个\",{\"1\":{\"414\":1}}],[\"这样子在网站上显示的时候\",{\"1\":{\"419\":1}}],[\"这样子颠颠撞撞大概也有五六年的时间了\",{\"1\":{\"408\":1}}],[\"这样子\",{\"1\":{\"294\":1,\"412\":1}}],[\"这样子保证了每个类都是先经过最顶端的类加载器bootstrap\",{\"1\":{\"272\":1}}],[\"这样子当用到service的时候\",{\"1\":{\"85\":1}}],[\"这样子可以在子线程工作\",{\"1\":{\"17\":1}}],[\"这样dagger\",{\"1\":{\"83\":1}}],[\"这样深耦合的代码显然不是我们需要的\",{\"1\":{\"82\":1}}],[\"这样绘制出来的曲线比较符合我们的要求\",{\"1\":{\"63\":1}}],[\"这样就完成了整个快速排序\",{\"1\":{\"465\":1}}],[\"这样就完成了一次rebuild\",{\"1\":{\"128\":1}}],[\"这样就不会对已经排序的数组再次排序\",{\"1\":{\"461\":1}}],[\"这样就得到了一个有序数组\",{\"1\":{\"459\":1}}],[\"这样就能保证这个树的结构不会出错\",{\"1\":{\"432\":2}}],[\"这样就获取到未安装apk中的资源了\",{\"1\":{\"427\":1}}],[\"这样就可以立即继续进一步执行代码\",{\"1\":{\"337\":1}}],[\"这样就可以避免多个线程因为操作的数据值不一致而产生错误\",{\"1\":{\"317\":1}}],[\"这样就可以在初始化一个key后\",{\"1\":{\"296\":1}}],[\"这样就同时存在多个类的对象\",{\"1\":{\"294\":1}}],[\"这样就会产生问题\",{\"1\":{\"281\":1}}],[\"这样就将\",{\"1\":{\"223\":1}}],[\"这样就实现了进程间通信\",{\"1\":{\"58\":1}}],[\"这样就保证了单例\",{\"1\":{\"294\":1}}],[\"这样就保证了\",{\"1\":{\"53\":1}}],[\"这样编译完之后\",{\"1\":{\"54\":1}}],[\"这样\",{\"1\":{\"53\":1,\"127\":1,\"170\":1,\"211\":1}}],[\"这样当连续遍历n次后\",{\"1\":{\"455\":1}}],[\"这样当数据更新时\",{\"1\":{\"401\":1}}],[\"这样当线程t1访问时\",{\"1\":{\"294\":1}}],[\"这样当t1再次执行tag2时就会再生成一个新对象\",{\"1\":{\"294\":1}}],[\"这样当child比父级给的约束大时\",{\"1\":{\"239\":1}}],[\"这样当scrollable中由于用户手势或者通过scrollcontroller调用jumpto\",{\"1\":{\"237\":1}}],[\"这样当路由变化时\",{\"1\":{\"181\":1}}],[\"这样当\",{\"1\":{\"112\":1,\"178\":1}}],[\"这样当时我们在\",{\"1\":{\"111\":1}}],[\"这样当下一次进行put\",{\"1\":{\"48\":1}}],[\"这样当querylocalinterface时会返回与descriptor一致的iinterface\",{\"1\":{\"40\":1}}],[\"这样当用户点击app图标启动app时\",{\"1\":{\"14\":1}}],[\"这样主activity的生命周期也不会受影响\",{\"1\":{\"14\":1}}],[\"这样不管是分享出去的原图\",{\"1\":{\"2\":1}}],[\"探究平常用法背后的实现原理\",{\"1\":{\"0\":1}}],[\"但插入慢o\",{\"1\":{\"451\":1}}],[\"但下图不是完全二叉树\",{\"1\":{\"444\":1}}],[\"但却找不到\",{\"1\":{\"438\":1}}],[\"但同时图中顶点数不为0的情况\",{\"1\":{\"438\":1}}],[\"但同一时刻最多只能有一个osthread\",{\"1\":{\"392\":1}}],[\"但边数最少的连通子图\",{\"1\":{\"438\":1}}],[\"但链地址法只是线性下降\",{\"1\":{\"428\":1}}],[\"但误打误撞竟然也成功的搭建好了博客\",{\"1\":{\"408\":1}}],[\"但并不是所有的方法都有对应的dart\",{\"1\":{\"395\":1}}],[\"但思路如此\",{\"1\":{\"371\":1}}],[\"但仍然存在以下问题\",{\"1\":{\"370\":1}}],[\"但仍然希望以安全的方式使用它\",{\"1\":{\"322\":1}}],[\"但每次新的emit到来时\",{\"1\":{\"337\":1}}],[\"但他的取消只会向下传播\",{\"1\":{\"330\":1}}],[\"但他的操作是挂起的\",{\"1\":{\"328\":1}}],[\"但他的父类没有实现序列化\",{\"1\":{\"307\":1}}],[\"但他在添加数据时需要扩展数组\",{\"1\":{\"44\":1}}],[\"但如果容量充足\",{\"1\":{\"428\":1}}],[\"但如果存在锁竞争\",{\"1\":{\"320\":1}}],[\"但如果按照iso\",{\"1\":{\"302\":1}}],[\"但如果threadlocal本身保存的都是同一个对象\",{\"1\":{\"288\":1}}],[\"但其他线程都在等待池无法竞争锁\",{\"1\":{\"297\":1}}],[\"但其实还有一张更加简洁的方法\",{\"1\":{\"294\":1}}],[\"但可能会导致死锁\",{\"1\":{\"297\":1}}],[\"但还没获取到该对象的锁时\",{\"1\":{\"297\":1}}],[\"但还是建议子类只需要实现\",{\"1\":{\"186\":1}}],[\"但当考虑到多线程时事情会变得有些复杂\",{\"1\":{\"294\":1}}],[\"但当使用app内部的density=2\",{\"1\":{\"53\":1}}],[\"但都在table数组的大小范围内\",{\"1\":{\"280\":1}}],[\"但解析可以在初始化之后开始\",{\"1\":{\"273\":1}}],[\"但会对标记进行压缩\",{\"1\":{\"264\":1}}],[\"但特殊情况下可能无法完整显示因而需要支持滚动的情况\",{\"1\":{\"242\":1}}],[\"但提供了在\",{\"1\":{\"229\":1}}],[\"但最后还是使用imageinfo\",{\"1\":{\"200\":1}}],[\"但不管哪种方式\",{\"1\":{\"387\":1}}],[\"但不保证执行完该方法\",{\"1\":{\"266\":1}}],[\"但不适合对象过多的情况\",{\"1\":{\"262\":1}}],[\"但不会\",{\"1\":{\"197\":1}}],[\"但不可否认的是\",{\"1\":{\"0\":1}}],[\"但有时候并不能满足使用需求\",{\"1\":{\"187\":1,\"199\":1,\"203\":1}}],[\"但在实际开始动画之前\",{\"1\":{\"161\":1}}],[\"但\",{\"1\":{\"160\":1}}],[\"但这里的this\",{\"1\":{\"281\":1}}],[\"但这时如何将二者联系起来呢\",{\"1\":{\"83\":1}}],[\"但这种情况绘制出来的贝塞尔曲线如下\",{\"1\":{\"62\":1}}],[\"但这只是一种障眼法\",{\"1\":{\"14\":1}}],[\"但进程间的同步问题操作系统无法实现\",{\"1\":{\"58\":1}}],[\"但是组节点53没有左子节点\",{\"1\":{\"458\":1}}],[\"但是简单\",{\"1\":{\"455\":1}}],[\"但是插入和读取比较耗时\",{\"1\":{\"452\":1}}],[\"但是查找慢o\",{\"1\":{\"450\":1}}],[\"但是需要有额外的空间\",{\"1\":{\"445\":1}}],[\"但是需要注意的是\",{\"1\":{\"242\":1}}],[\"但是堆排序堆数据初始分布不敏感一直都是\",{\"1\":{\"442\":1}}],[\"但是没法保证这个值是这个堆中的最小值\",{\"1\":{\"439\":1}}],[\"但是没有同步互斥机制\",{\"1\":{\"58\":1}}],[\"但是我的电脑\",{\"1\":{\"418\":1}}],[\"但是之前多次尝试不得其道\",{\"1\":{\"408\":1}}],[\"但是受hexo的限制\",{\"1\":{\"405\":1}}],[\"但是作为初入编程的一点点小纪念\",{\"1\":{\"398\":1}}],[\"但是太慢了\",{\"1\":{\"396\":1}}],[\"但是具体的方法体此时依旧还没有被反序列\",{\"1\":{\"394\":1}}],[\"但是依然可以往里面加入消息\",{\"1\":{\"375\":1}}],[\"但是可能在执行添加代码的时候isolate就已经终止了而导致这些方法收不到回调\",{\"1\":{\"372\":1}}],[\"但是可以通过flowon\",{\"1\":{\"339\":1}}],[\"但是可以调用挂起函数suspend\",{\"1\":{\"327\":1}}],[\"但是教程中爬虫截止2018\",{\"1\":{\"371\":1}}],[\"但是为了符合语法规范\",{\"1\":{\"369\":1}}],[\"但是为了便于理解径向动画的原理\",{\"1\":{\"172\":1}}],[\"但是一旦初始化就不能再修改\",{\"1\":{\"369\":1}}],[\"但是尽量不要用正则表达式之类的符号\",{\"1\":{\"349\":1}}],[\"但是会阻塞当前线程\",{\"1\":{\"336\":1}}],[\"但是会有相互循环引用的问题\",{\"1\":{\"265\":1}}],[\"但是主协程也总是会被取消的\",{\"1\":{\"329\":1}}],[\"但是只是判断\",{\"1\":{\"328\":1}}],[\"但是同时收集结果流\",{\"1\":{\"327\":1}}],[\"但是有一个逻辑漏洞\",{\"1\":{\"319\":1}}],[\"但是并发下并不线程安全\",{\"1\":{\"317\":1}}],[\"但是并非固定的1\",{\"1\":{\"273\":1}}],[\"但是根据下面的说法\",{\"1\":{\"305\":1}}],[\"但是编译器不知道这个类具体是什么\",{\"1\":{\"292\":1}}],[\"但是编译器要进行额外的类型检查\",{\"1\":{\"291\":1}}],[\"但是能保存fruit的容器应该也要能安全的保存apple\",{\"1\":{\"291\":1}}],[\"但是object\",{\"1\":{\"288\":1}}],[\"但是慢并且最好不要用来存储大容量的数据\",{\"1\":{\"287\":1}}],[\"但是再看外部类的全局变量\",{\"1\":{\"281\":1}}],[\"但是数组类的元素类型要通过类加载器创建\",{\"1\":{\"274\":1}}],[\"但是当拓展时无法申请到足够内存时会导致outofmemory\",{\"1\":{\"252\":1}}],[\"但是当column的children尺寸大于父级尺寸时\",{\"1\":{\"242\":1}}],[\"但是实际这些图片加载过程中的内存由native端图片加载库管理\",{\"1\":{\"211\":1}}],[\"但是powerimage本身不会出现我们之前在flutter\",{\"1\":{\"211\":1}}],[\"但是对于大多数混合开发的\",{\"1\":{\"203\":1}}],[\"但是对于renderview下级的节点\",{\"1\":{\"121\":1}}],[\"但是必须在初始化之前完成\",{\"1\":{\"277\":1}}],[\"但是必须在实际使用到之前赋非null值\",{\"1\":{\"184\":1}}],[\"但是必须注意要在setcontentview\",{\"1\":{\"13\":1}}],[\"但是也可能超出此范围\",{\"1\":{\"183\":1}}],[\"但是默认情况下其只能产生线性变化的\",{\"1\":{\"182\":1}}],[\"但是样式看起来和页面中的文字样式不一样\",{\"1\":{\"171\":1}}],[\"但是因为\",{\"1\":{\"377\":1}}],[\"但是因为没有监听\",{\"1\":{\"152\":1}}],[\"但是因为build方法重新执行了一次\",{\"1\":{\"130\":1}}],[\"但是release模式下不会\",{\"1\":{\"143\":1}}],[\"但是android可以访问flutter的assets资源\",{\"1\":{\"137\":1}}],[\"但是这样仍然有个问题\",{\"1\":{\"294\":1}}],[\"但是这样也存在一个问题\",{\"1\":{\"294\":1}}],[\"但是这样就不能和主线程共享数据\",{\"1\":{\"136\":1}}],[\"但是这种方法从子进程返回主进程涉及到进程间通信\",{\"1\":{\"14\":1}}],[\"但是这种只适用于主动分享出去的文件\",{\"1\":{\"2\":1}}],[\"但是两者都会在每一帧被rebuild\",{\"1\":{\"132\":1}}],[\"但是不包括父类的\",{\"1\":{\"295\":1}}],[\"但是不同的是\",{\"1\":{\"131\":1}}],[\"但是不需要再单独开一个进程\",{\"1\":{\"14\":1}}],[\"但是重新绘制了\",{\"1\":{\"130\":1}}],[\"但是很显然实际开发中\",{\"1\":{\"84\":1}}],[\"但是如果遇到数据是逆序的时候\",{\"1\":{\"445\":1}}],[\"但是如果threadlocal保存的是一个引用类型的对象\",{\"1\":{\"288\":1}}],[\"但是如果是final修饰的常量\",{\"1\":{\"277\":1}}],[\"但是如果是另外一个沙盒中的错误则无法处理\",{\"1\":{\"145\":1}}],[\"但是如果要联动处理在\",{\"1\":{\"213\":1}}],[\"但是如果只是想解决图片缓存问题的话\",{\"1\":{\"202\":1}}],[\"但是如果想要实现更复杂的效果\",{\"1\":{\"156\":1}}],[\"但是如果有特殊的动画效果需要实现\",{\"1\":{\"153\":1}}],[\"但是如果activity\",{\"1\":{\"94\":1}}],[\"但是如果每个依赖都这样写的话\",{\"1\":{\"82\":1}}],[\"但是如果用户选择了不再提醒\",{\"1\":{\"68\":1}}],[\"但是如果保存大量数据\",{\"1\":{\"49\":1}}],[\"但是由于向上\",{\"1\":{\"442\":1}}],[\"但是由于正则匹配\",{\"1\":{\"349\":1}}],[\"但是由于java语言的特性\",{\"1\":{\"294\":1}}],[\"但是由于finlize\",{\"1\":{\"266\":1}}],[\"但是由于a\",{\"1\":{\"265\":1}}],[\"但是由于直接子widget要重建\",{\"1\":{\"128\":1}}],[\"但是由于硬件加速不支持canvas\",{\"1\":{\"57\":1}}],[\"但是由于没有对数据再包装\",{\"1\":{\"49\":1}}],[\"但是在实际使用的时候\",{\"1\":{\"362\":1}}],[\"但是在实际运行中\",{\"1\":{\"14\":1}}],[\"但是在运行时会被检查出objarr指向的数组实际类型\",{\"1\":{\"291\":1}}],[\"但是在某些特殊场景\",{\"1\":{\"240\":1}}],[\"但是在此期间\",{\"1\":{\"115\":1}}],[\"但是在后续使用到状态栏相关代码的时候发现获取到的状态栏高度和实际高度不一致\",{\"1\":{\"53\":1}}],[\"但是在客户端中被回调的方法却是和客户端中主动调用服务端方法的线程一致\",{\"1\":{\"36\":1}}],[\"但是他们底层的binder对象是同一个\",{\"1\":{\"36\":1}}],[\"但是\",{\"1\":{\"21\":1,\"53\":1,\"131\":1,\"226\":1,\"240\":1,\"287\":1,\"291\":1,\"294\":2,\"335\":1,\"352\":1}}],[\"但是宿主死后仍按照启动service方式存活\",{\"1\":{\"21\":1}}],[\"但是无法确保在精确的时间得到执行\",{\"1\":{\"3\":1}}],[\"但是仍然无法正常使用\",{\"1\":{\"1\":1}}],[\"但网络上已经有很多步骤更加具体\",{\"1\":{\"0\":1}}],[\"▽\",{\"1\":{\"0\":1}}],[\"☆╰╮\",{\"1\":{\"0\":1}}],[\"ε\",{\"1\":{\"0\":1}}],[\"￣\",{\"1\":{\"0\":4}}],[\"千万不要打脸\",{\"1\":{\"0\":1}}],[\"哎呀\",{\"1\":{\"0\":1}}],[\"也只需要分别使用a\",{\"1\":{\"375\":1}}],[\"也只是更新该线程本身的threadlocal对应的value\",{\"1\":{\"288\":1}}],[\"也需要执行权限x\",{\"1\":{\"351\":1}}],[\"也保证了只能创建一个单例\",{\"1\":{\"294\":1}}],[\"也无法区分objarr1和objarr2中实际指向的两个map<k\",{\"1\":{\"291\":1}}],[\"也无法通过虚引用获取其实例\",{\"1\":{\"271\":1}}],[\"也有人说在方法区\",{\"1\":{\"274\":1}}],[\"也叫运行时绑定\",{\"1\":{\"273\":1}}],[\"也支持在同一个页面内嵌套多个滑动列表并关联\",{\"1\":{\"226\":1}}],[\"也计入\",{\"1\":{\"225\":1}}],[\"也实现了\",{\"1\":{\"224\":1}}],[\"也是okhttprequest各个子类主要的不同点\",{\"1\":{\"364\":1}}],[\"也是合法的\",{\"1\":{\"291\":1}}],[\"也是\",{\"1\":{\"226\":1}}],[\"也是body\",{\"1\":{\"223\":1}}],[\"也是通过在post\",{\"1\":{\"31\":1}}],[\"也一并传入\",{\"1\":{\"215\":1}}],[\"也创建有自己的\",{\"1\":{\"178\":1}}],[\"也正常显示\",{\"1\":{\"171\":1}}],[\"也会调用dart\",{\"1\":{\"383\":1}}],[\"也会删除用户对应的主目录home\",{\"1\":{\"353\":1}}],[\"也会反序列化\",{\"1\":{\"304\":1}}],[\"也会被相同大小的\",{\"1\":{\"171\":1}}],[\"也会消耗点击事件\",{\"1\":{\"13\":1}}],[\"也要stoptheworld\",{\"1\":{\"264\":1}}],[\"也要把异常向上抛\",{\"1\":{\"144\":1}}],[\"也要慢慢的修正\",{\"1\":{\"0\":1}}],[\"也不是可运行的程序或批处理文件\",{\"1\":{\"411\":1}}],[\"也不用实时修改\",{\"1\":{\"322\":1}}],[\"也不全是刚刚包裹child内容的大小\",{\"1\":{\"131\":1}}],[\"也不能乱写瞎写\",{\"1\":{\"0\":1}}],[\"也即我们示例中的centerwidget\",{\"1\":{\"121\":1}}],[\"也就会执行containerrenderobjectmixin<rendersliver\",{\"1\":{\"230\":1}}],[\"也就意味着他在rendering\",{\"1\":{\"122\":1}}],[\"也就可以推导出\",{\"1\":{\"81\":1}}],[\"也就解决屏幕适配的问题\",{\"1\":{\"53\":1}}],[\"也就是一个工具模板\",{\"1\":{\"415\":1}}],[\"也就是isolate\",{\"1\":{\"381\":1}}],[\"也就是isolate创建好以后执行的方法\",{\"1\":{\"379\":1}}],[\"也就是使用string\",{\"1\":{\"283\":1}}],[\"也就是在jvm进行类加载\",{\"1\":{\"279\":1}}],[\"也就是singlechildscrollview不可滑动\",{\"1\":{\"238\":1}}],[\"也就是singlechildscrollview的尺寸\",{\"1\":{\"238\":1}}],[\"也就是singlechildrenderobjectelement\",{\"1\":{\"125\":1}}],[\"也就是恢复原位\",{\"1\":{\"226\":1}}],[\"也就是恢复到初始位置\",{\"1\":{\"220\":1}}],[\"也就是delta不会\",{\"1\":{\"220\":1}}],[\"也就是dart中的sendport\",{\"1\":{\"114\":1}}],[\"也就是tohero\",{\"1\":{\"180\":1}}],[\"也就是threadpool\",{\"1\":{\"115\":1}}],[\"也就是导致这个任务后续代码无法执行\",{\"1\":{\"141\":1}}],[\"也就是本例中的center\",{\"1\":{\"127\":1}}],[\"也就是richtext\",{\"1\":{\"126\":1}}],[\"也就是这里先执行了center\",{\"1\":{\"122\":1}}],[\"也就是\",{\"1\":{\"121\":1,\"173\":3,\"213\":1,\"226\":1}}],[\"也就是我们可以滑动的范围\",{\"1\":{\"238\":1}}],[\"也就是我们的renderview\",{\"1\":{\"120\":1}}],[\"也就是我们最开始写的center\",{\"1\":{\"120\":1}}],[\"也就是我们通过dart端的\",{\"1\":{\"115\":1}}],[\"也就是之前widgetsflutterbinding混合的几个bindingbase子类中\",{\"1\":{\"118\":1}}],[\"也就是前面的\",{\"1\":{\"101\":1}}],[\"也就是说videmodule的数据生命周期可能要比他附着的activity或fragment的生命周期长\",{\"1\":{\"402\":1}}],[\"也就是说将完全相同一个对象保存了两次\",{\"1\":{\"309\":1}}],[\"也就是说在程序执行\",{\"1\":{\"279\":1}}],[\"也就是说会将所有内容全部加载\",{\"1\":{\"240\":1}}],[\"也就是说其内部lay\",{\"1\":{\"237\":1}}],[\"也就是说其将\",{\"1\":{\"183\":1}}],[\"也就是说要么不能超范围\",{\"1\":{\"220\":1}}],[\"也就是说无论\",{\"1\":{\"213\":1}}],[\"也就是说imagecache\",{\"1\":{\"198\":1}}],[\"也就是说网络图片加载的url\",{\"1\":{\"196\":1}}],[\"也就是说它只能产生\",{\"1\":{\"186\":1}}],[\"也就是说text插入到center过程主要在statelesselement中\",{\"1\":{\"126\":1}}],[\"也就是说实际上还是上一个执行完毕\",{\"1\":{\"95\":1}}],[\"也就是说\",{\"1\":{\"85\":1,\"115\":1,\"131\":1,\"150\":1,\"155\":1,\"158\":1,\"220\":3,\"242\":1,\"272\":1,\"285\":1,\"291\":1,\"365\":1,\"382\":1}}],[\"也就是说不能有两个同名的方法\",{\"1\":{\"34\":1}}],[\"也就是把自己要执行的intent和执行所需的context封装后给别人\",{\"1\":{\"75\":1}}],[\"也就是用来确定图形绘制到目标图形的时候\",{\"1\":{\"57\":1}}],[\"也就是需要我们在使用该binder时实现的方法\",{\"1\":{\"40\":1}}],[\"也没有hash计算\",{\"1\":{\"44\":1}}],[\"也证实了我们之前的一个观点\",{\"1\":{\"43\":1}}],[\"也可能超出范围\",{\"1\":{\"220\":1}}],[\"也可能是\",{\"1\":{\"197\":1}}],[\"也可能不是\",{\"1\":{\"186\":1}}],[\"也可以配置成运行成不同的进程\",{\"1\":{\"421\":1}}],[\"也可以省略\",{\"1\":{\"345\":1}}],[\"也可以用thread\",{\"1\":{\"336\":1}}],[\"也可以随机数\",{\"1\":{\"304\":1}}],[\"也可以随时触发新动画\",{\"1\":{\"153\":1}}],[\"也可以kg\",{\"1\":{\"296\":1}}],[\"也可以使用powerimage\",{\"1\":{\"204\":1}}],[\"也可以使用自定义widget\",{\"1\":{\"132\":1}}],[\"也可以被传入\",{\"1\":{\"182\":1}}],[\"也可以按照child的大小显示\",{\"1\":{\"131\":1}}],[\"也可以交给其他fragment或者activity的\",{\"1\":{\"94\":1}}],[\"也可以将aidl涉及到的aidl文件\",{\"1\":{\"32\":1}}],[\"也可以类比得到\",{\"1\":{\"15\":1}}],[\"也可参考官方文档或者android\",{\"1\":{\"2\":1}}],[\"宁可少写\",{\"1\":{\"0\":1}}],[\"务必每个观点都有对应的参考依据\",{\"1\":{\"0\":1}}],[\"今天重新学习类三种排序方法\",{\"1\":{\"289\":1}}],[\"今天对\",{\"1\":{\"79\":1}}],[\"今天就因为这种问题\",{\"1\":{\"0\":1}}],[\"今日头条适配方案\",{\"1\":{\"53\":1}}],[\"今日起\",{\"1\":{\"0\":1}}],[\"今后写博客\",{\"1\":{\"0\":1}}],[\"的小数组进行排序\",{\"1\":{\"462\":1}}],[\"的算法减小h在此进行希尔排序\",{\"1\":{\"462\":1}}],[\"的下标\",{\"1\":{\"440\":1}}],[\"的有向图\",{\"1\":{\"438\":1}}],[\"的分享\",{\"1\":{\"419\":1}}],[\"的分析基础上进行对比分析\",{\"1\":{\"199\":1}}],[\"的相关配置\",{\"1\":{\"417\":1}}],[\"的版本\",{\"1\":{\"416\":1}}],[\"的文件\",{\"1\":{\"414\":1}}],[\"的文章\",{\"1\":{\"0\":1}}],[\"的安装路径\",{\"1\":{\"412\":1}}],[\"的call\",{\"1\":{\"397\":1}}],[\"的center为锚点\",{\"1\":{\"231\":1}}],[\"的辅助isolate\",{\"1\":{\"393\":1}}],[\"的worker比等待中的任务数pending\",{\"1\":{\"390\":1}}],[\"的widget\",{\"1\":{\"121\":1}}],[\"的来源一致\",{\"1\":{\"387\":1}}],[\"的后缀\",{\"1\":{\"357\":1}}],[\"的后面\",{\"1\":{\"345\":1}}],[\"的环境就配置好了\",{\"1\":{\"348\":1}}],[\"的账号和密码\",{\"1\":{\"347\":1}}],[\"的返回类型不是\",{\"1\":{\"345\":1}}],[\"的返回值\",{\"1\":{\"233\":1}}],[\"的单个值\",{\"1\":{\"334\":1}}],[\"的单例加载图片\",{\"1\":{\"211\":1}}],[\"的lock和unlock方法可以保证同一时间只有一个协程访问指定代码\",{\"1\":{\"334\":1}}],[\"的list<widget>\",{\"1\":{\"227\":1}}],[\"的取消只会向下传播\",{\"1\":{\"331\":1}}],[\"的取值限定了他们的范围\",{\"1\":{\"220\":1}}],[\"的区别如下\",{\"1\":{\"391\":1}}],[\"的区别\",{\"0\":{\"323\":1}}],[\"的区别在于\",{\"1\":{\"17\":1}}],[\"的t需要与实际的group的t保持一致\",{\"1\":{\"322\":1}}],[\"的fetch\",{\"1\":{\"322\":1}}],[\"的foreachtween\",{\"1\":{\"152\":1}}],[\"的result实例保存了计算结果\",{\"1\":{\"322\":1}}],[\"的renderobjecttowidgetelement\",{\"1\":{\"121\":1}}],[\"的kotlin入门视频时的一些笔记\",{\"1\":{\"321\":1}}],[\"的key与要查询的key\",{\"1\":{\"49\":1}}],[\"的第一周\",{\"1\":{\"302\":1}}],[\"的第二个闹钟时\",{\"1\":{\"3\":1,\"7\":1}}],[\"的思路\",{\"1\":{\"298\":1}}],[\"的超类型为t\",{\"1\":{\"293\":1}}],[\"的向上转型\",{\"1\":{\"291\":1}}],[\"的意义存疑\",{\"1\":{\"282\":1}}],[\"的高位和地位进行按位异或\",{\"1\":{\"280\":1}}],[\"的静态变量\",{\"1\":{\"279\":1}}],[\"的静态方法\",{\"1\":{\"178\":1}}],[\"的动态链接\",{\"1\":{\"278\":1}}],[\"的引用\",{\"1\":{\"278\":1}}],[\"的限制只接受创建\",{\"1\":{\"233\":1}}],[\"的懒加载从而避免创建无法通过\",{\"1\":{\"233\":1}}],[\"的方式存储和管理与ui相关的数据\",{\"1\":{\"402\":1}}],[\"的方式进行计算\",{\"1\":{\"327\":1}}],[\"的方向展示\",{\"1\":{\"231\":1}}],[\"的方法来达到这个目的\",{\"1\":{\"321\":1}}],[\"的方法中\",{\"1\":{\"223\":1}}],[\"的方法\",{\"1\":{\"95\":1,\"183\":1,\"212\":1,\"225\":2,\"229\":2}}],[\"的反方向展示\",{\"1\":{\"231\":1}}],[\"的原因\",{\"1\":{\"230\":1}}],[\"的原创文章\",{\"1\":{\"58\":1,\"288\":1}}],[\"的不同\",{\"1\":{\"233\":1}}],[\"的不同分别创建\",{\"1\":{\"228\":1}}],[\"的不同创建两种\",{\"1\":{\"228\":1}}],[\"的不同状态分别更新\",{\"1\":{\"191\":1}}],[\"的交互设计\",{\"1\":{\"227\":1}}],[\"的定义是\",{\"1\":{\"227\":1}}],[\"的定位是官方\",{\"1\":{\"199\":1}}],[\"的创建的\",{\"1\":{\"226\":1}}],[\"的滚动事件进行组合\",{\"1\":{\"226\":1}}],[\"的通知\",{\"1\":{\"226\":1}}],[\"的重点\",{\"1\":{\"226\":1}}],[\"的范围时\",{\"1\":{\"223\":1}}],[\"的手势事件都会由\",{\"1\":{\"223\":1}}],[\"的影响\",{\"1\":{\"222\":1}}],[\"的逻辑比较简单\",{\"1\":{\"215\":1}}],[\"的逻辑要简单的多\",{\"1\":{\"155\":1}}],[\"的配合\",{\"1\":{\"213\":1}}],[\"的nestedscrollview\",{\"1\":{\"213\":1}}],[\"的事件转发给\",{\"1\":{\"213\":1}}],[\"的最大滑动范围\",{\"1\":{\"213\":1}}],[\"的最大可滑动范围\",{\"1\":{\"213\":1}}],[\"的最小高\",{\"1\":{\"79\":1}}],[\"的主轴方向尺寸\",{\"1\":{\"213\":1}}],[\"的主轴尺寸\",{\"1\":{\"213\":1,\"226\":1}}],[\"的主要作用是借助rawimagedatamap提供了缓存图片原始数据的功能\",{\"1\":{\"202\":1}}],[\"的主要作用是根据传入的\",{\"1\":{\"183\":1}}],[\"的主要不同在于extendednetworkimageprovider的实现\",{\"1\":{\"200\":1}}],[\"的主要区别在于\",{\"1\":{\"185\":1}}],[\"的主要子类之一\",{\"1\":{\"184\":1}}],[\"的主要逻辑在\",{\"1\":{\"189\":1}}],[\"的主要逻辑在对应的\",{\"1\":{\"155\":1}}],[\"的主要逻辑也在继承自\",{\"1\":{\"153\":1}}],[\"的尺寸变化之后会调用其\",{\"1\":{\"223\":1}}],[\"的尺寸\",{\"1\":{\"213\":1}}],[\"的尺寸多出一个\",{\"1\":{\"213\":1}}],[\"的尺寸如何\",{\"1\":{\"213\":1}}],[\"的尺寸和位置参数\",{\"1\":{\"55\":1}}],[\"的进一步封装\",{\"1\":{\"212\":1}}],[\"的话\",{\"1\":{\"212\":1,\"383\":1,\"384\":1}}],[\"的滑动联动\",{\"1\":{\"226\":1}}],[\"的滑动事件都会通过\",{\"1\":{\"226\":1}}],[\"的滑动事件都归集到\",{\"1\":{\"223\":1}}],[\"的滑动事件组合起来\",{\"1\":{\"226\":1}}],[\"的滑动是独立的两个事件\",{\"1\":{\"212\":1}}],[\"的滑动\",{\"1\":{\"212\":1}}],[\"的物理属性\",{\"1\":{\"212\":1,\"227\":1}}],[\"的封装\",{\"1\":{\"212\":1,\"227\":2}}],[\"的onloadresult方法中对获取到的powerimageresult进行处理之后回调powerimagebaserequest的onloadsuccess\",{\"1\":{\"211\":1}}],[\"的onreceive方法中创建一个线程\",{\"1\":{\"59\":1}}],[\"的内存也在flutter侧管理\",{\"1\":{\"211\":1}}],[\"的内容绘制在屏幕上面\",{\"1\":{\"195\":1}}],[\"的内容只会突然变化为\",{\"1\":{\"153\":1}}],[\"的内容\",{\"1\":{\"69\":1,\"146\":1,\"157\":1}}],[\"的build\",{\"1\":{\"205\":1}}],[\"的功能\",{\"1\":{\"202\":1,\"415\":1}}],[\"的架构图如下\",{\"1\":{\"199\":1}}],[\"的拓展版\",{\"1\":{\"199\":1}}],[\"的拓展\",{\"1\":{\"199\":1}}],[\"的拓展组件\",{\"1\":{\"199\":1}}],[\"的二次开发\",{\"1\":{\"198\":1}}],[\"的scrollcontroller\",{\"1\":{\"224\":1}}],[\"的scrollx>0即景色向右移动\",{\"1\":{\"41\":1}}],[\"的sizebytes可能为\",{\"1\":{\"197\":1}}],[\"的关系如下\",{\"1\":{\"196\":1}}],[\"的全局方法\",{\"1\":{\"195\":1}}],[\"的一些通用方法\",{\"1\":{\"229\":1}}],[\"的一部分内容来实现滑动的视觉设计效果\",{\"1\":{\"227\":1}}],[\"的一个句柄\",{\"1\":{\"194\":1}}],[\"的一次细节较真\",{\"1\":{\"55\":2}}],[\"的构造方法或者\",{\"1\":{\"186\":1}}],[\"的处理\",{\"1\":{\"186\":1}}],[\"的父类\",{\"1\":{\"186\":1,\"233\":1}}],[\"的效果\",{\"1\":{\"183\":1}}],[\"的源码实现做一简单分析\",{\"1\":{\"212\":1}}],[\"的源码可以发现\",{\"1\":{\"207\":1}}],[\"的源码可以看到\",{\"1\":{\"184\":1}}],[\"的源码\",{\"1\":{\"183\":1,\"201\":1}}],[\"的视觉效果\",{\"1\":{\"181\":1}}],[\"的位置信息\",{\"1\":{\"177\":1}}],[\"的呢\",{\"1\":{\"176\":1}}],[\"的显示\",{\"1\":{\"191\":1}}],[\"的显示与否\",{\"1\":{\"176\":1}}],[\"的显示效果\",{\"1\":{\"176\":1}}],[\"的过程\",{\"1\":{\"173\":1,\"186\":1}}],[\"的过程叫做注入\",{\"1\":{\"82\":1}}],[\"的正方形\",{\"1\":{\"173\":1}}],[\"的圆\",{\"1\":{\"173\":1}}],[\"的组合效果\",{\"1\":{\"173\":1}}],[\"的样式\",{\"1\":{\"173\":1}}],[\"的上层有一个叠加层\",{\"1\":{\"171\":1}}],[\"的属性\",{\"1\":{\"170\":1}}],[\"的作用于\",{\"1\":{\"183\":1}}],[\"的作用\",{\"1\":{\"168\":1}}],[\"的帧刷新\",{\"1\":{\"162\":1}}],[\"的情况外\",{\"1\":{\"166\":1}}],[\"的情况\",{\"1\":{\"161\":2,\"317\":1}}],[\"的状态\",{\"1\":{\"159\":2,\"226\":1}}],[\"的各个构造方法创建指定的\",{\"1\":{\"198\":1}}],[\"的各个子类也只需要实现transform方法即可\",{\"1\":{\"183\":1}}],[\"的各个\",{\"1\":{\"157\":1}}],[\"的各个属性\",{\"1\":{\"157\":1}}],[\"的工作\",{\"1\":{\"155\":1}}],[\"的类型是否为指定的\",{\"1\":{\"230\":1}}],[\"的类型\",{\"1\":{\"184\":1,\"230\":1}}],[\"的类\",{\"1\":{\"154\":1}}],[\"的其他子类\",{\"1\":{\"154\":1}}],[\"的子类借助\",{\"1\":{\"233\":1}}],[\"的子类只需要按照要求提供\",{\"1\":{\"227\":1}}],[\"的子类只需要重写\",{\"1\":{\"184\":1}}],[\"的子类可以满足基本的需求\",{\"1\":{\"156\":1}}],[\"的子类一样\",{\"1\":{\"153\":1}}],[\"的子类\",{\"1\":{\"153\":1,\"183\":1,\"186\":1,\"212\":1,\"233\":1}}],[\"的子类主要实现\",{\"1\":{\"152\":1}}],[\"的变化展示不同部分的\",{\"1\":{\"228\":1}}],[\"的变化\",{\"1\":{\"152\":1,\"213\":1}}],[\"的大小则随着\",{\"1\":{\"173\":1}}],[\"的大小固定为var\",{\"1\":{\"173\":1}}],[\"的大小\",{\"1\":{\"146\":1,\"157\":1,\"172\":1,\"173\":4,\"285\":1}}],[\"的消息循环机制有关\",{\"1\":{\"141\":1}}],[\"的inheritedwidget\",{\"1\":{\"130\":1}}],[\"的id\",{\"1\":{\"79\":1}}],[\"的performrebuild\",{\"1\":{\"128\":1}}],[\"的继承关系\",{\"1\":{\"124\":1}}],[\"的mount方法中\",{\"1\":{\"121\":1}}],[\"的力量之源\",{\"1\":{\"86\":1}}],[\"的测试数据\",{\"1\":{\"81\":1}}],[\"的\",{\"1\":{\"79\":1,\"87\":1,\"102\":1,\"115\":1,\"153\":3,\"158\":1,\"159\":1,\"168\":1,\"171\":1,\"172\":1,\"173\":2,\"176\":1,\"182\":1,\"186\":1,\"191\":1,\"194\":1,\"197\":4,\"211\":1,\"212\":16,\"213\":7,\"216\":1,\"219\":1,\"223\":2,\"225\":1,\"226\":7,\"227\":11,\"228\":2,\"229\":1,\"230\":1,\"232\":1,\"233\":4,\"329\":1,\"334\":1,\"417\":1,\"419\":1}}],[\"的信息\",{\"1\":{\"79\":1}}],[\"的布局文件中添加一个\",{\"1\":{\"79\":2}}],[\"的基本使用\",{\"1\":{\"88\":1}}],[\"的基本信息如最小高度\",{\"1\":{\"79\":1}}],[\"的基本上会立即\",{\"1\":{\"5\":1}}],[\"的用法做了一些简单的整理\",{\"1\":{\"79\":1}}],[\"的值时自动切换到第二个并回调\",{\"1\":{\"159\":1}}],[\"的值超过第一个\",{\"1\":{\"159\":1}}],[\"的值并计算设置\",{\"1\":{\"156\":1}}],[\"的值并刷新\",{\"1\":{\"146\":1,\"157\":1}}],[\"的值变化\",{\"1\":{\"155\":1}}],[\"的值\",{\"1\":{\"65\":1,\"176\":1,\"226\":1,\"229\":1}}],[\"的坐标满足\",{\"1\":{\"62\":1}}],[\"的学习笔记整理\",{\"1\":{\"60\":1}}],[\"的实现比较简单\",{\"1\":{\"233\":1}}],[\"的实现做了简单分析\",{\"1\":{\"227\":1}}],[\"的实现\",{\"1\":{\"205\":1,\"213\":1,\"329\":1,\"364\":1,\"379\":1}}],[\"的实现也比较简单\",{\"1\":{\"156\":1}}],[\"的实现和用法进行简单分析\",{\"1\":{\"146\":1}}],[\"的实现类\",{\"1\":{\"111\":1}}],[\"的实现方法\",{\"1\":{\"58\":1}}],[\"的实例\",{\"1\":{\"55\":1}}],[\"的结果输入到less中\",{\"1\":{\"58\":1}}],[\"的部分方法\",{\"1\":{\"57\":1}}],[\"的专栏\",{\"1\":{\"55\":2}}],[\"的注解\",{\"1\":{\"55\":1}}],[\"的活动联结起来\",{\"1\":{\"55\":1}}],[\"的行为和另一个子view\",{\"1\":{\"55\":1}}],[\"的产品\",{\"1\":{\"54\":1}}],[\"的使用及实现原理\",{\"1\":{\"52\":1,\"287\":2}}],[\"的时候一直提示有问题\",{\"1\":{\"418\":1}}],[\"的时候不需要else\",{\"1\":{\"322\":1}}],[\"的时候才会被\",{\"1\":{\"226\":1}}],[\"的时候将从\",{\"1\":{\"194\":1}}],[\"的时候就会触发动画从\",{\"1\":{\"153\":1}}],[\"的时候调用的是child\",{\"1\":{\"128\":1}}],[\"的时候创建\",{\"1\":{\"124\":1}}],[\"的时候都会增加一个唯一的\",{\"1\":{\"79\":1}}],[\"的时候\",{\"1\":{\"44\":1,\"109\":1,\"147\":1,\"170\":1,\"197\":1,\"212\":1,\"225\":1,\"233\":1,\"287\":1,\"383\":1}}],[\"的具体值并执行\",{\"1\":{\"41\":1}}],[\"的流程创建\",{\"1\":{\"225\":1}}],[\"的流程\",{\"1\":{\"40\":1}}],[\"的整型\",{\"1\":{\"21\":1}}],[\"的私有进程中进行\",{\"1\":{\"17\":1}}],[\"的应用\",{\"1\":{\"14\":1}}],[\"的条件\",{\"1\":{\"12\":1}}],[\"的资料\",{\"1\":{\"0\":1}}],[\"拿来主义\",{\"1\":{\"0\":1}}],[\"白白耽搁了一晚上的时间\",{\"1\":{\"0\":1}}],[\"其元素先进先出\",{\"1\":{\"452\":1}}],[\"其元素先进后出\",{\"1\":{\"452\":1}}],[\"其思路是\",{\"1\":{\"459\":1}}],[\"其思路主要是获取到对应的classloader\",{\"1\":{\"420\":1}}],[\"其思想是\",{\"1\":{\"451\":1,\"455\":1,\"456\":1}}],[\"其速度如下\",{\"1\":{\"445\":1}}],[\"其过程如下图所示\",{\"1\":{\"432\":1}}],[\"其访问节点的顺序如下\",{\"1\":{\"430\":1}}],[\"其所涉及内容可能已经发生较大变化\",{\"1\":{\"408\":1}}],[\"其所用的request对象来自于okhttprequest\",{\"1\":{\"365\":1}}],[\"其置顶文章每页都有\",{\"1\":{\"370\":1}}],[\"其craw\",{\"1\":{\"370\":1}}],[\"其child只支持可以生成renderbox的widget\",{\"1\":{\"242\":1}}],[\"其后可以包含aa\",{\"1\":{\"369\":1}}],[\"其之后的异常不会被处理\",{\"1\":{\"341\":1}}],[\"其它操作\",{\"1\":{\"322\":1}}],[\"其写操作因为要插入内存屏障\",{\"1\":{\"317\":1}}],[\"其大体过程与get\",{\"1\":{\"280\":1}}],[\"其先让child在主轴方向尽可能大的进行layout\",{\"1\":{\"239\":1}}],[\"其会创建\",{\"1\":{\"230\":1}}],[\"其创建了\",{\"1\":{\"226\":1}}],[\"其创建的\",{\"1\":{\"188\":1}}],[\"其范围是minscrollextent~double\",{\"1\":{\"220\":1}}],[\"其范围是\",{\"1\":{\"220\":1}}],[\"其范围是pixels\",{\"1\":{\"220\":2}}],[\"其范围\",{\"1\":{\"220\":1}}],[\"其值一般为retentionpolicy\",{\"1\":{\"298\":1}}],[\"其值一般为elementtype\",{\"1\":{\"298\":1}}],[\"其值都只会增大\",{\"1\":{\"220\":1}}],[\"其值等于\",{\"1\":{\"213\":1}}],[\"其逻辑比较简单\",{\"1\":{\"214\":1}}],[\"其在内部更新和维护\",{\"1\":{\"213\":1}}],[\"其只接受可以创建\",{\"1\":{\"213\":1}}],[\"其尺寸为所处的viewport的主轴尺寸\",{\"1\":{\"213\":1}}],[\"其最大滑动范围为内部滑动视图最大滑动范围之和\",{\"1\":{\"212\":1}}],[\"其最大滑动范围为\",{\"1\":{\"212\":1}}],[\"其底层逻辑依然是对\",{\"1\":{\"212\":1,\"227\":1}}],[\"其startloading方法会调用performloadimage方法\",{\"1\":{\"211\":2}}],[\"其整体架构如下\",{\"1\":{\"203\":1}}],[\"其子类则通过\",{\"1\":{\"233\":1}}],[\"其子类一般只需要重写imageprovider的imagestreamcompleter\",{\"1\":{\"196\":1}}],[\"其子类中一般会监听\",{\"1\":{\"156\":1}}],[\"其混入了widgetsbindingobserver以便监听系统生命周期\",{\"1\":{\"189\":1}}],[\"其提供\",{\"1\":{\"186\":1}}],[\"其主要由三部分组成\",{\"1\":{\"227\":1}}],[\"其主要逻辑都在创建的\",{\"1\":{\"213\":1}}],[\"其主要逻辑在\",{\"1\":{\"186\":1}}],[\"其主要的子类有\",{\"1\":{\"183\":1}}],[\"其主要作用是将rootwidget\",{\"1\":{\"120\":1}}],[\"其evaluate方法内部通过其唯一的抽象方法transform方法实现\",{\"1\":{\"183\":1}}],[\"其效果如图\",{\"1\":{\"172\":1}}],[\"其\",{\"1\":{\"166\":1,\"167\":1,\"182\":1}}],[\"其有三个子类\",{\"1\":{\"159\":1}}],[\"其接受一个\",{\"1\":{\"154\":1}}],[\"其同样也分为\",{\"1\":{\"154\":1}}],[\"其状态只和构造函数中的参数有关\",{\"1\":{\"133\":1}}],[\"其工程基本的结构如下\",{\"1\":{\"132\":1}}],[\"其继承关系\",{\"1\":{\"125\":1,\"126\":2}}],[\"其本身并不在屏幕上绘制肉眼可见的内容\",{\"1\":{\"124\":1}}],[\"其内部操作可以挂起\",{\"1\":{\"328\":1}}],[\"其内部处理了scrollcontroller\",{\"1\":{\"234\":1}}],[\"其内部处理了\",{\"1\":{\"212\":1,\"227\":1}}],[\"其内部持有一个双向的\",{\"1\":{\"231\":1}}],[\"其内部持有imagestreamcompleter\",{\"1\":{\"197\":1}}],[\"其内部持有我们的renderview作为rootnode\",{\"1\":{\"118\":1}}],[\"其内部维持有三个\",{\"1\":{\"197\":1}}],[\"其内部的\",{\"1\":{\"171\":1}}],[\"其内部主要是开启了\",{\"1\":{\"162\":1}}],[\"其内部有方法提供androidinjector\",{\"1\":{\"94\":1}}],[\"其内部先调用了getwindow\",{\"1\":{\"13\":1}}],[\"其基本的原理依旧是利用\",{\"1\":{\"94\":1}}],[\"其宽高等于specsize\",{\"1\":{\"65\":1}}],[\"其次这个binder的引用在所有client中都固定为0而无须通过其它手段获得\",{\"1\":{\"58\":1}}],[\"其实\",{\"1\":{\"378\":1}}],[\"其实已经被其他线程访问过了\",{\"1\":{\"319\":1}}],[\"其实上述方法也可分为这两个模式\",{\"1\":{\"294\":1}}],[\"其实在后面我们可以看到\",{\"1\":{\"280\":1}}],[\"其实是容纳\",{\"1\":{\"212\":1}}],[\"其实是他的\",{\"1\":{\"212\":1}}],[\"其实是通过dart中的\",{\"1\":{\"116\":1}}],[\"其实就是使用ui\",{\"1\":{\"194\":1}}],[\"其实通过上述的分析\",{\"1\":{\"125\":1}}],[\"其实严格来说\",{\"1\":{\"122\":1}}],[\"其实现都是依赖于\",{\"1\":{\"182\":1}}],[\"其实现如下\",{\"1\":{\"96\":1}}],[\"其实现类是phonewindow\",{\"1\":{\"13\":1}}],[\"其实只要掌握原理\",{\"1\":{\"94\":1}}],[\"其实也包括了各个图形的透明部分\",{\"1\":{\"57\":1}}],[\"其实际对应于android\",{\"1\":{\"55\":1}}],[\"其实我们也可以自己实现多渠道打包\",{\"1\":{\"54\":1}}],[\"其余数据仍然无序\",{\"1\":{\"442\":1}}],[\"其余是次要群组\",{\"1\":{\"353\":1}}],[\"其余操作\",{\"0\":{\"344\":1}}],[\"其余n\",{\"1\":{\"289\":1}}],[\"其余线程能够立即得知这个更改\",{\"1\":{\"317\":1}}],[\"其余线程中的threadlocal对象也会访问到obj的最新值\",{\"1\":{\"288\":1}}],[\"其余线程阻塞等待\",{\"1\":{\"279\":1}}],[\"其余不会触发初始化\",{\"1\":{\"279\":1}}],[\"其余时候只会触发重新paint\",{\"1\":{\"237\":1}}],[\"其余时候依靠\",{\"1\":{\"166\":1}}],[\"其余辅助类\",{\"1\":{\"212\":1}}],[\"其余的步骤和我们之前分析的官方\",{\"1\":{\"200\":1}}],[\"其余四种构造方法也都是在此方法的基础上分别指定了各自的\",{\"1\":{\"188\":1}}],[\"其余与父类componentelement\",{\"1\":{\"128\":1}}],[\"其余情况都比较简单\",{\"1\":{\"126\":1}}],[\"其余情况都需要拦截\",{\"1\":{\"13\":1}}],[\"其余为1\",{\"1\":{\"80\":1}}],[\"其余属性可选\",{\"1\":{\"55\":1}}],[\"其余内容基本上都完美还原了设计稿的内容\",{\"1\":{\"53\":1}}],[\"其坐标都是以父view的左上角顶点为原点\",{\"1\":{\"41\":1}}],[\"其点击事件分发用伪代码表示如下\",{\"1\":{\"13\":1}}],[\"其他流如果需要取消\",{\"1\":{\"342\":1}}],[\"其他环境\",{\"1\":{\"322\":2}}],[\"其他线程对齐进行了操作但是该数据最终没有被变化\",{\"1\":{\"319\":1}}],[\"其他线程对threadlocal对象的操作不会影响本线程\",{\"1\":{\"288\":1}}],[\"其他逻辑\",{\"1\":{\"288\":1}}],[\"其他两个场景都只有\",{\"1\":{\"226\":1}}],[\"其他类型\",{\"1\":{\"205\":1}}],[\"其他类可以调用imageprovider\",{\"1\":{\"196\":1}}],[\"其他类可以通过\",{\"1\":{\"158\":1}}],[\"其他属性\",{\"0\":{\"174\":1}}],[\"其他方法\",{\"0\":{\"164\":1},\"1\":{\"223\":1}}],[\"其他子类\",{\"0\":{\"159\":1}}],[\"其他地方可以使用\",{\"1\":{\"111\":1,\"112\":1}}],[\"其他event\",{\"1\":{\"109\":1}}],[\"其他用法的完全可以触类旁通\",{\"1\":{\"94\":1}}],[\"其他activity依然可以通过pendingintent执行intent\",{\"1\":{\"75\":1}}],[\"其他点的曲线坐标和对应的点坐标不一致\",{\"1\":{\"62\":1}}],[\"其他由zygote进程孵化的系统进程\",{\"1\":{\"60\":1}}],[\"其他进程也访问该资源\",{\"1\":{\"58\":1}}],[\"其他进行不可访问\",{\"1\":{\"17\":1}}],[\"其他部分要为透明\",{\"1\":{\"57\":1}}],[\"其他umeng要求的配置\",{\"1\":{\"54\":1}}],[\"其他代码\",{\"1\":{\"52\":4,\"297\":1}}],[\"其他回调方法\",{\"1\":{\"37\":1}}],[\"其他的参数必须标记方向\",{\"1\":{\"34\":1}}],[\"其他motionevent事件\",{\"1\":{\"13\":1}}],[\"其他没有发现的更是不知几多\",{\"1\":{\"0\":1}}],[\"其中一棵柱子上面有若干个半径依次递减的空心圆盘\",{\"1\":{\"459\":1}}],[\"其中有部分内容是参考网上的教程\",{\"1\":{\"419\":1}}],[\"其中有titleview和contentview\",{\"1\":{\"13\":1}}],[\"其中涉及到的第三方网站及其所有资源均属原主所有\",{\"1\":{\"370\":1}}],[\"其中typeerror需要继承自error或者exception\",{\"1\":{\"369\":1}}],[\"其中this\",{\"1\":{\"56\":1}}],[\"其中9~10行相当于okhttp步骤2创建网络请求\",{\"1\":{\"362\":1}}],[\"其中第一个是主要群组\",{\"1\":{\"353\":1}}],[\"其中userdel\",{\"1\":{\"353\":1}}],[\"其中需要注意的有\",{\"1\":{\"295\":1}}],[\"其中引用类型对象大小只计算为4\",{\"1\":{\"282\":1}}],[\"其中加载\",{\"1\":{\"273\":1}}],[\"其中的代码出错\",{\"1\":{\"145\":1}}],[\"其中defaultonerror\",{\"1\":{\"144\":1}}],[\"其中file\",{\"1\":{\"111\":1}}],[\"其中315为设计稿中的控件大小\",{\"1\":{\"81\":1}}],[\"其中375位设计稿屏幕宽度\",{\"1\":{\"81\":1}}],[\"其中较为完整的一篇如下\",{\"1\":{\"72\":1}}],[\"其中proxyintent通过proxyintent\",{\"1\":{\"72\":1}}],[\"其中通过viewrootimpl类的performtraversals\",{\"1\":{\"65\":1}}],[\"其中activitythreadhandlercallback\",{\"1\":{\"72\":1}}],[\"其中a\",{\"1\":{\"62\":1}}],[\"其中\",{\"1\":{\"53\":1,\"79\":1,\"81\":1,\"128\":1,\"172\":1,\"211\":3,\"225\":1,\"282\":1,\"302\":1,\"306\":1,\"322\":1,\"358\":1,\"428\":1}}],[\"其中执行顺序是\",{\"1\":{\"29\":1}}],[\"其中id参数代表唯一标识通知的整型数\",{\"1\":{\"21\":1}}],[\"其中onstartcommand\",{\"1\":{\"17\":1}}],[\"其中y是文字baseline的y坐标\",{\"1\":{\"15\":1}}],[\"其中com\",{\"1\":{\"2\":1}}],[\"其中不可避免有很多未经查实的资料\",{\"1\":{\"0\":1}}],[\"其危害不小\",{\"1\":{\"0\":1}}],[\"我选择的是将博客放在子目录\",{\"1\":{\"419\":1}}],[\"我\",{\"1\":{\"417\":1}}],[\"我使用的版本是\",{\"1\":{\"410\":1}}],[\"我使用到的resources\",{\"1\":{\"53\":1}}],[\"我就是使用后一种方法\",{\"1\":{\"409\":1}}],[\"我尝试过许多种工具\",{\"1\":{\"408\":1}}],[\"我的花园\",{\"1\":{\"399\":2}}],[\"我的第五个android应用\",{\"1\":{\"398\":1}}],[\"我的第四个android应用\",{\"1\":{\"398\":1}}],[\"我的第三个android应用\",{\"1\":{\"398\":1}}],[\"我的邮箱是\",{\"1\":{\"0\":1}}],[\"我们还可以通过自定义binding\",{\"1\":{\"401\":1}}],[\"我们还可以注意到\",{\"1\":{\"190\":1}}],[\"我们拿到的isolate主要是持有一个和native中对应sendport\",{\"1\":{\"378\":1}}],[\"我们先来看第一部分\",{\"1\":{\"363\":1}}],[\"我们先看一下他是如何实现layout的\",{\"1\":{\"238\":1}}],[\"我们先看一下几个属性的创建过程\",{\"1\":{\"106\":1}}],[\"我们写个简单的demo验证一下\",{\"1\":{\"309\":1}}],[\"我们写的内容也能正常显示到屏幕上\",{\"1\":{\"122\":1}}],[\"我们得知\",{\"1\":{\"209\":1}}],[\"我们通过networkimage\",{\"1\":{\"196\":1}}],[\"我们通过得到的这个mserviceinterface可以在客户端调用服务所实现的方法\",{\"1\":{\"58\":1}}],[\"我们大体梳理了图片展示的这部分流程\",{\"1\":{\"195\":1}}],[\"我们以下面这个二叉树为例\",{\"1\":{\"346\":1}}],[\"我们以\",{\"1\":{\"186\":1}}],[\"我们分析了\",{\"1\":{\"182\":1,\"211\":1}}],[\"我们主要关注3点\",{\"1\":{\"389\":1}}],[\"我们主要关注两件事\",{\"1\":{\"118\":1}}],[\"我们主要将\",{\"1\":{\"172\":1}}],[\"我们在看一下保存的部分\",{\"1\":{\"309\":1}}],[\"我们在之前的\",{\"1\":{\"172\":1}}],[\"我们在widget\",{\"1\":{\"125\":1}}],[\"我们首先来看一下\",{\"1\":{\"158\":1}}],[\"我们简单分析一下\",{\"1\":{\"147\":1}}],[\"我们将\",{\"1\":{\"146\":1}}],[\"我们看一下multichildrenderobjectwidget\",{\"1\":{\"127\":1}}],[\"我们看到threadlocal出现内存泄漏条件还是很苛刻的\",{\"1\":{\"288\":1}}],[\"我们看到\",{\"1\":{\"43\":1,\"165\":1,\"302\":1}}],[\"我们应该已经知道\",{\"1\":{\"125\":1}}],[\"我们接下来主要关注一下几个属性\",{\"1\":{\"122\":1}}],[\"我们再看看2019\",{\"1\":{\"302\":1}}],[\"我们再看一下每个枚举类的值\",{\"1\":{\"285\":1}}],[\"我们再看一下timer的实现\",{\"1\":{\"104\":1}}],[\"我们再\",{\"1\":{\"170\":1}}],[\"我们再来看一下刚刚提到的几个类\",{\"1\":{\"122\":1}}],[\"我们再来看一下renderobjecttowidgetelement调用的父类renderobjectelement\",{\"1\":{\"121\":1}}],[\"我们关注和屏幕渲染有关的rendererbinding\",{\"1\":{\"118\":1}}],[\"我们关注initinstances\",{\"1\":{\"118\":1}}],[\"我们的操作已经结束了\",{\"1\":{\"328\":1}}],[\"我们的singlechildscrollview顺利得到了尺寸\",{\"1\":{\"239\":1}}],[\"我们的所有widget在element的组织下\",{\"1\":{\"127\":1}}],[\"我们的widget\",{\"1\":{\"126\":1}}],[\"我们的\",{\"1\":{\"117\":1,\"152\":1,\"213\":1}}],[\"我们的application无需改动\",{\"1\":{\"14\":1}}],[\"我们选择android端的实现\",{\"1\":{\"115\":1}}],[\"我们注意到在scrollable\",{\"1\":{\"235\":1}}],[\"我们注意到其中使用了\",{\"1\":{\"211\":1}}],[\"我们注意到给只给richtext\",{\"1\":{\"127\":1}}],[\"我们注意到\",{\"1\":{\"115\":1,\"197\":1,\"389\":1}}],[\"我们已经知道\",{\"1\":{\"112\":1}}],[\"我们依次看一下上述几个方法的具体实现\",{\"1\":{\"102\":1}}],[\"我们也可以监听\",{\"1\":{\"172\":1}}],[\"我们也可以自定义基于\",{\"1\":{\"86\":1}}],[\"我们也看到了statelesswidget本身并没有创建renderobject的方法\",{\"1\":{\"126\":1}}],[\"我们也还可以看到\",{\"1\":{\"101\":1}}],[\"我们能确定的是\",{\"1\":{\"100\":1}}],[\"我们发现虽然这dagger\",{\"1\":{\"94\":1}}],[\"我们需要在对应的activity或fragment中\",{\"1\":{\"401\":1}}],[\"我们需要在path计算完成后\",{\"1\":{\"63\":1}}],[\"我们需要有的类只能有一个实例\",{\"1\":{\"87\":1}}],[\"我们需要分别这两个构造方法\",{\"1\":{\"85\":1}}],[\"我们使用的绝大多数类肯定不止一个构造方法\",{\"1\":{\"85\":1}}],[\"我们要引入另外两个主角\",{\"1\":{\"85\":1}}],[\"我们要绘制的图形\",{\"1\":{\"57\":1}}],[\"我们只要在xml中为组件加上这个属性就可以实现相应的效果\",{\"1\":{\"401\":1}}],[\"我们只要计算出center到baseline之间的偏移量\",{\"1\":{\"15\":1}}],[\"我们只关注vm下面的实现\",{\"1\":{\"383\":1}}],[\"我们只看和app相关的实现\",{\"1\":{\"111\":1}}],[\"我们只需要在需要使用依赖注入的类中使用诸如androidinjection\",{\"1\":{\"94\":1}}],[\"我们只需要在activity中添加如下代码就可以实现自动注入\",{\"1\":{\"93\":1}}],[\"我们只需要使用\",{\"1\":{\"84\":1}}],[\"我们只需要统一去修改magicfun\",{\"1\":{\"82\":1}}],[\"我们知道此时的specsize是父容器目前可以用的大小\",{\"1\":{\"65\":1}}],[\"我们知道\",{\"1\":{\"65\":1}}],[\"我们知道跨进程的两个listener是两个不同的对象\",{\"1\":{\"36\":1}}],[\"我们指定的view的layoutparams和父容器\",{\"1\":{\"65\":1}}],[\"我们人为的在两个点之间加入两个控制点\",{\"1\":{\"63\":1}}],[\"我们获取的数据可以当做贝塞尔曲线的端点\",{\"1\":{\"61\":1}}],[\"我们会调用objectoutputstream的writeobject方法\",{\"1\":{\"309\":1}}],[\"我们会发现mibinder的对象会在activitythread中的private\",{\"1\":{\"58\":1}}],[\"我们会先创建一个mibinder对象并且在public\",{\"1\":{\"58\":1}}],[\"我们可以处理这两者之间的关系\",{\"1\":{\"402\":1}}],[\"我们可以\",{\"1\":{\"327\":1}}],[\"我们可以将网络请求简化如下\",{\"1\":{\"322\":1}}],[\"我们可以通过修改minimaldaysinfirstweek和firstdayofweek来更改yyyy格式化的值\",{\"1\":{\"302\":1}}],[\"我们可以计算enumclazz\",{\"1\":{\"285\":1}}],[\"我们可以得出以下结论\",{\"1\":{\"239\":1}}],[\"我们可以得知\",{\"1\":{\"122\":1}}],[\"我们可以验证之前的判断\",{\"1\":{\"227\":1}}],[\"我们可以从下面的代码中得到证实\",{\"1\":{\"131\":1}}],[\"我们可以从event得到两种值\",{\"1\":{\"41\":1}}],[\"我们可以看到\",{\"1\":{\"121\":1,\"195\":1,\"302\":1}}],[\"我们可以看到使用handler创建一个messenger\",{\"1\":{\"43\":1}}],[\"我们可以知道\",{\"1\":{\"116\":1,\"186\":1}}],[\"我们可以在其中定义一些变量<variable\",{\"1\":{\"401\":1}}],[\"我们可以在其内部实例化并返回service类\",{\"1\":{\"85\":1}}],[\"我们可以在编译器的可视化界面中\",{\"1\":{\"400\":1}}],[\"我们可以在源码中看到原因\",{\"1\":{\"309\":1}}],[\"我们可以在过渡页面将activity切换动画设置为渐变效果\",{\"1\":{\"14\":1}}],[\"我们可以推导出\",{\"1\":{\"81\":1}}],[\"我们可以先计算path的总长度\",{\"1\":{\"63\":1}}],[\"我们可以使用paint\",{\"1\":{\"63\":1}}],[\"我们可以直接使用messenger\",{\"1\":{\"43\":1}}],[\"我们可以选择重新连接服务\",{\"1\":{\"38\":1}}],[\"我们没法直接获取到baseline的坐标\",{\"1\":{\"15\":1}}],[\"我们完全可以将其当做主进程的第一个activity\",{\"1\":{\"14\":1}}],[\"我自己也写过不少这样欠缺思考\",{\"1\":{\"0\":1}}],[\"我会把平时学习的心得体会\",{\"1\":{\"0\":1,\"398\":1}}],[\"累积\",{\"1\":{\"0\":1}}],[\"l1371\",{\"1\":{\"388\":1}}],[\"lwm\",{\"1\":{\"361\":1}}],[\"l展示目录下的文件列表\",{\"1\":{\"350\":1}}],[\"lru\",{\"1\":{\"197\":1,\"202\":1}}],[\"llc\",{\"1\":{\"401\":1}}],[\"ll\",{\"1\":{\"179\":1}}],[\"ltr\",{\"1\":{\"117\":3,\"228\":1}}],[\"l\",{\"1\":{\"58\":4,\"350\":1,\"361\":1}}],[\"ls\",{\"0\":{\"350\":1},\"1\":{\"58\":1,\"350\":2,\"361\":1}}],[\"laforce\",{\"1\":{\"451\":1}}],[\"lafore\",{\"1\":{\"444\":1}}],[\"landscape\",{\"1\":{\"415\":1}}],[\"language\",{\"1\":{\"32\":1,\"395\":2,\"417\":1}}],[\"languages\",{\"1\":{\"0\":1}}],[\"lang\",{\"1\":{\"14\":3,\"40\":3,\"58\":3,\"111\":2,\"115\":1,\"272\":1,\"274\":1,\"279\":2,\"282\":1,\"285\":3,\"295\":1,\"372\":1,\"397\":1,\"438\":1}}],[\"lazy\",{\"1\":{\"394\":1,\"396\":1}}],[\"lazy方式创建一个序列\",{\"1\":{\"327\":1}}],[\"launchin\",{\"1\":{\"337\":1}}],[\"launch\",{\"1\":{\"322\":1,\"324\":1,\"325\":3,\"327\":1,\"329\":1,\"417\":1}}],[\"launches\",{\"1\":{\"328\":1}}],[\"launched\",{\"1\":{\"115\":2}}],[\"launcher$appclassloader\",{\"1\":{\"272\":1}}],[\"launcher\",{\"1\":{\"60\":1}}],[\"lambda在java8中引进\",{\"1\":{\"345\":1}}],[\"lambda表达式10个示例\",{\"1\":{\"345\":1}}],[\"lambda表达式形式如下\",{\"1\":{\"345\":1}}],[\"lambda表达式的方法\",{\"1\":{\"345\":1}}],[\"lambda表达式在kotlin中的应用\",{\"0\":{\"345\":1}}],[\"lambda写法\",{\"1\":{\"345\":1}}],[\"lambda2\",{\"1\":{\"322\":2}}],[\"lambda1\",{\"1\":{\"322\":2}}],[\"lambda\",{\"1\":{\"281\":1,\"345\":4}}],[\"lag\",{\"1\":{\"216\":1}}],[\"laid\",{\"1\":{\"179\":1,\"180\":1}}],[\"laizuling\",{\"1\":{\"63\":1}}],[\"large\",{\"1\":{\"131\":1,\"396\":1}}],[\"lastaxisdirection\",{\"1\":{\"223\":1}}],[\"lastaccessed\",{\"1\":{\"115\":1}}],[\"lastcandrag\",{\"1\":{\"223\":1}}],[\"lastcallback\",{\"1\":{\"97\":6,\"98\":1}}],[\"lasthasscrolledbody\",{\"1\":{\"213\":2}}],[\"laststack\",{\"1\":{\"191\":1,\"192\":1,\"193\":1}}],[\"lastexception\",{\"1\":{\"191\":1,\"192\":1,\"193\":3}}],[\"lastelapsedduration\",{\"1\":{\"162\":1,\"163\":1}}],[\"lastmodified\",{\"1\":{\"115\":1}}],[\"lasttimems\",{\"1\":{\"110\":4,\"111\":1}}],[\"last\",{\"1\":{\"109\":1,\"111\":1,\"112\":1,\"209\":1,\"302\":2,\"391\":2}}],[\"lastzerotimer中\",{\"1\":{\"106\":1}}],[\"lastzerotimer\",{\"1\":{\"106\":4}}],[\"lastprioritycallback\",{\"1\":{\"98\":2}}],[\"lastindex\",{\"1\":{\"63\":1}}],[\"layer\",{\"1\":{\"57\":1,\"119\":1,\"239\":3}}],[\"layoutmanager=\",{\"1\":{\"401\":1}}],[\"layout>\",{\"1\":{\"401\":2}}],[\"layout=\",{\"1\":{\"400\":1}}],[\"layoutbuilder\",{\"1\":{\"241\":2,\"242\":1}}],[\"layoutinflater\",{\"1\":{\"56\":1}}],[\"layoutparam\",{\"1\":{\"55\":1}}],[\"layoutparams\",{\"1\":{\"41\":6,\"64\":1}}],[\"layoutdependson\",{\"1\":{\"55\":3}}],[\"layout\",{\"0\":{\"74\":1,\"238\":1},\"1\":{\"55\":7,\"56\":8,\"65\":2,\"66\":6,\"71\":1,\"74\":2,\"79\":14,\"93\":1,\"213\":1,\"229\":1,\"238\":2,\"400\":3,\"401\":6}}],[\"late\",{\"1\":{\"102\":2,\"103\":1,\"111\":2,\"112\":1,\"130\":2,\"147\":2,\"177\":2,\"178\":1,\"216\":1,\"224\":2,\"278\":1}}],[\"later\",{\"1\":{\"75\":1,\"103\":1,\"109\":1,\"209\":1,\"383\":1}}],[\"latest\",{\"1\":{\"54\":2,\"327\":1}}],[\"lateinit\",{\"1\":{\"43\":1,\"82\":1,\"83\":1,\"86\":1,\"92\":1,\"93\":1,\"467\":1}}],[\"label=\",{\"1\":{\"54\":1,\"400\":1}}],[\"label\",{\"1\":{\"54\":1,\"193\":1}}],[\"lee0oo0\",{\"1\":{\"427\":1}}],[\"leetcode\",{\"1\":{\"346\":1}}],[\"leetcode笔记\",{\"0\":{\"346\":1}}],[\"lerp\",{\"1\":{\"184\":8}}],[\"lerpdouble\",{\"1\":{\"167\":2}}],[\"lets\",{\"1\":{\"389\":1}}],[\"let\",{\"1\":{\"108\":1}}],[\"letter\",{\"1\":{\"64\":1,\"302\":1}}],[\"letterindex\",{\"1\":{\"64\":2}}],[\"less\",{\"1\":{\"58\":1,\"220\":1,\"278\":1,\"349\":1}}],[\"left指针向右移动查找比c大的值\",{\"1\":{\"464\":1}}],[\"leftindex\",{\"1\":{\"441\":9,\"467\":6}}],[\"leftpreorder\",{\"1\":{\"346\":2}}],[\"lefttree\",{\"1\":{\"346\":3}}],[\"leftover\",{\"1\":{\"226\":1}}],[\"left\",{\"1\":{\"41\":3,\"56\":1,\"64\":1,\"108\":1,\"181\":2,\"228\":1,\"239\":1,\"346\":2,\"429\":1,\"430\":1,\"432\":17,\"464\":1,\"467\":6}}],[\"leafrenderobjectwidget\",{\"1\":{\"198\":1}}],[\"leafrenderwidget\",{\"1\":{\"194\":1}}],[\"least\",{\"1\":{\"198\":1,\"242\":1,\"302\":1}}],[\"leak\",{\"1\":{\"36\":1,\"198\":1,\"256\":1}}],[\"leading\",{\"1\":{\"15\":1}}],[\"length表明了该类型存储数据的长度\",{\"1\":{\"283\":1}}],[\"length取余数\",{\"1\":{\"280\":1}}],[\"length限定为2的n次方\",{\"1\":{\"280\":1}}],[\"lengthfrompath\",{\"1\":{\"115\":1}}],[\"length\",{\"1\":{\"45\":1,\"52\":4,\"56\":1,\"63\":1,\"64\":4,\"72\":1,\"78\":1,\"79\":1,\"109\":4,\"110\":1,\"111\":11,\"112\":4,\"115\":2,\"127\":2,\"211\":3,\"212\":2,\"226\":1,\"280\":5,\"283\":2,\"289\":11,\"296\":5,\"378\":1}}],[\"len\",{\"1\":{\"36\":2,\"272\":3,\"391\":3}}],[\"leveraging\",{\"1\":{\"3\":1}}],[\"level\",{\"1\":{\"3\":2,\"378\":1,\"383\":1,\"396\":1}}],[\"lose\",{\"1\":{\"391\":1}}],[\"lo\",{\"1\":{\"306\":1,\"309\":1}}],[\"lowlevelcleanup\",{\"1\":{\"383\":1}}],[\"low\",{\"1\":{\"296\":2,\"383\":1,\"396\":1}}],[\"lowerbound\",{\"1\":{\"161\":3,\"162\":1,\"163\":1,\"168\":1}}],[\"lower\",{\"1\":{\"3\":1}}],[\"loadplatform\",{\"1\":{\"387\":1}}],[\"loadfactor\",{\"1\":{\"280\":4,\"287\":1}}],[\"loadclass\",{\"1\":{\"272\":3,\"424\":1,\"427\":1}}],[\"loadcache尝试从本地文件中读取缓存\",{\"1\":{\"201\":1}}],[\"loadcache\",{\"1\":{\"201\":2}}],[\"loadcache优先从缓存中读取\",{\"1\":{\"201\":1}}],[\"loadimage向\",{\"1\":{\"211\":1}}],[\"loadimage\",{\"1\":{\"209\":1,\"211\":2}}],[\"loading\",{\"0\":{\"274\":1},\"1\":{\"274\":1,\"279\":1,\"382\":2,\"396\":1}}],[\"loadingprogress\",{\"1\":{\"192\":1,\"193\":1}}],[\"loadingbuilder\",{\"1\":{\"191\":1,\"193\":2}}],[\"loadnetwork\",{\"1\":{\"201\":3}}],[\"loaded\",{\"1\":{\"196\":1,\"198\":1,\"276\":1,\"295\":1,\"383\":1,\"394\":2}}],[\"loader启动swapper\",{\"1\":{\"60\":1}}],[\"loader层\",{\"1\":{\"60\":1}}],[\"loader\",{\"1\":{\"60\":2,\"198\":3,\"211\":2,\"272\":2,\"273\":1,\"382\":4}}],[\"loadasync方法时\",{\"1\":{\"211\":1}}],[\"loadasync方法\",{\"1\":{\"208\":1,\"209\":1}}],[\"loadasync方法加载图片\",{\"1\":{\"201\":1}}],[\"loadasync\",{\"0\":{\"209\":1},\"1\":{\"196\":4,\"201\":2,\"209\":1,\"211\":3}}],[\"load方法获取图片\",{\"1\":{\"196\":1}}],[\"load方法获取并缓存到\",{\"1\":{\"196\":1}}],[\"load\",{\"1\":{\"196\":2,\"201\":3,\"202\":2,\"211\":1,\"280\":1,\"317\":1,\"387\":1}}],[\"loaddata\",{\"1\":{\"136\":1}}],[\"loadurl\",{\"1\":{\"42\":1}}],[\"loose\",{\"1\":{\"131\":3}}],[\"lookuplocalfunction\",{\"1\":{\"389\":1}}],[\"lookupexception\",{\"1\":{\"305\":1}}],[\"lookup\",{\"1\":{\"115\":1,\"309\":2}}],[\"look\",{\"1\":{\"49\":1}}],[\"loop一步步将事件上报\",{\"1\":{\"116\":1}}],[\"loop列表为空\",{\"1\":{\"101\":1}}],[\"loop执行完毕之后\",{\"1\":{\"101\":1}}],[\"loop中的microtask\",{\"1\":{\"101\":1}}],[\"loop中的micro\",{\"1\":{\"101\":1}}],[\"loop中没有micro\",{\"1\":{\"95\":1,\"101\":1}}],[\"loop的实现\",{\"1\":{\"95\":1}}],[\"loop取出事件并执行\",{\"1\":{\"95\":1}}],[\"loop\",{\"0\":{\"25\":1,\"95\":1},\"1\":{\"25\":2,\"29\":1,\"31\":1,\"95\":3,\"98\":4,\"100\":1,\"101\":1,\"109\":1,\"136\":1,\"180\":1,\"372\":1,\"375\":1,\"389\":1,\"391\":3}}],[\"looper在\",{\"1\":{\"31\":1}}],[\"looper\",{\"0\":{\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1},\"1\":{\"22\":1,\"24\":4,\"25\":2,\"26\":1,\"28\":1,\"80\":9}}],[\"location\",{\"1\":{\"125\":4,\"170\":1,\"278\":1}}],[\"localhost\",{\"1\":{\"414\":2}}],[\"localizations\",{\"1\":{\"127\":1}}],[\"locale\",{\"1\":{\"117\":1,\"125\":1,\"127\":2}}],[\"local\",{\"1\":{\"40\":1,\"58\":1,\"249\":1,\"281\":2,\"298\":1,\"325\":1,\"349\":1}}],[\"localbinder\",{\"1\":{\"19\":5}}],[\"localservice\",{\"1\":{\"19\":7}}],[\"lockstate\",{\"1\":{\"121\":1}}],[\"lock\",{\"1\":{\"108\":1,\"115\":6,\"383\":3}}],[\"locked\",{\"1\":{\"41\":1}}],[\"log2​n\",{\"1\":{\"458\":1}}],[\"logn\",{\"1\":{\"439\":2,\"442\":2,\"451\":1,\"459\":1,\"460\":1}}],[\"logo\",{\"1\":{\"398\":1}}],[\"logout\",{\"1\":{\"361\":1}}],[\"login\",{\"1\":{\"361\":1}}],[\"logic\",{\"1\":{\"220\":1}}],[\"logd\",{\"1\":{\"81\":4}}],[\"logexcessivecallbacks\",{\"1\":{\"36\":1}}],[\"log\",{\"1\":{\"17\":5,\"35\":1,\"36\":3,\"37\":2,\"48\":1,\"69\":1,\"93\":1,\"327\":1}}],[\"longstring\",{\"1\":{\"305\":1}}],[\"longsparselongarray\",{\"1\":{\"287\":1}}],[\"longsparsearray\",{\"1\":{\"287\":1}}],[\"long>\",{\"1\":{\"287\":2}}],[\"longcatislooong\",{\"1\":{\"180\":1}}],[\"longer\",{\"1\":{\"180\":2,\"389\":1,\"391\":1}}],[\"long\",{\"1\":{\"3\":3,\"13\":3,\"30\":1,\"115\":1,\"272\":2,\"282\":1,\"297\":5,\"299\":1,\"304\":1,\"308\":1,\"311\":1}}],[\"love\",{\"1\":{\"0\":1}}],[\"liaohuqiu\",{\"1\":{\"286\":1}}],[\"liangxanhai\",{\"1\":{\"115\":1}}],[\"lifo\",{\"1\":{\"251\":1}}],[\"lifetime\",{\"1\":{\"115\":1}}],[\"lifecyclestate\",{\"1\":{\"117\":1,\"121\":1,\"122\":2,\"126\":1}}],[\"lifecycle\",{\"1\":{\"59\":1,\"402\":1}}],[\"life\",{\"1\":{\"3\":1}}],[\"lightweight\",{\"1\":{\"381\":1}}],[\"lightgreen\",{\"1\":{\"131\":1}}],[\"lighten\",{\"1\":{\"57\":1}}],[\"limited\",{\"1\":{\"322\":1}}],[\"limit\",{\"1\":{\"112\":1,\"115\":1}}],[\"likely\",{\"1\":{\"278\":1}}],[\"like\",{\"1\":{\"105\":1,\"133\":1,\"136\":1,\"370\":1,\"396\":2}}],[\"libraries\",{\"1\":{\"387\":1,\"392\":1}}],[\"library\",{\"1\":{\"61\":2,\"105\":1,\"143\":1,\"202\":1,\"376\":1,\"378\":2,\"382\":1,\"383\":2,\"384\":3,\"389\":2}}],[\"library中\",{\"1\":{\"32\":1,\"201\":1}}],[\"lib下的rt\",{\"1\":{\"272\":1}}],[\"lib\",{\"1\":{\"96\":3,\"97\":1,\"98\":2,\"99\":2,\"100\":6,\"101\":2,\"102\":1,\"103\":2,\"104\":1,\"105\":9,\"106\":4,\"107\":2,\"108\":4,\"109\":4,\"111\":9,\"112\":4,\"115\":2,\"117\":1,\"118\":3,\"119\":1,\"120\":1,\"121\":3,\"122\":3,\"125\":2,\"126\":4,\"127\":6,\"132\":2,\"172\":1,\"195\":1,\"272\":1,\"349\":3,\"372\":3,\"373\":1,\"376\":4,\"377\":9,\"378\":5,\"379\":1,\"380\":1,\"381\":1,\"384\":3,\"389\":4}}],[\"liveimage都继承自\",{\"1\":{\"197\":1}}],[\"liveimages并返回\",{\"1\":{\"198\":1}}],[\"liveimages中追踪\",{\"1\":{\"198\":1}}],[\"liveimages中都没有\",{\"1\":{\"198\":1}}],[\"liveimages中已经有了\",{\"1\":{\"198\":1}}],[\"liveimages中\",{\"1\":{\"197\":1,\"198\":1}}],[\"liveimages\",{\"1\":{\"197\":1,\"198\":3}}],[\"liveimage>\",{\"1\":{\"197\":1}}],[\"liveimage\",{\"1\":{\"197\":2,\"198\":7}}],[\"livedata\",{\"1\":{\"78\":1,\"401\":1}}],[\"livedata的子类mediatorlivedata可以添加多个监听项\",{\"1\":{\"78\":1}}],[\"livedata<string>\",{\"1\":{\"78\":1}}],[\"livedata可以在数据有变化的时候调用订阅者并执行指定方法\",{\"1\":{\"78\":1}}],[\"live\",{\"1\":{\"78\":3,\"197\":2,\"198\":3,\"372\":1,\"383\":1,\"389\":1,\"391\":1}}],[\"linking\",{\"0\":{\"275\":1},\"1\":{\"275\":3,\"278\":2,\"279\":1}}],[\"linked\",{\"1\":{\"212\":1}}],[\"linktarget\",{\"1\":{\"115\":1}}],[\"linktodeath\",{\"1\":{\"36\":1}}],[\"link\",{\"1\":{\"80\":1,\"92\":2}}],[\"linux创建新项目时默认的权限分别是\",{\"1\":{\"352\":1}}],[\"linux文件和目录名字除了\",{\"1\":{\"349\":1}}],[\"linux常用命令\",{\"0\":{\"349\":1}}],[\"linuxidc\",{\"1\":{\"347\":1}}],[\"linux社区\",{\"1\":{\"347\":1}}],[\"linux下配置jdk和androidstudio开发环境\",{\"0\":{\"348\":1}}],[\"linux下配置git\",{\"0\":{\"347\":1}}],[\"linux下git和github使用方法总结\",{\"1\":{\"347\":1}}],[\"linux内核\",{\"1\":{\"60\":1}}],[\"linux进程间通信之管道\",{\"1\":{\"58\":1}}],[\"linux通过将一个虚拟内存区域与一个硬盘上的文件关联起来\",{\"1\":{\"58\":1}}],[\"linux也将一组连续的虚拟页面\",{\"1\":{\"58\":1}}],[\"linux为每个进程维护了一个单独的虚拟地址空间\",{\"1\":{\"58\":1}}],[\"linux\",{\"1\":{\"58\":3,\"108\":1,\"347\":3,\"349\":1,\"366\":1,\"387\":2}}],[\"line\",{\"1\":{\"327\":1,\"378\":1}}],[\"lineto\",{\"1\":{\"63\":3}}],[\"linear\",{\"1\":{\"147\":1,\"161\":2,\"166\":1,\"184\":1,\"186\":3}}],[\"lineargradient\",{\"1\":{\"63\":1}}],[\"linearlayoutmanager\",{\"1\":{\"401\":1}}],[\"linearlayout\",{\"1\":{\"56\":1}}],[\"linearlayout>\",{\"1\":{\"56\":1,\"66\":1,\"79\":2,\"400\":1}}],[\"line2567\",{\"1\":{\"13\":1}}],[\"listindex++\",{\"1\":{\"462\":1}}],[\"listindex\",{\"1\":{\"462\":1}}],[\"listinterfaces\",{\"1\":{\"115\":1}}],[\"listitem=\",{\"1\":{\"401\":1}}],[\"listen\",{\"1\":{\"198\":1,\"211\":1,\"373\":2}}],[\"listenedonce\",{\"1\":{\"198\":2}}],[\"listener的方法\",{\"1\":{\"345\":1}}],[\"listenertask\",{\"1\":{\"198\":1}}],[\"listeners\",{\"1\":{\"103\":3,\"198\":1,\"383\":1}}],[\"listenerr\",{\"1\":{\"56\":2}}],[\"listenerl\",{\"1\":{\"56\":4}}],[\"listener\",{\"1\":{\"35\":8,\"56\":2,\"64\":2,\"103\":8,\"157\":1,\"159\":1,\"191\":1,\"197\":2,\"198\":4,\"209\":1,\"211\":1,\"345\":6}}],[\"listenable通常是\",{\"1\":{\"154\":1}}],[\"listenable\",{\"1\":{\"154\":6,\"155\":12,\"156\":5,\"158\":2}}],[\"listview\",{\"1\":{\"131\":1,\"212\":3,\"226\":1,\"227\":1,\"233\":1}}],[\"liststop\",{\"1\":{\"115\":1}}],[\"liststart\",{\"1\":{\"115\":1}}],[\"listnext\",{\"1\":{\"115\":1}}],[\"list根据解析到的参数执行对应的方法\",{\"1\":{\"115\":1}}],[\"list执行完毕后就会被赋值\",{\"1\":{\"115\":1}}],[\"list中\",{\"1\":{\"106\":1}}],[\"list>\",{\"1\":{\"66\":1}}],[\"list<object\",{\"1\":{\"376\":1}}],[\"list<book>\",{\"1\":{\"322\":1}}],[\"list<fruit>\",{\"1\":{\"291\":1}}],[\"list<clazz>\",{\"1\":{\"291\":1}}],[\"list<double>\",{\"1\":{\"226\":1}}],[\"list<widget>\",{\"0\":{\"233\":1},\"1\":{\"213\":1,\"227\":1,\"228\":1,\"233\":3}}],[\"list<map<string\",{\"1\":{\"211\":3}}],[\"list<powerimagerequest>\",{\"1\":{\"211\":2}}],[\"list<people>\",{\"1\":{\"35\":6,\"36\":3,\"37\":1}}],[\"list<int>\",{\"1\":{\"210\":1}}],[\"list<element>\",{\"1\":{\"127\":2}}],[\"list<sendport>\",{\"1\":{\"112\":2}}],[\"list<stringtags>\",{\"1\":{\"58\":1}}],[\"list<stringtag>\",{\"1\":{\"58\":2}}],[\"list<string>\",{\"1\":{\"58\":1,\"64\":1,\"373\":1,\"378\":3}}],[\"list<\",{\"1\":{\"109\":2,\"226\":1,\"292\":2,\"293\":2}}],[\"list<t>\",{\"1\":{\"102\":1}}],[\"list<t\",{\"1\":{\"102\":4}}],[\"list<resolveinfo>\",{\"1\":{\"2\":1}}],[\"list\",{\"1\":{\"33\":1,\"35\":1,\"36\":1,\"37\":1,\"66\":1,\"102\":3,\"106\":2,\"109\":1,\"111\":5,\"112\":2,\"115\":8,\"142\":2,\"198\":1,\"211\":16,\"212\":1,\"227\":1,\"233\":1,\"234\":1,\"369\":1,\"377\":2,\"378\":3,\"383\":2,\"391\":1,\"401\":2,\"462\":3}}],[\"mbp\",{\"1\":{\"358\":1}}],[\"mbackgroundcolor\",{\"1\":{\"65\":1}}],[\"mbackground\",{\"1\":{\"65\":4}}],[\"mbasecachesize\",{\"1\":{\"49\":1}}],[\"mbasecache\",{\"1\":{\"49\":1}}],[\"mnt\",{\"1\":{\"349\":1}}],[\"mname\",{\"1\":{\"295\":3}}],[\"mv\",{\"1\":{\"349\":1}}],[\"mv移动\",{\"1\":{\"349\":1}}],[\"mvalueanimator\",{\"1\":{\"63\":6}}],[\"mvalues\",{\"1\":{\"44\":1,\"45\":5,\"46\":2,\"47\":2,\"48\":1,\"287\":1}}],[\"m说明这次的提交\",{\"1\":{\"347\":1}}],[\"mworker和mfuture的关系前文已经描述了\",{\"1\":{\"80\":1}}],[\"mworker\",{\"1\":{\"80\":3}}],[\"mwidth\",{\"1\":{\"65\":7}}],[\"mwindow\",{\"1\":{\"13\":1}}],[\"much\",{\"1\":{\"396\":1}}],[\"mutator\",{\"1\":{\"391\":1}}],[\"mutablelivedata\",{\"1\":{\"78\":2}}],[\"mutablelivedata<string>\",{\"1\":{\"78\":2}}],[\"mutually\",{\"1\":{\"378\":1}}],[\"mutex不会阻塞线程\",{\"1\":{\"334\":1}}],[\"mutex\",{\"1\":{\"115\":5,\"334\":1}}],[\"mutexlocker\",{\"1\":{\"115\":3}}],[\"mustcallsuper\",{\"1\":{\"118\":1}}],[\"mustbedocumented\",{\"1\":{\"86\":1}}],[\"must\",{\"1\":{\"80\":1,\"102\":1,\"103\":1,\"115\":1,\"153\":1,\"156\":1,\"185\":1,\"221\":1,\"225\":1,\"281\":2,\"389\":1,\"391\":1,\"396\":2}}],[\"multiframe\",{\"1\":{\"209\":2}}],[\"multiframeimagestreamcompleter\",{\"1\":{\"196\":1,\"201\":1}}],[\"multi\",{\"1\":{\"198\":1}}],[\"multiple\",{\"1\":{\"198\":1,\"226\":1,\"322\":1,\"382\":1,\"391\":3,\"392\":1}}],[\"multiply\",{\"1\":{\"57\":1}}],[\"multichildrenderobjectwidget\",{\"1\":{\"127\":6,\"228\":3,\"230\":1}}],[\"multichildrenderobjectelement\",{\"1\":{\"126\":2,\"127\":2,\"228\":1,\"230\":3}}],[\"multidex深入学习\",{\"1\":{\"14\":1}}],[\"multidex初次启动app优化方案优雅的实现\",{\"1\":{\"14\":1}}],[\"multidexopt即执行multidex\",{\"1\":{\"14\":1}}],[\"multidexkeepproguard\",{\"1\":{\"14\":1}}],[\"multidexkeepfile\",{\"1\":{\"14\":1}}],[\"multidexapplication\",{\"1\":{\"14\":1}}],[\"multidex\",{\"1\":{\"14\":6}}],[\"multidexenabled\",{\"1\":{\"14\":1}}],[\"mf\",{\"1\":{\"282\":2}}],[\"mfuture\",{\"1\":{\"80\":4}}],[\"mforwardcolor\",{\"1\":{\"65\":1}}],[\"mfirsttouchtarget表示能处理点击事件的子view\",{\"1\":{\"13\":1}}],[\"mfirsttouchtarget\",{\"1\":{\"13\":6}}],[\"mhandler\",{\"1\":{\"72\":1,\"80\":2}}],[\"mhashes\",{\"1\":{\"49\":4,\"50\":1,\"52\":4}}],[\"mh\",{\"1\":{\"72\":4}}],[\"mheight\",{\"1\":{\"65\":3}}],[\"md\",{\"1\":{\"397\":1,\"417\":3}}],[\"md文件并打开\",{\"1\":{\"368\":1}}],[\"md5key\",{\"1\":{\"201\":5}}],[\"mdata\",{\"1\":{\"80\":2}}],[\"mdatas\",{\"1\":{\"64\":2}}],[\"mdecor\",{\"1\":{\"13\":1}}],[\"mminheight\",{\"1\":{\"65\":2}}],[\"mminwidth\",{\"1\":{\"65\":2}}],[\"mmeasurecache\",{\"1\":{\"65\":1}}],[\"mmessenger\",{\"1\":{\"43\":4}}],[\"mm\",{\"1\":{\"53\":1,\"302\":5}}],[\"mkdir\",{\"1\":{\"349\":1,\"370\":3,\"407\":1}}],[\"mkeys\",{\"1\":{\"44\":1,\"45\":6,\"46\":1,\"47\":1,\"48\":1,\"287\":2}}],[\"mkilled\",{\"1\":{\"36\":1}}],[\"mgr命令将自己注册成smgr时binder驱动会自动为它创建binder实体\",{\"1\":{\"58\":1}}],[\"mgroupflags\",{\"1\":{\"13\":2}}],[\"mgarbage被标记为true\",{\"1\":{\"48\":1}}],[\"mgarbage\",{\"1\":{\"44\":1,\"45\":1,\"47\":1,\"48\":1,\"287\":1}}],[\"mtask\",{\"1\":{\"80\":2}}],[\"mtasks\",{\"1\":{\"80\":3}}],[\"mtarget对象\",{\"1\":{\"43\":1}}],[\"mtarget\",{\"1\":{\"43\":3}}],[\"mtitleheight\",{\"1\":{\"64\":2}}],[\"mtypearray\",{\"1\":{\"64\":2}}],[\"mtwicebasecachesize\",{\"1\":{\"49\":1}}],[\"mtwicebasecache\",{\"1\":{\"49\":1}}],[\"mthread\",{\"1\":{\"24\":1}}],[\"mplatform\",{\"1\":{\"363\":1,\"365\":1}}],[\"mprogress\",{\"1\":{\"65\":1}}],[\"mprivateflags3\",{\"1\":{\"65\":1}}],[\"mprimaryactionmode\",{\"1\":{\"13\":2}}],[\"mparams\",{\"1\":{\"80\":2}}],[\"mpaint\",{\"1\":{\"64\":11}}],[\"mpathmeasure\",{\"1\":{\"63\":3}}],[\"mpeoplelist\",{\"1\":{\"36\":7}}],[\"mpeoplemanager\",{\"1\":{\"35\":3,\"37\":1}}],[\"m\",{\"1\":{\"30\":3,\"81\":7,\"302\":2,\"322\":6,\"327\":1,\"346\":1,\"361\":2,\"407\":1,\"433\":1}}],[\"mclasloader\",{\"1\":{\"272\":5}}],[\"mclicklistener\",{\"1\":{\"64\":1}}],[\"mcancelled\",{\"1\":{\"80\":1}}],[\"mcallbacks\",{\"1\":{\"36\":5}}],[\"mcallback\",{\"1\":{\"28\":1,\"29\":3,\"36\":5,\"72\":1}}],[\"mchooseid\",{\"1\":{\"64\":2}}],[\"mcolorchoosetext\",{\"1\":{\"64\":1}}],[\"mcolorchoosetextbg\",{\"1\":{\"64\":1}}],[\"mcolortext\",{\"1\":{\"64\":1}}],[\"mcolorindexbg\",{\"1\":{\"64\":1}}],[\"mcolorlettertext\",{\"1\":{\"64\":1}}],[\"mcollections\",{\"1\":{\"49\":1}}],[\"mcookie\",{\"1\":{\"36\":1}}],[\"mcontext\",{\"1\":{\"35\":2,\"64\":1,\"71\":2,\"72\":1}}],[\"mconnection\",{\"1\":{\"17\":3,\"20\":1,\"58\":2}}],[\"mls\",{\"1\":{\"391\":1}}],[\"ml\",{\"1\":{\"115\":12,\"383\":2,\"389\":3,\"390\":3,\"391\":21}}],[\"mlistener\",{\"1\":{\"35\":5}}],[\"mlistenerinfo\",{\"1\":{\"13\":2}}],[\"mlooper\",{\"1\":{\"28\":2}}],[\"mipmap\",{\"1\":{\"424\":1}}],[\"migrate\",{\"1\":{\"416\":1}}],[\"might\",{\"1\":{\"25\":1,\"179\":1,\"180\":1,\"198\":1,\"220\":1}}],[\"millis\",{\"1\":{\"297\":5}}],[\"millisecond\",{\"1\":{\"105\":1,\"302\":1}}],[\"millisecondssinceepoch\",{\"1\":{\"110\":1}}],[\"milliseconds是否等于0\",{\"1\":{\"109\":1}}],[\"milliseconds为0的情况\",{\"1\":{\"107\":1}}],[\"milliseconds为0\",{\"1\":{\"106\":1}}],[\"milliseconds\",{\"0\":{\"107\":1,\"108\":1},\"1\":{\"105\":23,\"106\":1,\"108\":1,\"109\":4,\"362\":2}}],[\"miss\",{\"1\":{\"383\":1,\"391\":1}}],[\"missedticks\",{\"1\":{\"109\":3}}],[\"misc\",{\"1\":{\"272\":4}}],[\"mixin\",{\"1\":{\"118\":1,\"119\":1,\"202\":1,\"230\":1}}],[\"micros\",{\"1\":{\"391\":1}}],[\"microsecondspersecond\",{\"1\":{\"163\":1}}],[\"microsecond\",{\"1\":{\"105\":1}}],[\"micro\",{\"1\":{\"109\":2}}],[\"microtask会在同步方法之后立即执行\",{\"1\":{\"101\":1}}],[\"microtask会在同步方法执行完毕之后立即被执行\",{\"1\":{\"95\":1}}],[\"microtask实际上是使用\",{\"1\":{\"100\":1}}],[\"microtaskloop\",{\"1\":{\"98\":2,\"100\":1}}],[\"microtasks\",{\"1\":{\"97\":1,\"99\":1}}],[\"microtask本质还是调用schedulemicrotask实现的\",{\"1\":{\"96\":1}}],[\"microtask列表会一直执行\",{\"1\":{\"95\":1}}],[\"microtask等\",{\"1\":{\"95\":1}}],[\"microtask\",{\"1\":{\"95\":5,\"96\":2,\"97\":3,\"98\":2,\"99\":2,\"103\":1,\"141\":1,\"209\":1}}],[\"midentityhashcode\",{\"1\":{\"49\":2}}],[\"mibinder\",{\"1\":{\"36\":2,\"58\":2}}],[\"minimum\",{\"1\":{\"391\":1}}],[\"minimaldaysinfirstweek和simpledateformat\",{\"1\":{\"302\":1}}],[\"minimaldaysinfirstweek\",{\"1\":{\"302\":4}}],[\"minit\",{\"1\":{\"295\":2}}],[\"minit=\",{\"1\":{\"295\":1}}],[\"miniwidth指定的值中最大的一个值\",{\"1\":{\"65\":1}}],[\"miniwidth指定的值\",{\"1\":{\"65\":1}}],[\"minor\",{\"1\":{\"288\":1}}],[\"minextent\",{\"1\":{\"213\":1}}],[\"minclipovaldiameter\",{\"1\":{\"172\":2,\"173\":1}}],[\"minwidth=\",{\"1\":{\"79\":1}}],[\"minscrollextent默认返回0\",{\"1\":{\"238\":1}}],[\"minscrollextent~double\",{\"1\":{\"226\":1}}],[\"minscrollextent和pixels最小值\",{\"1\":{\"220\":1}}],[\"minscrollextent\",{\"1\":{\"220\":7,\"223\":1,\"226\":1,\"238\":3}}],[\"minstance\",{\"1\":{\"72\":5,\"363\":4}}],[\"minsdkversion\",{\"1\":{\"14\":1}}],[\"min\",{\"1\":{\"65\":1,\"161\":1,\"167\":3,\"213\":1,\"220\":8,\"241\":1,\"391\":6}}],[\"mindextexts\",{\"1\":{\"64\":4}}],[\"minheight=\",{\"1\":{\"79\":1}}],[\"minheight\",{\"1\":{\"55\":1,\"241\":1,\"242\":1}}],[\"minute\",{\"1\":{\"10\":1,\"285\":2,\"302\":2}}],[\"mradius\",{\"1\":{\"65\":2}}],[\"mremote\",{\"1\":{\"40\":4,\"58\":5}}],[\"mrecevierreplymsg\",{\"1\":{\"20\":2}}],[\"mrun\",{\"1\":{\"24\":1}}],[\"mqueue\",{\"1\":{\"24\":1,\"25\":1,\"28\":2,\"43\":1}}],[\"mst源码\",{\"1\":{\"438\":1}}],[\"mstatus\",{\"1\":{\"80\":4}}],[\"ms\",{\"1\":{\"109\":4,\"110\":1,\"327\":13}}],[\"msharedpreferences\",{\"1\":{\"69\":5}}],[\"msearchbar>\",{\"1\":{\"56\":2}}],[\"msearchbar\",{\"1\":{\"56\":12}}],[\"msearchbar表明是给该控件使用的自定义属性\",{\"1\":{\"56\":1}}],[\"mserviceinterface\",{\"1\":{\"58\":2}}],[\"mserviceconnection\",{\"1\":{\"43\":1}}],[\"mservice开始了\",{\"1\":{\"36\":1}}],[\"mservice\",{\"1\":{\"19\":4,\"20\":2,\"35\":1,\"36\":2,\"54\":1}}],[\"msizetext\",{\"1\":{\"64\":2}}],[\"msize++\",{\"1\":{\"45\":1}}],[\"msize\",{\"1\":{\"44\":1,\"45\":6,\"46\":1,\"47\":1,\"48\":3,\"49\":2,\"52\":2,\"287\":2}}],[\"mscroller\",{\"1\":{\"41\":7}}],[\"msg的获取\",{\"0\":{\"31\":1}}],[\"msg自带的回调方法\",{\"1\":{\"29\":1}}],[\"msg\",{\"1\":{\"20\":13,\"25\":5,\"28\":2,\"29\":6,\"30\":2,\"43\":8,\"72\":6,\"80\":3,\"107\":1,\"108\":6,\"109\":3,\"111\":2,\"115\":3,\"334\":3,\"373\":3,\"376\":6,\"384\":2,\"389\":3}}],[\"mywidget\",{\"1\":{\"133\":1}}],[\"my\",{\"1\":{\"79\":1,\"137\":1,\"245\":1,\"400\":1}}],[\"myapp\",{\"1\":{\"132\":2,\"401\":1}}],[\"myappwidget\",{\"1\":{\"79\":6}}],[\"myapplication\",{\"1\":{\"14\":3,\"40\":11}}],[\"myrecyclerdecoration\",{\"1\":{\"64\":2}}],[\"mykotlin\",{\"1\":{\"54\":2}}],[\"mylooper\",{\"0\":{\"26\":1},\"1\":{\"25\":1,\"26\":2,\"28\":1,\"31\":1}}],[\"myservice\",{\"1\":{\"17\":1}}],[\"myservices\",{\"1\":{\"17\":5}}],[\"myotherclass\",{\"1\":{\"14\":1}}],[\"myclass1\",{\"1\":{\"322\":5}}],[\"myclasstoo\",{\"1\":{\"14\":1}}],[\"myclass\",{\"1\":{\"14\":2}}],[\"mydomain\",{\"1\":{\"2\":1}}],[\"mozilla\",{\"1\":{\"370\":1}}],[\"moving\",{\"1\":{\"198\":1}}],[\"moved\",{\"1\":{\"98\":1,\"180\":1}}],[\"move\",{\"1\":{\"64\":1,\"115\":5,\"198\":1,\"379\":1,\"380\":1,\"384\":1,\"387\":1,\"388\":1,\"389\":1,\"391\":1,\"459\":2}}],[\"moveto\",{\"1\":{\"63\":2}}],[\"movetofirst\",{\"1\":{\"2\":1}}],[\"mounted\",{\"1\":{\"176\":3,\"180\":1}}],[\"mount方法主要逻辑在componentelement中\",{\"1\":{\"126\":1}}],[\"mount方法将element添加到element\",{\"1\":{\"122\":1}}],[\"mount方法\",{\"1\":{\"121\":2,\"126\":1,\"127\":1}}],[\"mount\",{\"1\":{\"121\":4,\"122\":1,\"124\":1,\"126\":2,\"127\":5}}],[\"mouse\",{\"1\":{\"13\":1}}],[\"moment\",{\"1\":{\"115\":1}}],[\"moldams\",{\"1\":{\"72\":1}}],[\"most模式\",{\"1\":{\"65\":1}}],[\"most\",{\"1\":{\"65\":3,\"131\":1}}],[\"more\",{\"1\":{\"45\":1,\"109\":1,\"111\":1,\"233\":1,\"243\":1,\"245\":1,\"246\":1,\"247\":1,\"248\":1,\"287\":1,\"391\":4}}],[\"modifier\",{\"1\":{\"304\":1}}],[\"modify\",{\"1\":{\"40\":1}}],[\"modcount\",{\"1\":{\"280\":1,\"287\":1}}],[\"module不仅可以交给application的\",{\"1\":{\"94\":1}}],[\"module之间的关联关系将application和activity等的依赖注入通过androidinjector关联起来的\",{\"1\":{\"94\":1}}],[\"module的\",{\"1\":{\"87\":1}}],[\"module中添加另外一个\",{\"1\":{\"85\":1}}],[\"module类中的\",{\"1\":{\"85\":1}}],[\"modules\",{\"1\":{\"85\":2,\"87\":1,\"89\":1}}],[\"module\",{\"0\":{\"91\":1},\"1\":{\"85\":2,\"86\":1,\"87\":2,\"91\":3}}],[\"module则是提供一个类\",{\"1\":{\"85\":1}}],[\"module和\",{\"0\":{\"85\":1},\"1\":{\"85\":2}}],[\"mode组成如下\",{\"1\":{\"351\":1}}],[\"mode默认为tickermode\",{\"1\":{\"328\":1}}],[\"model在这里的实现是一个数据库\",{\"1\":{\"399\":1}}],[\"model\",{\"1\":{\"211\":2,\"392\":1}}],[\"mode\",{\"1\":{\"57\":3,\"65\":1,\"69\":1,\"111\":9,\"225\":3,\"296\":2,\"328\":1,\"351\":1,\"383\":1,\"384\":1,\"426\":2}}],[\"modes\",{\"1\":{\"13\":2}}],[\"modalbarrier\",{\"1\":{\"154\":1}}],[\"modal\",{\"1\":{\"41\":2}}],[\"month\",{\"1\":{\"302\":6}}],[\"montouchlistener\",{\"1\":{\"13\":1}}],[\"monday\",{\"1\":{\"302\":2}}],[\"monitorleavescope\",{\"1\":{\"391\":1}}],[\"monitorlocker\",{\"1\":{\"115\":5,\"389\":2,\"390\":1,\"391\":3}}],[\"monitor\",{\"1\":{\"115\":4,\"297\":1,\"389\":2,\"391\":14}}],[\"monclicklistener\",{\"1\":{\"13\":1}}],[\"motionevent\",{\"1\":{\"13\":15,\"64\":1}}],[\"madvise\",{\"1\":{\"387\":1}}],[\"makefile文件\",{\"1\":{\"282\":1}}],[\"makefile\",{\"1\":{\"282\":1}}],[\"makes\",{\"1\":{\"278\":1}}],[\"make\",{\"1\":{\"198\":2,\"376\":2,\"378\":1,\"386\":1}}],[\"maketext\",{\"1\":{\"56\":1,\"78\":1}}],[\"machine\",{\"0\":{\"252\":1},\"1\":{\"249\":1,\"275\":1,\"277\":1,\"279\":2,\"395\":1,\"396\":1}}],[\"macro\",{\"1\":{\"125\":1}}],[\"mactive\",{\"1\":{\"80\":5}}],[\"markneedssemanticsupdate\",{\"1\":{\"237\":1}}],[\"markneedspaint\",{\"1\":{\"237\":1}}],[\"markneedslayout\",{\"1\":{\"229\":1,\"237\":1}}],[\"markneedsbuild\",{\"1\":{\"121\":1,\"126\":1}}],[\"marking\",{\"1\":{\"126\":1}}],[\"marker\",{\"1\":{\"115\":1,\"302\":1}}],[\"markclosed\",{\"1\":{\"111\":2}}],[\"mark\",{\"1\":{\"109\":1}}],[\"marray\",{\"1\":{\"49\":4,\"50\":2,\"51\":1,\"52\":1}}],[\"magicfun\",{\"1\":{\"82\":1}}],[\"mamsinvocationhandler核心代码\",{\"1\":{\"72\":1}}],[\"mamsinvocationhandler\",{\"1\":{\"72\":3}}],[\"materialscrollbehavior\",{\"1\":{\"178\":1}}],[\"materialpointarctween\",{\"1\":{\"174\":1}}],[\"materialpageroute\",{\"1\":{\"170\":1}}],[\"materialrectcenterarctween\",{\"1\":{\"174\":1}}],[\"materialrectarctween\",{\"1\":{\"174\":1,\"178\":1}}],[\"material\",{\"1\":{\"131\":1,\"132\":1,\"171\":1}}],[\"materialappstate\",{\"1\":{\"178\":2}}],[\"materialapp类\",{\"1\":{\"178\":1}}],[\"materialapp\",{\"1\":{\"131\":1,\"132\":1,\"143\":1,\"174\":1,\"178\":4,\"181\":1}}],[\"materialbutton\",{\"1\":{\"130\":1}}],[\"math\",{\"1\":{\"65\":1,\"155\":1,\"156\":1,\"172\":1,\"173\":1,\"213\":1,\"220\":2,\"223\":1,\"226\":2,\"238\":2}}],[\"matchtextdirection\",{\"1\":{\"193\":2}}],[\"matching\",{\"1\":{\"49\":2,\"180\":1}}],[\"matches\",{\"1\":{\"49\":1}}],[\"match\",{\"1\":{\"2\":1,\"56\":2,\"65\":1,\"79\":4,\"396\":1,\"400\":2,\"401\":2}}],[\"mask\",{\"1\":{\"65\":1}}],[\"master\",{\"1\":{\"41\":1,\"61\":1,\"172\":1,\"347\":3,\"419\":1}}],[\"maxheight的值\",{\"1\":{\"242\":1}}],[\"maxheight比column想要的大时\",{\"1\":{\"242\":1}}],[\"maxheight\",{\"1\":{\"241\":1,\"242\":1}}],[\"maxindex\",{\"1\":{\"289\":5}}],[\"maxinnerextent\",{\"1\":{\"223\":4}}],[\"maximumsizebytes\",{\"1\":{\"197\":1,\"198\":1}}],[\"maximumsize\",{\"1\":{\"197\":1,\"198\":1}}],[\"maximum\",{\"1\":{\"80\":1}}],[\"maxscrollextent就是多出来的那一部分\",{\"1\":{\"238\":1}}],[\"maxscrollextent返回的是主轴方向上child减去singlechildscrollview之后的尺寸和0\",{\"1\":{\"238\":1}}],[\"maxscrollextent分别设置了viewport和content的范围\",{\"1\":{\"238\":1}}],[\"maxscrollextent和pixels中最大值\",{\"1\":{\"220\":1}}],[\"maxscrollextent\",{\"1\":{\"213\":4,\"220\":6,\"223\":1,\"226\":3,\"238\":2}}],[\"maxpaintextent\",{\"1\":{\"213\":1}}],[\"maxports\",{\"1\":{\"112\":3}}],[\"maxextent\",{\"1\":{\"213\":1}}],[\"maxed\",{\"1\":{\"115\":1,\"390\":1}}],[\"maxclipovaldiameter\",{\"1\":{\"172\":3,\"173\":2}}],[\"maxlines\",{\"1\":{\"117\":2,\"125\":1,\"127\":2}}],[\"max\",{\"1\":{\"65\":2,\"112\":1,\"115\":2,\"131\":2,\"161\":1,\"167\":3,\"220\":8,\"223\":1,\"226\":2,\"238\":2,\"283\":1,\"390\":2,\"391\":5,\"456\":5}}],[\"malloc\",{\"1\":{\"58\":1}}],[\"mapped\",{\"1\":{\"396\":1}}],[\"mappings\",{\"1\":{\"387\":1}}],[\"mapping\",{\"1\":{\"58\":1,\"287\":1}}],[\"mapof\",{\"1\":{\"322\":1}}],[\"map委托\",{\"1\":{\"322\":1}}],[\"mapentry<object\",{\"1\":{\"180\":1}}],[\"map<double\",{\"1\":{\"291\":1}}],[\"map<dynamic\",{\"1\":{\"211\":4}}],[\"map<k\",{\"1\":{\"287\":1}}],[\"map<type\",{\"1\":{\"223\":1}}],[\"map<extendedimageprovider<dynamic>\",{\"1\":{\"202\":1}}],[\"map<string\",{\"1\":{\"201\":1,\"202\":1,\"211\":6,\"291\":2,\"322\":1,\"364\":4,\"378\":3}}],[\"map<object\",{\"1\":{\"175\":1,\"178\":1,\"180\":2,\"197\":3}}],[\"map<int\",{\"1\":{\"112\":1}}],[\"mapcollections<k\",{\"1\":{\"49\":1}}],[\"map\",{\"1\":{\"33\":1,\"78\":3,\"111\":1,\"112\":1,\"197\":1,\"198\":1,\"209\":6,\"210\":5,\"211\":16,\"212\":2,\"280\":1,\"288\":7,\"309\":1,\"321\":4,\"322\":5,\"327\":2,\"338\":1,\"345\":5,\"438\":2}}],[\"mainscope\",{\"1\":{\"326\":4}}],[\"maintainstate\",{\"1\":{\"179\":1}}],[\"mainthread\",{\"1\":{\"80\":2,\"288\":2}}],[\"mainerrorwidget的一种实现方式\",{\"1\":{\"143\":1}}],[\"mainerrorwidget\",{\"1\":{\"143\":3}}],[\"mainaxisextent\",{\"1\":{\"213\":6}}],[\"mainaxissize\",{\"1\":{\"131\":4,\"241\":2}}],[\"mainaxisalignment\",{\"1\":{\"131\":2,\"241\":2}}],[\"mainapplication\",{\"1\":{\"89\":1,\"92\":1}}],[\"mainapp\",{\"1\":{\"81\":1}}],[\"mainactivitysubcomponent通过将mainactivitymodule加入到appcomponent之中\",{\"1\":{\"94\":1}}],[\"mainactivitysubcomponent\",{\"1\":{\"90\":1,\"91\":2}}],[\"mainactivitymodule\",{\"1\":{\"89\":1,\"91\":2}}],[\"mainactivity\",{\"1\":{\"17\":1,\"56\":1,\"69\":2,\"77\":1,\"91\":1,\"93\":1,\"211\":1}}],[\"main\",{\"0\":{\"368\":1,\"391\":1},\"1\":{\"32\":3,\"40\":1,\"41\":1,\"54\":2,\"61\":1,\"93\":1,\"110\":1,\"111\":1,\"115\":3,\"117\":1,\"131\":2,\"132\":3,\"136\":2,\"272\":2,\"281\":1,\"282\":4,\"288\":9,\"295\":1,\"308\":1,\"322\":3,\"324\":1,\"325\":4,\"327\":3,\"328\":1,\"341\":1,\"346\":1,\"368\":2,\"370\":2,\"371\":2,\"372\":1,\"382\":3,\"383\":1,\"387\":12,\"389\":3,\"391\":4,\"397\":1,\"401\":2}}],[\"maybemakeserviceisolate\",{\"1\":{\"383\":1}}],[\"maybestartherotransition\",{\"0\":{\"179\":1},\"1\":{\"179\":2}}],[\"maybelocaleof\",{\"1\":{\"127\":1}}],[\"maybeof\",{\"1\":{\"122\":2}}],[\"maybeconnecthandler\",{\"1\":{\"111\":1}}],[\"mayaddlistener\",{\"1\":{\"103\":2}}],[\"maycomplete\",{\"1\":{\"103\":1}}],[\"may\",{\"1\":{\"24\":1,\"45\":1,\"59\":1,\"80\":1,\"85\":1,\"111\":1,\"179\":1,\"180\":1,\"209\":2,\"276\":1,\"302\":1,\"383\":1,\"391\":7}}],[\"maven\",{\"1\":{\"1\":2}}],[\"mandatory\",{\"1\":{\"381\":1,\"386\":1}}],[\"management\",{\"1\":{\"136\":1}}],[\"manager实现缓存网络图片的功能\",{\"1\":{\"202\":1}}],[\"manager\",{\"1\":{\"78\":3,\"132\":1,\"371\":2}}],[\"manageraidl\",{\"1\":{\"35\":10,\"36\":3}}],[\"managing\",{\"1\":{\"130\":1}}],[\"many\",{\"1\":{\"102\":1,\"112\":1}}],[\"manifest\",{\"1\":{\"54\":1,\"69\":3,\"180\":8,\"181\":17,\"282\":2}}],[\"manifestplaceholders\",{\"1\":{\"54\":3}}],[\"manifest>\",{\"1\":{\"2\":1,\"421\":1}}],[\"man\",{\"1\":{\"0\":1,\"108\":1}}],[\"mesage\",{\"1\":{\"376\":1}}],[\"messgae\",{\"1\":{\"389\":2}}],[\"messagenotify\",{\"1\":{\"115\":1}}],[\"messagehandlertask\",{\"1\":{\"115\":3,\"389\":1,\"391\":3}}],[\"messagehandler\",{\"1\":{\"115\":8,\"383\":2,\"389\":1,\"391\":8}}],[\"messagemap\",{\"1\":{\"111\":7,\"112\":7}}],[\"messagestatusstring\",{\"1\":{\"391\":3}}],[\"messagestatus\",{\"1\":{\"391\":4}}],[\"messages\",{\"1\":{\"106\":1,\"107\":1,\"115\":3,\"389\":1,\"391\":16}}],[\"messageservice\",{\"1\":{\"20\":1}}],[\"messagequeue\",{\"1\":{\"24\":1,\"25\":1,\"376\":2,\"391\":2}}],[\"message三者关系\",{\"1\":{\"22\":1}}],[\"message\",{\"0\":{\"22\":1},\"1\":{\"20\":7,\"25\":1,\"29\":1,\"30\":4,\"31\":2,\"43\":9,\"72\":2,\"80\":4,\"101\":3,\"106\":2,\"107\":1,\"108\":3,\"111\":2,\"112\":2,\"115\":31,\"211\":1,\"373\":7,\"376\":5,\"378\":11,\"379\":1,\"383\":2,\"384\":1,\"389\":17,\"391\":54}}],[\"messenger底层是使用handler发送消息\",{\"1\":{\"43\":1}}],[\"messengerimpl\",{\"1\":{\"43\":2}}],[\"messengerhandler\",{\"1\":{\"43\":2}}],[\"messenger的使用可以参考这篇文章\",{\"1\":{\"43\":1}}],[\"messenger只用于服务端和客户端串行的传递消息\",{\"1\":{\"43\":1}}],[\"messenger是android中用于ipc的方式之一\",{\"1\":{\"43\":1}}],[\"messengerservice\",{\"1\":{\"20\":3,\"43\":1}}],[\"messenger\",{\"0\":{\"20\":1},\"1\":{\"20\":10,\"43\":14,\"58\":1}}],[\"members\",{\"1\":{\"394\":1}}],[\"member\",{\"1\":{\"322\":1}}],[\"memories\",{\"1\":{\"282\":4,\"286\":1,\"287\":1}}],[\"memoryimage\",{\"1\":{\"196\":1}}],[\"memory\",{\"1\":{\"58\":1,\"59\":1,\"136\":3,\"188\":1,\"200\":1,\"286\":1,\"287\":1,\"372\":1,\"383\":4,\"387\":1,\"396\":1}}],[\"meituan\",{\"1\":{\"280\":1}}],[\"means\",{\"1\":{\"136\":1,\"220\":2,\"383\":1,\"391\":1}}],[\"measuretimemillis\",{\"1\":{\"327\":1}}],[\"measurespec\",{\"1\":{\"65\":12}}],[\"measurespec是一个32位int值\",{\"1\":{\"65\":1}}],[\"measured\",{\"1\":{\"65\":1}}],[\"measure\",{\"1\":{\"65\":5,\"180\":1}}],[\"mergesort\",{\"1\":{\"459\":3}}],[\"merge\",{\"1\":{\"126\":2,\"347\":1,\"459\":2}}],[\"mechanism\",{\"1\":{\"111\":1,\"180\":1}}],[\"media\",{\"1\":{\"349\":1}}],[\"mediaquery\",{\"1\":{\"126\":1,\"131\":1}}],[\"mediatorlivedata<string>\",{\"1\":{\"78\":1}}],[\"mediatorlivedata\",{\"1\":{\"78\":3}}],[\"mediaserver\",{\"1\":{\"60\":1}}],[\"mediaserver进程\",{\"1\":{\"60\":1}}],[\"met\",{\"1\":{\"389\":1}}],[\"metric\",{\"1\":{\"383\":5}}],[\"metrics\",{\"1\":{\"53\":6,\"225\":4,\"383\":1}}],[\"methodinvocation\",{\"1\":{\"395\":1}}],[\"methodhandle实例最后解析结果ref\",{\"1\":{\"279\":1}}],[\"methods\",{\"1\":{\"278\":1,\"295\":2,\"392\":1,\"394\":1}}],[\"methodcall\",{\"1\":{\"135\":3,\"211\":1}}],[\"methodcallhandler\",{\"1\":{\"135\":1,\"211\":1}}],[\"methodchannel\",{\"1\":{\"135\":4,\"211\":10}}],[\"method\",{\"0\":{\"253\":1,\"254\":1},\"1\":{\"61\":1,\"72\":5,\"79\":5,\"102\":1,\"115\":3,\"135\":1,\"196\":1,\"202\":1,\"211\":4,\"233\":1,\"249\":1,\"253\":1,\"278\":6,\"279\":1,\"295\":2,\"297\":1,\"298\":1,\"300\":1,\"305\":1,\"306\":1,\"312\":1,\"383\":8,\"391\":1,\"395\":1,\"396\":1}}],[\"metadata\",{\"1\":{\"54\":1}}],[\"meta\",{\"1\":{\"54\":2,\"282\":2}}],[\"me\",{\"1\":{\"0\":1,\"25\":2,\"115\":2,\"243\":1,\"389\":1,\"391\":6,\"419\":1}}],[\"tbes\",{\"1\":{\"383\":3}}],[\"tclass\",{\"1\":{\"322\":1}}],[\"tc\",{\"1\":{\"305\":15,\"309\":1,\"312\":1}}],[\"t7\",{\"1\":{\"294\":1}}],[\"t2运行到这里时\",{\"1\":{\"294\":1}}],[\"t2也开始执行tag2生成一个新对象\",{\"1\":{\"294\":1}}],[\"t2\",{\"1\":{\"294\":1}}],[\"t1\",{\"1\":{\"272\":3}}],[\"t0\",{\"1\":{\"272\":2}}],[\"turnidge\",{\"1\":{\"391\":1}}],[\"turns\",{\"1\":{\"155\":5}}],[\"tuple\",{\"1\":{\"379\":2,\"389\":2}}],[\"tuple等\",{\"1\":{\"369\":1}}],[\"tue\",{\"1\":{\"302\":1}}],[\"tuesday\",{\"1\":{\"302\":1}}],[\"tutorial\",{\"1\":{\"140\":1}}],[\"twitter出品的高性能序列化方案\",{\"1\":{\"303\":1}}],[\"twitter\",{\"1\":{\"303\":1}}],[\"tween<color\",{\"1\":{\"184\":1}}],[\"tween<t\",{\"1\":{\"184\":1}}],[\"tween<t>\",{\"1\":{\"153\":2,\"184\":1}}],[\"tween<t>的evaluate\",{\"1\":{\"152\":1}}],[\"tween<rect\",{\"1\":{\"177\":1}}],[\"tween<double>的值\",{\"1\":{\"184\":1}}],[\"tween<double>\",{\"1\":{\"153\":1}}],[\"tween<dynamic>\",{\"1\":{\"149\":2,\"150\":1}}],[\"tweenvisitor<dynamic>\",{\"1\":{\"151\":1,\"152\":1,\"153\":1}}],[\"tweenvisitor<dynamic>并传给子类\",{\"1\":{\"149\":1}}],[\"tweenvisitor\",{\"1\":{\"151\":1}}],[\"tweenconstructor<dynamic>\",{\"1\":{\"149\":1,\"150\":1}}],[\"tweensequence\",{\"1\":{\"183\":2}}],[\"tweens\",{\"1\":{\"148\":1}}],[\"tweenanimationbuilderstate<t\",{\"1\":{\"153\":1}}],[\"tweenanimationbuilderstate\",{\"1\":{\"153\":1}}],[\"tweenanimationbuilder<double>\",{\"1\":{\"153\":1}}],[\"tweenanimationbuilder\",{\"0\":{\"153\":1},\"1\":{\"146\":1,\"147\":2,\"153\":7,\"154\":1,\"156\":2,\"157\":1}}],[\"tween\",{\"0\":{\"184\":1},\"1\":{\"146\":2,\"147\":1,\"148\":2,\"149\":10,\"150\":4,\"151\":1,\"152\":2,\"153\":13,\"154\":1,\"156\":1,\"157\":3,\"181\":1,\"182\":4,\"183\":1,\"184\":8,\"185\":3,\"186\":2}}],[\"two\",{\"1\":{\"115\":1,\"147\":1,\"327\":6}}],[\"typicode\",{\"1\":{\"136\":1}}],[\"type=\",{\"1\":{\"401\":2}}],[\"typeerror\",{\"1\":{\"369\":1}}],[\"typename\",{\"1\":{\"115\":1}}],[\"typeacceptsnull<t>\",{\"1\":{\"102\":1}}],[\"typedef\",{\"1\":{\"99\":1,\"115\":1}}],[\"typedarray\",{\"1\":{\"56\":2}}],[\"typedvalue\",{\"1\":{\"53\":1}}],[\"type\",{\"1\":{\"55\":3,\"57\":1,\"102\":1,\"103\":1,\"115\":4,\"158\":1,\"177\":2,\"180\":2,\"181\":6,\"183\":1,\"204\":1,\"211\":2,\"230\":2,\"274\":1,\"275\":2,\"278\":1,\"298\":1,\"305\":1,\"322\":2,\"357\":1,\"370\":1,\"376\":1,\"378\":1,\"383\":1,\"418\":1}}],[\"type代表window的类型\",{\"1\":{\"41\":1}}],[\"types\",{\"1\":{\"34\":1,\"58\":1,\"85\":1,\"322\":1,\"396\":2,\"400\":1}}],[\"tls\",{\"1\":{\"115\":3}}],[\"tlen\",{\"1\":{\"115\":2,\"391\":2}}],[\"tport\",{\"1\":{\"115\":1,\"391\":2}}],[\"tdest\",{\"1\":{\"115\":4}}],[\"tsource\",{\"1\":{\"115\":2}}],[\"t>主动声明通配符\",{\"1\":{\"293\":1}}],[\"t>表示的是t的子类\",{\"1\":{\"292\":1}}],[\"t>\",{\"1\":{\"103\":1,\"108\":1,\"115\":1,\"292\":2,\"322\":1}}],[\"t\",{\"1\":{\"45\":3,\"49\":1,\"55\":2,\"102\":11,\"103\":1,\"108\":10,\"109\":1,\"112\":1,\"115\":6,\"116\":2,\"129\":2,\"136\":2,\"150\":1,\"158\":2,\"166\":5,\"167\":3,\"170\":1,\"180\":2,\"181\":1,\"182\":1,\"183\":11,\"184\":19,\"185\":8,\"186\":24,\"196\":1,\"198\":5,\"202\":1,\"225\":2,\"287\":1,\"288\":14,\"290\":2,\"297\":3,\"322\":12,\"327\":1,\"345\":1,\"347\":2,\"356\":1,\"357\":1,\"361\":1,\"373\":2,\"378\":6,\"383\":22,\"384\":1,\"387\":5,\"388\":2,\"389\":1,\"391\":5,\"438\":2}}],[\"tar\",{\"0\":{\"357\":1},\"1\":{\"355\":2,\"357\":5}}],[\"target<drawable>\",{\"1\":{\"211\":2}}],[\"target开始动画\",{\"1\":{\"161\":1}}],[\"targetvalue\",{\"1\":{\"149\":6,\"150\":2,\"153\":1}}],[\"targetintent\",{\"1\":{\"72\":9}}],[\"targetactivity\",{\"1\":{\"71\":2,\"79\":8}}],[\"target\",{\"1\":{\"13\":4,\"25\":2,\"28\":2,\"31\":1,\"43\":7,\"55\":3,\"72\":4,\"75\":1,\"79\":3,\"147\":1,\"161\":2,\"211\":4,\"298\":1,\"299\":1,\"383\":3}}],[\"targetsdkversion\",{\"1\":{\"14\":1}}],[\"targets\",{\"1\":{\"13\":4}}],[\"tailrec为kotlin中优化关键字\",{\"1\":{\"322\":1}}],[\"tailrec\",{\"1\":{\"322\":2}}],[\"taking\",{\"1\":{\"275\":1}}],[\"take\",{\"1\":{\"327\":2,\"338\":1}}],[\"takes\",{\"1\":{\"226\":1}}],[\"takebytes\",{\"1\":{\"111\":1}}],[\"tables\",{\"1\":{\"376\":1}}],[\"table不为空则返回table长度\",{\"1\":{\"280\":1}}],[\"table\",{\"1\":{\"280\":4,\"287\":1,\"288\":2,\"383\":8}}],[\"tab$e\",{\"1\":{\"212\":1}}],[\"tab\",{\"1\":{\"212\":1,\"288\":2}}],[\"tabs\",{\"1\":{\"212\":4}}],[\"tabbar\",{\"1\":{\"212\":3}}],[\"tabbarview等直接对sliverfillviewport等进行封装的widget\",{\"1\":{\"234\":1}}],[\"tabbarview\",{\"1\":{\"212\":4,\"227\":1}}],[\"tapped\",{\"1\":{\"140\":1}}],[\"task也没有普通的event\",{\"1\":{\"109\":1}}],[\"task中\",{\"1\":{\"103\":1}}],[\"task直到清空micro\",{\"1\":{\"101\":1}}],[\"task就执行micro\",{\"1\":{\"101\":1}}],[\"task之后\",{\"1\":{\"101\":1}}],[\"task了\",{\"1\":{\"95\":1}}],[\"tasks\",{\"1\":{\"80\":1,\"109\":1,\"115\":4,\"382\":1,\"390\":6,\"391\":11}}],[\"task\",{\"1\":{\"80\":8,\"95\":1,\"101\":3,\"109\":4,\"115\":11,\"380\":1,\"386\":1,\"389\":4,\"390\":3,\"391\":18,\"392\":1}}],[\"taskcallback\",{\"1\":{\"35\":10,\"36\":4,\"391\":2}}],[\"tag为gityuan\",{\"1\":{\"370\":1}}],[\"tag2\",{\"1\":{\"294\":2}}],[\"tag1\",{\"1\":{\"294\":2}}],[\"tag的map\",{\"1\":{\"175\":1}}],[\"tag一致\",{\"1\":{\"170\":2}}],[\"tag\",{\"1\":{\"17\":5,\"36\":2,\"37\":2,\"69\":1,\"93\":1,\"170\":4,\"175\":2,\"177\":2,\"178\":1,\"180\":6,\"283\":1,\"364\":5,\"383\":6}}],[\"tear\",{\"1\":{\"395\":1}}],[\"teal\",{\"1\":{\"130\":2,\"131\":1}}],[\"terror\",{\"1\":{\"391\":1}}],[\"termination\",{\"1\":{\"389\":2}}],[\"terminated\",{\"1\":{\"389\":1}}],[\"terminate\",{\"1\":{\"383\":1}}],[\"terminatecapability\",{\"1\":{\"373\":1,\"377\":1,\"378\":5}}],[\"terminates\",{\"1\":{\"59\":1,\"389\":1}}],[\"tech\",{\"1\":{\"280\":1}}],[\"tenured\",{\"1\":{\"249\":1}}],[\"tenminutes\",{\"1\":{\"11\":2}}],[\"temp\",{\"1\":{\"289\":6,\"349\":1,\"455\":2,\"456\":2,\"462\":2,\"467\":2}}],[\"temporarily\",{\"1\":{\"209\":1,\"391\":2}}],[\"templates\",{\"1\":{\"345\":1}}],[\"template\",{\"1\":{\"115\":1,\"438\":1}}],[\"tempview\",{\"1\":{\"55\":1}}],[\"tell\",{\"1\":{\"106\":1,\"108\":1,\"176\":1}}],[\"testinterface\",{\"1\":{\"345\":7}}],[\"testclass\",{\"1\":{\"272\":3}}],[\"test\",{\"1\":{\"95\":2,\"122\":1,\"132\":1,\"229\":1,\"281\":1,\"468\":1}}],[\"textrue\",{\"1\":{\"211\":1}}],[\"texture不相上下了\",{\"1\":{\"211\":1}}],[\"texture使用\",{\"1\":{\"211\":1}}],[\"texture方案\",{\"1\":{\"211\":1}}],[\"textureregistrywrf\",{\"1\":{\"211\":2}}],[\"texture和ffi方案分别使用\",{\"1\":{\"209\":1}}],[\"textureid中\",{\"1\":{\"211\":1}}],[\"textureid和ui\",{\"1\":{\"209\":1}}],[\"textureid\",{\"1\":{\"206\":2,\"207\":1,\"210\":10}}],[\"textureimageinfo\",{\"1\":{\"206\":4}}],[\"texture\",{\"1\":{\"202\":1,\"205\":1,\"206\":1,\"207\":4,\"211\":9}}],[\"text内部的richtext等对应的element都加入到element\",{\"1\":{\"127\":1}}],[\"text赋值了\",{\"1\":{\"127\":1}}],[\"text本身作为statelesswidget并不产生renderobject\",{\"1\":{\"127\":1}}],[\"textparentdata>\",{\"1\":{\"127\":2}}],[\"text作为statelesswidget\",{\"1\":{\"127\":1}}],[\"text插入到tree中执行的方法分别是text\",{\"1\":{\"126\":1}}],[\"text是statelesswidget的子类\",{\"1\":{\"126\":1}}],[\"text是statelesswidget\",{\"1\":{\"126\":1}}],[\"textheightbehavior\",{\"1\":{\"117\":1,\"125\":1,\"127\":2}}],[\"textwidthbasis\",{\"1\":{\"117\":1,\"125\":1,\"127\":2}}],[\"textstyle\",{\"1\":{\"126\":2,\"131\":1,\"143\":1}}],[\"textspan\",{\"1\":{\"125\":1,\"126\":4}}],[\"textscalefactor\",{\"1\":{\"117\":1,\"125\":1,\"127\":2}}],[\"textsize=\",{\"1\":{\"79\":1}}],[\"textsize\",{\"1\":{\"56\":6}}],[\"textalign\",{\"1\":{\"117\":1,\"125\":1,\"126\":4,\"127\":2}}],[\"textdirection\",{\"1\":{\"117\":4,\"122\":2,\"125\":1,\"126\":2,\"127\":3,\"228\":2}}],[\"text=character\",{\"1\":{\"111\":1}}],[\"text=\",{\"1\":{\"79\":3,\"401\":2}}],[\"textview\",{\"1\":{\"79\":1,\"301\":3}}],[\"textcolor=\",{\"1\":{\"56\":2}}],[\"textcolor\",{\"1\":{\"56\":1}}],[\"text\",{\"1\":{\"15\":8,\"36\":1,\"54\":4,\"58\":1,\"64\":10,\"117\":8,\"125\":2,\"126\":8,\"127\":2,\"130\":4,\"131\":10,\"132\":1,\"135\":1,\"140\":1,\"143\":1,\"172\":1,\"212\":2,\"234\":1,\"241\":2,\"242\":2,\"301\":1,\"302\":4,\"371\":2,\"401\":1}}],[\"txt文件中\",{\"1\":{\"361\":1}}],[\"txt将ls的内容追加输出到result\",{\"1\":{\"361\":1}}],[\"txt\",{\"1\":{\"14\":2}}],[\"trianglenum\",{\"1\":{\"459\":2}}],[\"trigger\",{\"1\":{\"109\":1,\"147\":1,\"198\":1,\"391\":1}}],[\"troubleshooting\",{\"1\":{\"243\":1}}],[\"treenode\",{\"1\":{\"346\":6}}],[\"treeify\",{\"1\":{\"280\":1}}],[\"tree间接管理widget\",{\"1\":{\"127\":1}}],[\"tree这里并没有对应的对象\",{\"1\":{\"126\":1}}],[\"tree如下\",{\"1\":{\"126\":1}}],[\"tree有一个关联的renderobject负责layout\",{\"1\":{\"122\":1}}],[\"tree的\",{\"1\":{\"126\":1}}],[\"tree的步骤一样\",{\"1\":{\"126\":1}}],[\"tree的output\",{\"1\":{\"122\":1}}],[\"tree的根节点\",{\"1\":{\"122\":1}}],[\"tree的根节点renderview绑定\",{\"1\":{\"121\":1}}],[\"tree的根节点renderview\",{\"1\":{\"117\":1,\"118\":1}}],[\"tree的pipelineowner\",{\"1\":{\"119\":1}}],[\"tree相关的类\",{\"1\":{\"119\":1}}],[\"tree管理\",{\"1\":{\"119\":1}}],[\"tree实际上并不存在\",{\"1\":{\"119\":1}}],[\"tree中的呢\",{\"1\":{\"127\":1}}],[\"tree中看到的center其实是center\",{\"1\":{\"125\":1}}],[\"tree中\",{\"1\":{\"119\":1,\"127\":4}}],[\"tree\",{\"1\":{\"117\":1,\"118\":3,\"119\":1,\"120\":1,\"122\":2,\"125\":1,\"127\":4,\"130\":1,\"132\":1,\"150\":1,\"195\":1,\"346\":7}}],[\"treated\",{\"1\":{\"105\":1}}],[\"treat\",{\"1\":{\"13\":1}}],[\"travis便会自动帮我们创建并更新静态网页\",{\"1\":{\"407\":1}}],[\"travis\",{\"0\":{\"407\":1},\"1\":{\"407\":2}}],[\"traverse\",{\"1\":{\"383\":1}}],[\"training\",{\"1\":{\"396\":1}}],[\"trainhoppinganimation\",{\"1\":{\"159\":1}}],[\"tracing\",{\"1\":{\"198\":1}}],[\"track\",{\"1\":{\"209\":1}}],[\"trackliveimage\",{\"1\":{\"198\":3}}],[\"tracking\",{\"1\":{\"198\":2}}],[\"trace\",{\"1\":{\"115\":3,\"198\":1,\"383\":1,\"389\":1,\"391\":4}}],[\"trampoline\",{\"1\":{\"115\":1}}],[\"translating\",{\"1\":{\"392\":1}}],[\"translation\",{\"1\":{\"41\":1}}],[\"translationy\",{\"1\":{\"41\":1}}],[\"translationy是view左上角顶点与父容器左上角顶点的偏移量\",{\"1\":{\"41\":1}}],[\"translationx\",{\"1\":{\"41\":2}}],[\"transfer\",{\"1\":{\"328\":1}}],[\"transformed\",{\"1\":{\"240\":3}}],[\"transforminternal\",{\"1\":{\"186\":5}}],[\"transforming\",{\"1\":{\"185\":1}}],[\"transform方法中并返回\",{\"1\":{\"183\":1}}],[\"transform方法返回值传入animatable\",{\"1\":{\"183\":1}}],[\"transformation\",{\"1\":{\"172\":1}}],[\"transformations有两个转化livedata的方法\",{\"1\":{\"78\":1}}],[\"transform将此animation\",{\"1\":{\"158\":1}}],[\"transform\",{\"1\":{\"147\":2,\"155\":1,\"156\":1,\"166\":1,\"183\":6,\"184\":3,\"185\":3,\"186\":9,\"327\":2}}],[\"transient\",{\"1\":{\"280\":5,\"287\":6,\"306\":1,\"308\":2,\"311\":1}}],[\"transitioned\",{\"1\":{\"391\":1}}],[\"transitionnativetovm\",{\"1\":{\"389\":3}}],[\"transitionxxx\",{\"1\":{\"383\":1}}],[\"transition\",{\"1\":{\"179\":1,\"180\":2,\"181\":1,\"383\":2,\"389\":3}}],[\"transitioning\",{\"1\":{\"179\":1}}],[\"transitiononusergestures\",{\"1\":{\"175\":1}}],[\"transitionbuilder\",{\"1\":{\"156\":1}}],[\"transitions\",{\"1\":{\"147\":1,\"181\":1}}],[\"transparent<\",{\"1\":{\"66\":1}}],[\"transparent\",{\"1\":{\"63\":1,\"184\":1}}],[\"transaction\",{\"1\":{\"40\":5,\"58\":5}}],[\"transact\",{\"1\":{\"40\":2,\"58\":3}}],[\"truncating\",{\"1\":{\"115\":1}}],[\"truncated\",{\"1\":{\"115\":4}}],[\"truncate\",{\"1\":{\"115\":1}}],[\"true为删除\",{\"1\":{\"21\":1}}],[\"true\",{\"1\":{\"2\":1,\"13\":7,\"14\":1,\"17\":1,\"24\":2,\"36\":3,\"40\":2,\"42\":1,\"47\":1,\"55\":4,\"56\":2,\"58\":2,\"63\":1,\"72\":7,\"77\":1,\"80\":2,\"95\":1,\"98\":1,\"105\":2,\"106\":2,\"109\":1,\"111\":3,\"114\":2,\"115\":5,\"117\":1,\"119\":1,\"122\":1,\"126\":1,\"136\":1,\"149\":1,\"164\":1,\"181\":1,\"193\":1,\"198\":1,\"201\":1,\"209\":2,\"211\":2,\"212\":2,\"223\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":2,\"238\":1,\"272\":2,\"295\":3,\"300\":2,\"309\":2,\"312\":1,\"322\":1,\"328\":1,\"369\":1,\"378\":4,\"379\":1,\"382\":1,\"383\":3,\"387\":2,\"388\":1,\"389\":7,\"391\":5,\"400\":1,\"437\":2,\"438\":2}}],[\"tr\",{\"1\":{\"80\":2}}],[\"trymarkisolateready\",{\"1\":{\"383\":1}}],[\"try\",{\"0\":{\"142\":1},\"1\":{\"20\":1,\"35\":3,\"36\":2,\"40\":1,\"43\":1,\"58\":1,\"72\":1,\"80\":3,\"96\":1,\"98\":2,\"102\":3,\"109\":1,\"111\":2,\"112\":1,\"121\":1,\"126\":2,\"142\":1,\"198\":2,\"201\":2,\"209\":1,\"211\":1,\"228\":1,\"272\":1,\"296\":1,\"300\":1,\"305\":1,\"306\":2,\"308\":1,\"309\":3,\"327\":2,\"328\":1,\"341\":2,\"343\":1,\"363\":1,\"365\":1,\"370\":1,\"373\":2,\"378\":2,\"453\":4}}],[\"thin\",{\"1\":{\"395\":1}}],[\"thisisinitialvalue\",{\"1\":{\"322\":1}}],[\"this引用的是country对象\",{\"1\":{\"321\":1}}],[\"this引用逃逸\",{\"1\":{\"317\":2,\"320\":1}}],[\"this$0来引用anobj的\",{\"1\":{\"281\":1}}],[\"this$0\",{\"1\":{\"281\":5}}],[\"this及navigatorstate\",{\"1\":{\"178\":1}}],[\"this\",{\"1\":{\"13\":9,\"14\":5,\"19\":2,\"28\":1,\"37\":2,\"40\":5,\"41\":1,\"43\":1,\"49\":2,\"56\":4,\"58\":4,\"64\":3,\"65\":1,\"69\":3,\"71\":1,\"75\":1,\"77\":1,\"78\":2,\"79\":1,\"80\":8,\"81\":4,\"84\":2,\"92\":1,\"93\":1,\"94\":1,\"96\":1,\"100\":1,\"101\":1,\"102\":2,\"103\":6,\"105\":7,\"106\":7,\"108\":1,\"111\":4,\"115\":11,\"118\":1,\"120\":4,\"121\":3,\"122\":4,\"125\":4,\"126\":3,\"127\":2,\"128\":2,\"130\":8,\"131\":2,\"134\":1,\"136\":1,\"143\":2,\"147\":7,\"154\":1,\"155\":3,\"156\":2,\"158\":3,\"165\":2,\"166\":3,\"167\":4,\"172\":3,\"175\":6,\"177\":12,\"178\":1,\"179\":1,\"180\":5,\"183\":6,\"184\":2,\"185\":2,\"186\":1,\"192\":3,\"193\":1,\"196\":6,\"198\":2,\"201\":1,\"202\":2,\"211\":5,\"213\":3,\"216\":1,\"217\":2,\"219\":1,\"220\":1,\"221\":2,\"223\":1,\"225\":2,\"226\":3,\"228\":1,\"230\":2,\"233\":1,\"238\":1,\"243\":1,\"272\":1,\"277\":1,\"278\":2,\"281\":6,\"287\":1,\"288\":4,\"295\":2,\"297\":4,\"301\":1,\"305\":1,\"312\":2,\"314\":1,\"321\":1,\"322\":1,\"327\":2,\"328\":2,\"345\":1,\"364\":6,\"365\":1,\"369\":1,\"373\":3,\"376\":1,\"378\":10,\"379\":1,\"381\":1,\"382\":2,\"383\":9,\"384\":1,\"386\":1,\"387\":1,\"389\":5,\"390\":1,\"391\":12,\"400\":1,\"401\":1,\"402\":1,\"426\":1}}],[\"though\",{\"1\":{\"383\":1}}],[\"those\",{\"1\":{\"180\":1,\"216\":1}}],[\"thandler\",{\"1\":{\"115\":2,\"389\":1,\"391\":4}}],[\"than\",{\"1\":{\"108\":1,\"115\":1,\"220\":1,\"287\":1}}],[\"that\",{\"1\":{\"36\":1,\"49\":2,\"75\":1,\"80\":1,\"96\":1,\"100\":2,\"101\":2,\"102\":5,\"103\":2,\"104\":2,\"105\":2,\"108\":1,\"111\":2,\"112\":1,\"115\":6,\"118\":1,\"122\":1,\"125\":1,\"126\":1,\"131\":2,\"134\":1,\"136\":1,\"177\":1,\"183\":1,\"186\":1,\"188\":1,\"194\":1,\"196\":1,\"198\":3,\"202\":1,\"216\":1,\"220\":1,\"225\":5,\"227\":1,\"228\":1,\"233\":1,\"242\":1,\"274\":1,\"275\":2,\"276\":1,\"278\":1,\"302\":2,\"327\":1,\"373\":1,\"378\":4,\"382\":1,\"383\":3,\"387\":2,\"389\":3,\"391\":2,\"395\":1,\"396\":2,\"426\":1}}],[\"thus\",{\"1\":{\"102\":1}}],[\"threshold\",{\"1\":{\"280\":5,\"287\":1}}],[\"three\",{\"1\":{\"142\":1,\"327\":4}}],[\"thread关联的state\",{\"1\":{\"396\":1}}],[\"thread进入safepoint并将优化后的代码绑定到方法上\",{\"1\":{\"396\":1}}],[\"thread可能在不同时间关联不同的osthread\",{\"1\":{\"392\":1}}],[\"thread便和这个osthread关联起来执行dart代码\",{\"1\":{\"392\":1}}],[\"thread用来执行dart\",{\"1\":{\"392\":1}}],[\"threadcontextelement\",{\"1\":{\"325\":1}}],[\"thread的join\",{\"1\":{\"297\":1}}],[\"thread的线程池中执行messagehandler\",{\"1\":{\"115\":1}}],[\"threadgroup\",{\"1\":{\"297\":1}}],[\"threadterminated\",{\"1\":{\"297\":3}}],[\"threadlocal深入分析\",{\"1\":{\"288\":1}}],[\"threadlocal<string\",{\"1\":{\"325\":1}}],[\"threadlocal<\",{\"1\":{\"288\":3}}],[\"threadlocals\",{\"1\":{\"288\":2}}],[\"threadlocal对象只是在thread所属的threadlocals中充当一个key\",{\"1\":{\"288\":1}}],[\"threadlocal2\",{\"1\":{\"288\":1}}],[\"threadlocalmap中\",{\"1\":{\"288\":1}}],[\"threadlocalmap\",{\"1\":{\"288\":5}}],[\"threadlocal\",{\"1\":{\"288\":13,\"325\":6}}],[\"threadlocal是thread中用来保存线程私有变量的数据结构\",{\"1\":{\"288\":1}}],[\"threaded\",{\"1\":{\"136\":1}}],[\"threadexitcallback\",{\"1\":{\"115\":1}}],[\"threadpool\",{\"1\":{\"115\":13,\"380\":1,\"386\":1,\"389\":4,\"390\":2,\"391\":4}}],[\"threadpoolexector\",{\"1\":{\"80\":1}}],[\"threadpoolexecutor\",{\"1\":{\"80\":5}}],[\"threadstartcallback\",{\"1\":{\"115\":1}}],[\"threadstart\",{\"1\":{\"115\":2}}],[\"threadstart线程要执行的方法指针\",{\"1\":{\"115\":1}}],[\"threadstartdata\",{\"1\":{\"115\":3}}],[\"threadstartfunction\",{\"1\":{\"115\":2}}],[\"threads\",{\"1\":{\"112\":1,\"115\":1,\"136\":3,\"382\":1,\"383\":1,\"390\":1,\"391\":1}}],[\"thread\",{\"1\":{\"24\":2,\"59\":1,\"72\":1,\"80\":5,\"87\":1,\"108\":2,\"115\":50,\"116\":1,\"136\":2,\"272\":4,\"288\":22,\"297\":3,\"324\":3,\"325\":2,\"327\":2,\"329\":1,\"345\":1,\"372\":1,\"376\":1,\"381\":1,\"382\":2,\"383\":8,\"384\":1,\"388\":1,\"389\":30,\"390\":1,\"391\":6,\"392\":1}}],[\"through\",{\"1\":{\"100\":1,\"372\":1,\"396\":1,\"426\":1}}],[\"throwisolatespawnexception\",{\"1\":{\"384\":1}}],[\"thrown\",{\"1\":{\"102\":1,\"196\":1,\"209\":1,\"272\":1}}],[\"throwable\",{\"1\":{\"72\":1,\"80\":1,\"341\":1,\"343\":1}}],[\"throws\",{\"1\":{\"35\":2,\"36\":4,\"40\":3,\"58\":3,\"72\":1,\"80\":1,\"102\":1,\"272\":1,\"280\":1,\"297\":2,\"305\":4,\"306\":3,\"309\":4,\"311\":2,\"322\":1,\"362\":1}}],[\"throw\",{\"1\":{\"24\":1,\"80\":4,\"99\":1,\"102\":2,\"103\":1,\"105\":2,\"111\":4,\"153\":1,\"186\":1,\"209\":1,\"211\":3,\"230\":1,\"297\":1,\"305\":1,\"309\":2,\"378\":1}}],[\"them\",{\"1\":{\"276\":1,\"327\":1,\"328\":1}}],[\"themes\",{\"1\":{\"415\":2}}],[\"themedata\",{\"1\":{\"132\":1}}],[\"theme\",{\"1\":{\"66\":1,\"132\":1,\"147\":1}}],[\"these\",{\"1\":{\"233\":1,\"395\":1,\"396\":2}}],[\"thestacktrace\",{\"1\":{\"102\":3}}],[\"their\",{\"1\":{\"136\":1,\"147\":3,\"212\":1,\"228\":1,\"277\":1,\"295\":1,\"372\":1}}],[\"theerror\",{\"1\":{\"102\":3}}],[\"they\",{\"1\":{\"75\":1,\"115\":1,\"125\":1,\"147\":1,\"186\":1,\"202\":1,\"322\":1,\"326\":1,\"383\":1,\"396\":1}}],[\"then只是对传入的回调的进行了包装\",{\"1\":{\"103\":1}}],[\"then<r>\",{\"1\":{\"103\":1}}],[\"then的实现\",{\"1\":{\"103\":1}}],[\"then\",{\"0\":{\"103\":1},\"1\":{\"49\":1,\"87\":1,\"95\":1,\"101\":2,\"102\":4,\"103\":2,\"110\":1,\"111\":6,\"115\":1,\"136\":1,\"180\":2,\"220\":4,\"272\":1,\"384\":1,\"391\":1,\"396\":2}}],[\"therefore\",{\"1\":{\"302\":1,\"383\":1}}],[\"thereof\",{\"1\":{\"111\":1}}],[\"there\",{\"1\":{\"13\":2,\"45\":1,\"80\":1,\"102\":1,\"108\":1,\"109\":1,\"115\":2,\"225\":1,\"226\":1,\"389\":1}}],[\"the\",{\"1\":{\"0\":1,\"1\":1,\"10\":1,\"14\":1,\"15\":14,\"40\":2,\"45\":3,\"49\":8,\"58\":2,\"59\":4,\"65\":1,\"75\":2,\"80\":8,\"86\":2,\"93\":1,\"96\":3,\"97\":2,\"98\":5,\"100\":5,\"101\":5,\"102\":22,\"103\":6,\"104\":6,\"105\":7,\"106\":5,\"108\":12,\"109\":14,\"111\":8,\"112\":10,\"114\":3,\"115\":33,\"118\":7,\"119\":3,\"120\":2,\"121\":3,\"125\":2,\"126\":1,\"130\":1,\"131\":7,\"136\":3,\"147\":7,\"152\":1,\"154\":4,\"155\":1,\"156\":4,\"158\":3,\"165\":3,\"176\":2,\"179\":6,\"180\":9,\"181\":6,\"185\":4,\"193\":3,\"195\":1,\"196\":2,\"198\":14,\"202\":4,\"209\":10,\"216\":4,\"220\":19,\"225\":10,\"226\":7,\"228\":3,\"233\":8,\"236\":2,\"242\":1,\"243\":1,\"272\":5,\"274\":2,\"275\":4,\"276\":1,\"277\":2,\"278\":5,\"279\":2,\"280\":1,\"281\":3,\"283\":3,\"288\":1,\"295\":2,\"297\":1,\"302\":7,\"305\":4,\"306\":3,\"308\":7,\"309\":1,\"314\":2,\"322\":2,\"327\":6,\"328\":1,\"372\":3,\"373\":5,\"376\":2,\"378\":21,\"379\":1,\"381\":1,\"382\":4,\"383\":19,\"384\":4,\"386\":3,\"387\":11,\"389\":22,\"390\":2,\"391\":30,\"392\":4,\"395\":1,\"396\":8,\"426\":4}}],[\"tisolate\",{\"1\":{\"383\":1}}],[\"tight模式的flexible\",{\"1\":{\"131\":1}}],[\"tight的话\",{\"1\":{\"131\":2}}],[\"tight\",{\"1\":{\"131\":2}}],[\"tid\",{\"1\":{\"115\":3}}],[\"tickerchannel\",{\"1\":{\"328\":6}}],[\"tickermode\",{\"1\":{\"176\":1,\"328\":1}}],[\"tickerfuture\",{\"1\":{\"161\":7,\"162\":2}}],[\"tickerproviderstatemixin\",{\"1\":{\"161\":1}}],[\"tickerprovider\",{\"1\":{\"161\":2,\"164\":1,\"168\":2}}],[\"ticker\",{\"1\":{\"157\":3,\"161\":5,\"162\":3,\"164\":1,\"168\":3,\"328\":2}}],[\"ticked\",{\"1\":{\"152\":1}}],[\"tick\",{\"0\":{\"163\":1},\"1\":{\"101\":2,\"109\":2,\"161\":2,\"162\":1,\"163\":1,\"168\":2}}],[\"tilemode\",{\"1\":{\"63\":1}}],[\"title\",{\"1\":{\"13\":1,\"132\":1,\"371\":3,\"400\":1,\"417\":1}}],[\"titleview可以用this\",{\"1\":{\"13\":1}}],[\"titleview为标题栏\",{\"1\":{\"13\":1}}],[\"timezone\",{\"1\":{\"417\":1}}],[\"timelineevent\",{\"1\":{\"387\":1}}],[\"timelinegetmicros\",{\"1\":{\"387\":1}}],[\"timelinebeginendscope\",{\"1\":{\"383\":1}}],[\"timeline\",{\"1\":{\"381\":1,\"383\":2,\"387\":1,\"388\":1}}],[\"timelinetask\",{\"1\":{\"198\":2}}],[\"timelimit\",{\"1\":{\"201\":1}}],[\"timestamp\",{\"1\":{\"216\":1}}],[\"times\",{\"1\":{\"198\":1,\"322\":3}}],[\"timeinseconds\",{\"1\":{\"166\":2,\"167\":4}}],[\"timeinmillis\",{\"1\":{\"5\":1,\"10\":2}}],[\"timeelapsestring\",{\"1\":{\"110\":1}}],[\"timeout=300\",{\"1\":{\"371\":1}}],[\"timeout\",{\"1\":{\"105\":1,\"106\":3,\"107\":1,\"109\":2,\"297\":1,\"370\":1,\"391\":1}}],[\"timeouts\",{\"1\":{\"105\":1}}],[\"timeunit\",{\"1\":{\"80\":1,\"362\":2}}],[\"time\",{\"1\":{\"11\":2,\"59\":1,\"75\":1,\"80\":1,\"102\":1,\"105\":1,\"106\":3,\"108\":3,\"110\":2,\"147\":1,\"156\":1,\"165\":4,\"180\":1,\"216\":2,\"275\":1,\"278\":1,\"281\":2,\"302\":10,\"327\":3,\"370\":6,\"391\":8,\"392\":2,\"396\":2}}],[\"timeretry\",{\"1\":{\"201\":1}}],[\"timer>\",{\"1\":{\"109\":2}}],[\"timerheap\",{\"1\":{\"106\":2}}],[\"timermillisecondclock\",{\"1\":{\"105\":1,\"108\":4,\"109\":1}}],[\"timers\",{\"1\":{\"105\":1,\"106\":4,\"108\":4,\"109\":10}}],[\"timerfactory创建的\",{\"1\":{\"105\":1}}],[\"timerfactory\",{\"1\":{\"105\":3}}],[\"timer的创建实际上是zone通过两种方式创建的\",{\"1\":{\"105\":1}}],[\"timer\",{\"0\":{\"104\":1,\"106\":1},\"1\":{\"3\":1,\"101\":10,\"102\":1,\"104\":9,\"105\":55,\"106\":16,\"107\":2,\"108\":1,\"109\":25,\"391\":1}}],[\"toindex\",{\"1\":{\"440\":7,\"441\":11}}],[\"tointarray\",{\"1\":{\"346\":2,\"437\":1,\"438\":1,\"462\":1}}],[\"toint\",{\"1\":{\"81\":1}}],[\"tocstring\",{\"1\":{\"391\":1}}],[\"tochararray\",{\"1\":{\"321\":1,\"453\":1}}],[\"toerrorcstring\",{\"1\":{\"383\":1}}],[\"tobiginteger\",{\"1\":{\"322\":2}}],[\"tobytearray\",{\"1\":{\"272\":1}}],[\"tobytedata等方法最终都是调用ui\",{\"1\":{\"195\":1}}],[\"tobytedata\",{\"1\":{\"194\":1,\"202\":1}}],[\"tohexstring\",{\"1\":{\"296\":1}}],[\"toherocontext\",{\"1\":{\"180\":2}}],[\"toheroes\",{\"1\":{\"180\":7}}],[\"toherolocation\",{\"1\":{\"177\":1,\"181\":1}}],[\"tohero\",{\"1\":{\"177\":4,\"180\":9,\"181\":2}}],[\"tohero两个\",{\"1\":{\"177\":1}}],[\"towards\",{\"1\":{\"220\":2,\"225\":1}}],[\"tolist\",{\"1\":{\"212\":2,\"226\":1,\"337\":1}}],[\"told\",{\"1\":{\"202\":1}}],[\"tolerance\",{\"1\":{\"165\":5}}],[\"toset\",{\"1\":{\"337\":1}}],[\"tosubtreecontext\",{\"1\":{\"180\":3}}],[\"tostringshort\",{\"1\":{\"147\":1}}],[\"tostring\",{\"1\":{\"143\":1,\"165\":1,\"185\":1,\"296\":1,\"306\":1,\"308\":1,\"311\":1,\"378\":3,\"422\":1,\"429\":1,\"453\":1}}],[\"to页面layout之后再开始\",{\"1\":{\"179\":1}}],[\"toroute\",{\"1\":{\"177\":3,\"179\":5,\"180\":1}}],[\"total\",{\"1\":{\"282\":2,\"370\":1}}],[\"totaltimeinseconds\",{\"1\":{\"167\":3}}],[\"totalpathlength\",{\"1\":{\"63\":2}}],[\"too\",{\"1\":{\"102\":1,\"112\":1,\"115\":1,\"216\":1,\"327\":1}}],[\"toolbar等组合起来控制fragment显示\",{\"1\":{\"400\":1}}],[\"toolbarheight\",{\"1\":{\"212\":1}}],[\"toolbar类\",{\"1\":{\"55\":1}}],[\"toolbar\",{\"1\":{\"55\":2}}],[\"tools=\",{\"1\":{\"400\":1,\"401\":1}}],[\"tools\",{\"1\":{\"0\":1,\"392\":1,\"396\":1,\"400\":2,\"401\":2}}],[\"todouble\",{\"1\":{\"163\":1,\"206\":2}}],[\"todo\",{\"1\":{\"69\":1,\"79\":5,\"82\":1,\"101\":1,\"111\":2,\"180\":1,\"211\":2,\"295\":2,\"345\":1,\"387\":1,\"391\":1,\"432\":1}}],[\"touppercase\",{\"1\":{\"64\":2,\"296\":1,\"321\":4,\"345\":1}}],[\"touchslop则代表认为滑动开始的最小距离\",{\"1\":{\"41\":1}}],[\"touchtarget\",{\"1\":{\"13\":4}}],[\"touches\",{\"1\":{\"13\":2}}],[\"touch\",{\"1\":{\"0\":1,\"13\":5,\"41\":2,\"198\":4,\"349\":1}}],[\"token\",{\"1\":{\"58\":1,\"407\":1}}],[\"tofilepath\",{\"1\":{\"349\":3}}],[\"tofloat\",{\"1\":{\"57\":2,\"81\":6}}],[\"toformattime\",{\"1\":{\"11\":1}}],[\"toast\",{\"1\":{\"56\":2,\"78\":2}}],[\"topologicalsort\",{\"1\":{\"438\":1}}],[\"toplevelfunction\",{\"1\":{\"378\":1}}],[\"topcenter\",{\"1\":{\"170\":2}}],[\"topics\",{\"1\":{\"58\":1}}],[\"top\",{\"1\":{\"15\":1,\"41\":4,\"181\":2,\"378\":1,\"389\":1,\"391\":1,\"441\":5}}],[\"to\",{\"0\":{\"248\":1},\"1\":{\"3\":1,\"10\":1,\"13\":5,\"15\":1,\"40\":1,\"49\":3,\"58\":1,\"59\":1,\"65\":1,\"75\":2,\"79\":1,\"80\":1,\"96\":1,\"97\":1,\"98\":2,\"100\":1,\"101\":2,\"102\":6,\"103\":4,\"104\":2,\"105\":2,\"106\":4,\"107\":2,\"108\":5,\"109\":3,\"111\":8,\"112\":2,\"115\":13,\"118\":1,\"120\":3,\"125\":1,\"126\":2,\"131\":2,\"136\":2,\"147\":6,\"153\":1,\"154\":2,\"156\":2,\"172\":1,\"176\":1,\"177\":1,\"179\":9,\"180\":8,\"185\":1,\"186\":2,\"194\":1,\"196\":2,\"198\":7,\"201\":1,\"202\":2,\"209\":5,\"213\":4,\"216\":2,\"220\":1,\"225\":1,\"226\":4,\"228\":2,\"233\":3,\"242\":2,\"243\":1,\"272\":1,\"276\":2,\"277\":1,\"278\":3,\"283\":1,\"287\":1,\"295\":2,\"297\":2,\"302\":1,\"306\":2,\"308\":3,\"309\":4,\"314\":1,\"316\":1,\"322\":5,\"327\":5,\"328\":4,\"345\":1,\"361\":1,\"369\":1,\"373\":2,\"376\":2,\"378\":2,\"379\":1,\"382\":4,\"383\":10,\"384\":2,\"386\":1,\"387\":2,\"389\":14,\"391\":16,\"392\":3,\"393\":1,\"396\":3,\"400\":1,\"414\":1,\"426\":1,\"459\":6}}],[\"wc\",{\"1\":{\"361\":1}}],[\"w可以查看用户相关信息\",{\"1\":{\"353\":1}}],[\"w\",{\"1\":{\"302\":2,\"351\":1,\"352\":2,\"361\":1,\"370\":1,\"371\":1}}],[\"w3cnote\",{\"1\":{\"281\":1}}],[\"wbmp\",{\"1\":{\"188\":1}}],[\"w4lle\",{\"1\":{\"116\":1}}],[\"wpx\",{\"1\":{\"81\":8}}],[\"wjtaigwh\",{\"1\":{\"61\":1}}],[\"writing\",{\"1\":{\"245\":1}}],[\"written\",{\"1\":{\"115\":1,\"392\":1}}],[\"writemessage\",{\"1\":{\"376\":1,\"389\":1}}],[\"writer\",{\"1\":{\"376\":1}}],[\"write操作和synchronize\",{\"1\":{\"317\":1}}],[\"writeenum\",{\"1\":{\"312\":1}}],[\"writeexternaldata方法中\",{\"1\":{\"312\":1}}],[\"writeexternaldata\",{\"1\":{\"312\":1}}],[\"writeexternal\",{\"1\":{\"311\":1,\"312\":3}}],[\"writelong\",{\"1\":{\"311\":1}}],[\"writeunshared\",{\"1\":{\"309\":1}}],[\"writeserialdata\",{\"1\":{\"312\":1}}],[\"writes\",{\"1\":{\"309\":2,\"312\":1}}],[\"writestring\",{\"1\":{\"40\":1,\"58\":1,\"312\":1}}],[\"writeclassdesc\",{\"1\":{\"309\":1}}],[\"writeclass\",{\"1\":{\"309\":1}}],[\"writehandle\",{\"1\":{\"309\":2}}],[\"writenull\",{\"1\":{\"309\":1}}],[\"writenoexception\",{\"1\":{\"40\":1,\"58\":1}}],[\"writefile\",{\"1\":{\"382\":1}}],[\"writefields\",{\"1\":{\"306\":2}}],[\"writefloat\",{\"1\":{\"311\":1}}],[\"writefatalexception\",{\"1\":{\"309\":2}}],[\"writefrom\",{\"1\":{\"115\":1}}],[\"writeint\",{\"1\":{\"280\":2,\"309\":1,\"311\":1,\"314\":1}}],[\"writeinterfacetoken\",{\"1\":{\"40\":1,\"58\":1}}],[\"writeordinaryobject方法中\",{\"1\":{\"312\":1}}],[\"writeordinaryobject\",{\"1\":{\"312\":1}}],[\"writeobject0\",{\"1\":{\"309\":3,\"312\":1}}],[\"writeobjectoverride\",{\"1\":{\"309\":1}}],[\"writeobject\",{\"1\":{\"280\":1,\"306\":3,\"308\":1,\"309\":3,\"311\":1}}],[\"writeonlyappend\",{\"1\":{\"111\":1}}],[\"writeonly\",{\"1\":{\"111\":1}}],[\"writearray\",{\"1\":{\"312\":1}}],[\"writeasbytes\",{\"1\":{\"201\":1}}],[\"writeapimessage\",{\"1\":{\"115\":1}}],[\"writebyte\",{\"1\":{\"115\":1,\"309\":1,\"312\":1}}],[\"writetoparcel\",{\"1\":{\"314\":1}}],[\"writetoblocking\",{\"1\":{\"108\":2}}],[\"writetypedlist\",{\"1\":{\"58\":1}}],[\"write\",{\"1\":{\"2\":3,\"108\":1,\"111\":1,\"272\":1,\"280\":1,\"308\":1,\"370\":1,\"371\":9,\"382\":1}}],[\"wrote\",{\"1\":{\"108\":1}}],[\"wrongconstant\",{\"1\":{\"56\":1}}],[\"wraprequestbody\",{\"1\":{\"364\":1}}],[\"wrappedrequestbody\",{\"1\":{\"364\":2}}],[\"wrapper\",{\"1\":{\"193\":1,\"283\":1}}],[\"wrapping\",{\"1\":{\"117\":1}}],[\"wrap\",{\"1\":{\"56\":2,\"65\":2,\"66\":2,\"79\":2}}],[\"were\",{\"1\":{\"378\":1,\"384\":1,\"395\":1,\"396\":1}}],[\"weeks\",{\"1\":{\"302\":2}}],[\"week\",{\"1\":{\"302\":15}}],[\"weakreference<threadlocal<\",{\"1\":{\"288\":1}}],[\"weakreference<textureregistry>\",{\"1\":{\"211\":1}}],[\"website\",{\"1\":{\"308\":1}}],[\"webp\",{\"1\":{\"188\":2}}],[\"webviewclient\",{\"1\":{\"42\":2}}],[\"webview\",{\"1\":{\"42\":2}}],[\"welcome\",{\"1\":{\"79\":1,\"243\":1}}],[\"wenku\",{\"1\":{\"63\":1}}],[\"weight分别为1\",{\"1\":{\"74\":1}}],[\"weight\",{\"0\":{\"74\":1},\"1\":{\"56\":6,\"74\":1,\"183\":1}}],[\"weightgroup\",{\"1\":{\"56\":4}}],[\"we\",{\"1\":{\"49\":3,\"96\":1,\"98\":3,\"101\":3,\"102\":4,\"104\":2,\"106\":1,\"107\":1,\"108\":4,\"109\":2,\"111\":1,\"112\":4,\"115\":5,\"126\":1,\"179\":3,\"180\":3,\"181\":1,\"198\":8,\"202\":2,\"216\":2,\"220\":10,\"221\":1,\"225\":5,\"226\":1,\"327\":3,\"378\":3,\"382\":1,\"383\":10,\"384\":1,\"386\":1,\"389\":2,\"390\":2,\"391\":25}}],[\"wow64\",{\"1\":{\"370\":1}}],[\"would\",{\"1\":{\"102\":1,\"198\":1,\"383\":1,\"387\":1}}],[\"woshiwoshiyu\",{\"1\":{\"35\":1}}],[\"words\",{\"1\":{\"220\":1}}],[\"worry\",{\"1\":{\"136\":1,\"180\":1}}],[\"workrequest\",{\"1\":{\"404\":2}}],[\"working\",{\"1\":{\"372\":1}}],[\"work\",{\"1\":{\"136\":1,\"326\":1,\"382\":1,\"396\":1}}],[\"workspace\",{\"1\":{\"373\":1}}],[\"works\",{\"1\":{\"127\":1}}],[\"worker从线程池中的取出任务执行\",{\"1\":{\"391\":1}}],[\"worker有两种情况\",{\"1\":{\"391\":1}}],[\"worker调用threadpool\",{\"1\":{\"391\":1}}],[\"worker会从task\",{\"1\":{\"391\":1}}],[\"workerlist\",{\"1\":{\"391\":1}}],[\"workerloop\",{\"1\":{\"391\":1}}],[\"worker的threadpool\",{\"1\":{\"390\":1}}],[\"workers\",{\"1\":{\"115\":4,\"390\":3,\"391\":8}}],[\"worker\",{\"0\":{\"391\":1},\"1\":{\"115\":37,\"389\":10,\"390\":7,\"391\":18,\"404\":2}}],[\"workerthread\",{\"1\":{\"80\":1}}],[\"workerrunnable<params\",{\"1\":{\"80\":1}}],[\"workmanager用来管理即时或定时任务\",{\"1\":{\"404\":1}}],[\"workmanager管理任务\",{\"0\":{\"404\":1}}],[\"workmanager主要倾向于保证任务在app退出\",{\"1\":{\"3\":1}}],[\"workmanager和alarmmanager则在app退出之后也可以使用\",{\"1\":{\"3\":1}}],[\"workmanager\",{\"1\":{\"3\":1,\"404\":1}}],[\"world\",{\"0\":{\"243\":1},\"1\":{\"0\":1,\"43\":1,\"79\":1,\"95\":1,\"272\":3,\"408\":1}}],[\"why\",{\"1\":{\"228\":1,\"280\":1,\"281\":1}}],[\"white\",{\"1\":{\"143\":1}}],[\"which\",{\"1\":{\"109\":1,\"112\":1,\"115\":2,\"147\":17,\"154\":12,\"198\":1,\"212\":1,\"220\":1,\"234\":1,\"322\":1,\"357\":1,\"383\":2,\"391\":3,\"392\":2,\"396\":3,\"426\":1}}],[\"while\",{\"1\":{\"102\":2,\"108\":1,\"111\":1,\"112\":1,\"115\":2,\"127\":1,\"272\":1,\"289\":1,\"297\":2,\"328\":1,\"369\":1,\"370\":1,\"378\":1,\"391\":7,\"432\":2,\"437\":1,\"438\":3,\"440\":1,\"441\":1,\"451\":1,\"459\":3,\"462\":1,\"467\":3}}],[\"whether\",{\"1\":{\"98\":1,\"165\":1}}],[\"whereas\",{\"1\":{\"322\":1}}],[\"wherever\",{\"1\":{\"220\":1}}],[\"where\",{\"1\":{\"49\":1,\"105\":2,\"179\":1,\"202\":1,\"209\":1,\"216\":1,\"281\":1,\"369\":2,\"383\":1}}],[\"whenever\",{\"1\":{\"147\":1,\"391\":1}}],[\"whencomplete\",{\"1\":{\"111\":2}}],[\"when\",{\"1\":{\"41\":1,\"49\":1,\"63\":1,\"69\":1,\"78\":1,\"100\":1,\"103\":2,\"115\":1,\"118\":2,\"147\":1,\"180\":2,\"185\":1,\"193\":3,\"196\":1,\"198\":1,\"243\":1,\"308\":1,\"321\":1,\"322\":1,\"327\":2,\"334\":1,\"383\":1,\"387\":1,\"389\":4,\"391\":2,\"396\":1,\"451\":1}}],[\"what\",{\"1\":{\"20\":3,\"49\":1,\"72\":1,\"80\":1,\"127\":1,\"133\":1,\"180\":1,\"302\":1,\"316\":1}}],[\"who\",{\"1\":{\"0\":1,\"294\":1,\"353\":1}}],[\"wzhttps\",{\"1\":{\"15\":1}}],[\"www\",{\"1\":{\"15\":2,\"41\":3,\"55\":1,\"58\":5,\"59\":2,\"61\":1,\"111\":1,\"281\":1,\"282\":1,\"286\":1,\"291\":1,\"306\":1,\"309\":1,\"346\":1,\"347\":1,\"362\":2,\"370\":2,\"371\":1,\"372\":2,\"407\":1,\"458\":1}}],[\"warm\",{\"1\":{\"396\":1}}],[\"watch\",{\"1\":{\"372\":2}}],[\"watermark\",{\"1\":{\"58\":1}}],[\"ways\",{\"1\":{\"392\":1}}],[\"way\",{\"1\":{\"225\":1,\"327\":2}}],[\"wake\",{\"1\":{\"106\":1,\"108\":1}}],[\"wakeuphandler\",{\"1\":{\"108\":2}}],[\"wakeups\",{\"1\":{\"108\":1}}],[\"wakeuptime\",{\"1\":{\"105\":3,\"106\":3,\"108\":7,\"109\":2}}],[\"wakeup\",{\"1\":{\"4\":2,\"5\":1,\"10\":1,\"11\":1,\"106\":2,\"108\":2,\"109\":1}}],[\"waitmicros\",{\"1\":{\"391\":1}}],[\"wait和future\",{\"1\":{\"102\":1}}],[\"waiting\",{\"1\":{\"102\":1,\"297\":1,\"327\":1}}],[\"wait<t>\",{\"1\":{\"102\":1}}],[\"wait\",{\"1\":{\"101\":3,\"297\":2,\"327\":1,\"383\":1}}],[\"waitforinjectclass\",{\"1\":{\"91\":2,\"93\":2}}],[\"want\",{\"1\":{\"49\":1,\"202\":1,\"391\":2}}],[\"wants\",{\"1\":{\"13\":1}}],[\"wassynchronouslyloaded\",{\"1\":{\"192\":2,\"193\":1}}],[\"wasn\",{\"1\":{\"49\":1}}],[\"was\",{\"1\":{\"13\":2,\"102\":1,\"115\":1,\"180\":5,\"198\":2,\"209\":1,\"220\":1,\"383\":4,\"391\":1,\"396\":1}}],[\"win32\",{\"1\":{\"413\":1}}],[\"windows下可以运行start\",{\"1\":{\"368\":1}}],[\"windows\",{\"1\":{\"112\":1,\"370\":1,\"408\":1,\"411\":1,\"413\":1,\"419\":1}}],[\"windowbackground\",{\"1\":{\"66\":1}}],[\"windowbackground使背景透明\",{\"1\":{\"66\":1}}],[\"windowmanager\",{\"1\":{\"41\":5,\"81\":4}}],[\"window\",{\"1\":{\"13\":2,\"81\":1,\"118\":2}}],[\"wire\",{\"1\":{\"309\":1}}],[\"wiki\",{\"1\":{\"302\":1}}],[\"wikipedia\",{\"1\":{\"87\":1,\"302\":1}}],[\"widthconstraints\",{\"1\":{\"238\":1}}],[\"widthfactor\",{\"1\":{\"117\":2,\"122\":9,\"125\":2}}],[\"widthpixels\",{\"1\":{\"81\":1}}],[\"widthsize\",{\"1\":{\"65\":3}}],[\"widthmode\",{\"1\":{\"65\":3}}],[\"widthmeasurespec\",{\"1\":{\"65\":7}}],[\"width\",{\"1\":{\"57\":1,\"64\":4,\"81\":1,\"117\":1,\"131\":7,\"172\":4,\"173\":1,\"176\":4,\"190\":2,\"192\":1,\"193\":2,\"206\":9,\"207\":2,\"210\":12,\"211\":5,\"238\":3,\"239\":2}}],[\"width=\",{\"1\":{\"56\":2,\"66\":2,\"79\":5,\"400\":1,\"401\":1}}],[\"width=1080\",{\"1\":{\"53\":2}}],[\"widget要展示在屏幕上需要经历build\",{\"1\":{\"238\":1}}],[\"widget其底层逻辑依然是对scrollable的封装\",{\"1\":{\"234\":1}}],[\"widget根据实现方式的不同\",{\"1\":{\"234\":1}}],[\"widgetbuilder\",{\"1\":{\"181\":1}}],[\"widget等出错会打印exception\",{\"1\":{\"143\":1}}],[\"widget$\",{\"1\":{\"143\":1}}],[\"widget在build时出错的话\",{\"1\":{\"143\":1}}],[\"widget一旦生成便\",{\"1\":{\"132\":1}}],[\"widget和android中的view很相似但又有不同\",{\"1\":{\"132\":1}}],[\"widget简单入门\",{\"0\":{\"132\":1}}],[\"widget>\",{\"1\":{\"129\":1}}],[\"widget都重建了\",{\"1\":{\"128\":1}}],[\"widget是配置信息\",{\"1\":{\"128\":1}}],[\"widget分为多个种类\",{\"1\":{\"126\":1}}],[\"widget创建\",{\"1\":{\"126\":1}}],[\"widget才真正对应着我们在runapp里面传入的center\",{\"1\":{\"125\":1}}],[\"widget对应的element\",{\"1\":{\"125\":1}}],[\"widget对应的renderobject\",{\"1\":{\"124\":1}}],[\"widget中\",{\"1\":{\"122\":1}}],[\"widget的滑动效果\",{\"1\":{\"240\":1}}],[\"widget的原因\",{\"1\":{\"213\":1}}],[\"widget的noname不一致\",{\"1\":{\"130\":1}}],[\"widget的\",{\"1\":{\"122\":1}}],[\"widget通过renderobjecttowidgetelement\",{\"1\":{\"122\":1}}],[\"widget及其child\",{\"1\":{\"120\":1}}],[\"widget绑定到renderview\",{\"1\":{\"117\":1}}],[\"widgetsapp\",{\"1\":{\"178\":1,\"181\":1}}],[\"widgetsbinding的scheduleattachrootwidget\",{\"1\":{\"119\":1}}],[\"widgetsbinding\",{\"1\":{\"118\":4,\"119\":1,\"120\":1,\"179\":1}}],[\"widgetsflutterbinding作为将flutter\",{\"1\":{\"127\":1}}],[\"widgetsflutterbinding\",{\"0\":{\"118\":1},\"1\":{\"117\":1,\"118\":2}}],[\"widgets\",{\"1\":{\"117\":1,\"118\":1,\"119\":2,\"120\":1,\"121\":3,\"122\":3,\"125\":3,\"126\":4,\"127\":7,\"136\":1,\"143\":1,\"146\":1,\"157\":1,\"172\":1,\"228\":1,\"233\":1}}],[\"widget\",{\"0\":{\"125\":1,\"228\":1},\"1\":{\"41\":1,\"55\":12,\"79\":8,\"117\":2,\"119\":3,\"120\":1,\"121\":5,\"122\":6,\"125\":10,\"126\":13,\"127\":5,\"128\":4,\"130\":15,\"131\":5,\"132\":3,\"133\":2,\"134\":1,\"135\":1,\"143\":6,\"146\":10,\"147\":6,\"150\":3,\"152\":4,\"153\":8,\"154\":5,\"155\":11,\"156\":6,\"157\":10,\"169\":2,\"170\":2,\"171\":5,\"172\":2,\"174\":2,\"175\":1,\"176\":12,\"177\":4,\"178\":3,\"180\":5,\"181\":4,\"182\":1,\"188\":2,\"190\":6,\"191\":2,\"193\":23,\"194\":1,\"198\":1,\"205\":9,\"206\":19,\"207\":14,\"212\":8,\"213\":14,\"217\":1,\"223\":1,\"227\":14,\"228\":3,\"230\":2,\"233\":6,\"234\":2,\"235\":3,\"237\":1,\"240\":1,\"242\":1,\"401\":2}}],[\"willnotdraw\",{\"1\":{\"65\":2}}],[\"will\",{\"1\":{\"49\":1,\"65\":1,\"96\":1,\"101\":3,\"103\":3,\"104\":2,\"108\":4,\"109\":2,\"111\":2,\"112\":1,\"115\":4,\"118\":1,\"126\":1,\"153\":1,\"179\":1,\"193\":1,\"198\":2,\"209\":1,\"225\":1,\"226\":2,\"242\":1,\"327\":3,\"378\":2,\"382\":1,\"383\":6,\"389\":1,\"390\":1,\"391\":4,\"426\":1}}],[\"withcontext\",{\"1\":{\"322\":1,\"324\":1,\"334\":1}}],[\"without\",{\"1\":{\"115\":1,\"396\":1}}],[\"within\",{\"1\":{\"13\":1,\"295\":1,\"396\":1}}],[\"with\",{\"1\":{\"0\":1,\"15\":1,\"20\":1,\"34\":1,\"48\":1,\"52\":1,\"58\":1,\"75\":2,\"101\":2,\"102\":1,\"103\":2,\"105\":1,\"106\":3,\"108\":1,\"111\":1,\"112\":1,\"114\":1,\"115\":2,\"118\":1,\"127\":1,\"128\":1,\"130\":1,\"133\":1,\"136\":1,\"140\":1,\"147\":1,\"152\":1,\"158\":1,\"160\":1,\"179\":1,\"180\":1,\"181\":1,\"183\":1,\"192\":1,\"201\":2,\"202\":1,\"211\":1,\"212\":1,\"226\":1,\"229\":1,\"237\":1,\"272\":1,\"274\":1,\"288\":1,\"302\":1,\"306\":1,\"314\":1,\"316\":1,\"327\":2,\"330\":1,\"372\":2,\"378\":4,\"384\":1,\"387\":2,\"396\":3}}],[\"a的左子节点c的右子节点d\",{\"1\":{\"458\":1}}],[\"ahead\",{\"1\":{\"392\":1}}],[\"ahr0cdovl2jsb2cuy3nkbi5uzxqv\",{\"1\":{\"58\":1}}],[\"aot编译出的代码和runtime会使用jit中用到的内联缓存\",{\"1\":{\"397\":1}}],[\"aot编译依然可能包含一些无法被非虚拟化\",{\"1\":{\"397\":1}}],[\"aot中\",{\"1\":{\"396\":1}}],[\"aot上述这些分析是保守的\",{\"1\":{\"396\":1}}],[\"aot汇编过程会进行全局静态分析以确定程序的哪些部分是可以从已知的entry\",{\"1\":{\"396\":1}}],[\"aot启动时间更短\",{\"1\":{\"396\":1}}],[\"aot与jit各有优劣\",{\"1\":{\"396\":1}}],[\"aot\",{\"1\":{\"387\":2,\"392\":2,\"396\":3}}],[\"a以上所有\",{\"1\":{\"351\":1}}],[\"aefdhzmg\",{\"1\":{\"346\":1}}],[\"aes也可以替换为\",{\"1\":{\"296\":1}}],[\"aes\",{\"1\":{\"296\":7}}],[\"aalong=100\",{\"1\":{\"309\":2}}],[\"aaaaaaaty\",{\"1\":{\"61\":1}}],[\"air\",{\"1\":{\"395\":1}}],[\"ainitname\",{\"1\":{\"295\":1}}],[\"aidlbinderinterface\",{\"1\":{\"58\":15}}],[\"aidl从客户端\",{\"1\":{\"40\":2}}],[\"aidl是android中用于ipc的语言\",{\"1\":{\"40\":1}}],[\"aidl的权限验证\",{\"0\":{\"39\":1}}],[\"aidl不支持方法重载\",{\"1\":{\"34\":1}}],[\"aidl中只支持方法\",{\"1\":{\"34\":1}}],[\"aidl中除了基本数据类型\",{\"1\":{\"34\":1}}],[\"aidl中用到的parcelable对象必须新建一个同名aidl接口\",{\"1\":{\"34\":1}}],[\"aidl对象必须显示import\",{\"1\":{\"34\":1}}],[\"aidl接口\",{\"1\":{\"33\":1}}],[\"aidl\",{\"0\":{\"21\":1,\"35\":1},\"1\":{\"32\":1,\"34\":1,\"35\":2,\"40\":4,\"43\":4,\"58\":11,\"59\":1}}],[\"agrs\",{\"1\":{\"345\":1}}],[\"agent\",{\"1\":{\"370\":1}}],[\"age\",{\"1\":{\"295\":6,\"299\":1,\"321\":1,\"322\":4,\"369\":2}}],[\"against\",{\"1\":{\"378\":1}}],[\"again\",{\"1\":{\"45\":1,\"198\":1,\"202\":1,\"209\":1}}],[\"away\",{\"1\":{\"225\":1}}],[\"await\",{\"1\":{\"95\":1,\"135\":1,\"136\":3,\"196\":2,\"201\":11,\"209\":1,\"210\":1,\"211\":3,\"325\":1,\"329\":1,\"334\":1,\"373\":1,\"378\":3}}],[\"avoids\",{\"1\":{\"287\":1}}],[\"avoid\",{\"1\":{\"202\":1,\"209\":1,\"391\":2}}],[\"availablekey\",{\"1\":{\"437\":4,\"438\":3}}],[\"available\",{\"1\":{\"115\":1,\"131\":3,\"373\":1,\"390\":1}}],[\"afloat=\",{\"1\":{\"311\":1}}],[\"afloat\",{\"1\":{\"311\":4}}],[\"afun\",{\"1\":{\"134\":5,\"369\":2}}],[\"afterpoint\",{\"1\":{\"62\":2}}],[\"after\",{\"1\":{\"49\":1,\"97\":1,\"101\":1,\"102\":1,\"115\":1,\"126\":1,\"179\":1,\"226\":1,\"230\":1,\"288\":2,\"373\":1,\"383\":2,\"391\":1,\"396\":1,\"407\":1}}],[\"a00a5\",{\"1\":{\"117\":1,\"122\":1}}],[\"acquired\",{\"1\":{\"391\":2}}],[\"account\",{\"1\":{\"347\":1}}],[\"accept\",{\"1\":{\"103\":1}}],[\"access则说明成功连接\",{\"1\":{\"347\":1}}],[\"accessible\",{\"1\":{\"281\":1,\"307\":1,\"392\":1,\"426\":1}}],[\"accessed\",{\"1\":{\"115\":1}}],[\"access\",{\"1\":{\"78\":1,\"136\":2,\"295\":1,\"304\":1,\"372\":1,\"403\":1,\"426\":1}}],[\"acceleratedecelerateinterpolator\",{\"1\":{\"63\":1}}],[\"aclass\",{\"1\":{\"345\":1,\"369\":4}}],[\"across\",{\"1\":{\"134\":1}}],[\"actor<countermsg>\",{\"1\":{\"334\":1}}],[\"actors\",{\"1\":{\"334\":1}}],[\"actor\",{\"1\":{\"329\":1,\"334\":7}}],[\"actualnewpixels\",{\"1\":{\"220\":3,\"221\":4}}],[\"actually\",{\"1\":{\"180\":1,\"297\":1}}],[\"actual\",{\"1\":{\"115\":1,\"396\":1}}],[\"active\",{\"1\":{\"115\":1,\"121\":1,\"389\":1}}],[\"activities\",{\"1\":{\"59\":1,\"217\":1,\"425\":1}}],[\"activitymainbinding\",{\"1\":{\"401\":1}}],[\"activitymanagernative\",{\"1\":{\"72\":1}}],[\"activitymanager\",{\"1\":{\"58\":2}}],[\"activity间跳转\",{\"1\":{\"135\":1}}],[\"activityinjector\",{\"1\":{\"92\":2}}],[\"activityinfo\",{\"1\":{\"2\":1}}],[\"activity>\",{\"1\":{\"79\":1,\"300\":1}}],[\"activity或者发送广播\",{\"1\":{\"79\":1}}],[\"activitythreadhandlercallback核心代码\",{\"1\":{\"72\":1}}],[\"activitythreadhandlercallback\",{\"1\":{\"72\":2}}],[\"activitythread\",{\"1\":{\"72\":3}}],[\"activitythreadcls\",{\"1\":{\"72\":3}}],[\"activitycompat\",{\"1\":{\"69\":1}}],[\"activityconfigcallback\",{\"1\":{\"13\":1}}],[\"activity窗口焦点变化\",{\"1\":{\"65\":1}}],[\"activity销毁时\",{\"1\":{\"17\":1}}],[\"activity内有一个window对象\",{\"1\":{\"13\":1}}],[\"activity\",{\"1\":{\"7\":1,\"19\":1,\"56\":1,\"58\":1,\"65\":1,\"71\":1,\"79\":4,\"92\":1,\"93\":1,\"94\":1,\"135\":1,\"219\":2,\"225\":7,\"300\":5,\"326\":2,\"400\":2,\"401\":2,\"423\":1}}],[\"actiongardenfragmenttoplantdetailfragment\",{\"1\":{\"400\":1}}],[\"action定义了在各个界面的切换关系\",{\"1\":{\"400\":1}}],[\"actions\",{\"1\":{\"147\":1}}],[\"actionmasked\",{\"1\":{\"13\":2}}],[\"action\",{\"1\":{\"7\":2,\"8\":1,\"9\":1,\"10\":1,\"11\":3,\"12\":1,\"13\":17,\"64\":2,\"75\":2,\"78\":1,\"79\":1,\"400\":1}}],[\"ac811902db42a51cf97e3290788ade4a\",{\"1\":{\"95\":1}}],[\"ac\",{\"1\":{\"61\":1}}],[\"ambient\",{\"1\":{\"228\":1}}],[\"amount\",{\"1\":{\"220\":1}}],[\"am\",{\"1\":{\"58\":2,\"95\":6,\"101\":6,\"302\":3,\"369\":3}}],[\"aml4awfvew9uzze5otvaz21hawwuy29tcg==\",{\"1\":{\"0\":1}}],[\"a3\",{\"1\":{\"56\":2}}],[\"a284628487\",{\"1\":{\"58\":1,\"59\":1}}],[\"a2\",{\"1\":{\"56\":2}}],[\"a1\",{\"1\":{\"56\":2,\"458\":1}}],[\"axisdirection\",{\"1\":{\"227\":5,\"228\":11,\"231\":4,\"235\":6,\"236\":4,\"239\":6}}],[\"axis\",{\"1\":{\"55\":1,\"131\":2,\"223\":1,\"228\":3,\"236\":1,\"238\":9}}],[\"axes\",{\"1\":{\"55\":2}}],[\"abnormal\",{\"1\":{\"389\":1}}],[\"abnormally\",{\"1\":{\"389\":2}}],[\"abctags\",{\"1\":{\"417\":1}}],[\"abc\",{\"1\":{\"369\":4,\"424\":2,\"427\":1}}],[\"absolutepath\",{\"1\":{\"425\":1,\"426\":1}}],[\"absorb\",{\"0\":{\"219\":1},\"1\":{\"219\":3}}],[\"absorberhandle\",{\"1\":{\"213\":1}}],[\"abstractmap<k\",{\"1\":{\"287\":1}}],[\"abstract\",{\"1\":{\"40\":1,\"58\":1,\"90\":1,\"91\":2,\"105\":1,\"111\":1,\"118\":1,\"121\":1,\"125\":2,\"126\":1,\"127\":1,\"147\":2,\"152\":1,\"154\":1,\"158\":1,\"165\":1,\"186\":3,\"201\":1,\"211\":1,\"227\":1,\"229\":1,\"285\":1,\"364\":1}}],[\"able\",{\"1\":{\"106\":1,\"107\":1}}],[\"aborted\",{\"1\":{\"180\":1,\"181\":1}}],[\"abort\",{\"1\":{\"180\":3}}],[\"aborts\",{\"1\":{\"101\":1}}],[\"about\",{\"1\":{\"136\":1,\"177\":1,\"180\":1,\"225\":1,\"295\":1,\"316\":1,\"389\":1}}],[\"above\",{\"1\":{\"3\":1,\"100\":1,\"102\":1,\"220\":1,\"226\":1,\"383\":1}}],[\"ab\",{\"1\":{\"61\":1,\"372\":2}}],[\"adt\",{\"1\":{\"445\":1}}],[\"adapters支持更多形式的属性绑定\",{\"1\":{\"401\":1}}],[\"adapter等等\",{\"1\":{\"399\":1}}],[\"adefghmz\",{\"1\":{\"346\":1}}],[\"advanced\",{\"1\":{\"172\":1}}],[\"advancewakeuptime\",{\"1\":{\"109\":1}}],[\"ad\",{\"1\":{\"61\":1,\"302\":1}}],[\"adil\",{\"1\":{\"32\":1}}],[\"addassetpath\",{\"1\":{\"427\":4}}],[\"addonexitlistener\",{\"1\":{\"373\":1,\"376\":1}}],[\"addonlastlistenerremovedcallback\",{\"1\":{\"209\":1}}],[\"adderrorlistener\",{\"1\":{\"373\":1}}],[\"addelapsedtimefrom\",{\"1\":{\"272\":1}}],[\"added\",{\"1\":{\"109\":1,\"209\":1,\"389\":2}}],[\"addwithpaintoffset\",{\"1\":{\"240\":1}}],[\"addition\",{\"1\":{\"221\":1}}],[\"additional\",{\"1\":{\"147\":1,\"276\":1,\"391\":1}}],[\"adding\",{\"1\":{\"98\":1}}],[\"addpostframecallback\",{\"1\":{\"118\":1,\"179\":1,\"216\":1}}],[\"addpersistentframecallback\",{\"1\":{\"118\":1}}],[\"addpeople\",{\"1\":{\"35\":3,\"36\":1}}],[\"addtime\",{\"1\":{\"272\":1}}],[\"addthreadtolistlocked\",{\"1\":{\"115\":1}}],[\"addtouchtarget\",{\"1\":{\"13\":3}}],[\"addread\",{\"1\":{\"111\":2}}],[\"addstatuslistener\",{\"1\":{\"158\":1,\"168\":1}}],[\"adds\",{\"1\":{\"106\":1}}],[\"addsource\",{\"1\":{\"78\":2}}],[\"addlistener\",{\"1\":{\"103\":5,\"152\":1,\"155\":2,\"158\":1,\"168\":1,\"181\":1,\"191\":1,\"198\":1,\"237\":2}}],[\"addupdatelistener\",{\"1\":{\"63\":1}}],[\"add\",{\"1\":{\"36\":2,\"57\":1,\"105\":1,\"106\":1,\"111\":1,\"112\":3,\"209\":1,\"211\":1,\"226\":1,\"292\":2,\"293\":3,\"347\":5,\"370\":1,\"383\":2,\"391\":1,\"407\":1,\"422\":1,\"438\":1,\"462\":1}}],[\"addflags\",{\"1\":{\"2\":2}}],[\"authenticated\",{\"1\":{\"347\":1}}],[\"author\",{\"1\":{\"81\":1,\"308\":1,\"417\":1}}],[\"authorities=\",{\"1\":{\"2\":1}}],[\"automatic\",{\"1\":{\"417\":1}}],[\"automaticpackageresolution\",{\"1\":{\"378\":2}}],[\"automatically\",{\"1\":{\"118\":1,\"147\":2}}],[\"auto\",{\"1\":{\"17\":1,\"19\":2,\"35\":1,\"40\":1,\"56\":1,\"58\":1,\"79\":5,\"115\":2,\"287\":1,\"295\":2,\"380\":1,\"381\":4,\"382\":3,\"383\":3,\"386\":2,\"387\":1,\"388\":1,\"389\":22,\"390\":1,\"391\":2,\"400\":1,\"401\":2,\"407\":1}}],[\"arm\",{\"1\":{\"392\":1}}],[\"arch\",{\"1\":{\"383\":3}}],[\"archive\",{\"1\":{\"111\":1}}],[\"arr2\",{\"1\":{\"459\":2}}],[\"arr\",{\"1\":{\"289\":39,\"291\":1,\"321\":2,\"433\":1,\"460\":1}}],[\"arra10\",{\"1\":{\"282\":1}}],[\"arraystoreexception呢\",{\"1\":{\"291\":1}}],[\"array<int>\",{\"1\":{\"327\":1}}],[\"array<in\",{\"1\":{\"322\":1}}],[\"array<aparcelable\",{\"1\":{\"314\":1}}],[\"array<string>\",{\"1\":{\"272\":1,\"322\":1,\"345\":1}}],[\"array<out\",{\"1\":{\"69\":1,\"322\":1}}],[\"arraydeque<runnable>\",{\"1\":{\"80\":2}}],[\"arrayofnulls\",{\"1\":{\"314\":1}}],[\"arrayof\",{\"1\":{\"69\":1,\"322\":2,\"345\":1}}],[\"array\",{\"1\":{\"45\":3,\"49\":1,\"56\":4,\"115\":1,\"272\":1,\"275\":1,\"305\":2,\"314\":2,\"376\":1,\"377\":3,\"389\":7,\"450\":1,\"451\":7}}],[\"arraymap其特性与sparsearray类似\",{\"1\":{\"287\":1}}],[\"arraymap\",{\"0\":{\"287\":1},\"1\":{\"52\":2}}],[\"arraymap特殊之处在于将key\",{\"1\":{\"49\":1}}],[\"arraymap实现了map<k\",{\"1\":{\"49\":1}}],[\"arraymap则支持所有类型的key\",{\"1\":{\"44\":1}}],[\"arraymap<ibinder\",{\"1\":{\"36\":2}}],[\"arraylistof<int>\",{\"1\":{\"462\":1}}],[\"arraylistof<string>\",{\"1\":{\"321\":1}}],[\"arraylistof\",{\"1\":{\"422\":2}}],[\"arraylist<t\",{\"1\":{\"438\":1}}],[\"arraylist<packageinfo>\",{\"1\":{\"422\":2}}],[\"arraylist<packageinfobean>\",{\"1\":{\"422\":1}}],[\"arraylist<apple>\",{\"1\":{\"291\":1,\"292\":1}}],[\"arraylist<v>\",{\"1\":{\"291\":1}}],[\"arraylist<>\",{\"1\":{\"35\":1,\"36\":1,\"211\":1}}],[\"arraylist具体实现的构造函数如下\",{\"1\":{\"291\":1}}],[\"arraylist\",{\"1\":{\"33\":1,\"35\":1,\"36\":1,\"291\":1}}],[\"arr1\",{\"1\":{\"282\":1,\"459\":2}}],[\"arr1大小\",{\"1\":{\"282\":2}}],[\"arr0\",{\"1\":{\"282\":1}}],[\"arr0大小\",{\"1\":{\"282\":1}}],[\"arbitrarily\",{\"1\":{\"225\":1}}],[\"arbitrary\",{\"1\":{\"225\":1}}],[\"artificially\",{\"1\":{\"220\":1}}],[\"article\",{\"1\":{\"15\":4,\"35\":1,\"40\":1,\"41\":1,\"54\":2,\"58\":6,\"59\":1,\"63\":1,\"115\":1,\"273\":1,\"279\":1,\"283\":1,\"287\":1,\"288\":1,\"294\":1}}],[\"argtype=\",{\"1\":{\"400\":1}}],[\"argv\",{\"1\":{\"382\":1}}],[\"argc\",{\"1\":{\"382\":1}}],[\"arg1\",{\"1\":{\"369\":1}}],[\"arg0\",{\"1\":{\"369\":1}}],[\"arg\",{\"1\":{\"211\":2,\"310\":1,\"322\":1,\"369\":4}}],[\"argument定义了在切换界面时需要带的参数\",{\"1\":{\"400\":1}}],[\"argument\",{\"1\":{\"115\":1,\"185\":1,\"376\":2,\"378\":1}}],[\"arguments\",{\"1\":{\"103\":1,\"156\":1,\"198\":1,\"211\":20,\"233\":1,\"376\":2,\"378\":1,\"384\":1,\"389\":2}}],[\"argumenterror\",{\"1\":{\"102\":1,\"103\":1,\"111\":3,\"378\":1}}],[\"args在两个fragment之间传递数据\",{\"1\":{\"400\":1}}],[\"args或message作为参数\",{\"1\":{\"373\":1}}],[\"args>\",{\"1\":{\"115\":1}}],[\"args\",{\"1\":{\"72\":6,\"85\":1,\"86\":4,\"87\":2,\"100\":3,\"108\":7,\"114\":3,\"115\":6,\"272\":1,\"281\":1,\"282\":2,\"295\":1,\"308\":1,\"322\":1,\"345\":4,\"369\":4,\"373\":1,\"378\":4,\"389\":14,\"391\":2,\"402\":1}}],[\"areflect\",{\"1\":{\"295\":1}}],[\"area\",{\"0\":{\"254\":1}}],[\"are\",{\"1\":{\"13\":2,\"75\":1,\"98\":2,\"99\":1,\"102\":3,\"105\":1,\"106\":3,\"108\":4,\"109\":2,\"115\":5,\"127\":1,\"136\":2,\"179\":1,\"180\":1,\"220\":7,\"225\":1,\"226\":1,\"277\":1,\"281\":1,\"322\":2,\"327\":4,\"368\":1,\"373\":1,\"376\":1,\"383\":2,\"389\":4,\"391\":2,\"396\":4}}],[\"analysis\",{\"1\":{\"373\":1}}],[\"analytics\",{\"1\":{\"54\":1}}],[\"aname\",{\"1\":{\"321\":1}}],[\"anisolate\",{\"1\":{\"378\":1}}],[\"anint=10\",{\"1\":{\"308\":1,\"309\":2}}],[\"anint=\",{\"1\":{\"308\":1,\"311\":1}}],[\"anint\",{\"1\":{\"308\":2,\"311\":4}}],[\"animal>\",{\"1\":{\"322\":1}}],[\"animatable<double>\",{\"1\":{\"183\":2,\"185\":2}}],[\"animatable<t>的子类\",{\"1\":{\"183\":1}}],[\"animatable<t>\",{\"1\":{\"183\":4,\"184\":1}}],[\"animatable<u>从\",{\"1\":{\"168\":1}}],[\"animatable<u>\",{\"1\":{\"158\":1,\"168\":1}}],[\"animatable\",{\"0\":{\"183\":1},\"1\":{\"158\":1,\"182\":3,\"183\":11,\"184\":3,\"186\":3}}],[\"animating\",{\"1\":{\"147\":1}}],[\"animationwithparentmixin<double>\",{\"1\":{\"183\":1}}],[\"animation和createherorecttween方法\",{\"1\":{\"177\":1}}],[\"animations的示意图\",{\"1\":{\"173\":1}}],[\"animations\",{\"0\":{\"170\":1,\"172\":1},\"1\":{\"181\":1}}],[\"animationstatus\",{\"1\":{\"158\":1,\"162\":2,\"163\":2,\"181\":3}}],[\"animationdirection\",{\"1\":{\"162\":1,\"163\":1,\"167\":2}}],[\"animationdrawable\",{\"1\":{\"66\":4}}],[\"animationdrawable等实现一个透明背景的\",{\"1\":{\"66\":1}}],[\"animationbehavior\",{\"1\":{\"161\":2}}],[\"animationbuilder\",{\"1\":{\"156\":1}}],[\"animationlocalstatuslistenersmixin\",{\"1\":{\"160\":1}}],[\"animationlocallistenersmixin\",{\"1\":{\"160\":1}}],[\"animationeagerlistenermixin\",{\"1\":{\"160\":1}}],[\"animationmin<t\",{\"1\":{\"159\":1}}],[\"animationmax<t\",{\"1\":{\"159\":1}}],[\"animationmean\",{\"1\":{\"159\":1}}],[\"animation<u>\",{\"1\":{\"158\":2}}],[\"animation<t>的接口\",{\"1\":{\"159\":1}}],[\"animation<t>\",{\"1\":{\"158\":1,\"159\":2,\"182\":2,\"183\":2,\"186\":1}}],[\"animation<double>创建\",{\"1\":{\"185\":1}}],[\"animation<double>对象作为parent\",{\"1\":{\"183\":1}}],[\"animation<double>生产\",{\"1\":{\"182\":1}}],[\"animation<double>的\",{\"1\":{\"168\":1}}],[\"animation<double>继承的animation<u>\",{\"1\":{\"168\":1}}],[\"animation<double>\",{\"1\":{\"147\":3,\"155\":3,\"158\":3,\"159\":1,\"160\":1,\"177\":1,\"180\":1,\"181\":1,\"182\":3,\"183\":4,\"185\":1,\"186\":1}}],[\"animationcontroller\",{\"0\":{\"160\":1},\"1\":{\"146\":3,\"147\":5,\"150\":1,\"152\":3,\"154\":1,\"155\":1,\"156\":2,\"157\":8,\"159\":1,\"160\":2,\"161\":8,\"162\":2,\"165\":2,\"168\":5,\"182\":7,\"184\":1,\"186\":1}}],[\"animation\",{\"0\":{\"158\":1},\"1\":{\"63\":2,\"66\":1,\"146\":1,\"147\":6,\"150\":2,\"152\":4,\"153\":1,\"154\":2,\"156\":6,\"157\":6,\"158\":10,\"159\":13,\"160\":2,\"161\":2,\"168\":3,\"170\":2,\"172\":3,\"177\":3,\"179\":5,\"180\":2,\"181\":9,\"182\":3,\"183\":7,\"184\":1,\"185\":1}}],[\"animatee\",{\"1\":{\"186\":1}}],[\"animatewith\",{\"1\":{\"161\":1,\"168\":1}}],[\"animateback\",{\"1\":{\"161\":1,\"168\":2,\"182\":1,\"186\":1}}],[\"animateto等方法修改了scrollposition的时候\",{\"1\":{\"237\":1}}],[\"animatetointernal\",{\"1\":{\"161\":1}}],[\"animateto\",{\"1\":{\"161\":1,\"168\":2,\"182\":1,\"186\":1,\"212\":1,\"223\":1,\"225\":1}}],[\"animates\",{\"1\":{\"147\":3,\"154\":4}}],[\"animate\",{\"1\":{\"147\":2,\"158\":1,\"172\":1,\"181\":1,\"182\":1,\"183\":2}}],[\"animatedevaluation<t>\",{\"1\":{\"183\":2}}],[\"animatedevaluation\",{\"1\":{\"182\":1,\"183\":2}}],[\"animatedmodalbarrier\",{\"1\":{\"154\":1}}],[\"animatedcrossfade\",{\"1\":{\"147\":1}}],[\"animatedcontainer\",{\"1\":{\"147\":1}}],[\"animatedtheme\",{\"1\":{\"147\":1}}],[\"animatedpositioneddirectional\",{\"1\":{\"147\":1}}],[\"animatedpositioned\",{\"1\":{\"147\":1}}],[\"animatedphysicalmodel\",{\"1\":{\"147\":1}}],[\"animatedpaddingstate\",{\"1\":{\"152\":2}}],[\"animatedpadding\",{\"1\":{\"147\":1,\"152\":1}}],[\"animatedopacity\",{\"1\":{\"147\":1}}],[\"animatedstate\",{\"0\":{\"155\":1},\"1\":{\"154\":1,\"155\":2}}],[\"animatedswitcher\",{\"1\":{\"147\":1}}],[\"animatedsize\",{\"1\":{\"147\":1}}],[\"animatedslide\",{\"1\":{\"147\":1}}],[\"animatedscale\",{\"1\":{\"147\":1}}],[\"animatedrotation\",{\"1\":{\"147\":1}}],[\"animateddefaulttextstyle\",{\"1\":{\"147\":1}}],[\"animatedalign\",{\"1\":{\"147\":1}}],[\"animated\",{\"1\":{\"146\":1,\"147\":11,\"154\":7,\"156\":1,\"157\":1,\"188\":2,\"216\":1}}],[\"animatedbuilder\",{\"0\":{\"156\":1},\"1\":{\"146\":2,\"154\":1,\"156\":6,\"157\":2,\"181\":1}}],[\"animatedwidget会监听turns的值变化\",{\"1\":{\"155\":1}}],[\"animatedwidgetbasestate<animatedpadding>\",{\"1\":{\"152\":2}}],[\"animatedwidgetbasestate<tweenanimationbuilder<t>>\",{\"1\":{\"153\":1}}],[\"animatedwidgetbasestate<t\",{\"1\":{\"152\":1}}],[\"animatedwidgetbasestate\",{\"1\":{\"147\":1,\"152\":2,\"153\":1}}],[\"animatedwidget\",{\"0\":{\"154\":1},\"1\":{\"146\":4,\"147\":1,\"154\":6,\"155\":5,\"156\":6,\"157\":5}}],[\"animatedfoo\",{\"1\":{\"146\":3,\"147\":1,\"152\":1,\"153\":1,\"156\":2,\"157\":3}}],[\"animatedvalue\",{\"1\":{\"63\":1}}],[\"anim\",{\"1\":{\"63\":1,\"400\":1}}],[\"anonymous\",{\"1\":{\"281\":1}}],[\"anobj1\",{\"1\":{\"281\":2}}],[\"anobj\",{\"1\":{\"281\":17}}],[\"another\",{\"1\":{\"147\":2,\"176\":1,\"241\":1,\"373\":3,\"391\":1}}],[\"anchor\",{\"1\":{\"228\":2}}],[\"ancestorcontext\",{\"1\":{\"177\":1}}],[\"ancestor\",{\"1\":{\"127\":6}}],[\"ancestorrenderobjectelement是renderobjecttowidgetelement\",{\"1\":{\"122\":1}}],[\"ancestorrenderobjectelement和parentdataelement都为null\",{\"1\":{\"121\":1}}],[\"ancestorrenderobjectelement\",{\"1\":{\"117\":1,\"121\":3,\"122\":2,\"127\":3}}],[\"anerroroccurred\",{\"1\":{\"209\":1}}],[\"angle\",{\"1\":{\"155\":1,\"156\":1}}],[\"anti\",{\"1\":{\"63\":1}}],[\"answer\",{\"1\":{\"58\":1,\"243\":1}}],[\"anzhi\",{\"1\":{\"54\":1}}],[\"annotationutils\",{\"1\":{\"301\":1}}],[\"annotation类型\",{\"1\":{\"299\":1}}],[\"annotationretention\",{\"1\":{\"86\":1}}],[\"annotations\",{\"1\":{\"86\":1}}],[\"annotation\",{\"1\":{\"36\":1,\"86\":2,\"298\":1,\"301\":1}}],[\"any>\",{\"1\":{\"322\":2}}],[\"anymore\",{\"1\":{\"193\":1}}],[\"any这两个处理future集合的方法外\",{\"1\":{\"102\":1}}],[\"any<t>\",{\"1\":{\"102\":1}}],[\"any\",{\"1\":{\"34\":1,\"58\":1,\"59\":1,\"98\":1,\"101\":4,\"102\":2,\"108\":1,\"115\":1,\"136\":1,\"147\":1,\"180\":1,\"211\":2,\"226\":2,\"243\":1,\"277\":1,\"280\":1,\"281\":2,\"304\":1,\"322\":6,\"376\":2,\"383\":2,\"387\":1,\"389\":2,\"391\":3,\"395\":1,\"396\":2,\"402\":1}}],[\"an\",{\"1\":{\"13\":3,\"40\":2,\"45\":1,\"58\":2,\"75\":1,\"80\":2,\"92\":1,\"102\":2,\"108\":1,\"111\":4,\"112\":1,\"114\":1,\"115\":2,\"120\":1,\"136\":1,\"147\":12,\"154\":8,\"156\":1,\"158\":1,\"160\":1,\"180\":2,\"183\":2,\"188\":8,\"195\":1,\"196\":1,\"198\":1,\"202\":1,\"213\":1,\"220\":3,\"272\":3,\"275\":2,\"281\":2,\"287\":1,\"309\":1,\"314\":1,\"322\":2,\"369\":1,\"372\":3,\"378\":5,\"383\":2,\"387\":1,\"389\":3,\"391\":4}}],[\"android之android\",{\"1\":{\"427\":1}}],[\"android之序列化详解\",{\"1\":{\"316\":1}}],[\"android逆向之旅\",{\"1\":{\"421\":1,\"427\":1}}],[\"android可以再添加这个依赖\",{\"1\":{\"322\":1}}],[\"android平台特有\",{\"1\":{\"303\":1}}],[\"android应用开发这方面比较火的是butter\",{\"1\":{\"298\":1}}],[\"android线程管理之threadlocal理解及应用场景\",{\"1\":{\"288\":1}}],[\"android内存优化\",{\"1\":{\"287\":1}}],[\"android机型\",{\"1\":{\"226\":1}}],[\"android的实现在runtime\",{\"1\":{\"389\":1}}],[\"android的intent有两个主要作用\",{\"1\":{\"135\":1}}],[\"android的activity默认在ui线程调用了looper的prepare\",{\"1\":{\"26\":1}}],[\"android篇\",{\"1\":{\"94\":1}}],[\"androidinjection\",{\"1\":{\"93\":1,\"94\":1}}],[\"androidinjectionmodule\",{\"1\":{\"89\":1}}],[\"androidinjector<activity>\",{\"1\":{\"92\":1}}],[\"androidinjector<mainactivity>\",{\"1\":{\"90\":1}}],[\"androidinjector\",{\"1\":{\"90\":1,\"91\":1,\"92\":1,\"94\":1}}],[\"android特需\",{\"1\":{\"88\":1}}],[\"android模拟器访问电脑localhost\",{\"0\":{\"76\":1}}],[\"android阅读笔记\",{\"0\":{\"73\":1}}],[\"android插件化系列第\",{\"1\":{\"72\":1}}],[\"android通过hook启动未注册activity\",{\"0\":{\"70\":1}}],[\"android运行时权限是android6之后出现的处理权限的新方式\",{\"1\":{\"67\":1}}],[\"android运行时权限\",{\"0\":{\"67\":1}}],[\"android自定义透明背景的dialog\",{\"0\":{\"66\":1}}],[\"android自定义view时两个图形重叠部分的绘制方式\",{\"1\":{\"65\":1}}],[\"android自定义view的一些知识点\",{\"0\":{\"65\":1}}],[\"android自定义view实现联系人列表\",{\"0\":{\"64\":1}}],[\"android为我们提供了绘制二阶和三阶贝塞尔曲线的方法\",{\"1\":{\"61\":1}}],[\"android为了避免重复闹钟可能带来的性能消耗\",{\"1\":{\"3\":1}}],[\"android常用的通信方式\",{\"1\":{\"60\":1}}],[\"android笔记之贝塞尔曲线的应用\",{\"0\":{\"61\":1}}],[\"android笔记之跨进程通信\",{\"0\":{\"58\":1}}],[\"android笔记之xfermode\",{\"0\":{\"57\":1}}],[\"android=\",{\"1\":{\"56\":1,\"66\":3,\"79\":3,\"400\":1,\"401\":2,\"421\":1}}],[\"android控件组\",{\"0\":{\"56\":1}}],[\"android实现可折叠toolbar\",{\"0\":{\"55\":1}}],[\"android多渠道打包知识\",{\"0\":{\"54\":1}}],[\"androidautosize等\",{\"1\":{\"81\":1}}],[\"androidautosize\",{\"1\":{\"53\":1,\"81\":1}}],[\"android今日头条屏幕适配方案的原理梳理\",{\"0\":{\"53\":1}}],[\"android5\",{\"1\":{\"35\":1}}],[\"androidlib\",{\"1\":{\"34\":2,\"35\":7,\"36\":3}}],[\"android接口定义语言\",{\"1\":{\"32\":1}}],[\"androidminafast\",{\"1\":{\"20\":1}}],[\"androidmanifest\",{\"1\":{\"17\":1,\"54\":3,\"79\":2}}],[\"android666\",{\"1\":{\"17\":1,\"34\":2,\"35\":9,\"36\":4,\"40\":11,\"41\":1,\"54\":2,\"56\":4,\"61\":1,\"295\":2,\"421\":2,\"423\":1,\"427\":1}}],[\"androidservice相关知识\",{\"0\":{\"16\":1}}],[\"android中是否应该使用枚举\",{\"0\":{\"286\":1}}],[\"android中常用的有二阶\",{\"1\":{\"61\":1}}],[\"android中的shareduserid属性详解\",{\"1\":{\"421\":1,\"427\":1}}],[\"android中的sparearray和arraymap实现分析\",{\"0\":{\"44\":1}}],[\"android中的跨进程通信ipc主要有以下几种方式\",{\"1\":{\"58\":1}}],[\"android中的messenger源码详解\",{\"0\":{\"43\":1}}],[\"android中的坐标\",{\"1\":{\"41\":1}}],[\"android中webview使用的一些问题\",{\"0\":{\"42\":1}}],[\"android中view相关知识\",{\"0\":{\"41\":1}}],[\"android中aidl相关知识\",{\"0\":{\"40\":1}}],[\"android中aidl的使用\",{\"0\":{\"32\":1}}],[\"android中绘制文字的方法如下\",{\"1\":{\"15\":1}}],[\"android中可以用到的循环任务实现有handler\",{\"1\":{\"3\":1}}],[\"android源代码\",{\"1\":{\"13\":1}}],[\"android开发者要注意\",{\"1\":{\"294\":1}}],[\"android开发艺术探索\",{\"1\":{\"13\":2,\"39\":1,\"40\":1,\"43\":1,\"65\":1,\"80\":1}}],[\"android开发常用设置\",{\"0\":{\"1\":1}}],[\"android系统大体分为4个模块\",{\"1\":{\"60\":1}}],[\"android系统架构简介\",{\"0\":{\"60\":1}}],[\"android系统就会认为该broadcastreceiver已经完成任务了\",{\"1\":{\"59\":1}}],[\"android系统窗口管理机制\",{\"1\":{\"13\":1}}],[\"android系统的窗口机制如下图\",{\"1\":{\"13\":1}}],[\"android事件分发\",{\"0\":{\"13\":1},\"1\":{\"13\":1}}],[\"android官网\",{\"1\":{\"12\":1}}],[\"android定时任务及循环任务基础大集合\",{\"1\":{\"12\":1}}],[\"android推荐选择方案\",{\"1\":{\"3\":1}}],[\"androidxref\",{\"1\":{\"13\":1}}],[\"androidx\",{\"1\":{\"2\":2,\"81\":1,\"400\":1,\"401\":1}}],[\"android11文件分区存储在图片读写的适配\",{\"0\":{\"2\":1}}],[\"androiddev\",{\"1\":{\"1\":1}}],[\"android\",{\"0\":{\"3\":1,\"14\":1,\"15\":1,\"22\":1,\"88\":1},\"1\":{\"1\":1,\"2\":9,\"3\":2,\"9\":1,\"13\":1,\"14\":5,\"17\":6,\"20\":2,\"22\":1,\"32\":1,\"35\":7,\"36\":11,\"40\":20,\"43\":5,\"52\":1,\"53\":6,\"54\":14,\"55\":7,\"56\":9,\"57\":3,\"58\":18,\"59\":2,\"66\":24,\"70\":1,\"72\":4,\"78\":4,\"79\":34,\"81\":6,\"87\":2,\"88\":1,\"93\":1,\"108\":1,\"115\":1,\"132\":1,\"135\":1,\"136\":1,\"140\":2,\"211\":3,\"226\":1,\"282\":3,\"286\":2,\"287\":5,\"303\":2,\"313\":1,\"314\":2,\"322\":1,\"347\":2,\"348\":2,\"363\":2,\"389\":1,\"399\":1,\"400\":14,\"401\":13,\"403\":1,\"404\":2,\"408\":1,\"421\":3}}],[\"and\",{\"1\":{\"0\":1,\"3\":3,\"13\":2,\"59\":1,\"75\":2,\"101\":1,\"102\":4,\"103\":3,\"105\":1,\"106\":2,\"108\":3,\"109\":2,\"115\":4,\"118\":2,\"119\":1,\"127\":1,\"134\":1,\"136\":3,\"140\":1,\"147\":2,\"154\":2,\"155\":1,\"156\":1,\"179\":1,\"180\":5,\"184\":1,\"188\":1,\"213\":1,\"216\":2,\"225\":2,\"274\":1,\"275\":3,\"276\":1,\"277\":1,\"278\":1,\"279\":2,\"280\":1,\"283\":1,\"287\":1,\"295\":3,\"302\":3,\"305\":1,\"306\":1,\"307\":1,\"326\":1,\"327\":4,\"328\":1,\"372\":4,\"376\":1,\"378\":5,\"382\":1,\"383\":1,\"386\":1,\"387\":4,\"389\":2,\"391\":2,\"392\":2,\"394\":1,\"396\":4,\"417\":1,\"426\":1}}],[\"atransient=\",{\"1\":{\"308\":2,\"309\":2}}],[\"atransient\",{\"1\":{\"308\":2}}],[\"atestclsobj\",{\"1\":{\"295\":5}}],[\"atestclsobj=\",{\"1\":{\"295\":1}}],[\"atestclass\",{\"1\":{\"295\":5}}],[\"ationcontext\",{\"1\":{\"211\":1}}],[\"atomicinteger\",{\"1\":{\"334\":1}}],[\"atomically\",{\"1\":{\"108\":1}}],[\"atop\",{\"1\":{\"57\":2}}],[\"attempted\",{\"1\":{\"281\":1}}],[\"attempts\",{\"1\":{\"126\":1}}],[\"attempting\",{\"1\":{\"111\":1}}],[\"attributeset\",{\"1\":{\"56\":1,\"64\":2}}],[\"attrs\",{\"1\":{\"56\":4,\"64\":5}}],[\"attr\",{\"1\":{\"56\":1,\"115\":10}}],[\"attaches\",{\"1\":{\"396\":1}}],[\"attached\",{\"1\":{\"237\":2}}],[\"attachnotificationtree\",{\"1\":{\"121\":1}}],[\"attachrenderobject方法将\",{\"1\":{\"127\":1}}],[\"attachrenderobject\",{\"1\":{\"121\":2,\"127\":2}}],[\"attachrootwidget步骤中通过一系列操作\",{\"1\":{\"125\":1}}],[\"attachrootwidget方法中给renderobjecttowidgetadapter作为child参数传入的rootwidget\",{\"1\":{\"121\":1}}],[\"attachrootwidget\",{\"1\":{\"119\":1}}],[\"attachtorendertree\",{\"0\":{\"121\":1},\"1\":{\"119\":1,\"121\":1}}],[\"attachinterface\",{\"1\":{\"40\":1,\"58\":1}}],[\"attach\",{\"1\":{\"40\":1,\"58\":1,\"120\":1,\"216\":2,\"217\":1,\"237\":2}}],[\"attachbasecontext\",{\"1\":{\"14\":2}}],[\"at\",{\"1\":{\"10\":1,\"15\":1,\"40\":1,\"45\":1,\"49\":1,\"58\":1,\"59\":1,\"65\":3,\"75\":1,\"80\":2,\"106\":1,\"108\":1,\"109\":1,\"112\":1,\"115\":2,\"117\":1,\"131\":1,\"147\":1,\"165\":1,\"179\":1,\"180\":1,\"181\":1,\"198\":1,\"209\":1,\"216\":1,\"242\":1,\"272\":1,\"302\":1,\"327\":6,\"389\":2,\"391\":3,\"396\":1,\"397\":1,\"414\":1}}],[\"asflow\",{\"1\":{\"327\":3,\"336\":2}}],[\"ascontextelement\",{\"1\":{\"325\":2}}],[\"ascenter\",{\"1\":{\"15\":1}}],[\"ascent\",{\"1\":{\"15\":6}}],[\"asiterable\",{\"1\":{\"321\":1}}],[\"asinleton\",{\"1\":{\"294\":4}}],[\"asingletonfactory\",{\"1\":{\"294\":1}}],[\"asingleton\",{\"1\":{\"294\":26}}],[\"asinterface\",{\"1\":{\"35\":1,\"40\":1,\"43\":2,\"58\":4}}],[\"asampleactivity\",{\"1\":{\"301\":1}}],[\"asapicobject\",{\"1\":{\"115\":1}}],[\"as有了初始化的值\",{\"1\":{\"294\":1}}],[\"ask\",{\"1\":{\"243\":1}}],[\"asboxconstraints\",{\"1\":{\"213\":1}}],[\"asbinder\",{\"1\":{\"36\":2,\"40\":2,\"58\":2}}],[\"asdrawable\",{\"1\":{\"211\":1}}],[\"ast\",{\"1\":{\"392\":1,\"395\":2}}],[\"asts\",{\"1\":{\"392\":2}}],[\"astypedlist\",{\"1\":{\"211\":1}}],[\"astatelesswidget\",{\"1\":{\"134\":2}}],[\"aspect\",{\"1\":{\"129\":1,\"153\":1}}],[\"assumptions\",{\"1\":{\"396\":1}}],[\"assumes\",{\"1\":{\"225\":1}}],[\"assumed\",{\"1\":{\"105\":1}}],[\"associated\",{\"1\":{\"288\":1,\"383\":1}}],[\"asset等\",{\"1\":{\"198\":1,\"211\":1}}],[\"assetbundleimageprovider\",{\"1\":{\"196\":1}}],[\"assetbundle\",{\"1\":{\"188\":1}}],[\"asset\",{\"1\":{\"137\":1,\"188\":1,\"200\":1,\"211\":2}}],[\"assets\",{\"1\":{\"137\":2}}],[\"assets或者其他本地资源\",{\"1\":{\"137\":1}}],[\"assetmanager\",{\"1\":{\"137\":1,\"427\":6}}],[\"asserts\",{\"1\":{\"384\":1}}],[\"assert\",{\"1\":{\"100\":1,\"103\":2,\"106\":1,\"108\":2,\"109\":2,\"111\":1,\"112\":2,\"115\":18,\"116\":1,\"118\":2,\"121\":3,\"125\":1,\"126\":2,\"127\":2,\"153\":2,\"154\":1,\"155\":1,\"156\":2,\"158\":1,\"162\":2,\"163\":1,\"167\":1,\"176\":3,\"177\":1,\"180\":2,\"181\":6,\"185\":2,\"186\":2,\"190\":1,\"201\":1,\"202\":1,\"211\":2,\"213\":2,\"220\":1,\"221\":1,\"225\":1,\"226\":2,\"228\":1,\"230\":3,\"237\":1,\"238\":3,\"239\":1,\"240\":1,\"380\":1,\"381\":1,\"382\":1,\"383\":8,\"386\":1,\"387\":3,\"389\":8,\"390\":2,\"391\":15}}],[\"assignment\",{\"1\":{\"281\":1,\"396\":1}}],[\"assigned\",{\"1\":{\"121\":1,\"281\":1}}],[\"assignowner\",{\"1\":{\"121\":2}}],[\"assign\",{\"1\":{\"115\":1,\"121\":1,\"317\":1}}],[\"assignable\",{\"1\":{\"103\":1}}],[\"asyncdispatched\",{\"1\":{\"111\":4}}],[\"asynccompleteerror`\",{\"1\":{\"102\":1}}],[\"asynccallbackentry\",{\"1\":{\"97\":3}}],[\"asynccallback\",{\"1\":{\"97\":1}}],[\"asyncrun\",{\"0\":{\"99\":1},\"1\":{\"97\":1,\"98\":3,\"99\":3,\"100\":1}}],[\"async\",{\"1\":{\"95\":1,\"96\":3,\"97\":1,\"98\":2,\"100\":2,\"102\":1,\"103\":2,\"104\":1,\"105\":4,\"111\":2,\"135\":1,\"136\":2,\"145\":1,\"196\":1,\"201\":2,\"209\":1,\"210\":2,\"211\":4,\"325\":1,\"329\":2,\"378\":2}}],[\"asynchronously\",{\"1\":{\"101\":2,\"103\":1,\"216\":2,\"327\":1}}],[\"asynchronous\",{\"1\":{\"80\":1}}],[\"asynctask的finish\",{\"1\":{\"80\":1}}],[\"asynctask的execute\",{\"1\":{\"80\":1}}],[\"asynctaskresult<progress>\",{\"1\":{\"80\":1}}],[\"asynctaskresult<\",{\"1\":{\"80\":2}}],[\"asynctask<params\",{\"1\":{\"80\":2}}],[\"asynctask\",{\"1\":{\"80\":4}}],[\"asynctask对象必须在主线程\",{\"1\":{\"80\":1}}],[\"asynctask有一下限制\",{\"1\":{\"80\":1}}],[\"asynctask常用方法\",{\"1\":{\"80\":1}}],[\"asynctask本质是线程池和handler的包装类\",{\"1\":{\"80\":1}}],[\"asynctask是android中多线程处理方式之一\",{\"1\":{\"80\":1}}],[\"asynctask源码解析\",{\"0\":{\"80\":1}}],[\"as\",{\"1\":{\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"63\":1,\"81\":1,\"97\":2,\"100\":1,\"101\":2,\"102\":2,\"103\":1,\"105\":1,\"109\":2,\"115\":4,\"119\":1,\"121\":3,\"126\":2,\"127\":5,\"131\":2,\"136\":1,\"150\":1,\"152\":2,\"153\":2,\"155\":1,\"158\":1,\"176\":1,\"180\":1,\"183\":1,\"184\":6,\"193\":1,\"196\":1,\"198\":1,\"201\":2,\"205\":2,\"211\":2,\"242\":2,\"277\":1,\"294\":16,\"322\":1,\"328\":1,\"370\":1,\"373\":1,\"378\":2,\"383\":3,\"391\":1,\"396\":2,\"417\":2,\"422\":1}}],[\"al\",{\"1\":{\"361\":1}}],[\"alhd\",{\"1\":{\"350\":1}}],[\"alternatives\",{\"1\":{\"348\":2}}],[\"always\",{\"1\":{\"389\":1}}],[\"alwaysstoppedanimation\",{\"1\":{\"159\":1}}],[\"alwaysrebuildwidgetstate\",{\"1\":{\"130\":2}}],[\"alwaysrebuildwidget\",{\"1\":{\"130\":3}}],[\"along=100\",{\"1\":{\"308\":1,\"309\":2}}],[\"along=\",{\"1\":{\"308\":1,\"311\":1}}],[\"along\",{\"1\":{\"131\":1,\"308\":3,\"309\":1,\"311\":4}}],[\"also\",{\"1\":{\"102\":2,\"103\":1,\"220\":1,\"322\":1,\"387\":1,\"391\":1,\"392\":2}}],[\"already\",{\"1\":{\"80\":2,\"103\":1,\"108\":2,\"112\":1,\"115\":2,\"121\":1,\"155\":1,\"176\":1,\"179\":1,\"220\":2,\"382\":1}}],[\"alreadydispatchedtonewtouchtarget\",{\"1\":{\"13\":1}}],[\"alertdialog\",{\"1\":{\"69\":2}}],[\"alibaba\",{\"1\":{\"203\":1,\"211\":2}}],[\"alive\",{\"1\":{\"80\":1,\"180\":1}}],[\"alias\",{\"1\":{\"63\":1,\"359\":3}}],[\"aligned后\",{\"1\":{\"282\":1}}],[\"aligntransition\",{\"1\":{\"154\":1}}],[\"align其实是一个singlechildrenderobjectwidget\",{\"1\":{\"122\":1}}],[\"alignment等属性变化时自动渐变到新值的动画效果\",{\"1\":{\"156\":1}}],[\"alignment\",{\"0\":{\"123\":2},\"1\":{\"117\":4,\"122\":10,\"123\":1,\"124\":2,\"125\":3,\"155\":6,\"170\":6,\"193\":2,\"206\":4,\"207\":2,\"241\":4,\"242\":4}}],[\"align\",{\"1\":{\"15\":1,\"64\":1,\"122\":3,\"147\":1,\"154\":1,\"170\":2}}],[\"aliyun\",{\"1\":{\"1\":1}}],[\"alarm\",{\"1\":{\"10\":2,\"11\":1,\"12\":1}}],[\"alarmintent\",{\"1\":{\"5\":1,\"10\":2,\"11\":2}}],[\"alarmmgr\",{\"1\":{\"5\":1,\"10\":2,\"11\":2}}],[\"alarmmanager可以确保任务在指定时间\",{\"1\":{\"3\":1}}],[\"alarmmanager\",{\"1\":{\"3\":1,\"5\":1,\"6\":1,\"8\":1,\"10\":3,\"11\":2,\"12\":3}}],[\"alarmmanager设置重复任务\",{\"0\":{\"3\":1}}],[\"allheroesfor方法获取到当前页和目标页面的\",{\"1\":{\"181\":1}}],[\"allheroesfor\",{\"1\":{\"175\":2,\"180\":2}}],[\"alloconlystackzone\",{\"1\":{\"115\":1}}],[\"allocation\",{\"1\":{\"282\":1}}],[\"allocateport\",{\"1\":{\"115\":2}}],[\"allocate\",{\"1\":{\"102\":1,\"116\":1}}],[\"allocated\",{\"1\":{\"102\":1,\"112\":1,\"383\":1,\"396\":1}}],[\"allocarrays\",{\"1\":{\"52\":2}}],[\"allowable\",{\"1\":{\"391\":1}}],[\"allow\",{\"1\":{\"220\":1,\"391\":7}}],[\"allowed\",{\"1\":{\"131\":1}}],[\"allows\",{\"1\":{\"105\":1,\"295\":1,\"391\":1}}],[\"allowcorethreadtimeout\",{\"1\":{\"80\":1}}],[\"all\",{\"1\":{\"2\":1,\"13\":1,\"14\":1,\"54\":1,\"57\":1,\"65\":1,\"97\":1,\"108\":1,\"109\":1,\"112\":1,\"136\":1,\"140\":1,\"143\":1,\"180\":1,\"209\":1,\"282\":2,\"298\":1,\"302\":1,\"306\":1,\"371\":1,\"372\":1,\"387\":1,\"389\":1,\"391\":2,\"396\":1}}],[\"apt\",{\"1\":{\"347\":1}}],[\"aparcelable\",{\"1\":{\"314\":3}}],[\"apk动态加载机制的研究\",{\"1\":{\"427\":1}}],[\"apkpath\",{\"1\":{\"425\":2,\"426\":1,\"427\":1}}],[\"apk\",{\"1\":{\"54\":2,\"56\":2,\"66\":3,\"79\":3,\"400\":2,\"401\":4,\"421\":1,\"425\":1}}],[\"appdatabase\",{\"1\":{\"399\":1}}],[\"appjit\",{\"1\":{\"392\":1,\"396\":3}}],[\"apparently\",{\"1\":{\"387\":1}}],[\"approaches\",{\"1\":{\"322\":1}}],[\"appropriate\",{\"1\":{\"105\":1}}],[\"appclassloader的父加载器是extclassloader\",{\"1\":{\"272\":1}}],[\"appclassloader和extclassloader都继承自urlclassloader\",{\"1\":{\"272\":1}}],[\"appcolor在notifyclients的时候修改了noname的child之一colorfulcontainer为dirty\",{\"1\":{\"130\":1}}],[\"appcolor在updatechild的时候会判断widget\",{\"1\":{\"130\":1}}],[\"appcolor的\",{\"1\":{\"130\":1}}],[\"appcolor\",{\"1\":{\"130\":29}}],[\"appcompatactivity\",{\"1\":{\"93\":1}}],[\"appcomponent中\",{\"1\":{\"91\":1}}],[\"appcomponent的范围是整个应用程序都有效\",{\"1\":{\"89\":1}}],[\"appcomponent\",{\"1\":{\"89\":1}}],[\"app内存暴增\",{\"1\":{\"198\":1}}],[\"app内部的density已经被改成了2\",{\"1\":{\"53\":1}}],[\"app内部要读取其内容的话\",{\"1\":{\"2\":1}}],[\"apps\",{\"1\":{\"140\":1,\"396\":1,\"400\":1}}],[\"app的界面有我的花园\",{\"1\":{\"399\":1}}],[\"app的界面\",{\"1\":{\"132\":1}}],[\"app的main\",{\"1\":{\"132\":1}}],[\"app的结构示意\",{\"1\":{\"127\":1}}],[\"app的renderobject\",{\"1\":{\"122\":1}}],[\"app中的\",{\"1\":{\"122\":1}}],[\"app中所有的代码都在一个isolate中运行\",{\"1\":{\"95\":1}}],[\"app基于dart语言编写\",{\"1\":{\"117\":1}}],[\"app绘制过程简析\",{\"0\":{\"117\":1}}],[\"appwidgetids\",{\"1\":{\"79\":7}}],[\"appwidgetmanager\",{\"1\":{\"79\":4}}],[\"appwidgetprovider\",{\"1\":{\"79\":2}}],[\"appwidget\",{\"1\":{\"79\":26}}],[\"appwidget的使用之pendingintent\",{\"0\":{\"79\":1}}],[\"app之间\",{\"1\":{\"60\":1}}],[\"app层\",{\"1\":{\"60\":1}}],[\"app=\",{\"1\":{\"56\":1,\"400\":1,\"401\":2}}],[\"appbar\",{\"1\":{\"55\":3,\"132\":2,\"143\":2}}],[\"appbarlayout$scrollingviewbehavior\",{\"1\":{\"55\":1}}],[\"appbarlayout>\",{\"1\":{\"55\":2}}],[\"appbarlayout类\",{\"1\":{\"55\":1}}],[\"appbarlayout\",{\"1\":{\"55\":1}}],[\"appname\",{\"1\":{\"54\":1}}],[\"appinfo\",{\"1\":{\"54\":3}}],[\"appkey\",{\"1\":{\"54\":1}}],[\"appendparams\",{\"1\":{\"364\":1}}],[\"append\",{\"1\":{\"48\":1,\"111\":1,\"115\":2,\"296\":1,\"370\":2,\"371\":2,\"390\":2,\"453\":4}}],[\"applewebkit\",{\"1\":{\"370\":1}}],[\"apples\",{\"1\":{\"293\":4}}],[\"apple>\",{\"1\":{\"293\":1}}],[\"apple\",{\"1\":{\"291\":3,\"292\":1,\"293\":1}}],[\"applic\",{\"1\":{\"211\":1}}],[\"applicationinfo\",{\"1\":{\"422\":1}}],[\"applicationid\",{\"1\":{\"54\":3}}],[\"application的jit热身时间\",{\"1\":{\"396\":1}}],[\"application范围内的\",{\"0\":{\"89\":1}}],[\"applications\",{\"1\":{\"75\":1,\"396\":1}}],[\"application使用hookapplication\",{\"1\":{\"71\":1}}],[\"application\",{\"1\":{\"71\":1,\"81\":1,\"89\":1,\"92\":1,\"130\":1,\"387\":1,\"396\":2,\"426\":2}}],[\"application中的meta\",{\"1\":{\"54\":1}}],[\"application>\",{\"1\":{\"2\":1,\"17\":1,\"54\":1,\"79\":1}}],[\"applicable\",{\"1\":{\"13\":1}}],[\"applibrary\",{\"1\":{\"41\":1,\"61\":1}}],[\"applycontentdimensions\",{\"1\":{\"238\":1}}],[\"applyclampedpointersignalupdate\",{\"0\":{\"222\":1},\"1\":{\"222\":1}}],[\"applyclampeddragupdate无法消耗\",{\"1\":{\"226\":1}}],[\"applyclampeddragupdate不会主动从0变为负值\",{\"1\":{\"226\":1}}],[\"applyclampeddragupdate\",{\"0\":{\"220\":1},\"1\":{\"220\":2,\"226\":9}}],[\"applyviewportdimension\",{\"1\":{\"238\":1}}],[\"applynewdimensions\",{\"0\":{\"223\":1},\"1\":{\"223\":6}}],[\"applyphysicstouseroffset\",{\"1\":{\"221\":1}}],[\"applyboundaryconditions\",{\"1\":{\"220\":1,\"221\":1}}],[\"applyfulldragupdate\",{\"0\":{\"221\":1},\"1\":{\"220\":1,\"221\":1,\"226\":4}}],[\"applyto\",{\"1\":{\"213\":2}}],[\"applyuseroffset方法\",{\"1\":{\"226\":1}}],[\"applyuseroffset\",{\"0\":{\"226\":1},\"1\":{\"212\":1,\"226\":6}}],[\"applydimension\",{\"1\":{\"53\":1}}],[\"apply\",{\"1\":{\"10\":1,\"69\":1,\"88\":1,\"147\":1,\"221\":1,\"226\":2}}],[\"app\",{\"0\":{\"119\":1},\"1\":{\"2\":3,\"3\":2,\"36\":1,\"40\":1,\"52\":1,\"54\":19,\"55\":6,\"56\":2,\"60\":1,\"72\":3,\"79\":6,\"117\":4,\"135\":2,\"202\":1,\"203\":2,\"272\":2,\"382\":2,\"387\":7,\"400\":7,\"401\":4}}],[\"app不能直接通过路径访问文件\",{\"1\":{\"2\":1}}],[\"api层\",{\"1\":{\"318\":1}}],[\"api\",{\"1\":{\"2\":1,\"3\":4,\"114\":1,\"115\":6,\"116\":4,\"127\":1,\"168\":4,\"186\":5,\"188\":1,\"198\":1,\"226\":1,\"233\":1,\"242\":1,\"295\":1,\"302\":2,\"381\":2,\"382\":1,\"383\":10,\"386\":3,\"388\":5,\"389\":2}}],[\"a\",{\"0\":{\"245\":1},\"1\":{\"0\":2,\"3\":2,\"36\":1,\"40\":1,\"49\":3,\"54\":1,\"58\":1,\"62\":2,\"74\":1,\"75\":2,\"78\":3,\"80\":5,\"95\":1,\"97\":2,\"98\":1,\"101\":1,\"102\":7,\"103\":4,\"105\":2,\"106\":9,\"107\":2,\"108\":7,\"109\":1,\"111\":4,\"112\":3,\"114\":3,\"115\":14,\"118\":1,\"120\":2,\"122\":1,\"126\":1,\"131\":3,\"132\":1,\"133\":2,\"134\":1,\"136\":1,\"147\":4,\"154\":5,\"158\":1,\"160\":1,\"171\":11,\"173\":2,\"174\":2,\"176\":1,\"177\":1,\"179\":3,\"180\":8,\"181\":3,\"183\":1,\"184\":2,\"185\":1,\"188\":5,\"192\":1,\"193\":2,\"194\":2,\"198\":2,\"209\":3,\"212\":1,\"213\":3,\"216\":2,\"225\":5,\"227\":1,\"230\":3,\"233\":1,\"234\":2,\"241\":1,\"242\":2,\"265\":2,\"274\":3,\"275\":2,\"276\":1,\"277\":1,\"278\":2,\"279\":1,\"281\":2,\"282\":1,\"286\":1,\"287\":2,\"289\":2,\"297\":2,\"302\":5,\"308\":6,\"309\":2,\"314\":1,\"321\":1,\"322\":11,\"327\":8,\"328\":5,\"344\":2,\"346\":1,\"350\":1,\"369\":2,\"371\":1,\"378\":2,\"379\":1,\"383\":7,\"384\":2,\"386\":1,\"387\":4,\"389\":4,\"390\":2,\"391\":6,\"392\":1,\"396\":1,\"417\":1,\"426\":2,\"450\":1,\"459\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
